# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: TODO

* バグ

- [ ] 次の式で val をセット出来ない。
      let! val = func() {
         val = 1;
      };
- [ ] Mapping を implement するクラスは、 abstract/interface のメンバは持てないようにする
  
- [ ] 互換性のない値で switch - case が書けてしまう。
  
- [ ] リストのリテラルで、継承関係のある値を混在させた時に、
      共通のスーパークラスのリストにならない。
       
       [ Super, Sub ] としたとき、 List<Super> となるべきだが、 List<stem> になる。  
  

- [ ] 型パラメータを持つクラスの proto 宣言が出来ない。
  
- [ ] 文字列中の . を編集すると company-mode がエラーする
  
* エラー  

- [ ] lua51 へのトランスコンパイラで、 %s の値が多値返却の変換はできないのでエラーにする。
- [ ] provide しているファイルで __test はエラーにする。
  
* 機能


- [ ] let list:List<Super> = [ Sub ]; が出来ない。
      List<Super> <- List<Sub> の代入になり、
      Mutable なリストは型パラメータ完全一致でなければならないため。

- [ ] stem を Mapping 可能としているが、本来は不使用にすべき。
      現状 MacroMetaInfo.tokenList で stem を使用しているため、
      これをタプルに切り替え、 stem の Mapping は Warning にする。
  
- [ ] 公開 macro の中から、自分のモジュール内の関数をコールするとき、
      モジュール名は import の as で決定するので指定ができない。

- [ ] formatter の作成

  
- [ ] advertise でメソッドを追加する時に、
      アクセス制御を pri, pro で作成できるようにする。
  
- [ ] if! の elseif を作る  

- [ ] Array, List の get(index) 対応。
      戻り値を nilable として、範囲外にアクセスした場合に nil を返す。
  
  
- [ ] match でパラメータのない alge は、一つの case に複数指定できるようにする。
  
- [ ] マクロの実引数の stat 内で補完が効くように対応する。
  
- [ ] accessMode に Low を追加。
    Low は、クラス内でも特別なメソッドからのみアクセスを許可する。

    - Low を作るくらいなら、別クラスを作ってカプセル化すべきか？
    - でも別クラスを作ると、それだけオーバーヘッドがかかる。
    
  
- [ ] スタブを対応する。  

- [ ] A and B or C の結果の型をまともに判定できるように対応する。
     今は and or の形の場合を特別に扱っている。
     その為にも stem の TypeInfoKind を、専用にして処理を変更する。
  
- [ ] override 禁止を追加する
  
- [ ] 独立したスコープを宣言できるようにする
  
- [ ] 一部のシンボルが別シンボル扱いになってしまっている。
      C のクロージャの管理が怪しい。
     - when!
     - foreach 
       
     - [ ] if! 等の _exp などの自動変数をクロージャで使った場合も対応できるか確認。
       出来なければコンパイルエラーとする

  
- [ ] 内部関数から、クロージャで ... にアクセスできる。
  
 
- [ ] foreach などで、 繰り返しの要因になっているオブジェクトは imut にする。
  
  
- [ ] トップスコープにないクラスの static メンバのライフタイムが Lua と C で異なる。
  
- [ ] alge 型のパラメータの名前が無いと、分かりにくい。
  
- [ ] 多値返却の時、コンパイラの引数の評価順序によって、処理を変更する必要がある。

 
  
- [ ] let list = [ new Hoge() ]; の c-lang へ変換が出来ない

  
- [ ] 次が出来てしまう。
  
abstract class Super {
   pub abstract fn func(): str;
}
class Sub1 extend Super {
   pub override fn func(): str {
      return __func__;
   }
}
class Sub2 extend Super {
   pub override fn func(): str {
      return __func__;
   }
}
fn func( list:List<Super> ) {
   list.insert( new Sub2() );
}
let mut list:List<Sub1> = [];
func( list ); // List<Sub1> に Sub2 のインスタンスが入ってしまう。。。
foreach obj in list {
   print( obj.func() );
}

  
  
- [ ] form<T> を対応する。 これは fn (...<T>) : ...<T> のシンタックスシュガー

- [ ] 関数コールに引数を与えるときに、仮引数名を必須とするオプションを追加する。
      bool などは true/false では意味が分からない。
  
- [ ] set, enum, alge の nil 条件演算子対応。
- [ ] for 内で let の初期化するとエラー。
      let 宣言時の初期化ではなく、宣言後の初期化。
      mut 宣言している変数だとエラーにならない。
  
- [ ] forsort で、 map をソートした場合、キーが int/real/str 以外だと実行時エラーする。
      コンパイルエラーにする。
 
- [ ] forsort の compare をカスタマイズ可能にする。
- [ ] builtinクラスを LuneScript のクラスで定義できるようにする。
- [ ] class の trust サポート

- [ ] Nodes.MacroValInfo の値の alge 化。
- [ ] accessor の override 指定
  
- [ ] Sub クラスが Super クラスのメンバを shadowing したときエラー検知できていない。
- [ ] インスタンスから、クラス名などのメタ情報を取得できるようにする。
- [ ] Generics の @@@ 対応。
  
- [ ] switch - case で、同じ case が複数存在してもエラーにならない

     
- [ ] Alge の Generics 対応。
- [ ] Nilable 型対応。
      - nilable の値を管理するクラス。 Nilable<int> で int! を保持する。
      - Nilable の import 対応。
      - Nilable の Mapping 対応
      - Nilable の Nilaccess 対応
- [ ] nilable 型から Nilable への auto boxing.
      - 引数
      - alge 引数
      - 変数代入
      - return
- [ ] Generics のクラスの getTxt() のタイプが T になる。
      本来は Set<int> になるべきところが、 Set<T> になる。
  
- [ ] inner 関数を定義した時、意図せずに外部のシンボルにアクセスしてしまうことがある。
      外部シンボルにアクセスできないようなブロックを宣言可能にする。
- [ ] meta ファイルがあると、 meta が古くても以前の meta の情報を使用して補完している。
- [ ] interface を継承した interface の制限をまとめる
- [ ] switch の式化  
- [ ] enum 値を追加した時、その enum 側を利用している switch などを
      簡単にチェックできる機能を追加する。
- [ ] 同名のメソッドを持つメンバを複数 advertise したときの動作が未定義。
- [ ] json 型を追加する。 json 型は Map のサブセットで、
      key,value に設定可能な型を制限する。 json 型を mapping する jmapping を追加。
- [ ] if! let の else で、  nilable の値にアクセス出来るようにする。
- [ ] 引数を 2 つの型に限定することが出来ない。
      例えば int、str どちらかに限定できない。現状だと stem になってしまう。
- [ ] interface にメソッドの処理を書けるようにする。
- [ ] super クラスと interface で同名で異なる型のメソッドを定義しているときに
      エラーにならない。
- [ ] switch に使用している値にアクセスできるように (_exp)
- [ ] string 系の組込みメソッド拡充。
- [ ] 配列の繰り返し要素指定定義。
- [ ] SymbolInfo の canBeLeft と mutable の扱いを整理する。
      本来は、 canBeLeft は変数自体の書き換えで、mutable はオブジェクトの操作。
      mutable は、 expTypeInfo の mutable で制御すべき。
- [ ] 空文、空のブロック文の時に、 Lua のバージョンによっては nop を入れる。
- [ ] ローカル変数が 200 を越えると Lua 実行時エラーになるので、ガードをかける。
      - import
      - enum
      - class
      - macro
      - func
      - var
- [ ] 後置 ! の対応。 unwrap のシンタックスシュガー。 ただし unwrap の default はなし。
- [ ] 同じ名前を global 宣言しているモジュールをインポートすると、 
      prototype 宣言の型チェック処理が動いてしまう。

      
- [ ] 関数呼び出しの シンタックスシュガー対応
- [ ] 関数呼び出しの引数名指定
- [ ] マクロを別 TransUnit で処理。
      - [ ] マクロ内での import。
- [ ] トランスコード時、関数の型(引数、戻り値)をコメントで出力する
- [ ] enum への変換 _from() で、アンマッチ時のデフォルト値を持つ関数を追加。
- [ ] class 内 class, enum サポート。
- [ ] コメントを Lua コードに出力
- [ ] テストコードのサポート。テストコードでは pri のデータにもアクセス可能とする。
- [ ] front.lns の lua, save, glue 毎の関数化
- [ ] when のブロック内でシンボルを補完すると、 nilable と 非 nilable の両方が出る。

*  C へのトランスコード

- [ ] 相互参照すると開放されない
  
#+BEGIN_SRC lns
let mut val:Map<int,stem> = {};
let mut val2:Map<int,stem> = { 0:val };
val[ 0 ] = val2;
class Test {
   let mut val:stem! {non,pub};
}
let mut test = new Test( nil );
test.set_val( test );
#+END_SRC
  
- [ ] メソッド内でのクロージャアクセスに対応できていない。
      コンパイルエラーになる。

#+BEGIN_SRC lns
let test;
{
   let work = 1;
   class Test {
      pub fn func() {
         print( work );
      }
   }
   test = new Test();
}
test.func();
#+END_SRC

- [ ] anonymous 関数から、クロージャをコールするとコンパイルエラー

#+BEGIN_SRC lns
let func2:form;
{
   let val = 1;
   fn func( work:int ) {
      print( work + val );
   }
   func2 = fn () {
      func( 10 );
   };
}
func2(##);
#+END_SRC
  
  
- [ ] Scope.accessSymbol() で、 Arg, Var のみ処理しているが、
      Func も処理対象にする。ただし、 Closure でない関数は除外。
      Func の ExpRef ノードを保持しておき、 
      AST ノード解析後に改めて Closure の検出を行なう。
      AST 解析後でないと Closure かどうかを正確に判断できない。
  
- [ ] チュートリアル
   - [X] value.org
   - [X] set.org
   - [X] variable.org     
   - [X] func.org
   - [X] arg.org
   - [X] multipleRetVal.org
   - [X] defaultArg.org
   - [X] nilable.org
   - [X] branch.org
   - [X] cast.org
   - [X] class1.org
   - [X] class2accessor.org
   - [X] classAdvertise.org
   - [X] classInherit.org
   - [X] classMapping.org
   - [X] classOverride.org
   - [-] crosscompile.org
   - [X] enum.org
   - [X] generics.org
   - [-] import.org
   - [X] interface.org
   - [X] loop.org
   - [-] macro.org
   - [X] match.org
   - [ ] nilcond.org
   - [ ] recommend.org
   - [ ] require.org
   - [ ] test.org

  


- [ ] セルフホスティング
   - [X] Ver
   - [X] LuaMod
   - [X] LuneControl
   - [ ] Meta
   - [X] Testing
   - [X] Code
   - [ ] Log
   - [X] LuaVer
   - [X] Depend
   - [X] Util
   - [ ] frontInterface
   - [X] Writer
   - [X] Parser
   - [ ] Ast
   - [ ] Option
   - [ ] Nodes
   - [ ] Formatter
   - [ ] dumpNode
   - [ ] Macro
   - [ ] TransUnit
   - [ ] convLua
   - [ ] convCC
   - [ ] OutputDepend
   - [ ] TestCtrl
   - [ ] front
   - [ ] glueFilter
  

   
- [ ] block の stem 変数は、 lune_stem_t ではなく lune_stem_t * で管理すべき。
      大域ジャンプに対応できない。
  
- [ ] 次の処理が変換に失敗する
  fn func( val:int ) {
    let list = [ val, val ];
  }
  
   

- [ ] processToIF() の処理を関数コール処理に入れる。

- [ ] when! や if! などで定義したシンボルをクロージャで使用する場合の対応。

- [ ] any のメンバに確保に使用した allocateor を保持させ、
      gc の処理で free する際にそれを使用する。

 
- [ ] C モジュールのコール。 C からのコール。
- [ ] スレッド
- [ ] 排他が必要な変数の宣言と、排他ブロック宣言。
- [ ] lns のビルドツールを作成する。
      ビルドツールによって .meta ファイル等の出力に排他制御をいれて、
      マルチスレッドで処理できるようにする。

- [X] メソッド内の関数定義が多重に定義される

- [X] クロージャと普通の関数とで、関数の型を変える。
      今は普通の関数にも form 引数が付いているが、これを削除する。

- [X] 
     let map:stem!, err = func();

     上記のソースを C に落すと次になる。
     
      lune_setQ( map_130, lune_fromDDD( lune_call_form( _pEnv, func_129.val.pAny, lune_global.ddd0 ).val.pAny, 0 ) );
      lune_setQ( err_131, lune_fromDDD( lune_call_form( _pEnv, func_129.val.pAny, lune_global.ddd0 ).val.pAny, 1 ) );
     
     func() の戻り値が ... で、複数扱いになっていない。


      

     
** 高速化

- [ ] 単純な ExRef からのメソッド呼び出しでも call ラッパを使用しているが、
      ダイレクトでコールする方が効率が良い。
      
- [ ] 比較演算の結果が stem になっている。

      if ( val1 > val2 ) {
      }

      上記が次のようになる

      if ( lns_isCondTrue( LNS_STEM_BOOL( val1 > val2 ) ) {
      }

   
- [ ] メソッド内で、 self にアクセスしていない場合、
      self のオブジェクトを宣言しない。


- [X] stem と any の分離
  - [X] collection を stem で扱う。
  - [X] int 系の closure を any で扱っているが、これを val にして、
        val に stem を保持する。
  - [X] nil を any で扱っているが、これを stem で扱うにする。
  - [X] any から int 系を削除する。
  - [X] enum の値のオブジェクトをグローバルで宣言しない。
        いまは any で扱っているため、毎回インスタンス生成しないように 、
	グローバルで生成しているが、 any で扱わなくて大丈夫なので、変更する。
        
- [X] stem,any,prim の使いわけ
     - [X] bool を stem ではなく prim に変更。
      
      
   
- [ ] block で stemNum, varNum が  0 のものは、 enter/leave 処理を入れない。
      ただし、block 内で new している場合や、戻り値がプリミティブ以外のものがある場合、
      enter/leave 処理を入れないと開放タイミングが遅れる。
      この辺りを調整する方法を考える。

- [ ] if 文の条件で lune_isCondTrue() を使用しているが、
      式の評価結果が nilable でなければ不要。
  
- [ ] lune_stem_t の alloc 処理を高速化。
      - lune_stem_t の pNext, pPrev を利用して空きリストを作成して、
	そこから alloc する。
	最初は単純にバッファからの先頭から順に確保し、
	最後まで確保し終ったら空きリストから取得する。

- [ ] lune_func2stem が汎用化のため可変長引数を使っているが、
      可変長引数はオーバーヘッドが重い。
      それぞれ専用関数を作って処理する。

- [ ] immediate 文字列は、毎度生成するのではなく、
      static に生成しておいてそれを返す。

- [ ] collection の int とそれ以外(real は stem 等と同じ)を分ける。 

- [X] for 等の loop ブロックは、
      lune_enter_block(), lune_leave_block() 処理をブロック内ではなく、
      ブロック外にする。
      ブロック内の先頭で lune_reset_block() を実行する。
- [X] 戻り値が 1 つの int の関数でも stem 型を返している。

   

* emacs
- [ ] emacs のカーソル位置にあるシンボルの型確認
- [ ] 行末が文字列、コメントだと、emacs のインデント調整がおかしい
- [ ] org-mode で lns コードを実行できるようにする

- [X] anonymous 関数を引数にした場合、その次の引数のインデント位置がおかしい
- [X] emacs のインデントで行末に無駄なスペースが入る
- [X] company-mode で run-at-time のリトライ処理が走る時、
      バッファが変っているとエラー。


* 制限・仕様

- pri の同名関数を sub class 側で定義できてしまう。
  - これが出来ないと、super クラスの中身まで sub class 側で知っておく必要があり、
    カプセル化と矛盾する。

- List, Map, Array の kind を Class にはしない。
  - Class にしてしまうと、 Generics の特殊処理が上手くいかない。

- 関数内の関数で __func__ を使用した場合、モジュール名が __func__ に付かない。
  mod.func.inner にならずに func.inner になる。

- 宣言した変数を代入だけして使用していない場合、警告する。引数は除外。
  これは対応しない。
  なぜなら多値の戻り値を格納した場合、全ての変数を利用するとは限らないため。

* テストコード

- [ ] Map オブジェクトに [] でインデックスアクセスする時に、
      キーの型チェックが出来ていない。
     .sym でシンボルアクセスするときのチェックも出来ていない。
- [ ] 依存ソース一覧(subfile,import)を出力する機能を追加する。
- [X] 外部のモジュールで宣言された、コンストラクタを持つ class を extend 
- [X] 間接 import したモジュール内の enum の omit アクセス
- [X] 引数が enum の nilable だった場合、補完が効かない。
- [X] enum 値のシンボル名が文字列等のシンボル以外でも定義できてしまう。
- [X] pub 宣言している変数の型の Map のキーが、 pub 宣言していないとエラー検知しない。
- [X] meta 情報の削減
- [X] メソッドの prototype 宣言と、実際の定義が違う時に、型チェックしていない。
- [X] interface を implement しているときに、 関数の引数チェックしていない。
- [X] enum の nilable から $_txt すると、型が str でなく get__txt 型になっている
- [X] proto 宣言と、実際の宣言時で abstruct の違いがエラーにならない。
- [X] ループ外で break を実行してもエラーしない。
- [X] static メソッドから self が参照できる。
- [X] abstruct な Super クラスが実装していないメソッドを、
      サブクラスが実装していない場合にエラーが出ない。
- [X] interface を extend している abstruct クラスで、
      メソッドを実装しないとエラーになる。
- [X] 'pro' のメソッドが外部モジュールで override できない。
- [X] 'pro' のメソッドが外部モジュールで call できない。
- [X] Mapping の処理がクラス宣言後なので、
      クラス宣言内部から _toMap() 等が利用できない。
- [X] コンストラクタで __func__ を使うと nil になる。
- [X] method から form へのキャストが出来てしまう。  
- [X] Map のキーが enum だった場合、補完が利かない。
- [X] let val:List<Hoge>! のとき、 val$[1] のアクセス結果が Hoge になっている。
      本来は Hoge! であるべき。
- [X] Mapping で、メンバの型が Class の nilable だった場合、 _fromMap に失敗する。
- [X] super の引数チェック
- [X] prototype 宣言しかしていないメソッドを持つクラスのエラー出力対応。
- [X] abstruct が typo。 実際は abstract。
- [X] 関数のないところで return できてしまう。
- [X] enum 型名 == enum 値 ができてしまう。
- [X] 複数値を返す関数呼び出しを () で括った場合、本来は値が一つになるはずが、複数のまま。
- [X] 外部モジュールで error している関数を呼んだ場合、 getBreakKind() が Error にならない
- [X] 戻り値を持つ関数の、return 有無を確認するフロー解析
- [X] macro 内の変数に mut を設定しても上書きが無視される。
- [X] macro 内の `{} がエラーになる。
- [X] form を pub 宣言した型名を、外部からその型名でアクセスできない。
- [X] while true {} のループ内の for 文などから return した場合、 return なしになる。
- [X] 同じ型の関数を複数宣言してもエラーにならない。
- [X] 外部モジュールで宣言した form を、引数にもつ __init を pub にするとエラー。
- [X] 外部モジュールで宣言した super class のメンバに代入できない。 immutable 扱いになる。
- [X] 外部モジュールの pro メソッドが、 pub として登録されている。
- [X] コンストラクタで super を呼んでいなくてもエラーにならない。
- [X] 自動コンストラクタが super のコンストラクタを実行していない。
- [X] form の戻り値が nilable だと、戻り値なしの関数をセットできてしまう。  
- [X] abstract を override したメソッドから super() が呼べてしまう。
- [X] 自分自身を import すると処理が返ってこない。
- [X] if で、条件不成立にならない式を書けてしまう。
    if "" { }  等。
- [X] apply of で列挙される型が stem になってしまっている。
- [X] -u で lua を作ると、 lua のコメントの先頭に挿入されるパスが ./ が付いてしまう
- [X] 型名単体が r-value になっている。
- [X] table.unpack を list, array のメソッドに変更する
- [X] 戻り値を持たない関数の結果を、変数に代入できてしまう。
- [X] import 処理で lns ソースを解析する際、TypeId の IdProvider が同じものなので、
      TypeId の整合性が取れないことがある。
      import 時の typeId のリセット
- [X] __func__ が nil になることがある。
- [X] マクロ以外のシンボル名の先頭に _ を使っている場合のチェック
- [X] lua5.1 の対応
      - [X] package.searchpath() が 5.1 はない。
- [X] import のモジュールがない時に TransUnit を続けられるようにする。
      - TransUnit の解析は続けないが、強制エラー終了しないように修正。
- [X] macro を pub に出来るように。
- [X] map の型宣言で、 value の型宣言しなくてもエラーにならない。 
      Map<int> ができてしまう。
- [X] import のフォーマットバージョンチェック
- [X] ... を最終要素以外にも定義できてしまう。
- [X] Map のキー指定にタイプ名を指定できてしまう。
      hoge[ str ] = nil; 的な。
- [X] 次のような enum 表記が出来てしまう。
      enum HOGE {
         Val1,
         Val2,
      }
      HOGE.Val1.Val1 <--- これ
- [X] lnsc でコンパイル指定した lns ファイルがないと、 .lua, .meta.tmp ファイルが残る。
- [X] List.sort, Array.sort を対応する。
- [X] meta ファイルの更新を必要な時だけ行なう。
      meta に影響のないモジュール内部実装を変えただけの場合に、 
      meta を更新してしまうと、 それを import しているモジュールも更新対象になってしまう。
- [X] "%d" に対する引数がオーバ時にエラーしない。
- [X] "%q" は lua5.3 でも文字列以外は指定できない。
- [X] 関数、メソッドでない場所で __func__ が使えてしまう。  
- [X] unwrap default の型チェックが出来ていない。
      例えば次のようなことが出来てしまう。
      let val:str! = "abc";
      print( (unwrap val default 1) + 10 );
- [X] import しているシンボルを、自分のモジュールのシンボルとして公開する。
      モジュールの相互参照で切り出したときに、変更を最小にする。
      alias な感じ。
- [X] @@= は、メンバを持たないクラスのみに有効。  
- [X] static でないメソッドが r-value になっている。
- [X] unwrap と @@@ とで、 unwrap の方が優先順位が高い。 本来は逆。
- [X] stem からキャストする際に動的にタイプチェックし、
      マッチしていない場合は nil を返す @@@ 演算子を追加する。
- [X] 内部関数内では 初期値なし immutable のアクセスはエラーとする。
- [X] 変数の値保持制御で return 等の flow 解析を行なう。
- [X] 繰り返し文内で immutable な変数を書き換えられてしまう。
- [X] setter の mut 制御が出来ていない？ immutable なインスタンスでも set できる。
- [X] form 型の変数に関数オブジェクトを代入した時に、
      関数の引数が参照型から、非参照型を指定してもエラーにならない。
- [X] let! のブロックがフロー解析対象になっていない。
- [X] クラス定義の中でマクロが使えない。
      メソッド定義をマクロ化出来ない。
- [X] デフォルトコンストラクタを持つクラスを継承したときに、
      コンストラクタを宣言せずにクラスを作成可能にする
- [X] __init ブロック内で、プロトタイプ宣言している static メソッドを使うと nil エラー。
- [X] 定義済みの class を再度定義できてしまう。
- [X] 初期化していない型宣言もしていない変数に、 Imut な値をセットするとエラー
- [X] override メソッドの型一致チェックできていない。
- [X] nil 条件演算子 $ から getter アクセス $ すると、本来の nil 条件演算子制御が出来ない。
- [X] tonumber() の戻り値は real!
- [X] Make 時に _lune モジールのバージョン更新チェックを行なう
  
- [X] enum 値補完の時に enum の _from() などのメソッドまで表示されてしまう。  
- [X] let の初期値で enum が補完できない。
- [X] 次が実行時エラーする
  
class Test {
   let val:int;
}
class Sub extend Test {
}
- [X] 次のケースがエラーになる。
fn func( val:int! ) {
   foreach item in [1,2] {
      let! castType = val {
         castType = item; // error
      };
   }
}
- [X] 次の場合、要素の型が確定していない List を型推論で代入エラーにすべき
   let val;
   val = [];
- [X] import したモジュール内で宣言されたクラスの interface のメソッドにアクセスできなかった。
- [X] import を先頭以外にも出来るようにしたため、
      convLua.lns の self.typeInfo2ModuleName は、スコープと同じで階層化が必要。
- [X] let val:List<int>!;  
      val or [] が List<int> にならない。 List<int>!;  になってしまう。
- [X] 型指定アクセッサのアクセス制御判定が意図した動作になっていない。
  pub let val:Sub {pub:Super}; のこのとき、 
  Sub は pub でなくても Super が pub なら OK のはずが、 
  Sub が pub にないとエラーになってしまう。
- [X] override の時、 interface メドッドの mut の一致を確認してない？
- [X] fn ():int { return 1; } (); が実行時エラーする。
- [X] pub fn () {} が出来てしまう。 anonymous 関数は、本来 pub は出来ない。
- [X] nilable でないのに val$.$work が指定できる。
- [X] 関数引数のクロージャ。
      引数に対して lune_initVal_stem() する。
- [X] foreach 等のループ変数のクロージャ。
      ループ変数に対して lune_initVal_stem() する。
- [X] 意味のない箇所を () で括れてしまう。 
- [X] 本来、次は Pub でない Hoge を含んだ func が pub なので、エラーになるはず。
  
class Hoge {
}
pub fn func( list:&List<Hoge> );
      
- [X] 初期化していないメンバーがあるのにエラーにならない。
- [X] マクロの引数が足りない時にエラーにならない  
- [#] 次のエラーが検知できない。
form test();

test(); // test は form の型名なので、コールできないから本来はコンパイルエラー。
- [X] 次の時、 val の shadowing が検知できない
let val;

fn func() {
   let mut val;
}
- [X] タイプ名を指定するところに、変数名を指定できる。
let val = 1;
let list:List<val> = [];
  



  
  

  
- [ ] macro に与えられたリテラルな List/Array/Map/Set を、そのまま展開して変数に格納する。
- [ ] import すると、モジュールのシンボルがスコープに追加される。
      このシンボルが変数などと被ると使いづらい。
- [ ] モジュールパス名をシンボル名に使えない。
      例えば test/hoge.lns 内で、 test をシンボル名として使えない。
- [ ] import を先頭以外に書けるようにする。
- [ ] 全 Nodes を辿る処理を Nodes に追加。 
      Node を定義する際の macro で対応できるように。
- [ ] 関数内クラス、クラス内クラスに対応する。
     現状は関数内でクラス宣言できるが、
     メソッド宣言をクラス宣言外部で行なった場合などのケアが出来ていない。
- [ ] lune_set_block_var のタイミングで var の確保を行なう。
  
      

* ドキュメント

- [ ] -u オプション
- [ ] import as 対応
- [ ] __func__, __line__, __mod__ のサポート
- [X] form の型宣言
- [ ] メソッドの super
- [X] set 対応
- [ ] alias 対応  
- [X] when! の対応
     指定されたシンボルを unwrap して、ブロック内では unwrap 後の型として扱う。
- [X] map 型からの Class 生成(fromMap)、 Class からの map 生成 (toMap)
- [X] Lua 5.2 で bit 演算子を利用した場合、 bit モジュールを利用するように変換する
- [X] module 宣言したモジュールの glue コード自動生成
- [X] enum の全要素リストを取れるようにする。
- [X] bool 値との比較演算
- [X] クラス宣言のメソッド内から、自分自身のクラスを new できない。 
      メソッドの分離定義すると new できる。
      デフォルトコンストラクタを使用することを宣言できるようにする。
- [X] getter を省略して setter だけ生成できるように
- [X] "%s" (val) の %s と val の対応チェック
      - [X] lua5.1 の場合、 %s の val は tostring() する。
- [X] 型固定の可変長引数対応
- [X] 多値を返す関数を、意図せずに多値として扱ってしまう。
      例えば list.insert( func() ) で func() が int, int を返す場合、
      本来は list 末尾に値を挿入したいのに、
      末尾でない場所に格納されてしまい意図しない結果になる。
      ※ 要検討
      代入先が省略可能で、代入元が多値の第二引数以降なら warning を出す。
- [X] 独自クラスの generics 対応
- [X] Generics クラスの Mapping 対応
- [X] alge 型を enum 型のような省略表記が出来ない。
- [X] サブデータを持たない alge 型を == で比較できるようにする。
- [X] let で初期値を入れずに済むフロー解析
- [X] let!  等の nil ブロックのフロー解析。
- [X] nilable からキャストできない。
- [X] 次が出来てしまう。 
  test1(nil), test1( "abc" ) が出来てしまうのは NG。 
  
  test1() に stem! と相互変換できない引数を持つ関数は代入できてはダメ。
  fn (val:int) {} の引数は stem! との相互変換はできないので、本来は代入できてはダメ。

   form Test( ... );
   fn func( test1:Test ) {
      test1( nil );
   }

   func( fn (val:int) {
      print( val + 1 );
   } );
- [X] グローバルな _lune を使用しているが、これを -r オプションの場合はローカルにする。
      また、モジュールのパスを変更できるようにする。
      これは、モジュールを生成した LuneScript のバージョンが異なる場合に、
      正常動作するように対応するため。

- [ ] 値を扱えるマクロを定義できるようにする。

- [ ] int/real/str プリミティブ型の @@@ 対応。
- [ ] コンストラクタからメソッドをコールする場合、
      全メンバをセットしてから。
- [ ] getter で、メンバの super クラスの型で返したい。
       
  

* ビルド制御変更

#+BEGIN_SRC txt
mod1.meta: mod1.lns mod2.meta
#+END_SRC

上記依存関係の時、次のいずれかの条件が成立する時に meta ファイルを更新する。

- 更新時間が mod1.lns > mod1.meta
- 更新時間が mod2.meta > mod1.meta かつ、
  mod2.meta 内の ID が、 mod1.meta 内に保持している mod2.meta の ID と異なる。
  
meta ファイル内に、ビルド時の lns ファイルの更新時間と、ビルド回数から ID を生成する。

  ID = "%d.%d" (lnsファイルの更新時間, ビルド回数)

ここでビルド回数は、対象 lns ファイルを何回ビルドしたかを示す数で、
meta ファイル内に記録し、ビルド毎にインクリメントする。
lns ファイルに対応する meta ファイルがない場合は 1 とする。



mod2.meta: mod2.lns

     
      
  
  

* advent

- [X] 紹介
- [X] setup
- [X] hello world
- [X] 値
- [X] enum
- [X] 変数
- [X] 分岐
- [X] foreach 等の loop
- [X] 関数, form
- [X] nilable, unwrap, map
- [X] クロスコンパイル  
- [X] クラス 基本
- [X] クラス accessor
- [X] クラス 継承
- [X] クラス advertise
- [X] クラス override, super, abstract
- [X] alge  
- [X] インタフェース
- [X] mapping
- [X] nil 条件演算子
- [X] import, provide
- [X] require, module
- [X] macro
- [X] make
- [X] LuneScript を作ってみての感想
      - こんな機能が欲しかった
	- accessor の自動生成
        - advertise 
      - コーディングルールの強制
	- python のインデント
	- bool の比較
      - 近年の言語の調査

- [ ] subfile
- [ ] glue
