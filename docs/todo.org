# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: TODO

* 機能

ビルドの条件

#+BEGIN_SRC txt
mod1.meta: mod1.lns mod2.meta
#+END_SRC

上記依存関係の時、次のいずれかの条件が成立する時に meta ファイルを更新する。

- 更新時間が mod1.lns > mod1.meta
- 更新時間が mod2.meta > mod1.meta かつ、
  mod2.meta 内の ID が、 mod1.meta 内に保持している mod2.meta の ID と異なる。
  
meta ファイル内に、ビルド時の lns ファイルの更新時間と、ビルド回数から ID を生成する。

  ID = "lnsファイルの更新時間"."ビルド回数"



mod2.meta: mod2.lns

- [ ] switch の式化  
- [ ] __init ブロック内で、プロトタイプ宣言している static メソッドを使うと nil エラー。
- [ ] enum 値を追加した時、その enum 側を利用している switch などを簡単にチェックできる機能を追加する。
- [ ] autocomplete で、処理中に次を処理して重くなる。
- [ ] 同名のメソッドを持つメンバを複数 advertise したときの動作が未定義。
- [ ] meta ファイルの更新を必要な時だけ行なう。
      meta に影響のないモジュール内部実装を変えただけの場合に、 
      meta を更新してしまうと、 それを import しているモジュールも更新対象になってしまう。
- [ ] json 型を追加する。 json 型は Map のサブセットで、
      key,value に設定可能な型を制限する。 json 型を mapping する jmapping を追加。
- [ ] let! のブロックがフロー解析対象になっていない。
- [ ] if! let の else で、  nilable の値にアクセス出来るようにする。
- [ ] 型固定の可変長引数対応
- [ ] 引数を 2 つの型に限定することが出来ない。
      例えば int、str どちらかに限定できない。現状だと stem になってしまう。
- [ ] import を先頭以外に書けるようにする。
- [ ] インスタンスから、クラス名などのメタ情報を取得できるようにする。
- [ ] interface にメソッドの処理を書けるようにする。
- [ ] super クラスと interface で同名で異なる型のメソッドを定義しているときにエラーにならない。
- [ ] switch に使用している値にアクセスできるように (_exp)
- [ ] import しているシンボルを、自分のモジュールのシンボルとして公開する。
      モジュールの相互参照で切り出したときに、変更を最小にする。
      alias な感じ。
- [ ] string 系の組込みメソッド拡充。
- [ ] form 型の変数に関数オブジェクトを代入した時に、
      関数の引数が参照型から、非参照型を指定してもエラーにならない。
- [ ] 配列の繰り返し要素指定定義。
- [ ] SymbolInfo の canBeLeft と mutable の扱いを整理する。
      本来は、 canBeLeft は変数自体の書き換えで、mutable はオブジェクトの操作。
      mutable は、 expTypeInfo の mutable で制御すべき。
- [ ] 空文、空のブロック文の時に、 Lua のバージョンによっては nop を入れる。
- [ ] ローカル変数が 200 を越えると Lua 実行時エラーになるので、ガードをかける。
      - import
      - enum
      - class
      - macro
      - func
      - var
- [ ] 後置 ! の対応。 unwrap のシンタックスシュガー。 ただし unwrap の default はなし。
- [ ] stem からキャストする際に動的にタイプチェックし、
      マッチしていない場合は nil を返す @@@ 演算子を追加する。

- [ ] 同じ名前を global 宣言しているモジュールをインポートすると、 
      prototype 宣言の型チェック処理が動いてしまう。
- [ ] Set を対応する

      
- [ ] List, Map, Array の kind を Class にする。

- [ ] List オブジェクトの insert() 等の補完が効かない。
- [ ] メソッドの form 対応
- [ ] デフォルトコンストラクタを持つクラスを継承したときに、
      コンストラクタを宣言せずにクラスを作成可能にする
- [ ] 関数呼び出しの シンタックスシュガー対応
- [ ] 関数呼び出しの引数名指定
- [ ] マクロを別 TransUnit で処理。
      - [ ] マクロ内での import。
- [ ] トランスコード時、関数の型(引数、戻り値)をコメントで出力する
- [ ] enum への変換 _from() で、アンマッチ時のデフォルト値を持つ関数を追加。
- [ ] class 内 class, enum サポート。
- [ ] class の trust サポート
- [ ] コメントを Lua コードに出力
- [ ] テストコードのサポート。テストコードでは pri のデータにもアクセス可能とする。
- [ ] 行末が文字列、コメントだと、emacs のインデント調整がおかしい
- [ ] emacs のインデントで行末に無駄なスペースが入る
- [ ] front.lns の lua, save, glue 毎の関数化
- [ ] emacs のカーソル位置にあるシンボルの型確認
- [ ] let で初期値を入れずに済むフロー解析
- [ ] let!  等の nil ブロックのフロー解析。
- [ ] 独自クラスの generics 対応


- [ ] when のブロック内でシンボルを補完すると、 nilable と 非 nilable の両方が出る。

- [ ] C へのトランスコード

* 制限・仕様

- pri の同名関数を sub class 側で定義できてしまう。
  - これが出来ないと、super クラスの中身まで sub class 側で知っておく必要があり、
    カプセル化と矛盾する。
  

* テストコード

- [ ] 依存ソース一覧(subfile,import)を出力する機能を追加する。
- [X] 外部のモジュールで宣言された、コンストラクタを持つ class を extend 
- [X] 間接 import したモジュール内の enum の omit アクセス
- [X] 引数が enum の nilable だった場合、補完が効かない。
- [X] enum 値のシンボル名が文字列等のシンボル以外でも定義できてしまう。
- [X] pub 宣言している変数の型の Map のキーが、 pub 宣言していないとエラー検知しない。
- [X] meta 情報の削減
- [X] メソッドの prototype 宣言と、実際の定義が違う時に、型チェックしていない。
- [X] interface を implement しているときに、 関数の引数チェックしていない。
- [X] enum の nilable から $_txt すると、型が str でなく get__txt 型になっている
- [X] proto 宣言と、実際の宣言時で abstruct の違いがエラーにならない。
- [X] ループ外で break を実行してもエラーしない。
- [X] static メソッドから self が参照できる。
- [X] abstruct な Super クラスが実装していないメソッドを、
      サブクラスが実装していない場合にエラーが出ない。
- [X] interface を extend している abstruct クラスで、
      メソッドを実装しないとエラーになる。
- [X] 'pro' のメソッドが外部モジュールで override できない。
- [X] 'pro' のメソッドが外部モジュールで call できない。
- [X] Mapping の処理がクラス宣言後なので、
      クラス宣言内部から _toMap() 等が利用できない。
- [X] コンストラクタで __func__ を使うと nil になる。
- [X] method から form へのキャストが出来てしまう。  
- [X] Map のキーが enum だった場合、補完が利かない。
- [X] let val:List<Hoge>! のとき、 val$[1] のアクセス結果が Hoge になっている。
      本来は Hoge! であるべき。
- [X] Mapping で、メンバの型が Class の nilable だった場合、 _fromMap に失敗する。
- [X] super の引数チェック
- [X] prototype 宣言しかしていないメソッドを持つクラスのエラー出力対応。
- [X] abstruct が typo。 実際は abstract。
- [X] 関数のないところで return できてしまう。
- [X] enum 型名 == enum 値 ができてしまう。
- [X] 複数値を返す関数呼び出しを () で括った場合、本来は値が一つになるはずが、複数のまま。
- [X] 外部モジュールで error している関数を呼んだ場合、 getBreakKind() が Error にならない
- [X] 戻り値を持つ関数の、return 有無を確認するフロー解析
- [X] macro 内の変数に mut を設定しても上書きが無視される。
- [X] macro 内の `{} がエラーになる。
- [X] form を pub 宣言した型名を、外部からその型名でアクセスできない。
- [X] while true {} のループ内の for 文などから return した場合、 return なしになる。
- [X] 同じ型の関数を複数宣言してもエラーにならない。
- [X] 外部モジュールで宣言した form を、引数にもつ __init を pub にするとエラー。
- [X] 外部モジュールで宣言した super class のメンバに代入できない。 immutable 扱いになる。
- [X] 外部モジュールの pro メソッドが、 pub として登録されている。
- [X] コンストラクタで super を呼んでいなくてもエラーにならない。
- [X] 自動コンストラクタが super のコンストラクタを実行していない。
- [X] form の戻り値が nilable だと、戻り値なしの関数をセットできてしまう。  
- [X] abstract を override したメソッドから super() が呼べてしまう。
- [X] 自分自身を import すると処理が返ってこない。
- [X] if で、条件不成立にならない式を書けてしまう。
    if "" { }  等。
- [X] apply of で列挙される型が stem になってしまっている。
- [X] -u で lua を作ると、 lua のコメントの先頭に挿入されるパスが ./ が付いてしまう
- [X] 型名単体が rvalue になっている。
- [X] table.unpack を list, array のメソッドに変更する
- [X] 戻り値を持たない関数の結果を、変数に代入できてしまう。
- [X] import 処理で lns ソースを解析する際、TypeId の IdProvider が同じものなので、
      TypeId の整合性が取れないことがある。
      import 時の typeId のリセット
- [X] __func__ が nil になることがある。
- [X] マクロ以外のシンボル名の先頭に _ を使っている場合のチェック
- [X] lua5.1 の対応
      - [X] package.searchpath() が 5.1 はない。
- [X] import のモジュールがない時に TransUnit を続けられるようにする。
      - TransUnit の解析は続けないが、強制エラー終了しないように修正。
- [X] macro を pub に出来るように。
- [X] map の型宣言で、 value の型宣言しなくてもエラーにならない。 Map<int> ができてしまう。
- [X] import のフォーマットバージョンチェック

* ドキュメント

- [ ] -u オプション
- [ ] import as 対応
- [ ] __func__, __line__, __mod__ のサポート
- [ ] form の型宣言
- [ ] メソッドの super
- [X] when! の対応
     指定されたシンボルを unwrap して、ブロック内では unwrap 後の型として扱う。
- [X] map 型からの Class 生成(fromMap)、 Class からの map 生成 (toMap)
- [X] Lua 5.2 で bit 演算子を利用した場合、 bit モジュールを利用するように変換する
- [X] module 宣言したモジュールの glue コード自動生成
- [X] enum の全要素リストを取れるようにする。
- [X] bool 値との比較演算
- [X] クラス宣言のメソッド内から、自分自身のクラスを new できない。 
      メソッドの分離定義すると new できる。
      デフォルトコンストラクタを使用することを宣言できるようにする。
- [X] getter を省略して setter だけ生成できるように
- [X] "%s" (val) の %s と val の対応チェック
      - [X] lua5.1 の場合、 %s の val は tostring() する。
   
     
      
  
  

* advent

- [X] 紹介
- [X] setup
- [X] hello world
- [X] 値
- [X] enum
- [X] 変数
- [X] 分岐
- [X] foreach 等の loop
- [X] 関数, form
- [X] nilable, unwrap, map
- [X] クロスコンパイル  
- [X] クラス 基本
- [X] クラス accessor
- [X] クラス 継承
- [X] クラス advertise
- [X] クラス override, super, abstract
- [X] alge  
- [X] インタフェース
- [X] mapping
- [X] nil 条件演算子
- [X] import, provide
- [X] require, module
- [X] macro
- [X] make

- [ ] LuneScript を作ってみての感想
      - こんな機能が欲しかった
	- accessor の自動生成
        - advertise 
      - コーディングルールの強制
	- python のインデント
	- bool の比較
      - 近年の言語の調査

- [ ] subfile
- [ ] glue
