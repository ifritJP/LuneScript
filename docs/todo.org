# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: TODO

* 機能

- [ ] switch に使用している値にアクセスできるように (_exp)
- [ ] pri の同名関数を sub class 側で定義できてしまう。
- [ ] import しているシンボルを、自分のモジュールのシンボルとして公開する。
      モジュールの相互参照で切り出したときに、変更を最小にする。
- [ ] macro を pub に出来るように。
- [ ] string 系の組込みメソッド拡充。
- [ ] form 型の変数に関数オブジェクトを代入した時に、
      関数の引数が参照型から、非参照型を指定してもエラーにならない。
- [ ] 型固定の可変長引数対応
- [ ] lua5.1 の対応
- [ ] SymbolInfo の canBeLeft と mutable の扱いを整理する。
      本来は、 canBeLeft は変数自体の書き換えで、mutable はオブジェクトの操作。
      mutable は、 expTypeInfo の mutable で制御すべき。
- [ ] 空文、空のブロック文の時に、 Lua のバージョンによっては nop を入れる。
- [ ] ローカル変数が 200 を越えると Lua 実行時エラーになるので、ガードをかける。
      - import
      - enum
      - class
      - macro
      - func
      - var
- [ ] 後置 ! の対応。 unwrap のシンタックスシュガー。 ただし unwrap の default はなし。
- [ ] Class にキャストする際、メタメソッドを持たないテーブルはエラーとする。
- [ ] stem からキャストする際に動的にタイプチェックし、
      マッチしていない場合は nil を返す @@@ 演算子を追加する。

- [ ] 同じ名前を global 宣言しているモジュールをインポートすると、 
      prototype 宣言の型チェック処理が動いてしまう。
- [ ] Set を対応する

- [ ] import 処理で lns ソースを解析する際、TypeId の IdProvider が同じものなので、
      TypeId の整合性が取れないことがある。
      import 時の typeId のリセット
      
- [ ] List, Map, Array の kind を Class にする。

- [ ] List オブジェクトの insert() 等の補完が効かない。
- [ ] import のフォーマットバージョンチェック
- [ ] メソッドの form 対応
- [ ] デフォルトコンストラクタを持つクラスを継承したときに、
      コンストラクタを宣言せずにクラスを作成可能にする
- [ ] 関数呼び出しの シンタックスシュガー対応
- [ ] 関数呼び出しの引数名指定
- [ ] マクロを別 TransUnit で処理。
      - [ ] マクロ内での import。
- [ ] トランスコード時、関数の型(引数、戻り値)をコメントで出力する
- [ ] enum への変換 _from() で、アンマッチ時のデフォルト値を持つ関数を追加。
- [ ] class 内 class, enum サポート。
- [ ] class の trust サポート
- [ ] コメントを Lua コードに出力
- [ ] テストコードのサポート。テストコードでは pri のデータにもアクセス可能とする。
- [ ] 行末が文字列、コメントだと、emacs のインデント調整がおかしい
- [ ] emacs のインデントで行末に無駄なスペースが入る
- [ ] front.lns の lua, save, glue 毎の関数化
- [ ] emacs のカーソル位置にあるシンボルの型確認
- [ ] let で初期値を入れずに済むフロー解析
- [ ] "%s" (val) の %s と val の対応チェック
- [ ] import のモジュールがない時に TransUnit を続けられるようにする。
- [ ] 独自クラスの generics 対応


- [ ] when のブロック内でシンボルを補完すると、 nilable と 非 nilable の両方が出る。

- [ ] C へのトランスコード

* テストコード

- [ ] 依存ソース一覧(subfile,import)を出力する機能を追加する。
- [X] 外部のモジュールで宣言された、コンストラクタを持つ class を extend 
- [X] 間接 import したモジュール内の enum の omit アクセス
- [X] 引数が enum の nilable だった場合、補完が効かない。
- [X] enum 値のシンボル名が文字列等のシンボル以外でも定義できてしまう。
- [X] pub 宣言している変数の型の Map のキーが、 pub 宣言していないとエラー検知しない。
- [X] meta 情報の削減
- [X] メソッドの prototype 宣言と、実際の定義が違う時に、型チェックしていない。
- [X] interface を implement しているときに、 関数の引数チェックしていない。
- [X] enum の nilable から $_txt すると、型が str でなく get__txt 型になっている
- [X] proto 宣言と、実際の宣言時で abstruct の違いがエラーにならない。
- [X] ループ外で break を実行してもエラーしない。
- [X] static メソッドから self が参照できる。
- [X] abstruct な Super クラスが実装していないメソッドを、
      サブクラスが実装していない場合にエラーが出ない。
- [X] interface を extend している abstruct クラスで、
      メソッドを実装しないとエラーになる。
- [X] 'pro' のメソッドが外部モジュールで override できない。
- [X] 'pro' のメソッドが外部モジュールで call できない。
- [X] Mapping の処理がクラス宣言後なので、
      クラス宣言内部から _toMap() 等が利用できない。
- [X] コンストラクタで __func__ を使うと nil になる。
- [X] method から form へのキャストが出来てしまう。  
- [X] Map のキーが enum だった場合、補完が利かない。
- [X] let val:List<Hoge>! のとき、 val$[1] のアクセス結果が Hoge になっている。
      本来は Hoge! であるべき。
- [X] Mapping で、メンバの型が Class の nilable だった場合、 _fromMap に失敗する。
- [X] super の引数チェック
- [X] prototype 宣言しかしていないメソッドを持つクラスのエラー出力対応。
- [X] abstruct が typo。 実際は abstract。
- [X] 関数のないところで return できてしまう。
- [X] enum 型名 == enum 値 ができてしまう。
- [X] 複数値を返す関数呼び出しを () で括った場合、本来は値が一つになるはずが、複数のまま。
- [X] 外部モジュールで error している関数を呼んだ場合、 getBreakKind() が Error にならない
- [X] 戻り値を持つ関数の、return 有無を確認するフロー解析
- [X] macro 内の変数に mut を設定しても上書きが無視される。
- [X] macro 内の `{} がエラーになる。
- [X] form を pub 宣言した型名を、外部からその型名でアクセスできない。
- [X] while true {} のループ内の for 文などから return した場合、 return なしになる。
- [X] 同じ型の関数を複数宣言してもエラーにならない。
- [X] 外部モジュールで宣言した form を、引数にもつ __init を pub にするとエラー。
- [X] 外部モジュールで宣言した super class のメンバに代入できない。 immutable 扱いになる。
- [X] 外部モジュールの pro メソッドが、 pub として登録されている。
- [X] コンストラクタで super を呼んでいなくてもエラーにならない。
- [X] 自動コンストラクタが super のコンストラクタを実行していない。
- [X] form の戻り値が nilable だと、戻り値なしの関数をセットできてしまう。  
- [X] abstract を override したメソッドから super() が呼べてしまう。
- [X] 自分自身を import すると処理が返ってこない。


* ドキュメント

- [ ] import as 対応
- [ ] __func__, __line__, __mod__ のサポート
- [ ] form の型宣言
- [ ] メソッドの super
- [X] when! の対応
     指定されたシンボルを unwrap して、ブロック内では unwrap 後の型として扱う。
- [X] map 型からの Class 生成(fromMap)、 Class からの map 生成 (toMap)
- [X] Lua 5.2 で bit 演算子を利用した場合、 bit モジュールを利用するように変換する
- [X] module 宣言したモジュールの glue コード自動生成
- [X] enum の全要素リストを取れるようにする。      

* advent

- [ ] 値
- [ ] enum
- [ ] 変数
- [ ] 分岐
- [ ] foreach 等の loop
- [ ] 関数
- [ ] nilable, unwrap, map
- [ ] nil 条件演算子
- [ ] provide
- [ ] クラス 基本
- [ ] クラス accessor
- [ ] クラス 継承, abstract
- [ ] クラス override, super
- [ ] クラス advertise
- [ ] インタフェース
- [ ] mapping
- [ ] import
- [ ] require, module
- [ ] subfile
- [ ] macro
- [ ] make  

