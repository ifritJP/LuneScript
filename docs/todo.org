# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: TODO

* 機能

- [ ] Nodes.MacroValInfo の値の alge 化。
- [ ] accessor の override 指定
  
- [ ] Sub クラスが Super クラスのメンバを shadowing したときエラー検知できていない。
- [ ] インスタンスから、クラス名などのメタ情報を取得できるようにする。
- [ ] Generics の @@@ 対応。
  
- [ ] switch - case で、同じ case が複数存在してもエラーにならない
       
     
- [ ] Alge の Generics 対応。
- [ ] Nilable 型対応。
      - nilable の値を管理するクラス。 Nilable<int> で int! を保持する。
      - Nilable の import 対応。
      - Nilable の Mapping 対応
      - Nilable の Nilaccess 対応
- [ ] nilable 型から Nilable への auto boxing.
      - 引数
      - alge 引数
      - 変数代入
      - return
- [ ] Generics のクラスの getTxt() のタイプが T になる。
      本来は Set<int> になるべきところが、 Set<T> になる。
- [ ] クラス定義の中でマクロが使えない。
      メソッド定義をマクロ化出来ない。
- [ ] 宣言した変数を代入だけして使用していない場合、警告する。引数は除外。
  
- [ ] inner 関数を定義した時、意図せずに外部のシンボルにアクセスしてしまうことがある。
      外部シンボルにアクセスできないようなブロックを宣言可能にする。
- [ ] meta ファイルがあると、 meta が古くても以前の meta の情報を使用して補完している。
- [ ] interface を継承した interface の制限をまとめる
- [ ] 関数内の関数で __func__ を使用した場合、モジュール名が __func__ に付かない。
       mod.func.inner にならずに func.inner になる。
- [ ] switch の式化  
- [ ] __init ブロック内で、プロトタイプ宣言している static メソッドを使うと nil エラー。
- [ ] enum 値を追加した時、その enum 側を利用している switch などを簡単にチェックできる機能を追加する。
- [ ] 同名のメソッドを持つメンバを複数 advertise したときの動作が未定義。
- [ ] json 型を追加する。 json 型は Map のサブセットで、
      key,value に設定可能な型を制限する。 json 型を mapping する jmapping を追加。
- [ ] let! のブロックがフロー解析対象になっていない。
- [ ] if! let の else で、  nilable の値にアクセス出来るようにする。
- [ ] 引数を 2 つの型に限定することが出来ない。
      例えば int、str どちらかに限定できない。現状だと stem になってしまう。
- [ ] import を先頭以外に書けるようにする。
- [ ] interface にメソッドの処理を書けるようにする。
- [ ] super クラスと interface で同名で異なる型のメソッドを定義しているときにエラーにならない。
- [ ] switch に使用している値にアクセスできるように (_exp)
- [ ] string 系の組込みメソッド拡充。
- [ ] form 型の変数に関数オブジェクトを代入した時に、
      関数の引数が参照型から、非参照型を指定してもエラーにならない。
- [ ] 配列の繰り返し要素指定定義。
- [ ] SymbolInfo の canBeLeft と mutable の扱いを整理する。
      本来は、 canBeLeft は変数自体の書き換えで、mutable はオブジェクトの操作。
      mutable は、 expTypeInfo の mutable で制御すべき。
- [ ] 空文、空のブロック文の時に、 Lua のバージョンによっては nop を入れる。
- [ ] ローカル変数が 200 を越えると Lua 実行時エラーになるので、ガードをかける。
      - import
      - enum
      - class
      - macro
      - func
      - var
- [ ] 後置 ! の対応。 unwrap のシンタックスシュガー。 ただし unwrap の default はなし。
- [ ] 同じ名前を global 宣言しているモジュールをインポートすると、 
      prototype 宣言の型チェック処理が動いてしまう。

      
- [ ] List, Map, Array の kind を Class にする。

- [ ] メソッドの form 対応
- [ ] デフォルトコンストラクタを持つクラスを継承したときに、
      コンストラクタを宣言せずにクラスを作成可能にする
- [ ] 関数呼び出しの シンタックスシュガー対応
- [ ] 関数呼び出しの引数名指定
- [ ] マクロを別 TransUnit で処理。
      - [ ] マクロ内での import。
- [ ] トランスコード時、関数の型(引数、戻り値)をコメントで出力する
- [ ] enum への変換 _from() で、アンマッチ時のデフォルト値を持つ関数を追加。
- [ ] class 内 class, enum サポート。
- [ ] class の trust サポート
- [ ] コメントを Lua コードに出力
- [ ] テストコードのサポート。テストコードでは pri のデータにもアクセス可能とする。
- [ ] front.lns の lua, save, glue 毎の関数化
- [ ] let で初期値を入れずに済むフロー解析
- [ ] let!  等の nil ブロックのフロー解析。


- [ ] when のブロック内でシンボルを補完すると、 nilable と 非 nilable の両方が出る。

- [ ] C へのトランスコード


* emacs
- [ ] anonymous 関数を引数にした場合、その次の引数のインデント位置がおかしい
- [ ] emacs のカーソル位置にあるシンボルの型確認
- [ ] 行末が文字列、コメントだと、emacs のインデント調整がおかしい
- [ ] emacs のインデントで行末に無駄なスペースが入る



* 制限・仕様

- pri の同名関数を sub class 側で定義できてしまう。
  - これが出来ないと、super クラスの中身まで sub class 側で知っておく必要があり、
    カプセル化と矛盾する。
  

* テストコード

- [ ] 依存ソース一覧(subfile,import)を出力する機能を追加する。
- [X] 外部のモジュールで宣言された、コンストラクタを持つ class を extend 
- [X] 間接 import したモジュール内の enum の omit アクセス
- [X] 引数が enum の nilable だった場合、補完が効かない。
- [X] enum 値のシンボル名が文字列等のシンボル以外でも定義できてしまう。
- [X] pub 宣言している変数の型の Map のキーが、 pub 宣言していないとエラー検知しない。
- [X] meta 情報の削減
- [X] メソッドの prototype 宣言と、実際の定義が違う時に、型チェックしていない。
- [X] interface を implement しているときに、 関数の引数チェックしていない。
- [X] enum の nilable から $_txt すると、型が str でなく get__txt 型になっている
- [X] proto 宣言と、実際の宣言時で abstruct の違いがエラーにならない。
- [X] ループ外で break を実行してもエラーしない。
- [X] static メソッドから self が参照できる。
- [X] abstruct な Super クラスが実装していないメソッドを、
      サブクラスが実装していない場合にエラーが出ない。
- [X] interface を extend している abstruct クラスで、
      メソッドを実装しないとエラーになる。
- [X] 'pro' のメソッドが外部モジュールで override できない。
- [X] 'pro' のメソッドが外部モジュールで call できない。
- [X] Mapping の処理がクラス宣言後なので、
      クラス宣言内部から _toMap() 等が利用できない。
- [X] コンストラクタで __func__ を使うと nil になる。
- [X] method から form へのキャストが出来てしまう。  
- [X] Map のキーが enum だった場合、補完が利かない。
- [X] let val:List<Hoge>! のとき、 val$[1] のアクセス結果が Hoge になっている。
      本来は Hoge! であるべき。
- [X] Mapping で、メンバの型が Class の nilable だった場合、 _fromMap に失敗する。
- [X] super の引数チェック
- [X] prototype 宣言しかしていないメソッドを持つクラスのエラー出力対応。
- [X] abstruct が typo。 実際は abstract。
- [X] 関数のないところで return できてしまう。
- [X] enum 型名 == enum 値 ができてしまう。
- [X] 複数値を返す関数呼び出しを () で括った場合、本来は値が一つになるはずが、複数のまま。
- [X] 外部モジュールで error している関数を呼んだ場合、 getBreakKind() が Error にならない
- [X] 戻り値を持つ関数の、return 有無を確認するフロー解析
- [X] macro 内の変数に mut を設定しても上書きが無視される。
- [X] macro 内の `{} がエラーになる。
- [X] form を pub 宣言した型名を、外部からその型名でアクセスできない。
- [X] while true {} のループ内の for 文などから return した場合、 return なしになる。
- [X] 同じ型の関数を複数宣言してもエラーにならない。
- [X] 外部モジュールで宣言した form を、引数にもつ __init を pub にするとエラー。
- [X] 外部モジュールで宣言した super class のメンバに代入できない。 immutable 扱いになる。
- [X] 外部モジュールの pro メソッドが、 pub として登録されている。
- [X] コンストラクタで super を呼んでいなくてもエラーにならない。
- [X] 自動コンストラクタが super のコンストラクタを実行していない。
- [X] form の戻り値が nilable だと、戻り値なしの関数をセットできてしまう。  
- [X] abstract を override したメソッドから super() が呼べてしまう。
- [X] 自分自身を import すると処理が返ってこない。
- [X] if で、条件不成立にならない式を書けてしまう。
    if "" { }  等。
- [X] apply of で列挙される型が stem になってしまっている。
- [X] -u で lua を作ると、 lua のコメントの先頭に挿入されるパスが ./ が付いてしまう
- [X] 型名単体が r-value になっている。
- [X] table.unpack を list, array のメソッドに変更する
- [X] 戻り値を持たない関数の結果を、変数に代入できてしまう。
- [X] import 処理で lns ソースを解析する際、TypeId の IdProvider が同じものなので、
      TypeId の整合性が取れないことがある。
      import 時の typeId のリセット
- [X] __func__ が nil になることがある。
- [X] マクロ以外のシンボル名の先頭に _ を使っている場合のチェック
- [X] lua5.1 の対応
      - [X] package.searchpath() が 5.1 はない。
- [X] import のモジュールがない時に TransUnit を続けられるようにする。
      - TransUnit の解析は続けないが、強制エラー終了しないように修正。
- [X] macro を pub に出来るように。
- [X] map の型宣言で、 value の型宣言しなくてもエラーにならない。 Map<int> ができてしまう。
- [X] import のフォーマットバージョンチェック
- [X] ... を最終要素以外にも定義できてしまう。
- [X] Map のキー指定にタイプ名を指定できてしまう。
      hoge[ str ] = nil; 的な。
- [X] 次のような enum 表記が出来てしまう。
      enum HOGE {
         Val1,
         Val2,
      }
      HOGE.Val1.Val1 <--- これ
- [X] lnsc でコンパイル指定した lns ファイルがないと、 .lua, .meta.tmp ファイルが残る。
- [X] List.sort, Array.sort を対応する。
- [ ] meta ファイルの更新を必要な時だけ行なう。
      meta に影響のないモジュール内部実装を変えただけの場合に、 
      meta を更新してしまうと、 それを import しているモジュールも更新対象になってしまう。
- [ ] Map オブジェクトに [] でインデックスアクセスする時に、キーの型チェックが出来ていない。
     .sym でシンボルアクセスするときのチェックも出来ていない。
- [X] "%d" に対する引数がオーバ時にエラーしない。
- [X] "%q" は lua5.3 でも文字列以外は指定できない。
- [X] 関数、メソッドでない場所で __func__ が使えてしまう。  
- [X] unwrap default の型チェックが出来ていない。
      例えば次のようなことが出来てしまう。
      let val:str! = "abc";
      print( (unwrap val default 1) + 10 );
- [X] import しているシンボルを、自分のモジュールのシンボルとして公開する。
      モジュールの相互参照で切り出したときに、変更を最小にする。
      alias な感じ。
- [X] @@= は、メンバを持たないクラスのみに有効。  
- [X] static でないメソッドが r-value になっている。
- [X] unwrap と @@@ とで、 unwrap の方が優先順位が高い。 本来は逆。
- [X] stem からキャストする際に動的にタイプチェックし、
      マッチしていない場合は nil を返す @@@ 演算子を追加する。
  
      

* ドキュメント

- [ ] -u オプション
- [ ] import as 対応
- [ ] __func__, __line__, __mod__ のサポート
- [X] form の型宣言
- [ ] メソッドの super
- [X] set 対応
- [ ] alias 対応  
- [X] when! の対応
     指定されたシンボルを unwrap して、ブロック内では unwrap 後の型として扱う。
- [X] map 型からの Class 生成(fromMap)、 Class からの map 生成 (toMap)
- [X] Lua 5.2 で bit 演算子を利用した場合、 bit モジュールを利用するように変換する
- [X] module 宣言したモジュールの glue コード自動生成
- [X] enum の全要素リストを取れるようにする。
- [X] bool 値との比較演算
- [X] クラス宣言のメソッド内から、自分自身のクラスを new できない。 
      メソッドの分離定義すると new できる。
      デフォルトコンストラクタを使用することを宣言できるようにする。
- [X] getter を省略して setter だけ生成できるように
- [X] "%s" (val) の %s と val の対応チェック
      - [X] lua5.1 の場合、 %s の val は tostring() する。
- [X] 型固定の可変長引数対応
- [X] 多値を返す関数を、意図せずに多値として扱ってしまう。
      例えば list.insert( func() ) で func() が int, int を返す場合、
      本来は list 末尾に値を挿入したいのに、
      末尾でない場所に格納されてしまい意図しない結果になる。
      ※ 要検討
      代入先が省略可能で、代入元が多値の第二引数以降なら warning を出す。
- [X] 独自クラスの generics 対応
- [X] Generics クラスの Mapping 対応
- [X] alge 型を enum 型のような省略表記が出来ない。
- [X] サブデータを持たない alge 型を == で比較できるようにする。
       
  

* ビルド制御変更

#+BEGIN_SRC txt
mod1.meta: mod1.lns mod2.meta
#+END_SRC

上記依存関係の時、次のいずれかの条件が成立する時に meta ファイルを更新する。

- 更新時間が mod1.lns > mod1.meta
- 更新時間が mod2.meta > mod1.meta かつ、
  mod2.meta 内の ID が、 mod1.meta 内に保持している mod2.meta の ID と異なる。
  
meta ファイル内に、ビルド時の lns ファイルの更新時間と、ビルド回数から ID を生成する。

  ID = "%d.%d" (lnsファイルの更新時間, ビルド回数)

ここでビルド回数は、対象 lns ファイルを何回ビルドしたかを示す数で、
meta ファイル内に記録し、ビルド毎にインクリメントする。
lns ファイルに対応する meta ファイルがない場合は 1 とする。



mod2.meta: mod2.lns

     
      
  
  

* advent

- [X] 紹介
- [X] setup
- [X] hello world
- [X] 値
- [X] enum
- [X] 変数
- [X] 分岐
- [X] foreach 等の loop
- [X] 関数, form
- [X] nilable, unwrap, map
- [X] クロスコンパイル  
- [X] クラス 基本
- [X] クラス accessor
- [X] クラス 継承
- [X] クラス advertise
- [X] クラス override, super, abstract
- [X] alge  
- [X] インタフェース
- [X] mapping
- [X] nil 条件演算子
- [X] import, provide
- [X] require, module
- [X] macro
- [X] make
- [X] LuneScript を作ってみての感想
      - こんな機能が欲しかった
	- accessor の自動生成
        - advertise 
      - コーディングルールの強制
	- python のインデント
	- bool の比較
      - 近年の言語の調査

- [ ] subfile
- [ ] glue
