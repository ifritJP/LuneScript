# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}

[[https://github.com/ifritJP/LuneScript/actions][https://github.com/ifritJP/LuneScript/workflows/Test/badge.svg]]

#+TITLE: LuneScript

Latest document (for Japanese)

https://ifritjp.github.io/documents/lunescript/

** What is LuneScript

As mentioned above, LuneScript is a language that covers Lua's concerns, and is a transcompiler that can convert code developed with LuneScript into Lua code.

LuneScript has the following features.
- NULL safety.
- Since it is a statically typed language, simple mistakes can be found at compile time by type checking.
- Type inference minimizes the effort of type declaration.
- With generics, it is possible to process while preserving type information.
- Supports class definition as language grammar.
- Supports pattern matching. (match)
- Reduced load time due to lazy loading.
- Mutual conversion between structured and unstructured data. (Mapping)
- With macros, it is possible to realize designs that do not rely on dynamic processing such as polymorphism.
- Detects variable initialization omission
- Transcompile to Lua and go.
- Supports JSON compatible data representation.
- The transcompiled Lua code can operate independently without assuming an external library.
- The transcompiled Lua code outputs the processing written in LuneScript as it is, so there is no performance degradation.
- Existing Lua external modules available from LuneScript.
- LuneScript runs on Lua and requires only Lua standard modules, so it's easy to deploy.
  - With the go version of LuneScript, transcompile time can be reduced to 1/20.
- Lua modules converted from LuneScript can be used from other Lua modules.
- Supports Lua5.1 ~ 5.4.
  - See below for Lua5.1.
  - [[#crosscompile]]
- LuneScript is self-hosted.
- Supports code completion in emacs
- Supports tag jump by lnstags
  - [[#lnstags]]
- Supports automatic generation of glue code
- The learning cost is low because it is based on the syntax of Lua and C.

** Setup LuneScript

LuneScript provides 2 version.

- go version
- lua script version

*** go version

- download lnsc file.
  - [[https://drive.google.com/drive/folders/1S5NgeM6qIOIUC0rkBHqnWZcuhmsTqB2w][google drive]]  (latest release)
- execute the following commands.

: $ chmod +x lnsc
: $ sudo install lnsc /usr/local/bin
   
*** lua script version    

 - In case of lua5.1
  
 #+BEGIN_SRC sh
 $ luarocks install lunescript51
 #+END_SRC  

 - In case of lua5.2, lua5.3
  
 #+BEGIN_SRC sh
 $ luarocks install lunescript
 #+END_SRC  
  
* LuneScript Getting Started Reference

-----


* Making Lua easier with the transcompiler LuneScript !!
:PROPERTIES:
:CUSTOM_ID: _index
:END:

Lua is a very compact language with high potential.

It can be said that it is one of the easiest languages to use as a language to be incorporated into a program.

However, although it is "easy to use as a language to be incorporated into a program", it is a fact that there are various points of concern compared to the language of Imadoki.

On the other hand, the evolution of Lua to bring it closer to the language of Imadoki could be a trade-off with one of Lua's major features of being "compact."

Therefore, I will introduce the transcompiler LuneScript that can cover the parts of Lua that you care about without modifying Lua itself.


** How to use LuneScript

LuneScript is developed on github.

<https://github.com/ifritJP/LuneScript>

Please refer to the following for the installation method.
- Introduction
  - [[#tutorial2_setup]]


*** command

Installing LuneScript installs the lnsc command.

For information on how to use the lnsc command, refer to the following article.
- Hello world
  - [[#tutorial3_hello]]


*** Cross-compiling between Lua versions

LuneScript supports cross-compilation between versions of Lua. Please refer to the following article.
- Cross-compiling between Lua versions
  - [[#crosscompile]]


** LuneScript specification

This section describes the specifications of LuneScript.


*** Value and type

Please refer to the following article for the values and types handled by LuneScript.
- Value edition
  - [[#value]]
- enum edition
  - [[#enum]]


*** comment

Comments adopt C ++ style. One-line comment ~//~ and multi-line comment ~/* */~ can be specified.
#+BEGIN_SRC lns
// @lnsFront: skip
// 行末までコメント
/* ここから〜
ここまでコメント*/
#+END_SRC



*** operator

In principle, use the same operator as Lua.

Note that // (truncate division) in Lua5.3 is a one-line comment in LuneScript.

In LuneScript, / between ints is automatically truncated and divided.


*** Variable declaration

Please refer to the following article for LuneScript variables.
- Variable edition
  - [[#variable]]


*** General control statement

Please refer to the following for the control statement of LuneScript.
- General branch
  - [[#branch]]
- Repeated syntax
  - [[#loop]]


*** Function declaration

For LuneScript functions, refer to the following.
- Function
  - [[#func]]


*** nilable

LuneScript is a nil-safe (null-safe) language.

For nilables that provide LuneScript nil safety, see:
- nilable edition
  - [[#nilable]]


*** class

LuneScript supports classes for object-oriented programming.

LuneScript classes have the following restrictions:
- Does not support multiple inheritance.
- +Does not support generics.+
- All are methods that can be overridden.
  - Overrides cannot be suppressed.
- You cannot define a method with the same name that has different arguments between inheritances.
  - The exception is the constructor, which has the same name (__init).

Please refer to the following article.
- Class basics
  - [[#class1]]
- accessor edition
  - [[#class2accessor]]
- Class inheritance
  - [[#classinherit]]
- Class advertise edition
  - [[#classadvertise]]
- Class override
  - [[#classoverride]]
- Interface
  - [[#interface]]


**** prototype declaration

LuneScript parses the script in order from the top.

The symbols referenced in the script must be predefined. For example, to declare a variable of type TEST, you need to define the class TEST in advance.

Also, in order to define classes that refer to each other, it is necessary to declare one of them as a prototype.

The following is an example when ClassA and ClassB cross-reference each.
#+BEGIN_SRC lns
// @lnsFront: ok
pub class Super {
}
pub proto class ClassB extend Super;
pub class ClassA {
  let val: ClassB;
}
pub class ClassB extend Super{
  let val: ClassA;
}
#+END_SRC


proto declares as above.

You must declare the same thing, such as pub or extend, in the prototype declaration and the actual definition.


*** Mapping

LuneScript class instances can be converted to and from Map objects.

This is called Mapping.

Please refer to the following for Mapping.
- mapping edition
  - [[#classmapping]]


*** Generics

LuneScript supports Generics.

See below for details.
- generics edition
  - [[#generics]]


*** nil conditional operator

It supports the nil conditional operator as an easy way to work with nilable values.
- nil conditional operator edition
  - [[#nilcond]]   


*** module

For information on LuneScript module management, refer to the following.
- import / provide
  - [[#import]]
- require / module edition
  - [[#require]]


** Build

For information on how to build a project using LuneScript, please refer to the following.
- Build edition
  - [[#make]]  


*** _lune.lua module

As mentioned above, a file transcompiled to Lua with LuneScript can be executed as is with the Lua command. At this time, no external module is required.

This means that the transcompiled Lua code contains all the code needed for processing.

For example, if you transcompile the following processing code,
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val:int! ):int {
   return 1 + unwrap val default 0;
}
#+END_SRC


The Lua code is quite long, like this:
#+BEGIN_SRC lua -n
--mini.lns
local _moduleObj = {}
local __mod__ = 'mini'
if not _ENV._lune then
   _lune = {}
end
function _lune.unwrap( val )
   if val == nil then
      __luneScript:error( 'unwrap val is nil' )
   end
   return val
end 
function _lune.unwrapDefault( val, defval )
   if val == nil then
      return defval
   end
   return val
end

local function func( val )
   return 1 + _lune.unwrapDefault( val, 0)
end

return _moduleObj
#+END_SRC


The 4th to 18th lines are the processing required for unwrap. Note that this code will be output to all Lua files.

*Since this code itself is a common process, you can require it as a separate module and combine the common processes by specifying the -r option when transcompiling.*

Specifically, specify the -r option as follows.
#+BEGIN_SRC txt
$ lua lune/base/base.lua -r src.lns save
#+END_SRC


With this -r option, the above code is translated as follows, which is pretty neat.
#+BEGIN_SRC lua
--mini.lns
local _moduleObj = {}
local __mod__ = 'mini'
_lune = require( "lune.base._lune" )
local function func( val )
   return 1 + _lune.unwrapDefault( val, 0)
end

return _moduleObj
#+END_SRC


Note that require ("lune.base._lune") will be inserted, so this module must be set so that it can be loaded. You don't need to be aware of this if you are in an environment where the transcompiler works, but you need to be careful if you run the converted Lua source in some other environment.


*** macro

LuneScript uses simple macros.


**** Significance of macro

Macros have some limitations compared to regular functions. In addition, processing that can be performed by macros can often be realized by making full use of object orientation.

So what's the point of using macros?

That is, "the operation is statically determined by using a macro".

If the same process is realized in an object-oriented manner, it will be a dynamic process. On the other hand, if it is realized by a macro, it will be a static process.

What makes you happy about this?

It is the same as that statically typed languages are superior to dynamically typed languages.

By statically processing the statically determined information, it can be analyzed statically.

For example, most object-oriented function overrides can be resolved statically by using macros. Making static function calls rather than dynamic function overrides makes it easier to follow the source code.

It is not good to use macros indiscriminately, but it is not ideal to easily use dynamic processing such as function overriding.

It is necessary to use dynamic processing and macros properly.


**** Macro definition

Please refer to the following article for macro definition.
- Macro edition
  - [[#macro]]


*** supplement

For supplementary articles, we will add links here.
- Introducing Lua's transcompiler LuneScript 2
  - Introduction of subfile, module, nil conditional operators
  - [[#introduce2]]
- Let's have more fun with Lua's transcompiler LuneScript's crazy development environment
  - Completion, syntax checking, subfile search
  - [[#completion]]

For articles that are not linked from this page, please follow them from the sidebar.

-----


* Introduction
:PROPERTIES:
:CUSTOM_ID: tutorial2_setup
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will introduce how to install LuneScript.


** LuneScript on Web Browser 

To check the operation of LuneScript, we have prepared a LuneScript environment that runs on a web browser.

[[#onweb]]

In addition, the following sample sources may have a Run button. You can run the sample source by pressing that button. And you can modify the source and run it.

It takes a few seconds to 10 seconds for the first time from pressing the Run button to running the sample (the time depends on the network environment and terminal specifications). This is to load the Lua VM and the LuneScript compiler on the browser.

If you load it once and then re-execute it, this loading process is not performed and you can execute it instantly.


** How to install LuneScript

LuneScript offers two delivery methods:
- Single binary go version that can be run independently
- Lua version that acts as a Lua script


*** go version

We have prepared a Dockerfile for building LuneScript from the source registered in git.

https://github.com/ifritJP/LuneScript/tree/master/src/test/docker/compose
- linux/build/Dockerfile
- alpine/build/Dockerfile
The following will generate lnsc for Linux in LuneScript / src:
: $ git clone --depth 1 https://github.com/ifritJP/LuneScript
: $ cd LuneScript/src
: $ sudo docker build -t linux_lns test/docker/compose/linux/build
: $ sudo docker run --rm -v $PWD:/local linux_lns cp /usr/bin/lnsc /local/lnsc


Put lnsc in your PATH.

In the proxy environment, specify proxy as shown below when docker build.
: $ sudo docker build -t linux_lns test/docker/compose/linux/build --build-arg PROXY=http://proxy.hoge/


This concludes the introduction of the go version of LuneScript.


*** Lua version

LuneScript is a Lua transcompiler. LuneScript itself also acts as a Lua script.

Therefore, the Lua version of LuneScript requires a Lua runtime environment.

The Lua versions supported by LuneScript are 5.1, 5.2, 5.3, 5.4.

However, there are some restrictions when using it with Lua 5.1. I'll discuss the specific restrictions in a separate article.

*Postscript: 12/10 (About Lua 5.1 support)*

The version of Lua installed by default on your system is often 5.1 series.

Check the installed version of Lua with the following command.
#+BEGIN_SRC txt
$ lua -v 
#+END_SRC



**** Introduction of Lua

You can download Lua from the following URL:

http://www.lua.org/download.html

On Linux, it's easy to deploy with package management, but be careful with your Lua version.

For example, in apt type package management such as ubuntu, it can be installed with the following command.
#+BEGIN_SRC sh
$ sudo apt install lua5.3
#+END_SRC



***** For Windows

On Windows, you need the cygwin version of Lua.

The transcompiled Lua code works even if it's not a cygwin version.

However, LuneScript itself assumes a linux environment, so cygwin is required.

Be sure to have a cygwin version of Lua.

We'll see later if it works on Windows Subsystem for Linux.


**** Introduction of LuneScript

As mentioned earlier, LuneScript acts as a Lua script.

Lua's module management is very simple, just put the files in the Lua-managed module directory.

The LuneScript module is published on github.

https://github.com/ifritJP/LuneScript

You can also set up by manually copying the files, but the following describes how to set up using LuneScript's setup.lua.

Manually copying files is difficult unless you are familiar with Lua's module management.


***** How to install LuneScript

Run LuneScript setup.lua.

The procedure is as follows.
#+BEGIN_SRC sh
$ git clone https://github.com/ifritJP/LuneScript.git
$ cd LuneScript/src
$ lua5.3 setup.lua -d
$ sudo make install
#+END_SRC


This will install LuneScript in the module directory.

If you want to specify the Lua module directory where LuneScript will be installed, remove -d from ~lua5.3 setup.lua -d~ and execute.


***** Module directory managed by Lua

You can check the module directory managed by Lua with the following command.
#+BEGIN_SRC sh
$ lua5.3 -e 'print( package.path )'
#+END_SRC


The result of the above command is as follows. (Depends on the environment)
#+BEGIN_SRC sh
/usr/local/share/lua/5.3/?.lua;/usr/local/share/lua/5.3/?/init.lua;/usr/local/lib/lua/5.3/?.lua;/usr/local/lib/lua/5.3/?/init.lua;/usr/share/lua/5.3/?.lua;/usr/share/lua/5.3/?/init.lua;./?.lua;./?/init.lua
#+END_SRC


If you separate this with;, it will be as follows.
- =/usr/local/share/lua/5.3/?.lua=
- =/usr/local/share/lua/5.3/?/init.lua=
- =/usr/local/lib/lua/5.3/?.lua=
- =/usr/local/lib/lua/5.3/?/init.lua=
- =/usr/share/lua/5.3/?.lua=
- =/usr/share/lua/5.3/?/init.lua=
- =./?.lua=
- =./?/init.lua=
I won't go into details, but the following directories are the module directories managed by Lua.
- =/usr/local/share/lua/5.3=
- =/usr/local/lib/lua/5.3=
- =/usr/share/lua/5.3=
- =./=
*The directory depends on your environment.*

You can also specify the module directory by using environment variables, but the explanation here is omitted.


** emacs settings

LuneScript provides emacs lisp for developing with emacs.

Make the following settings.
#+BEGIN_SRC lisp
  (add-to-list 'load-path "my-lune-path")  ;;; clone した LuneScript のパスを指定
  (setq lns-lua-command "/usr/local/bin/lua")  ;;; lua のパス
  (require 'lns-conf)
  (require 'lns-flymake)
  (require 'lns-company-mode)
  (require 'lns-helm)
#+END_SRC


This makes the following available:
- .lns file indentation and coloring
- Syntax check with flymake
- Completion by company-mode
Syntax checking supports flymake and flycheck. If you want to use flycheck, require lns-flycheck instead of lns-flymake.

For helm, company-mode, flycheck and flymake, please do M-x package-install separately.


** Project file

LuneScript makes use of the directory hierarchy for module management. Therefore, the current directory is important when transcompiling with LuneScript.

By placing a file with the following name in the current directory when transcompiling, it will be treated as a project file.
: lune.js


Be sure to generate the above file, especially if you edit the LuneScript source with an editor, as this file will be searched to find out where the project directory of the LuneScript source is.


*** Project file format

The project file is in JSON format.

At a minimum, create a lune.js file with the following content:
#+BEGIN_SRC js
{}
#+END_SRC


The directory where this file is placed will be the starting directory of the module.

For example, in the case of the following directory structure,
#+BEGIN_SRC txt
foo/
foo/lune.js
foo/bar/
foo/bar/mod1.lns
#+END_SRC


bar.mod1 is the module path for mod1.lns.


*** Added command line options

By setting the LuneScript command line options in the project file, the command line options set in the project file at the time of transcompiling will be used.

To set command line options, use the =cmd_option= key to set the string list as follows:
#+BEGIN_SRC js
{
    "cmd_option": [ "--valid-luaval" ]
}
#+END_SRC



** summary

Lua's module management is so simple that it's easy to deploy.

Next time, I will introduce Hello World by LuneScript.

-----


* Hello world
:PROPERTIES:
:CUSTOM_ID: tutorial3_hello
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I would like to introduce Hello world using LuneScript.


** lnsc command

Installing LuneScript installs the lnsc command.

Use the lnsc command as follows.
#+BEGIN_SRC sh
$ lnsc src.lns exe
#+END_SRC


Where src.lns is the path of the script created by LuneScript. exe is an option of lnsc, which means to execute the specified script.


** Hello world 

Now let's use LuneScript to run the traditional Hello world.

Create a file hello.lns with the following content:
#+BEGIN_SRC lns
// @lnsFront: ok
print( "Hello world." );
#+END_SRC


Then run the following command:
#+BEGIN_SRC sh
$ lnsc hello.lns exe
#+END_SRC


This will output "Hello world".

It's not interesting if it's just this, so I'll continue talking a little more.

First, modify hello.lns a bit like this:
#+BEGIN_SRC lns
// @lnsFront: ok
let txt = "world";
print( "Hello %s." ( txt ) );
#+END_SRC


The result of this script is also ~Hello world.~.

Now try running the following command:
#+BEGIN_SRC sh
$ lnsc hello.lns lua
#+END_SRC


I think the following was output.
#+BEGIN_SRC lua
--hello.lns
local _moduleObj = {}
local __mod__ = 'hello'
if not _lune then
   _lune = {}
end
local txt = "world"
print( string.format( "Hello %s.", txt) )
return _moduleObj
#+END_SRC


This is the code that converted hello.lns to Lua.

It's kind of messy, but you can see that ~print( string.format( "Hello %s.", txt) )~ is being output.

This indicates that ~print( "Hello %s." ( txt ) )~ written in LuneScript is expanded to ~print( string.format( "Hello %s.", txt) )~ when transcompiled to Lua.

Now run the following command:
#+BEGIN_SRC sh
$ lnsc hello.lns save
#+END_SRC


This created the hello.lua file. The contents of the hello.lua file are the same as the Lua code you just output.

Now run hello.lua with the following command:
#+BEGIN_SRC sh
$ lua5.3 hello.lua
#+END_SRC


~Hello world.~ will be output. The code transcompiled to Lua is Lua code that does not depend on LuneScript.

The first ~lnsc hello.lns exe~ executed is a command that transcompiles a LuneScript script and executes it.

The next ~lnsc hello.lns lua~ command is a command that transcompiles the LuneScript script and prints the Lua code to standard output.

The last command I ran, ~lnsc hello.lns save~, is a command that transcompiles a LuneScript script and saves the Lua code.

In this document, we will use the exe, but use the save command to check the converted code.


*** Main function

You can handle command line options by defining the main function.

Please refer to the following.

[[#shebang_main]]


** Error message

LuneScript requires the delimiter =;=. If you do not put =;= at the end as follows, you will get an error.
#+BEGIN_SRC lns
// @lnsFront: error
print( "Hello world." )
#+END_SRC


At this time, the following error message is output.
#+BEGIN_SRC txt
mini.lns:1:23: error: EOF
lua5.3: ./lune/base/Util.lua:176: has error
stack traceback:
	[C]: in function 'error'
	./lune/base/Util.lua:176: in function 'lune.base.Util.err'
	./lune/base/TransUnit.lua:3465: in method 'error'
	./lune/base/TransUnit.lua:3538: in method 'getToken'
	./lune/base/TransUnit.lua:11641: in method 'analyzeStatement'
	./lune/base/TransUnit.lua:3710: in method 'analyzeStatementList'
	./lune/base/TransUnit.lua:5430: in function <./lune/base/TransUnit.lua:5393>
	(...tail calls...)
	./lune/base/front.lua:848: in method 'loadFileToLuaCode'
	./lune/base/front.lua:914: in method 'loadFile'
	./lune/base/front.lua:1066: in method 'loadModule'
	./lune/base/front.lua:1709: in method 'exec'
	./lune/base/front.lua:1744: in function 'lune.base.front.exec'
	lune/base/base.lua:1: in main chunk
	[C]: in ?  
#+END_SRC


In this error output, the following message indicates a compilation error:
: mini.lns:1:23: error: EOF


This error indicates that an unexpected EOF error occurred on the 23rd byte of the first line of mini.lns.

Any other error output is an internal error in LuneScript. To suppress error output inside LuneScript, specify the following option (diag --nodebug).
#+BEGIN_SRC sh
$ lnsc hello.lns exe diag --nodebug
mini.lns:1:23: error: EOF
has error
#+END_SRC



** runtime

It's a bit heavy for an article about Hello world, but I'll explain the runtime while looking at the output Lua code.

The code output from LuneScript to Lua has the runtime needed to make it work.

For example, if you convert the following LuneScript code to Lua,
#+BEGIN_SRC lns
// @lnsFront: ok
fn add( val:int! ):int {
   return 10 + unwrap val default 0;
}
print( add( 1 ) ); // 11
print( add( nil ) ); // 10
#+END_SRC


It will be as follows.
#+SRCNAME: mini.lns
#+BEGIN_SRC lua
--mini.lns
local _moduleObj = {}
local __mod__ = 'mini'
local _lune = {}
if _lune1 then
   _lune = _lune1
end
function _lune.unwrap( val )
   if val == nil then
      __luneScript:error( 'unwrap val is nil' )
   end
   return val
end
function _lune.unwrapDefault( val, defval )
   if val == nil then
      return defval
   end
   return val
end

if not _lune1 then
   _lune1 = _lune
end
local function add( val )

   return 10 + _lune.unwrapDefault( val, 0)
end

print( add( 1 ) )
print( add( nil ) )
return _moduleObj
#+END_SRC


You can see that a decent amount of runtime is being output. By the way, above =local function add( val )= is the runtime.

The content of the source LuneScript code increases or decreases the amount of runtime inserted. The output of the entire runtime is about 10KB in size.

This runtime prints to all the converted Lua code.

If you are concerned about the runtime code being inserted into your Lua code, you can replace the runtime deployment with =require= by specifying =-r= as a command line option for lnsc:
#+BEGIN_SRC lua
--mini.lns
local _moduleObj = {}
local __mod__ = 'mini'
local _lune = require( "lune.base._lune1" )
if not _lune1 then
   _lune1 = _lune
end
local function add( val )

   return 10 + _lune.unwrapDefault( val, 0)
end

print( add( 1 ) )
print( add( nil ) )
return _moduleObj
#+END_SRC


However, in this case, lune.base._lune1 will be required, so it must be in the load path so that lune.base._lune1 can be loaded.

Where 1 in _lune1 indicates the runtime version.

You don't have to worry if you are running the Lua version of LuneScript, but be careful if you only want to run the converted Lua code in another environment.

By specifying the =--runtime mod= option instead of the =-r= option,
#+BEGIN_SRC lua
--mini.lns
local _moduleObj = {}
local __mod__ = 'mini'
local _lune = require( "mod" )
if not _lune1 then
   _lune1 = _lune
end
local function add( val )

   return 10 + _lune.unwrapDefault( val, 0)
end

print( add( 1 ) )
print( add( nil ) )
return _moduleObj
#+END_SRC


Instead of loading lune.base._lune as above, you can switch to the specified mod module.

As the version of LuneScript changes, so does the runtime of LuneScript. If you have a mix of Lua modules converted with different versions of LuneScript, using the default lune.base._lune may not work properly.

To avoid this, use the --runtime option to prevent an unintended version of the runtime from loading.

By specifying =-mklunemod path= on the command line, the runtime module file will be generated at the specified path.


** comment

The comments in LuneScript are ~//~ and ~/* */~.

~//~ treats up to the end of the line as a comment, and ~/* */~ treats multiple lines as a comment.

Next time, I will explain the values handled by LuneScript.

-----


* Cross-compiling between Lua versions
:PROPERTIES:
:CUSTOM_ID: crosscompile
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I'll change the schedule a little and explain the cross-compilation of LuneScript.


** Cross-compile

"Cross-compilation" here means "cross-compilation" between versions of Lua.

When transcompiling to Lua, LuneScript transcompiles according to the version of Lua running LuneScript.

For example, the following control is performed.
- When running on Lua5.2, bitwise operations use the bit32 library.
- When running on Lua5.3, bitwise operations use Lua's built-in operators.
Cross-compiling transcompiles the output Lua code to the specified Lua version instead of the version of Lua running LuneScript.

This allows you to:

  "Run LuneScript on Lua5.3 and transcompile to Lua5.1"


*** how to use  

To use it, simply specify the version with the -ol option as follows:
#+BEGIN_SRC sh
$ lnsc src.lns lua -ol 51
#+END_SRC


The above example transcompiles src.lns for lua5.1 and prints the result to stdout.

The values specified for the -ol option are as follows:
|-|-|
| option | version | 
|-+-|
| 51 | Lua5.1 | 
| 52 | Lua5.2 | 
| 53 | Lua5.3 | 

The -ol option can be specified with save and lua.


** LuneScript for Lua5.1

Until now, LuneScript required Lua5.2 and Lua5.3 to execute, but with the above cross-compilation support, it can now be executed with Lua5.1 as well.

Since LuneScript is self-hosting that develops itself in LuneScript, it is compatible with Lua5.1 by cross-compiling LuneScript itself.

*Developing with LuneScript has the advantage of "absorbing Lua version differences to some extent" in addition to "increasing productivity".*

*However, it can only be absorbed to some extent.*

Lua5.1 has the limitations described in the next section.


*** Lua5.1 Limits

Transcompiling LuneScript code to Lua5.1 has the following restrictions:

//It's more of a Lua5.1 limitation than a LuneScript limitation. ..//
- The class destructor cannot be used.
- Bitwise operations cannot be used.
- % G is not available for character classes such as =find()=.
- When% s and% q are specified in the format of =string.format()=, only character strings can be specified.
In the above, for destructors and bit operations, an error is output at compile time, but for% g,% s,% q, an error is not output at compile time, so be careful.

However, for% s and% q, the following pattern avoids an error by adding =tostring()= when transcompiling.
#+BEGIN_SRC lns
// @lnsFront: ok
print( string.format( "%d,%s,%s,%s",  1, 1.0, {}, [] ) );
#+END_SRC


As mentioned above, the format format using a literal string looks at% s and the corresponding data type, and if it is not str, adds =tostring()= as follows.
#+BEGIN_SRC lua
print( string.format( "%d,%s,%s,%s", 1, tostring( 1.0), tostring( {}), tostring( {}) ) )
#+END_SRC


This conversion is possible only when using literal strings.

For example, the following cases cannot be converted.
#+BEGIN_SRC lns
// @lnsFront: ok
let formatTxt = "%d,%s,%s,%s";
print( string.format( formatTxt,  1, 1.0, {}, [] ) );
#+END_SRC



** summary

LuneScript supports cross-compilation between versions of Lua.

This will support execution on Lua5.1, Lua5.2, Lua5.3.

However, Lua5.1 has its limitations.

Next time, I will talk about classes.

-----


* Value edition
:PROPERTIES:
:CUSTOM_ID: value
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain the values that can be handled by LuneScript.


** Value type

The correspondence table between the value types that can be handled by LuneScript and the Lua values after transcompiler is shown.
|-|-|-|-|-|
| LuneScript | Lua | go | Use | How to define in LuneScript | 
|-+-+-+-+-|
| nil, null | nil | nil | nil | nil | 
| int | Numerical value | LnsInt | integer | 0 1 2 3 ?A 0x10 -100 | 
| real | Numerical value | LnsReal | Real number | 0.0 1.0 0.001 | 
| str | String | string | String, binary data | "abc" 'def'  ```hij``` | 
| bool | Boolean value | bool | Boolean value | true false | 
| List | table | LnsList | list | [1, 2, 3 ] | 
| +Array+ | +table+ | +Array (fixed length)+ | +[@ 1, 2, 3 ]+ | 
| Map | table | LnsMap | map | { "A":1, "BC": 100 } | 
| Set | table | LnsSet | set | (@ 1, 2, 3) | 
| class | table | struct | class | class Test {} | 
| interface | table | interface | interface | interface Test {} | 
| fn | function | func | function | fn func() {} | 
| enum | Numbers, strings | const | enum | enum Test { } | 
| alge | table | struct | Algebraic data | alge Test { } | 
| Luaval | Lua value | Lns_luaValue | The value of Lua itself | 
| stem | value | LnsAny | A type that can hold all values except nil | 

*2019/3 Set added. 2020/10 Luaval added*

As mentioned above, LuneScript subdivides Lua values and treats each as a separate type.

The intent of the subdivision is to improve Lua's next specification:
- All Lua numbers are real numbers, and if you are not familiar with them, problems will occur due to the fact that the numbers are real numbers. For example, Lua's calculation for ~10/3~ is 3.3333 instead of 3.
- Lua's tables are divided into sequences where all keys are natural numbers and non-sequences where keys are not natural numbers.
  - Due to this difference, the functions for enumerating the data in the table are divided into ipairs and pairs, and it is necessary to use them properly.
    - It can be said that there is no problem if only pairs are used. .. ..
  - The ~#~ operator, which gets the size of a table, is confusing because it returns the size of the sequence, not the size of the non-sequence.


*** nil

nil is the same as Lua's nil.

Null is also available in LuneScript.

null is an alias for nil.

Null support allows LuneScript to handle JSON out of the box.


*** Integer, real number

LuneScript treats integers and real numbers separately.

This makes 10/3 3 and 10 / 3.0 3.3333 ...

The model names are as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let val:int = 1;      // 整数 int
let val2:real = 1.5;  // 実数 real
#+END_SRC



**** Numeric literal

Numeric literals are C89-like.
- Integers support decimal and hexadecimal representations
- Real numbers are exponential notation in decimal and e.


**** letter

LuneScript can use ~?~ to treat the code of the character following ~?~ as an immediate value of type int.
#+BEGIN_SRC lns
// @lnsFront: ok
print( ?a ); // 97  (0x61)
#+END_SRC


If you want to get the character code of'or', you need to escape it with \ like? \'.

Only 1 byte of code can be retrieved this way. For example, if the character following? Is a multibyte code such as UTF-8, the first byte is fetched, the second and subsequent bytes are parsed as LuneScript code, and a parse error occurs.


**** Four arithmetic operations

The four arithmetic operations of numbers are the same as Lua.

The type of the result of the binary operation changes as follows.
- The result of the operation of int and int is int.
- The result of the operation of real and real is real.
- The result of the operation of int and real is real.
However, if the result of the operation of int and int is out of the range of int, the internal value at runtime will be real, but the type on LuneScript will remain int. To round the result to an int, it must be cast with ~@@int~.

When transcompiled to go, it remains int internally.


**** Bit operation

Supports bit operations. Not available in Lua 5.1.

The bit length is 32 bits for Lua5.2. The bit length of Lua5.3 depends on the environment.
- Logical AND (&)
#+BEGIN_SRC lns
// @lnsFront: ok
print( 1 & 3 == 1 );
#+END_SRC

- OR (|)
#+BEGIN_SRC lns
// @lnsFront: ok
print( 1 | 2 == 3 );
#+END_SRC

- Exclusive OR (~)
#+BEGIN_SRC lns
// @lnsFront: ok
print( 1 ~ 3 == 2 );
#+END_SRC

- Logical shift (left) (| <<)
#+BEGIN_SRC lns
// @lnsFront: ok
print( 1 |<< 2 == 4 );
#+END_SRC

- Logical shift (right) (| >>)
#+BEGIN_SRC lns
// @lnsFront: ok
print( 0x10 |>> 2 == 4 );
#+END_SRC

- Bit inversion (~)
#+BEGIN_SRC lns
// @lnsFront: ok
print( ~2 == 0xfffffffd );
#+END_SRC



*** String

Enclose it in "or" to make a string. You can use'in "" and "in".

Note that "",'' cannot include line breaks. Use "" to include line breaks.

  Use `` `to define a multi-line string without using. Inside `` `` `` is a string as it is, not a line break.

Use [N] to get the character at a specific position in the string. The N specified here indicates that the string starts with 1.
#+BEGIN_SRC lns
// @lnsFront: ok
let txt = "abc";
print( txt[ 2 ] );  // 98
#+END_SRC


*The behavior when N exceeds the string length is undefined.*

Get the string length with #.
#+BEGIN_SRC lns
// @lnsFront: ok
print( #"abc" ); // 3
#+END_SRC


The type name is str as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let val:str = "abc"; // 文字列 str
#+END_SRC



*** Boolean (bool)

It has true and false.

The model name is bool as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let val:bool = true; // bool
#+END_SRC



*** list

Lists are types to which you can add or remove values.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut list:List<int> = [];
list.insert( 1 ); // [ 1 ]
list.insert( 2 ); // [ 1, 2 ]
list.insert( 3 ); // [ 1, 2, 3 ]
list.remove(); // [ 1, 2 ]
print( list[1] ); // 1
#+END_SRC


*Access the elements of the list with [index]. The index at the top of the list is 1. The behavior when accessing outside the range of the list is undefined.*

//The original LuneScript was developed as a lua transcompiler, so//I set the index from 1 to emphasize compatibility with lua,//I think this was a failure now. ..//

It is ~#~ to get the length of the list. For example, ~#list~ gets the length of the list variable list.

The addition of the value is the same as Lua, =insert()=, and the deletion is =remove()=.

The type name is List <T> as follows. Where T indicates the type of element that the list holds.
#+BEGIN_SRC lns
// @lnsFront: ok
let val:List<int> = [1,2];
#+END_SRC



*** Map   

Map literals are an extension of the JSON format.

You can work with the JSON format as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
let map = {
   "val1": 1,
   "val2": 2,
   "val3": 3
};
print( map.val1, map.val2, map.val3 ); // 1 2 3
#+END_SRC


It differs from JSON in the following ways:
- All values except nil can be used for keys and values
#+BEGIN_SRC lns
// @lnsFront: ok
let mut test:Map<int,int> = {};
let map = {
   1: "val1",
   2.0: "val2",
   test: "val3"
};
print( map[ 1 ], map[ 2.0 ], map[ test ] ); // val1 val2 val3
#+END_SRC


Also, since null is an alias of nil, JSON itself can be handled.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut map:Map<str,int> = {};
map[ "abc" ] = 1;
map.xyz = 10;
#+END_SRC


Access the Map elements with [key]. If the key type is str, you can also access it as .key.

For example, the following ["abc"] and .abc access the same element, so print in the following example prints true.
#+BEGIN_SRC lns
// @lnsFront: skip
print( map[ "abc" ] == map.abc ); // true
#+END_SRC


Note that you cannot use the ~#~ operator on maps.

The model name of Map is Map <K, V> as follows. Where K is the key type and V is the value type associated with the key.
#+BEGIN_SRC lns
// @lnsFront: ok
let val:Map<str,int> = { "abc":123 };
#+END_SRC



**** Map notes

Keep the following in mind when working with Maps:
- Map keys cannot distinguish between int and real.
*Specifically, it is undefined what ~map[1]~ and ~map[1.0]~ return in the example below.*
#+BEGIN_SRC lns
// @lnsFront: ok
let map = {
   1: "val1",
   1.0: "val2",
};
print( map[ 1 ], map[ 1.0 ] );
#+END_SRC


This is a limitation from the Lua specification.

Note that when transcompiled to go, int and real are distinguished.
- Key equivalence judgment when a key other than int, real, str is used
In the following example, list1 and list2 are both lists with an int 1 as an element. Using this list1 as a key, register "aaa" in the map.

And if you get the values from map with list1 and list2 as keys, the result will be aaa and nil.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut map:Map<&List<int>,str> = {};
let list1 = [ 1 ];
let list2 = [ 1 ];
map[ list1 ] = "aaa";
print( map[ list1 ], map[ list2 ] );  // aaa nil
#+END_SRC


This is because list1 and list2 are determined as different keys.

If you use anything other than int, real, or str for a map key, the keys must be equal or not for the same object.
- nilable
As mentioned above, access to Map elements is as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let map = {
   "val1": 1,
   "val2": 2,
   "val3": 3
};
print( map.val1, map.val2, map.val3 ); // 1 2 3
#+END_SRC


Here, map.val1 becomes nilable and cannot be treated as 1 of the original data int as it is.

That is, you cannot run =map.val1 + 1= as follows:
: print( map.val1 +1 )


This is because when you access an element of the map, the result is nilable.

See below for nilable.

[[#nilable]]


*** Set

Handles a set of values.

See the following article for more information.

[[#set/]]


*** generics

List, Array and Map support generics.

For example, declare as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let list:List<int> = [];  // int を要素に持つリスト
let array:Array<real> = [@];  // real を要素に持つ配列
let map:Map<str,int> = {}; // str をキー、int を値に持つマップ
#+END_SRC



*** Collection type
#+BEGIN_SRC lns
// @lnsFront: ok
let list = [ 1, 2, 3 ];
let map = { "A": 10, "B": 11, "C": 12 };
#+END_SRC


Collection such as lists and maps can declare literals as above. The types of lists and maps generated at this time are determined by the constituent values.

If all the values used in the constructor of a collection are of the same type, the type of the collection will be the type of that value.

For example, ~[ 1, 2, 3 ]~ in the above sample is List <int>.

If the values used in the collection's constructor are different, the collection's type will be stem.

Specifically, it looks like this:
#+BEGIN_SRC lns
// @lnsFront: ok
let list1 = [ 1, 2, 3 ];			// List<int>
let list2 = [ 'a', 'b', 'c' ];			// List<str>
let list3 = [ 'a', 1, 'c' ];			// List<stem>
let map1 = { "A": 10, "B": 11, "C": 12 };	// Map<str,int>
let map2 = { "A": 10, "B": 11, "C": 12 };	// Map<str,int>
let map3 = { "a": 'z', "b": 'y', "c": 'x' };	// Map<str,str>
let map4 = { "a": 1, "b": 'Z' };		// Map<str,stem>
#+END_SRC



*** Constructor for a collection with a mixture of inherited classes

Constructors for collections with a mixture of inherited classes can fail because type inference cannot be resolved.

In that case, specify the type.

The following sample is shown.
#+BEGIN_SRC lns
// @lnsFront: error
class Test {
}
class Sub extend Test {
}
{
   let mut val1 = [ [ new Test() ], [ new Sub() ] ]; // error
   let mut val2:List<List<Test>> = [ [ new Test() ], [ new Sub() ] ]; // ok
   let mut val3 = [ [ new Test() ], [ new Test() ] ]; // ok
   let mut val4 = [ [ new Sub() ], [ new Sub() ] ]; // ok
}
#+END_SRC


Here, val1 using type inference will result in an error. On the other hand, val2, which specifies the type, is OK. Since val3 and val4 do not have a mixture of classes, type inference is possible.


*** enum

LuneScript supports enums.

See tomorrow's article for more details.

[[#enum/]]


*** Luaval

LuneScript can execute Lua code. The execution result of Lua code is converted internally for int, real, bool, str, but other values are processed as Lua values without conversion.

It is Luaval that holds the value of that Lua.

See below for details.

[[#lua/]]


*** stem

stem is a type that can hold all values except nil.

LuneScript is a statically typed language, and if you give it a value different from the expected type, a compilation error will occur.

On the other hand, the stem type is a type that can handle all types other than nil, so no compile error will occur even if any value other than nil is given.

stem! is a type that can handle all values including nil. You can think of it as a Lua variable itself.


*** form

form is a type that handles function objects.

The function will be described later.

-----


* Set edition
:PROPERTIES:
:CUSTOM_ID: set
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This section describes how to handle the LuneScript value set Set.


** Difference between Set and Map

Set manages the set of values, and Map manages the association of values.

When both are converted to Lua, they are managed as a table, so using Set is not superior to Map in terms of execution speed and memory.

Using Set instead of Map has the following effects:
- Clarify the use of data
- No need to deal with Map value in vain
- Easy to write literal values
Set and Map are the same in the following ways:
- Does not maintain the order of the stored values.
- nilable cannot be stored.


** Set constructor

Set generates data by writing as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let obj = (@ 1, 2, 3, 4 ); // 1 2 3 4
#+END_SRC


This is a Set that holds 1,2,3,4 data.

Set encloses the values with ~(@ )~.

In the above process, the type declaration is omitted by type inference, but if it is not omitted, write as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let obj:Set<int> = (@ 1, 2, 3, 4 ); // 1 2 3 4
#+END_SRC


~Set<int>~ declares a Set whose element is an int.

If you use an empty Set, you must specify the type because type inference is not possible.
#+BEGIN_SRC lns
// @lnsFront: ok
let obj:Set<int> = (@);
#+END_SRC



** Operation of Set

It supports the following operations:
- Added =add()=
- Delete =del()=
- Presence / absence confirmation =has()=
- Get number of elements =len()=
- Duplicate =clone()=
Add or delete values to Set as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut obj = (@ 1, 2, 3, 4 );
obj.add( 0 );  // 0 1 2 3 4
obj.del( 2 );  // 0 1 3 4
#+END_SRC


Check the existence of the value managed by Set as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let obj = (@ 1, 2, 3, 4 );
print( obj.has( 0 ) );  // false
print( obj.has( 1 ) );  // true
#+END_SRC


Set can get the number of elements with the = len () = method. However, the =len()= method enumerates the elements and calculates the number, so the amount of computation is proportional to size.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut obj = (@ 1, 2, 3, 4 );
print( obj.len() );
#+END_SRC


Use =clone()= to generate the same Set.
#+BEGIN_SRC lns
// @lnsFront: ok
let obj = (@ 1, 2, 3, 4 );
let obj2 = obj.clone();
#+END_SRC


clone clones the element shallowly.


** Operations between Sets

It supports the following operations:
- Synthetic =or()=
  - Leave the union of the two sets
- Common =and()=
  - Leave the intersection of the two sets
- Difference =sub()=
  - Leave the part that is not common to the set of arguments from the current set
This operation rewrites the contents of the target Set.
#+BEGIN_SRC lns
// @lnsFront: ok
let set1 = (@  1, 2, 3 );
let set2 = (@  2, 3, 4 );
let set3 = set1.clone().or(set2);   // 1 2 3 4
let set4 = set1.clone().and(set2);  // 2 3 
let set5 = set1.clone().sub(set2);  // 1
#+END_SRC


-----


* enum edition
:PROPERTIES:
:CUSTOM_ID: enum
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain the enum value of LuneScript.


** enum

LuneScript enums allow you to name and manage sets of values.

The types of values that can be handled as enums are as follows.
- int
- real
- str  
The range of an enum can be defined from multiple values, but the value types must be the same.

That is, an enum with an int value cannot define a real or str value.


*** Definition method

The enum is defined as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
print( TestEnum.val0, TestEnum.val1, TestEnum.val2 );  // 0, 1, 2
#+END_SRC


In this example, we define val0, val1, val2, which are 0, 1, 2 respectively.

If you want to specify a value for an enum, define it as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
enum TestEnum {
  val0 = 10,
  val1,
  val2 = 20,
}
print( TestEnum.val0, TestEnum.val1, TestEnum.val2 ); // 10, 11, 20
#+END_SRC


If you omit the enum value, assign the value as follows:
- Assign the value obtained by adding 1 to the previous enum value.
- The first enum value is 0
When assigning a character string to the enum value, the value cannot be omitted.
#+BEGIN_SRC lns
// @lnsFront: ok
enum TestEnum {
  val0 = "abc",
  val1 = "def",
  val2 = "ghi",
}
print( TestEnum.val0, TestEnum.val1, TestEnum.val2 ); // abc def ghi
#+END_SRC


An expression can be specified for the value to be set in the enum value. However, this expression should only use immediate values.

For example, in the following cases
#+BEGIN_SRC lns
// @lnsFront: error
fn func(): int {
  return 100;
}
enum TestEnum {
  val0,
  val1 = val0 + 10,  // 10
  val2 = func(),     // error
}
#+END_SRC


~val = val0 + 10~ can be specified because it uses an immediate value, but ~val2 = func()~ will result in an error because it is not an immediate value.


*** how to use

The defined enum can be used as a type as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ): int {
   return val + 100;
}
print( func( TestEnum.val1 ) ); // 101
#+END_SRC


Where the argument val of =func()= is of type TestEnum. This allows the argument val of =func()= to be a range-limited int rather than just an int.

If you specify an enum value, it will be ~enum type symbol.enum value symbol~, such as ~TestEnum.val~.


*** Omitted

Basically, to specify an enum value, use ~enum type symbol.enum value symbol~, but if you know that the type to which you want to assign is an enum type, you can omit ~enum type symbol~.

For example, in the following case, we know that the argument of =func()= is of type TestEnum, so we can specify it as .val1 instead of TestEnum.val1.
#+BEGIN_SRC lns
// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ): int {
   return val + 100;
}
print( func( .val1 ) ); // 101
#+END_SRC


If you omit the enum type defined in the external module, you need to import the external module.

I will explain about import at a later date.


*** Enum value conversion

The enum value can be used as a defined value as well as as an enum value.

You can see this by looking at val + 100 in the example above, where val is the enum value defined in TestEnum, which can be either 0, 1, or 2. (In the above example, val1 is passed, so it becomes 1). So ~val + 100~ is 1 + 100, resulting in 101.

On the other hand, look at the following example.
#+BEGIN_SRC lns
// @lnsFront: error
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ): int {
   return val + 100;
}
let val = 1;
func( val ); // error
#+END_SRC


~func( val )~ in this example will result in an error.

In this case, val is 1 and val1 is 1 in TestEnum, but an error occurs because the type of val is int and the type is different from TestEnum.

To convert a value of type assigned to an enum value to the corresponding enum value, use the =_from()= function as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ): int {
   return val + 100;
}
let val = 1;
func( unwrap TestEnum._from( val ) );
#+END_SRC


Here ~func( unwrap TestEnum._from( val ) )~ gets the enum value TestEnum.val1 of TestEnum corresponding to val by =TestEnum._from()= and passes it to =func()=.

I'll talk about unwrap later.


*** enum value name

The enum value assigns a value to the symbol.

The enum value can get this symbol name dynamically by $ _txt.

For example, TestEnum.val1 is output in the following cases.
#+BEGIN_SRC lns
// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ) {
   print( val.$_txt ); 
}
func( .val1 ); // TestEnum.val1
#+END_SRC


$ _txt gets the symbol name of the enum value.

We'll talk about $ later, but it's syntactic sugar for function calls.


**** Note on $ _txt

There are the following caveats to $ _txt:

*"If there are multiple enum values with the same value, it is undefined which enum value symbol name $ _txt returns."*

For example, in the following cases, it is undefined whether = print () = prints TestEnum.val1 or TestEnum.val2.
#+BEGIN_SRC lns
// @lnsFront: ok
enum TestEnum {
  val0,
  val1 = 10,
  val2 = 10,
}
fn func( val:TestEnum ) {
   print( val.$_txt ); 
}
func( .val1 ); // TestEnum.???
#+END_SRC


*Also, the string format obtained by $ _txt may change in the future. Do not write code that switches processing depending on the result of _txt.*


*** List of all enum values

You can get a list of all enums defined by enums with $ _allList.

For example, in the following code
#+BEGIN_SRC lns
// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
foreach val in TestEnum.$_allList {
   print( val.$_txt );
}
#+END_SRC


Outputs the following:
#+BEGIN_SRC txt
TestEnum.val0
TestEnum.val1
TestEnum.val2
#+END_SRC



** Algebraic data type

For enum types, you can group one type of int, real, or str to limit the range, but you cannot group multiple types. Algebraic data types are a more general version of enum types, and all types can be grouped, not just int, real, and str.

Details are explained in the next article.

[[#match]]


** summary

By using enums, you can easily define the range and provide an exciting way to handle enums easily.

Next time, I'll talk about variables.

-----


* match edition
:PROPERTIES:
:CUSTOM_ID: match
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript supports algebraic data types and pattern matching.


** Algebraic data type (alge type)

The enum type can limit the range by grouping int, real, or str values.

On the other hand, the algebraic data type is a more general version of the enum type, and all types can be grouped, not limited to int, real, and str.

Algebraic data types are declared with the alge keyword.

Here is an example:
#+BEGIN_SRC lns
// @lnsFront: ok
class Hoge {
   pri let val:int {pub};
}
alge Test {
   Val1,
   Val2( int ),
   Val3( str ),
   Val4( Hoge ),
   Val5( num:int, txt:str ),
}
#+END_SRC


This example declares an alge type Test.

Test has a range from Val1 to Val5. In addition, Val1 to Val5 each have the following parameters.
|-|-|
| value | Parameters | 
|-+-|
| Val1 | none | 
| Val2 | int | 
| Val3 | str | 
| Val4 | Hoge | 
| Val5 | int, str | 

There are no restrictions on the parameter types. In this example, Val4 has a Hoge class type as a parameter.

There is no limit to the number of parameters. In this example, Val5 has int and str as parameters.

There are two ways to specify the parameter, one is to specify only the type, and the other is to specify the name and type. In this example, Val2 through Val4 specify only the type, and Val5 specifies the parameter name and type. The parameter name only has the effect of clarifying the meaning of that parameter.

To use this alge type value, write:
#+BEGIN_SRC lns
// @lnsFront: skip
let val1 = Test.Val1;
let val2 = Test.Val2( 1 );
let val3 = Test.Val3( "abc" );
let val4 = Test.Val4( new Hoge( 100 ) );
let val5 = Test.Val5( 10, "xyz" );
#+END_SRC


The meaning of each is as follows.
- val1 is Test.Val1
- val2 has 1 as a parameter Test.Val2
- val3 has "abc" as a parameter Test.Val3
- val4 has new Hoge (100) as a parameter Test.Val4
- val5 has 10, "xyz" as a parameter Test.Val5


** match

The enum type can be used in the same way as the original value as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ): int {
   return val + 100;
}
let val = 1;
func( unwrap TestEnum._from( val ) );
#+END_SRC


In this example, we have a TestEnum type value of +100 in the function =func()=, which indicates that the TestEnum type can also be used as an int number.

On the other hand, alge type values require special processing. That process is match.

The following is an example of match.
#+BEGIN_SRC lns
// @lnsFront: ok
class Hoge {
   pri let val:int {pub};
}

alge Test {
   Val1,
   Val2( int ),
   Val3( str ),
   Val4( Hoge ),
   Val5( int, str ),
}

fn func( test:Test ) {
   match test {
      case .Val1 {
         print( test.$_txt );
      }
      case .Val2( x ) {
         print( test.$_txt, x );
      }
      case .Val3( x ) {
         print( test.$_txt, x );
      }
      case .Val4( x ) {
         print( test.$_txt, x.$val );
      }
      case .Val5( x, y ) {
         print( test.$_txt, x, y );
      }
   }
}

func( Test.Val1 ); // Test.Val1
func( Test.Val2( 1 ) ); // Test.Val2 1
func( Test.Val3( "abc" ) ); // Test.Val3 abc
func( Test.Val4( new Hoge( 100 ) ) ); // Test.Val4  100
func( Test.Val5( 10, "xyz" ) ); // Test.Val5 10 xyz
#+END_SRC


In this example, match is performed inside the =func()= function.

In case, it branches from Val1 to Val5. Val2 to Val5 each declare a variable that receives a parameter.

For example, func (Test.Val2 (1)) passes ~Test.Val2( 1 )~ to =func()=. Here it matches ~case .Val2( x )~ of match in =func()=. Then x is set to 1 and ~print( test.$_txt, x )~ is executed.

Here ~test.$_txt~ expands the string "Test.Val2" that indicates Val2 in the range.

match can use default, _default, and _match as well as switch.


** abbreviation for alge type

Like enum types, alge types can use abbreviations.

If you have the following algae type Test and a function that takes that Test as an argument,
#+BEGIN_SRC lns
// @lnsFront: ok
alge Test {
   Val1,
   Val2,
   Val3( int ),
}
fn func( test:Test ) {
   print( test );
}
#+END_SRC


When calling =func()=, Test can be omitted as follows:
#+BEGIN_SRC lns
// @lnsFront: skip
func( .Val1 );
func( .Val2 );
func( .Val3( 10 ) );
#+END_SRC


If you want to omit the alge type defined in the external module, you need to import the external module.


** Alge type comparison

Simple alge-type values with no parameters can be compared as follows:
#+BEGIN_SRC lns
// @lnsFront: error
alge Test {
   Val1,
   Val2,
   Val3( int ),
}
fn func( test:Test ) {
   if test == .Val1 {
      print( "Val1" );
   }
   elseif test == .Val2 {
      print( "Val2" );
   }
   elseif test == .Val3(1) {  // error
      print( "Val3" );
   }
   else {
      print( "no" );
   }
}
func( .Val1 ); // Val1
func( .Val2 ); // Val2
#+END_SRC


Note that the values with parameters (Val3 in the above case) will be different even if the same parameters are given. By the way, the above ~test == .Val3(1)~ will result in an error. This is because the result of this expression is always "false", so a compile error will prevent you from getting unintended results at run time.


** Alge use case

Using alge you can write the JSON structure as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
alge JsonVal {
   JNull,
   JBool(bool),
   JInt(int),
   JReal(real),
   JStr(str),
   JArray(List<JsonVal>),
   JObj(Map<str,JsonVal>),
}
fn dumpJson( stream:oStream, jval:JsonVal ) {
   match jval {
      case .JNull {
         stream.write( "null" );
      }
      case .JBool( val ) {
         stream.write( "%s" (val) );
      }     
      case .JInt( val ) {
         stream.write( "%d" (val ) );
      }        
      case .JReal( val ) {
         stream.write( "%g" (val ) );
      }        
      case .JStr( val ) {
         stream.write( '"%s"' (val ) );
      }        
      case .JArray( list ) {
         stream.write( "[" );
         foreach val, index in list {
            if index > 1 {
               stream.write( "," );
            }
            dumpJson( stream, val );
         }
         stream.write( "]" );
      }        
      case .JObj( map ) {
         stream.write( "{" );
         let mut cont = false;
         foreach val, key in map {
            if cont {
               stream.write( ',' );
            }
            else {
               cont = true;
            }
            stream.write( '"%s":' (key) );
            dumpJson( stream, val );
         }
         stream.write( "}" );
      }
   }
}
dumpJson( io.stdout,
          JsonVal.JObj( { "foo": JsonVal.JInt( 1 ),
                          "bar": JsonVal.JStr( "abc" ) } ) );
#+END_SRC


You can do the same thing by using cast, inheritance, etc. without using algae. However, there are drawbacks to inheritance as well as casting.

Alge isn't a panacea either, but I think it's a better option than using cast or inheritance in some situations.

Next time, I will explain the interface.

-----


* Variable edition
:PROPERTIES:
:CUSTOM_ID: variable
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain the variables of LuneScript.


** variable

LuneScript is a statically typed language, and variables have types.

Declare the variable with let as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
let val:int = 1;
#+END_SRC


The above example declares a variable val with an int of 1 as the initial value.

After the variable name, specify the type.

If the initial value is set to 1.0, which is real instead of 1, which is int, a compile error will occur because the type is different.
#+BEGIN_SRC lns
// @lnsFront: error
let val:int = 1.0;  // error
#+END_SRC


+Also, variable declarations now require an initial value.+

+This is to prevent access to uninitialized variables.++In the future, let flow analysis determine if a variable holds a value,++I am thinking of eliminating the need for initial values.+

Initialization at the time of variable declaration is not mandatory. If you refer to a variable that has not been initialized, a compile error will occur. Details will be described later.

In addition, type inference is possible even if it is not initialized when the variable is declared.


*** Type inference

LuneScript supports type inference.

You can determine the type of a variable from the initial value you set for that variable. This allows you to declare a variable without specifying a type as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
let val1 = 1; // int 
let val2 = 1.0; // real
let val3 = "abc"; // str
#+END_SRC


In this case, treat val1 as an int, val2 as a real, and val3 as a str.

You may need to specify the type, for example:
- Set nil to the initial value of a variable of type nilable
: let mut val:int! = nil;

- Set an immediate empty value (=[]=, ={}=, etc.) to the initial value of the list type or map type variable.
: let mut val:List<int> = [];

- When setting an instance of a subclass to a variable of the following class type, if you want to set the variable type to the superclass type
: let val:Super = new Sub();



*** Variable initialization

Accessing uninitialized variables will result in a compilation error.
#+BEGIN_SRC lns
// @lnsFront: error
{
   let val;
   print( "%s" ( val ) ); // error
}
#+END_SRC


In =print()= above, I'm accessing an uninitialized val, but I get a compile error here.


**** Flow analysis

Variable initialization parses the flow and checks for variable uninitialized paths.

For example, in the following cases, an error will occur.
#+BEGIN_SRC lns
// @lnsFront: error
fn func( flag:bool )
{
   let val;
   if flag {
     val = 1;
   }
   print( val ); // error
}
#+END_SRC


The cause of the above error is that if flag is true, val is initialized, but if false, val is not initialized.

All paths must be initialized before they can be accessed, as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( flag:bool )
{
   let val;
   if flag {
     val = 1;
   }
   else {
     val = 2;
   }
   print( val ); // ok
}
#+END_SRC


Note that this process is an initialization for the variable val, not a rewrite for the val, so there is no need to declare the mut, which will be described later.

By the way, the flow is also analyzed in the following slightly complicated cases.
#+BEGIN_SRC lns
// @lnsFront: error
fn func( kind:int )
{
   let val;
   if kind < 10 {
      if kind > 0 {
         val = 1;
      }
      else {
         if kind == 0 {
            val = 2;
         }
         elseif kind == 1 {
            val = 3;
         }
         // ※ 
      }
   }
   else {
      val = 4;
   }
   print( val ); // error
}
#+END_SRC


It may be a little difficult to understand, but since the initialization of val is missing at the time of else at the position of * above, the val reference of print will result in an error.

In the following cases, an error will occur at print (val).
#+BEGIN_SRC lns
// @lnsFront: error
fn func( flag:bool )
{
   let val;
   fn sub() {
      print( val ); // error
   }
   val = 1;
   sub();
}
#+END_SRC


Originally, val is initialized when executing =sub()=, so it should not be an error, but this is the current specification.


**** Type inference

Type inference is possible even if it is not initialized when the variable is declared.

However, type inference uses the first type assigned in the flow analysis.

For example, in the following cases
#+BEGIN_SRC lns
// @lnsFront: error
fn func( flag:bool )
{
   let val;
   if flag {
      val = 1;
   }
   else {
      val = 1.0; // error
   }
}
#+END_SRC


In the first ~val = 1~ val is of type int. Then, at the next ~val = 1.0~, an error occurs because you are trying to assign real 1.0 to an int type val.

In the above cases, you can avoid the error by declaring the type when declaring the variable as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( flag:bool )
{
   let val:stem; // stem 型を宣言
   if flag {
      val = 1;
   }
   else {
      val = "a";
   }
   print( val );
}
#+END_SRC


In addition to stem, there are other cases where you need to declare a type. For example, you may want to use a variable of type superclass, or you may want to use a variable of type nilable.


*** shadowing

LuneScript prohibits variable declarations with the same name.

Here, the same name means not only the same name within the same scope but also the same name within an accessible scope.

Specifically, the following variable declaration will result in an error.
#+BEGIN_SRC lns
// @lnsFront: error
{
   let val = 1;
   {
      let val = 1;  // error
   }
}
#+END_SRC


I think there are pros and cons to this specification, but I've made it to the safety side.


*** Access control

The declared variable is treated as a local variable.

If you want to publish to an external module, declare it with pub as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
pub let val = 1;
#+END_SRC


To access an externally exposed variable, use import as follows:
#+BEGIN_SRC lns
// @lnsFront: skip
import SubModule;
print( SubModule.val );
#+END_SRC


Where SubModule is the LuneScript module (SubModule.lns) that declares ~pub let val = 1;~.

If you want to access this val, you can access it by typing SubModule.val.

The basic way to expose variables to external modules is pub, but you can also use global.
#+BEGIN_SRC lns
// @lnsFront: ok
pub let val1 = 1;
global let val2 = 2;
#+END_SRC


The difference between pub and global is the namespace difference.

As you can see from the following example, this is a sample of accessing val1 and val2 from the outside.
#+BEGIN_SRC lns
// @lnsFront: skip
import SubModule;
print( SubModule.val1 );
print( val2 );
#+END_SRC


val1 is accessed as SubModule.val1 as a variable in the SubModule namespace, while val2 is accessed as a variable in the top-level namespace.

When developing a system with LuneScript alone, it is unlikely that you will use global (or you should avoid using global), but when working with other Lua modules, use global. I think there are times when you have to do it.

Global is supported for the purpose of maintaining such compatibility.

The global restrictions are as follows.

*"A variable declared global is valid when you import a module that declares the variable."*

For example, in the following example, val2 seems to exist in SubModule for nothing,
#+BEGIN_SRC lns
// @lnsFront: skip
import SubModule;
print( SubModule.val1 );
print( val2 );
#+END_SRC


In the following case, since SubModule has not been imported, val2 does not exist and an error occurs.
#+BEGIN_SRC lns
// @lnsFront: skip
print( val2 );
#+END_SRC


In addition, variables that are exposed to the outside have the following restrictions.

*"Variables exposed to the outside must be declared in the highest scope of the script."*

For example, the following val2 will result in an error because it is not the highest scope.
#+BEGIN_SRC lns
// @lnsFront: error
pub let val = 1;
{
   pub let val2 = 1; // error
}
#+END_SRC



*** mutable

A variable that is simply declared is treated as a variable that cannot be changed.

For example, the following ~val = 2~ will result in an error.
#+BEGIN_SRC lns
// @lnsFront: error
let val = 1;
val = 2; // error
#+END_SRC


If it is a mutable variable, declare it with mut as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut val = 1;
val = 2;
#+END_SRC


You can also assign the initial value after declaring the immutable variable as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let val;
val = 1;
#+END_SRC


However, if you set an additional value after substituting the initial value as shown below, an error will occur.
#+BEGIN_SRC lns
// @lnsFront: error
let val;
val = 1;
val = 2; // error
#+END_SRC



**** immutable type

*As mentioned above, variables that are not declared mut are immutable. In addition, type inferred types without a mut declaration are also immutable. For example, in the following case, list1 is declared mut, so it is possible to modify List (insert), but list2 is immutable without declaring mut, so the operation to modify List is an error.*
#+BEGIN_SRC lns
// @lnsFront: error
let mut list1 = [1];
list1.insert( 2 ); // ok
let list2 = [1];
list2.insert( 2 ); // error
#+END_SRC


Immutable types are represented as & T by adding & to the original type T. For example, =&List<int>= represents a list <int> that cannot be modified. You cannot change it, but you can refer to it such as foreach.

=&List<List<int>>= is an immutable list with =List<int>= as an element. Where =List<int>= is mutable because it does not have a &. That is, it looks like this:
#+BEGIN_SRC lns
// @lnsFront: error
let list:&List<List<int>> = [[100],[]];
list[1].insert( 1 ); // ok
list.insert( [10] ); // error
#+END_SRC



**** Type inference and mutable

As mentioned above, the type of variable that is not declared mut is immutable.

However, this is the case when using type inference.

Variables that are not mut-declared depend on the mutable declaration for that type, if the type is explicitly stated.

For example, in the following cases
#+BEGIN_SRC lns
// @lnsFront: error
let list1:List<int> = [1,2];
let list2:&List<int> = [1,2];
let mut list3 = [1,2];
let list4 = [1,2];
list1.insert( 3 );
list2.insert( 3 ); // error
list3.insert( 3 );
list4.insert( 3 ); // error
#+END_SRC


=list2.insert( 3 );= and =list4.insert( 3 );= are in error because list2 and list4 are immutable & List <int>.

In addition, this specification has a problem before, and it has been fixed in ver 1.2.0. Previously, even if the type was specified, it was an immutable type if mut was not declared, but its behavior was inferior in variables, members, and arguments, so it has been corrected to the current specification.

If you want to revert to the specifications of ver 1.2.0 or earlier, specify the option --legacy-mutable-control.

However, this option may be deprecated in the future.


*** Multiple declarations

LuneScript, like Lua, can return multiple values for a function's return value.

To use this return value as the initial value of the variable declaration, declare as follows.
#+BEGIN_SRC lns
// @lnsFront: skip
let val1, val2 = func();
let mut val3, mut val4 = func();
#+END_SRC


Declare mut before each variable name.


*** Access check
:PROPERTIES:
:CUSTOM_ID: access_check
:END:


If you do not refer to the declared local variable after setting the value, a warning is output. On the other hand, class members and function arguments are not subject to access checks.

The following sample is an example of using only the second value without using the first value for multivalued returns. In this case, it warns that val1, which stores the first value, is not being used.
#+BEGIN_SRC lns
// @lnsFront: ok
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let val1, val2 = sub(); // warning val1
   print( val2 );
}
#+END_SRC


To avoid warning for variables declared only to access the second and subsequent values of such multivalued returns, use the'_' symbol as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let _, val2 = sub(); // ok
   print( val2 );
}
#+END_SRC


Note that variables declared with the'_'symbol cannot be accessed. An error will occur if you access it.
#+BEGIN_SRC lns
// @lnsFront: error
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let _, val2 = sub();
   print( _ ); // error
   print( val2 );
}
#+END_SRC


The access check is also performed after updating the value of the variable.

For example, val1 is warned if:
#+BEGIN_SRC lns
// @lnsFront: ok
fn func() {
   let mut val1 = 1;
   print( val1 );
   val1 = 2; // warning
}
#+END_SRC


This is because print (val1) references val1 after setting val1 to 1, but then =val1 = 2= updates val1 and then does not reference val1.


**** Closure access check

This access check also works with closures.

The following sample does not warn after =val1 = 2=, judging that it refers to val1 due to the call of =sub()=.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func() {
   let mut val1 = 1;
   fn sub() {
      print( val1 );
   }
   val1 = 2;
   sub();
}
#+END_SRC


However, there are the following restrictions.
- Treat as if there was a value reference at the time of reference, not a closure function call
  - For example, it processes when a closure function is assigned to a variable or passed as an argument of another function.
- Access by closure does not distinguish between reference and setting
  - Even if it is set only in the closure function, it is treated as a reference.
Closure access checking is an experimental feature.


*** Special symbol

The following symbols point to special values.
|-|-|
| symbol | value | 
|-+-|
| ~__mod__~ | Module name | 
| ~__func__~ | Current function name | 
| ~__line__~ | Current line number | 

*The format of the names expanded by ~__mod__~ and ~__func__~ may change in the future.*


** Type conversion (cast)

All values except nil can be assigned to variables of type stem.

It has an implicit type conversion.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut val:stem = 1;
val = 1.0;
val = "abc";
val = {};
val = [];
val = [@];
#+END_SRC


On the other hand, assigning a stem type value to a different type will result in an error.
#+BEGIN_SRC lns
// @lnsFront: error
let val1:stem = 1;
let val2:int = val1; // error
#+END_SRC


If you need explicit type conversion, see the following articles:

[[#cast]]


** reference

Variables hold object references except for some (int, real, nil).

For example, in the following cases
#+BEGIN_SRC lns
// @lnsFront: ok
let mut list1 = [ 10 ];
let list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
foreach val in list2 {
   print( val ); // 10 20 30
}
#+END_SRC

- Set list1 to a reference to a List <int> type list (=[ 10 ]=) object
- Set list2 to the reference held by list1
- Insert 20, 30 into the list object referenced by list1
- =print()= for each value of the list object referenced by list2
*Here, list1 and list2 refer to the same list object, so if you insert 20, 30 into list1, print (val) foreaching list2 will print 10 20 30.*

*Also, if you insert 40 into list2 as follows, print (val) prints 10 20 30 40 because you insert 40 into the same list object.*
#+BEGIN_SRC lns
// @lnsFront: ok
let mut list1 = [ 10 ];
let mut list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
list2.insert( 40 );
foreach val in list2 {
   print( val ); // 10 20 30 40
}
#+END_SRC


If you set list1 to a new list object (=[ 100]=), print (val) prints 10 20 30 40 because the list object referenced by list1 and the list object referenced by list2 are different.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut list1 = [ 10 ];
let mut list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
list2.insert( 40 );
list1 = [ 100 ];
foreach val in list2 {
   print( val ); // 10 20 30 40
}
#+END_SRC


This is also the case for List <List <int >>.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut list = [ 10, 20 ];
let mut wrapList:List<List<int>> = [];
wrapList.insert( list );
wrapList.insert( list );
wrapList.insert( [ 100, 200 ] );
list[ 1 ] = list[ 1 ] + 1;
print( wrapList[ 1 ][ 1 ], wrapList[ 1 ][ 2 ] ); // 11 20
print( wrapList[ 2 ][ 1 ], wrapList[ 2 ][ 2 ] ); // 11 20
print( wrapList[ 3 ][ 1 ], wrapList[ 3 ][ 2 ] ); // 100 200
#+END_SRC


I've added a list to the 1st and 2nd of the wrapList, and a new list object to the 3rd of the wrapList. After that, after incrementing list [1], the contents of wrapList are output.

Here, wrapList [1] [1] and wrapList [2] [1] point to the same list [1], so the incremented value is output. Since wrapList [3] will be a new list object, it will not be affected by the increment.


** summary

LuneScript variables incorporate the following elements:
- Type inference
- Access control
- mutable
- Multiple declarations
I'm going to have the minimum functionality needed to handle Lua with static cleanup.

Next time, I will explain the branch control of LuneScript.

-----


* General branch syntax
:PROPERTIES:
:CUSTOM_ID: branch
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain the general branching syntax of LuneScript.


** Syntax list

LuneScript supports the following general branching syntax:
- if
- switch
By the way, the reason why we use "general" branch control here is that there is a separate branch control in the nilable control.


*** if

Use the if statement as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
let val = 1;
if val == 1 {
   print( "hoge" );
}
elseif val == 2 {
   print( "foo" );
}
else {
   print( "bar" );
}
#+END_SRC


I don't think it's necessary to explain, but it is processed as follows.
- If the if expression holds, the if block is executed.
- If the if expression does not hold and the elseif expression holds, the elseif block is executed.
- If all expressions are unsuccessful, the else block is executed.
- There may be multiple elseifs.
- elseif and else do not have to exist.
- The condition for an expression to "fail" is when the result of the expression is nil or false.


**** Comparison with bool value

LuneScript does not recommend comparing with bool values.

Specifically, we do not recommend the following operations.
#+BEGIN_SRC lns
// @lnsFront: ok
   let val1 = true;
   if val1 == true {
   }
   if val1 == false {
   }
   if val1 ~= false {
   }
   if val1 ~= true {
   }
#+END_SRC


The above operations will be deprecated in the near future.

Currently, it prints a warning message at compile time.

If you want to switch the process depending on the boolean value of bool, do as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let exp = true;
if exp {
   print( "exp is true" );
}
else {
   print( "exp is false" );
}
if not exp {
   print( "exp is false" );
}
#+END_SRC



*** switch

Use the switch statement as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
let val = 1;
switch val {
   case 1 {
      print( "hoge" );
   }
   case 2 {
      print( "foo" );
   }
   default {
      print( "bar" );
   }
}
#+END_SRC


This sample is synonymous with the if sample above.

You can write multiple expressions in the switch case as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
let val = 1;
switch val {
   case 10, 20, 30 {
      print( "hoge" );
   }
   default {
      print( "bar" );
   }
}
#+END_SRC


This is synonymous with the following if statement, which executes the block if it matches any of the values.
#+BEGIN_SRC lns
// @lnsFront: ok
let val = 1;
if val == 10 or val == 20 or val == 30 {
   print( "hoge" );
}
else {
   print( "bar" );
}
#+END_SRC


The point to note in the switch statement is that break is not required unlike C language.

For example, the following break exits the for statement instead of exiting the switch statement.
#+BEGIN_SRC lns
// @lnsFront: ok
for count = 1, 10 {
   switch count {
      case 5 {
         break;
      }
   }
}
#+END_SRC



**** Flow analysis of enum values

If the switch condition is an enum value, the case statement checks whether all enum values are specified and analyzes the flow.

For example, in the following cases, the =print()= statement after the switch statement in the =func()= function results in an unreachable error. This is because return is specified for all values of the enum value Val (Val1, Val2).
#+BEGIN_SRC lns
// @lnsFront: error
enum Val {
   Val1,
   Val2,
}
fn func( val:Val ) {
   switch val {
      case .Val1 {
         return;
      }
      case .Val2 {
         return;
      }
   }
   print( work ); // error : 全ての enum 値の case があり、 return している
}
#+END_SRC


Also, if cases are specified for all enum values and default is also specified, the default will not be reached and a warning will be issued.
#+BEGIN_SRC lns
// @lnsFront: ok
enum Val {
   Val1,
   Val2,
}
fn func( val:Val ) {
   switch val {
      case .Val1 {
         return;
      }
      case .Val2 {
         return;
      }
      default { // warning : ここには到達しない
         return;
      }
   }
}
#+END_SRC



***** fail safe default

As mentioned above, if a case is specified for all enum values and default is also specified, the default will not be reached and a warning will be issued.

However, if you are using default as fail safe, you may want to specify default.

In such cases, you can suppress the warning by specifying _default instead of default.
#+BEGIN_SRC lns
// @lnsFront: ok
enum Val {
   Val1,
   Val2,
}
fn func( val:Val ) {
   switch val {
      case .Val1 {
         return;
      }
      case .Val2 {
         return;
      }
      _default { // ここには到達しないが、 warning は出力されない
         return;
      }
   }
}
#+END_SRC



**** All cases forced switch
:PROPERTIES:
:CUSTOM_ID: _switch
:END:


In a switch that requires an enum value, if you want to make sure that cases are declared for all enum values, you can use _switch as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
enum Val {
   Val1,
   Val2,
}
fn func( val:Val ) {
   _switch val {
      case .Val1 {
         return;
      }
      case .Val2 {
         return;
      }
   }
}
#+END_SRC


In _switch, if there is a missing case for enum, a compile error will occur. Also, default cannot be used.
#+BEGIN_SRC lns
// @lnsFront: error
enum Val {
   Val1,
   Val2,
}
fn func( val:Val ) {
   _switch val { // error
      case .Val1 {
         return;
      }
   }
}
#+END_SRC


By using _switch, when the enum value increases during development, it is possible to reliably detect omissions in the switch-case statement.

_Match can be used in match-case as well.


** summary

The general branching syntax for LuneScript is if and switch.

There is no goto.

Next time, I will talk about repetitive control.

-----


* Repeated syntax
:PROPERTIES:
:CUSTOM_ID: loop
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain the iterative syntax of LuneScript.


** Syntax list

LuneScript supports the following iterative syntax:
- while
- repeat (to be deleted in the future)
- for
- apply
- foreach
- forsort  


*** while, repeat

While and repeat are used as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut val = 1;
while val < 10 {
   val = val + 1;
}
print( val ); // 10
repeat {
   let mut endFlag = false;
   val = val + 1;
   if val >= 20 {
      endFlag = true;
   }
} endFlag;
print( val ); // 20
#+END_SRC


while processes the block while the expression holds, and repeat processes the block while the expression fails.

Variables in scope inside the block are available in repeat expressions.

*Repeat will be deleted in the future.*


*** infinite loop

If you want to use an infinite loop, use while true {}. Where true must be an immediate value.

For example, if you use a variable instead of an immediate value as shown below, it will loop infinitely in processing, but it will not be treated as an infinite loop in flow analysis.
#+BEGIN_SRC lns
// @lnsFront: skip
let flag = true;
while flag {
}
#+END_SRC


The problem with not being considered an infinite loop is that you can't do the intended flow analysis.

For example, LuneScript determines that the =print()= statement after an infinite loop is not processed in the following cases:
#+BEGIN_SRC lns
// @lnsFront: error
while true {
}
print( "hoge" );
#+END_SRC


However, if true above is not an immediate value, we assume that it is not an infinite loop and that the =print()= statement may be processed.

If something that should not be processed is determined to be processed, what originally causes a compile error does not become an error, and you may miss a code defect.

Be sure to use immediate true for infinite loops.

Note that repeat {} false is also not treated as an infinite loop.

I thought it would be better to prepare an instruction dedicated to infinite loops like Rust, but at present it is this specification.


*** for

Use it as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
for count = 1, 10, 1 {
  print( count );
}
#+END_SRC


It has basically the same specifications as Lua. The above example processes the block by incrementing count by 1 from 1 to 10.

Note that the values 1, 10, 1 are evaluated only once at the start of for.

In other words, if you do something like this, it will behave differently than you expected.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut addVal = 1;
for count = 1, 10, addVal {
  addVal = addVal + 1;
  print( count );
}
#+END_SRC


*If the value to be incremented is omitted, 1 is used.*


*** apply

apply is a Lua for in compatibility instruction.

Use it as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
apply txt of string.gmatch( "hoge.foo.bar", '[^%.]+' ) {
   print( txt );
}
#+END_SRC


Note that the expression given to exp in ~apply val of exp {}~ must be a function call. This is the current limit.


*** foreach

foreach is a function that enumerates the elements of lists, arrays, and maps.

Use it as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
foreach val, index in [ 1, 2, 3 ] {
   print( index, val );
}
foreach val, index in [@ 10, 20, 30 ] {
   print( index, val );
}
foreach val, key in { "a":100, "b":200, "c":300 } {
   print( key, val );
}
foreach val in (@ 1, 2, 3 ) {
   print( val );
}
#+END_SRC


*Set enumerates only values*

The list, array index, and map key can be omitted as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
foreach val in [ 1, 2, 3 ] {
   print( val );
}
foreach val in [@ 10, 20, 30 ] {
   print( val );
}
foreach val in { "a":100, "b":200, "c":300 } {
   print( val );
}
#+END_SRC


*It is prohibited to change the enumerated objects during the loop processing of foreach and forsort. The behavior when changed is undefined.*

For example, the following is prohibited.
#+BEGIN_SRC lns
// @lnsFront: skip
let mut list = [ 1, 2, 3 ];
foreach val, index in list {
   list[ index ] = val + 10;
}
#+END_SRC



*** forsort

*If you enumerate the elements with Foreach in Set and Map, the enumeration order of the elements is indefinite.*

When enumerating the elements of Set and Map, forsort enumerates them in the order sorted by key (ascending order).
#+BEGIN_SRC lns
// @lnsFront: ok
forsort val, key in { "b":200, "c":300, "a":100 } {
   print( key, val );
}
forsort val in (@ 2, 4, 1, 0 ) {
   print( val );
}
#+END_SRC


Map forsort can omit the key.
#+BEGIN_SRC lns
// @lnsFront: ok
forsort val in { "b":200, "c":300, "a":100 } {
   print( val );
}
#+END_SRC


*Since forsort does clone and sort internally, there is some overhead.*

Also, if the Set type and Map key type are not sortable types, an error will occur.


*** break

break breaks through the innermost iterative control statement.

There is no continue.


** summary

The general control syntax of LuneScript is basically the same as Lua.

The main difference is that we have added foreach and forsort to process lists etc.

Next time, I will explain the function.

-----


* Function
:PROPERTIES:
:CUSTOM_ID: func
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain the functions of LuneScript.


** Function definition
The LuneScript function is defined as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
fn add_sub( val1:int, val2:int ): int, int {
   return val1 + val2, val1 - val2;
}
print( add_sub( 1, 2 ) ); // 3, -1
#+END_SRC


The above example defines the following function:
|-|
| Definition | 
|-|
| Function name | add_sub | 
| First argument name | val1 | 
| First argument type | int | 
| Second argument name | val2 | 
| Second argument type | int | 
| First return type | int | 
| Second return type | int | 

LuneScript can return multiple return values.


**** Return value

Use the return statement for the return value of the function.

The function can return multiple values.

See below for multi-valued return values.

[[#multipleretval]]


** Function that does not return

Some functions do not return processing.

Here is an example:
#+BEGIN_SRC lns
// @lnsFront: error
fn func(): __ {
   while true {
   }
}
func();
print( 1 ); // error
#+END_SRC


In this example, =func()= is an infinite loop. Therefore, =func()= will not return any processing.

To make this clear, the return type of =func()= is ~__~. ~__~ indicates that it is a function that does not return processing.

This tells us that the next =print()= statement for =func()= will not be processed, resulting in an error.

Note that a function whose return type is ~__~ must not return processing.

For example, if you break as follows, the process will be returned from =func()= because the loop will be broken. In such a case, an error will occur.
#+BEGIN_SRC lns
// @lnsFront: error
fn func(val:int): __ {
   while true {
      if val == 1 {
         break;
      }
   }
}
#+END_SRC



** Variadic argument, return value

Variadic arguments and return values can be used.

See the following article for details.

[[#arg]]


** Definition location

Functions can be defined wherever a statement can be written. Specifically, it can be defined in the block as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
fn sub():int {
   let mut val = 0;
   {
      {
         fn func(): int {
            return 1;
         }
         val = val + func();
      }
      fn func(): int {
         return 2;
      }
      val = val + func();
   }
   fn func(): int {
      return 3;
   }
   return val + func();
}
print( sub() ); // 6
#+END_SRC


Functions with the same name can be defined in different scopes.


** Public function

Functions, like variables, can be exposed to the outside world using pub.
#+BEGIN_SRC lns
// @lnsFront: ok
pub fn func(): int {
   return 1;
}
#+END_SRC


By specifying pub, it becomes a function that can be accessed from the outside.

global is also available.
#+BEGIN_SRC lns
// @lnsFront: ok
global fn func(): int {
   return 1;
}
#+END_SRC


The global declaration of a function has the same restrictions as the global declaration of a variable.

*"A function declared global is valid when the module that declares the function is imported."*

External exposure of functions has the following restrictions:

*"Externally exposed functions must be declared in the top-level scope of the script."*


** form type

*LuneScript can handle function objects as values. You can use form as the type of a special function object.*

The following is an example of using form.
#+BEGIN_SRC lns
// @lnsFront: ok
fn test() {
   print( "hoge" );
}
fn sub( func:form ) {
  func();
}
sub( test ); // hoge
#+END_SRC


This example has the following configuration:
- Define function test
- Function sub has form type arguments
- Execute sub with test as an argument
This will run test inside sub and print hoge.

The form type is treated as the following function.
#+BEGIN_SRC lns
// @lnsFront: skip
fn func(...):... {}
#+END_SRC



*** Function type that can be assigned to form type

As mentioned above, form is synonymous with ~fn func(...):... {}~.

Also, =...= represents zero or more =stem!=.

That is, functions with stem! Arguments can be assigned to form types, and functions with non-stem! Arguments cannot be assigned.

If it can be assigned, the next call to func2 (nil) will call func (nil), which will result in incorrect behavior.
#+BEGIN_SRC lns
// @lnsFront: error
fn func( val:int ) {
   print( val + 1 );
}
let func2:form = func;
func2( nil );
#+END_SRC


The following are examples of substitutable and non-substitutable cases.
#+BEGIN_SRC lns
// @lnsFront: error
let form1:form = fn ( val1:stem! ) { };
let form2:form = fn ( val1:stem ) { };  // error
let form3:form = fn ( val1:stem!, val2:stem! ) { };
let form4:form = fn ( val1:stem!, val2:stem ) { }; // error
#+END_SRC


The above form1 and form3 can be assigned, and form2 and form4 cannot be assigned.


*** form declaration

As mentioned above, form can handle only some types of functions.

To handle a function that cannot be handled by form, declare the form as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
form funcform( val:int ):int;
fn sub( func:funcform ) {
   print( func( 1 ) + 1 );
}
sub( fn ( val:int ):int { return val + 1; } ); // 3
#+END_SRC


In this example, funcform is declared as form.

The form declaration makes funcform a functional type with an int type val as an argument and an int type as a return value.


** anonymous function

An anonymous function defines a function that has no name.

The following is an example of an anonymous function.
#+BEGIN_SRC lns
// @lnsFront: ok
fn sub( func:form ) {
  func( 1 );
}
sub( fn ( val:stem! ) { print( val ); } );  // 1
#+END_SRC


This example defines the anonymous function ~fn ( val:int ) { print( val ); }~.

By passing this anonymous function as an argument to sub (), the anonymous function will be executed inside sub ().

Anonymous function declarations are expressions.


** Function call

Adding ~()~ to a function object will execute that function.

The types of the formal and actual arguments of the function must match. The omitted actual argument is treated as nil. If the formal argument corresponding to the omitted actual argument is not nilable, an error will occur.


*** Omission of arguments

Check the following article for omission of arguments.

[[#defaultarg]]


** Function restrictions

LuneScript functions cannot be overloaded due to different arguments.


** summary

To summarize the LuneScript functions,
- Declare with fn
- Can have multiple return values
- Has variable length arguments and return values
- Publish functions to external modules with pub, global
- Function object types use form types and form declarations
- There is an anonymous function
- The omitted actual argument contains nil
- No function overload
Next time, I will talk about nilable.

-----


* Multi-valued return value
:PROPERTIES:
:CUSTOM_ID: multipleretval
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript supports multi-valued function return values.

For example, a function can return multiple values:
#+BEGIN_SRC lns
// @lnsFront: ok
fn func(): int,int {
   return 1, 2;
}
print( func() );  // 1 2
#+END_SRC


In the sample above, func () returns 1 and 2. This multi-valued return value is passed as it is as an argument of print ().

Multi-valued return values are very useful, but there are still few languages that have multi-valued return values. Also, the second and subsequent values of the return value often have optional implications.

Therefore, it is easy to forget the existence of the second and subsequent return values.

This can cause glitches.


** Problems due to multi-valued return values

*The following code is from Lua, not LuneScript.*
#+BEGIN_SRC lua
local function func1( txt ) 
   print( string.byte( txt:gsub( "b", "B" ) ) )
end
local function func2( txt ) 
   print( string.byte( (txt:gsub( "b", "B" )) ) )
end
func1( "abcb" ) -- 66
func2( "abcb" ) -- 97
#+END_SRC


The func1 () and func2 () output different results even though they give the same argument "abcb". Do you know why this is so?

By the way, ~txt:gsub( "b", "B" )~ is Lua's standard library that returns the string that is converted from "b" to "B" in the string txt, and ~string.byte()~ is the standard library that returns the value contained in the specified string.

Then the answer to the question.

func1 () passes the return value of ~txt:gsub( "b", "B" )~ as is to string.byte, while func2 () passes ~(txt:gsub( "b", "B" ))~ enclosed in ~()~.

As a result, func1 () passes the multi-valued value of ~txt:gsub( "b", "B" )~ to string.byte () as it is, while func2 () gives string.byte () the first multi-valued value of ~txt:gsub( "b", "B" )~. I'm just passing.

~string.byte()~ returns the character value of the index specified by the second argument if the second argument is passed. On the other hand, if the second argument is omitted, the value of the first character is returned.

And ~txt:gsub( "b", "B" )~ is a function that returns multiple values. Specifically, it returns the converted string str and the number of converted ints.

I think that anyone using Lua knows that ~txt:gsub( "b", "B" )~ is a function that returns a converted string. On the other hand, how many people recognize that this function is a multi-valued function?

And how many people, if aware, immediately realize that it leads to glitches?

Originally, you want to use only the converted character string of ~txt:gsub( "b", "B" )~ as an argument, but the function behavior may change due to the unintentionally passed multi-valued return value.

In other words, when you originally had to use only the beginning of a multi-value using ~()~ like func2 (), you may end up using the multi-value as it is like func1 ().

Remember what I wrote at the beginning here.
- ~Multi-valued return values are very useful, but there are still few languages that have multi-valued return values.~
- ~Also, the second and subsequent values of the return value often have optional implications.~
- ~Therefore, it is easy to forget the existence of the second and subsequent return values.~
Multi-valued return values are useful, but they also carry this risk.


** For LuneScript

In LuneScript, to avoid such a problem, I decided to make it explicit when dealing with multi-valued return values. If not specified, a warning will be issued.

However, it is troublesome to specify when using multi-values.

Therefore, we will limit the cases that need to be specified to the following cases.

The destination of the multi-valued return value
- If it is a function argument and the argument is optional
- When the value specified for return and the value can be omitted
In other words, if you want to assign a value directly to a variable such as let, you don't need to specify it. This is because I thought that preparing a variable to assign a value to was the same as explicitly stating that the second and subsequent arguments of multiple values would be used.


** Explicit method

The specific explicit method is as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func1(): int,int {
   return 1, 2;
}
fn func2( val1:int, val2:int!) {
   print( val1, val2 );
}

func2( func1()** );
#+END_SRC


By adding ~**~ after the function call, as in ~func1()**~ above, it is clear that the multivalued function call is being used.

-----


* Omission of arguments
:PROPERTIES:
:CUSTOM_ID: defaultarg
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

In LuneScript, nilable type arguments can be omitted when calling a function.

For example, the following function func () can be called with no arguments.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val1:int!, val2:int! ):int {
   when! val1, val2 {
      return val1 + val2;
   }
   when! val1 {
      return val1;
   }
   when! val2 {
      return val2;
   }
   return 0;
}
print( func(1,2) );  // 3
print( func(1) );    // 1
print( func() );     // 0
#+END_SRC


The problem here is that ~func(1)~ and ~func()~ cannot determine whether they intentionally omitted the argument or forgot to specify it.

Omitting arguments is a useful feature that saves you coding effort, but if you forget to specify the arguments you should have specified, you may not be able to detect them.

To avoid this, you can prevent forgetting to specify by defining the argument as follows and prohibiting the omission of the argument.
- Do not use nilable type arguments
- Define non-nilable type arguments after nilable type arguments
However, if you forbid the omission of arguments, you have the following problems:
- Coding effort will increase.
- Useless argument specifications increase, and the readability of the code deteriorates.
To avoid the problem of forgetting to specify an argument while omitting the argument, LuneScript introduces an explicit argument omission.


** Explicit omission of arguments

LuneScript uses ~##~ to omit the argument.

If you call func () above, it looks like this:
#+BEGIN_SRC lns
// @lnsFront: skip
print( func(1,2) );  // 3
print( func(1##) );  // 1
print( func(##) );   // 0
#+END_SRC


By adding ~##~ to the place where the argument is omitted, it is specified that the argument is omitted there.

If ~##~ is omitted without being specified, a warning will be issued.

This prevents the argument from being omitted and the argument from being forgotten to be specified.

Treat warnings as errors by adding the -Werror option when transcompiling.

On the other hand, if it is troublesome to specify ##, you can suppress the warning when ~##~ is omitted without specifying it by adding the --disable-checking-define-abbr option.

-----


* Variadic argument, return value
:PROPERTIES:
:CUSTOM_ID: arg
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />


** Variadic argument, return value

You can define variadic and variadic functions by using ... for arguments and return values.

The following is a sample using ....
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( ... ) : int, ... {
   let argList = [ ... ];
   let mut total = 0;
   foreach arg in argList {
      when! arg {
         total = total + arg@@int;
      }
   }
   return total, ...;
}

print( func( 1, 2, 3, 4 ) ); // 10 1 2 3 4 
#+END_SRC


In the above example, we define and execute a function func () that sums the values of the given variadic arguments and returns the sum and the given variadic arguments.

Use ... in the function body to indicate the variadic argument itself. Where ... is a value of zero or more stem !. stem! will be described later.

Callers of functions with variadic arguments can specify zero or more arguments of any type.


** Generics

You can declare variadic arguments and return values by using ... as described above.

However, since all the values of ... are treated as stem !, the type information is lost.

In the sample above, I'm passing int data to func (), but I still need unwrap and cast to access the value inside func () because the type information is lost.

To preserve the type information, use ~...<type>~ as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( ...<int> ) : int, ...<int> {
   let argList = [ ... ];
   let mut total = 0;
   foreach arg in argList {
      total = total + arg;
   }
   return total, ...;
}
print( func( 1, 2, 3, 4 ) ); // 10 1 2 3 4 
#+END_SRC


By using ~...<int>~, it is possible to handle variadic arguments and return values while retaining the int type information.

Note that func1 () and func2 () in the following sample are synonymous.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func1( ...<stem!> ) {
   print( ... );
}
fn func2( ... ) {
   print( ... );
}
func1( 1, "abc" );
func2( 1, "abc" );
#+END_SRC


-----


* nilable edition
:PROPERTIES:
:CUSTOM_ID: nilable
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain about nilable of LuneScript.


** What is nilable

LuneScript has a value of nil.

As mentioned earlier, variables of type stem can hold all types except nil.
#+BEGIN_SRC lns
// @lnsFront: error
let mut val:stem = 1;
val = 1.0;
val = "abc";
val = {};
val = [];
val = [@];
val = nil; // error
#+END_SRC


So how can we keep nil? Use stem! Instead of stem.
#+BEGIN_SRC lns
// @lnsFront: ok
let mut val:stem! = 1;
val = 1.0;
val = "abc";
val = {};
val = [];
val = [@];
val = nil; // ok
#+END_SRC


A type that can hold nil in this way is called nilable.

nilable is not only stem !, but all types except some have nilable types.

For example, int! And str! Are nilable type of int and nilable type of str.

By adding! To the end of the type name, it becomes a nilable type that can retain the original type and nil.
#+BEGIN_SRC lns
// @lnsFront: error
let mut val1:int = 1;
val1 = nil;  // error

let mut val2:int! = 1;
val2 = nil;  // ok
#+END_SRC


nil is a value that is different from any other value and is a convenient value to use as an outlier. However, the value of a variable becomes nil at an unintended timing, which often causes problems.

LuneScript achieves nil safety (null safety) by dividing it into nilable types that can hold nil and non-nilable types that cannot hold nil.


** nilable type restrictions

The nilable type has the limitation that it cannot be used as the original type as it is.

I think it's hard to tell what this explanation is, so take a look at the following example.
#+BEGIN_SRC lns
// @lnsFront: error
let val:int! = 1;
print( val + 1 );  // error
#+END_SRC


The above val is of type int nilable. And I'm running val + 1, which gives an error.

This is because val is an int !, not an int, so it cannot be treated as an int as it is.

So why nilable has such a limitation is as follows.
- nilable is a type that can hold nil
- That is, the nilable type can be nil
- To use it as the original type, you have to make sure it is not nil

You cannot assign nil to non-nilable types. And the nilable type cannot be used as the original type as it is.

This restriction can logically prevent a variable from becoming nil at an unintended timing and becoming a malfunction.

This is the nil-safe (null-safe) principle adopted by many languages.


** Comparison with nilable type

As mentioned earlier, the nilable type cannot be used as is as non-nilable.

However, it can be compared as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
fn check( val:int! ) {
   if val == 1 {
      print( "ok" );
   }
   else {
      print( "ng" );
   }
}
check( 1 ); // ok
check( 2 ); // ng
#+END_SRC


In the sample above, val is an int! And val == 1 is compared to an int. It is possible to compare nilable and non-nilable in this way.


** Conversion from nilable type to non-nilable type

The conversion from non-nilable to nilable is implicit, as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
let val:int! = 1;   // int! <-- int
#+END_SRC


On the other hand, the conversion from nilable to non-nilable must be done explicitly.

LuneScript provides the following for converting nilable to non-nilable types:
- unwrap 
- when!
- if!
- if! let
- let!
- unwrap!


*** unwrap

unwrap converts an expression of type nilable to a non-nilable type.

For example, use it as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
let val1:int! = 1;
let val2:int = unwrap val1;
#+END_SRC


In this sample val1 is an int !. By unwrapping that val1, we are converting from int! To int.

If the value to unwrap is nil as shown below, the program will make a run-time error.
#+BEGIN_SRC lns
// @lnsFront: ok
let val1:int! = nil;
let val2:int = unwrap val1;   // runtime error
#+END_SRC


The unwrap default prevents this run-time error. unwrap default specifies the value when the value to be converted is nil.

The following is an example using default.
#+BEGIN_SRC lns
// @lnsFront: ok
let val1:int! = nil;
let val2:int = unwrap val1 default 0;
#+END_SRC


In this example, val1 is nil, so a default of 0 is the result of unwrap's evaluation.

Use unwrap without default only when you know for sure that it is not nil.


*** when!

*when! Determines if the specified variable of type nilable is nil and branches.*

The following is an example of when !.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val:int!, val2:int! ): int {
   when! val, val2 {
      return val + val2;
   }
   else {
      return 0;
   }
}
print( func( 1, 2 ) );      // 3
print( func( nil, 2 ) );    // 0
print( func( 1, nil ) );    // 0
print( func( nil, nil ) );  // 0
#+END_SRC


In this example, when! Branches to int! type val and val2.
- Run ~return val + val2~ if val and val2 are non-nil
- If val or val2 is nil, execute return 0
when! Executes the first block when all the specified variables are non-nil.

*Within this block, the behavior is as follows:*
- The specified variable will be of unwrapped non-nilable type.
- The specified variable is immutable.
If any of the variables specified in when! are nil, the else block is executed. else is optional.

*Note that only variables can be specified for when !. You cannot write members or expressions.*


*** if!

*if! Determines if the specified expression is nil and branches.*

The following is an example of if !.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val:int! ): int! {
   return val;
}
fn sub( val:int! ): int {
   if! func( val ) {
      return _exp + 10;
   }  
   else {
      return 0;
   }
}
print( sub( 1 ) ); // 11
print( sub( nil ) ); // 0
#+END_SRC


In this example, func () is branched with if !.
- Run ~return _exp + 10;~ if func () is non-nil
- If func () is nil, execute return 0
*if! Executes the first block when the specified expression is non-nil. Within this block, you can access the result of the expression as _exp. At this time, _exp is of non-nilable type.*

If the expression specified in if! is nil, the else block is executed. else is optional.

By the way, if the expression specified by if! Returns multiple values, only the first return value is the target. Ignore the second and subsequent return values.

Note that if! Cannot be nested as follows.

This is because the inner if! _Exp is shadowed by the outer if! _Exp.
#+BEGIN_SRC lns
// @lnsFront: skip
   if! func( val ) {
      if! func( val ) {
         return _exp + 10;
      }  
      else {
         return 0;
      }  
   }  
#+END_SRC


To prevent this, use the following if! Let.


*** if! let

if! let is a version in which you can specify the variable name that stores the result of the expression judged by if !.

The following is a sample if! Let.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val1:int!, val2:int! ): int!, int! {
   return val1, val2;
}
fn sub( val1:int!, val2:int! ): int {
   if! let work1, work2 = func( val1, val2 ) {
      return work1 + work2;
   }  
   else {
      return 0;
   }
}
print( sub( 1, 2 ) ); // 3
print( sub( nil, 2 ) ); // 0
print( sub( 1, nil ) ); // 0
print( sub( nil, nil ) ); // 0
#+END_SRC


In this example, we are running ~if! let work1, work2 = func( val1, val2 )~.

This assigns the result of func () to work1, work2 and executes the first block if everything is non-nil. You can access work1 and work2 within this block. work1 and work2 are of non-nilable type. The scope of the variable declared with if! let is the first block.

If either is nilable, execute an else block. else is optional.


*** let!

let! declares a variable with an initial value other than nil.

Here is a sample let!
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val1:int!, val2:int! ): int!, int! {
   return val1, val2;
}
fn sub( val1:int!, val2:int! ): int {
   let mut work0 = 0;
   let! work1, work2 = func( val1, val2 ) {
      work1 = 0;
      work2 = 0;
   }
   then {
      work0 = 10;
   };     
   return work0 + work1 + work2;
}
print( sub( 1, 2 ) ); // 3
print( sub( nil, 2 ) ); // 0
print( sub( 1, nil ) ); // 0
print( sub( nil, nil ) ); // 0
#+END_SRC


In this example, we are running ~let! work1, work2 = func( val1, val2 )~.
- It declares work1 and work2 that default to the result of func ().
- If either work1 or work2 is nil, the first block is executed.
- If everything is non-nil, then execute the block. then is optional.
The let statement requires;. In the sample above,; is added as ~};~ at the end of the block then.

The first block has a limitation that must handle one of the following:
- Set values for all variables declared with let.
- Exit the scope declaring let.
In the above example, the values are set for work1 and work2, but it is OK to exit this function with return.

*The behavior when the above restrictions are not observed is undefined.*


*** unwrap!

unwrap! is a control similar to let !. The difference is that instead of declaring a variable, it assigns it to an existing variable.

The following is an example of unwrap !.
#+BEGIN_SRC lns
// @lnsFront: ok
fn test( arg:int! ) {
  let mut val = 0;

  unwrap! val = arg { print( 0 ); return; } then { val = val + 1; };
  print( val );
}
test( 1 );  // print( 2 );
test( 2 );  // print( 3 );
test( nil );  // print( 0 );
#+END_SRC


In the above example, val is an int type variable. I'm using unwrap! To assign an int! Type arg to this variable.

The above ~unwrap! val = arg { print( 0 ); return; } then { val = val + 1; };~ performs the following processing.
- If arg is nil, run ~{ print( 0 ); return; }~.
- If arg is non-nil, assign arg to val. Then execute the block.
- then is optional.


** Map type access

If you access an element of Map type data, the result will be nilable.

For example, in the following cases
#+BEGIN_SRC lns
// @lnsFront: ok
let val = { "abc": 1 };
let val2 = val.abc;
#+END_SRC


val2 is an int! instead of an int.

This is because if there is no Map type element, the evaluation result will be nil.

By the way, list and array element access is not nilable.
#+BEGIN_SRC lns
// @lnsFront: ok
let val = [ 1, 2, 3 ];
let val2 = val[ 1 ];
#+END_SRC


In the above example, val2 would be an int instead of an int !.

*The behavior when accessing val [4] is undefined.*

Be careful when accessing lists and arrays by index.

I also thought about making the index access result of the list and array nilable, but I didn't do it because I felt it was overkill.


** summary

LuneScript provides nil safety with the following specifications:
- nilable and non-nilable
- unwrap 

Next time, I will talk about classes.

-----


* closure
:PROPERTIES:
:CUSTOM_ID: closure
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript supports closures.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( mut val:int ): form {
   return fn () {
      val = val + 1;
      print( val );
   };
}

let sub1 = func( 10 );
sub1(##); // 11
sub1(##); // 12
sub1(##); // 13
sub1(##); // 14
let sub2 = func( 100 );
sub2(##); // 101
sub2(##); // 102
sub2(##); // 103
sub2(##); // 104
#+END_SRC


The above function func () is a function that creates and returns closures. This closure is a function that increments and outputs the func argument val.

In this sample, func (10) and func (100) are called, the closures generated by each are set to sub1 and sub2, and they are called four times. As a result, 11 to 14, 101 to 104 are output.

-----


* Class basics
:PROPERTIES:
:CUSTOM_ID: class1
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript supports object-oriented programming with classes.


** Class specifications

LuneScript classes support the following:
- Access control
- accessor
- Inheritance
- abstract
- override
- advertise
- Mapping
- interface  
This time, I will explain the basic class definition.


** Minimum class definition

The minimum class definition is as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
}
#+END_SRC


It defines a class called Test.

+Note that the class definition must be done in the highest scope.+

*(2019/6/24) Added support for class definition in functions. However, classes that can be exposed to the outside must be declared in the highest scope.*


*** External disclosure

To expose the class to an external module, add pub as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
pub class Test {
}
#+END_SRC



** Instance generation

Instantiation of a class uses the new operator as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
}
let test = new Test();
#+END_SRC



** Method definition

The method definition is almost the same as the function definition.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pub fn func() {
      print( __func__ );
   }
}
let test = new Test();
test.func();  // Test.func
#+END_SRC


Note that the method cannot be set to form type.

For example, the following ~sub( test.func )~ will fail.
#+BEGIN_SRC lns
// @lnsFront: error
class Test {
   pub fn func() {
      print( __func__ );
   }
}
fn sub( foo:form ) {
   foo();
}

let test = new Test();
sub( test.func );  // error
#+END_SRC


To avoid this error, create an anonymous function and pass it to sub () as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pub fn func() {
      print( __func__ );
   }
}
fn sub( foo:form ) {
   foo();
}

let test = new Test();
sub( fn() { test.func(); } );
#+END_SRC



*** Access control

There are three types of access control:
|-|-|
| kinds | meaning | 
|-+-|
| pub | External disclosure | 
| local | Published in the same module | 
| pro | Publish to subclass | 
| pri | private | 

If not specified, the default is pri.


*** self symbol

You can use the self symbol in the method.

The self symbol represents an instance of itself.

In the following example, the public method sub calls the private method func () using self.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   fn func() {
      print( __func__ );
   }
   pub fn sub() {
      self.func();
   }
}
let test = new Test();
test.sub();  // Test.func
#+END_SRC



*** Separatism

The method can be defined separately from the class definition.

The method definition above can also be written as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
}
pub fn Test.func() {
   print( __func__ );
}
let test = new Test();
test.func();  // Test.func
#+END_SRC


However, the method of the class defined in another module cannot be defined in the module being imported.


*** prototype declaration

Method definitions can also separate the actual definition by declaring only the type within the class definition.

The following example prototypes func () and separates the actual definition.

Prototyping func () allows you to call func () within sub ().
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   fn func();
   pub fn sub() {
      self.func();
   }
}
pub fn Test.func() {
   print( __func__ );
}
let test = new Test();
test.sub();  // Test.func
#+END_SRC


Of course, the prototype declaration and the actual method type must match.


*** Class method definition

Normal methods cannot be executed without an instance because they are associated with an instance, but class methods associated with a class can be executed without an instance.

To define a class method, simply add static to the method definition.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pub static fn sfunc() {
      print( __func__ );
   }
}
Test.sfunc(); // Test.sfunc
#+END_SRC


*Class methods are only available in classes defined in the highest scope.*


** Member definition

Member definitions are similar to variable definitions, with the following differences:
- Initial value cannot be set at the time of declaration
- Access control added
- accessor can be specified

The following is an example of member definition.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
   pri let val3:int;
   pub fn func() {
      print( self.val1, self.val2, self.val3 );
   }

}
let test = new Test( 1, 2, 3 );
test.func(); // 1 2 3 
#+END_SRC


Class Test has val1, val2, val3 as members.

The definition of val1 is ~pri let val1:int;~.

I don't think this is a problem because it's just a regular variable declaration with pri.

pri is access control and has the same meaning as the method definition.


** mutable

Members and methods also have mutable and immutable.

The differences between the methods mutable and immutable are as follows:
- A mutable method is a method whose members can be changed.
- Immutable methods are methods whose members cannot be changed

The following are examples of mutable members and methods.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let mut val1:int;
   pri let val2:int;
   pub fn func() {
      print( self.val1, self.val2 );
   }
   pub fn add( val:int ) mut {
      self.val1 = self.val1 + val;
   }
}
let mut test = new Test( 1, 2 );
test.func(); // 1 2
test.add( 10 );
test.func(); // 11 2
#+END_SRC


In this example, val1 is mutable and val2 is immutable. Also, func () is immutable and add () is mutable.

*Mutable methods declare mut after the argument is declared.*

The mutable method add () sets the value to member val1. It can be built without error.

So what happens if you remove the mut declaration from the method add () as follows:
#+BEGIN_SRC lns
// @lnsFront: error
class Test {
   pri let mut val1:int;
   pri let val2:int;
   pub fn func() {
      print( self.val1, self.val2 );
   }
   pub fn add( val:int ) {
      self.val1 = self.val1 + val;  // error
   }
}
#+END_SRC


The above example will result in an error.

If you try to change a member from within a method that is not mutable, you will get an error.

You will also get an error if:
#+BEGIN_SRC lns
// @lnsFront: error
class Test {
   pri let mut val:int;
   pub fn increment() mut {
      self.val = self.val + 1;
   }
   pub fn func() {
      self.increment(); // error
   }
}
#+END_SRC


In the above example, func () calls increment (), but immutable methods cannot call mutable methods.


** allmut member

As mentioned earlier, if a class member is mutable, but the instance of that class is immutable, then that member is immutable.

In the following example, the mutable member val is accessed from within the func () method, but since the func () method is immutable, val is also immutable and an error occurs.
#+BEGIN_SRC lns
// @lnsFront: error
class Test {
   pri let mut val:int;
   pub fn func() {
      self.val = self.val + 1;  // error
   }
}
#+END_SRC


mutablity is a necessary concept to prevent unintended changes in value. On the other hand, it is a very strict rule that no member can be changed from an immutable method.

If this rule is applied, it will be difficult to design in the following cases, for example.
- Consider a class Data that manages read-only data by associating it with a key
- In the Data class, define a method get () that returns the associated data when a key is given as an argument.
- The Data instance that registered all the data to be managed should be immutable to prevent unnecessary changes.
I think this is a general idea.

Then, suppose that the following specifications are added after the development progresses.
- In order to speed up the processing of the above get () method, the previous argument key and the data associated with that key are cached.
This process of "cache the previous argument key and the data associated with that key" will rewrite the data. That is, it must be mutable, not immutable.

On the other hand, Data instances have already been declared immutable in many places. In other words, it cannot be cached.

Allmut is used in such cases. allmut declares a member mutablity and is always mutable independent of the instance mutablity.

The following is a sample of allmut.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let allmut val:int;
   pub fn func() {
      self.val = self.val + 1;  // ok
   }
}
#+END_SRC


By declaring ~pri let allmut val:int;~ in this way, val will always be mutable. This makes it possible to rewrite val from the immutable method func ().

*However, allmut is just a remedy and should not be overused.*

*In particular, when performing asynchronous programming with go described later, safety is not guaranteed if allmut is present.*


** Constructor definition

The constructor can be defined with __init.

Constructors differ from method definitions in the following ways:
- The constructor name must be __init.
- The return type cannot be specified.
- The constructor definition must come after all member definitions.
- If you inherit from a class, you must first execute the constructor for that class.
  - Use super () to execute the constructor of the super class.
- The constructor must initialize all members.
  - If you do not explicitly initialize members of type nilable, the default value is nil.
- The method defined in the class can be accessed only after all the members have been initialized by the process in the constructor.
  - However, static methods and methods of super class can be accessed.
  - Also, the method can be accessed from the function object defined in the constructor.
- You cannot call a method that just declares a prototype from within the constructor.
- You cannot return in the constructor.
The following is an example of the constructor.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
   pub fn __init() {
      self.val1 = 0;
      self.val2 = 0;
   }
}
let test = new Test();
#+END_SRC


The constructor can also set initial values for immutable members.


*** Constructor arguments

The constructor can have arguments. This argument is given by the new operator.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
   pub fn __init( val1:int, val2:int ) {
      self.val1 = val1 + 10;
      self.val2 = val2 + 10;
   }
   pub fn func() {
      print( self.val1, self.val2 );
   }
}
let test = new Test( 1, 2 );
test.func(); // 11 12
#+END_SRC



*** Default constructor

If you do not define a constructor, a constructor that sets all members is automatically generated. This constructor is called the default constructor.

The default constructor has arguments to set all members. The order of the arguments is the order in which the members of the class are declared.

The following class declaration does not declare a constructor, so a default constructor is generated internally.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
}
#+END_SRC


Its default constructor is defined as:
#+BEGIN_SRC lns
// @lnsFront: skip
   pub fn __init( val1:int, val2:int ) {
      self.val1 = val1;
      self.val2 = val2;
   }
#+END_SRC


The default constructor access control is pub.


**** Default constructor for derived classes

There are two types of default constructors for derived classes: old and current.


***** Current format

The current form default constructor for a derived class Sub is:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pro let val:int;
}
class Sub extend Test {
   let val2:int;
   pub fn func() {
      print( self.val, self.val2 );
   }
}
let sub = new Sub( 1, 2 );
sub.func(); // 1, 2
#+END_SRC


Like ~new Sub( 1, 2 )~ above, it is an argument of the constructor of the super class + all members of the derived class.


***** Old format

The old-style default constructor for a derived class Sub is:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pro let val:int!;
}
class Sub extend Test {
   let val2:int;
   _lune_control default__init_old;
   pub fn func() {
      print( self.val, self.val2 );
   }
}
let sub = new Sub( 2 );
sub.func(); // nil, 2
#+END_SRC


Like ~new Sub( 2 )~ above, it will be all members of the derived class.

In the old format, all arguments of the super class must be nilable. You must also declare in ~_lune_control default__init_old;~ to use the old-style default constructor. This declaration must be declared after declaring all members.


**** Explicit default constructor

The default constructor is generated internally if you do not define a constructor.

However, this behavior becomes a problem when writing the following processing.
#+BEGIN_SRC lns
// @lnsFront: error
class Test {
   pri let mut val:int {pub};
   pub static fn create(): Test {
      return new Test( 1 );  // error
   }
}
#+END_SRC


The above creates an instance of the Test class in the create () method, but fails with no constructor declaration.

Originally, the default constructor is generated because there is no constructor definition, but since the timing to define the default constructor is done at the end of the class definition, there is no constructor in the create () method in the class definition.

In such cases, explicitly declare to use the default constructor.

Here is an example:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let mut val:int {pub};
   _lune_control default__init;
   pub static fn create(): Test {
      return new Test( 1 );
   }
}
#+END_SRC


By declaring ~_lune_control default__init;~, you can specify the use of the default constructor, and the default constructor will be generated at this time.

Note that ~_lune_control default__init;~ must be declared after all members, just like a regular constructor.


** Class members

Just as a method has a class method, a member has a class member.

Just add static to the class member definition.

Class members are initialized in the __init block.

The following is an example of a class member definition.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri static let val1:int;
   pri static let val2:int;

   __init {
      Test.val1 = 1;
      Test.val2 = 1;
   }
}
#+END_SRC


The __init block has the following restrictions:
- The __init block definition must come after all class member definitions.
  - If you do not explicitly initialize members of type nilable, the default value is nil.
- The __init block must initialize all members.
- You cannot return inside the __init block.
- You can call class methods from the __init block, but the class methods you call must be declared before the __init block.


** summary

LuneScript class definitions support the following:
- Define a class with the keyword class
- Instance creation is new
- Access control possible
- Access yourself with the self symbol
- Separate class definition and method definition
- prototype declaration
- Static class methods, class members
- The constructor is __init
- If you do not create a constructor, a default constructor will be created

Next time, I will explain how to generate an accessor.

-----


* accessor edition
:PROPERTIES:
:CUSTOM_ID: class2accessor
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain about the member accessor.


** accessor

You can easily create accessors (get, set) for members.

Here is an example:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let mut val2:int {pub,pub};
   pri let val3:int {pub};
}
let mut test = new Test( 1, 2, 3 );
print( test.$val2, test.$val3 );  // 2 3
test.set_val2( 10 );
print( test.$val2, test.$val3 );  // 10 3
#+END_SRC


In the above example, the definition of val2 is ~pri let val2:int {pub,pub};~.

This ~{pub,pub}~ defines an accessor for val2. This specifies access control for getter and setter. This specification creates the following method internally:
#+BEGIN_SRC lns
// @lnsFront: skip
pub fn Test.get_val2(): int {
   return self.val2;
}
pub fn Test.set_val2( val:int ) {
   self.val2 = val;
}
#+END_SRC


To access the getter, use $ to access it as follows:
#+BEGIN_SRC lns
// @lnsFront: skip
let mut test = new Test( 1, 2, 3 );
print( test.$val2, test.$val3 );  // 2 3
#+END_SRC


~test.$val2~ is syntactic sugar for ~test.get_val2()~.

As mentioned above, accessor is declared in the order of "getter access control" and "setter access control".

If you don't need setter, omit "setter access control".

If you don't need getters and you need setters, declare them as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let mut val1:int {non,pub};
}
#+END_SRC


This function can be used when customizing getters while automatically generating setters.

LuneScript accessors are ordinary methods. It's not something like a C # property.


** getter return type

The return type of a getter usually matches the type of its member.

For example, getter in the member list of the following Test returns a return value of type =List<int>=.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let mut list:List<int> {pub};
}
let test = new Test( [] );
foreach val in test.$list { 
   print( val );
}
#+END_SRC


Here, since the =List<int>= type is a mutable type, the value of the member list can be changed by an external operation.

However, there are many situations where you do not want to allow changes even if you allow references in external operations.

In such a case, you can control the return type of getter. There are two ways to limit it:
- Returns as an immutable type
- Return as type of super class or interface


*** Returns as an immutable type

You can create a getter that returns a mutable member as an immutable by declaring the getter as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pri let mut list:List<int> {pub&};
}
#+END_SRC


*In this example, it is =pub&=. By adding & to the getter's "access control", its return type will be immutable.*


*** Return as type of super class or interface

By declaring getter as follows, it can be returned as the type of super class or interface instead of the member type itself.
#+BEGIN_SRC lns
// @lnsFront: ok
class Val {
}
class ValSub extend Val {
}

class Test {
   pri let val1:ValSub {pub};
   pri let val2:ValSub {pub:Val};
}
let test = new Test( new ValSub(), new ValSub() );
let val1 = test.$val1;
let val2 = test.$val2;
#+END_SRC


*Here, the getter for =Test.val1= is pub, but the getter for Test.val2 is pub: Val.*

This causes =test.$val1= to return type =ValSub=, while =test.$val2= returns type Sub.


** Accessor customization

LuneScript's accessor doesn't provide any customization features like C # properties (the ability to implement non-simple setter / getter processing).

This is because LuneScript's accessor is just a simplification of method declaration, not a "separate thing" like C # properties, so if you need an accessor that does its own processing, you can create it yourself. Because.

You can also use $ if you have defined your own getter.

$ val is syntactic sugar for get_val (), not dedicated to accessors.


** summary

The LuneScript accessor has the following specifications:
- Can be declared at the same time as member declaration
- Declare in the order of getter, setter
- When accessing getters, prefix the member name with $.
- accessor is a simple method definition and is not a different concept from a method.

Next time, I will explain inheritance.

-----


* Class inheritance
:PROPERTIES:
:CUSTOM_ID: classinherit
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript supports class inheritance.


** Class inheritance

The following is an example of class inheritance.
#+BEGIN_SRC lns
// @lnsFront: ok
class Super {
   pub fn func() {
      print( __func__ );
   }
}
class Sub extend Super {
}
let sub = new Sub();
sub.func(); // Super.func
#+END_SRC


This is an example where the Sub class inherits from the Super class.

Inheritance uses extend when declaring a class to specify the parent class to inherit.

Only one class can be inherited.

If the access control of the constructor is pri, that class cannot be inherited.


*** Subclass constructor

If the parent class's constructor has arguments, the subclass must declare the constructor.

For example, in the following example, the Super class does not explicitly declare a constructor, but it internally generates a default constructor with arguments that initialize member val.
#+BEGIN_SRC lns
// @lnsFront: ok
class Super {
   pro let val:int;
}
class Sub extend Super {
   pub fn __init( val:int ){
      super( val );
   }
   pub fn func() {
      print( self.val );
   }
}
let sub = new Sub( 1 );
sub.func(); // 1
#+END_SRC


At this time, the Sub class that inherits Super has a constructor whose parent class has arguments, so it is necessary to declare the constructor of the Sub class. We also call super () to execute the constructor of the parent class Super in the constructor of the Sub class. This super () should be written on the first line.


** summary

LuneScript supports class inheritance with the following specifications:
- Only one class can be inherited
- The subclass must call the constructor of the parent class.
- Call the constructor of the parent class with super ().
- super () needs each on the first line of the constructor.

Next time, I'll talk about method overrides.

-----


* Class advertise edition
:PROPERTIES:
:CUSTOM_ID: classadvertise
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript allows transparent access to the member methods held by the class.


** advertise

I think the expression "transparent access" is difficult to convey, so I will explain it with the following example.
#+BEGIN_SRC lns
// @lnsFront: ok
abstract class Test {
   pub abstract fn foo(): str;
   pub abstract fn bar(): str;
}
class TestSub1 extend Test {
   pub override fn foo(): str {
      return "foo";
   }
   pub override fn bar(): str {
      return "bar";
   }
}
class TestSub2 extend Test {
   pri let sub:TestSub1;
   advertise sub;
   pub override fn bar(): str {
      return "hoge" .. self.sub.bar();
   }
}
fn func( test:Test ){
   print( test.foo(), test.bar() );
}
func( new TestSub1() ); // foo, bar
func( new TestSub2( new TestSub1() ) ); // foo, hogebar
#+END_SRC


TestSub2 advertises member sub.

This causes TestSub2 to internally generate a process that calls the methods (foo, bar) of the member sub as follows:
#+BEGIN_SRC lns
// @lnsFront: skip
pub override fn TestSub2.foo(): str {
   return self.sub.foo();
}
pub override fn TestSub2.bar(): str {
   return self.sub.bar();
}
#+END_SRC


TestSub2 in this example declares the method bar ().

If the method declared in this way and the method generated by advertise have the same name, the declared method takes precedence.


*** Note

*When advertising multiple members, the behavior is undefined if there is a method with the same name among the members.*


** summary
- By declaring advertise, member methods can be accessed transparently.
- Be careful when advertising multiple members
Next time, I'll talk about interfaces.

-----


* Class override
:PROPERTIES:
:CUSTOM_ID: classoverride
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript supports method overrides.


** Method override

All class methods can be overridden.

Rather, it is currently not possible to suppress override.

The following is an example of method override.
#+BEGIN_SRC lns
// @lnsFront: ok
class Super {
   pub fn func() {
      print( __func__ );
   }
}
class Sub extend Super {
   pub override fn func() {
      print( __func__ );
   }
}
fn test( obj:Super ) {
   obj.func();
}
test( new Super() ); // Super.func
test( new Sub() ); // Sub.func
#+END_SRC


Here, the Sub class overrides the func method of the Super class.

The method on the Sub class side to override must be specified with the override keyword.


** Parent class method call

Use super () to call a parent class method from an overriding subclass.

The following is an example of super ().
#+BEGIN_SRC lns
// @lnsFront: ok
class Super {
   pub fn func(): int {
      return 1;
   }
}
class Sub extend Super {
   pub override fn func(): int {
      return 10 + super();
   }
}
fn test( obj:Super ) {
   print( obj.func() );
}
test( new Sub() ); // 11
#+END_SRC


In this example, the func () method of the Super class is overridden by the Sub class. Then I'm using super () from func () in the Sub class to call the func () method in the Super class.


** abstract

You can define an abstract method that has no substance.

The following is an example of abstract.
#+BEGIN_SRC lns
// @lnsFront: ok
abstract class Super {
   pub abstract fn func(): int;
}
class Sub extend Super {
   pub override fn func(): int {
      return 10;
   }
}
fn test( obj:Super ) {
   print( obj.func() );
}
test( new Sub() );
#+END_SRC


In this example, the func () method is an abstract method that has no substance.

Note that a class with an abstract method must be declared as an abstract class.

The substance of the abstract method is defined in the inherited class. If you do not override in a class that inherits all the abstract methods of the parent class, the inherited class must be declared as abstract.

The abstract class cannot be instantiated by itself.


** summary

The specifications of the LuneScript method override / abstract are as follows:
- All methods can be overridden
- The class to override must specify override
- Use super () to call the method that is the source of the override from the method that is overriding.
- You can declare an abstract method that has no substance
- A class with an abstract method becomes an abstract class
- abstract method must be overridden in subclass
- The abstract class cannot instantiate by itself
Next time, I'll talk about class advertise.

-----


* Interface
:PROPERTIES:
:CUSTOM_ID: interface
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript does not support multiple inheritance of classes, but instead supports interfaces.


** interface

If you're using Java or C #, you're probably familiar with it, but you can think of an interface as a class with limited functionality.

Specifically, interfaces differ from classes in the following ways:
- The declaration is interface, not class.
- I can't have a member.
- All methods are abstract. Therefore, an instance cannot be created by the interface alone.
- Classes that implement the interface add () to extend
- Classes can implement multiple interfaces
- Do not add override to the method of the class that implements the interface.
The following is an example of the interface.
#+BEGIN_SRC lns
// @lnsFront: ok
interface IF {
   pub fn func();
}
class Test extend (IF) {
   pub fn func() {
      print( __func__ );
   }
}
fn sub( obj:IF ) {
   obj.func();
}
sub( new Test() ); // Test.func
#+END_SRC


This example defines an interface IF.

The following is an example of a class that implements the two interfaces.
#+BEGIN_SRC lns
// @lnsFront: ok
interface IF1 {
   pub fn func1();
}
interface IF2 {
   pub fn func2();
}
class Test extend (IF1,IF2) {
   pub fn func1() {
      print( __func__ );
   }
   pub fn func2() {
      print( __func__ );
   }
}
fn sub( obj1:IF1, obj2:IF2 ) {
   obj1.func1();
   obj2.func2();
}
let mut test = new Test();
sub( test, test ); // Test.func Test.func2
#+END_SRC


If you want to implement multiple interfaces, declare extend followed by ().

By the way, as a limitation when implementing multiple interfaces, if there are methods with the same name but different types in the interface to be implemented as follows, an error will occur.
#+BEGIN_SRC lns
// @lnsFront: error
interface IF1 {
   pub fn func():int;
}
interface IF2 {
   pub fn func():str;
}
class Test extend (IF1,IF2) { // mismatch IF1.func, IF2.func
}
#+END_SRC


Note that the current interface specifications do not support method default processing.


** summary

LuneScript does not support multiple inheritance of classes, but instead supports interfaces.

Next time, I'll talk about Mapping.

-----


* mapping edition
:PROPERTIES:
:CUSTOM_ID: classmapping
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript supports mutual conversion between class instances and maps.


** mapping

LuneScript supports mutual conversion between class instances and map objects.

Specifically, you can:
- Creating a map object from an instance of a class
- Creating an instance of a class from a map object
This allows you, for example, to generate JSON data from an instance of a class, or vice versa.

This feature is called mapping.

To use mapping, you need to declare Mapping as the interface to implement when declaring the class.

Here is an example:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test extend (Mapping){
   let val1:int {pub};
   let val2:str {pub};
}
let test = new Test(1, "abc" );
let map = test._toMap();
print( map.val1, map.val2 ); // 1 abc
let test2 = unwrap Test._fromMap( map );
print( test2.$val1, test2.$val2 ); // 1 abc
#+END_SRC


In the above example, the class Test declares a Mapping implementation.

This will generate the following method internally:
- fn _toMap():&Map<str,&stem>
- static fn _fromMap(map:&Map<str,&stem>):Test!,str!
_toMap () is a method that creates a map object from an instance, and _fromMap () is a class method that creates an instance from a map object.

Note that _fromMap () returns nil if the map object does not meet the conditions for instantiation.

Specifically, if you pass the following map object to _fromMap () in Test above, an instance will be created, but
#+BEGIN_SRC js
{
   "val1": 1,
   "val2": "abc"
}
#+END_SRC


If you pass the following map object, no instance will be created.
#+BEGIN_SRC js
{
   "val1": 1,
   "val2": 2
}
#+END_SRC


In the case of the above map object, val2 should be str, but it is int and it becomes inconsistent.

Also note that _fromMap () checks for member type inconsistencies, but not ranges.

For example, even if it is a value that cannot be taken originally, it will be instantiated as long as it has a type. However, for enums, if the value of the map object is not defined in the enum, it returns nil.


*** Mapping restrictions

Classes that implement mapping have the following restrictions on their members:
- If you have a class instance as a member, the class must be mappable.
- If you have a map object as a member, the key must be int, real, or str.


** summary

Mapping makes it easy to generate JSON data from an instance of a class.

Next time, I'll talk about the nil conditional operator.

-----


* generics edition
:PROPERTIES:
:CUSTOM_ID: generics
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This section describes the generics that LuneScript supports.

LuneScript initially supported Generics only for built-in Lists / Arrays / Maps, but it also supports Generics for user-defined functions and classes.


** function

The function Generics is declared as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
fn func<T>( val:T ) : Set<T> {
   return (@ val);
}
#+END_SRC


As you can see from the above sample, when declaring a function, declare it with the function name + ~<Temporary parameter>~.

Where func <T> () is a function that creates a Set <T> with an argument value.

You can specify multiple formal parameters.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func<T1,T2>( val1:T1, val2:T2 ) : Set<T1>, List<T2> {
   return (@ val1), [ val2 ];
}
#+END_SRC



** nilable, mutable

Formal parameters have the same concept of nilable and mutable as regular types.

This allows you to write the following process:
#+BEGIN_SRC lns
// @lnsFront: error
fn func1<T>( val:T ) : T {
   return val;
}
fn func2<T>( val:T ) : &T {
   return val;
}
fn func3<T>( val:T ) : T! {
   return val;
}
let mut test1 = func1( [ 1, 2 ] );
test1.insert( 1 );
let mut test2 = func2( [ 1, 2 ] );
test2.insert( 1 ); // error test2 is not mutable
let mut test3 = func3( [ 1, 2 ] );
test3.insert( 1 ); // error test3 is nilable
#+END_SRC

- func1 returns the argument as is of type T.
- func2 returns the argument as immutable type & T.
- func3 returns the argument as nilable type T !.
This allows test1.insert (), but test2 and test3 will result in a compilation error.

One thing to keep in mind here is that you can use nilable and mutable when using formal parameters, but not when declaring formal parameter names. That is, the following ~func1<T!>~ will result in an error.
#+BEGIN_SRC lns
// @lnsFront: error
fn func1<T!>( val:T ) : T {
   return val;
}
#+END_SRC


Also, nilable is not available for formal parameters. That is, you will get an error if:
#+BEGIN_SRC lns
// @lnsFront: error
fn func1<T>( val:T ) : T {
   return val;
}
let val:int! = 1;
print( func1( val ) ); // error type mismatch
#+END_SRC


In this example, func1 (val) gives int! to func1 (), but ~func1<T>(val:T)~'s val is T and the formal parameter is an error because nilable is not available.

If you want to do this, declare it as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
fn func1<T>( val:T! ) : T {
   return unwrap val;
}
let val:int! = 1;
print( func1( val ) ); // ok
#+END_SRC


That is, ~fn func1<T>( val:T! )~ declares that the argument of func1 () is nilable.

However, it can be inconvenient if you can't handle the value of nilable. Nilable <T> is available for such cases.

This will be explained separately at a later date.


*** sample

By using Generics, you can write the following processing.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func<T>( val:T ) : Set<T> {
   return (@ val);
}
foreach val in func( "foo" ) {
   print( val .. "bar" );  // foobar
}
foreach val in func( 1 ) {
   print( val + 100 );  // 101
}
#+END_SRC


func ("foo") produces a Set <str> of (@ "foo"), and func (1) produces a Set <int> of (@ 1).

As you can see from the above, the type parameters are determined according to the called argument.


**** effect

By using stem instead of generics, you can write similar processing as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val:stem ) : Set<stem> {
   return (@ val);
}
foreach val in func( "foo" ) {
   print( val@@str .. "bar" );
}
foreach val in func( 1 ) {
   print( val@@int + 100 );
}
#+END_SRC


However, in this case, type information such as str and int will be rounded to stem. You will need to cast ~@@str~ or ~@@int~ as it will be rounded to stem.

Casting is inconvenient and above all very dangerous.

By using Generics, you can access it safely without using a cast.


** class

The generics for the class are declared as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test<T> {
   let val:T;
   pub fn func() : List<T> {
      return [ self.val ];
   }
}
#+END_SRC


For classes, specify formal parameters when specifying the name of the class declaration.

When declaring a method outside the class declaration, it is not necessary to declare a formal parameter as shown below.
#+BEGIN_SRC lns
// @lnsFront: skip
pub fn Test.func2() : Set<T> {
   return (@ self.val );
}
#+END_SRC


Create an instance of the Generics class as follows:
#+BEGIN_SRC lns
// @lnsFront: skip
let test = new Test<str>( "abc" );
#+END_SRC


If all formal parameters are used in the arguments of the constructor, it is possible to omit the actual type parameters as follows.
#+BEGIN_SRC lns
// @lnsFront: skip
let test = new Test( "abc" );
#+END_SRC


*The interface does not support generics.*


** Method

A method can have both a class formal parameter and a method formal parameter.

In the following sample, the Test.func () method has a class formal parameter T and a method formal parameter T2.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test<T> {
   let val:T;
   pub fn func<T2>(val:T2) : Map<T,T2> {
      return { self.val: val };
   }
}
let test = new Test( "abc");
foreach val, key in test.func( 1 ) {
   print( key .. "xyz", val + 10 );
}
foreach val, key in test.func( "ABC" ) {
   print( key .. "xyz", val .. "XYZ" );
}
#+END_SRC



** Type parameter constraints

All types except nil can be specified for the actual type parameter.

For this reason, processing for values of formal parameter types within generics classes and functions is limited to type-independent operations such as ~==~ and =~==.

If this is the case, you will not be able to write effective processing in the processing in Generics.

Therefore, we will use the constraint of the type parameter.


*** sample

The following is a sample type parameter constraint.

Here, by declaring ~class Test<T:Val>~, the formal parameters of the Test class are limited to the Val class.

This allows you to call the Val class method func () on the value of val within the Test.sub () method.
#+BEGIN_SRC lns
// @lnsFront: ok
abstract class Val {
   pub abstract fn func(): str;
}
class Test<T:Val> {
   let val:T;
   pub fn sub() {
      print( "this is " .. self.val.func() );
   }
}
#+END_SRC


The following is a sample using this Test class.
#+BEGIN_SRC lns
// @lnsFront: ok
abstract class Val {
   pub abstract fn func(): str;
}
class Test<T:Val> {
   let val:T;
   pub fn sub() {
      print( "this is " .. self.val.func() );
   }
}

class Val1 extend Val {
   pub override fn func(): str {
      return "val1";
   }
}

class Val2 extend Val {
   pub override fn func(): str {
      return  "val2";
   }
}

fn func1( test:Test<Val1> ) {
   test.sub();
}
fn func2( test:Test<Val2> ) {
   test.sub();
}

func1( new Test( new Val1() ) );  // this is val1
func2( new Test( new Val2() ) );  // this is val2
#+END_SRC


The configuration of this sample is as follows.
- The Val1 and Val2 classes are classes that inherit from the Val class.
- The func () function has a Test type argument test and calls the test.sub () method.
- ~new Test( new Val1() )~ and ~new Test( new Val2() )~ instantiate the test type of the actual parameters of Val1 and Val2 and call the func () function.
As a result, Val1.func () and Val2.func () are called and ~this is val1~ and ~this is val2~ are output.

Note that T in ~Test<T:Val>~ must be Val, so a specification such as ~new Test<"abc">~ will result in an error.

Because "abc" is of type str, str is not of type Val.

By the way, the syntax of the formal parameter constraint is the same as the extend of class.

That is, it looks like this:
#+BEGIN_SRC lns
// @lnsFront: skip
class Hoge<T:SuperClass(IF,...)> {
}
#+END_SRC


Where SuperClass is a class and IF is an interface.

SuperClass and IF can be omitted respectively.


** Mapping of generics class

LuneScript has a Mapping feature that transforms an instance of a class into a Map object.

For mapping, refer to the following article.

[[#classmapping]]

To map a class, that class must extend the Mapping interface.

The following is a simple example.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test<T> extend (Mapping) {
   let txt:str;
   pub fn func( val:T ) {
      print( self.txt, val );
   }
}

let test = new Test<int>( "hoge" );
let map = test._toMap();
if! let test2 = Test<int>._fromMap( map ) {
   test2.func( 1 );
}
#+END_SRC


The Test <T> class extends Mapping. This allows the Test <T> class to be mapped.

In the above case, nothing is different from the case of a regular class that is not generics. This is because it is not included in the members of the formal parameter type.

If you have a member of the formal parameter type as shown below, an error will occur.
#+BEGIN_SRC lns
// @lnsFront: error
class Test<T> extend (Mapping) {
   let txt:T;
}
#+END_SRC


This is because in order for a class to extend Mapping, all members held by that class must be able to map, whereas the formal parameter T, which is the type of member txt, is of all types except nilable. Because it can be.

To avoid this, set a Mapping constraint on the formal parameter used as the member type.

Specifically, it is ~Test<T:(Mapping)>~ as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
class Test<T:(Mapping)> extend (Mapping) {
   let val:T {pub};
}

let test = new Test( "abc" );
let map = test._toMap();
if! let test2 = Test<str>._fromMap( map ) {
   print( test2.$val .. "xyz" );
}
#+END_SRC


This allows the Generics class to be mapped.

-----


* nil conditional operator edition
:PROPERTIES:
:CUSTOM_ID: nilcond
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain the nil conditional operator of LuneScript.


** Map access

For example, if you have the following Map data,
#+BEGIN_SRC lns
// @lnsFront: ok
let json = {
   "lv1": {
      "lv2": {
         "lv3": {
            "lv4": { 
               "lv5": {
                  "val": 1
               }           
            }        
         }     
      }  
   }
};
#+END_SRC


To access the val of lv5, you need to do the following:
#+BEGIN_SRC lns
// @lnsFront: skip
if! let lv1 = json.lv1 {
   if! let lv2 = lv1.lv2 {
      if! let lv3 = lv2.lv3 {
         if! let lv4 = lv3.lv4 {
            if! let lv5 = lv4.lv5 {
               print( lv5.val );
            }        
         }     
      }  
   }  
}
#+END_SRC


Or you need to unwrap it like this:
#+BEGIN_SRC lns
// @lnsFront: skip
print( (unwrap (unwrap (unwrap (unwrap (unwrap json.lv1).lv2).lv3).lv4).lv5).val );
#+END_SRC


Either way, it's not good.

The nil conditional operator can be used to easily perform such nested nil checks.


** nil conditional operator

Accessing the val of lv5 above using the nil conditional operator gives:
#+BEGIN_SRC lns
// @lnsFront: skip
print( json.lv1$.lv2$.lv3$.lv4$.lv5$.val );
#+END_SRC


It's pretty refreshing.

The nil conditional operator, specified immediately after an expression in nilable, controls whether the expression in nilable is nil and whether subsequent expressions are executed.

If the evaluation result of an expression of nilable is not nil, the subsequent expression is executed, and if the evaluation result of the expression of nilable is nil, the result of the expression is nil without executing the subsequent expression.

To access the list, use ~$[~, and to call the function, use ~$(~.

Here is an example:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pub let val:List<int>;
   pub fn func():int {
      return 100;
   }
}
fn sub( test:Test! ) {
   print( test$.val$[1], test$.func$() );
}
sub( new Test( [ 1, 2 ] ) ); // 1 100
sub( nil ); // nil nil
#+END_SRC


In the above example, the val list of the Test class and func are accessed using the nil conditional operator in the sub () function. This allows you to access without unwrapping.


** Note

Whenever you use nil conditional access, the evaluation result is nilable.

Here is an example:
#+BEGIN_SRC lns
// @lnsFront: ok
class Test {
   pub let val:int;
}
fn sub( test:Test! ) {
   if! test$.val {
      print( _exp + 1 );
   }
}
sub( new Test( 10 ) ); // 11
#+END_SRC


In the above case, the val of the Test class is an int.

In the sub function in the above example, an instance of the Test class of type nilable is accessed by ~test$.val~. At this time, the evaluation result of ~test$.val~ is int! Instead of int.


** summary

Nil conditional access makes it easy to unwrap deep nests.

Next time, I'll talk about module management.

-----


* import / provide
:PROPERTIES:
:CUSTOM_ID: import
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain the module management of LuneScript.


** module

Module management in LuneScript is basically the same as Lua.

The differences from Lua are listed below.
- Unless otherwise declared, each file is a module.
- The extension of the file name is .lns, and the name excluding .lns is the module name.
- init.lns is not supported.
- LuneScript built-in keywords (class, etc.) file names are not supported.
To be on the safe side, here's what LuneScript and Lua have in common with module management.
- The package search path is controlled by the path information stored in package.path.
- Module names are separated by. To represent subdirectories.
- Does not support cross-reference modules.

For example, the module name in the file hoge / test.lns would be hoge.test.

As you can see from the above,. Cannot be included in the directory name and file name (other than the extension).

The LuneScript source is a module without any declaration.

For example, Test.lns like this would be a module with the func function.
#+NAME: Test.lns
#+BEGIN_SRC lns
// @lnsFront: ok
// Test.lns
fn func(): str, str {
   return __mod__, __func__;
}
#+END_SRC


However, a pub declaration is required to expose the information in the module to the outside world.

Specifically, you need to declare pub as follows:
#+NAME: Test.lns
#+BEGIN_SRC lns
// @lnsFront: ok
// Test.lns
pub fn func(): str, str {
   return __mod__, __func__;
}
#+END_SRC


This makes the func () function of this module available externally.


** import

import declares the use of external modules.

Declare import at the beginning of the module.

*(2019/6/24) Added support for declaring inside functions.*

To use the above Test.lns, do the following:
#+BEGIN_SRC lns
// @lnsFront: skip
import Test;

print( Test.func() ); // @Test   Test.func
#+END_SRC


In the above example, Test.func () calls func () in the Test module.

By importing in this way, you can access the symbols declared by the external module in the pub.

When importing work / Test.lns, it will be as follows.
#+BEGIN_SRC lns
// @lnsFront: skip
import work.Test;

print( Test.func() ); // work.Test	Test.func
#+END_SRC


As you can see from the above example, to access the imported module, use the name after the last. In the module name. In the case of the above example, work.Test is imported, so access it with the symbol Test.

When importing multiple modules, if the access names are the same (for example, when importing foo.bar and hoge.bar), use as described below.


*** import as

import as specifies the access name after import.

For example, if the above work.Test is foo with import as, it will be as follows.
#+BEGIN_SRC lns
// @lnsFront: skip
import work.Test as foo;

print( foo.func() ); // work.Test	Test.func
#+END_SRC



** Require () from Lua a module transcompiled with LuneScript

LuneScript is a Lua transcompiler. In other words, modules written in LuneScript can be used by require () from Lua.

In this case, the module written in LuneScript is always a table.

For example, the transcompiled Lua source for Test.lns above looks like this:
#+BEGIN_SRC lua
--work/Test.lns
local _moduleObj = {}
local __mod__ = 'work.Test'
if not _lune then
   _lune = {}
end
local function func(  )
   local __func__ = 'Test.func'

   return __mod__, __func__
end
_moduleObj.func = func
return _moduleObj
#+END_SRC


As you can see from the source above, if you require () this source from Lua, you will get _moduleObj.

On the other hand, Lua's require () can return any value. And you may expect this behavior.

This means that Lua modules transcompiled with LuneScript cannot be used by directly requiring from Lua, which expects to get objects other than tables.

The mechanism that enables compatibility with such Lua modules is provide.


** provide

provide provides compatibility with existing Lua modules.

*Avoid using it if compatibility with the Lua module is not required.*

The following is an example of provide.
#+BEGIN_SRC lns
// @lnsFront: ok
// Test.lns
pub fn func(): str, str {
   return __mod__, __func__;
}

provide func;
#+END_SRC


In the above example, provide is given the function func ().

As a result, the transcompiled result of this Test.lns module looks like this:
#+BEGIN_SRC lua
--work/Test.lns
local __mod__ = 'work.Test'
if not _lune then
   _lune = {}
end
local function func(  )
   local __func__ = 'Test.func'

   return __mod__, __func__
end
return func
#+END_SRC


As you can see from the above, if you require () this module from Lua, you get the function func.

By using provide in this way, you can generate a module that is compatible with existing Lua modules.

*Note that only symbols can be specified for provide. You cannot specify an immediate value.*


** summary

LuneScript makes it easy to create modules and is compatible with existing Lua modules.

Next time, I'll show you how to leverage an existing Lua module from LuneScript.

-----


* require / module edition
:PROPERTIES:
:CUSTOM_ID: require
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain how to handle Lua modules from LuneScript.


** require

Use require () when working with Lua modules.

The specification of require () is the same as Lua, but the return value is stem. That is, it has no type information. Casting is required as appropriate.


** module

As mentioned above, require () returns stem.

Since stem has no type information, it is not easy to use.

So we use the module declaration.

For example, if you have a Lua module Test.lua like this:
#+BEGIN_SRC lua
local mod = {}
mod.val = 1;
function mod.func1( val )
   return val + 10
end
function mod:func2( val )
   return self.val + val
end
return mod
#+END_SRC


This Test.lua module has the following elements:
- int member val
- Function func1
- Method func2
*The function mentioned here is called with. Like obj.func1 (), and the method is called with: like obj: func1 () when called.*

The module declaration that utilizes this Test.lua module is as follows.
#+BEGIN_SRC lns
// @lnsFront: skip
module Test require 'Test'
{
   pub static let val:int;
   pub static fn func1( val:int ):int;
   pub fn func2( val:int ):int;
}
print( Test.val, Test.func1( 10 ), Test.func2( 20 ) ); // 1 20 21
#+END_SRC


First, module Test of module Test require'Test'declares the module name Test. Think of the module name as a regular class name. I used the same module name as Lua here, but it doesn't matter if it has a different name.

module Test require'Test' require'Test' specifies which module to load. Here we specify that the Test module is loaded.

The rest is the same as a regular class declaration.

The module declared as module is accessed by the module name.
#+BEGIN_SRC lns
// @lnsFront: skip
print( Test.val, Test.func1( 10 ), Test.func2( 20 ) );
#+END_SRC



*** LuneScript is not builtin lua API

LuneScript has built-in the minimum required Lua standard API for self-hosting.

You cannot directly access Lua's standard APIs that are not built-in (for example, =math.pi=).

To access APIs that are not built-in, you can make them available by declaring a module as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
module Math require 'math' {
   pub static let pi:real;
   pub static fn sin(x:real):real;
}

print( Math.pi, Math.sin(Math.pi/2) );  // 3.1415926535898	1.0
#+END_SRC



*** Module declaration restrictions

The module declaration has the following restrictions:
- Modules cannot be inherited to declare new classes
- Do not check the consistency between the required Lua module and the declared module
  - Behavior in case of inconsistency is undefined


** summary
- LuneScript can handle Lua modules.
- There are two ways to work with Lua modules: require () and module declarations.
- There are restrictions on the module declaration.

Next time, I'll talk about macros.

-----


* Semi-automatic generation of glue code
:PROPERTIES:
:CUSTOM_ID: glue
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

There are two cases of Lua's external modules:
- Case consisting of Lua script
- Case of using Native Library such as C
To use the Native Library from Lua, you need a glue that bridges the interface for Lua.

LuneScript has the ability to generate this glue semi-automatically.

The LuneScript glue automatic generation function is not a function that automatically generates Lua glue from a source such as C / C ++ represented by swig, but a function that automatically generates the glue code of a module declared as a module in LuneScript.
#+BEGIN_SRC txt
swig:		C/C++ ==> glue
LuneScript:	Lns   ==> glue
#+END_SRC



** how to use

To generate glue, specify the glue keyword when defining the module.

The following is a sample that generates glue for the test.ext module.
#+BEGIN_SRC lns
// @lnsFront: skip
module External require "test.ext" glue 'hoge_' {
   pub static fn create( val:int ): External;
   pub fn add( val:int ):int;
}

let obj = External.create( 1 );
print( obj.add( 10 ) ); // 11
#+END_SRC


The "test.ext" and'hoge_'specified here are used when generating glue.

To generate glue code from this source, run the following command:
#+BEGIN_SRC txt
$ lua lune/base/base.lua src.lns glue [dir]
#+END_SRC


Where src.lns is the source of the input and dir is the path of the destination directory.

This command generates two glue codes:
- test_ext_glue.c
- test_ext_glue.h  
test_ext_glue.c has the following contents:
#+BEGIN_SRC c
#include "test_ext_glue.h"
static int lns_glue_create( lua_State * pLua );
static int lns_glue_add( lua_State * pLua );
static const char * s_full_class_name = "test_ext";
static const luaL_Reg s_lua_func_info[] = {
  { "create", lns_glue_create },
  { NULL, NULL }
};
static const luaL_Reg s_lua_method_info[] = {
  { "add", lns_glue_add },
  { NULL, NULL }
};
void * lns_glue_get_test_ext( lua_State * pLua, int index )
{
    return luaL_checkudata( pLua, index, s_full_class_name);
}

static void lns_glue_setupObjMethod(
    lua_State * pLua, const char * pName, const luaL_Reg * pReg )
{
    luaL_newmetatable(pLua, pName );
    lua_pushvalue(pLua, -1);
    lua_setfield(pLua, -2, "__index");

#if LUA_VERSION_NUM >= 502
    luaL_setfuncs(pLua, pReg, 0);

    lua_pop(pLua, 1);
#else
    luaL_register(pLua, NULL, pReg );

    lua_pop(pLua, 1);
#endif
}

void * lns_glue_new_test_ext( lua_State * pLua, size_t size )
{
    void * pBuf = lua_newuserdata( pLua, size );
    if ( pBuf == NULL ) {
        return NULL;
    }
    
#if LUA_VERSION_NUM >= 502
    luaL_setmetatable( pLua, s_full_class_name );
#else
    luaL_getmetatable( pLua, s_full_class_name );
    lua_setmetatable( pLua, -2 );
#endif

    return pBuf;
}

int luaopen_test_ext( lua_State * pLua )
{
    lns_glue_setupObjMethod( pLua, s_full_class_name, s_lua_method_info );

#if LUA_VERSION_NUM >= 502
    luaL_newlib( pLua, s_lua_func_info );
#else
    luaL_register( pLua, s_full_class_name, s_lua_func_info );
#endif
    return 1;
}
static int lns_glue_add( lua_State * pLua ){
  int val = 0;
  val = luaL_checkinteger( pLua, 2 );
  return hoge_add( pLua, val);
}
static int lns_glue_create( lua_State * pLua ){
  int val = 0;
  val = luaL_checkinteger( pLua, 1 );
  return hoge_create( pLua, val);
}
#+END_SRC


This test_ext_glue.c is the code that registers the create () and add () methods defined in LuneScript with Lua.

The functions corresponding to create () and add () defined in LuneScript are lns_glue_create () and lns_glue_add ().

*Note that this function calls hoge_create () and hoge_add (), respectively. This hoge_ uses the glue string specified in the LuneScript code.*

test_ext_glue.h has the following contents.
#+BEGIN_SRC c
#include <lauxlib.h>
extern int hoge_create( lua_State * pLua, int val );
extern int hoge_add( lua_State * pLua, int val );
extern int luaopen_test_ext( lua_State * pLua );
extern void * lns_glue_get_test_ext( lua_State * pLua, int index );
extern void * lns_glue_new_test_ext( lua_State * pLua, size_t size );
#+END_SRC


Here, hoge_create () and hoge_add () have the following types.
#+BEGIN_SRC c
extern int hoge_create( lua_State * pLua, int val );
extern int hoge_add( lua_State * pLua, int val );
#+END_SRC


The first argument lua_State * and the return value int have the same meaning as Lua's glue interface.

The second argument, int, contains the argument of the method defined in LuneScript. This is because test_ext_glue.c, which is automatically generated by LuneScript, takes the value from the Lua stack and sets the value.

In Lua glue, you need to call the API to get the function arguments, but if you generate glue with LuneScript, you are running the API to get the function arguments in the glue code. This eliminates the need for the user to call the API to get the function arguments.

However, if the argument type of the method defined on the LuneScript side is other than int (int!), Real (real!), Str (str!), The glue generated by LuneScript cannot handle it, so a separate user It is necessary to take measures on the side.

Also, the return value of glue needs to be controlled by the user in the same way as Lua's glue interface.

The test.ext module is completed by defining hoge_create () and hoge_add () separately.

For example, define as follows (glue.c).
#+BEGIN_SRC c
// glue.c
#include <test_ext_glue.h>

typedef struct {
    int val;
} glue_t;

int hoge_create( lua_State * pLua, int val )
{
    glue_t * pGlue = (glue_t*)lns_glue_new_test_ext( pLua, sizeof( glue_t ) );
    pGlue->val = val;
    return 1;
}

int hoge_add( lua_State * pLua, int val )
{
    glue_t * pGlue = lns_glue_get_test_ext( pLua, 1 );
    lua_pushinteger( pLua, val + pGlue->val );
    return 1;
}
#+END_SRC


By the way, the build is done as follows.
#+BEGIN_SRC txt
$ gcc -std=c99 -fPIC -shared -o test/ext.so glue.c test_ext_glue.c 
#+END_SRC


-----


* Collaboration with Lua
:PROPERTIES:
:CUSTOM_ID: lua
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript can execute Lua code.

However, there are a few things to keep in mind when running Lua code.

The following are some things to keep in mind when running Lua code on LuneScript.


** Run Lua code

In LuneScript, you can execute Lua code from within LuneScript by using the _load () function and so on.

The _load () function has basically the same specifications as lua's load () function.

A sample is shown below.
#+BEGIN_SRC lns
// @lnsFront: ok
let code = ```
return { val1 = 10, val2 = 20 }
```;
let loaded, err = _load( code, nil );
when! loaded {
   if! let obj = loaded( ## ) {
      forsort val, key in obj@@Map<str,int> {
         print( key, val + 100 ); 
      }
   }
} else {
   print( err );
}
#+END_SRC


This sample outputs the following values:
#+BEGIN_SRC txt
val1	110
val2	120
#+END_SRC


This is the result of enumerating the Lua tables returned by Lua code ~return { val1 = 10, val2 = 20 }~ with forsort and outputting them with =print( key, val + 100 );=.

The above sample is almost the same as the LuneScript code below.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func():Map<str,int> {
   return { "val1":10, "val2":20 };
}
forsort val, key in func() {
   print( key, val + 100 ); 
}
#+END_SRC


In this way, LuneScript and Lua can work together.


** Lua → LuneScript data conversion

When you execute Lua code from LuneScript, the result of executing that Lua code is of type Luaval.

The Luaval type is a type that holds the data in the Lua code, and the data in the Lua code that corresponds to the type T of LuneScript is =Luaval<T>=.

For example, ~{ val1 = 10, val2 = 20 }~ in the above sample corresponds to Map <str, int> of LuneScritp and becomes =Luaval<Map<str,int>>=.

*Note that when transcompiling from LuneScript to Lua, Luaval <T> will be the exact type of T. When transcompiling from LuneScript to Lua, you don't need to be aware of Luaval <T> because even if you explicitly declare it as Luaval <T>, it will be converted internally as T.*

When converting from LuneScript to a language other than Lua (currently convertible to go), Luaval <T> and T are treated differently, so you need to be aware of Luaval <T> when converting to something other than Lua. ..

*By specifying "--valid-luaval" as the transcompile option, Luaval <T> and T are managed separately when transcompiling to Lua.*

The above sample can be rewritten to use func () with an argument of =Luaval<Map<str,int>>= as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func(map:Luaval<&Map<str,int>>) {
   forsort val, key in map {
      print( key, val + 100 ); 
   }
}
let code = ```
return { val1 = 10, val2 = 20 }
```;
let loaded, err = _load( code, nil );
when! loaded {
   if! let obj = loaded( ## ) {
      func( obj@@Map<str,int> );
   }
} else {
   print( err );
}
#+END_SRC


*Also, for the Luaval type data of Map like the above sample, you can refer to the data in Map by element access using foreach or =[]= like Map of LuneScript. However, you can refer to it, but you cannot change it.*


*** Mutual convertible type

If the data types in your Lua code are:
- int, real, bool, str
- Nilable above
*For str, there is an overhead proportional to the string length.*


** Luaval type cast

There are restrictions on casting Luaval types.

The above sample passes =obj@@Map<str,int>= as an argument to func as follows:
#+BEGIN_SRC lns
// @lnsFront: skip   
   if! let obj = loaded( ## ) {
      func( obj@@Map<str,int> );
   }
#+END_SRC


This is an operation that casts obj to Map <str, int>, where the type of obj is Luaval <stem>, and if you cast it to Map <str, int>, the cast type will be It becomes Luaval <Map <str, int >>.

When it is possible to cast from a type T1 to type T2, if you instruct to cast from Luaval <T1> to T2, the cast result will be Luaval <T2>.

Also, the next cast is not possible.
- Cast from T1 to Luaval <T1>
- Cast from Luaval <T1> to T1
Specifically, you cannot cast from Map <str, int> to Luaval <Map <str, int >>.

However, the stem type is exceptionally capable of mutual casting with Luaval.

It is possible to cast from Luaval type to non-Luaval type by going through stem type as follows.
: Luaval => stem => Luaval


*The behavior when casting to a different type is undefined.*


*** expandLuavalMap

The data in the collection in the Lua code is treated as Luaval.

For example, Map type data is Luaval <Map>. Map type and Luaval <Map> type data are not compatible and cannot be assigned.

The following functions are provided as a way to expand the Luaval type data of this collection as LuneScript values.
: fn expandLuavalMap( Luaval<stem>! ) : stem!;


When you use this function, the following processing is applied.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func(map:Luaval<&Map<str,int>>) {
   forsort val, key in map {
      print( key, val + 100 ); 
   }
}
fn func2(map:&Map<str,int>) {
   forsort val, key in map {
      print( key, val + 100 ); 
   }
}
let code = ```
return { val1 = 10, val2 = 20 }
```;
let loaded, err = _load( code, nil );
when! loaded {
   if! let obj = loaded( ## ) {
      func( obj@@Map<str,int> );
      if! let map = expandLuavalMap( obj ) {
         func2( map@@Map<str,int> );
      }
   }
} else {
   print( err );
}
#+END_SRC


In this sample, we have a func () function that enumerates Luaval <& Map <str, int >> and a func2 () function that enumerates & Map <str, int>.

Expand Luaval type data with expandLuavalMap () before calling func2 () and cast it to Map <str, int> instead of Luaval <Map <str, int >>, Map <str, Treated as int>.

Note that expandLuavalMap () creates a clone that expands the Luaval type data given by the argument.


** Luaval type conversion

The Luaval type that holds a nilable type T! Is Luaval <T> !. It cannot be Luaval <T!>.

Also, the Immutable of Luaval <T> becomes Luaval <& T>.


** Luaval type function, Luaval type object method

The functional type Luaval has its argument and return value of Luaval type.

For example, the argument proc of the func function in the following sample is from of type Luaval <Process>, the argument of this Form is Luaval <& List <int >>, and the return value is Luaval <& List <int >>.
#+BEGIN_SRC lns
// @lnsFront: skip
   form Process( val:&List<int> ) : &Map<int>;
   fn func( proc:Luaval<Process> ) {
      let list = proc( [ 1, 2, 3 ] );
   }
#+END_SRC



** LuneScript → Lua data conversion

When you pass a LuneScript value to a Lua function, you must pass a Luaval type value.

However, if the Lua function argument has the following values, it will be of the same type instead of the Luava type.
- int, real, bool, str
- Collection type such as List that has the above as an element
- Nilable above
Here is a sample.
#+BEGIN_SRC lns
// @lnsFront: ok
let code = ```
return function( tbl )
   local total = 0
   for key, val in pairs( tbl ) do
      total = total + val
   end
   return total
end
```;
let loaded, err = _load( code, nil );
when! loaded {
   if! let obj = loaded( ## ) {
   let map = { "val1":1, "val2":10 };
      print( (obj@@form)( map ) );  // Lua の関数コール
   }
} else {
   print( err );
}
#+END_SRC


This sample calls a function that calculates the sum of the values of the Lua table elements given as arguments.

In this sample, a data map of type Map <str, int> is specified as an argument of a Lua function and executed.

At this time, Map <str, int> type data is internally converted to Lua table.

-----


* Build edition
:PROPERTIES:
:CUSTOM_ID: make
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain how to build a project using LuneScript.

++ LuneScript provides a transcompiler for use from the command line,++We do not provide a build tool dedicated to LuneScript.++Therefore, here we will explain the general build method.+

You can transcompile LuneScript in the following ways:
- Individual build
- Batch build
Batch builds transcompile multiple .lns files at once.


** Individual build

To transcompile to Lua, run the following command:
#+BEGIN_SRC txt
$ lnsc hello.lns save
#+END_SRC


This transcompiles hello.lns and outputs the converted code to hello.lua.

This hello.lua can be run with the Lua command.
#+BEGIN_SRC txt
$ lua hello.lua
#+END_SRC


You can transcompile all .lns files by doing this for all .lns files.

However, if you have a lot of .lns files, this is inefficient.


** Batch build

Batch builds transcompile multiple .lns files at once.

To specify multiple .lns files, specify @-in the lnsc option and pass the .lns file path to stdin. The .lns file path passed to stdin prints one file per line.

For example, if you want to pass all the .lns files from the proj directory:
#+BEGIN_SRC txt
$ find proj -name '*.lns' | lnsc @- save
#+END_SRC


At the moment, this is the fastest way to do it.


** Reference information

*The following is reference information.*


*** Meta information file

A meta information file is a file that collects information such as the classes published by a module and the dependencies of other modules imported by that module.

When importing, you can reduce the analysis time by reading this meta information file instead of analyzing the module.

The meta information file can be generated with the following command.
#+BEGIN_SRC txt
$ lnsc hello.lns SAVE
#+END_SRC


*What is different from the previous command is the difference between "save" and "SAVE".*

Lowercase save produces only transcompiled Lua code, while uppercase SAVE produces Lua code and meta information files.

Specifically, executing the above command will generate hello.lua and hello.meta.

When importing a module, LuneScript loads the .meta file when all of the following conditions are met: At this time, the .lns file to be imported is not analyzed.
- There are .lua and .meta corresponding to .lns
- The following conditions are met for the update time of each file.
  - ~.lns < .meta~
- The following conditions are satisfied for the update time of the module mod2 being imported in the mod1.lns to be imported.
  - ~mod1 > mod2~
- The format version of the .meta file is correct


*** Dependency

If you have two modules, mod1 and mod2, and mod1 is importing mod2, then "mod1 depends on mod2".

"Mod1 depends on mod2" means that when you modify mod2, "not only mod2, but mod1 also needs to be transcompiled".

The make command has long been used to build modules with such dependencies. There are various build tools in recent years, but make must be a typical build tool.

The make command controls the updates of files that depend on a file when it is modified by the defined dependencies.

Defining this dependency manually can be a daunting task.

LuneScript provides the ability to automatically generate dependencies for make commands.

To have LuneScript automatically generate dependencies, specify options during SAVE as follows:
#+BEGIN_SRC sh
$ lnsc mod1.lns --depends depends/mod1.d SAVE
#+END_SRC


This transcompiles mod1.lns and at the same time prints mod1.lns dependency information to depends / mod1.d.

By incorporating this dependency information into the Makefile, you can easily control the build with make without having to manually define the dependencies.


**** sample

For example, suppose you create a project with the following modules.
#+BEGIN_SRC txt
test/proj/
      |
      +--- Mod1.lns
      |
      +--- Mod2.lns
      |
      +--- Mod3.lns
      |
      +--- Mod4.lns
#+END_SRC


Here, the contents of each file are as follows.
- Mod1.lns
#+NAME: Mod1.lns
#+BEGIN_SRC lns
// @lnsFront: skip
import test.proj.Mod2;

pub fn func(): str {
   return "%s -> %s" (__func__, Mod2.func() );
}
print( func() );
#+END_SRC

- Mod2.lns
#+NAME: Mod2.lns
#+BEGIN_SRC lns
// @lnsFront: skip
import test.proj.Mod3;

pub fn func(): str {
   return "%s -> %s" (__func__, Mod3.func() );
}
#+END_SRC

- Mod3.lns
#+NAME: Mod3.lns
#+BEGIN_SRC lns
// @lnsFront: skip
import test.proj.Mod4;

pub fn func(): str {
   return "%s -> %s" (__func__, Mod4.func() );
}
#+END_SRC

- Mod4.lns
#+NAME: Mod4.lns
#+BEGIN_SRC lns
// @lnsFront: ok
pub fn func(): str {
   return __func__;
}
#+END_SRC


The above file dependencies are as follows:
|-|-|
| File | Dependent files | 
|-+-|
| Mod1.lns | Mod2.lns | 
| Mod2.lns | Mod3.lns | 
| Mod3.lns | Mod4.lns | 
| Mod4.lns | none | 

The Makefile that builds this project looks like this:
#+BEGIN_SRC makefile
PROJ_DIR=test/proj
MKFILE=$(PROJ_DIR)/Makefile
SRC_DIR=$(PROJ_DIR)/

.PHONY: test all build setup

define comp
	@echo "$1 -> $2"
	lnsc $1 --depends depends/$(shell echo $1 | sed 's@/@.@g').d SAVE
endef

%.meta: %.lns
	$(call comp,$<,$@)

SRCS =
SRCS += Mod1.lns
SRCS += Mod2.lns
SRCS += Mod3.lns
SRCS += Mod4.lns

SRCS := $(addprefix $(SRC_DIR),$(SRCS))

META_LIST=$(SRCS:.lns=.meta)
LUA_LIST=$(SRCS:.lns=.lua)

-include depends/*.d

all:
	@echo make setup
	@echo make build

setup:
	mkdir -p depends

build: $(META_LIST)
#+END_SRC


The important part here is ~define comp~ and ~-include depends/*.d~.
- ~define comp~ registers transcompilation and dependency information file generation processing.
- ~-include depends/*.d~ is reading the generated dependency information file.
By creating such a makefile, it is possible to build according to the import dependency.


** summary

You can easily control the build of your LuneScript project by using the make command.

-----


* Macro edition
:PROPERTIES:
:CUSTOM_ID: macro
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

This time, I will explain about LuneScript macros.


** macro

LuneScript supports macros.

*Perhaps it makes more sense these days to say metaprogramming rather than macros.*

To explain "what is a macro", it is easier to explain the difference from a function.

*A function is a collection of certain processes. On the other hand, macros can define multiple function definitions themselves together. Of course, you can define not only function definitions but almost all processes that can be defined as macros.*

I think Lisp is the most major programming language for macros, but LuneScript macros aren't as powerful as Lisp. However, it is not as restrictive as C macros.


*** Simple macro example

The following is an example of a simple macro.
#+BEGIN_SRC lns
// @lnsFront: ok
macro _Hello() {
   print( "hello world" );
}
_Hello(); // hello world
#+END_SRC


This is the macro _Hello that displays hello world.

The macro definition uses the macro keyword.

This example is a macro that is exactly the same as using a function definition, and there is no point in defining it as a macro.

However, it is a good example to convey that "macros can be defined in the same way as function definitions".

In programming languages equipped with macros, macro definitions often require special processing, unlike general function definitions.

This raises the hurdle of mind that "macro seems to be difficult".

However, with LuneScript, you can define macros in the same way as general function definitions, as in the hello world sample above.

However, you cannot define a meaningful macro by writing a macro like the above example.

The following describes how to define meaningful macros.


*** Macro example

Here's an example of a slightly more practical macro:

This macro has the following specifications.
- Macro _Test that defines a function that returns a value of int
- The int value returned by the function is given as a macro argument.
- The name of the function to be defined is determined by the value of int
- Specifically, the function name that returns 1 is func1.
Below is the specific macro code.
#+BEGIN_SRC lns
// @lnsFront: ok
macro _Test( val:int ) {
   {
      let name = "func%d"(val);
   }
   fn ,,,name(): int {
      return ,,val;
   }
}

_Test( 1 );
_Test( 10 );

print( func1(), func10() ); // 1  10
#+END_SRC


Expanding a macro is almost the same as a function call.

In this case, _Test (1) and _Test (10) are macro expansions. _Test (1), _Test (10) expands to:
#+BEGIN_SRC lns
// @lnsFront: ok
// Test( 1 )
fn func1():int {
   return 1;
}
// Test( 10 )
fn func10():int {
   return 10;
}
#+END_SRC


This defines the functions func1 () and func10 (), so ~print( func1(), func10() )~ outputs 1 10.

This macro is described below.


*** How to write a macro

The syntax for defining a macro is:
#+BEGIN_SRC lns
// @lnsFront: skip
macro name( arg ) {
   {
      macro-statement
   }
   expand-statement
}
#+END_SRC


Start with the keyword macro, followed by the macro name name, the argument arg, and so on. The macro name name must start with _. Conversely, non-macro symbol names must start with something other than _.

Macro arguments support the following types:
- int
- real
- str
- bool  
- stat
- List, Map, Set above
- sym
- __exp
- __block
sym, stat, __exp, __block will be described later.

This is followed by the macro-statement block and the expand-statement.

To understand how to define a macro, it's easier to understand expand-statement first, so let's talk about expand-statement before we talk about the macro-statement block.


**** argument

The following can be used as the argument types dedicated to macros.
- sym
- stat  
- __exp
- __block


***** sym

sym is a type that can store symbols.

Symbols can be used as functions, variables, members, classes, all symbols.


***** stat

stat is a type that can store statements.


***** __exp

__exp is a type that can store all expressions.

You can specify any expression, for example =1 + 1= or =func()=. However, the expression must be error-free and evaluable when you call the macro.


***** __block

__block is a type that can store the block statement ={}=.

Like __exp, it must be a block that can be evaluated without error when calling the macro.


**** expand-statement

expand-statement writes the code after expanding the macro.

In the _Test macro example, the following part is the expand-statement.
#+BEGIN_SRC lns
// @lnsFront: skip
   fn ,,,name(): int {
      return ,,val;
   }
#+END_SRC


This expands the function definition.

Macro-specific operators are available in this expand-statement. ,, is the operator.

The available operators are:
- ,,,,
- ,,,
- ,,
*,,,, are operators that convert the symbol obtained by evaluating the variable that follows it into a string.*

*,,, are operators that convert the string obtained by evaluating the variable that follows it into a symbol.*

*,, are operators that expand the variables that follow.*

That is, in the above example, ,,, name converts the string in the name variable to a symbol, and ,, val expands the val variable, and the ~_Test( 1 )~ macro expands to:
#+BEGIN_SRC lns
// @lnsFront: ok
fn func1():int {
   return 1;
}
#+END_SRC


You can write any code in expand-statement, provided that the following restrictions are met:

*expand-statement must be a statement.*

In other words, expand-statement can be written in any code as long as it is not a statement, such as an expression or part of an incomplete token.

You can also write multiple statements in expand-statement.


**** macro-statement

In the macro-statement block, define the variables used in expand-statement. Variables used in expand-statement must be declared in the top-level scope of the macro-statement block.

In the _Test macro example, next is macro-statement.
#+BEGIN_SRC lns
// @lnsFront: skip
   {
      let name = "func%d"(val);
   }
#+END_SRC


Here we define the variable name. "Func% d" (val) is set as the initial value of name.

Within the macro-statement, you can take advantage of all the features of LuneScript. Specifically, you can also define functions in macro-statement.

For example, the _Test macro can also be written as:
#+BEGIN_SRC lns
// @lnsFront: ok
macro _Test( val:int ) {
   {
      fn funcname(): str {
         return "func%d"(val);
      }
      let name = funcname();
   }
   fn ,,,name(): int {
      return ,,val;
   }
}
#+END_SRC


In this example, macro-statement declares the funcname () function and assigns the result to the name variable.

Note that the only functions that can be used in macro-statement are the standard LuneScript functions. Even a function defined in the same source cannot be used from macro-statement if the function is defined outside the macro.

macro-statement can use macro-only operators like expand-statement.

Specifically, the following operators are available:
- ,,,,
- ,,,
- ,,
- ~`{}~
- ~~  
*",,,," ",,," ",," is almost the same as expand-statement. The difference from expand-statement is that expand-statement processes the variable that immediately follows it, while macro-statement processes the expression that immediately follows it.*

~`{}~ can use the statement written in ~`{}~ as it is.

For example, the above _Test macro can also be written using ~`{}~ as follows.
#+BEGIN_SRC lns
// @lnsFront: ok
macro _Test( val:int ) {
   {
      let defstat = `{
         fn ,,,"func%d"(val)~~():int {
            return ,,val;
         }
      };
   }
   ,,defstat;
}

_Test( 1 );
_Test( 10 );

print( func1(), func10() ); // 1  10
#+END_SRC


Here, ~`{}~ is used to store the function definition itself in the variable defstat, and defstat is expanded by expand-statement.

The initialization part of this defstat is extracted as follows.
#+BEGIN_SRC lns
// @lnsFront: skip
      let defstat = `{
         fn ,,,"func%d"(val)~~():int {
            return ,,val;
         }
      };
#+END_SRC


*Here you can see that we are using ~~.*

*~~ specifies the delimiter of operator expressions such as ,,,. In the above, ~~ is used after "func% d" (val). This indicates that the expression that applies the ,,, operator is up to "func% d" (val), after which () is part of the macro-expanding statement.*

If you do not specify ~~, the string generated by "func% d" (val) will have () added, resulting in a syntax error.

The following is an example of a list of ~`{}~.
#+BEGIN_SRC lns
// @lnsFront: ok
macro _Test( val:int ) {
   {
      let mut statList:List<stat> = [];
      for count = 1, val {
         statList.insert(
            `{          
               fn ,,,"func%d"(count)~~():int {
                  return ,,count;
               }
            } );
      }
   }
   ,,statList;
}

_Test( 5 );

print( func1(), func2(), func3(), func4(), func5() ); // 1 2 3 4 5
#+END_SRC


In this example, multiple function definitions (func1 to func5) are created by storing multiple function definitions in the list statList of ~`{}~ and expanding them.

The macro-statement block is not required. If you omit the macro-statement block, omit each {} as follows.
#+BEGIN_SRC lns
// @lnsFront: skip
macro name( arg ) {
   expand-statement
}
#+END_SRC



**** Functions available in macro-statement

The following functions are available in macro-statement:
- fn _lnsLoad( name:str, code:str ): stem;
This function loads the LuneScript code specified by code and returns its module.


**** Macro expansion

The method of expanding the macro is the same as the function call.


*** Public macro

Macros can be exposed to external modules.

You can make the macro available to the import destination by declaring pub as follows:
#+BEGIN_SRC lns
// @lnsFront: ok
pub macro _Hello() {
   print( "hello world" );
}
#+END_SRC



*** A little practical macro example

The following is an example of a slightly more practical macro.

In order to handle JSON used in REST API parameters and responses provided by Google etc. in LuneScript, it is convenient to classify it for each REST API JSON format. At such times, manually defining classes that handle multiple types of JSON-formatted data is inefficient and a source of bugs.

So we'll load the sample JSON format and create a macro that defines a class that can store that JSON format.

In this example, we read the following JSON file and
#+NAME: hoge.js
#+BEGIN_SRC js
{
    "val1": "abc",
    "val2": 0
}
#+END_SRC


It is a macro that defines the following class to handle the above JSON.
#+BEGIN_SRC lns
// @lnsFront: ok
class Hoge {
  pri let val1:str {pub};
  pri let val2:int {pub};
}
#+END_SRC


The following is a concrete example of a macro.
#+BEGIN_SRC lns
// @lnsFront: skip
macro _MkClass( name:str, path:str ) {
   {
      let mut memStatList:List<stat> = [];
      if! let mut fileObj = io.open( path ) {
         if! let txt = fileObj.read( "*a" ) {
            let defMap = "pub let val = %s;" (txt);
            let mod = _lnsLoad( "json", defMap );
            if! let jsonval = mod.val {
               fn getType( val:stem ): str {
                  switch type( val ) {
                     case "number" {
                        return "int";
                     }
                     case "string" {
                        return "str";
                     }
                  }
                  return "stem";
               }
               forsort val, key in jsonval@@Map<str,stem> {
                  memStatList.insert( `{
                     pri let ,,,key : ,,,getType( val )~~ {pub};
                  } );
               }
            }
         }
      }
   }
   class ,,,name {
      ,,memStatList;
   }
}
_MkClass( "Hoge", "hoge.js" );

let hoge = new Hoge( "ABC", 100 );
print( hoge.$val1, hoge.$val2 );
#+END_SRC


This macro reads JSON from a file and declares a class to store that JSON structure.

The class name is specified by the first argument of the macro.

This macro does the following:
- Open the specified file and read the JSON string defined in that file.
- From the JSON string txt, generate the LuneScript code with "pub let val =% s;" (txt) ;.
- Use _lnsLoad () to load the generated LuneScript code
- Extract the json val from the loaded module and list the JSON elements with forsort
- Generate ~`{}~ that declares the members that hold the enumerated elements and add it to memStatList
- Declare the class with name and memStatList.
In this sample, the members are treated as int and str type data for ease of processing. Lists etc. are not supported.


*** Common Map between macros

Macros are processes that are executed at compile time. Also, macro execution is independent of each other. When executing two macros A and B, it is not possible to change the control of macro B depending on the execution result of macro A.

However, this can be inconvenient. Therefore, sharing data within macros is a common map between macros.

** This is an experimental function.*

You can use the special variable =__var= from within the macro-statement of the macro.

The special variable __var has the following restrictions:
- Public macros cannot use __var
- Macros that access __var must be used from the same namespace that defines them.
- If you access __var from a different namespace, the contents of that __var are undefined.

The types of this variable are:
: let mut __var:Map<str,stem>


This variable is generated at the beginning of compilation of each module and all macros access the same variable.

Here is an example:
#+BEGIN_SRC lns
// @lnsFront: ok
   macro _test0( name:str, val:int ) {
      {
         __var[ name ] = val;
      }
   }
   macro _test1() {
      {
         let val;
         if! let work = __var[ "hoge" ] {
            val = work@@int;
         }
         else {
            val = 10;
         }
      }
      print( "%s" (,,val) );
   }
   _test0( "hogea", 1 );
   _test1(); // 10
   _test0( "hoge", 1 );
   _test1(); // 1
#+END_SRC


In this example, the _test0 () macro holds the int data in =__var[ "hoge" ]=, and the _test1 () macro modifies the processing according to the stored value of =__var[ "hoge" ]=.


** summary

LuneScript allows you to define macros as if you were a function.

Also, by using macros, you can define various processes.

Next time, I'll show you how to build a project that you develop using LuneScript.

-----


* Cast edition
:PROPERTIES:
:CUSTOM_ID: cast
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript provides three types of casts.
- ~@@~
- ~@@@~
- ~@@=~


** ~@@~  

~@@~ forces a type conversion without checking the type of the source value at runtime.
#+BEGIN_SRC lns
// @lnsFront: ok
let val1:stem = 1;
let val2:int = val1@@int;
#+END_SRC


The following values that cannot be converted can also be forcibly cast.
#+BEGIN_SRC lns
// @lnsFront: ok
let val1:stem = 1;
let val2:str[] = val1@@str[];
print( #val2 ); // runtime error 
#+END_SRC


*The above assigns the value 1 of type int to val1 of stem type and casts it to val2 of str list type. That is, I have cast the int to a str list. Accessing this val2 will result in a run-time error.*

If you explicitly cast something that can implicitly perform type conversion with @@, you will get a warning.

For example, in the following sample ~func( "abc"@@stem )~, a warning is output because the conversion from the string "abc" to stem can be done without an explicit cast.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val:stem ) {
}
func( "abc"@@stem );
#+END_SRC


Also, apparently incorrect type conversions will result in compilation errors.

For example, in the following case, ~1@@str~ is converting from int to str, but this type conversion is not possible, so a compile error will occur.
#+BEGIN_SRC lns
// @lnsFront: error
let val = "abc"@@int;  // error
let val2 = 1@@str;  // error
#+END_SRC


Casting =@@= to a class type will output a warning.

=@@= cannot be cast from nilable to non-nilable.

Use ~@@@~ or ~@@=~ to cast to a class type.


** ~@@@~

~@@@~ dynamically checks the source type and converts it.

The following is an example of ~@@@~.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val:stem ) {
   if! val@@@int {
      print( "int:%d" ( _exp ) );
   }
   if! val@@@str {
      print( "str:%s" ( _exp ) );
   }
}
func( 1 ); // int:1
func( "abc" ); // str:abc
#+END_SRC


~val@@@int~ checks the type of val, converts it if it is an int, and returns nil if it is not an int. ~val@@@str~ also checks the type of val, converts it if it is str, and returns nil if it is not str.

This causes ~func( 1 )~ to output an int: 1 and ~func( "abc" )~ to output str: abc.

=@@@= can be cast even if the cast source is nilable.


*** Limitation of ~@@@~ 1

A @@@ cast from a real value to an int should return nil, but in some cases it succeeds.

That case is when you cast a real type value that has no decimal point to an int.

By default, @@@ casts from real values to ints should return nil, which is a current limitation.

When transcompiled to Go language, @@@ cast from real type value to int returns nil as originally specified.

This behavior is subject to change in the future.

For example, the following ~func( 1 )~ outputs ~int:1~, ~real:1~, and ~func( 2.5 )~ outputs ~real:2.5~.
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val:stem ) {
   if! val@@@int {
      print( "int:%d" ( _exp ) );
   }
   if! val@@@real {
      print( "real:%g" ( _exp ) );
   }
}
func( 1.0 );
func( 2.5 );
#+END_SRC



*** Limitation of ~@@@~ 2

@@@ is only available for int / real / str / class / interface.

Enum etc. cannot be used.

Also, generics are not available in class.


** ~@@=~

~@@=~ is used when converting a class that does not have a method. If you specify a class that has a method or a class other than the class, a compile error will occur.

Note that ~@@=~ also forcibly performs type conversion without checking the conversion source value.

~@@=~ should only be used if type checking takes a long time.


** summary

*Cast should be avoided as much as possible except for conversion between int and real. You can create generic processing while preserving the type by using generics or alge.*

Even if you use the cast, use ~@@@~ and design so that the use of ~@@~ and ~@@=~ is the minimum necessary.

-----


* subfile edition
:PROPERTIES:
:CUSTOM_ID: subfile
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

As the processing of the module increases, the file grows accordingly.

Since it is not good for file bloat, in such a case, it is a general refactoring to subdivide the responsibility of the module and separate the file for each module.

However, it is often the case that the responsibilities cannot be divided neatly, or that the division has a large effect on other modules. As an alternative means when it is not possible to deal with module division in this way, subfile is created.

Subfile is the division of a module that originally consists of one file into multiple files.

In principle, LuneScript has 1 module = 1 file, but when it is subfiled, 1 module = multiple files.


** Subfile structure

A subfile consists of one main and multiple subs.
#+BEGIN_SRC
- main
  +- sub1
  +- sub2
  +- ...
  +- ...
  +- subN
#+END_SRC



** how to use

If main.lns, sub.lns exist under the foo / bar directory and sub.lns is a subfile of main.lns as follows:
#+BEGIN_SRC
foo/bar
     + main.lns
     + sub.lns
#+END_SRC


To use the subfile, declare as follows on the main side.
#+BEGIN_SRC lns
// @lnsFront: skip
subfile use foo.bar.sub;
#+END_SRC


Also, on the subfile side, declare as follows.
#+BEGIN_SRC lns
// @lnsFront: skip
subfile owner foo.bar.main;
#+END_SRC


This treats the specified module (foo.bar.sub in the above example) as a split subfile and treats sub.lns as part of the main.lns module.


*** limit

Module declarations must be made at the beginning of the script. However, comments are excluded.

Multiple subfile use can be declared in one file. Only one subfile owner can be declared. That is, a file can have multiple subfiles, but one subfile can only be used by one owner.

If multiple subfile use is declared, the subfiles will be processed in the order in which they were declared.

Subfiles can be thought of as basically the same as C's #include, but differ from #include in the following ways:
- C's =#include= expands the file where it was declared, while LuneScript expands the subfile to the final location of the file.
- The subfile must be complete as a statement.
  - You cannot write part of an expression in a subfile, such as =#include=.
- There must be one main file for a subfile.
- No further subfiles can be used from the subfile.
For example, if you have the following main.lns, sub1.lns, sub2.lns
- main.lns
#+BEGIN_SRC lns
// @lnsFront: skip
//------ main.lns -------
subfile use sub1;
subfile use sub2;

pub let val = 1;
#+END_SRC

- sub1.lns
#+BEGIN_SRC lns
// @lnsFront: skip
//------ sub1.lns -------
subfile owner main;

pub let val1 = 1;
#+END_SRC

- sub2.lns
#+BEGIN_SRC lns
// @lnsFront: skip
//------ sub2.lns -------
subfile owner main;

pub let val2 = 1;
#+END_SRC


main.lns is equivalent to the following script.
#+BEGIN_SRC lns
// @lnsFront: skip
//------ main.lns -------
pub let val = 1;
pub let val1 = 1;
pub let val2 = 1;
#+END_SRC


-----


* Lazy load edition
:PROPERTIES:
:CUSTOM_ID: lazyloading
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

For a project of some size, you will be importing multiple modules. And I am importing another module within the imported module.

Import in a scripting language means dynamic loading. When you start a script, the main processing of the script finally starts after all the modules used by the script are loaded.

For example, if there is an import relationship as shown in the following figure, the processing of the main mod module will be performed after all the related modules have been loaded.
#+BEGIN_SRC dot :file lazy.svg :cache yes :results silent
digraph G {
rankdir = TB;
mod -> funcA
mod -> funcB
mod -> funcC

funcA -> subA_1
funcA -> subA_2
funcA -> subA_3

funcB -> subB_1
funcB -> subB_2
funcB -> subB_3

funcC -> subC_1
funcC -> subC_2
funcC -> subC_3
}
#+END_SRC


[[https://ifritjp.github.io/documents/lunescript/lazy.svg]]

However, not all imported modules are always used.

For example, consider a program that provides three functions (funcA, funcB, funcC). If you select and run one of the three in this program, the remaining two unselected features will not be used.

import loads the module regardless of whether the module is used or not. In other words, the time required to load the module and the memory area for storing the loaded data are wasted.

As explained in the figure above, if funcA is selected, funcB, funcB_1 ~ funcB_3, func_C, funcC_1 ~ funcC_3 will be wasted.

If your project is small, you rarely need to worry about this waste. However, as the size of the project grows, this waste cannot be ignored.

For example, if one module takes 0.01 seconds to load, 100 modules would take 1 second.

If the program is resident, the load process is only once, so you can put up with it even if it takes some startup time, but if you have to start it for each request without being resident, this useless load process can not be ignored. increase.

Lazy loading eliminates the waste of this loading process.


** Lazy loading

Lazy loading is a process that loads modules when they are needed, rather than loading all the relevant modules at boot time.

As explained in the figure above, if funcA is selected, the inaccessible funcB, funcB_1 ~ funcB_3, func_C, funcC_1 ~ funcC_3 will not be loaded.

This saves the load processing time and the memory area for storing the loaded data.


*** How to achieve lazy loading

Lazy loading determines whether the module has been loaded when it is accessed, loads it if it is not loaded, and uses the loaded data if it is not loaded.

On the other hand, normal loading loads modules in a string at startup (import timing).

In other words, lazy loading involves more judgment processing than normal loading, so there is that much overhead. Of course, the overhead is very small. However, it is true that there is overhead, so performance degradation can occur in very critical or case cases.

Such cases need to be considered when using lazy loading.


*** Impact of lazy loading

As mentioned earlier, lazy loading has a small amount of overhead.

But that will have little effect.

The more likely effect is the difference in execution order.


**** Effect of execution order due to difference in load method

The processing written in the top scope of a module is executed when the module is loaded.

For example, if you have the following module
#+BEGIN_SRC lns
// @lnsFront: ok
print( "hoge" );
fn func() {
    print( "foo" );
}
#+END_SRC


Hoge is output when this module is loaded. On the other hand, func () is not executed, so foo is not output.

And if there is the next module to import this module,
#+BEGIN_SRC lns
// @lnsFront: skip
import Hoge;

print( "bar" );
Hoge.func();
#+END_SRC


For a normal load, the following output is produced:
#+BEGIN_SRC txt
hoge
bar
foo
#+END_SRC


On the other hand, in the case of lazy loading, the following output is produced.
#+BEGIN_SRC txt
bar
hoge
foo
#+END_SRC


*Comparing the output results, the output order of bar and hoge is swapped.*

The reason why this happens is that on a normal road
- The submodule Hoge is loaded at the timing of import, and
- At that timing, =print( "hoge" )= is executed and
- =print( "bar" )= is executed after the submodule Hoge has finished loading.
On the other hand, in lazy loading, the submodule Hoge is not loaded at the timing of import in normal loading, and it is not loaded.
- First =print( "hoge" )= is run,
- Just before running the next =Hoge.func()=, the submodule Hoge is loaded and
- =print( "hoge" )= is processed.
This is the difference between normal and lazy loads.


**** Impact of global due to different loading methods

In addition to pub / pro / pri / local, LuneScript access control includes global.

For more information on global, see other articles, but global is registered when the module is loaded.

*In other words, the timing at which global data is registered will be different due to the effect of lazy loading.*

I think there are few cases where global is used, but be careful.


** how to use

Lazy loading is available with the following instructions:
- import
- module
|-|-|
| order | Load processing | 
|-+-|
| import | Compile option dependent | 
| import.l | Lazy loading | 
| import.d | Normal load | 
|-|-|
| order | Load processing | 
|-+-|
| module | Compile option dependent | 
| module.l | Lazy loading | 
| module.d | Normal load | 

For example, the Sub module will be lazy loaded by doing the following:
#+BEGIN_SRC lns
// @lnsFront: skip
import.l Sub;
#+END_SRC


import and module depend on compile options.

If you specify the following in the compile options,
: --default-lazy


import and module will be lazy loading.

If import.d and module.d are specified, normal loading will occur even when =--default-lazy= is specified.

-----


* shebang and command line arguments
:PROPERTIES:
:CUSTOM_ID: shebang_main
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript supports shebang.


** Shebang compatible

Shebang is a function that executes the specified interpreter when the script file is executed by specifying the interpreter to be used in the comment on the first line of the script file that is often seen in shell scripts. For example, in bash, specify as follows.
#+BEGIN_SRC sh
#! /bin/bash
#+END_SRC


In LuneScript, specify:
#+BEGIN_SRC sh
#! /usr/bin/lnsc -shebang
#+END_SRC


Here, =/usr/bin/lnsc= needs to be specified according to the environment.

This allows the LuneScript file containing =#!= to be executed as is.

For example, if you have the following file hello.lns,
#+BEGIN_SRC sh
#! /usr/bin/lnsc -shebang
print( "hello world" );
#+END_SRC


You can run this hello.lns directly.
#+BEGIN_SRC txt
$ hello.lns
hello world
#+END_SRC


+At this time, there are the following restrictions.+
- +In the go version of lnsc, the .lua that corresponds to the .lns file you are importing++Must be generated in advance.+


** Command line arguments

There are cases where you want to handle command line arguments, such as when launched by shebang or transcompiled to go.

To handle this command line argument, define the following __main function to handle the command line arguments passed to this function's arguments.
#+BEGIN_SRC lns
// @lnsFront: skip   
pub fn __main( argList:&List<str> ):int
#+END_SRC


The type of the __main function must be declared with the above type except for the argument name argList.


*** Execution order of __main

The execution order of this __main function is performed after the top scope processing is completed. That is, for the following script
#+BEGIN_SRC lns
#! /usr/bin/lnsc -shebang
// @lnsFront: skip   
print( "hello world" );

pub fn __main( argList:&List<str> ):int {
   print( "hoge" );
   return 0;
}
#+END_SRC


The output result is as follows.
#+BEGIN_SRC txt
$ ./mini.lns 
hello world
hoge
#+END_SRC



*** __main argument

The argument for =__main= is =&List<str>=.

This list contains the script path first, followed by command line arguments.
#+BEGIN_SRC lns
#! /usr/bin/lnsc -shebang
// @lnsFront: skip   
pub fn __main( argList:&List<str> ):int {
   foreach arg in argList {
      print( arg );
   }
   return 0;
}
#+END_SRC


-----


* Recommended directory structure for projects that use LuneScript
:PROPERTIES:
:CUSTOM_ID: dir
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript supports transcompiling to lua and go.

On the other hand, lua and go have different directory management methods.

This section describes the recommended directory structure so that you can use it in directory management in either language without any problems.


** Premise

The explanation here assumes that you are developing with the following github repository.
: github.com/HOGE/PROJ

- HOGE is any github account name.
- PROJ is any repository name.
In addition, the explanation is based on the assumption that the following modules are defined.
: foo.bar.lib



** Basic configuration

Shows the basic structure of the directory.
#+BEGIN_SRC txt
PROJ/
 +-- go.mod
 +-- lune.js
 +-- foo/
   +-- bar/
      +-- lib.lns
#+END_SRC


Place go.mod, lune.js and foo / directly under the PROJ directory.


*** lune.js

lune.js is created with the following contents.
: {}



*** go.mod

The configuration of go.mod at this time is shown. Note that go.mod is not needed if you do not transcompile to go.
#+BEGIN_SRC txt
module github.com/HOGE/PROJ

go 1.16
#+END_SRC



*** Main and sub modules

*The repository may manage the main program and the submodules used by the main program.*

*When managed as a submodule, the above basic structure restrictions are slightly relaxed.*

Specifically, the following are mitigated:
- You don't have to have go.mod, lune.js and foo directly under PROJ.
- You no longer need to register go.sum on github.
For example, it can be placed under src as follows.
#+BEGIN_SRC txt
PROJ/
 +-- src/  <--- ※任意のディレクトリ以下に配置可能
   +-- go.mod
   +-- lune.js
   +-- foo/
     +-- bar/
        +-- lib.lns
#+END_SRC


In this case, go.mod has a different module path as follows:
#+BEGIN_SRC txt
module github.com/HOGE/PROJ/src

go 1.16
#+END_SRC



*** Environment variable GOPATH

When transcompiling to go, the above PROJ directory must be placed in the following location.
: ${GOPATH}/src/github.com/HOGE/PROJ


If GOPATH is not set, =${HOME}/go= will be used.

-----


* Transcompile to Go language
:PROPERTIES:
:CUSTOM_ID: go
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript can be transcompiled to Go as well as Lua as the language to transcompile.

This feature makes LuneScript faster (about 16 times faster) by transcompiling LuneScript's self-hosting code into go language code and building it with go.

See below for speedups. https://ifritjp.github.io/blog2/public/posts/2021/2021-06-28-lunescript-build-time-2000/

However, some features are not supported because the support is limited to the features required for LuneScript self-hosting.

That said, LuneScript's self-hosting itself uses most of LuneScript's features, so it's fine for normal use.


** How to transcompile to go language

*To transcompile to the go language, specify -langGo when using the LuneScript command line option save or SAVE to output the transcompile result to go to a file with a .go extension.*


** Cooperation with Lua

When transcompiling to the go language, you need to use a special type when working with Lua.

See below for details.

[[#lua]]


** Post-transcompile configuration to Go language

LuneScript is a Lua transcompiler that features the ability to use Lua code directly from LuneScript.

This feature is inherited even after transcompiling to the Go language.

For example, you can run the following code even after converting it to Go language.
#+BEGIN_SRC lns
// @lnsFront: ok
let step = 30;

// Lua のフィボナッチ関数
let code = ```
local function fib ( n )
   if n < 2 then return n end
   return fib(n - 2) + fib(n - 1)
end
return fib
```;

// Lua コードのロード
form fibFunc( num:int ):int;
fn loadLua( txt:str ) : Luaval<fibFunc> {
   let fib;
   __luago {
      let loaded = unwrap _load( txt ## );
      fib = unwrap loaded(##);
   }
   return fib@@fibFunc;
}

// プロファイル用マクロ
macro _profile( exec:__exp ) {
   {}
   {
      let prev = os.clock();
      print( "%s = %d: step = %d: time = %g"
             (,,,,exec, ,,exec, step, os.clock() - prev ) );
   }
}

// Lua のコードをロードして実行
let fib_lua = loadLua( code );
__luago {
   _profile( fib_lua( step ) );
}

// LuneScript のフィボナッチ関数
fn fib_lns( num:int ) : int {
   if num < 2 {
      return num;
   }
   return fib_lns( num - 2 ) + fib_lns( num - 1 );
}
// Go で定義した fib_lns 関数を実行
_profile( fib_lns( step ) );
#+END_SRC


This code does the Fibonacci calculations in lua and LuneScript.

The first code variable defines the lua code, loads it with the loadLua () function, and loads the Lua function with fib_lua. And the fib_lns () function in the latter half is a LuneScript function that performs Fibonacci calculations.


*** When transcompiled to Lua

Transcompiling the above code into Lua and running it produces the following:
#+BEGIN_SRC txt
fib_lua( step ) = 24157817: step = 37: time = 5.69
fib_lns( step ) = 24157817: step = 37: time = 5.38
#+END_SRC


This shows the calculation result and calculation time of fib_lua () and fib_lns () respectively.

Looking at this, we can see that the Lua-loaded function fib_lua () and the Lns function fib_lns () take about the same amount of time to execute.

This is a natural result. This is because if you convert LuneScript to Lua, the fib_lns () written in LuneScript and the fib_lua () in Lua will be almost the same Lua code.

The code when transcompiling the above code into Lua looks like this:
#+BEGIN_SRC lua
--miniGo.lns
local _moduleObj = {}
local __mod__ = '@miniGo'
local _lune = require( "lune.base.runtime2" )
if not _lune2 then
   _lune2 = _lune
end
local step = 37
local code = [==[
local function fib ( n )
   if n < 2 then return n end
   return fib(n - 2) + fib(n - 1)
end
return fib
]==]
local function loadLua( txt )
   local loaded = _lune.unwrap( _lune.loadstring52( txt ))
   local fib = _lune.unwrap( loaded(  ))
   return fib
end
local fib_lua = loadLua( code )
do
   local prev = os.clock(  )
   print( string.format( "%s = %d: step = %d: time = %g", "fib_lua( step )", fib_lua( step ), step, os.clock(  ) - prev) )
end
local function fib_lns( num )
   if num < 2 then
      return num
   end
   return fib_lns( num - 2 ) + fib_lns( num - 1 )
end
do
   local prev = os.clock(  )
   print( string.format( "%s = %d: step = %d: time = %g", "fib_lns( step )", fib_lns( step ), step, os.clock(  ) - prev) )
end
return _moduleObj
#+END_SRC


Below is an excerpt of the notable definition of the fib_lns () function.
#+BEGIN_SRC lua
local function fib_lns( num )
   if num < 2 then
      return num
   end
   return fib_lns( num - 2 ) + fib_lns( num - 1 )
end
#+END_SRC


As you can see, fib_lns () and fib_lub () are equivalent code.

So it's not surprising that fib_lns () and fib_lua () take about the same amount of time.


*** When transcompiled to go

On the other hand, when transcompiled to go, the execution result is as follows.
#+BEGIN_SRC txt
fib_lua( step ) = 24157817: step = 37: time = 6.07
fib_lns( step ) = 24157817: step = 37: time = 0.34
#+END_SRC


*You can see that fib_lns () has a shorter calculation time of about 1/18 than fib_lua ().*

The result of transcompiling to go is as follows.
#+BEGIN_SRC go
// This code is transcompiled by LuneScript.
package lnsc
import . "lnsc/lune/base/runtime_go"
var init_miniGo bool
var miniGo__mod__ string
var miniGo_step LnsInt
var miniGo_code string
var miniGo_fib_lua *Lns_luaValue
type miniGo_fibFunc_1003_ func (arg1 LnsInt) LnsInt
// 14: decl @miniGo.loadLua
func miniGo_loadLua_1009_(txt string) *Lns_luaValue {
    var loaded *Lns_luaValue
    loaded = Lns_unwrap( Lns_car(Lns_getVM().Load(txt, nil))).(*Lns_luaValue)
    var fib LnsAny
    fib = Lns_unwrap( Lns_car(Lns_getVM().RunLoadedfunc(loaded,Lns_2DDD([]LnsAny{}))[0]))
    return fib.(*Lns_luaValue)
}

// 36: decl @miniGo.fib_lns
func miniGo_fib_lns_1025_(num LnsInt) LnsInt {
    if num < 2{
        return num
    }
    return miniGo_fib_lns_1025_(num - 2) + miniGo_fib_lns_1025_(num - 1)
}

func Lns_miniGo_init() {
    if init_miniGo { return }
    init_miniGo = true
    miniGo__mod__ = "@miniGo"
    Lns_InitMod()
    miniGo_step = 37
    miniGo_code = "local function fib ( n )   if n < 2 then return n end   return fib(n - 2) + fib(n - 1)endreturn fib"
    miniGo_fib_lua = miniGo_loadLua_1009_(miniGo_code)
    {
        var prev LnsReal
        prev = Lns_getVM().OS_clock()
        Lns_print([]LnsAny{Lns_getVM().String_format("%s = %d: step = %d: time = %g", []LnsAny{"fib_lua( step )", Lns_getVM().RunLoadedfunc(miniGo_fib_lua,Lns_2DDD(miniGo_step))[0].(LnsInt), miniGo_step, Lns_getVM().OS_clock() - prev})})
    }
    
    {
        var prev LnsReal
        prev = Lns_getVM().OS_clock()
        Lns_print([]LnsAny{Lns_getVM().String_format("%s = %d: step = %d: time = %g", []LnsAny{"fib_lns( step )", miniGo_fib_lns_1025_(miniGo_step), miniGo_step, Lns_getVM().OS_clock() - prev})})
    }
    
}
func init() {
    init_miniGo = false
}
#+END_SRC


It's very hard to read, so if you extract the definition part of the fib_lns () function, it will be as follows.
#+BEGIN_SRC go
func miniGo_fib_lns_1025_(num LnsInt) LnsInt {
    if num < 2{
        return num
    }
    return miniGo_fib_lns_1025_(num - 2) + miniGo_fib_lns_1025_(num - 1)
}
#+END_SRC


The function name is longer, but you can see that the LuneScript code has been converted to go as is. When you execute a function, you just call the function normally as follows.
:  miniGo_fib_lns_1025_(miniGo_step)


On the other hand, Lua's fib_lua () function is loaded with a function for executing Lua's code by =miniGo_fib_lua = miniGo_loadLua_1009_(miniGo_code)=, and when it is executed, the function is called as follows.
: Lns_getVM().RunLoadedfunc(miniGo_fib_lua,Lns_2DDD(miniGo_step))


As you can see, fib_lns () and fib_lua () process completely differently.


*** Build

The following steps are required to transcompile and build to go.
- Generate go.mod
- Register the LuneScript runtime with go.mod
- Generate main.go
- Generate .go from .lns
- Update go.mod
- go build
If you update .lns, repeat the process after "Generate .go from .lns".

I will explain each step.


**** Generate go.mod

Execute the following command in the directory where lune.js is located.
: $ go mod init test # <--- test は環境に合せて指定してください



**** Register the LuneScript runtime with go.mod

Register the LuneScript runtime with go.mod with the following command:
: $ go get github.com/ifritJP/LuneScript/src@latest


Run go mod tidy for the rest of the work, but be sure to run go get first.


**** Generate main.go

go requires the entry function main ().

The following command creates main.go, which defines go's main () function.
: $ lnsc hoge.lns mkmain main.go


Here hoge.lns specifies the main module that defines __main in lns. main.go specifies the output path.

A module that defines the __main function is required when transcompiling to go.

The main.go generated by this command contains the code that initializes the lns runtime.


**** Generate .go from .lns

Generate .go with the following command.
: $ lnsc hoge.lns save -langGo


For the main module that contains the __main function, add the --main option as well.
: $ lnsc hoge.lns save -langGo --main hoge


Where the hoge in --main hoge is the import path for the main module.

For example, if the main module is foo / bar / hoge.lns
: $ lnsc foo/bar/hoge.lns save -langGo --main foo.bar.hoge


It will be.

If you want to transcompile LuneScript to go, you need the __main function.


**** Update go.mod

Update go.mod with the following command.
: $ go mod tidy



**** go build

After converting all the lns files and generating main.go, run go build.
: $ go build


*If the above fails, try the following:*
: $ go build -tags gopherlua


This will build the transcompiled module with go.


*** Lua library link required after transcompiling to go
#+BEGIN_QUOTE
追記

*Lua ライブラリのリンクを回避する方法を用意しました。*

[[#lua_runtime]]
#+END_QUOTE


As mentioned above, LuneScript works closely with Lua. And even after transcompiling to go, it supports the linked operation.

To achieve this integration, the code after transcompiling to go requires a lua VM to do the lua processing.

In detail, besides this Lua integration, LuneScript has some processing that requires a Lua VM. Specifically, Lua VM is used for macro expansion processing and some built-in function processing.

*The lua VM assumes the official lua-5.3.4 and links liblua5.3.so.*

The go language has the advantage of being able to generate one environment-independent executable, but unfortunately transcompiling LuneScript to go requires a link to liblua5.3.so.

Not only do you need liblua5.3.so at run time, but you also need the lua-5.3.4 include file at build time.

-----


* Transcompile time package to Go language
:PROPERTIES:
:CUSTOM_ID: go_package
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

Modules packaged with go are available from LuneScript.


** go package management overview

go manages packages with go.mod.

Packages managed by this go.mod are cached in the local directory specified by the environment variable GOPATH.

LuneScript can take advantage of this cached module.

To use the package on github with go, write as follows.
#+BEGIN_SRC go
import "github.com/ifritJP/lnshttpd"
#+END_SRC


LuneScript can access the go modules in the same way.


** import

To import the .lns file in the go package with LuneScript, write:
#+BEGIN_SRC lns
// @lnsFront: skip
import go/github:com.ifritJP.lnshttpd.lnsservlet;
#+END_SRC


This is an example of importing lnsservlet.lns from https://github.com/ifritJP/lnshttpd.

Now let's look at =go/github:com.ifritJP.lnshttpd.lnsservlet=.

As you can probably imagine by comparing =https://github.com/ifritJP/lnshttpd= and =go/github:com.ifritJP.lnshttpd.lnsservlet=, there are additional rules when using the go package:
- Prepend =go/=
- If there is a., Like github.com, specify: instead of.
LuneScript searches for modules in the go package path instead of the normal search path when a module of the above format is specified.

Specifically, it searches the files in the following order:
- vendor/github.com/ifritJP/lnshttpd/lnsservlet.lns 
- ${GOPATH}/pkg/mod/github.com/ifrit!j!p/lnshttpd@XXXXXXXXXXXXXXXXX/lnsservlet.lns
Here, the =XXXXXXXXXXXXXXXXX= part of =@XXXXXXXXXXXXXXXXX/lnsservlet.lns= is obtained from the TAG information of the module described in go.mod. In other words, you need to run go mod tidy in advance.


** module

To use the go module from LuneScript, you need a module declaration.

The module declaration is also used when using the Lua module from LuneScript, but when using the go module, there are additional rules:
- Add to the module declaration that you are using the go module
The following is an example declaration when using servlet.go on github.com.ifritJP.lnshttpd.
#+BEGIN_SRC lns
// @lnsFront: skip
module servlet require "go/github:com.ifritJP.lnshttpd.servlet" of "" {
   pub static fn Start( listenPort:int,
                        handlerList: &List<&lnsservlet.HandlerInfo>,
                        hostingList:&List<&lnsservlet.HostingInfo> );
}
#+END_SRC


Here, =of ""= of =module servlet require "go/github:com.ifritJP.lnshttpd.servlet" of ""= declares the type of module to be used.

The character strings that can be specified are as follows.
|-|-|
| String | Module language | 
|-+-|
| "" | Same as transcompile destination language | 
| "Lua" | lua | 
| "Go" | go | 


*** Available languages

There are restrictions on the combination of languages that can be transcompiled and the languages that can be used with module.
|-|-|
| go module | lua module | 
|-+-|
| Transcompile to go | Possible | Possible | 
| Transcompile to lua | Impossible | Possible | 


*** Type compatibility

The go module is available from LuneScript in the module declaration.

However, type compatibility is limited.

The following types are paired with LuneScript and go.
|-|-|
| LuneScript type | type of go | 
|-+-|
| int | int | 
| real | float64 | 
| bool | bool | 
| str | string | 
| nilable | interface{} | 

-----


* * Lua runtime when transcompiled to Go *
:PROPERTIES:
:CUSTOM_ID: lua_runtime
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript is a project that started development as a Lua transcompiler. And to take advantage of Lua's assets, LuneScript also supports working with Lua.

This behavior of linking LuneScript and Lua is also available when transcompiled to go. In other words, Go and Lua work together.

To achieve this, we need a link between Go and Native lua runtimes. Even if you do not use the Lua linkage operation in the LuaScript code, you cannot separate the link of the Lua runtime because it uses the Lua runtime function internally.

The cooperation between LuneScript and Lua is an important function due to the nature of Lua's transcompiler. On the other hand, if you think of LuneScript as a Go transcompiler, working with Lua isn't very important.

In addition, the advantages of go are as follows.
- It is possible to create a single file that operates independently without depending on the library of the execution environment.
- Supports cross-compilation to various environments
If you need to link the Lua runtime, you lose the above advantages.

The Lua runtime is environment-independent, but it's a big shackle to maintain the above advantages.

Therefore, it is possible to execute transcompiled code without linking the Native Lua runtime.


** Use of gopher-lua

gopher-lua is a Lua runtime implemented in go. Avoid linking with the Native Lua runtime by using gopher-lua.

To use gopher-lua, specify -tags as an option during go build.
: go build -tags gopherlua


Specifying this option switches the Lua runtime from Native Lua to gopher-lua.


*** Precautions for gopher-lua

When using gopher-lua, the Lua runtime specification is limited by the gopher-lua specification.

Specific examples are given below.
- lua version is 5.1
- Some APIs such as string.dump are not available
- Non-pure Lua libraries such as luasocket are not available
- Slower than Native Lua
If you're not using LuneScript and Lua integration, you don't have to worry about it, but you should be aware that there are differences between Native Lua and gopher-lua.


** Other Lua runtimes

There are several types of Lua runtimes implemented in go.

The following are typical examples.
- https://github.com/yuin/gopher-lua
- https://github.com/Azure/golua
- https://github.com/Shopify/go-lua  
yuin / gopher-lua is the implementation used this time. The only implementation that was able to execute LuneScript's self-hosted Lua code, as a typical example.

Azure / golua seems to be a project launched by Microsoft. I expected it to be based on lua5.3, but it didn't do what I expected it to do (I can't parse Lua). Since the repository of github is Archived, future development cannot be expected.

Shopify / go-lua is based on lua5.2. A simple Lua script works, but I couldn't load lua, which self-hosts LuneScript. For this reason, it was expected that there would be a compatibility problem, so this time we decided not to adopt it in LuneScript.

I've tried several Lua implementations with go, but it's a shame that few Lua implementations support a level of compatibility that allows LuneScript to run.

If I implement Lua in the future, I thought that it could be used as a test case to check the compatibility of Lua by checking whether LuneScript works.

However, if it doesn't work, it's not easy to know what caused it to not work, so it's not realistic considering that it's not easy to use as a test case.

-----


* Safe asynchronous processing
:PROPERTIES:
:CUSTOM_ID: async
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

Taking the opportunity of transcompiling from LuneScript to go language, asynchronous processing by LuneScript is supported.

It has a simple function to statically eliminate data races.


** __Runner interface

To do asynchronous processing with LuneScript, implement the __Runner interface.

*The __Runner interface is of the following type: __async will be discussed later.*
#+BEGIN_SRC lns
pub interface __Runner {
   pub fn run() __async mut;
}
#+END_SRC


If you implement this interface, you can take advantage of the new built-in functions __run (), __join ().

For example, if you do the following, =print("hoge:", self.val );= will be processed asynchronously.
#+BEGIN_SRC lns
class Hoge extend (__Runner) {
   let val:int;
   pub fn run() __async mut {
      print("hoge:", self.val );
   }
}

let list:List<Hoge> = [];
for index = 0, 10 {
   let mut hoge = new Hoge(index);
   __run( hoge, __lns.runMode.Sync, "" );
   list.insert( hoge );
}
foreach hoge in list {
   __join( hoge );
}
#+END_SRC



*** __run () function

The __run () function is a function to start asynchronous execution of the __Runner class.

When asynchronous execution is started, the run () method of the __Runner class is executed in a separate thread.

The types of the __run () function are:
#+BEGIN_SRC lns
pub fn __run( runner:__Runner, mode: RunMode, name:str ) : bool
#+END_SRC

- The first argument, runner, specifies the __Runner object to run.
- For the mode of the second argument, specify the following.
  - __lns.runMode.Sync
    - If the number of running __Runners exceeds a certain number, a new thread will not be started and will be executed here.
  - __lns.runMode.Queue
    - If the number of running __Runners exceeds a certain number, put it in the Runner queue and execute it when the running __Runner stops.
  - __lns.runMode.Skip
    - If the number of running __Runners exceeds a certain number, Runner will not be executed.
    - If not executed, returns false.
- For name of the third argument, specify the name of this asynchronous process.
When transcompiled to lua, the behavior is as follows.
- If mode is __lns.runMode.Sync or __lns.runMode.Queue, run here without starting a new thread.
- If mode is __lns.runMode.Skip, return false without executing.


*** __join () function

The __join () function is a function that waits for the asynchronous processing of __Runner to finish.
#+BEGIN_SRC lns
pub fn __join( runner:__Runner ) 
#+END_SRC


When transcompiled to lua, nothing is done because there is no asynchronous processing.


*** Constructor argument restrictions

The arguments of the constructor of the class that extends __Runner are limited to the following types.
- int, real, str, bool, enum 
- immutable type
In other words, the following cases will result in an error.
#+BEGIN_SRC lns
class Test {
}
class Hoge extend (__Runner) {
   pub fn __init( test:Test, list:List<int> ) __async { // error
   }
   pub fn run() __async mut {
   }
}
#+END_SRC


This error is because the arguments test and list are of mutable type.

You need to declare it as immutable as follows.
#+BEGIN_SRC lns
class Test {
}
class Hoge extend (__Runner) {
   pub fn __init( test:&Test, list:&List<int> ) __async { // ok
   }
   pub fn run() __async mut {
   }
}
#+END_SRC



** __async, __noasyc attributes

If you look at the definition of the run () method in the __Runner interface, you can see that __async has been added.

This declares that the function can be executed asynchronously.

LuneScript manages the conventional synchronous processing in which only one thread operates and the asynchronous processing in which a new thread is started and executed.

To execute a function asynchronously, you must declare that the function can be executed asynchronously.

*That's __async.*

*On the other hand, the traditional synchronization process is __noasyc.*

//Normally, I think the pair of async is sync,//I dare to use noasync for the following reasons.//
- Difficult to distinguish between async and sync
- Noasync because the subject is asynchronous processing (async) and synchronous processing is an exception
If neither __async nor __noasync is declared, the default is __noasyc, but there is a way to treat the default as __async.


** __async Declared function limits

*The __async declared function has the following restrictions:*
- You cannot access the __noasync declared function from within the __async declared function.
- __async Unable to access out-of-scope mutable variables from within the declared function.
*On the other hand, functions declared with __noasync do not have such restrictions.*

This is a guard to safely perform asynchronous processing.

*Asynchronous processing must consider exclusive control. If you do not perform exclusive control where necessary, it will be a bug.*

[[https://ja.wikipedia.org/wiki/%E7%AB%B6%E5%90%88%E7%8A%B6%E6%85%8B#%E6%83%85%E5%A0% B1% E5% 87% A6% E7% 90% 86] [Refer to here for the necessity of exclusive control. ]]]

*However, it is very difficult to manually cover where exclusive control is required in all cases.*

*Therefore, LuneScript adopts a method to reduce the omission of exclusive control due to human error by declaring meta information in the grammar and checking the inconsistency by the compiler.*

Rust is a typical language that takes this approach.

*Rust provides a high degree of exclusive control with a strict definition of meta information.*

*LuneScript uses meta-information definitions that are relatively easy and easy to handle, instead of providing as high a level of exclusive control as Rust.*

*By using __asyncLock, which will be described later, you can access __noasync from __async.*


*** Functions declared with __noasync cannot be executed from within the functions declared with __async.

This means that the following cases will result in an error:
#+BEGIN_SRC lns
class Test {
   fn func1() __noasync {
   }
   fn func2() __async {
      self.func1(); // error
   }
}
#+END_SRC


The above func1 is __noasync and func2 is __async. At this time, __noasync's func2 cannot access __noasync's func1.


*** __async Unable to access out-of-scope mutable variables from within the declared function.

This means that the following cases will result in an error:
#+BEGIN_SRC lns
let mut list = [ 1, 2 ];
let list2 = [ 1, 2 ];
class Test {
   fn func() __async {
      foreach val in list { // error
         print( val );
      }
      foreach val in list2 { // ok
         print( val );
      }
   }
}
#+END_SRC


The func above is __async and list is a mutable variable with top scope.

At this time, you cannot access the mutable list from the __async func.

On the other hand, list2 is immutable. Immutable variables can be accessed from func.

You can also access mutable members from the __noasync method.


** __async:__noasyc == N:1

LuneScript is designed to have multiple threads (N) running asynchronously (=__async=) and one thread running on =__noasync=.

If you have multiple threads running on =__noasync=, it's no longer asynchronous, so it's not surprising that there is only one thread on =__noasync=.


** How to temporarily remove the __async restriction. (__asyncLock)

As mentioned earlier, there are restrictions on the functions declared in __async.

The ideal is to meet this limitation in everything, but in reality there are cases where that is not enough.

Therefore, we provide a way to temporarily remove the restrictions on the functions declared in __async.

*That is __asyncLock.*

For example, use __asyncLock as follows.
#+BEGIN_SRC lns
class Test {
   fn func1() __noasync {
   }
   fn func2() __async {
      __asyncLock {
         self.func1(); // ok
      }
   }
}
#+END_SRC


Since func2 is __async, you wouldn't normally be able to access the __noasync func2, but within the __asyncLock block, __async is unrestricted.


*** Relationship between __asyncLock and __noasync

__asyncLock temporarily causes the __async declared function to act as __noasync.

And as mentioned earlier, there must be one thread acting as __noasync.

Therefore, __asyncLock waits until the execution of the __noasync thread is stopped, and executes the block of _asyncLock after the __noasync thread is stopped.

Other __asyncLock blocks are treated in the same way as __noasync threads are running.


**** Nesting __asyncLock across functions

In the following case, we are calling func3-> func2-> func1.

At this time, __asyncLock is executed by func3 and func2, but since it is executed as the existing __noasync when func2 is executed, __asyncLock of func2 is executed without blocking.
#+BEGIN_SRC lns
class Test {
   fn func1() __noasync {
   }
   fn func2() __async {
      __asyncLock {
         self.func1();
      }
   }
   fn func3() __async {
      __asyncLock {
         self.func2();
      }
   }
}
#+END_SRC


In this way, __asyncLock across functions can be nested.

On the other hand, __asyncLock in the same function cannot be nested. I get an error.
#+BEGIN_SRC lns
class Test {
   fn func1() __noasync {
   }
   fn func2() __async {
      __asyncLock {
         __asyncLock { // error
            self.func1();
         }
      }
   }
}
#+END_SRC



*** __asyncLock overhead

As mentioned above, __asyncLock provides exclusive control.

The use of __asyncLock should be minimized as exclusive control is overhead.

For example, if you use __asyncLock inside a for loop as follows, the overhead of the loop will be added.
#+BEGIN_SRC lns
class Test {
   fn func1() __noasync {
   }
   fn func2() __async {
      for _ = 1, 10000000 {
         __asyncLock {
            self.func1();
         }
      }
   }
}
#+END_SRC


In this case, it's a good idea to put __asyncLock out of the for loop. However, there are cases where the exclusion range becomes too wide when you go out of the for loop.

You need to be careful about which range you want to __asyncLock.


*** __asyncLock limits

__asyncLock has the following restrictions:
- You cannot return or break from within __asyncLock.
In other words, the following processing cannot be performed.
#+BEGIN_SRC lns
class Test {
   fn func1() __noasync : bool {
      return true;
   }
   fn func2() __async : int {
      __asyncLock {
         if self.func1() {
            return 1; // error
         }
      }
      return 0;
   }
}
#+END_SRC


To perform such processing, write as follows.
#+BEGIN_SRC lns
class Test {
   fn func1() __noasync : bool {
      return true;
   }
   fn func2() __async : int {
      let mut val = 0;
      __asyncLock {
         if self.func1() {
            val = 1;
         }
      }
      return val;
   }
}
#+END_SRC



** Default to __async

The undeclared function is __noasync.

There is a way to make this the default __async.
: _lune_control default_async_all


If the above is declared at the beginning of a .lns file, it defaults to __async in that .lns file.


** Software design

The features so far are summarized below.
- There are multiple __async threads (N) and one __noasync thread is N: 1.
- In addition, __asyncLock blocks while the __noasync thread is running.
From these, the following is required to perform asynchronous processing in LuneScript.

*"Basically, __Runner handles __async, and __noasync processing is kept to the minimum necessary."*

For example, start __Runner immediately after starting it with __main (), and wait for the end of that __Runner with __join. The basic design is.


** Mechanism for safe asynchronous control

LuneScript prevents omission of exclusive control by the following.
- __async Declared function limits
- Restrictions on constructors for classes that extend __Runner
#+BEGIN_SRC lns
let mut list = [ 1, 2 ];
class Test {
   fn func() __async {
      foreach val in list {
         print( val );
      }
   }
}
#+END_SRC


For example, accessing list from func () above would normally result in a compile error, but if this is not an error, another thread updated the value of list while executing the func () method. In that case, references and changes to list occur at the same time, resulting in indefinite behavior.

To guard against this, there are restrictions on the functions declared in __async.

Also, if you execute the following code,
#+BEGIN_SRC lns
class Hoge extend (__Runner) {
   let list:List<int>;
   pub fn __init( list:List<int> ) __async {
      self.list = list;

      __run( self, __lns.runMode.Queue, "test" );
   }
   pub fn run() __async mut {
      self.list.insert(1);
   }
}

let mut workList = [1];
let hoge1 = new Hoge( workList );
let hoge2 = new Hoge( workList );
#+END_SRC


Originally, since the type of list in the constructor of Hoge is mutable, a compile error will occur, but if this is not an error, insert () will occur at the same time due to asynchronous processing of multiple Hoge for the same workList, and it is undefined. It will work.

To guard against this, there are restrictions on the constructor that extends __Runner.


*** Incomplete limits

As mentioned above, LuneScript exclusive control is incomplete.

As some of you may have already noticed, it is easy to cause indefinite behavior even if you follow the current restrictions.

For example, list2 accessed from func () in the code below is immutable because it is & List <int>, which satisfies the restrictions of the __async function.
#+BEGIN_SRC lns
let mut list = [ 1, 2 ];
let list2 = list;
class Test {
   fn func() __async {
      foreach val in list2 {
         print( val );
      }
   }
}
#+END_SRC


However, if list is updated from another thread while func is running asynchronously, list2 accessed by func is the same instance as list, so it behaves indefinitely.

The same can happen with constructor restrictions.

This is an incomplete limit, but it's a trade-off between the ease of programming development and the rigor of static checking, and LuneScript balances it to this specification. It has become.

We will continue to seek ways to improve the rigor of static checking while maintaining the ease of programming development.

-----


* Asynchronous processing O (past information)
:PROPERTIES:
:CUSTOM_ID: async_old
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

Taking the opportunity of transcompiling from LuneScript to go language, asynchronous processing by LuneScript is supported.

However, this is a very experimental content and should be used as a reference only.

*Abolished from 1.3.0. Keep this document as a past log.*


** LuneScript runtime

LuneScript has a runtime to bridge the gap between the LuneScript language specification and the language specification to which it is transcompiled.

For example, when transcompiling to go, the following processing is realized in ryetime.
- Cooperation with lua
- and or operator behavior
These processes are accessing the data declared in the runtime.

When LuneScript supports asynchronous processing, it is necessary to exclusively support data access in the runtime.

On the other hand, exclusive control by mutex etc. affects the performance even when single threaded.

In this asynchronous process, in order to minimize the impact on single threads, exclusive control was minimized, necessary data was duplicated, and the data to be accessed was switched for each thread.

Specifically, the runtime data required for "cooperation with lua" and "behavior of the and or operator" is duplicated for each thread and switched for each thread.

There is one problem here.

That is, go cannot get the ID of the thread that is currently running.

If the thread ID can be obtained, when accessing the runtime data, the current thread ID can be obtained and the access destination can be switched to the runtime data corresponding to that thread ID.

However, it cannot be done because the thread ID cannot be obtained.

If you can't do this, you'll need to pass the thread ID to all function arguments.

I really don't want to do this, so I thought of another method.

The following describes the asynchronous processing method introduced this time.


** Introduction and restrictions of the LnsThread class

When performing asynchronous processing with LuneScript, inherit the LnsThread class.

The LnsThread class is as follows:
#+BEGIN_SRC lns
// @lnsFront: skip
abstract class LnsThread {
   pro abstract fn loop() mut;
}
#+END_SRC


The LnsThread subclass overrides the loop () method and performs asynchronous processing within it.

When the following command is executed within a method of a subclass of LnsThread,
: _lune_control run_async_pipe;


The go routine loop () method is executed.

In order to inherit LnsThread, the following declaration must be made in advance.
: _lune_control use_async;


This is a command that declares asynchronous processing.

Within the module in which this command is executed, the following operations are restricted and can only be performed from within the methods of subclasses of LnsThread.
- and / or arithmetic
- nil conditional calculation
- Some built-in functions and method access
We have also added the __pipe <T> class as a way to send and receive data to and from asynchronous processing.

Think of the __pipe <T> class as equivalent to go's chan.

The __pipe <T> class is as follows:
#+BEGIN_SRC lns
// @lnsFront: skip
class __pipe<T> {
  pub fn get() mut : T!;
  pub fn put( val:T! ) mut;
}
#+END_SRC


Here, T in __pipe <T> must be a class that implements the __AsyncItem interface.

The val that was put () can be obtained by get (). If you give nil to put (val: T!), That __pipe will end communication, and even if you put () unexpectedly after that, get () will return nil.

The __AsyncItem interface implement class requires the Mapping interface to be implemented at the same time.

The following methods are added to the class that implements the __AsyncItem interface.
: pub static fn _createPipe( num:int ) : __pipe<T>!;


Where the argument num is the same as chan's cap.

Note that this =_createPipe()= function always returns nil when transcompiled to Lua.

To summarize the above, asynchronous processing is written as follows.
#+BEGIN_SRC lns
// @lnsFront: skip
_lune_control use_async;

class Test extend (__AsyncItem,Mapping) {
   let val:str {pub};
}

class Async extend LnsThread {
   let mut count:int {pub};
   let mut pipe:__pipe<Test>!;
   
   pub fn __init( pipe:__pipe<Test>! ) {
      super();
      self.pipe = pipe;
      self.count = 0;
   }
   
   pro override fn loop() mut {
      print( "hoge:" );
      while true {
         if! let mut pipe = self.pipe {
            let! val = pipe.get() {  // pipe からデータを取得
               print( "hoge:" );
               break;
            };
            val.$val.find( "%d" (self.count) ## );
            self.count = self.count + 1;
         }
      }
   }
   pub fn start() {
      _lune_control run_async_pipe;  // loop() 起動
   }
   pub fn put( test:Test ) mut {
      if! let mut pipe = self.pipe { // pipe にデータをセット
         pipe.put( test );
      }
   }
}

let mut async = new Async( Test._createPipe( 10 ) );
async.start();
let mut async2 = new Async( Test._createPipe( 10 ) );
async2.start();

for _ = 1, 100000 {
   async.put( new Test( "abcdefg" ) );
   async2.put( new Test( "abcdefg" ) );
}
print( async.$count, async2.$count );
#+END_SRC



*** Asynchronous processing restrictions

The behavior when the following processing is performed is undefined.
- Access data and methods of another module from within Loop ()
- Access the data and methods of the class that inherits LnsThread from another module
- Access data and methods between instances of classes that inherit LnsThread
As mentioned above, the specifications are very limited and inconvenient to use. This specification will definitely change in the future, so please use it as a reference only as mentioned at the beginning.

By the way, this is an asynchronous process with many restrictions, but it is used for the parse process of LuneScript, and it contributes a little to the speedup of LuneScript.

-----


* Collaboration with Lua
:PROPERTIES:
:CUSTOM_ID: luago
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript can execute Lua code.

This feature is preserved after transcompiling to the go language, but there are a few things to keep in mind.

Be especially careful with the combination of asynchronous processing and lua code execution.


** Luaval

*As already explained in the link, the result executed by lua is managed by Luaval type.*

[[#lua]]

This Luaval type data has the following restrictions.

*The Lua VM that runs to get the data dataA of type Luaval and the Lua VM that runs to access that dataA must be the same Lua VM.*

*The behavior is undefined if this limit is not met.*

If you do not handle Luaval in asynchronous processing, you need to be aware of which Lua VM is used because only one Lua VM is used.

*Note that "access to Luaval type data" does not include assignments between variables. In other words, the following ~work = val~ does not provide "access to Luaval type data", so you do not need to be aware of the Lua VM.*
#+BEGIN_SRC lns
fn func( val:&Luaval<&List<int>> ) {
   let work = val;
}
#+END_SRC



** Lua VM type

There are two types of Lua VMs:
- Lua VM running with __noasync
- Lua VM running on __async
  - Lua VM for __async exists for each asynchronous thread

When you run lua, you need to control which Lua VMs you access.

*The lua access block controls this.*


** lua access block

*There are the following types of lua access blocks: Also, the lua access block to use depends on whether the function to be accessed is __async or __noasync.*
- __luago
  - Used when accessing lua from __noasync function
  - This is a Lua VM for __noasync to access lua.
- __luaLock
  - Used when accessing lua from __async function
  - This is equivalent to the combination of __asyncLock and __luago.
- __luaDepend
  - Used when accessing lua from __async function
  - It is accessed by lua for the Lua VM associated with the currently running thread.
  - That is, if the currently running thread is __noasync, it will be accessed by the __noasync Lua VM, and if the currently running thread is __async, it will be accessed by the __async Lua VM.

*__luaDepend requires great care as the Lua VM used is determined at run time.*


*** sample

Below is a sample that executes the lua code.
#+BEGIN_SRC lns
// @lnsFront: ok
__luago {
   let code = ```
return { val1 = 10, val2 = 20 }
```;
   let loaded, err = _load( code, nil );
   when! loaded {
      if! let obj = loaded( ## ) {
         forsort val, key in obj@@Map<str,int> {
            print( key, val + 100 ); 
         }
      }
   } else {
      print( err );
   }
}
#+END_SRC


The code =return { val1 = 10, val2 = 20 }= of lua assigned to the variable code is executed, and the resulting Map is enumerated and output by foreach.

At the beginning of this, we declare __luago.


*** Use of lua access block properly

As mentioned above, in order to access Lua from asynchronous processing, it is necessary to use __luaLock and __luaDepend of lua access block properly.

However, you shouldn't use __luaDepend unless you're doing a lot of Lua's heavy work asynchronously.

By limiting to __luago and __luaLock instead of using __luaDepend, you may be able to minimize the load process in the Lua VM, reduce memory usage, and result in more efficient processing than running asynchronously.

*Also, if you use __luaDepend, you need to be careful about the lua VM used, and if you make a mistake, you will get uncertain results at run time.*

In order to use __luaDepend, it is necessary to carefully consider the advantages and disadvantages of asynchronous processing.


**** Cases where it is better to use __luaDepend

string.gmatch () requires a lua access block to access lua.

At this time, the Luaval data handled by string.gmatch () is closed in the apply block, so it is more efficient and safe to use __luaDepend.
#+BEGIN_SRC lns
   let mut list:List<str> = [];
   __luaDepend {
      apply token of string.gmatch( txt, pattern ) {
         list.insert( token );
      }
   }
#+END_SRC


-----


* Transcompiling to Go language (under consideration)
:PROPERTIES:
:CUSTOM_ID: go_study
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

For transcompiling support for Go language, refer to the following article.

[[#go]]

*The information here is out of date, but I'll leave it for reference only.*

Considering transcompiling from LuneScript to Go language.

Here, the content under consideration is recorded.


** aim

The aim of transcompiling from LuneScript to the Go language is as follows.
- Speed up LuneScript
  - LuneScript supports code completion, but large code is heavy and unusable.
  - By speeding up, the usability of LuneScript's code completion function will be improved.
- Upgrade work efficiency of LuneScript itself by speeding up
  - LuneScript's self-hosted build and test time is currently less than 2 minutes.
  - It's painful to take 2 minutes for each change, so go for speed.
  - We were working on transcompiling to C, but the GC implementation in C didn't go as planned, so we'll go ahead with Go, which supports GC at the language level.


** value
|-|-|-|
| LuneScript type | Go type | Type in Lns lantern for Go | 
|-+-+-|
| nil, null | interface{} | nil | 
| int | int | LnsInt (alias) | 
| real | float64 | LnsReal(alias) | 
| str | string | LnsStr (alias) | 
| bool | bool | LnsBool(alias) | 
| List | Unique structure | LnsList | 
| Array | arrangement | LnsArray | 
| Map | map | LnsMap | 
| Set | map (put item in key) | LnsSet | 
| class | Structure | 
| interface | interface | 
| form | func | LnsForm | 
| enum | int/float64/string | LnsEnum | 
| stem | interface{} | LnsStem | 
| nilable | interface{} | 


*** Handling of int / real

LuneScript int / real is defined using go's type alias as follows:
#+BEGIN_SRC go
type LnsInt = int
type LnsReal = float64
#+END_SRC



*** Handling of nilable

LuneScript nilable cannot be treated as the original value as it is. However, you can check if they are equal. This is the same as go and LuneScript.


*** Handling of boolean values

LuneScript has nil and false false, otherwise true. Since go needs to be judged by true / false, prepare a conditional conversion function for LuneScript.


*** Handling of and / or

LuneScript's and / or is not a logical operation, it controls the evaluation of expressions, and the evaluation result is not bool. The evaluation result of go is bool.


*** Handling of generics

Since go does not have Generics, all Generics types are handled by interface {}.


*** Handling of Set

Since go does not have Set, Map is used instead.


** Multi-value return

Multi-valued return of go and LuneScript behaves differently.

When hoge () is a multi-valued return function that returns x and y, the actions are as follows.
|-|-|-|
| code | LuneScript deployment result | go deployment result | 
|-+-+-|
| (hoge()) | x | x, y | 
| hoge(), val | x, val | x, y, val | 

To realize the above difference, go prepares the following conversion function.
#+BEGIN_SRC go
// 多値返却の先頭 int を返す
func carInt( multi ...interface{} ) int {
    if len( multi ) == 0 {
        panic( "nothing" )
    }
    return multi[0].(int)
}
// 多値返却の先頭 int! を返す
func carIntN( multi ...interface{} ) interface{} {
    if len( multi ) == 0 {
        return nil
    }
    if multi[0] == nil {
        return nil
    }
    return multi[0].(int)
}
#+END_SRC



** Classes and inheritance

Go has structs and receivers, but no inheritance.

LuneScript has inheritance, so you need to implement inheritance in Go.

Here's how to support the following LuneScript class in Go.
#+BEGIN_SRC lns
// @lnsFront: ok
interface IF {
  pub fn sub1():int;
}
class Parent {
   let val1:int;
   pub fn sub1():int {
      return self.val1;
   }
}
class Sub extend Parent {
   let val2:int;
   pub override fn sub1():int {
      return self.val2;
   }
   pub fn sub2():int {
      return self.val2;
   }
}
class SubSub extend Sub {
   let val3:int;
   pub override fn sub1():int {
      return self.val3;
   }
   pub fn sub3():int {
      return self.val3;
   }
}
#+END_SRC



*** Equivalent code by Go

Show the equivalent code by Go
#+BEGIN_SRC go
package main

import "fmt"

type ParentMtd interface {
    sub1 () int
}
type Parent struct {
    val1 int
    FP ParentMtd
}
type ParentDownCast interface {
    ToParent() *Parent
}

func (obj *Parent ) ToParent() *Parent {
    return obj
}


func (self *Parent) sub1() int {
    return self.val1
}

func NewParent(val1 int) *Parent {
    parent := Parent{ val1, nil }
    parent.FP = &parent
    return &parent
}

type SubMtd interface {
    ParentMtd
    sub2 () int
}

type Sub struct {
    Parent
    val2 int
    FP SubMtd
}
type SubDownCast interface {
    ToSub() *Sub
}

func (obj *Sub ) ToSub() *Sub {
    return obj
}


func (self *Sub) sub1() int {
    return self.val2
}
func (self *Sub) sub2() int {
    return self.val2
}

func newSub(val1,val2 int) *Sub {
    sub := Sub{ Parent{ val1, nil }, val2, nil }
    sub.Parent.FP = &sub
    sub.FP = &sub
    return &sub
}


type SubSubMtd interface {
    SubMtd
    sub3 () int
}

type SubSub struct {
    Sub
    val3 int
    FP SubSubMtd
}
type SubSubDownCast interface {
    ToSubSub() *SubSub
}

func (obj *SubSub ) ToSubSub() *SubSub {
    return obj
}
func (obj *SubSub ) ToSub() *Sub {
    return &obj.Sub
}

func (self *SubSub) sub1() int {
    return self.val3
}
func (self *SubSub) sub2() int {
    return self.Sub.sub2()
}
func (self *SubSub) sub3() int {
    return self.val3
}


func newSubSub(val1,val2,val3 int) *SubSub {
    subsub := SubSub{ Sub{ Parent{ val1, nil }, val2, nil }, val3, nil }
    subsub.Parent.FP = &subsub
    subsub.Sub.FP = &subsub
    subsub.FP = &subsub
    return &subsub
}

func testParent( obj *Parent ) {
    fmt.Println( obj.FP.sub1() )
}

func testSub( mess string, obj *Sub ) {
    fmt.Println( mess, obj.FP.sub1(), obj.FP.sub2() )
}

func testCast( obj *Parent ) {
    cast, ok := obj.FP.(SubDownCast)
    if ok {
        testSub( "cast", cast.ToSub() )
    } else {
        fmt.Println( "cast NG" )
    }
    
}

func Lns_init() {
    subsub := newSubSub( 1, 2, 3 )
    fmt.Println( subsub.val1, subsub.val2, subsub.val3 )
    fmt.Println( subsub.FP.sub1(), subsub.FP.sub2(), subsub.FP.sub3() )
    testSub( "subsub.Sub", &subsub.Sub )
    testParent( &subsub.Parent )
    testCast( &subsub.Parent )

    sub := newSub( 1, 2 )
    testSub( "sub", sub )
    testParent( &sub.Parent )
    testCast( &sub.Parent )

    testCast( NewParent( 1 ) )
}
#+END_SRC



*** Inheritance realization method


**** Parent class

First, the Parent class will be described.
#+BEGIN_SRC lns
// @lnsFront: ok
class Parent {
   let val1:int;
   pub fn sub1():int {
      return self.val1;
   }
}
#+END_SRC



***** data structure

To represent the Parent class, define the following structure and interface.
#+BEGIN_SRC go
type ParentMtd interface {
    sub1 () int
}
type Parent struct {
    val1 int
    FP ParentMtd
}
type ParentDownCast interface {
    ToParent() *Parent
}
func (obj *Parent ) ToParent() *Parent {
    return obj
}
#+END_SRC

- The ParentMtd interface has the following roles:
  - Define methods for Parent class
  - Expressing the morimorphism of the Parent class
- Parent structure has members and ParentMtd
- ParentDownCast is defined per class for downcast


***** Method

To represent the method of Parent class, define the following receiver function.
#+BEGIN_SRC go
func (self *Parent) sub1() int {
    return self.val1
}
#+END_SRC



***** constructor

Define the following as the constructor of the Parent class.
#+BEGIN_SRC go
func NewParent(val1 int) *Parent {
    super := &Parent{ val1, nil }
    super.FP = super
    return super
}
#+END_SRC


This constructor does the following:
- Member initialization
- FP settings


***** How to use the Parent class

Parent is used as follows.
#+BEGIN_SRC go
parent := NewParent( 1 )
print( parent.FP.sub1() )
#+END_SRC


When calling a method, be sure to call it through the FP interface.


**** Sub class

Describe the Sub class.
#+BEGIN_SRC lns
// @lnsFront: skip
class Sub extend Parent {
   let val2:int;
   pub override fn sub1():int {
      return self.val2;
   }
   pub fn sub2():int {
      return self.val2;
   }
}
#+END_SRC



***** data structure

To represent the Sub class, define the following structure and interface.
#+BEGIN_SRC go
type SubMtd interface {
    ParentMtd
    sub2 () int
}
type Sub struct {
    Parent
    val2 int
    FP SubMtd
}
type SubDownCast interface {
    ToSub() *Sub
}
func (obj *Sub ) ToSub() *Sub {
    return obj
}
func (obj *Sub ) ToParent() *Parent {
    return &obj.Parent
}
#+END_SRC

- The SubMtd interface declares the methods defined in Sub.
  - Do not include Parent methods
- The Sub structure declares the data of the Parent structure and the members defined in Sub.


***** Method

To represent the method of Sub class, define the following receiver function.
#+BEGIN_SRC go
func (self *Sub) sub1() int {
    return self.val2
}
func (self *Sub) sub2() int {
    return self.val2
}
#+END_SRC



***** constructor

Define the following as the constructor of the Sub class.
#+BEGIN_SRC go
func newSub(val1,val2 int) *Sub {
    sub := &Sub{ Parent{ val1, nil }, val2, nil }
    sub.Parent.FP = sub
    sub.FP = sub
    return sub
}
#+END_SRC


This constructor does the following:
- Member initialization
- FP settings
  - The super FP is also set here
  - Achieve polymorphism by setting & sub instead of & super in the FP of this super


**** SubSub class

Describes the SubSub class.
#+BEGIN_SRC lns
// @lnsFront: skip
class SubSub extend Sub {
   let val3:int;
   pub override fn sub1():int {
      return self.val3;
   }
   pub fn sub3():int {
      return self.val3;
   }
}
#+END_SRC



***** data structure

To represent the SubSub class, define the following structure and interface.
#+BEGIN_SRC go
type SubSubMtd interface {
    SubMtd
    sub3 () int
}

type SubSub struct {
    Sub
    val3 int
    FP SubSubMtd
}
type SubSubDownCast interface {
    ToSubSub() *SubSub
}
func (obj *SubSub ) ToSubSub() *SubSub {
    return obj
}
func (obj *SubSub ) ToSub() *Sub {
    return &obj.Sub
}
func (obj *SubSub ) ToParent() *Parent {
    return &obj.Parent
}
#+END_SRC

- The SubSubMtd interface declares the methods defined in SubSub.
  - Do not include Sub methods
- The SubSub structure declares the data of the Sub structure and the members defined in SubSub.


***** Method

Define the following receiver function to represent the methods of the SubSub class.
#+BEGIN_SRC go
func (self *SubSub) sub1() int {
    return self.val3
}
func (self *SubSub) sub2() int {
    return self.Sub.sub2()
}
func (self *SubSub) sub3() int {
    return self.val3
}
#+END_SRC



****** Method definition not overridden

Of note above is the fact that the sub2 () method calls =self.Sub.sub2()=.

The SubSub class does not override the sub2 method. In other words, the sub2 method of SubSub will use the method of the Sub class. Therefore, we are calling the Sub.sub2 method.


***** constructor

Define the following as the constructor of the SubSub class.
#+BEGIN_SRC go
func newSubSub(val1,val2,val3 int) *SubSub {
    subsub := &SubSub{ Sub{ Parent{ val1, nil }, val2, nil }, val3, nil }
    subsub.Parent.FP = subsub
    subsub.Sub.FP = subsub
    subsub.FP = subsub
    return subsub
}
#+END_SRC


This constructor does the following:
- Member initialization
- FP settings
  - Parent and Sub FPs are also set here
  - Achieve polymorphism by setting & subsub in the FP of Parent and Sub


**** IF interface
#+BEGIN_SRC lns
// @lnsFront: ok
interface IF {
  pub fn sub1():int;
}
#+END_SRC



***** data structure

The LuneScript interface uses the Go interface as it is.
#+BEGIN_SRC go
interface IF {
  pub fn sub1():int;
}
#+END_SRC



**** Method call

To call a method of the Parent class:
#+BEGIN_SRC go
func test(parent *Parent) int {
  print( parent.FP.sub1() )
  print( parent.sub1() )
}  
#+END_SRC



***** Difference between parent.FP.sub1 () and parent.sub1 ()

There are two patterns of method calls:
- parent.FP.sub1()
  - Method call corresponding to polymorphism
- parent.sub1()
  - Method call defined in Parent class
    - Not compatible with polymorphism


***** overhead
- Method calls that support polymorphism have a large overhead.
- Method calls that support polymorphism should be limited to cases where polymorphism is required.
- There is currently no definition in LuneScript as to whether polymorphism is needed.
  - Need to introduce final declarations in classes and methods to make it clear that polymorphism is not needed


**** up-cast / down-cast
- up-cast is achieved by accessing the embedded pointer
  - Up-cast to an interface uses the interface type held by the object
- down-cast implements interface with type assertions.
  - Define a DownCast interface for each class, cast to that interface, and then execute the cast function to the desired class.
#+BEGIN_SRC go
var ifObj IF = obj.FP // インタフェースをセットする
parent := &obj.Parent // アップキャスト
(parent.FP.(SubDownCast)).ToSub() // obj を Sub にダウンキャストする
#+END_SRC



*** Class summary
- Declare an interface that defines the methods of the class
  - Embed the interface of the method defined in the Super class
#+BEGIN_SRC go
type TestMtd interface {
    SuperMtd
    method() int
}
#+END_SRC

- Declare a structure that holds the members of the class and the interface above
  - Inheritance embeds the inherited type
#+BEGIN_SRC go
type Test struct {
    Super
    val int
    FP TestMtd
}
#+END_SRC

- Define an interface for downcasting
#+BEGIN_SRC go
type TestDownCast interface {
    ToTest() *Test
}
#+END_SRC

- Define a method for downcasting
  - This method declares everything for the Super class
#+BEGIN_SRC go
func (obj *SubSub) ToSub() *Sub {
    return &obj.Sub
}
#+END_SRC

- Declare a receiver that defines the behavior of the methods in the class
  - The receiver declares including the methods of the Super class
  - Functions that are not overridden call the methods of the structure that defines the method.
#+BEGIN_SRC go
func (self *Test) method() int {
    return self.super.method()
}
#+END_SRC

- Initialize the members and interface FP in the constructor
  - The interface is initialized to include the interface FP of the Super class.
- Method calls are made via interface FP
  - Polymorphism Invalid method call calls the method of the structure directly
#+BEGIN_SRC go
obj.FP.method() // ポリモーフィズム有効
obj.method()    // ポリモーフィズム無効
#+END_SRC

- up-cast is realized by accessing the pointer of the member Super class.
  - Up-cast to an interface uses the interface type held by the object
- down-cast implements an interface with type assertions and an interface for downcasting.
#+BEGIN_SRC go
var ifObj IF = obj.FP // インタフェースをセットする
super := &obj.super // アップキャスト
(parent.FP.(SubDownCast)).ToSub() // obj を Sub にダウンキャストする
#+END_SRC

- The interface uses Go's interface as it is
  - Use interface FP when up-casting from a class object to an interface


** Symbol name

The LuneScript and go symbol names differ significantly in the following ways:
- Namespace
  - LuneScript is in the same file (module)
  - go is in the same directory (package)
- Public / private control method
  - LuneScript is controlled by pub / pro etc.
  - go is controlled by the case of the first letter of the symbol
This difference causes the following problems.
- When different files FileA.lns and FileB.lns are defined with the same name symbol sym in LuneScript, when converting this to go, if the symbol sym with the same name is defined in FileA.go and FileB.go with the same configuration. , The symbol sym results in a duplicate definition error.
- Symbols that are publicly defined in lowercase in LuneScript are private in go.
  - Symbols that are defined privately in uppercase in LuneScript are made public in go.
To address this issue, we process symbol names as follows:

Add the file name to the beginning of the symbol of the function or class to be controlled as public or private. If it is public, add G (G of GLOBAL), and if it is private, add l (l of local).

So if you want to convert the following LuneScript source to go,
#+BEGIN_SRC lns
// @lnsFront: ok
fn func() {
}
pub class Class {
   let val1:int;
   pub let val2:int;
}
#+END_SRC


The relationship between the LuneScript and go symbols is as follows.
|-|-|-|
| Public / Private | lns | go | 
|-+-+-|
| private | func | lfile_func | 
| Release | Class | Gfile_Class | 
| private | val1 | lval1 | 
| Release | val2 | Gval2 | 

Since there is no difference in scope between LuneScript and go for arguments and local variables, they are basically converted as they are.


** Lua VM

The current LuneScript uses Lua VM when deploying Macro. There are two ways to use the Lua VM with Go:
- Use gopher-lua, a port of Lua to Go
- Use liblua
Using gopher-lua makes it easier to work with Lua VMs, but with the following limitations:
- Lua VM version becomes Lua5.1
- Slow compared to liblua
  - According to the information on the official Wiki (<https://github.com/yuin/gopher-lua/wiki/Benchmarks>), the execution time of fib (35) is as follows.
    - lua5.1.4 :: 1.71sec
    - Gopherlua :: 5.40sec
From the above, the LuneScript transcompiler uses liblua.


*** cgo

Use cgo to use liblua from Go.

cgo is a package for calling C language libraries from Go.

The C code written in the comment before import "C" is parsed and extracted into the C package so that it can be accessed from Go as follows.
#+BEGIN_SRC go
// #include <stdlib.h>
// #cgo CFLAGS: -I/usr/include/lua
// #cgo LDFLAGS: -ldl -lm -llua
// #include <lauxlib.h>
// #include <lualib.h>
import "C"

import "unsafe"

// lua のコードを実行する
func lua_runScript( script string ) {
    var vm * C.lua_State = C.luaL_newstate()
    if vm == nil {
        return
    }
    defer C.lua_close( vm )
    
    C.luaL_openlibs( vm )

    block := C.CString( script )
    defer C.free( unsafe.Pointer( block ) )
    
    C.luaL_loadstring( vm, block )
    C.lua_pcallk( vm, 0, C.LUA_MULTRET, 0, 0, nil )
}

func main() {
   lua_runScript( "print( 'hello world' )" )
}
#+END_SRC


*Since cgo does not support the #define macro function, the following macro-defined functions must be expanded and written by themselves.*
#+BEGIN_SRC c
#define luaL_dostring(L, s) \
	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
#+END_SRC


-----


* * Tag jump by lnstags (source code tag system) *
:PROPERTIES:
:CUSTOM_ID: lnstags
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript supports tag jump (source code tag system).


** What is Tag Jump (Source Code Tag System)?

Tag jumps provide access to the following information in the source code:
- Definition position of symbols (classes, functions, variables etc ..)
- Reference position of symbols (classes, functions, variables etc ..)


*** example

An example is shown below.
#+BEGIN_SRC lns
// @lnsFront: ok
class Foo {
   pub fn func() {
   }
}
class Bar {
   pub fn func() {
   }
}
let foo = new Foo();
foo.func();
let bar = new Bar();
bar.func();
#+END_SRC


For example, if you have a mini.lns file like the one above, to list the definition locations for the func method of the Foo class, run the following command:
#+BEGIN_SRC txt
$ lnstags inq def @mini.Foo.func
@mini.Foo.func      2 mini.lns            pub fn func() {
#+END_SRC


To list the reference positions for the func method of the Bar class, run the following command:
#+BEGIN_SRC txt
$ lnstags inq ref @mini.Bar.func
@mini.Bar.func     12 mini.lns         bar.func();
#+END_SRC


Details on how to use the lnstags command will be described later.


** Features of lnstags

In addition to the general tag jump function, lnstags provides the following functions.
- List of places where variable values are set
  - It distinguishes between setting a value and referencing it, and can list only where the value is set.
- Consideration of inheritance relationship
  - When calling a method that is overridden, the method that is actually called depends on polymorphism.
  - lnstags lists all the methods that can be called.


** How to use

lnstags is published at the following URL.

<https://github.com/ifritJP/lnstags>


*** How to build

There are two build methods:
- Use go install
- Close the repository and make
Normally go install is fine.


**** go install 

The following will install lnstags in $ GOPATH / bin.
: go install -tags gopherlua github.com/ifritJP/lnstags@latest



**** Build with go.
#+BEGIN_SRC txt
$ git clone --depth 1 https://github.com/ifritJP/lnstags
$ cd lnstags
$ make build ONLY_GO=y
#+END_SRC


The above will generate lnstags / lnstags.


*** Source code analysis

The source code is analyzed on the project directory of the source code to be analyzed.
#+BEGIN_SRC txt
$ cd proj  // lune.js を置いてあるディレクトリに移動する
$ lnstags init
$ lnstags build test/main.lns
#+END_SRC


*The lnstags build should be run with one of the following:*
- Specify the main .lns file for your project
: $ lnstags build main.lns

- Specify as =lnstags build @-= and specify the path of the .lns file to stdin line by line.
: $ find . -iname '*.lns' | lnstags build @-


lnstags parses all imported modules from the specified lns file.

This means that in most cases you just need to specify the main .lns file.

The latter case is used when not all modules can be traced from one lns file.

*Note that the current lnstags do not support delta updates.*

*Therefore, if you use @-for build, you need to specify all .lns files.*

*The analysis result of the source code is registered in the lnstags.sqlite3 file.*


*** DB update

If the source code is changed after analysis by =lctags build=, the information registered in the DB and the actual source code information will be inconsistent.

*To update the DB, do one of the following:*
- Run =lctags build= again.
- Run =lctags update=.
: $ lctags update



**** lctags update

=lctags update= updates the information based on the lns source file list registered in the DB.

Unlike =lctags build=, there is no need to specify the source file to parse.

If the number of lns files to be parsed increases or decreases, =lctags build= must be used instead of =lctags update=.


*** Inquiry

After parsing the source code with =lnstags build=, query the symbol information.

There are the following patterns for inquiries.
- inq
- inq-at
- suffix


**** inq

inq makes a query by specifying the symbol name.
#+BEGIN_SRC lns
// @lnsFront: ok
class Foo {
   pub fn func() {
   }
}
class Bar {
   pub fn func() {
   }
}
let foo = new Foo();
foo.func();
let bar = new Bar();
bar.func();
#+END_SRC


For example, if you had a mini.lns file like the one above, the symbol name for the func method of the Foo class would be:
: @mini.Foo.func


Where @mini indicates the module name and mini refers to mini.lns. For example, in the case of abc / def / ghi.lns, the module name will be @ abc. @ Def. @ Ghi. =Foo.func= points to the func method of the Foo class.

Then, by executing the following command, the definition position of @ mini.Foo.func is listed.
#+BEGIN_SRC txt
$ lnstags inq def @mini.Foo.func
@mini.Foo.func      2 mini.lns            pub fn func() {
#+END_SRC


*The def of this command =lnstags inq def= specifies a definition location query.*


**** Inquiry mode

The types of inquiries are as follows.
|-|-|
| option | motion | 
|-+-|
| def | Definition position | 
| ref | Reference position | 
| set | Setting position | 


**** inq-at

If you know the fully qualified name of the symbol you want to query, you can use the inq command, but finding the fully qualified name can be difficult or cumbersome.

*Therefore, inq-at makes an inquiry about the symbol at a predetermined position in the source.*

When querying the definition location of foo.func () in the 5th column of the 10th row when the following source is available
#+BEGIN_SRC lns
// @lnsFront: ok
class Foo {
   pub fn func() {
   }
}
class Bar {
   pub fn func() {
   }
}
let foo = new Foo();
foo.func();
let bar = new Bar();
bar.func();
#+END_SRC


Execute the following command.
#+BEGIN_SRC txt
$ lnstags inq-at def mini.lns 10 5
@mini.Foo.func      2 mini.lns            pub fn func() {
#+END_SRC


This will inquire about the symbol at the specified location.

*In the above case, we recognize that the fully qualified name of =foo.func= in mini.lns 105 is @ mini.Foo.func and make a def query about it.*

*When using inq-at, the specified lns file must be able to be built without error.*

It also takes time to parse the AST of the specified lns file.


**** suffix

inq-at gets the fully qualified name by specifying the location of the lns file, while suffix gets the list of fully qualified names with a suffix match of the symbol name.

For example, to display a list of fully qualified names that end in func, do the following:
#+BEGIN_SRC txt
$ lnstags suffix func
@mini.Foo.func
@mini.Bar.func
#+END_SRC



** When using from emacs

Load lisp / lnstags-conf.el.

The key bindings are as follows.
|-|-|
| Key | operation | 
|-+-|
| M-t | Of the symbol at the cursor position | Definition position |  Jump to | 
| M-r | Of the symbol at the cursor position | Reference position |  Jump to | 
| M-s | Of the symbol at the cursor position | Setting position |  Jump to | 
| M-m | Tag jump history | 
| C-t | Jump back | 

For M-t, M-r, M-s, it performs a suffix query to get a fully qualified name, lists the fully qualified names that match the symbol, and makes an inq query for the selected fully qualified name.

By adding the prefix C-u to M-t, M-r, and M-s, the inq-at query for the cursor position is performed.


** Analysis time

lnstags uses the AST analysis part of the LuneScript transcompiler to register the symbol information in the source code to be analyzed in the DB.

*Therefore, the time required for DB registration is almost equivalent to the transcompile time of the Lns file.*

Parsing LuneScript's self-hosted code takes less than 10 seconds.

By performing the heaviest AST analysis of the source code tag system in the LuneScript module, the code of lnstags itself has a simple structure of over 2000 lines. (As of 2021)

The lnstags themselves are also developed with LuneScript.

As mentioned earlier, lnstags does not support DB diffs. This is because we have determined that there are currently no large-scale LuneScript projects that take such a long time.

If you are using LuneScript for a large project, please contact me for reference.

-----


* Why Lua's transcompiler LuneScript was developed
:PROPERTIES:
:CUSTOM_ID: reason
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <style type="text/css"> <!-- pre.src { color: #ffffff; background-color: #101010; } --> </style>

Lua is a lightweight, high-performance language. Lua's name recognition is low compared to the same scripting languages such as Ruby, Python, and JavaScript, but it can be said to be one of the most major and easy-to-embed languages that can be used to extend the system. In fact, there are many systems that incorporate Lua.

Also, in terms of execution performance, it is in the high-speed category as a scripting language. Without DSP-like processing, it is unlikely to become a system performance bottleneck.

I myself have experience in developing some software (both hobbies and business) using Lua, and it is one of the languages I often use.


** Why Lua's transcompiler LuneScript was developed

Lua is one of my favorite languages. However, for the following reasons, I stopped writing Lua code directly and started thinking about developing it using the transcompiler LuneScript.
- I want to write comfortably and safely
- Lua has problems specific to dynamically typed languages
  - Cannot static error check
  - Difficult to grasp the contents of other people's code
  - Large risk of maintenance, function addition, and refactoring
  - Complementation at the time of coding is not good
  - Field access control in the table is not possible
- I'm dissatisfied with Lua's features
  - nil unsafe
  - No macro
- There are few alternatives to Lua's characteristics of built-in ease and high execution performance.
- Already use Lua on many systems
Each will be described below.


*** I want to write comfortably and safely

Yukihiro Matsumoto of Ruby wants Ruby to be fun.

I don't want LuneScript to be fun. No, I want to have more fun than I want.

Of course, it's better to have fun doing anything. I personally enjoy software development as a hobby (free of charge) in my private time.

Nowadays, even pure software stores that cannot be sold can get jobs that can receive guarantees using services like CrowdWorks. In such an era, the motivation to spend private time and develop free software is nothing but "fun".

However, software development itself is fun, but weird bug fixing and test code creation are not fun. The reason why such unpleasant work is necessary is that bugs are easy to get into software development, and the software will not work properly unless the bugs are removed.

Again, this task is not fun. It may be fun for some people, but at least for me it's a penance. Well, there is a sense of accomplishment that I've done it, but I don't want to bother to kill my private time, regardless of work.

I want to enjoy and secure software development without doing such unpleasant work as much as possible.

Perl author Larry Wall cites "laziness, impatience, and arrogance" as the three major virtues of a programmer. I think "fun and safe software development" is quite similar to this.

Lua doesn't provide a mechanism for easy and secure software development. If it's not provided, you can just make it yourself.

I spare no effort to make it easier.

This is the number one reason I develop LuneScript.


*** Problems specific to dynamically typed languages

I'm not denying dynamically typed languages.

I myself often write processes in dynamically typed languages, and I don't want to use statically typed languages when writing simple processes that are less than 100 lines.

The problem with dynamically typed languages here is when using dynamically typed languages for scripts that may be developed by an unspecified number of people, rather than scripts created by individuals and maintained by themselves. , It is mentioned that it tends to be a problem.


**** Cannot static error check

Humans make mistakes.

If you're a software engineer coding full-time, you'll probably have countless experiences passing the wrong type of data as an argument with both hands and feet. A common mistake is when you pass a parsed result of a numeric string input to a function, the function asks for a numeric value, but passes the parsed string data as is, for example. When I think about it, I can think of many other things.

When developing with multiple members, the probability of making mistakes due to communication mistakes etc. further increases.

If it is a statically typed language, you will notice a mistake at compile time or at coding time with a type mismatch error.

But in a dynamically typed language, you can't tell until you actually run it. In some cases, it does not occur simply by moving it, but it occurs only at a specific path or at a specific timing.

Simple mistakes often cause serious problems later on, and often require a great deal of cost to reach the cause.

I think there is an idea that "tests can cover it", but writing tests is not free. As I wrote at the beginning, I don't enjoy writing tests. If the compiler guarantees me without writing tests, I'll take that one.

It is possible to do some static checking on code written in a dynamically typed language. However, it is much more expensive and less accurate than that of statically typed languages.

With a statically typed language, at least type-related mistakes can be reliably parsed statically.

Of course, it can't be parsed if you make it an arbitrary type like void * in c or Object in java, or if you use forced type conversion.

In the future, I believe that static analysis technology will evolve through technologies such as deep learning, making it easier to develop software. And I think it's a statically typed language that supports such development, not a dynamically typed language.

Well, maybe it's a different paradigm.


**** Difficult to grasp the contents of other people's code

Other people's code is harder to grasp than the code I wrote. This is natural.

That's not what I want to say here.

Nor is it a low level of indentation, non-compliance with coding conventions, or anything else.

No matter how well-known engineers write, if Sole is written in a dynamically typed language, it's harder to understand than code written in a statically typed language.

This is because the type information of data, which is an important factor of the program, is hardly written. If some engineers say that type information is not very important, it is better to re-unit the "algorithm and data structure".

The type can be predicted from the symbol name. Also, the symbol name should be given as such.

However, this is just an expectation, not a fact. When developing software, I don't want to rely on detective games.

Others may argue that the type information is included in the comments or documentation and should be checked. However, comments and documentation often deviate from the implementation, and if you can understand it at a glance and if you can't understand it without looking at the code + α, I can understand it at a glance. Better.

As I say many times, I want to have fun.


**** Large risk of maintenance, function addition, and refactoring

It's rare that you don't modify any code once you've created it.

There are many reasons why the OS you are running has changed, you need to add features, or you have found a potential bug, but there are many opportunities to modify existing code.

When modifying such existing code, dynamically typed languages are more risky than statically typed languages.

Again, some might say, "If you write the test well, there's no problem." However, although the answer is half correct, it is half lost.

"Modifying" is synonymous with "behavior changes". There is a difference in the degree of change, but there is no difference in the change. And if the behavior changes, it is not safe to have a test.

The reason is that the test is to confirm that the behavior is correct, and since the behavior changes, the test cannot be used as it is. Of course, not everything can be used, but it can be limited to changes in behavior.

Now, let's return to the topic of dynamically typed and statically typed languages.

Why is a dynamically typed language more risky when modifying existing code than a statically typed language? The reason is that it is difficult to completely correct the affected parts by modifying them.

If it is a statically typed language, it can be said that the correction is almost completed as long as it is compiled. On the other hand, in dynamically typed languages, it is often said that even if you try to run a test after fixing everything, it will not work properly due to an error due to omission of correction. After crushing the errors one by one, it is finally completed.

Considering which takes longer to deal with compile errors or test errors, it's overwhelmingly test errors. If it's a compile error, you can just correct the line of the compile error, but if it's a test error, it adds extra work to identify the cause of the error. Furthermore, if there is a leak in the existing test itself, it may not be possible to find the correction leak itself.

Also, it is still good if the worker who modifies the module is the module creator himself, but it is not uncommon for a completely different person to handle it. In that case, the risk is further increased by the synergistic effect of "it is difficult to grasp the contents of the code of another person" mentioned earlier.

I made many design changes during the development of LuneScript, but it's a chill to imagine if I was doing this in a dynamically typed language.


**** Complementation at the time of coding is not good

A decent complementary feature is essential to make coding easier.

Nowadays, even in dynamically typed languages, the coding completion function is working quite hard. But don't you have a disappointing experience with the candidates listed by that complement? Or isn't there something that should be listed in the first place not listed at all?

Complementing dynamically typed languages is quite difficult. This is because the completion function recognizes completion candidates based on the type information, but it is difficult for dynamically typed languages to recognize them statically.

In a statically typed language, type information can be determined statically, so type-related completion can be achieved accurately.

Of course, LuneScript also provides completion.

See the next article for details.

[[#completion]]


**** Field access control in the table is not possible

Access control is important.

This is because it is possible to specify which data / function can be accessed.

As a major premise at the time of design, it is common sense to disclose functions and data that can be used from the outside, and to keep functions and data that cannot be guaranteed to operate when used from the outside.

However, Lua does not allow this for table fields.

Perhaps dynamic control is possible with metatable, but at least static control is not possible.

As I say many times, it is only better to detect an error dynamically than it can detect an error statically, which is overwhelmingly inconvenient.

Even in languages with access restrictions, you may be able to access functions and data that were kept private by using the reflection function, but this is not a problem.

Because access control clearly indicates the intention of the module designer, and if another person accesses the module without understanding the intention, the access is out of the designer's intention. Because I think the purpose is to inform you.

Especially when writing test code, it may be required to be able to access private functions / data, so having a means to access private functions / data is not a problem in itself.

The problem is that there is no such control and everything is accessible.


*** I'm dissatisfied with Lua's features

Lua is a compact and powerful language, but there are many features that plain Lua doesn't support.

One of the purposes of the transcompiler is to support functions that are not supported by plain Lua without modifying Lua.


**** nil unsafe

Lua's nil is a useful value, but it also causes dynamic errors. Many engineers are plagued by this nil-related error.

It is nil safe to solve that problem.

Many of the essential features of today's programming have already been realized since the days of Lisp. For example, GCs, lambda expressions, closures, etc. have been around for decades.

In other words, it can be said that it has hardly evolved since that time.

"Almost not evolved" also means "somewhat evolved", and nil safety may be included in one of the evolutions. It's that important.

However, Lua doesn't support nil safety, which is a significant deduction for Imadoki's language.

By the way, Rust addresses the danger of nil (null) with the concept of lifetime and ownership. When I first saw this approach, I was very interested in "Is there such a way?"

In addition, Rust solves various problems such as memory management and data access conflicts, as well as nil security, depending on lifetime and ownership.

If you've never touched Rust, be sure to check out Lifetime and Ownership.

Quiet talk break.

LuneScript manages nilable, which can take nil, and non-nilable, which cannot take nil, as different types to prevent nil errors from occurring at unintended timings.

It also supports unwrapping of nilable to non-nilable type conversions and nil conditional operators for easy access to multi-tiered nilable data, making nil error handling easier and safer. ..


**** No macro

Speaking of macros, Lisp has very powerful macros and can be said to be representative of languages that have macros. It is no exaggeration to say that macros underpin the appeal of Lisp.

However, I feel that many relatively new languages do not support macros.

Why does even C language have "what a macro"?

Well, even if the language itself doesn't have macros, it may be safe to say that macros are unnecessary if a separate engineer creates a script that automatically generates code from some data.

However, doing so would flood "some data" and "automatically generated scripts."

I think macros are necessary to prevent this from happening.

However, macros as sophisticated as Lisp are difficult to implement, and users need some learning.

With LuneScript, we have prepared macros that are easy to implement, have no burden on the user, and are easy for anyone to use and effective.

I also use macros in LuneScript's self-hosting, but I feel once again that macros are an integral part of programming languages.


*** There are few alternatives to Lua's characteristics of built-in ease and high execution performance.

As mentioned earlier, Lua is one of the easiest languages to integrate into your system.

In particular, its compactness and the ability to compile with only standard C functions are very useful for embedding.

There are several other languages that are conscious of embedding, but I don't know any language that goes beyond Lua in terms of embedding.


*** Already use Lua on many systems

There are many systems that incorporate Lua.

Once embedded in a system, Lua will stay alive if there isn't much to do as long as the system is alive.

Just because you don't like it doesn't mean you can change it.


** Lastly

LuneScript is being developed to make up for Lua's shortcomings.

This isn't because it's a language that Lua can't use, but because it's a regrettable language to neglect Lua's shortcomings and flirt with other languages.

If you have a chance to consider embedded languages in the future, please consider that Lua has LuneScript.

Again, Lua is a lightweight, high-performance language. And keep in mind that Lua also has an option called LuneScript.

-----


* Transcompiler development recommendations
:PROPERTIES:
:CUSTOM_ID: recommend
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

The final article on the Advent Calendar introductory to LuneScript will change the mindset and deal with transcompiler development itself.


** Reasons for promoting transcompiler development

I am developing a transcompiler called LuneScript.

Through this development, I feel that I have had a good experience as an engineer.

The reason for developing LuneScript is described in the next article.

[[#reason]]

I decided to write this article because I wanted many people to experience transcompiler development for the following reasons.
- Can constructively resolve dissatisfaction with the current situation
- You can check the trend technology
- Can correct coding rules
In the following, we will explain each of the above items.


*** Can constructively resolve dissatisfaction with the current situation

Are you dissatisfied with your current software development?
- I don't like my boss
- The performance of the development PC is shobo,
- The salary is cheap,
- There is a lot of overtime
*The "dissatisfaction" I am talking about is not the "dissatisfaction with the real world" surrounding software development mentioned above.*

To realize the ideas in my head when developing software
- It's easy to bug due to language specifications
- You can only write in a very time-consuming and troublesome way
- You have to make the utility-like things necessary to realize it from scratch, and it takes too much time to reach what you originally wanted to make.
- In the first place, it can not be realized in terms of language specifications
I'm dissatisfied with the programming language.

For those who have such dissatisfaction and have specific ideas for resolving the dissatisfaction, we recommend developing a transcompiler.

This is the number one reason I decided to develop a transcompiler myself.

"If you don't have one, you can make it yourself."

Isn't it a "software engineer" because he has the ability to realize ideas with software?


**** Why it's a "transcompiler" rather than a "compiler"

"Why is it a" transcompiler "instead of a" compiler "? You may be wondering.

This is because the "transcompiler" has lower technical hurdles than the "compiler". With the advent of LLVM, I think the hurdles for compiler development are lower than before, but the hurdles for transcompilers are still lower.

In particular, the "cause-seeking cost" when there is a bug in the compiled code is overwhelmingly lower with the transcompiler.

I think it's okay if the purpose is to make a compiler, but making a compiler is a means, and the purpose is to solve "dissatisfaction with programming languages".

It would be better if it could be achieved at the lowest possible cost.

Besides, most of the "dissatisfaction with programming languages" can be solved by a transcompiler.

Of course, if you have a complaint like "I want to shorten the compilation time", I think that I have to develop the compiler by myself, but most of the other complaints can be solved by the transcompiler.

Even if the ultimate goal is to build a compiler
- First, create a transcompiler,
- Demonstrate that dissatisfaction can be resolved and that it is easy to use as a language,
- I found it beneficial to use that transcompiler,
- After that, when I needed to compile directly to native
Ultimately, developing a compiler is an efficient way to do it.


**** Why it's a "transcompiler" rather than an "interpreter"

I mentioned above why it is not a "compiler".

Here's why it's not an "interpreter".

That said, the reason is the same as when it was a "compiler", because it has a "lower hurdle" than an "interpreter".

Creating an interpreter is a lower hurdle than a compiler. I myself have made several simple interpreters.

But when it comes to practical interpreters, it's a different story. When it comes to a practical interpreter, there are problems with development man-hours and problems with execution performance. As I wrote when I was a compiler, the purpose is to solve "dissatisfaction with programming languages", so let's not think about anything else.

There are many practical interpreted languages (scripting languages) in the world now. You don't have to bother to make it yourself.


**** Easy to understand output result

One of the advantages of a transcompiler over a compiler is that the output code of the transcompiler is easy for many to understand.

As for which is easier to understand, the "native code" output by the compiler or the "code in a certain language" output by the transcompiler, everyone agrees that the "code in a certain language" is easier to understand. ..

"Why should it be easy to understand?" Means that the introduction risk is that low.

When introducing a new technology into a project, you need to determine if it is "safe".

There are various points of view even if we simply say "safety".
- "Information security" that guarantees that no virus-like substances have entered
- Whether it can be exported overseas or is subject to the "Foreign Exchange Law"
- Is there a problem with the license? Even if the license of the part created by the author of the compiler is okay, is there a license issue in the code that the author unintentionally uses?
In order to introduce other new ones, it is necessary to clear some safety.

In clearing these safety, the clarity of the target technology is very important.

For compilers, it's impractical to look at the generated native code, so you'll have to look at the compiler's code to make sure it's safe.

The transcompiler, on the other hand, only needs to look at the license and the converted code.


*** You can check the trend technology

If you are developing a new transcompiler, it is the nature of the engineer to try to make it as easy to use as possible.

If so, it is customary to investigate the characteristics of different languages and capture the good ones.

As I developed LuneScript, I intend to research as many languages as possible and incorporate various features.

What does it mean to know the characteristics of different languages? For example, does it make sense for engineers who are usually only involved in C language projects to know the characteristics of Go and swift? I'm sure some people wonder about that.

If you are a person who usually collects new information on sites such as Qiita, you will not have any doubts about such things, but if not, many people will wonder. ..

I think that even engineers who are usually involved only in C language projects should understand the characteristics of Imadoki's language.

The reason is that even if the characteristics of Imadoki's language itself cannot be used in C language, ideas and essences can be introduced in C language as well.

For example, the idea of a functional language itself can be realized in C without using Haskell.

Of course, there are things that are difficult to write with C language syntax, and things that cannot be realized due to the C language specifications.

However, there is a difference between writing in C language after knowing the concept of functional language itself and writing in C language as usual because you only know C language.

In addition, incorporating the characteristics of the Imadoki language as a function of the transcompiler enables a deeper understanding than simply using the Imadoki language. Or rather, it cannot be captured without a deep understanding.

In this way, it can be said that the development of a transcompiler is a good experience to deepen the understanding of the characteristics of Imadoki's language.


*** Can correct coding rules

This is a little different from what I've mentioned so far, but I think it's quite important.

I think everyone has an ideal way of writing, such as "I want to write this" and "I should write this" when coding.

Developing a transcompiler also means that you can correct (enforce) your coding rules at the language level.

Many people may wonder, "What do you mean?" With this explanation, but I think you can say "block by indentation" in python.

Python represents blocks by indentation rather than keywords or delimiters.

In other words, instead of binding "blocks should be indented" with coding rules, Python corrects (forces) "if the indents are not aligned, it should not be treated as a block" at the language level.

Coding rules are often controversial. Developing your own transcompiler can prevent such useless controversy at the language level.

I wasn't really aware of it until I developed my own transcompiler, but there are some coding rules that I'm usually aware of that are no longer needed because they can't be implemented at the language level in another language. I found out.

When developing a new language, I think you should not only incorporate new features, but also review your usual coding rules and consider whether you can handle it at the language level.


** Lastly

So far, I have made simple interpreters and [[# __ / lctags /] [source code tag system]] as a hobby.

Through the development of LuneScript this time, I was able to realize another fun of software development.

I think many people think that there is no point in creating a new language. At least I thought so.

However, by developing LuneScript this time, I think I was able to grow as a software engineer again.

It's best if you can feel the growth yourself no matter what you think.

If you are dissatisfied with software development, please try to develop a new programming language.

-----


* A. Let's have more fun in an exciting development environment
:PROPERTIES:
:CUSTOM_ID: completion
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <style type="text/css"> <!-- pre.src { color: #ffffff; background-color: #101010; } --> </style>

What editors do you use to develop Lua?

Is it an environment full of crazy features like Lua Development Tools, Atom, VSCode? Or is it a classic environment such as emacs or vim?

In either environment, are you dissatisfied with the completion features while coding Lua?

Lua's completion feature is often pretty smart, but it's quite possible that it doesn't work, right?

Even with a little confirmation, the complement does not seem to work in the next scene.
- Field completion of the method of the object passed to the argument of the function
- Complementing object-oriented programming with metatable
With light processing, the above problem may not be of much concern, but when writing processing of a certain scale, it is quite anxious.

Lua's transcompiler LuneScript provides completion at the compiler level so that completion can be used in any situation.

Here, I will introduce the development support of Imadoki that can be used when coding LuneScript.

Specifically, there are three functions:
- Code completion function
- Confirmation of cursor position type information
- Syntax error checking function
- Search that recognizes subfile


** Code completion function

LuneScript provides class field completion.

For example, in the following code
#+BEGIN_SRC lns
// @lnsFront: ok
class Super {
   pub let val:int;
   pri let val2:int { pub };
   pub fn funcsuper():int! {
      return 0;
   }
}
class Test extend Super {
   pub fn __init( val: int ) {
      super( val, val + 1 );
   }
   pub fn func( val: int ):int {
      return 1;
   }
}
let test = new Test( 1 );
#+END_SRC


You can complete the test field as follows:

[[https://ifritjp.github.io/doc/LuneScript/comp1.gif]]

I would like you to pay attention to the following points.
- Recognizing inheritance relationships, Super and Test fields are listed as candidates
- Super's private val2 member is excluded from the list, recognizing access control
- Constructor (__ init) that cannot be accessed from the instance is excluded from the list
- Undefined get_val2 () is listed
It is a natural function, but it is surprisingly few that the compiler itself provides this natural function firmly.


** Confirmation of cursor position type information

LuneScript supports type inference.

This allows you to proceed with coding without having to specify the type information.

For example, the following code has no type explicit.
#+BEGIN_SRC lns
// @lnsFront: ok
foreach val, key in { "abc": 1, "xyz": 10 } {
  print( key, val );
}
#+END_SRC


This is convenient, but the disadvantage is that you can't check the type.

Therefore, we provide a function that allows you to check what type of symbol the cursor position is.

You can check the type information of the symbol by moving the cursor to the symbol you want to check and executing C-c I.


** Syntax error checking function

Since LuneScript is a compiler, it naturally has a Syntax error checking function.

Based on this error check information, the error location can be displayed on the editor.

For example, with the following source
#+BEGIN_SRC lns
// @lnsFront: ok
fn func( val: int ) {
   print( val );
}
let map = { "a": 1, "b":2 };
#+END_SRC


An error will occur if the following processing is added.

[[https://ifritjp.github.io/doc/LuneScript/error.gif]]

[[https://ifritjp.github.io/doc/LuneScript/error2.PNG]]

This means that the result of accessing a map type item will be nilable type, and if you give it to func (), you will get an int! And int type mismatch error.

You can easily check such errors that are often overlooked on the editor.


** Search that recognizes subfile

LuneScript has a function subfile that divides a file that defines a large module into multiple files and defines them.

By using this function, you can relieve the stress of making the file larger and the editor heavier.

However, it has the disadvantage of poor searchability within the module because the file is split.

For example, if a module consists of owner.lns, sub1.lns, sub2.lns, sub3.lns, to find out where the data in a module is accessed, owner.lns, sub1.lns You need to switch between the four files, sub2.lns and sub3.lns.

This is a tedious operation.

This troublesome operation is automatically performed at the time of search.

Specifically, if you can't find it by searching in owner.lns, switch to sub1.lns and search. If you can't find it in sub1.lns, then switch to sub2.lns and search. ... this process is done automatically.


** Configuration

This is the emacs setting.
#+BEGIN_SRC lisp
(require 'lns-conf)
;;(require 'lns-flymake)
(require 'lns-flycheck)
(require 'lns-company-mode)
;;(require 'lns-auto-complete)
(require 'lns-helm)
#+END_SRC


Select either code completion or Syntax check according to your environment.
- Code completion
  - flycheck 
  - flymake
- Syntax check
  - company-mode
  - auto-complete
LuneScript's flymake and auto-complete support is not maintained. We recommend using flycheck, company-mode.


** project

LuneScript manages module paths relative to the project. For this reason, you need to make emacs aware of the project root directory.

*To make emacs aware of your project's root directory, create the following lune.js file in your project's root directory:*
#+BEGIN_SRC txt
lune.js
#+END_SRC


*In this lune.js file, write the following:*
#+BEGIN_SRC js
{}
#+END_SRC



*** Module path

If you created lune.js in the following location, the module path for proj / foo / bar / module1.lsn would be foo.bar.module1.
#+BEGIN_SRC txt
proj/lune.js
proj/foo/bar/module1.lsn
#+END_SRC



** Lastly

This function has been confirmed to work on emacs. By the way, code completion corresponds to company-mode, auto-complete, syntax error check corresponds to flymake, flycheck.

By default, LuneScript provides settings for emacs, but emacs does only front-end control, and all back-ends are done by LuneScript.

In other words, it is quite possible to port it to an environment other than emacs. However, since I am an emacs user myself, I am developing emacs as a top priority.

If you are interested in LuneScript, I would appreciate it if you could support environments other than emacs.

-----


* LuneScript running on a web browser
:PROPERTIES:
:CUSTOM_ID: onweb
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

To check the operation of LuneScript, we have prepared a LuneScript environment that runs on a web browser.

<https://ifritjp.github.io/LuneScript-webFront/contents/>

The link above has three textareas:
- For LuneScript code entry
- For execution result output
- For output of conversion result to Lua
Enter the LuneScript code in the textarea for LuneScript code input and press the execute button to convert and execute it to Lua.

All LuneScript processing is running on the browser.

However, it has the following restrictions:
- Cannot operate files such as io.open ()
- Cannot load modules such as import ()
Since all the processing of LuneScript is running on the browser, it takes time to execute it for the first time on smartphones.


** Technical explanation

I'm using fengari to run a Lua VM on my browser and run the LuneScript compiler on that Lua VM.

See the following article for fengari.

[[#__/lua/fengari/]]

The fengari Lua VM loads its module with XMLHttpRequest when require on Lua. LuneScript consists of 30 Lua files, which means that you will load 30 Lua files sequentially. 30 Sequential loading of files is inefficient, so XMLHttpRequest is used to load them asynchronously in advance, and during require processing, the processing is switched so that the preloaded files are loaded.

Then, after loading the LuneScript compiler, LuneScript translates the input user's LuneScript code and executes it.

Loading the LuneScript compiler will take some time. It takes less than 10 seconds on my smartphone and less than 1 second on my PC. Once loaded, you don't need to load LuneScript until you reload your browser, and you can convert and execute your LuneScript code.

As a countermeasure when the user's LuneScript code is buggy and goes out of control, it is forcibly stopped 2 seconds after execution.

This LuneScript compiler works completely closed in the browser once loaded, so there is no load on the server side. The only function the server needs is hosting static content.


*** LuneScript fengari support

In running LuneScript on the fengari Lua VM, the following processing of LuneScript has been modified.

*"Switching List <X> type foreach processing from pairs () to ipairs ()"*

In the original Lua VM, pairs () and ipairs () list in the same order in the sequence table, whereas in the fengari Lua VM, pairs () seems to be in no particular order. LuneScript used pairs () instead of ipairs () for simplicity and certainty, but fengari Lua VM switched to ipairs ().

*Note that this switching is controlled by the --use-ipairs compile option. If --use-ipairs is specified, it will be ipairs (). Currently, pairs () is used when no option is specified, but we are considering reversing the default state in the future.*


** Reference sample code execution

I'm trying to use this technique to run the sample code in the LuneScript reference.

It's easy to embed, load the following JavaScript,
: ifritJP.github.io/LuneScript-webFront/contents/lunescript-front.js


Just execute the =lnsFront.setup()=, =lnsFront.compile()= functions.


*** lnsFront.setup()

=lnsFront.setup()= loads fengari and LuneScript, associates each HTML element, compiles and executes the LuneScript code stored in the textarea.

setup () is a function of the following type:
#+BEGIN_SRC js
lnsFront.setup( consoleId, luaCodeId, lnsCodeId, executeId )
#+END_SRC

|-|-|-|
| argument | meaning | Required / Option | 
|-+-+-|
| consoleId | Id of the textarea that stores the console output | Mandatory | 
| luaCodeId | The id of the textarea that stores the converted Lua code | Option | 
| lnsCodeId | Id of the textarea that stores the Lns code | Mandatory | 
| executeId | The id of the trigger button that starts the conversion | Option | 

If you do not use element in the above Option, specify an empty string for element ID.

For example, if you don't need the converted Lua code, do the following:
#+BEGIN_SRC js
var frontId = lnsFront.setup( consoleId, "", lnsCodeId, executeId )
#+END_SRC


In addition, this function manages the consoleId etc. given to the argument collectively, issues an ID and associates it. And that ID is the return value.

After executing lnsFront.setup (), click the button specified by executeId or execute lnsFront.compile () to convert the LuneScript code in the textarea of the registered lnsCodeId and execute it, and execute the execution result in each textarea. Store.

If you have multiple textareas to enter LuneScript code, run lnsFront.setup () on each.


**** Note on lnsFront.setup ()

*Do not run lnsFront.setup () multiple times for a textarea.*

After executing lnsFront.setup () once, execute the LuneScript code in the registered textarea by clicking the button registered with executeId or by executing lnsFront.compile ().


*** lnsFront.compile()

lnsFront.compile () compiles and executes the LuneScript code in the textarea registered with lnsFront.setup ().
#+BEGIN_SRC js
lnsFront.compile( frontId, maxTime )
#+END_SRC

|-|-|-|
| argument | meaning | Required / Option | 
|-+-+-|
| frontId | Return value of lnsFront.setup () | Mandatory | 
| maxTime | User's LuneScript execution time limit (seconds) | Option | 

If maxTime is omitted, the default limit is 2 seconds. If 10 seconds or more is specified, it will be treated as an invalid value and the default value will be set.

-----


* Importance of self-hosting and test design in quality control of language development
:PROPERTIES:
:CUSTOM_ID: test
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

If you're looking at this document, you're probably coding in a "programming language" every day. And many of you are busy crushing bugs that someone has put in.

Since the "programming language" that is taken care of every day is also software made by someone, it is important to control the quality of how to prevent bugs.

I'm lucky (?), And I've never run into a language bug while using a programming language at work.

//There are some language standards that seem like bugs. .. ..//

If you run into a programming language bug, dealing with it can be one of the most annoying software bugs out there.

//It's hard to reach that it's a programming language bug in the first place.//

Here, I would like to introduce how to test my own language that I am developing.

Programming languages can be classified into the following two types.
- Compiler type
- Interpreter type
Since the language I'm developing is compiler type, I'll talk about compiler type testing from now on.

By the way, I will introduce LuneScript, my own language, in the next article.

https://qiita.com/dwarfJP/items/21d4d4099ab0feb68eaf

We hope that it will be of some help to those who are considering developing their own language in the future.


*** Compiler is a function

The job of a compiler-type programming language is to convert code written in that programming language into machine language or the like.

for example,
- C language compiler converts to Native code
- Java compiler translates to JVM code
- Convert C # to CIL
- Clang translates to LLVM-IR, LLVM translates to various codes
In other words, a compiler can be thought of as "one large function that gives input and returns output in response to that input."

If you think of the compiler as a function, its testing is very simple. You can test by giving various inputs and comparing the output with the expected value.

The idea is exactly the same as the UNIT TEST function that I create on a daily basis.


*** Compiler testing

The proprietary language, LuneScript, has the following tests:
- Self-hosting LuneScript own build
- Normal system of all syntaxes supported by the language
- Abnormal system of all syntaxes supported by the language
Of particular importance here is self-hosting.

By self-hosting, you don't have to write test code, your own code becomes test code.

Creating meaningful test code on a reasonable scale can be a daunting task.

*Especially in the case of a unique language that no one else is using, it is not easy to find proper practical code instead of test code by searching github, so to some extent Scale test code is valuable.*

When you're self-hosting, your own code becomes that valuable test code.

However, even if you say "your own code becomes test code as it is", that alone is not enough testing. The syntax and design patterns used will be biased, and the test will be unsatisfactory in terms of completeness. Also, you can't put anomalous code that causes a compile error into your own self-hosted code. Therefore, self-hosting your own code is not enough as a test case, and you need a test to comprehensively check the normal system and a test to detect the compilation error.

For this normal system and abnormal system test, you can check the success or failure of the test by preparing the expected value in advance.

On the other hand, how should we determine "whether the result of compiling my own code is correct"? Is the problem.

Since the test case code is generally immutable, its compilation results are also immutable. This means that once you create a test case and expected value pair, you can continue to use the same expected value unless you change the test case.

On the other hand, the self-hosting code of your own will naturally change. In other words, the expected value changes constantly, so it is impossible to prepare the expected value in advance.

Now, how to determine if your self-hosted code compiles correctly is based on the following:
: 「使用中のコンパイラでのテストケースの結果」 == 「新しくコンパイルしたコンパイラでのテストケースの結果」


This is based on the assumption that the compiler you are using is behaving correctly, and the results of the test cases you ran with the compiler you are using and the results of the test cases you ran with the newly compiled compiler. The logic is that if they are the same, then the newly compiled compiler is also correct.

In addition, I am compiling myself again with the newly compiled compiler. I'm doing this to make sure that when I compile the same code, the output is exactly the same.

In summary, the LuneScript test does the following:
- step1 :: Compile your own self-hosted code to generate compiler B using your current compiler A
- step2 :: Use compiler B to compile your code again to generate compiler C
- step3 :: Use compiler C to compile your code again to generate compiler D
- step4 :: Make sure compiler C and compiler D are the same
- step5 :: Executes normal and abnormal tests of compiler A and saves the test results in result A
- step6 :: Executes normal and abnormal tests of compiler D and saves the test results in result D
- step7 :: Make sure result A and result D are the same
After passing the above tests, we will use compiler D as the latest compiler A next time. In addition, we will add tests for normal and abnormal systems with extended language specifications as needed.

In the case of self-hosting, if there is a problem, you may not be able to compile yourself, and you may not be able to proceed with development. This test ensures that the newly built compiler works properly and allows you to safely extend your language.

For your own language, the timing of your transition to self-hosting can be very important.

As the code scale of the compiler increases, the time required for porting also increases, so when developing your own language with full scratch, prioritize the functions required for self-hosting and make it self-hosting at the earliest possible stage. We recommend that you migrate.


** Still bugs remain

I introduced the tests that I am conducting in my own language development, but unfortunately the bugs remain even if I test them.

There are two categories of causes for the bug:
- Case where abnormal system cannot be detected
- A case where it should work normally but it does not work
Of the above two, the overwhelming majority of cases cannot detect an abnormal system.

This is because the normal path needs to be confirmed to work by writing the code according to the language specification, while the abnormal path needs to write the code that does not meet the language specification to detect the error.

It is quite difficult to say that this "out of the language specifications", and there are often holes.

Rather than seeking a perfect test from the beginning, it is important for testing to find these "holes", add test cases to close them, and respond so that they can be detected when the same "hole" is opened again. I think.


** Lastly

I think that the reason why we have continued to develop our own language is that we have proceeded with the following test policy.
- Early transition to self-hosting
  - If you move to self-hosting, you will inevitably need a certain level of quality assurance.
    - If the quality is poor, self-hosting will be hindered, so the quality will be maintained naturally.
- Don't aim for 100% test from the beginning
  - The purpose is to develop a proprietary language, not a test.
  - You can concentrate on your own language.
- What we have done in synchronization with the expansion of language specifications and the expansion of test codes
  - Can prevent omissions and degradation of tests
- Testing at the compiler I / O level, not at the function level
  - For function-level tests, it is necessary to change the test case every time the design is changed, but for tests at the compiler I / O level, there is no need to change the test case unless there is a change in the compiler specifications.
When developing your own language, I think it is efficient to aim for self-hosting first in terms of ensuring quality.

that's all.

-----


* Box edition
:PROPERTIES:
:CUSTOM_ID: box
:END:

# -*- coding:utf-8 -*-
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

*This is information under consideration. Currently not available.*


** Nilable type

As mentioned earlier, you cannot specify nilable as a generics real-type parameter.

Due to this limitation, the following ~new Test( val )~ will result in an error.
#+BEGIN_SRC lns
// @lnsFront: skip
class Test<T> {
   let val:T;
}
let val:int! = 1;
let test = new Test( val ); // error
#+END_SRC


There are two patterns to avoid this error.
- Use T!
- Use Nilable type
In the case of "using T!", The above process can be written as follows.
#+BEGIN_SRC lns
// @lnsFront: skip
class Test<T> {
   let val:T!; // <--- T! とする
}
let val:int! = 1;
let test = new Test( val );
#+END_SRC


However, this is cumbersome because in many cases you have to declare it as nilable even if it is non-nilable and good, which requires unwrapping.

Therefore, we will use the Nilable type.


*** What is Nilable type?

The Nilable type is a type that wraps the value of nilable. Think of it as an Integer class for int in Java.
