// -*- coding: utf-8 -*-

import lns.Ebnf;
import lns.Parser;
import lns.Code;
import lns.Util;
import lns.Formatter;
import go/github:com.ifritJP.LuneScript.src.lune.base.Tokenizer as LnsTokenizer;
import go/github:com.ifritJP.LuneScript.src.lune.base.Types as LnsTypes;
import go/github:com.ifritJP.LuneScript.src.lune.base.Depend as LnsDepend;
import go/github:com.ifritJP.LuneScript.src.lune.base.Util as LnsUtil;

fn createTokenizer() : LnsTokenizer.Tokenizer {
   let lnsCode = ```
{
   if val.val2
 {
   }




   else {
}


}
let val = [ 
  a

];
match hoge {

   case .a  {

}
}

switch hoge {
    case .a {
}
    case .b,
.c ___LNS___
{ 

}
```;
   return LnsTokenizer.StreamTokenizer.create(
      LnsTypes.TokenizerSrc.LnsCode( lnsCode, "test", nil ), false, nil, nil );
}

fn createTokenizerFromFile( path:str ) : LnsTokenizer.Tokenizer {
   return LnsTokenizer.StreamTokenizer.create(
      LnsTypes.TokenizerSrc.LnsPath( nil, path, "test", nil), false, nil, nil );
}


fn format( inpath:str, targetLineNo:int!,
           outpath:str, ebnfPath:str!, debugFlag:bool ) : bool
{
   let mut tokenizer;
   switch inpath {
      case "" {
         tokenizer = createTokenizer();
      }
      case "@-" {
         let lnsCode = io.stdin.read( "*a" ) or "";
         tokenizer = LnsTokenizer.StreamTokenizer.create(
            LnsTypes.TokenizerSrc.LnsCode( lnsCode, "test", nil ),
            false, nil, nil );
      }
      default {
         tokenizer = createTokenizerFromFile( inpath );
      }
   }
   
   //let mut tokenizer = createTokenizer();
   // let mut tokenizer = createTokenizerFromFile( "lns/main.lns" );
   // let mut tokenizer = createTokenizerFromFile( "lns/Ebnf.lns" );
   // let mut tokenizer = createTokenizerFromFile( "../../src/test/testGo.lns" );
   // let mut tokenizer = createTokenizerFromFile( "../../src/lune/base/front.lns" );
   // let mut tokenizer = createTokenizerFromFile( "../../src/lune/base/Nodes.lns" );


   let ebnfCtrl = Parser.analyze_ebnf( Ebnf.EbnfTokenizer.create( ebnfPath ) );
   if debugFlag {
      ebnfCtrl.dump();
   }

   let mut codeTokenizer = new Code.CodeTokenizer( tokenizer );
   let mut hook = new Formatter.ParseCodeHook( codeTokenizer, targetLineNo );
   _match ebnfCtrl.parse( "<code>", hook, hook ) {
      case .Eof {
         Util.log( "eof" );
      }
      case .Unmatch {
         Util.log( "unmatch" );
      }
      case .Abbr {
         let pos = codeTokenizer.getToken().pos;
         Util.log( "illegal", pos.lineNo, pos.column );
      }
      case .Detect( codeCore ) {
         Util.log( "outputCode" );
         if! let mut fileObj = io.open( outpath, "w" ) {
            let mut stream = new LnsUtil.memStream();
            Code.outputCode( codeCore, new Code.CodeGenerator( stream ) );
            fileObj.write( stream.$txt );
            fileObj.close();
            Util.log( "" );
            let token = codeTokenizer.getToken();
            let pos = token.pos;
            Util.log( "%d:%d" (pos.lineNo, pos.column), token.kind.$_txt );
            return true;
         }
      }
   }
   return false;
}

fn usage( mess:str ) : __ {
   print( mess );
   print( "" );
   print( "usage: command [-log] [-ebnf path] [-prof] [-i lineno] inpath outpath" );
   os.exit( 1 );
}

pub fn __main( argList:&_List<str> ) : int {
   let optList:List<str> = [];
   let mut ebnfPath:str! = nil;
   let mut index = 1;
   let mut prof = false;
   let mut debugFlag = false;
   let mut targetLineNo:int! = nil;

   fn getNext() : str {
      if index > #argList {
         usage( "illegal option" );
      }
      let arg = argList[ index ];
      index = index + 1;
      return arg;
   }
   while index <= #argList {
      let arg = getNext();
      if arg == "-log" {
         debugFlag = true;
         Util.setLog( true );
      } elseif arg == "-prof" {
         prof = true;
      } elseif arg == "-ebnf" {
         ebnfPath = getNext();
      } elseif arg == "-i" {
         if! let num = tonumber( getNext()## ) {
            targetLineNo = num@@int;
         } else {
            usage( "lineno is not number" );
         }
      } else {
         optList.insert( arg );
      }
   }

   if #optList < 3 {
      usage( "illegal argument" );
   }


   let mut exitCode = 1;
   LnsDepend.profile(
      prof, 
      fn() {               
         if format( optList[ 2 ], targetLineNo, optList[ 3 ], ebnfPath, debugFlag ) {
            exitCode = 0;
         }
      }, "prof" );
      
   return exitCode;
}
