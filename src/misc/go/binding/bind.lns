import lune.base.Ver;

/**
path で指定されている makefile から 'LNS_SRCS +=' のパターンを見つけて
lns を構成するファイルリストを取得する。
*/
fn getSrcList( path:str ): &List<str>! {
   let! mut mkstream = io.open( path ## ) {
      return nil;
   };
   let mut list:List<str> = [];
   while true {
      let! line = mkstream.read( '*l' ) {
         break;
      };
      if line.find( "^LNS_SRCS%s*%+=%s*base/" ## ) {
         let src = line.gsub( ".*= base/" , "" ).gsub( "%s", "" );
         list.insert( src );
      }
   }
   mkstream.close();

   list.insert( "runtime%d" (Ver.luaModVersion ) );
   return list;
}

/**
指定の path のファイルを読み取り、内容を返す。
*/
fn readFile( path:str ): str! {
   let! mut stream = io.open( path ## ) {
      print( "failed to open -- ", path );
      return nil;
   };
   let! code = stream.read( "*a" ) {
      print( "failed to read -- ", path );
      return nil;
   };
   stream.close();
   return code;
}

/**
"lune/base/%s.lua" (src) のファイルを byte compile した結果を返す。
*/
fn compile( src:str ): str! {
   let! code = readFile( "lune/base/%s.lua" (src) ) {
      return nil; 
   };
   let loaded, err = _load( code, nil );
   when! loaded {
      return string.dump( loaded, true );
   }
   print( "failed to load -- ", src, err );
   return nil;
   // return code;
}

/**
bin で指定した文字列を go のbyte slice 宣言文字列に置き換える。

戻り値は byte slice 宣言文字列を、一定サイズごとに分割した list。
一定サイズごとに分割するのは、 文字列連携を繰り返すと連結処理に掛るパフォーマンスが
非常に悪くなるため、適当な長さで連結せずに list で管理する。
*/
fn str2GoStr( bin:str ) : List<str> {
   let mut list:List<str> = [];
   let mut gostr = '';
   for index = 1, #bin {
      gostr = gostr .. "0x%02x," (bin[index]);
      if #gostr > 500 {
         list.insert( gostr );
         gostr = "";
      }
   }
   list.insert( gostr );
   return list;
}

/**
stream で指定した出力先に、 byte slice 宣言の codeList を key に紐付けて出力する。
*/
fn output( stream:oStream, key:str, codeList:&List<str> ) : bool {
   stream.write( '{\n' );
   stream.write( 'code := []byte{' );
   foreach code in codeList {
      stream.write( code );
      stream.write( '\n' );
   }
   stream.write( "}\n" );
   stream.write( 'key := "%s"\n' (key) );
   stream.write(
      'lnsSrcMap[ key ] = &lnsSrcInfo{ C.CString( string(code) ), len( code ) }\n' );
   stream.write( "}\n" );

   return true;
}

/**
指定した LuneScript の Makefile の情報をもとに、
LuneScript を構成する .lua ファイルをバンドルするための .go を生成する。
*/
pub fn createBinding( makePath:str ) : bool {

   if! let list = getSrcList( makePath ) {
      if! let mut ostream = io.open( "output.go", "w" ) {
         ostream.write( "package runtimelns\n" );
         ostream.write( 'import "C"\n' );
         ostream.write( 'type lnsSrcInfo struct {\n' );
         ostream.write( '  codeC *C.char\n' );
         ostream.write( '  len int\n' );
         ostream.write( '}\n' );
         ostream.write( "var lnsSrcMap map[string] *lnsSrcInfo\n" );
         ostream.write( "func init() {\n" );
         ostream.write( "lnsSrcMap = map[string] *lnsSrcInfo{}\n" );
         let mut total = 0;
         foreach path in list {
            print( path );
            if! let bytecode = compile( path ) {
               total = total + #bytecode;
               print( "size = ", #bytecode, total );
               let gostrList = str2GoStr( bytecode );
               output( ostream, "lune.base.%s" (path), gostrList );
            }
         }
         ostream.write( "}\n" );
         ostream.close();
         return true;
      }
   }
   return false;
}

pub fn __main(args:&List<str> ):int {
   if not createBinding( "Makefile" ) {
      return 1;
   }
   return 0;
}
