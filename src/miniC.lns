form FF( val:int, ... );
fn func( val:int, ... ) {
   print( val, ... );
}
fn func2( ... ) {
   print( ... );
}
form FF3( ...<&stem!> );

fn ret(): int, int, int {
   return 1, 2, 3;
}
fn sub( ff:FF ) {
   ff( ret()** );
   ff( 0, ret()** );
   ff( -1, 0, ret()** );
}
fn sub2( ff:form ) {
   ff( 1 );
   ff( ret()** );
   ff( 0, ret()** );
   ff( -1, 0, ret()** );
}
fn sub3( ff:FF3 ) {
   ff( ret()** );
   ff( 0, ret()** );
   ff( -1, 0, ret()** );
}
sub( func );
sub2( func2 );
sub3( print );

// fn funcL(): int, int {
//    return 1, 2;
// }

// class Test {
//    static let val:int;
//    __init {
//       Test.val = 1;
//    }
//    pub static fn funcS(): int, int {
//       return Test.val, 2;
//    }
//    pub fn func(): int, int {
//       return 1, 2;
//    }
// }
// fn sub( val1:int, val2:int ) {
//    print( val1, val2 );
// }
// print( "---" );
// sub( Test.funcS()** );
// sub( Test.funcS() + 1, 0 );
// sub( Test.funcS(), 0 );
// sub( ( Test.funcS() ), 0 );
// sub( ( Test.funcS() ) + 1, 0 );


// print( "---" );
// print( Test.funcS()** );
// print( Test.funcS() + 1, 0 );
// print( Test.funcS(), 0 );
// print( ( Test.funcS() ), 0 );
// print( ( Test.funcS() ) + 1, 0 );
// print( 0, Test.funcS()** );


// print( "---" );
// let test = new Test();
// sub( test.func()** );
// sub( test.func() + 1, 0 );
// sub( test.func(), 0 );
// sub( ( test.func() ), 0 );
// sub( ( test.func() ) + 1, 0 );




// interface IF {
//    pub fn func();
// }
// class TestA extend (IF) {
//    pub fn func() {
//       print( "TestA" );
//    }
// }
// class TestB extend (IF) {
//    pub fn func() {
//       print( "TestB" );
//    }
// }

// class Hoge<T> {
//    let mut val:T {pub,pub};
//    pub fn func(): T {
//       return self.val;
//    }
// }

// {
//    let test:Hoge<&IF> = new Hoge( new TestA() );
//    test.$val.func();
//    test.func().func();
// }
// {
//    let test:Hoge<&IF> = new Hoge( new TestB() );
//    test.$val.func();
//    test.func().func();
// }
