class Test {
   let txt:str {pub};
}
let test = new Test( "abc" );
print( test.$txt );


// fn funcL(): int, int {
//    return 1, 2;
// }

// class Test {
//    static let val:int;
//    __init {
//       Test.val = 1;
//    }
//    pub static fn funcS(): int, int {
//       return Test.val, 2;
//    }
//    pub fn func(): int, int {
//       return 1, 2;
//    }
// }
// fn sub( val1:int, val2:int ) {
//    print( val1, val2 );
// }
// print( "---" );
// sub( Test.funcS()** );
// sub( Test.funcS() + 1, 0 );
// sub( Test.funcS(), 0 );
// sub( ( Test.funcS() ), 0 );
// sub( ( Test.funcS() ) + 1, 0 );


// print( "---" );
// print( Test.funcS()** );
// print( Test.funcS() + 1, 0 );
// print( Test.funcS(), 0 );
// print( ( Test.funcS() ), 0 );
// print( ( Test.funcS() ) + 1, 0 );
// print( 0, Test.funcS()** );


// print( "---" );
// let test = new Test();
// sub( test.func()** );
// sub( test.func() + 1, 0 );
// sub( test.func(), 0 );
// sub( ( test.func() ), 0 );
// sub( ( test.func() ) + 1, 0 );




// interface IF {
//    pub fn func();
// }
// class TestA extend (IF) {
//    pub fn func() {
//       print( "TestA" );
//    }
// }
// class TestB extend (IF) {
//    pub fn func() {
//       print( "TestB" );
//    }
// }

// class Hoge<T> {
//    let mut val:T {pub,pub};
//    pub fn func(): T {
//       return self.val;
//    }
// }

// {
//    let test:Hoge<&IF> = new Hoge( new TestA() );
//    test.$val.func();
//    test.func().func();
// }
// {
//    let test:Hoge<&IF> = new Hoge( new TestB() );
//    test.$val.func();
//    test.func().func();
// }
