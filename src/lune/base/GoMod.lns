import lune.base.Option;
import lune.base.Types;
import lune.base.Util;
import lune.base.Depend;

pub class ModInfo {
   /** モジュールパス → バージョン */
   let moduleMap:&Map<str,str> {pub};
   /** モジュールパス → replace 先 */
   let replaceMap:&Map<str,str> {pub};

   pub fn getModulePath( path:str ) : str! {
      foreach ver, mod in self.moduleMap {
         if path.find( mod, 1, true ) == 1 {
            let relativeName = path.sub( #mod + 2 ## );
            
            if! let replacePath = self.replaceMap[ mod ] {
               return Util.pathJoin( replacePath, relativeName );
            }
            
            let mut gomod = "";
            foreach aChar in [ mod.byte(1,#mod) ] {
               when! aChar {
                  if aChar >= ?A and aChar <= ?Z {
                     gomod = "%s!%c" (gomod, aChar - ?A + ?a);
                  } else {
                     gomod = "%s%c" (gomod, aChar);
                  }
               }
            }
            gomod = "%s@%s" (gomod,ver);
            if! let gopath = Depend.getGOPATH() {
               let modpath = Util.pathJoin( gopath, "pkg/mod/%s" (gomod) );
               return Util.pathJoin( modpath, relativeName );
            }
         }
      }
      return nil;
   }
}

enum BlockKind {
   None,
   Require,
   Replace,
}

fn getReplace( map:Map<str,str>, tokenList:&List<str>, modIndex:int ) {
   let mut prevArrow = false;
   foreach token in tokenList {
      if token == "=>" {
         prevArrow = true;
      } elseif prevArrow {
         map[ tokenList[ modIndex ] ] = token;
         break;
      }
   }
}

pub fn getGoMap( option:&Option.Option ) : &ModInfo {
   let mut requireMap:Map<str,str> = {};
   let mut replaceMap:Map<str,str> = {};
   let modInfo = new ModInfo( requireMap, replaceMap );
   // if option.convTo ~= .Go {
   //    return modInfo;
   // }
   if! let mut file = io.open( "go.mod"## ) {
      let mut inBlock = BlockKind.None;
      while true {
         let! line = file.read( "*l" ) {
            break;
         };
         let trimedLine = line.gsub( "^%s", "" );
         let tokenList = Util.splitStr( trimedLine, "[^%s]+" );
         _switch inBlock {
            case .Require {
               if line.find( "^%)"## ) {
                  inBlock = .None;
               } else {
                  requireMap[ tokenList[ 1 ] ] = tokenList[ 2 ];
               }
            }
            case .Replace {
               if line.find( "^%)"## ) {
                  inBlock = .None;
               } else {
                  getReplace( replaceMap, tokenList, 1 );
               }
            }
            case .None {
               if line.find( "^require%s+[^%(]"## ) {
                  if #tokenList == 3 {
                     requireMap[ tokenList[ 2 ] ] = tokenList[ 3 ];
                  }
               } elseif line.find( "^require%s+%("## ) {
                  inBlock = .Require;
               } elseif line.find( "^replace%s+[^%(]"## ) {
                  getReplace( replaceMap, tokenList, 2 );
               } elseif line.find( "^replace%s+%("## ) {
                  inBlock = .Require;
               }
            }
         }
      }
   }
   return modInfo;
}
