{
   fn func( work:&List<Map<str,int>> ) {
      foreach list in work {
         foreach val, key in list {
            print( key, val );
         }
      }
   }
   let mut work = [{ "ab":1 }, { "xyz":2 }];
   work.remove(##);
   work.insert( {"eee":10} );
   func( work );
}
{
   fn func( val1:int!, val2:int! ) {
      when! val1, val2 {
         print( val1 + val2 );
      }
      else {
         print( val1, val2 );
      }
   }
   func( 1, 10 );
   func( nil, 10 );
   func( 10, nil );
   func( nil, nil );
}
{
   fn func( val1:int!, val2:int! ) {
      if! let val10, val20 = val1, val2 {
         print( val10 + val20 );
      }
      else {
         print( val1, val2 );
      }
   }
   func( 1, 10 );
   func( nil, 10 );
   func( 10, nil );
   func( nil, nil );
}
{
   fn func( val1:int!, val2:int! ) {
      let! val10, val20 = val1, val2 {
         print( val1, val2 );
         return;
      }
      then {
         print( val10 + val20 );
      };
      print( val10 - val20 );
   }
   func( 1, 10 );
   func( nil, 10 );
   func( 10, nil );
   func( nil, nil );
}
{
   class Test {
      pro let val1:int;
      pro let val2:int;
      pub fn sub1(): int {
         return self.val1 + 100;
      }
      pub fn sub2(): int {
         return self.val2 + 100;
      }
   }
   class Sub extend Test {
      let val3:int;
      pub override fn sub1(): int {
         return self.val1 + 200;
      }
      pub fn sub3(): int {
         return self.val3 + 200;
      }
   }
   class SubSub extend Sub {
      pub override fn sub1(): int {
         return self.val1 + 300;
      }
      pub override fn sub2(): int {
         return self.val2 + 300;
      }
   }

   fn func1( test:&Test ): int, int {
      if! let sub = test@@@Sub {
         print( "OK", sub.sub2() );
      }
      else {
         print( "CAN'T CAST" );
      }
      return test.sub1(), test.sub2();
   }

   fn func2( test:&stem ) {
      if! let sub = test@@@Sub {
         print( "OK", sub.sub2() );
      }
      else {
         print( "CAN'T CAST" );
      }
   }

   let test = new Test( 1, 2 );
   print( func1( test )** );
   func2( test );

   let sub = new Sub( 1, 2, 3 );
   print( sub.sub3(), func1( sub )** );
   func2( sub );

   let subsub = new SubSub( 1, 2, 3 );
   print( subsub.sub3(), func1( subsub )** );
   func2( subsub );
}
{
   class Test {
      let val1:int;
      let val2:int;
      pub fn __init(val1:int, val2:int) {
         self.val1 = val1;
         self.val2 = val2;
      }
      pub fn func() {
         print( self.val1, self.val2 );
      }
   }

   fn func():int,int {
      return 1, 2;
   }

   class Sub extend Test {
   }

   class SubSub extend Sub {
      let val3:int;
      pub fn __init() {
         super( 0, (func()));
         self.val3 = 3;
      }
      pub override fn func() {
         super();
         print( self.val3 );
      }
   }

   let test = new SubSub();
   test.func();
}
{
   class Test {
      let val:int;
      pub fn func():int {
         return self.val;
      }
   }
   class Sub extend Test {
      pub override fn func():int {
         return super() + 100;
      }
   }
   let list = [ new Sub( 1 ), new Test( 10 ) ];
   foreach val in list {
      print( val.func() );
   }
}
{
   fn func( val:str ) {
      switch val {
         case "1", "2" {
            print( "A" );
         }
         case "3", "4" {
            print( "B" );
         }
         default {
            print( "C" );
         }
      }
   }

   foreach val in [ "1", "2", "3", "4", "5" ] {
      func( val );
   }
}
{
   let mut val = 1;
   while true {
      if val > 10 {
         break;
      }
      print( val );
      val = val + 1;
   }
}
{
   let mut val = 1;
   repeat {
      print( val );
      val = val + 1;
   } val > 10;
}