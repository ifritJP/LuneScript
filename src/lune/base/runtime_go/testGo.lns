macro _section() {
   print( "----%s-----" (__line__) );
}
_section();
{
   fn func( work:&List<Map<str,int>> ) {
      foreach list in work {
         foreach val, key in list {
            print( key, val );
         }
      }
   }
   let mut work = [{ "ab":1 }, { "xyz":2 }];
   work.remove(##);
   work.insert( {"eee":10} );
   func( work );
}
_section();
{
   fn func( val1:int!, val2:int! ) {
      when! val1, val2 {
         print( val1 + val2 );
      }
      else {
         print( val1, val2 );
      }
   }
   func( 1, 10 );
   func( nil, 10 );
   func( 10, nil );
   func( nil, nil );
}
_section();
{
   fn func( val1:int!, val2:int! ) {
      if! let val10, val20 = val1, val2 {
         print( val10 + val20 );
      }
      else {
         print( val1, val2 );
      }
   }
   func( 1, 10 );
   func( nil, 10 );
   func( 10, nil );
   func( nil, nil );
}
_section();
{
   fn func() : int! {
      return 1;
   }
   let! val = func() {
      val = 2;
   };
   print( val );
}
_section();
{
   fn func( val1:int!, val2:int! ) {
      let! val10, val20 = val1, val2 {
         print( val1, val2 );
         return;
      }
      then {
         print( val10 + val20 );
      };
      print( val10 - val20 );
   }
   func( 1, 10 );
   func( nil, 10 );
   func( 10, nil );
   func( nil, nil );
}
_section();
{
   class Test {
      pro let val1:int;
      pro let val2:int;
      pub fn sub1(): int {
         return self.val1 + 100;
      }
      pub fn sub2(): int {
         return self.val2 + 100;
      }
   }
   class Sub extend Test {
      let val3:int;
      pub override fn sub1(): int {
         return self.val1 + 200;
      }
      pub fn sub3(): int {
         return self.val3 + 200;
      }
   }
   class SubSub extend Sub {
      pub override fn sub1(): int {
         return self.val1 + 300;
      }
      pub override fn sub2(): int {
         return self.val2 + 300;
      }
   }

   fn func1( test:&Test ): int, int {
      if! let sub = test@@@Sub {
         print( "OK", sub.sub2() );
      }
      else {
         print( "CAN'T CAST" );
      }
      return test.sub1(), test.sub2();
   }

   fn func2( test:&stem ) {
      if! let sub = test@@@Sub {
         print( "OK", sub.sub2() );
      }
      else {
         print( "CAN'T CAST" );
      }
   }

   let test = new Test( 1, 2 );
   print( func1( test )** );
   func2( test );

   let sub = new Sub( 1, 2, 3 );
   print( sub.sub3(), func1( sub )** );
   func2( sub );

   let subsub = new SubSub( 1, 2, 3 );
   print( subsub.sub3(), func1( subsub )** );
   func2( subsub );
}
_section();
{
   class Test {
      let val1:int;
      let val2:int;
      pub fn __init(val1:int, val2:int) {
         self.val1 = val1;
         self.val2 = val2;
      }
      pub fn func() {
         print( self.val1, self.val2 );
      }
   }

   fn func():int,int {
      return 1, 2;
   }

   class Sub extend Test {
   }

   class SubSub extend Sub {
      let val3:int;
      pub fn __init() {
         super( 0, (func()));
         self.val3 = 3;
      }
      pub override fn func() {
         super();
         print( self.val3 );
      }
   }

   let test = new SubSub();
   test.func();
}
_section();
{
   class Test {
      let val:int;
      pub fn func():int {
         return self.val;
      }
   }
   class Sub extend Test {
      pub override fn func():int {
         return super() + 100;
      }
   }
   let list = [ new Sub( 1 ), new Test( 10 ) ];
   foreach val in list {
      print( val.func() );
   }
}
_section();
{
   fn func( val:str ) {
      switch val {
         case "1", "2" {
            print( "A" );
         }
         case "3", "4" {
            print( "B" );
         }
         default {
            print( "C" );
         }
      }
   }

   foreach val in [ "1", "2", "3", "4", "5" ] {
      func( val );
   }
}
_section();
{
   let mut val = 1;
   while true {
      if val > 10 {
         break;
      }
      print( val );
      val = val + 1;
   }
}
_section();
{
   let mut val = 1;
   repeat {
      print( val );
      val = val + 1;
   } val > 10;
}
_section();
{
   class Test {
      let mut val:int {pub,pub};
   }

   let mut test = new Test( 10 );
   test.set_val( test.$val + 100 );
   print( test.$val );   
}
_section();
class Testggg {
   static let val:int;

   __init {
      Testggg.val = 1;
   }
   pub fn func():int {
      return Testggg.val + 10;
   }
   pub static fn sfunc():int {
      return 10;
   }
}
_section();
{
   let test = new Testggg();
   print( test.func(), Testggg.sfunc() );
}
_section();
{
   enum Test {
      Val1,
      Val2,
   }
   foreach val in Test.$_allList {
      print( val + 10 );
   }
   enum Test2 {
      Val1 = "a",
      Val2 = "b",
   }
   foreach val, index in Test2.$_allList {
      print( index, val, Test2._from( val ), val.get__txt(), val.$_txt );
   }
}
_section();
{
   enum Test {
      Val1,
      Val2,
   }

   fn func( val:Test ) {
      print( val + 1 );
   }

   func( .Val1 );
}
_section();
{
   alge Val {
      val1,
      val2( int, str ),
   }

   fn sub( val:Val ) {
      match val {
         case .val2( val1, val2 ) {
            print( "val2 %s" (val2) );
         }
         default {
            print( "other" );
         }
      }
      if val == .val1 {
         print( "equal" );
      }
      print( val.$_txt );
   }
   sub( Val.val1 );
   sub( Val.val2( 100, "xyz" ) );
}
_section();
{
   fn func( val:int, ... ) {
      print( ..., val );
   }

   func( 1, 2, "abc" );
}
_section();
{
   fn func( val:int, ... ) {
      let list = [ ... ];
      foreach item in list {
         print( item );
      }
   }

   func( 1, 2, "abc" );
}
_section();
{
   let val = -1.5;
   for index = 10,1, val {
      print( index );
   }
}
_section();
{
   form TestForm( val:str ):int, int;
   fn func( txt:str ) : TestForm! {
      return fn ( val:str ):int,int { print( val .. txt ); return 1, 2; };
   }
   let sub = func( "xyz" );
   when! sub {
      print( sub( "hoge" )** );
   }
}
_section();
{
   class Test0 {
      pub let val:int {pub};
      pub fn func( val:int ):int {
         return self.val + val;
      }
   }
   class Test1 {
      pub let val0:Test0 {pub};
      pub fn func( val:int ):int {
         return self.val0.$val + val;
      }
   }
   class Test2 {
      pub let val1:Test1! {pub};
   }
   class Test3 {
      pub let val2:Test2! {pub};
   }
   fn func(test:Test3) {
      print( test.val2$.val1$.func$( 1 ), test.val2$.val1$.val0$.func$( 10 ) );
   }
   func( new Test3(##) );
   func( new Test3( new Test2(##)) );
   func( new Test3( new Test2( new Test1( new Test0( 10 )  ))) );
}
_section();
{
   class Test {
      pub fn func1():int {
         return 1;
      }
      pub fn func2():int, int {
         return 1, 2;
      }
      pub fn func5():int, int, int, int, int {
         return 1, 2, 3, 4, 5;
      }
   }
   fn func( test:Test! ) {
      {
         let! val1 = test$.func1$() {
            print( "NG" );
            return;
         };
         print( val1 );
      }
      {
         let! val1, val2 = test$.func2$() {
            print( "NG" );
            return;
         };
         print( val1 + val2 );
      }
      {
         let! val1, val2, val3, val4, val5 = test$.func5$() {
            print( "NG" );
            return;
         };
         print( val1 + val2 + val3 + val4 + val5  );
      }
   }
   func( new Test() );
}
_section();
{
   class Test {
      let val:int {pub};
   }
   class Sub {
      let val:Test {pub};
   }
   let test:&Sub! = new Sub( new Test( 1 ) );
   print( test$.get_val$()$.get_val$() );
   print( test$.$val$.$val );
   print( test$.get_val$()$.$val );
   print( test$.$val$.get_val$() );
}
_section();
{
   class Test<T> {
      pub let val:T {pub};
      pub fn func():T {
         return self.val;
      }
      pub fn func2():T, T {
         return self.val, self.val;
      }
   }
   fn func1( test:&Test<int> ) {
      print( test.func() + 10 );
   }
   fn func2( test:&Test<str> ) {
      print( test.func() .. "xyz" );
   }


   let test = new Test( 1 );
   func1( test );
   let test2 = new Test( "a" );
   func2( test2 );

   print( test.func2() + 1 );
   print( test2.func2() .. "xyz" );
   fn sub( val1:int, val2:int, val3:int! ) {
      print( val1, val2 );
   }
   sub( test.func2()** ## );
   print( test.$val + 1);
   print( test.val + 1, test.val + 2);
   {
      let val1, val2 = test.val + 1, test.val + 2;
      print( val1 + val2 );
   }
}
_section();
{
   fn func( txt:str ) {
      print( "gsub:", txt, txt.gsub( "ai", "AI")** );
      print( "find:", txt, txt.find( "op" ## )** );
      print( "byte:", txt, txt.byte( 2, 3 )** );
      print( "rep:", txt, txt.rep( 3 ) );
      print( "sub:", txt, txt.sub( 2, 3 ) );
      print( "lower:", txt, txt.lower() );
      print( "upper:", txt, txt.upper() );
      print( "reverse:", txt, txt.reverse() );
      apply token of txt.gmatch( "[^a]+" ) {
         print( token );
      }
   }
   func( "fieoapfjaiopjfeop" );
}
_section();
{
   fn ite( param:int, prev:stem! ) : int!, str {
      let mut prevInt:int = 0;
      if prev == param {
         return nil, "";
      }  
      when! prev {
         prevInt = prev@@int;
      }  
      else {
         prevInt = 0;
      }  
      let next = prevInt + 1;
      return next, "@%d@" ( next );
   }  

   form iteForm( param:int, prev:stem! ) : int!, str;

   fn testIte( max:int ): iteForm, int, int! {
      return ite, max, nil;
   }  

   apply value1, value2 of testIte( 10 ) {
      print( value1, value2 );
   }
}
_section();
{
   fn func() : ...<int> {
      return 1, 2, 3;
   }

   {
      let val1, val2, val3 = func();
      print( val1, val2, val3 );
   }
   {
      let val1, val2 = func();
      print( val1, val2 );
   }
   print( func() );
}
_section();
{
   fn func() : ...<int> {
      return 1, 2, 3;
   }

   {
      if! let val1, val2, val3 = func() {
         print( val1 + 10, val2 + 10, val3 + 10 );
      }
   }
   {
      let val1, val2 = func();
      print( val1, val2 );
   }
   print( func() );
}
_section();
{
   fn func( stream:oStream ) {
      stream.write( "abcd\n" );
   }
   func( io.stdout );
}
_section();
{
   let set = (@ "10", "9", "1", "2", "3", "4" );
   forsort val in set {
      print( val .. "aa" );
   }  
}
_section();
{
   let map = {"X":1, "O":2, "A":3, "B":4, "C":5, "D":6 };
   forsort val, key in map {
      print( key .. "aa", val + 10 );
   }  
}
_section();
{
   let nilable:int! = nil;
   let mut map = {"X":1, "O":2, "A":3, "B":4, "C":5, "D":6, "Z":nil, "ZZ":nilable };
   map[ "xyz" ] = 10;
   map[ "A" ] = nil;
   forsort val, key in map {
      print( key .. "aa", val + 10 );
   }  
}
_section();
{
   fn func() {
      print( __mod__, __func__, __line__ );
   }
   func();
}
_section();
{
   class Test extend (Mapping) {
      let val:List<int> {pub};
      let val2:Map<int,str> {pub};
   }
   class Sub extend Test {
      let val3:Set<real> {pub};
   }
   class Hoge extend (Mapping) {
      let list:List<Sub> {pub};
   }
   let hoge = new Hoge(
      [ new Sub( [100, 200, 300], {10:"aa", 20:"bb"}, (@ 1.5, 10.5 ) ),
        new Sub( [1000, 2000, 3000], {100:"aaa", 200:"bbb"}, (@ 10.5, 100.5 ) ) ]);

   let map = hoge._toMap();
   foreach val0, key0 in map {
      foreach test, index in val0@@List<Map<str,stem>> {
         forsort val, key in test {
            switch key {
               case "val" {
                  foreach val2, key2 in val@@List<int> {
                     print( key0, index, key, key2, val2 );
                  }
               }
               case "val2" {
                  forsort val2, key2 in val@@Map<int,str> {
                     print( key0, index, key, key2, val2 );
                  }
               }
               case "val3" {
                  forsort val2 in val@@Set<real> {
                     print( key0, index, key, val2 );
                  }
               }
            }
         }
      }
   }

   let hoge2 = unwrap Hoge._fromStem( map );
   foreach sub in hoge2.$list {
      forsort val in sub.$val3 {
         print( val );
      }
      forsort val, key in sub.$val2 {
         print( key, val );
      }
      foreach val, index in sub.$val {
         print( index, val );
      }
   }
}
_section();
{
   fn func():int, int {
      return 1, 2;
   }
   {
      let val = func();
   }
}
_section();
{
   print( string.format( "%s = %s", "abcd", 123 ) );
   if! let luafn = _load( 'print( "hoge:" )' ## ) {
      luafn(##);
      let bin = string.dump( luafn ## );
      let fn2, mess =  _load( bin ## );
      when! fn2 {
         fn2(##);
      } else {
         print( mess );
      }
   }
}
_section();
{
   if! let mut fileObj = io.open( "miniGo.lns" ##) {
      print( fileObj.read( 100 ) );
   }
}
