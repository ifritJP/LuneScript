/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

_lune_control default_async_all;

import lune.base.Parser;
import lune.base.Util;
import lune.base.Code;
import lune.base.Log;
import lune.base.Types;


/**
ビルトインでないユーザが定義した型情報の ID 開始番号。

import 等で、別モジュールを解析する際に、モジュール毎の開始番号として使用する。
*/
pub let builtinRootId = 0;
let builtinStartId = 1;
pub let userRootId = 1000;
let userStartId = 1001;

pub class IdProvider {
   let mut id:int;
   let maxId:int;

   pub fn getNewId() mut : int {
      self.id = self.id + 1;
      if self.id >= self.maxId {
         Util.err( "id is over" );
      }
      return self.id;
   }
}
pub fn IdProvider.clone() : IdProvider {
   let mut idProd = new IdProvider( self.id, self.maxId );
   return idProd;
}

pub proto class TypeInfo2Map;

pub enum TypeInfoKind {
   Root,
   Macro,
   Prim,
   List,
   Array,
   Map,
   Class,
   IF,
   Func,
   Method,
   Nilable,
   Enum,
   Module,
   Stem,
   Alge,
   /** ... */
   DDD,
   /** 省略 ## */
   Abbr,
   Set,
   /** generics の型パラメータ */
   Alternate,
   Box,
   CanEvalCtrl,
   Etc,
   Form,
   FormFunc,
   /** Lua などの外部モジュール */
   Ext,
   /**
   * リストなどの型を複合する場合の型。共通ののインタフェースを持つ。
   * この型は export 対象外。
   * getCommonType() のためだけで使用。他の処理で使用したときは動作を保証しない。
   */ 
   CombineIF,
   // module宣言
   ExtModule,
}


let extStartId = 100000;
let extMaxId = 10000000;

pub proto interface TypeDataAccessor;
pub proto abstract class TypeInfo extend (TypeDataAccessor);

pub interface ModuleInfoIF {
   /** import したモジュールを assign したシンボル名 */
   pub fn get_assignName():str;
   /** import したモジュールのパス */
   pub fn get_modulePath():str;
}

pub class SimpleModuleInfo extend (ModuleInfoIF) {
   let assignName:str {pub};
   let modulePath:str {pub};
}

pub interface ModuleInfoManager {
   pub fn getModuleInfo( typeInfo:&TypeInfo ) : &ModuleInfoIF!;
}
pub proto class Scope extend(ModuleInfoManager);

/**
TypeInfo の付随した情報で、かつ mutable な情報。
*/
pub class TypeData {
   pri let mut children:List<&TypeInfo> {pub};
   pub fn __init() {
      self.children = [];
   }

   pub fn addFrom( typeData:&TypeData ) mut {
      foreach child in typeData.children {
         self.children.insert( child );
      }
   }
}

pub interface TypeDataAccessor {
   pub fn get_typeData():TypeData;
}

pub class SimpleTypeDataAccessor extend (TypeDataAccessor) {
   let typeData:TypeData {pub};
}

pub enum IdType {
   Base,
   Ext,
}
pub class ProcessInfo {
   let mut idProvSym:IdProvider {pub};
   let mut idProvScope:IdProvider {pub};
   let mut idProv:IdProvider {pub};
   let mut idProvBase:IdProvider {pub};
   let mut idProvExt:IdProvider {pub};
   let mut typeInfo2Map:TypeInfo2Map!;
   let mut validExtType:bool {pub};
   let validCheckingMutable:bool {pub};
   let id2TypeInfo:Map<int,&TypeInfo>;
   let validDetailError:bool {pub};
   let mut topScope:Scope! {non,local};
   let mut dummyParentType:TypeInfo! {non,local};
   let mut orgInfo:&ProcessInfo {pub};

   pub fn get_topScope() mut : Scope {
      return unwrap self.topScope;
   }
   pub fn get_dummyParentType() mut : TypeInfo {
      return unwrap self.dummyParentType;
   }

   let mut miscTypeData:TypeData;
      
   local fn get_typeInfo2Map() mut : TypeInfo2Map {
      return unwrap self.typeInfo2Map;
   }
   local fn set_typeInfo2Map( typeInfo2Map:TypeInfo2Map ) mut {
      self.typeInfo2Map = typeInfo2Map;
   }

   pub fn getTypeInfo( id:int ) : &TypeInfo! {
      return self.id2TypeInfo[ id ];
   }

   /** メンバを追加したら clone() のメンテナンスが必要 */
   pub fn clone() : ProcessInfo;
   
   pri fn __init(
      validCheckingMutable:bool, idProvBase:IdProvider,
      validExtType:bool, validDetailError:bool, typeInfo2Map:TypeInfo2Map! )
   {
      self.orgInfo = self;
      self.dummyParentType = nil;
      self.topScope = nil;
      self.miscTypeData = new TypeData();
      self.validDetailError = validDetailError;
      self.id2TypeInfo = {};
      self.validCheckingMutable = validCheckingMutable;
      self.validExtType = validExtType;
      self.idProvBase = idProvBase;
      self.idProvExt = new IdProvider( extStartId, extMaxId );
      self.idProv = self.idProvBase;
      self.idProvSym = new IdProvider( 0, extMaxId );
      self.idProvScope = new IdProvider( 0, extMaxId );
      self.typeInfo2Map = typeInfo2Map;
   }

   local static fn createRoot() : ProcessInfo
   {
      return new ProcessInfo(
         true, new IdProvider( builtinStartId, userStartId ), true, false, nil );
   }

   
   pub fn switchIdProvier( idType:IdType ) mut {
      Log._log2( .Trace, "start" );
      if idType == .Base {
         self.idProv = self.idProvBase;
      }
      else {
         self.idProv = self.idProvExt;
      }
   }
}

pub class IdInfo {
   pub let mut id:int {non,local};
   let mut processInfo:&ProcessInfo {pub};
   let allmut orgId:int!;

   pub fn isSwichingId() : bool {
      let! orgId = self.orgId {
         return false;
      };
      return orgId ~= self.id;
   }
   
   pub fn set_orgId(id:int) {
      self.orgId = id;
   }

   pub fn get_orgId() : int {
      return self.orgId or self.id;
   }
   pub fn __init( id:int, processInfo:&ProcessInfo ) {
      self.id = id;
      self.processInfo = processInfo;
      self.orgId = nil;
   }

   pub fn equals( idInfo:&IdInfo ) : bool {
      if self.$orgId == idInfo.$orgId {
         if self.processInfo == idInfo.processInfo {
            return true;
         }
         // if self.$orgId >= extStartId {
         //    return true;
         // }
      }
      return false;
   }
}

let mut rootProcessInfo = ProcessInfo.createRoot();
let rootProcessInfoRo = rootProcessInfo;
pub fn getRootProcessInfo() __noasync : ProcessInfo {
   return rootProcessInfo;
}
pub fn getRootProcessInfoRo() : &ProcessInfo {
   return rootProcessInfoRo;
}

local fn ProcessInfo.newIdForRoot() mut : IdInfo {
   return new IdInfo( builtinRootId, self );
}
local fn ProcessInfo.newIdForSubRoot() mut : IdInfo {
   return new IdInfo( userRootId, self );
}
local fn ProcessInfo.setRootTypeInfo( id:int, typeInfo:&TypeInfo ) mut {
   self.id2TypeInfo[ id ] = typeInfo;
}

local fn ProcessInfo.newId( typeInfo:&TypeInfo ) mut : IdInfo {
   let id = self.idProv.getNewId();
   self.id2TypeInfo[ id ] = typeInfo;
   return new IdInfo( id, self );
}


pub let rootTypeIdInfo = rootProcessInfo.newIdForRoot();


/** 所定の TypeInfo が属するモジュールの ModuleInfoIF の問い合わせを行なう */

pub class DummyModuleInfoManager extend (ModuleInfoManager) {
   pri static let instance:DummyModuleInfoManager {pub};
   pri fn __init() {
   }
   __init {
      DummyModuleInfoManager.instance = new DummyModuleInfoManager();
   }
   pub fn getModuleInfo( typeInfo:&TypeInfo ) : &ModuleInfoIF! {
      return nil;
   }
}

pub enum AccessMode {
   None,
   Pub,
   Pro,
   Pri,
   Local,
   Global,
}

pub enum SymbolKind {
   /** 型 */
   Typ,
   /** メンバ */
   Mbr,
   /** メソッド */
   Mtd,
   /** 関数 */
   Fun,
   /** 変数 */
   Var,
   /** 引数 */
   Arg,
   /** マクロ */
   Mac,
}

pub interface LowSymbol {
   /** このシンボルが属するスコープ */
   pub fn get_scope(): &Scope;
   /** シンボルのアクセス */
   pub fn get_accessMode(): AccessMode;
   /** このシンボルの ID */
   pub fn get_symbolId(): int;
   /** シンボルの名前 */
   pub fn get_name(): str;
   /** このシンボルが mut かどうか */
   pub fn get_mutable(): bool;
   /** シンボルの型 */
   pub fn get_typeInfo(): &TypeInfo;
   /** このシンボルの種類 SymbolKind */
   pub fn get_kind(): SymbolKind;
   /** このシンボルが、 closuer 内からセットされているかどうか */
   pub fn get_hasAccessFromClosure(): bool;
   /** 変換モジュール用パラメータ */
   pub fn get_convModuleParam():stem!;
   /** */
   pub fn get_staticFlag(): bool;
   /** */
   pub fn get_isLazyLoad(): bool;
}

pub proto abstract class SymbolInfo extend (LowSymbol) ;


let mut sym2builtInTypeMapWork:Map<str,SymbolInfo> = {};
let sym2builtInTypeMap:&Map<str,&SymbolInfo> = sym2builtInTypeMapWork;

pub class BuiltinTypeInfo {
   let typeInfo:&TypeInfo {pub};
   let typeInfoMut:TypeInfo! {pub};
   let scope:Scope! {pub};
}

let mut builtInTypeIdSetWork:Map<int,BuiltinTypeInfo> = {};
let builtInTypeIdSet:&Map<int,&BuiltinTypeInfo> = builtInTypeIdSetWork;

pub fn getSym2builtInTypeMap(): &Map<str,&SymbolInfo> {
   return sym2builtInTypeMap;
}
pub fn getBuiltInTypeIdMap():&Map<int,&BuiltinTypeInfo> {
   return builtInTypeIdSet;
}


pub enum SerializeKind {
   Nilable,
   Modifier,
   Module,
   Normal,
   Enum,
   Alge,
   DDD,
   Alias,
   Alternate,
   Generic,
   Box,
   Ext,
}

pub fn isBuiltin( typeId: int ) : bool {
   return builtInTypeIdSet[ typeId ] ~= nil;
}


pub fn isPubToExternal( mode:AccessMode ): bool {
   switch mode {
      case .Pub, .Pro, .Global {
         return true;
      }
   }
   return false;
}

let txt2AccessModeMap:&Map<str,AccessMode> = {
   "none" : .None,
   "pub" : .Pub,
   "pro" : .Pro,
   "pri" : .Pri,
   "local" : .Local,
   "global" : .Global,
};
pub fn txt2AccessMode( accessMode:str ) : AccessMode! {
   return txt2AccessModeMap[ accessMode ];
}

let accessMode2txtMap:&Map<AccessMode,str> = {
   .None:  "none",
   .Pub:  "pub",
   .Pro:  "pro",
   .Pri:  "pri",
   .Local:  "local",
   .Global:  "global",
};
pub fn accessMode2txt( accessMode:AccessMode ) : str {
   return unwrap accessMode2txtMap[ accessMode ];
}

pub enum MutMode {
   IMut,
   /**
   メンバの中身を含めて Imutable。
   例えば List<Hoge> の List が IMutRe の時、Hoge も Imutable。
   */ 
   IMutRe,
   Mut,
   AllMut,
   Depend,
}
pub fn isMutable( mode:MutMode ): bool {
   switch mode {
      case .AllMut, .Mut {
         return true;
      }
   }
   return false;
}

// pub enum AccessFromClosuer {
//    /** アクセスなし */
//    None,
//    /** 読み込みアクセス */
//    Read,
//    /** 書き込みアクセス */
//    Write,
// }

pub class TypeNameCtrl {
   /** 現在解析中モジュールの型情報 */
   let mut moduleTypeInfo:&TypeInfo {pub,pub};
   
   pub fn getParentFullName(
      mut typeInfo:&TypeInfo, mut importInfo:&ModuleInfoManager!, localFlag:bool! ) : str;
}

pub enum ScopeAccess {
   Normal,
   Full,
}

/** シンボル情報 */
pub abstract class SymbolInfo extend (LowSymbol) {
   pri let allmut namespaceTypeInfo: &TypeInfo! {non,local};

   pro fn __init() {
      self.namespaceTypeInfo = nil;
   }
   
   /** 左辺値になれる場合 true */
   pub abstract fn get_canBeLeft(): bool;
   /** 右辺値になれる場合 true */
   pub abstract fn get_canBeRight(): bool;
   /** このシンボルの ID */
   pub abstract fn get_symbolId(): int;
   /** このシンボルが属するスコープ */
   pub abstract fn get_scope(): &Scope;
   /** シンボルのアクセス */
   pub abstract fn get_accessMode(): AccessMode;
   /** */
   pub abstract fn get_staticFlag(): bool;
   /** */
   pub abstract fn get_isLazyLoad(): bool;
   /** シンボルの名前 */
   pub abstract fn get_name(): str;
   /**
シンボルの定義位置。実際の定義位置とズレることがある。参考程度にすること。
外部シンボルや、ビルトインの場合は nil。
 */
   pub abstract fn get_pos(): &Parser.Position!;
   /** シンボルの型 */
   pub abstract fn get_typeInfo(): &TypeInfo;
   /** シンボルの型 */
   pub abstract fn set_typeInfo(typeInfo:&TypeInfo);
   /** このシンボルが mut かどうか */
   pub abstract fn get_mutable(): bool;
   pub abstract fn get_mutMode(): MutMode;
   /** このシンボルの種類 SymbolKind */
   pub abstract fn get_kind(): SymbolKind;
   /** このシンボルがデータを保持しているかどうか */
   pub abstract fn get_hasValueFlag(): bool;
   pub abstract fn set_hasValueFlag( arg:bool );
   //pub abstract fn set_hasValueFlag( arg:bool );
   /** このシンボルが、 closuer 内からセットされているかどうか。 変数の時に有効。 */
   pub abstract fn get_hasAccessFromClosure(): bool;
   local abstract fn set_hasAccessFromClosure(flag:bool);
   /** このシンボルに値をセットした最後の位置。 変数の時に有効。 */
   pub abstract fn get_posForLatestMod():&Parser.Position!;
   local abstract fn set_posForLatestMod(pos:&Parser.Position!);
   /** このシンボルを最後に参照した値をセットした位置。 変数の時に有効。 */
   pub abstract fn get_posForModToRef():&Parser.Position!;
   pub abstract fn set_posForModToRef(pos:&Parser.Position!);

   pub fn hasAccess(): bool {
      if self.$posForModToRef or self.$posForLatestMod ~= self.$pos {
         return true;
      }
      return false;
   }
   
   pub fn updateValue( pos:&Parser.Position! ) {
      self.set_hasValueFlag( true );
      self.set_posForLatestMod( pos );
   }
   pub fn clearValue() {
      self.set_hasValueFlag( false );
   }
   
   // pub abstract fn get_accessFromClosure(): AccessFromClosuer;
   // pub abstract fn set_accessFromClosure( mode: AccessFromClosuer );
   /** 変換モジュール用パラメータ */
   pub abstract fn set_convModuleParam( param:stem! );
   pub abstract fn get_convModuleParam():stem!;


   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub abstract fn canAccess( fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!;

   pub abstract fn getOrg(): &SymbolInfo;


   /** このシンボルを定義している名前空間の TypeInfo*/
   pub fn get_namespaceTypeInfo(): &TypeInfo;
}


pub class DataOwnerInfo {
   pub let hasData:bool;
   pub let symbolInfo: &SymbolInfo;
}

class ClosureInfo {
   pri let closureSymMap: Map<int,&SymbolInfo>;
   pri let closureSymList: List<&SymbolInfo> {pub&};
   pri let closureSym2NumMap: Map<&SymbolInfo,int>;

   local fn __init() {
      self.closureSymMap = {};
      self.closureSym2NumMap = {};
      self.closureSymList = [];
   }

   local fn setClosure( symbol:&SymbolInfo ) mut :bool {
      if not self.closureSymMap[ symbol.$symbolId ] {
         self.closureSymMap[ symbol.$symbolId ] = symbol;
         self.closureSym2NumMap[ symbol ] = #self.closureSymList;
         self.closureSymList.insert( symbol );
         return true;
      }
      return false;
   }

   pub fn setRefPos() {
      foreach symInfo in self.closureSymList {
         symInfo.set_posForModToRef( symInfo.$posForLatestMod );
      }
   }
}

pub enum ScopeKind {
   Module,
   Class,
   Other
}

pub class Scope extend (ModuleInfoManager) {

   pri let scopeId:int {pub};

   /**
親のスコープ。
これが self と等しい場合は root。
*/
   pri let mut outerScope: Scope { pub };
   /**
親のスコープ。
これが self と等しい場合は root。

outerScope は、 readonly の Scope の、内部スコープを登録する際に、
親子関係を表現する際に利用する。
*/
   let mut parent: &Scope { pub, local };
   // このスコープのオーナーの TypeInfo。
   // 名前空間に関連する class, function の TypeInfo。
   pri let allmut ownerTypeInfo: &TypeInfo! { pub };
   // このスコープに登録されているシンボル情報。
   // シンボル名 → SymbolInfo のマップ。
   pri let mut symbol2SymbolInfoMap: Map<str,&SymbolInfo> { pub& };
   // このスコープがクラスのスコープかどうか。
   pri let scopeKind: ScopeKind;
   // 継承しているスコープ。
   pri let mut inherit: &Scope! {pub};
   // 継承しているスコープ。
   pri let ifScopeList: List<&Scope>;
   /** 所有権情報 */
   pri let symbolId2DataOwnerInfo: Map<int,DataOwnerInfo>;
   /** このスコープ内でアクセスしている closure シンボル */
   pri let closureInfo: ClosureInfo;
   pub fn get_closureSymList() : &List<&SymbolInfo> {
      return self.closureInfo.$closureSymList;
   }
   pub fn updateClosureRefPos()  {
      self.closureInfo.setRefPos();
   }
   
   pri let mut hasClosureAccess: bool {pub,pub};
   pri let mut typeInfo2ModuleInfoMap: Map<&TypeInfo,&ModuleInfoIF>;
   pri let mut validCheckingUnaccess:bool {pub,pub};
   

   pub fn __init( processInfo:ProcessInfo, parent: Scope!, scopeKind: ScopeKind,
                  inherit: &Scope!, ifScopeList:List<&Scope>! )
   {
      self.scopeId = processInfo.$idProvScope.getNewId();
      self.hasClosureAccess = false;

      self.closureInfo = new ClosureInfo();

      self.typeInfo2ModuleInfoMap = {};
      self.outerScope = unwrap parent default self;
      self.parent = self.outerScope;
      self.symbol2SymbolInfoMap = {};
      self.inherit = inherit;
      self.scopeKind = scopeKind;
      self.symbolId2DataOwnerInfo = {};
      self.ifScopeList = unwrap ifScopeList default [];
      self.ownerTypeInfo = nil;
      self.validCheckingUnaccess = true;
   }

   pub fn getNamespaceTypeInfo() : &TypeInfo;

   
   pub fn isRoot(): bool {
      return self.parent == self;
   }

   pub fn set_ownerTypeInfo( owner: &TypeInfo! ) mut {
      if not self.ownerTypeInfo {
         self.ownerTypeInfo = owner;
      }
   }
   pub fn switchOwnerTypeInfo( owner: &TypeInfo! ) {
      self.ownerTypeInfo = owner;
   }
   

   pub fn getTypeInfoChild( name: str ) : &TypeInfo! {
      if! self.symbol2SymbolInfoMap[ name ] {
         return _exp.$typeInfo;
      }
      return nil;
   }

   pub fn getSymbolInfoChild( name: str ) : &SymbolInfo! {
      return self.symbol2SymbolInfoMap[ name ];
   }

   pub fn setData( symbolInfo:&SymbolInfo ) mut {
      self.symbolId2DataOwnerInfo[ symbolInfo.$symbolId ] =
      new DataOwnerInfo( true, symbolInfo );
   }

   pub fn remove( name: str ) mut {
      self.symbol2SymbolInfoMap[ name ] = nil;
   }

   pub fn addSymbol( symbolInfo: SymbolInfo ) mut {
      self.symbol2SymbolInfoMap[ symbolInfo.$name ] = symbolInfo;
   }

   pub fn addModule( typeInfo:&TypeInfo, moduleInfo:&ModuleInfoIF ) mut {
      self.typeInfo2ModuleInfoMap[ typeInfo ] = moduleInfo;
   }

   pub fn getModuleInfo( typeInfo:&TypeInfo ) : &ModuleInfoIF! {
      if! let moduleInfo = self.typeInfo2ModuleInfoMap[ typeInfo ] {
         return moduleInfo;
      }
      if self.parent ~= self {
         return self.parent.getModuleInfo( typeInfo );
      }
      return nil;
   }
}

// 最上位のスコープ
let rootScope:Scope = new Scope( rootProcessInfo, nil, .Other, nil## );
// rootScope の Immutable 版
let rootScopeRo = rootScope;
rootProcessInfo.set_topScope( rootScope );

pub fn SymbolInfo.get_namespaceTypeInfo(): &TypeInfo {
   if! self.namespaceTypeInfo {
      return _exp;
   }
   let work = self.$scope.getNamespaceTypeInfo();
   self.namespaceTypeInfo = work;
   return work;
}


/**
このスコープが、 scope の同じか内部のスコープか調べる。

@return bool: 同じか内部のスコープの場合 true。
*/
pub fn Scope.isInnerOf( scope:&Scope ): bool {
   if self == scope {
      return true;
   }
   let mut workScope = self;
   while workScope.$parent ~= workScope {
      if workScope == scope {
         return true;
      }
      workScope = workScope.parent;
   }
   return false;
}

pub class ScopeWithRef extend Scope {
   pub fn __init( processInfo:ProcessInfo, outerScope: Scope,
                  parent: &Scope, scopeKind: ScopeKind,
                  inherit: &Scope!, ifScopeList:List<&Scope>! )
   {
      super( processInfo, outerScope, scopeKind, inherit, ifScopeList );
      self.set_parent( parent );
   }
}


let dummyList:&List<&TypeInfo> = [];
//let mut rootChildren:List<&TypeInfo> = [];

pub enum CanEvalType {
   /** 代入(アップキャスト可能な型は代入 OK とする)。 代入先は IMut で確定。 */
   SetOpIMut,
   /** 代入(アップキャスト可能な型は代入 OK とする)。 代入先は IMut かどうか無視。  */
   SetOp,
   /** 代入(アップキャスト可能な型でも、同一の型でない場合は NG とする) */
   SetEq,
   /** 値の等号を見る */
   Equal,
   /** 算術演算 */
   Math,
   /** 大小比較演算 */
   Comp,
   /** 論理演算 */
   Logical,
}

pub class SerializeInfo {
   let processInfo2Id: &Map<&ProcessInfo,int>;
   let validChildrenMap: &Map<&IdInfo,&TypeInfo> {pub};

   pub fn isValidChildren( idInfo:&IdInfo ) : bool {
      return not self.validChildrenMap[ idInfo ];
   }
   pub fn serializeId(idInfo:&IdInfo) : str {
      let id = idInfo.$orgId;
      if id >= extStartId {
         return "{ id = %d, mod = 0 }" ( id );
      }
      let processId = unwrap self.processInfo2Id[ idInfo.$processInfo ];
      return "{ id = %d, mod = %d }" ( idInfo.$orgId, processId );
   }
}

pub enum Async {
   /** Async の条件を満さない */
   Noasync,
   /**
次の要件を満す。   
- mutable な大域変数、あるいはクロージャの変数にアクセスしない。
- allmut への更新がない。
*/
   Async,
   /**
Async の要件に次を追加
- メンバや大域変数にはセットできない型。
- 別スレッドには渡せない。
*/   
   Transient,
}

pub abstract class TypeInfo extend (TypeDataAccessor) {

   // この TypeInfo のスコープ。
   // class, func など名前空間を持つ TypeInfo は有効。
   pri let allmut scope: &Scope! {pub};
   pri let typeData: TypeData {pub};
   // この TypeInfo の typeId を生成した processInfo
   pri let processInfo:&ProcessInfo {pub};
   // この TypeInfo が、親の TypeData の何番目の child か示す。 
   pri let mut childId:int {pub,local};

   pub abstract fn get_imutType(): &TypeInfo;
   local abstract fn set_imutType(typeInfo:&TypeInfo) mut;

   
   pub fn get_asyncMode() : Async {
      return .Async;
   }
   
   pro fn switchScope( scope: &Scope ) {
      self.scope = scope;
      scope.switchOwnerTypeInfo( self );
   }

   /**
   この TypeInfo がオーバーライドしている場合、
   そのオーバーライド元の TypeInfo を返す。
   オーバーライドしていない場合、 nil を返す。 
   */
   pub fn getOverridingType() : &TypeInfo! {
      return nil;
   }

   // pub fn get_scope(): Scope! {
   //    return typeInfo2ScopeMap[ self ];
   // }

   pub fn __init( scope: Scope!, processInfo:ProcessInfo ) {
      //typeInfo2ScopeMap[ self ] = scope;
      self.childId = 0;
      self.scope = scope;
      if! scope {
         _exp.set_ownerTypeInfo( self );
      }
      self.typeData = new TypeData();
      self.processInfo = processInfo;
      //TypeManager.add( self );
   }

   pub fn get_aliasSrc() : &TypeInfo {
      return self;
   }

   pub fn get_extedType() : &TypeInfo {
      return self;
   }
   
   pub static fn getModulePath( fullname:str ) : str {
      return ( fullname.replace( "@", "" ) );
   }

   /** この型がモジュールを示す型の場合 true  */
   pub fn isModule(): bool {
      return true;
   }

   /** 親の typeId  */
   pub fn getParentId(): &IdInfo {
      return rootTypeIdInfo;
   }

   /** スーパークラスの typeId */
   pub fn get_baseId(): &IdInfo {
      return rootTypeIdInfo;
   }

   /** この型が other を継承しているかどうか */
   pub fn isInheritFrom(
      processInfo:&ProcessInfo,
      other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool {
      return false;
   }

   /** シンプルな型名 */
   pub fn get_rawTxt(): str {
      return "";
   }

   /**
   この型の名前を取得する。

   型のフルパス名を取得する場合は、
    typeNameCtrl に現在の解析対象モジュールの TypeInfo を指定する。
    */  
   pro fn getTxtWithRaw(
      raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "";
   }

   /**
   この型の名前を取得する。

   型のフルパス名を取得する場合は、
    typeNameCtrl に現在の解析対象モジュールの TypeInfo を指定する。
    */  
   pub fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }

   /** other 型から dest 型への canEvalType の評価が可能かどうか */
   pro static fn canEvalWithBase(
      processInfo:&ProcessInfo, dest:&TypeInfo, destMut: bool, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!;

   /** other 型からこの型への canEvalType の評価が可能かどうか */
   pub fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo, canEvalType:CanEvalType,
      alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return false, nil;
   }

   /** この型が abstract かどうか */
   pub fn get_abstractFlag(): bool {
      return false;
   }

   /** この型情報を oStream にシリアライズする */
   pub fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      return;
   }


   /** 表示用文字列取得 */
   pub fn get_display_stirng_with( raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str {
      return "";
   }

   /** 表示用文字列取得 */
   pub fn get_display_stirng(): str {
      return self.get_display_stirng_with( "", nil );
   }


   /** Modifier の元となる型情報 */
   pub fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }

   /** この型と typeInfo が等しいかどうか */
   pub fn equals( processInfo:&ProcessInfo,
                  typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                  checkModifer:bool! ): bool
   {
      if checkModifer {
         return self == typeInfo;
      }
      return self == typeInfo.$srcTypeInfo;
   }

   /** この型が外部モジュールで定義した型かどうか */
   pub fn get_externalFlag(): bool {
      return false;
   }

   /** この型が実装しているインタフェースリスト */
   pub fn get_interfaceList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** generics の型リスト */
   pub fn get_itemTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** 引数の型リスト */
   pub fn get_argTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** 戻り値の型リスト */
   pub fn get_retTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** 名前空間の親 */
   pub abstract fn get_parentInfo(): &TypeInfo;

   pub static fn hasParent(typeInfo:&TypeInfo): bool {
      return typeInfo.$parentInfo ~= typeInfo;
   }
   
   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報が宣言されているか？
   */
   pub fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      while true {
         if other == self {
            return true;
         }
         if other.$parentInfo == other {
            break;
         }
         other = other.$parentInfo;
      }
      return false;
   }
   /** この型が属しているモジュールを取得 */
   pub fn getModule(): &TypeInfo {
      if self.isModule() {
         return self;
      }
      return self.$parentInfo.getModule();
   }
   /** typeId を取得 */
   pub fn get_typeId(): &IdInfo {
      return rootTypeIdInfo;
   }
   /** 型の種別 */
   pub fn get_kind(): TypeInfoKind {
      return .Root;
   }
   /**
static な型か。

メソッドでない関数は全て static となる。
   */
   pub fn get_staticFlag(): bool {
      return false;
   }
   /** アクセスモード */
   pub fn get_accessMode(): AccessMode {
      return AccessMode.Pri;
   }
   /** ユーザ定義でなく自動的に生成したかどうか */
   pub fn get_autoFlag(): bool {
      return false;
   }
   /** 非 nilable の型情報 */
   pub fn get_nonnilableType(): &TypeInfo {
      return self;
   }
   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub abstract fn get_baseTypeInfo(): &TypeInfo;

   /** nilable かどうか */
   pub fn get_nilable(): bool {
      return false;
   }
   /** nilable な型情報 */
   pub fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   /** nilable な型情報 */
   local abstract fn get_nilableTypeInfoMut() mut: TypeInfo;
   
   /** 子リスト取得 */
   pub fn get_children() : &List<&TypeInfo> {
      return self.typeData.$children;
   }
   /** mutable かどうか */
   pub fn get_mutMode(): MutMode {
      return .Mut;
   }

   pub static fn isMut( typeInfo:&TypeInfo ): bool {
      return isMutable( typeInfo.$mutMode );
   }

   /** 親の完全限定名を取得する */
   pub fn getParentFullName(
      typeNameCtrl:&TypeNameCtrl, 
      mut importInfo:&ModuleInfoManager!,
      localFlag:bool! ) : str
   {
      return typeNameCtrl.getParentFullName( self, importInfo, localFlag );
   }

   pub fn applyGeneric( processInfo:ProcessInfo, alt2typeMap:&Map<&TypeInfo,&TypeInfo>,
                        moduleTypeInfo:&TypeInfo ) : &TypeInfo!
   {
      return self;
   }

   pub fn get_genSrcTypeInfo(): &TypeInfo {
      return self;
   }

   pro fn serializeTypeInfoList(
      serializeInfo:&SerializeInfo,
      name: str, list: &List<&TypeInfo>, onlyPub: bool! ): str
   {
      let mut work = name;
      foreach typeInfo in list {
         if not onlyPub or typeInfo.$accessMode == .Pub  {
            if #work ~=  #name {
               work = work .. ", ";
            }
            work = "%s%s" (work, serializeInfo.serializeId( typeInfo.$typeId ) );
         }
      }
      return work .. "}, ";
   }

   pub static fn createScope(
      processInfo:ProcessInfo, parent: Scope!, scopeKind: ScopeKind,
      baseInfo: &TypeInfo!, interfaceList: &List<&TypeInfo>! ) : Scope
   {
      let mut inheritScope:&Scope! = nil;
      when! baseInfo {
         //inheritScope = unwrap getScope( baseInfo );
         inheritScope = unwrap baseInfo.$scope;
      }
      let mut ifScopeList:List<&Scope> = [];
      when! interfaceList {
         foreach ifType in interfaceList {
            ifScopeList.insert( unwrap ifType.$scope );
         }
      }
      return new Scope( processInfo, parent, scopeKind, inheritScope, ifScopeList );
   }

   // prototype
   pub fn createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo>;
   pub fn getFullName(
      typeNameCtrl:&TypeNameCtrl, importInfo:&ModuleInfoManager, localFlag:bool! ) : str;
   
}

local fn TypeData.addChildren( child:TypeInfo ) mut {
   child.set_childId( #self.children );
   self.children.insert( child );
}


pub alge LuavalResult {
   Err( mess:str ),
   OK( extType:&TypeInfo, pass:bool ),
}
pub fn ProcessInfo.createLuaval( luneType:&TypeInfo, validToCheck:bool ) mut : LuavalResult;

pub fn applyGenericDefault(
   processInfo:ProcessInfo, 
   typeInfo:&TypeInfo, alt2typeMap:&Map<&TypeInfo,&TypeInfo>,
   moduleTypeInfo:&TypeInfo ) : &TypeInfo
{
   if! let genType = typeInfo.applyGeneric( processInfo, alt2typeMap, moduleTypeInfo ) {
      return genType;
   }
   return typeInfo;
}

pub fn SymbolInfo.getModule(): &TypeInfo {
   return self.get_namespaceTypeInfo().getModule();
}

pub enum MethodKind {
   /** 全メソッド */
   All,
   /** static メソッド */
   Static,
   /** 非 static メソッド */
   Object,
}

/**
指定のクラスが持つ全メソッド名を取得する。

指定クラスが派生クラスだった場合、親クラスのメソッドも取得する。
*/
pub fn getAllNameForKind( classInfo:&TypeInfo, kind:MethodKind,
                          symbolKind:SymbolKind ) : &Util.OrderedSet<str>
{
   let mut nameSet = new Util.OrderedSet<str>();
   fn process( scope:&Scope ) __trans {
      if! let inherit = scope.$inherit {
         process( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case symbolKind {
               if symbolKind == .Mtd and symbolInfo.$name == "__init" {
                  // ピックアップ対象外
               }
               else {
                  let staticFlag = symbolInfo.$staticFlag;
                  if kind == .All or
                     kind == .Static and staticFlag or
                     kind == .Object and not staticFlag
                  {
                     nameSet.add( symbolInfo.$name );
                  }
               }
            }
         }
      }
   }

   if! let scope = classInfo.$scope {
      process( scope );
   }
   return nameSet;
}

pub fn getAllMethodName( classInfo:&TypeInfo, kind:MethodKind ) : &Util.OrderedSet<str> {
   return getAllNameForKind( classInfo, kind, .Mtd );
}


pub fn TypeNameCtrl.getModuleName(
   workTypeInfo:&TypeInfo, name:str, moduleInfoMan:&ModuleInfoManager ): str
{
   if! let moduleInfo = moduleInfoMan.getModuleInfo( workTypeInfo ) {
      let txt = moduleInfo.$assignName;
      return txt .. "." .. name;
   }
   else {
      if self.moduleTypeInfo ~= workTypeInfo {
         return workTypeInfo.$rawTxt .. "." .. name;
      }
   }
   return name;
}

pub fn TypeNameCtrl.getParentFullName(
   mut typeInfo:&TypeInfo, mut importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
{
   let mut workTypeInfo = typeInfo;
   let mut name = "";
   // let! mut infoMap = importInfo {
   //    infoMap = {};
   // };
   //while not infoMap[ typeInfo ] {
   let! moduleInfoMan = importInfo {
      moduleInfoMan = DummyModuleInfoManager.$instance;
   };
   //while not moduleInfoMan.getModuleInfo( workTypeInfo ) {
   while true {
      workTypeInfo = workTypeInfo.$parentInfo;
      let mut txt = workTypeInfo.$rawTxt;
      if workTypeInfo == workTypeInfo.$parentInfo {
         break;
      }
      if localFlag {
         if workTypeInfo.isModule() {
            name = self.getModuleName( workTypeInfo, name, moduleInfoMan );
            break;
         }
      }
      name = txt .. "." .. name;
   }
   return name;
}




pub fn isExtId(typeInfo:&TypeInfo): bool {
   if typeInfo.$typeId.id >= extStartId {
      return true;
   }
   return false;
}


pub class RootTypeInfo extend TypeInfo {
   pri let typeId:&IdInfo {pub};


   pri fn __init( processInfo:ProcessInfo, rootId:&IdInfo ) {
      super( processInfo.$topScope, processInfo );

      self.typeId = rootId;

      processInfo.set_dummyParentType( self );
   }
   pub override fn equals( processInfo:&ProcessInfo,
                           typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      if typeInfo@@@RootTypeInfo {
         return true;
      }
      return false;
   }

   
   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_imutType(): &TypeInfo {
      return self;
   }
   local override fn set_imutType(typeInfo:&TypeInfo) mut {
   }
   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self;
   }
   
   /** 名前空間の親 */
   pub override fn get_parentInfo(): &TypeInfo {
      return self;
   }

   local static fn create( processInfo:ProcessInfo, rootId:&IdInfo ) : RootTypeInfo {
      return new RootTypeInfo( processInfo, rootId );
   }

   pub override fn get_rawTxt(): str {
      return "<head>";
   }
   
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "<head>";
   }
}

/** TypeInfo の head。 */
let headTypeInfoMut:TypeInfo = RootTypeInfo.create( rootProcessInfo, rootTypeIdInfo );
pub let headTypeInfo:&TypeInfo = headTypeInfoMut;
rootProcessInfo.setRootTypeInfo( headTypeInfo.$typeId.id, headTypeInfo );


local static fn ProcessInfo.createUser(
   validCheckingMutable:bool, validExtType:bool,
   validDetailError:bool, typeInfo2Map:TypeInfo2Map! ) : ProcessInfo
{
   let mut processInfo = new ProcessInfo(
      validCheckingMutable, new IdProvider( userStartId, extStartId ),
      validExtType, validDetailError, typeInfo2Map );
   let mut scope = new Scope( processInfo, nil, .Other, nil## );
   processInfo.set_topScope( scope );
   let topType = RootTypeInfo.create( processInfo, processInfo.newIdForSubRoot());
   scope.set_ownerTypeInfo( topType );
      
   return processInfo;
}


//pub let headTypeInfo:TypeInfo = new TypeInfo( rootScope, rootProcessInfo );
//let rootTypeInfo:TypeInfo = new TypeInfo( rootScope );

pub let defaultTypeNameCtrl = new TypeNameCtrl( headTypeInfo );

pub fn TypeInfo.hasBase(): bool {
   return self.$baseTypeInfo ~= headTypeInfo;
}


pub fn Scope.getNamespaceTypeInfo() : &TypeInfo {
   let mut scope = self;
   repeat {
      if! scope.$ownerTypeInfo {
         return _exp;
      }
      scope = scope.$parent;
   } scope.isRoot();
   return unwrap scope.$ownerTypeInfo;
   // return headTypeInfo;
}

pub fn Scope.getModule() : &TypeInfo {
   return self.getNamespaceTypeInfo().getModule();
}

pub fn Scope.getProcessInfo(): &ProcessInfo {
   return self.getModule().$processInfo;
}

pub class NormalSymbolInfo extend SymbolInfo {
   // pri static let mut symbolIdSeed:int;

   // __init {
   //    NormalSymbolInfo.symbolIdSeed = 0;
   // }

   /** 左辺値になれる場合 true */
   pri let canBeLeft: bool { pub };
   /** 右辺値になれる場合 true */
   pri let canBeRight: bool { pub };

   /** このシンボルの ID */
   pri let symbolId: int { pub };
   /** このシンボルが属するスコープ */
   pri let scope: &Scope { pub };
   /** シンボルのアクセス */
   pri let accessMode: AccessMode { pub };
   /** */
   pri let staticFlag: bool { pub };
   /** */
   pri let isLazyLoad: bool { pub };
   /** シンボルの名前 */
   pri let name: str { pub };
   /** シンボルの名前 */
   pri let pos: &Parser.Position! { pub };
   /** シンボルの型 */
   pri let allmut typeInfo: &TypeInfo {pub};
   /** このシンボルの種類 SymbolKind */
   pri let kind: SymbolKind { pub };
   /** このシンボルがデータを保持しているかどうか */
   pri let allmut hasValueFlag: bool { pub, pub };
   pri let mutMode: MutMode {pub};
   // pri let allmut accessFromClosure: AccessFromClosuer { pub, pub };
   pri let allmut hasAccessFromClosure: bool {pub,local};
   pri let allmut posForLatestMod: &Parser.Position! {pub,local};
   pri let allmut posForModToRef:&Parser.Position! {pub,pub};
   
   /** 変換モジュール用パラメータ */
   pri let allmut convModuleParam:&stem! {pub,pub}; 

   pub override fn get_mutable(): bool {
      return isMutable( self.mutMode );
   }

   // pub override fn get_hasAccessFromClosure() : bool {
   //    return self.$accessFromClosure ~= .None;
   // }

   pub override fn getOrg(): &SymbolInfo {
      return self;
   }

   local fn __init(
      processInfo:ProcessInfo,
      kind:SymbolKind, canBeLeft:bool, canBeRight:bool, scope: Scope,
      accessMode: AccessMode, staticFlag: bool, name: str, pos:&Parser.Position!,
      typeInfo: &TypeInfo, mutMode: MutMode!, hasValueFlag: bool, isLazyLoad:bool )
   {
      super();
      self.convModuleParam = nil;
      //self.accessFromClosure = .None;
      self.hasAccessFromClosure = false;
      if hasValueFlag {
         self.posForLatestMod = pos;
      }
      else {
         self.posForLatestMod = nil;
      }
      self.posForModToRef = nil;
      
      //NormalSymbolInfo.symbolIdSeed = NormalSymbolInfo.symbolIdSeed + 1;
      self.kind = kind;
      self.canBeLeft = canBeLeft;
      self.canBeRight = canBeRight;
      self.symbolId = processInfo.$idProvSym.getNewId();
      self.scope = scope;
      self.accessMode = accessMode;
      self.staticFlag = staticFlag;
      self.name = name;
      self.pos = pos;
      self.typeInfo = typeInfo;
      self.mutMode = unwrap mutMode default MutMode.IMut;
      self.hasValueFlag = hasValueFlag;
      self.isLazyLoad = isLazyLoad;
   }

   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub override fn canAccess( fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!;
}

pro static fn TypeInfo.isInherit(
   processInfo:&ProcessInfo,
   typeInfo:&TypeInfo, other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ): bool
{
   let baseTypeInfo = typeInfo.$baseTypeInfo;
   //let interfaceList = typeInfo.$interfaceList;
   let otherTypeId = other.$typeId;
   if typeInfo.$typeId.equals( otherTypeId ) {
      return true;
   }
   if baseTypeInfo ~= headTypeInfo {
      if baseTypeInfo.isInheritFrom( processInfo, other, alt2type ) {
         return true;
      }
   };
   foreach ifType in typeInfo.$interfaceList {
      if ifType.isInheritFrom( processInfo, other, alt2type ) {
         return true;
      }
   }
   return false;
}

pub class ModifierTypeInfo extend TypeInfo {
   pri let srcTypeInfo: &TypeInfo { pub };
   pri let typeId: &IdInfo { pub };
   pri let mutMode: MutMode { pub };

   local fn __init( processInfo:ProcessInfo, srcTypeInfo:&TypeInfo, mutMode:MutMode ) {
      super( nil, processInfo );
      self.srcTypeInfo = srcTypeInfo;
      self.typeId = processInfo.newId( self );
      self.mutMode = mutMode;
   }

   pub override fn get_extedType() : &TypeInfo {
      return self;
   }
   
   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str,  typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      let mut txt = self.srcTypeInfo.getTxtWithRaw(
         raw, typeNameCtrl, importInfo, localFlag );
      switch self.mutMode {
         case .IMut, .IMutRe {
            txt = "&" .. txt;
         }
         case .AllMut {
            txt = "allmut " .. txt;
         }
         case .Depend {
            txt = "#" .. txt;
         }
      }
      return txt;
   }

   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str {
      let mut txt = self.srcTypeInfo.get_display_stirng_with( raw, alt2type );
      if isMutable( self.mutMode ) {
         txt = "mut " .. txt;
      }
      return txt;
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt, nil );
   }

   pub override fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      stream.write(
         '{ skind = %d, typeId = %d, srcTypeId = %s, mutMode = %d }\n' (
            SerializeKind.Modifier, self.typeId.id,
            serializeInfo.serializeId( self.srcTypeInfo.$typeId ),
            self.mutMode ) );
   }

   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      // if isGenericType( self.srcTypeInfo ) {
      //    return self.srcTypeInfo.canEvalWith( other, canEvalType, alt2type );
      // }

      if self.mutMode == .Depend {
         switch other.$mutMode {
            case .Mut, .Depend {
            }
            default {
               let mess = "mismatch %s, %s" (self.mutMode.$_txt, other.$mutMode.$_txt );
               return false, mess;
            }
         }
      }

      let evalType;
      if #self.srcTypeInfo.$itemTypeInfoList >= 1 {
         switch canEvalType {
            case .SetEq, .SetOp {
               // &List<Super> <-- List<Sub> などで、 型パラメータの継承を代入可能にする
               evalType = CanEvalType.SetOpIMut;
            }
            default {
               evalType = canEvalType;
            }
         }
      }
      else {
         evalType = canEvalType;
      }


      let result, mess = TypeInfo.canEvalWithBase(
         processInfo, self.srcTypeInfo, TypeInfo.isMut( self ),
         other.$srcTypeInfo, evalType, alt2type );
      return result, mess;
   }

   pub override fn equals(
      processInfo:&ProcessInfo, typeInfo: &TypeInfo,
      alt2type:Map<&TypeInfo,&TypeInfo>!, checkModifer:bool! ): bool
   {
      if checkModifer {
         if TypeInfo.isMut( self ) ~= TypeInfo.isMut( typeInfo ) {
            return false;
         }
      }
      return self.srcTypeInfo.equals(
         processInfo, typeInfo.$srcTypeInfo, alt2type, checkModifer );
   }

   advertise srcTypeInfo;
}



pub proto class DDDTypeInfo extend TypeInfo;

pub class TypeInfo2Map {
   pub let mut ImutModifierMap:Map<&TypeInfo,&TypeInfo> {pub};
   pub let mut ImutReModifierMap:Map<&TypeInfo,&TypeInfo> {pub};
   pub let mut MutModifierMap:Map<&TypeInfo,&TypeInfo> {pub};
   pub let mut BoxMap:Map<&TypeInfo,&TypeInfo> {pub};
   pub let mut DDDMap:Map<&TypeInfo,&DDDTypeInfo> {pub};
   pub let mut ExtDDDMap:Map<&TypeInfo,&DDDTypeInfo> {pub};
   pub let mut ExtMap:Map<&TypeInfo,&TypeInfo> {pub};
   // pub let mut ListMap:Map<&TypeInfo,&TypeInfo> {pub};
   // pub let mut SetMap:Map<&TypeInfo,&TypeInfo> {pub};
   // pub let mut ArrayMap:Map<&TypeInfo,&TypeInfo> {pub};

   pub fn __init() {
      self.ImutModifierMap = {};
      self.ImutReModifierMap = {};
      self.MutModifierMap = {};
      self.BoxMap = {};
      self.DDDMap = {};
      self.ExtDDDMap = {};
      self.ExtMap = {};
      // self.ListMap = {};
      // self.SetMap = {};
      // self.ArrayMap = {};
   }

   pub fn clone(): TypeInfo2Map {

      macro _clone( map:sym ) {
         foreach val, key in self.,,map {
            obj.,,map[ key ] = val;
         }
      }
      
      let mut obj = new TypeInfo2Map();
      _clone( ImutModifierMap );
      _clone( ImutReModifierMap );
      _clone( MutModifierMap );
      _clone( BoxMap );
      _clone( DDDMap );
      _clone( ExtDDDMap );
      _clone( ExtMap );
      // _clone( ListMap );
      // _clone( SetMap );
      // _clone( ArrayMap );
      return obj;
   }
}

pub fn ProcessInfo.clone() : ProcessInfo {
   let mut processInfo = new ProcessInfo(
      self.validCheckingMutable, self.idProvBase.clone(),
      self.validExtType, self.validDetailError, (unwrap self.typeInfo2Map).clone() );

   processInfo.idProvExt = self.idProvExt.clone();
   processInfo.idProvSym = self.idProvSym.clone();
   processInfo.idProvScope = self.idProvScope.clone();

   foreach val, key in self.id2TypeInfo {
      processInfo.id2TypeInfo[ key ] = val;
   }
   return processInfo;
}


rootProcessInfo.set_typeInfo2Map( new TypeInfo2Map() );

let immutableTypeSetWork:Set<&TypeInfo> = (@);
let immutableTypeSet = immutableTypeSetWork;

/**
指定の型が非破壊型なオブジェクトかどうか。

例えば int, str 型や enum などが非破壊型。
*/
pub static fn TypeInfo.isImmortal( mut typeInfo:&TypeInfo ) : bool {
   typeInfo = typeInfo.$nonnilableType;
   if immutableTypeSet.has( typeInfo ) {
      return true;
   }
   switch typeInfo.$kind {
      case .FormFunc, .Enum {
         return true;
      }
   }
   return false;
}

// 指定の型が mutable/imuttable に切り替え可能かどうか
pub static fn TypeInfo.isMutableType( mut typeInfo:&TypeInfo ) : bool {
   if TypeInfo.isImmortal( typeInfo ) {
      return false;
   }
   typeInfo = typeInfo.$nonnilableType;
   return isMutable( typeInfo.$mutMode );
}

pub static fn TypeInfo.canBeAsyncParam(typeInfo:&TypeInfo): bool {
   if TypeInfo.isMutableType( typeInfo ) {
      return false;
   }
   foreach itemType in typeInfo.$itemTypeInfoList {
      if not TypeInfo.canBeAsyncParam( itemType ) {
         return false;
      }
   }
   return true;
}

pub static fn TypeInfo.canBeAbsImmutMember(typeInfo:&TypeInfo): bool {
   if TypeInfo.isMutableType( typeInfo ) {
      return false;
   }
   foreach itemType in typeInfo.$itemTypeInfoList {
      if not TypeInfo.canBeAbsImmutMember( itemType ) {
         return false;
      }
   }
   return true;
}


pub fn ProcessInfo.createModifier(
   mut srcTypeInfo: &TypeInfo, mutMode:MutMode) mut : &TypeInfo
// pub static fn NormalTypeInfo.createModifier(
//    mut srcTypeInfo: &TypeInfo, mutMode:MutMode): &TypeInfo
{
   srcTypeInfo = srcTypeInfo.$srcTypeInfo;
   if not TypeInfo.isMutableType( srcTypeInfo ) {
      return srcTypeInfo;
   }
   
   switch mutMode {
      case .IMut {
         if! self.$typeInfo2Map.ImutModifierMap[ srcTypeInfo ] {
            return _exp;
         }
      }
      case .IMutRe {
         if! self.$typeInfo2Map.ImutReModifierMap[ srcTypeInfo ] {
            return _exp;
         }
      }
      case .AllMut {
         if! self.$typeInfo2Map.MutModifierMap[ srcTypeInfo ] {
            return _exp;
         }
      }
   }

   let modifier;
   if srcTypeInfo.$nonnilableType.$kind == .Ext {
      // 元々 Ext だったものは、 failCreateLuavalWith() を実行しない
      _match self.createLuaval(
         self.createModifier( srcTypeInfo.$extedType, mutMode ), false )
      {
         case .OK( workType, _ ) {
            if srcTypeInfo.$nilable {
               modifier = workType.$nilableTypeInfo;
            } else{
               modifier = workType;
            }
         }
         case .Err( err ) {
            Util.err( err );
         }
      }
   } else {
      modifier = new ModifierTypeInfo( self, srcTypeInfo, mutMode );
   }
   switch mutMode {
      case .IMut {
         self.$typeInfo2Map.ImutModifierMap[ srcTypeInfo ] = modifier;
      }
      case .IMutRe {
         self.$typeInfo2Map.ImutReModifierMap[ srcTypeInfo ] = modifier;
      }
      case .AllMut {
         self.$typeInfo2Map.MutModifierMap[ srcTypeInfo ] = modifier;
      }
   }
   return modifier;
}


pub class AutoBoxingInfo extend TypeInfo {
   //static let mut allObj:Map<&TypeInfo,AutoBoxingInfo>;
   pri let mut imutType:&TypeInfo {pub,local};

   let allmut count:int{pub};

   local fn __init( processInfo:ProcessInfo ) {
      super( nil, processInfo );
      self.count = 0;
      //AutoBoxingInfo.allObj[ self ] = self;
      self.imutType = headTypeInfo;
   }


   __init {
      //AutoBoxingInfo.allObj = {};
   }

   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }
   /** 名前空間の親 */
   pub override fn get_parentInfo(): &TypeInfo {
      return headTypeInfo;
   }
   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Etc;
   }

   pub fn inc() {
      //let mut obj = unwrap AutoBoxingInfo.allObj[ self ];
      let mut obj = self;
      obj.count = obj.count + 1;
   }

   pub fn unregist() {
      //AutoBoxingInfo.allObj[ self ] = nil;
   }
}

local fn ProcessInfo.setupImut( typeInfo:TypeInfo ) mut {
   typeInfo.set_imutType( self.createModifier( typeInfo, .IMut ) );
   let mut nilable = typeInfo.$nilableTypeInfoMut;
   if nilable ~= typeInfo {
      nilable.set_imutType( self.createModifier( nilable, .IMut ) );
   }
}

pub let dummyIdInfo = new IdInfo( 1, rootProcessInfo );
pub class CanEvalCtrlTypeInfo extend TypeInfo {
   pub static let detectAlt:&CanEvalCtrlTypeInfo;
   pub static let needAutoBoxing:&CanEvalCtrlTypeInfo;
   pub static let checkTypeTarget:&CanEvalCtrlTypeInfo;

   pri fn __init() __noasync {
      super( nil, rootProcessInfo );
   }
   __init {
      CanEvalCtrlTypeInfo.detectAlt = new CanEvalCtrlTypeInfo();
      CanEvalCtrlTypeInfo.needAutoBoxing = new CanEvalCtrlTypeInfo();
      CanEvalCtrlTypeInfo.checkTypeTarget = new CanEvalCtrlTypeInfo();
   }

   

   pub override fn get_kind(): TypeInfoKind {
      return .CanEvalCtrl;
   }

   pub override fn get_typeId(): &IdInfo {
      return dummyIdInfo;
      //return -1;
   }

   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }
   pub override fn get_imutType(): &TypeInfo {
      return self;
   }
   local override fn set_imutType(typeInfo:&TypeInfo) mut {
   }
   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self;
   }
   
   
   /** 名前空間の親 */
   pub override fn get_parentInfo(): &TypeInfo {
      return headTypeInfo;
   }

   pub static fn createDefaultAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      if detectFlag {
         let mut map:Map<&TypeInfo,&TypeInfo> = {};
         map[ CanEvalCtrlTypeInfo.detectAlt ] = headTypeInfo;
         return map;
      }
      return {};
   }

   pub static fn isValidApply( alt2type:Map<&TypeInfo,&TypeInfo> ) : bool {
      return alt2type[ CanEvalCtrlTypeInfo.detectAlt ] ~= nil;
   }

   pub static fn setupNeedAutoBoxing(
      alt2type:Map<&TypeInfo,&TypeInfo>, processInfo:ProcessInfo )
   {
      let mut autoBoxingInfo = new AutoBoxingInfo( processInfo );
      processInfo.setupImut( autoBoxingInfo );
      alt2type[ CanEvalCtrlTypeInfo.needAutoBoxing ] = autoBoxingInfo;
   }

   pub static fn updateNeedAutoBoxing( alt2type:Map<&TypeInfo,&TypeInfo> ) {
      if! alt2type[ CanEvalCtrlTypeInfo.needAutoBoxing ] {
         if! let mut autoBoxingInfo = _exp@@@AutoBoxingInfo {
            autoBoxingInfo.inc();
         }
      }
      else {
         Util.err( "no exist needAutoBoxing" );
      }
   }

   pub static fn hasNeedAutoBoxing( alt2type:Map<&TypeInfo,&TypeInfo> ): bool {
      if! alt2type[ CanEvalCtrlTypeInfo.needAutoBoxing ] {
         if! let mut autoBoxingInfo = _exp@@@AutoBoxingInfo {
            return autoBoxingInfo.$count ~= 0;
         }
      }
      return false;
   }
   

   pub static fn finishNeedAutoBoxing(
      alt2type:Map<&TypeInfo,&TypeInfo>, count:int ): bool
   {
      if! alt2type[ CanEvalCtrlTypeInfo.needAutoBoxing ] {
         if! let mut autoBoxingInfo = _exp@@@AutoBoxingInfo {
            autoBoxingInfo.unregist();
            return autoBoxingInfo.$count == count;
         }
      }
      return false;
   }

   /**
dst に対して autoBoxing 可能かどうか調べる。

追加で canEvalWith() を実行して評価可能かどうか確認する必要がある。
   */
   pub static fn canAutoBoxing( dst:&TypeInfo, src:&TypeInfo ): bool
   {
      let dstSrc = dst.$srcTypeInfo.$nonnilableType;
      if dstSrc.$kind ~= .Box {
         return false;
      }
      let srcSrc = src.$srcTypeInfo.$nonnilableType;
      if srcSrc.$kind == .Box {
         return false;
      }
      return true;
   }
}

pub class NilableTypeInfo extend TypeInfo {
   pri let nonnilableType: &TypeInfo { pub };
   pri let typeId: &IdInfo { pub };
   pri let mut imutType:&TypeInfo {pub,local};

   local fn __init( processInfo:ProcessInfo, nonnilableType:&TypeInfo ) {
      super( nil, processInfo );
      self.nonnilableType = nonnilableType;
      self.typeId = processInfo.newId( self );
      self.imutType = headTypeInfo;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Nilable;
   }
   pub override fn get_aliasSrc() : &TypeInfo {
      return self;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_nilable(): bool {
      return true;
   }
   
   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.nonnilableType.getTxtWithRaw(
         raw, typeNameCtrl, importInfo, localFlag ) .. "!";
   }


   pub override fn get_display_stirng_with(
      mut raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>!  ): str
   {
      if self.nonnilableType.$kind == .FormFunc {
         return self.nonnilableType.get_display_stirng_with( raw .. "!", alt2type );
      }
      return self.nonnilableType.get_display_stirng_with( raw, alt2type ) .. "!";
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt, nil );
   }

   pub override fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      stream.write(
         '{ skind = %d, typeId = %d, orgTypeId = %s }\n' (
            SerializeKind.Nilable, self.typeId.id,
            serializeInfo.serializeId( self.nonnilableType.$typeId ) ) );
   }

   pub override fn equals( processInfo:&ProcessInfo,
                           typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      if not typeInfo.$nilable {
         return false;
      }
      return self.nonnilableType.equals(
         processInfo, typeInfo.$nonnilableType, alt2type, checkModifer );
   }

   pub override fn applyGeneric(
      processInfo:ProcessInfo,  alt2typeMap:&Map<&TypeInfo,&TypeInfo>,
      moduleTypeInfo:&TypeInfo ) : &TypeInfo!
   {
      let typeInfo = self.nonnilableType.applyGeneric(
         processInfo, alt2typeMap, moduleTypeInfo );
      if typeInfo == self.nonnilableType {
         return self;
      }
      when! typeInfo {
         return typeInfo.$nilableTypeInfo;
      }
      return nil;
   }

   advertise nonnilableType;
}


pub class AliasTypeInfo extend TypeInfo {
   pri let rawTxt: str { pub };
   pri let accessMode: AccessMode { pub };
   pri let parentInfo: &TypeInfo { pub };
   pri let aliasSrcTypeInfo: &TypeInfo { pub };
   pri let externalFlag:bool { pub };
   pri let typeId: &IdInfo { pub };
   pri let nilableTypeInfo: TypeInfo {pub&};
   pri let mut imutType:&TypeInfo {pub,local};

   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self.nilableTypeInfo;
   }
   

   local fn __init( processInfo:ProcessInfo,
                  rawTxt: str, accessMode: AccessMode, parentInfo: &TypeInfo,
                  aliasSrcTypeInfo: &TypeInfo, externalFlag:bool)
   {
      super( nil, processInfo );
      self.imutType = headTypeInfo;
      self.rawTxt = rawTxt;
      self.accessMode = accessMode;
      self.parentInfo = parentInfo;
      self.aliasSrcTypeInfo = aliasSrcTypeInfo;
      self.externalFlag = externalFlag;
      self.typeId = processInfo.newId( self );
      self.nilableTypeInfo = new NilableTypeInfo( processInfo, self );
   }

   pub override fn getParentFullName(
      typeNameCtrl:&TypeNameCtrl,
      mut importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return typeNameCtrl.getParentFullName( self, importInfo, localFlag );
   }
   
   pub override fn getFullName(
      typeNameCtrl:&TypeNameCtrl, importInfo:&ModuleInfoManager, localFlag:bool! ) : str
   {
      return self.getParentFullName(
         typeNameCtrl, importInfo, localFlag ) .. self.$rawTxt;
   }
   
   
   pub override fn get_aliasSrc() : &TypeInfo {
      return self.aliasSrcTypeInfo;
   }
   /** 非 nilable の型情報 */
   pub override fn get_nonnilableType(): &TypeInfo {
      return self;
   }
   /** Modifier の元となる型情報 */
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_genSrcTypeInfo(): &TypeInfo {
      return self;
   }
   /** この型が属しているモジュールを取得 */
   pub override fn getModule(): &TypeInfo {
      return self.$parentInfo.getModule();
   }
   
   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.rawTxt, typeNameCtrl, importInfo, localFlag );
   }

   pub override fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, rawTxt = %q, srcTypeId = %s }\n' (
            SerializeKind.Alias,
            parentId.id,
            self.typeId.id, self.rawTxt,
            serializeInfo.serializeId( self.aliasSrcTypeInfo.$typeId ) ) );
   }

   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.rawTxt, nil );
   }

   /** 親の typeId  */
   pub override fn getParentId(): &IdInfo {
      return self.parentInfo.$typeId;
   }

   pub override fn applyGeneric(
      processInfo:ProcessInfo, alt2typeMap:&Map<&TypeInfo,&TypeInfo>,
      moduleTypeInfo:&TypeInfo ) : &TypeInfo!
   {
      let typeInfo = self.aliasSrcTypeInfo.applyGeneric(
         processInfo, alt2typeMap, moduleTypeInfo );
      if typeInfo == self.aliasSrcTypeInfo {
         return self;
      }
      return nil;
   }

   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo, canEvalType:CanEvalType,
      alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return self.aliasSrcTypeInfo.canEvalWith(
         processInfo, other.$aliasSrc, canEvalType, alt2type )**;
   }

   pub override fn equals( processInfo:&ProcessInfo,
                           typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      return self.aliasSrcTypeInfo.equals(
         processInfo, typeInfo.$aliasSrc, alt2type, checkModifer );
   }


   advertise aliasSrcTypeInfo;
}


/**
列挙したシンボル情報を処理するコールバック。

@return 列挙を続ける場合は true
*/
pub form filterForm( symbolInfo:&SymbolInfo ) __trans : bool;

/**
このスコープからアクセス可能なフィールドを列挙し callback を実行する。

@param includeSelfFlag true の場合、
自分自身のスコープに登録されているシンボルを列挙対象にする。
@param fromScope アクセスを開始しているスコープ。
@param callback コールバック。
@return bool 列挙を続ける場合 true
*/
pub fn Scope.filterTypeInfoField(
   includeSelfFlag: bool!, fromScope:&Scope,
   access:ScopeAccess, callback:filterForm ):bool
{
   if self.scopeKind ~= .Other {
      if includeSelfFlag {
         forsort symbolInfo in self.symbol2SymbolInfoMap {
            if symbolInfo.canAccess( fromScope, access ) {
               if not callback( symbolInfo ) {
                  return false;
               }
            }
         }
      }
      if! let scope = self.inherit {
         if not scope.filterTypeInfoField( true, fromScope, access, callback ) {
            return false;
         }
      }
   }

   return true;
}

/**
このスコープからアクセス可能な name のフィールドを取得する。

インタフェースは含めない。
*/
pub fn Scope.getSymbolInfoField(
   name: str, includeSelfFlag: bool!,
   fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!
{
   if self.scopeKind ~= .Other {
      if includeSelfFlag {
         if! self.symbol2SymbolInfoMap[ name ] {
            let! symbolInfo = _exp.canAccess( fromScope, access ) {
               return nil;
            };
            return symbolInfo;
         }
      }
      if! let mut scope = self.inherit {
         let symbolInfo = scope.getSymbolInfoField(
            name, true, fromScope, access );
         if symbolInfo {
            return symbolInfo;
         }
      }
   }

   return nil;
}

/**
このスコープからアクセス可能な name のフィールドを取得する。

インタフェースを含む。
*/
pub fn Scope.getSymbolInfoIfField(
   name: str, fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!
{
   if self.scopeKind == .Class {
      foreach scope in self.ifScopeList {
         if! let symbolInfo =
            scope.getSymbolInfoField( name, true, fromScope, access )
         {
            return symbolInfo;
         }
      }
   }

   if! let scope = self.inherit {
      if! let symbolInfo = scope.getSymbolInfoIfField( name, fromScope, access ) {
         return symbolInfo;
      }
   }

   return nil;
}

/**
このスコープからアクセス可能なフィールドを列挙し callback を実行する。

インタフェースのみ。
*/
pub fn Scope.filterSymbolInfoIfField(
   fromScope:&Scope, access:ScopeAccess, callback:filterForm ) : bool
{
   foreach scope in self.ifScopeList {
      if not scope.filterTypeInfoField(
         true, fromScope, access, callback ) {
         return false;
      }
   }

   if! let scope = self.inherit {
      if not scope.filterSymbolInfoIfField(
         fromScope, access, callback ) {
         return false;
      }
   }

   return true;
}



pub fn Scope.getTypeInfoField(
   name: str, includeSelfFlag:bool!,
   fromScope:&Scope, access:ScopeAccess ) : &TypeInfo!
{
   let symbolInfo =
      self.getSymbolInfoField( name, includeSelfFlag, fromScope, access );
   if! symbolInfo {
      return _exp.$typeInfo;
   }
   return nil;
}


/**
このスコープからアクセス可能なフィールドを列挙し callback を実行する。

クラスと IF 両方を列挙する。

@param includeSelfFlag true の場合、
自分自身のスコープに登録されているシンボルを列挙対象にする。
@param fromScope アクセスを開始しているスコープ。
@param callback コールバック。
@return bool 列挙を続ける場合 true
*/
pub fn Scope.filterTypeInfoFieldAndIF(
   includeSelfFlag: bool!, fromScope:&Scope,
   access:ScopeAccess, callback:filterForm ):bool
{
   if self.scopeKind ~= .Other {
      if includeSelfFlag {
         forsort symbolInfo in self.symbol2SymbolInfoMap {
            if symbolInfo.canAccess( fromScope, access ) {
               if not callback( symbolInfo ) {
                  return false;
               }
            }
         }
      }
      if! let scope = self.inherit {
         if not scope.filterTypeInfoField( true, fromScope, access, callback ) {
            return false;
         }
      }
   }

   foreach scope in self.ifScopeList {
      if not scope.filterTypeInfoField(
         true, fromScope, access, callback ) {
         return false;
      }
   }

   if! let scope = self.inherit {
      if not scope.filterSymbolInfoIfField(
         fromScope, access, callback ) {
         return false;
      }
   }

   return true;
}



/**
このスコープからシンボル name の型情報を取得する。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
@param onlySameNsFlag true の場合、検索対象を同一名前空間内に限定する。
  ここで、「同一名前空間内」とは、このスコープから辿れる名前空間という意味である。
*/
pub fn Scope.getSymbolInfo(
   name: str, fromScope:&Scope,
   onlySameNsFlag:bool, access:ScopeAccess ) : &SymbolInfo!
{
   if! self.symbol2SymbolInfoMap[ name ] {
      let! symbolInfo = _exp.canAccess( fromScope, access  ) {
         return nil;
      };
      return symbolInfo;
   }
   if not onlySameNsFlag {
      if! let scope = self.inherit {
         let symbolInfo = scope.getSymbolInfoField(
            name, true, fromScope, access );
         if symbolInfo {
            return symbolInfo;
         }
      }
   }

   if not onlySameNsFlag or not self.ownerTypeInfo {
      if self.parent ~= self {
         return self.parent.getSymbolInfo(
            name, fromScope, onlySameNsFlag, access );
      } elseif self ~= rootScopeRo {
         return rootScopeRo.getSymbolInfo(
            name, fromScope, onlySameNsFlag, access );
      }
   }
   else {
      let mut workScope = self.parent;
      while workScope.parent ~= workScope {
         if workScope.ownerTypeInfo$.$kind ~= TypeInfoKind.Class and
            workScope.ownerTypeInfo$.$kind ~= TypeInfoKind.Module
         {
            return workScope.getSymbolInfo(
               name, fromScope, onlySameNsFlag, access );
         }
         workScope = workScope.parent;
      }
      if workScope ~= rootScopeRo {
         return rootScopeRo.getSymbolInfo( name, fromScope, onlySameNsFlag, access );
      }
   }
   if! sym2builtInTypeMap[ name ] {
      return _exp;
   }
   return nil;
      
   // if not onlySameNsFlag or not self.ownerTypeInfo or
   //    self.ownerTypeInfo$.$kind == TypeInfoKind.Module
   // {
   //    if self.parent ~= self {
   //       return self.parent.getSymbolInfo( name, fromScope, onlySameNsFlag, access );
   //    }
   // }
   // if onlySameNsFlag and self.ownerTypeInfo and
   //    self.ownerTypeInfo$.$kind ~= TypeInfoKind.Module
   // {
   //    return nil;
   // }
   // if! sym2builtInTypeMapWork[ name ] {
   //    return _exp;
   // }
   // return nil;
}

pub fn Scope.getTypeInfo(
   name: str, fromScope:&Scope, onlySameNsFlag:bool, access:ScopeAccess ) : &TypeInfo!
{
   let! symbolInfo = self.getSymbolInfo( name, fromScope, onlySameNsFlag, access ) {
      return nil;
   };
   return symbolInfo.$typeInfo;
}


/**
このスコープからシンボル name の型情報を取得する。
フィールドを除く name。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
*/
pub fn Scope.getSymbolTypeInfo(
   name: str, fromScope:&Scope,
   moduleScope:&Scope, access:ScopeAccess ) : &SymbolInfo!
{
   let mut validThisScope = false;
   let mut limitSymbol = false;

   if! self.ownerTypeInfo {
      if _exp.$kind == .Func or _exp.$kind == .Method or _exp.$kind == .Module or
         self == moduleScope or self == rootScopeRo
      {
         validThisScope = true;
      }
      elseif _exp.$kind == .IF or _exp.$kind == .Class
      {
         // class 系の場合、アクセスできるシンボルは self と Alternate に限定する
         limitSymbol = true;
         validThisScope = true;
      }
      elseif _exp.$kind == .Enum or _exp.$kind == .Alge {
         validThisScope = true;
      }
   }
   else {
      validThisScope = true;
   }
   if validThisScope {
      if! let symbolInfo = self.symbol2SymbolInfoMap[ name ] {
         if not limitSymbol or name == "self" or
            ( symbolInfo.$typeInfo.$kind == .Alternate and
              symbolInfo.$kind == .Typ )
         {
            return symbolInfo.canAccess( fromScope, access  );
         }
      }
   }
    if self.parent ~= self {
      return self.parent.getSymbolTypeInfo( name, fromScope, moduleScope, access );
   } elseif self ~= rootScopeRo {
      return rootScopeRo.getSymbolTypeInfo( name, fromScope, moduleScope, access );
   }
   return sym2builtInTypeMap[ name ];
}


pub fn Scope.filterSymbolTypeInfo(
   fromScope:&Scope, moduleScope:&Scope, access:ScopeAccess, callback:filterForm )
{
   if self.scopeKind == .Class {
      if! self.symbol2SymbolInfoMap[ "self" ] {
         callback( _exp );
      }
   }
   if self.scopeKind ~= .Class {
      foreach symbolInfo in self.symbol2SymbolInfoMap {
         if not callback( symbolInfo ) {
            return;
         }
      }
   }

   if self.parent ~= self {
      self.parent.filterSymbolTypeInfo( fromScope, moduleScope, access, callback );
   } elseif self ~= rootScopeRo {
      rootScopeRo.filterSymbolTypeInfo( fromScope, moduleScope, access, callback );
   }
}


pub fn Scope.add(
   processInfo:ProcessInfo,
   kind: SymbolKind, canBeLeft:bool, canBeRight:bool, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo, accessMode:AccessMode, staticFlag:bool,
   mutMode:MutMode, hasValueFlag:bool, isLazyLoad:bool ) mut : SymbolInfo!, &SymbolInfo!
{
   let mut ownerTypeInfo:&TypeInfo! = nil;
   switch kind {
      case .Typ, .Fun, .Mac {
         let existSymbol;
         switch typeInfo.$kind {
            case .Enum {
               if self.ownerTypeInfo$.$kind == .Class {
                  existSymbol = self.getSymbolInfoField( name, true, self, .Full);
               }
               else {
                  existSymbol = self.getSymbolInfo( name, self, true, .Full );
               }
            }
            case .Class, .Module {
               existSymbol = self.getSymbolInfoChild(name );
            }
            default {
               existSymbol = self.getSymbolInfo( name, self, true, .Full );
            }
         }
         when! existSymbol {
            if typeInfo.$kind ~= existSymbol.$typeInfo.$kind or
               not isBuiltin( existSymbol.$typeInfo.$typeId.id )
            {
               return nil, existSymbol;
            }
         }
      }
      case .Var {
         if typeInfo.$kind == .Module {
            ownerTypeInfo = typeInfo;
         }
      }
   }
   
   let mut symbolInfo = new NormalSymbolInfo(
      processInfo, kind, canBeLeft, canBeRight, self, accessMode, staticFlag,
      name, pos, typeInfo, mutMode, hasValueFlag, isLazyLoad );
   symbolInfo.set_namespaceTypeInfo( ownerTypeInfo );
   self.symbol2SymbolInfoMap[ name ] = symbolInfo;
   return symbolInfo, nil;
}

pub fn Scope.addSymbolInfo(
   processInfo:ProcessInfo, symbolInfo:&SymbolInfo ) mut : SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, symbolInfo.$kind,
      symbolInfo.$canBeLeft, symbolInfo.$canBeRight, symbolInfo.$name, symbolInfo.$pos,
      symbolInfo.$typeInfo, symbolInfo.$accessMode, symbolInfo.$staticFlag,
      symbolInfo.$mutMode, symbolInfo.$hasValueFlag, symbolInfo.$isLazyLoad )**;
}

pub fn Scope.addLocalVar(
   processInfo:ProcessInfo,
   argFlag:bool, canBeLeft:bool, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo, mutable:MutMode ) mut : SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, argFlag and SymbolKind.Arg or SymbolKind.Var, canBeLeft,
      name ~= "_", name, pos, typeInfo, .Local, false, mutable, true, false )**;
}

pub let dummySymbol = unwrap rootScope.addLocalVar(
   rootProcessInfo, false, false, "$$", nil, headTypeInfo, .IMut );

pub fn Scope.addUnwrapedVar(
   processInfo:ProcessInfo,
   argFlag:bool, canBeLeft:bool, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo, mutable:MutMode ) mut : SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, argFlag and SymbolKind.Arg or SymbolKind.Var,
      canBeLeft, true, name, pos, typeInfo, .Local, false, mutable, true, false )**;
}


pub fn Scope.addExportedVar(
   processInfo:ProcessInfo,
   canBeLeft:bool, accessMode:AccessMode, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo, mutable:MutMode ) mut : &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Var, canBeLeft, true, name,
      pos, typeInfo, accessMode, true, mutable, true, false )**;
}

pub fn Scope.addVar(
   processInfo:ProcessInfo,
   accessMode:AccessMode, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo, mutable:MutMode, hasValueFlag:bool ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Var, true, true, name, pos, typeInfo,
      accessMode, false, mutable, hasValueFlag, false )**;
}




pub fn Scope.addEnumVal(
   processInfo:ProcessInfo,
   name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Mbr, false, true,
      name, pos, typeInfo, .Pub, true, .Mut, true, false )**;
}

pub fn Scope.addEnum(
   processInfo:ProcessInfo,
   accessMode:AccessMode, name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Typ, false, false,
      name, pos, typeInfo, accessMode, true, .Mut, true, false )**;
}

pub fn Scope.addAlgeVal(
   processInfo:ProcessInfo,
   name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Mbr, false, true,
      name, pos, typeInfo, .Pub, true, .Mut, true, false )**;
}

pub fn Scope.addAlge(
   processInfo:ProcessInfo,
   accessMode:AccessMode, name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Typ, false, false,
      name, pos, typeInfo, accessMode, true, .Mut, true, false )**;
}

pub fn Scope.addAlternate(
   processInfo:ProcessInfo,
   accessMode:AccessMode, name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut
{
   self.add(
      processInfo, SymbolKind.Typ, false, false,
      name, pos, typeInfo, accessMode, true, .Mut, true, false );
}

pub fn Scope.addMember(
   processInfo:ProcessInfo,
   name:str, pos:&Parser.Position!, typeInfo: &TypeInfo, accessMode:AccessMode,
   staticFlag:bool, mutMode:MutMode ) mut : &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Mbr, true, true, name, pos,
      typeInfo, accessMode, staticFlag, mutMode, true, false )**;
}

pub fn Scope.addMethod(
   processInfo:ProcessInfo,
   pos:&Parser.Position!, typeInfo: &TypeInfo, accessMode:AccessMode,
   staticFlag:bool ) mut : &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Mtd, true, staticFlag, typeInfo.$rawTxt, pos, typeInfo,
      accessMode,staticFlag, typeInfo.$mutMode, true, false )**;
}

pub fn Scope.addFunc(
   processInfo:ProcessInfo,
   pos:&Parser.Position!, typeInfo: &TypeInfo,
   accessMode:AccessMode, staticFlag:bool, mutable:bool ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Fun, true, true, typeInfo.$rawTxt, pos, typeInfo,
      accessMode, staticFlag, mutable and MutMode.Mut or MutMode.IMut, true, false )**;
}

pub fn Scope.addForm(
   processInfo:ProcessInfo,
   pos:&Parser.Position!, typeInfo: &TypeInfo, accessMode:AccessMode ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, .Typ, false, false, typeInfo.$rawTxt, pos,
      typeInfo, accessMode, true, .IMut, false, false )**;
}

pub fn Scope.addMacro(
   processInfo:ProcessInfo,
   pos:&Parser.Position!, typeInfo: &TypeInfo, accessMode:AccessMode ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Mac, false, false, typeInfo.$rawTxt, pos,
      typeInfo, accessMode, true, .IMut, true, false )**;
}


pub fn Scope.addClassLazy(
   processInfo:ProcessInfo, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo, lazyLoad:bool ) mut : &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      processInfo, SymbolKind.Typ, false, false, name, pos, typeInfo,
      typeInfo.$accessMode, true, .Mut, true, lazyLoad )**;
}

pub fn Scope.addClass(
   processInfo:ProcessInfo, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo ) mut : &SymbolInfo!, &SymbolInfo!
{
   return self.addClassLazy( processInfo, name, pos, typeInfo, false )**;
}

pub fn Scope.addExtModule(
   processInfo:ProcessInfo, name:str, pos:&Parser.Position!, mut typeInfo: &TypeInfo,
   lazy:bool, lang:Types.Lang ) mut : &SymbolInfo!, &SymbolInfo!
{
   if lang ~= .Same {
      _match processInfo.createLuaval( typeInfo, true ) {
         case .Err( mess ) {
            Util.err( mess );
         }
         case .OK( luavalTypeInfo, _ ) {
            typeInfo = luavalTypeInfo;
         }
      }
   }
   return self.add(
      processInfo, .Typ, false, false, name, pos, typeInfo,
      typeInfo.$accessMode, false, .Mut, true, lazy )**;
}

pub fn dumpOuterScope( workScope: &Scope, toScope:&Scope, prefix:str ) {
   workScope.filterSymbolTypeInfo(
      workScope, toScope, .Normal,
      fn ( symbolInfo:&SymbolInfo ): bool {
         Util.log( "scope: %s, %s" ( prefix, symbolInfo.$name ) );
         return true;
      }
   );
}

/**
デバッグ用。 scope 内のシンボル情報を出力する。
*/
pub fn dumpScope( workscope: &Scope!, workprefix:str ) {

   /**
デバッグ用。 scope 内のシンボル情報を出力する。
*/
   fn dumpScopeSub( scope: &Scope!, prefix:str, readyIdSet:Set<&Scope> ) {
      if! scope {
         if readyIdSet.has( _exp ) {
            return;
         }
         readyIdSet.add( _exp );
         if #prefix > 20 {
            Util.err("illegal");
         }

         forsort symbolInfo, symbol in _exp.$symbol2SymbolInfoMap {
            Util.log( "scope: %s, %s, %s" ( prefix, _exp, symbol ) );
            if! let subScope = symbolInfo.$typeInfo.$scope {
               dumpScopeSub( subScope, prefix .. "  ", readyIdSet );
            }
         }
      };
   }

   dumpScopeSub( workscope, workprefix, (@) );
}

/**
スコープを遡って、クロージャのシンボルを登録する。

事前に isClosureAccess() で、 symbol がクロージャであることを判定しておく必要がある。
*/
pub fn Scope.setClosure( workSymbol:&SymbolInfo ) mut {
   fn getFuncScope( mut scope:Scope ) : Scope {
      repeat {
         if! scope.$ownerTypeInfo {
            if _exp.$kind == .Func {
               return scope;
            }
         }
         scope = scope.$outerScope;
      } scope.isRoot();
      return scope;
   }


   let symbol = workSymbol.getOrg();
   let targetFuncScope = unwrap symbol.$namespaceTypeInfo.$scope;
   let mut funcScope = getFuncScope( self );
   
   while not funcScope.isRoot() {
      if not funcScope.closureInfo.setClosure( symbol ) {
         break;
      }
      funcScope = getFuncScope( funcScope.outerScope );
      if funcScope == targetFuncScope {
         break;
      }
   }
   if not symbol.$hasAccessFromClosure {
      symbol.set_hasAccessFromClosure( true );
   }
}

/**
@param moduleScope このモジュールの最上位スコープ
@param symbol シンボル
*/
pub fn Scope.isClosureAccess(
   moduleScope:&Scope, symbol:&SymbolInfo) : bool
{
   let processInfo = moduleScope.getModule().$processInfo;
   switch symbol.$kind {
      case .Var, .Arg, .Fun {
         if symbol.$scope == moduleScope or symbol.$scope == rootScopeRo {
            // symbol が、最上位スコープで定義されているなら、
            // 大域変数なのでクロージャではない
         }
         elseif symbol.$name == "self" {
            let funcType = self.getNamespaceTypeInfo();
            if funcType.$parentInfo.isInheritFrom(
               processInfo, symbol.$namespaceTypeInfo.$parentInfo ## )
            {
               // self の場合、メソッド内からのアクセスはクロージャではない
            }
            else {
               return true;
            }
         }
         else {
            // このシンボルアクセスが、クロージャかどうかを確認する。
            // symbol の定義位置が異なる名前空間の場合、クロージャとして判定する。
            let funcType = self.getNamespaceTypeInfo();
            if funcType ~= symbol.$namespaceTypeInfo {
               // クロージャならシンボル情報を登録する。
               return true;
            }
         }
      }
   }
   return false;
}


/**
@param moduleScope このモジュールの最上位スコープ
@param symbol シンボル
*/
pub fn Scope.accessSymbol(
   moduleScope:&Scope, symbol:&SymbolInfo ) mut
{
   if symbol.$kind == .Fun and self.getNamespaceTypeInfo() == symbol.$typeInfo {
      // 関数の body 内で、自分自身の関数シンボルにアクセスしている場合は、
      // クロージャにはならないので処理しない。
      return;
   }
   
   if self.isClosureAccess( moduleScope, symbol ) {
      self.setClosure( symbol );
   }
}




/**

*/
pub fn TypeInfo.createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
   return CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( detectFlag );
}


pub class NilTypeInfo extend TypeInfo {
   pri let typeId:&IdInfo {pub};

   pub override fn get_imutType(): &TypeInfo {
      return self;
   }
   local override fn set_imutType(typeInfo:&TypeInfo) mut {
   }
   
   local fn __init( processInfo:ProcessInfo ) {
      super( nil, processInfo );

      self.typeId = processInfo.newId( self );
   }

   /** この型がモジュールを示す型の場合 true  */
   pub override fn isModule(): bool {
      return false;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "nil";
   }


   /** other 型からこの型への canEvalType の評価が可能かどうか */
   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo, canEvalType:CanEvalType,
      alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      if not other.$nilable {
         return false, "%s is not nilable." (other.getTxt(##));
      }
      return other.$nilable, nil;
   }

   /** 表示用文字列取得 */
   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( "nil", nil );
   }


   /** この型と typeInfo が等しいかどうか */
   pub override fn equals( processInfo:&ProcessInfo,
                           typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      return self == typeInfo;
   }

   /** 名前空間の親 */
   pub override fn get_parentInfo(): &TypeInfo {
      return headTypeInfo;
   }

   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報が宣言されているか？
   */
   pub override fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      return true;
   }

   /** シンプルな型名 */
   pub override fn get_rawTxt(): str {
      return "nil";
   }
   /** 型の種別 */
   pub override fn get_kind(): TypeInfoKind {
      return .Prim;
   }
   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }
   /** nilable かどうか */
   pub override fn get_nilable(): bool {
      return true;
   }
   /** mutable かどうか */
   pub override fn get_mutMode(): MutMode {
      return .IMut;
   }
   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self;
   }

   /** 親の完全限定名を取得する */
   pub override fn getParentFullName(
      typeNameCtrl:&TypeNameCtrl, 
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "";
   }
}


pub fn Scope.getClassTypeInfo(): &TypeInfo {
   let mut scope = self;
   while true {
      if! let owner = scope.ownerTypeInfo {
         switch owner.$kind {
            case .Class, .IF, .Module {
               return owner;
            }
         }
      }
      if scope.parent == scope {
         break;
      }
      scope = scope.parent;
   }
   return headTypeInfo;
}


/**
このシンボルが、fromScope のスコープからアクセスできるか調べる。
 */
pub override fn NormalSymbolInfo.canAccess(
   fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!
{
   if access == .Full {
      return self;
   }

   //let typeInfo = self.$typeInfo;
   if self.scope == fromScope {
      return self;
   }

   let mut processInfo = fromScope.getProcessInfo();
   
   _switch self.$accessMode {
      case .Pub, .Global {
         return self;
      }
      case .Pro {
         let nsClass = self.scope.getClassTypeInfo();
         let fromClass = fromScope.getClassTypeInfo();
         if fromClass.isInheritFrom( processInfo, nsClass, nil ) {
            return self;
         }
         return nil;
      }
      case .Local {
         // if isBuiltin( self.$typeInfo.$typeId.id ) or 
         //    self.getModule().equals( processInfo, fromScope.getModule() ## )
         let selfMod = self.getModule();
         if not TypeInfo.hasParent( selfMod ) or
            selfMod.equals( processInfo, fromScope.getModule() ## )
         {
            return self;
         }
         return nil;
      }
      case .Pri {
         // let nsClass = self.scope.getClassTypeInfo();
         // let fromClass = fromScope.getClassTypeInfo();
         // if nsClass == fromClass {
         //    return self;
         // }
         // return nil;
         if fromScope.isInnerOf( self.scope ) {
            return self;
         }
         return nil;
      }
      case .None {
         Util.err( "illegl accessmode -- %s, %s"
                   (self.$accessMode, self.$name) );
      }
   }
}

pub alge OverrideMut {
   None,
   Prefix( &TypeInfo ),
   IMut( &TypeInfo ),
}


pub class AccessSymbolInfo extend SymbolInfo {
   pri let symbolInfo: &SymbolInfo {pub};
   pri let overrideMut:OverrideMut;
   pri let overrideCanBeLeft: bool;
   pri let overrideTypeInfo:&TypeInfo;

   pub fn __init(
      processInfo:ProcessInfo, symbolInfo: &SymbolInfo,
      overrideMut:OverrideMut, overrideCanBeLeft: bool ) 
   {
      super();
      self.symbolInfo = symbolInfo;
      self.overrideMut = overrideMut;
      self.overrideCanBeLeft = overrideCanBeLeft;
      let symType = symbolInfo.$typeInfo;
      let work;
      _match self.overrideMut {
         case .None {
            work = symType;
         }
         case .Prefix( prefixTypeInfo ) {
            if self.symbolInfo.$kind == .Mbr and
               symType.$kind == .Alternate and
               prefixTypeInfo.$kind == .Class and
               #prefixTypeInfo.$itemTypeInfoList > 0
            {
               let mut alt2TypeMap = prefixTypeInfo.createAlt2typeMap( false );
               let typeInfo = symType.applyGeneric(
                  processInfo, alt2TypeMap, symType.getModule() );
               when! typeInfo {
                  work = typeInfo;
               } else {
                  work = symType;
               }
            }
            else {
               work = symType;
            }
         }
         case .IMut( typeInfo ) {
            work = typeInfo;
         }
      }
      self.overrideTypeInfo = work;
   }


   pub override fn getOrg(): &SymbolInfo {
      return self.symbolInfo.getOrg();
   }

   pub override fn canAccess( fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!
   {
      if self.symbolInfo.canAccess( fromScope, access ) {
         return self;
      }
      return nil;
   }
   

   pub override fn get_typeInfo() : &TypeInfo {
      return self.overrideTypeInfo;
   }
   
   pub override fn get_mutMode(): MutMode {
      _match self.overrideMut {
         case .None {
            // 
         }
         case .Prefix( prefixTypeInfo ) {
            _switch self.symbolInfo.$mutMode {
               case .Depend {
                  return prefixTypeInfo.$mutMode;
               }
               case .AllMut, .IMut, .IMutRe {
                  return self.symbolInfo.$mutMode;
               }
               case .Mut {
                  _switch prefixTypeInfo.$mutMode {
                     case .AllMut {
                        return .Mut;
                     }
                     case .Mut, .IMut, .IMutRe, .Depend {
                        return prefixTypeInfo.$mutMode;
                     }
                  }
               }
            }
         }
         case .IMut( _ ) {
            return .IMut;
         }
      }
      return self.symbolInfo.$mutMode;
   }
   
   pub override fn get_mutable(): bool {
      return isMutable( self.get_mutMode() );
   };

   pub override fn get_canBeLeft(): bool {
      if not self.overrideCanBeLeft {
         return false;
      }
      return self.symbolInfo.$canBeLeft;
   }

   advertise symbolInfo;
}

pub class AnonymousSymbolInfo extend SymbolInfo {
   let symbolInfo:&SymbolInfo;
   let anonymousId:int {pub};

   advertise symbolInfo;

   pub fn __init( symbolInfo: &SymbolInfo, id:int ) 
   {
      super();
      self.symbolInfo = symbolInfo;
      self.anonymousId = id;
   }
}


/**
Generic クラスや関数で利用する代用型。

Set<T> の T を表わす型情報。
*/
pub class AlternateTypeInfo extend TypeInfo {
   pri let typeId:&IdInfo {pub};
   pri let txt:str {pub};
   pri let allmut parentInfo:&TypeInfo {non};
   pri let nilableTypeInfo: NilableTypeInfo {pub:&TypeInfo};
   pri let accessMode: AccessMode {pub};
   // 基底クラス。 無効な場合は headTypeInfo。
   pri let baseTypeInfo: &TypeInfo { pub };
   // インタフェースのリスト。
   pri let interfaceList: &List<&TypeInfo> { pub };

   /** クラスの型パラメータとして使う場合 true */
   pri let belongClassFlag: bool;
   /** 何番目の型パラメータか */
   pri let altIndex:int {pub};
   pri let mut imutType:&TypeInfo {pub,local};

   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self.nilableTypeInfo;
   }


   local fn __init(
      processInfo:ProcessInfo, scope:Scope, belongClassFlag:bool, altIndex:int,
      txt:str, accessMode:AccessMode, parentInfo:&TypeInfo,
      baseTypeInfo: &TypeInfo!, interfaceList: &List<&TypeInfo>! ) 
   {
      super( scope, processInfo );

      // processInfo.$idProv.increment();
      // self.typeId = processInfo.$idProv.$id;
      self.typeId = processInfo.newId( self );

      self.txt = txt;
      self.accessMode = accessMode;
      self.parentInfo = parentInfo;
      self.baseTypeInfo = unwrap baseTypeInfo default headTypeInfo;
      self.interfaceList = unwrap interfaceList default [];
      self.belongClassFlag = belongClassFlag;
      self.altIndex = altIndex;

      //processInfo.$idProv.increment();
      self.nilableTypeInfo = new NilableTypeInfo( processInfo, self );
      self.imutType = headTypeInfo;
   }

   local static fn create(
      processInfo:ProcessInfo, belongClassFlag:bool, altIndex:int,
      txt:str, accessMode:AccessMode, parentInfo:&TypeInfo, baseTypeInfo: &TypeInfo!,
      interfaceList: &List<&TypeInfo>! ) : AlternateTypeInfo, Scope
   {
      let mut scope = TypeInfo.createScope(
         processInfo, nil, .Class, baseTypeInfo, interfaceList );
      let mut newType = new AlternateTypeInfo(
         processInfo, scope, belongClassFlag, altIndex,
         txt, accessMode, parentInfo, baseTypeInfo, interfaceList );
      processInfo.setupImut( newType );
      
      return newType, scope;
   }

   local fn updateParentInfo( typeInfo:&TypeInfo ) {
      self.parentInfo = typeInfo;
   }

   /** この型がモジュールを示す型の場合 true  */
   pub override fn isModule(): bool {
      return false;
   }

   /** 親の typeId  */
   pub override fn getParentId(): &IdInfo {
      return self.parentInfo.$typeId;
   }

   pub override fn get_baseId(): &IdInfo {
      return self.baseTypeInfo.$typeId;
   }

   pub override fn get_parentInfo(): &TypeInfo {
      return self.parentInfo;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.txt;
   }

   pub static fn getAssign(
      typeInfo:&TypeInfo, alt2type:&Map<&TypeInfo,&TypeInfo> ) : &TypeInfo;
   

   pri fn canSetFrom(
      processInfo:&ProcessInfo, other:&TypeInfo,
      canEvalType:CanEvalType!, alt2type:Map<&TypeInfo,&TypeInfo> ): bool;

   /** この型が other を継承しているかどうか */
   pub override fn isInheritFrom(
      processInfo:&ProcessInfo, 
      other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool
   {
      let mut workAlt2type:Map<&TypeInfo,&TypeInfo>!;
      when! alt2type {
         let otherWork = AlternateTypeInfo.getAssign( other, alt2type );
         if self == otherWork.$srcTypeInfo {
            return true;
         }

         if! let genType = alt2type[ self ] {
            return genType.isInheritFrom( processInfo, otherWork, alt2type );
         }
         if not CanEvalCtrlTypeInfo.isValidApply( alt2type ) {
            workAlt2type = nil;
         } else {
            workAlt2type = alt2type;
         }
      } else {
         workAlt2type = nil;
      }
      if self == other.$srcTypeInfo {
         return true;
      }

      fn check() __trans : bool {
         if self.hasBase() {
            if self.baseTypeInfo.isInheritFrom( processInfo, other, workAlt2type ) {
               return true;
            }
         };
         foreach ifType in self.interfaceList {
            if ifType.isInheritFrom( processInfo, other, workAlt2type ) {
               return true;
            }
         }
         return false;
      }

      if check() {
         when! workAlt2type {
            workAlt2type[ self ] = other;
         }
         return true;
      }
      return false;
   }


   /** other 型からこの型への canEvalType の評価が可能かどうか */
   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      if self == other.$srcTypeInfo {
         return true, nil;
      }
      if other.$nilable {
         return false, "is doesn't support nilable.";
      }
      if not self.belongClassFlag {
         if! let altType = other@@@AlternateTypeInfo {
            if not altType.belongClassFlag and
               altType.altIndex == self.altIndex
            {
               // 関数の型パラメータは、インデックスが同じならば同じものとする
               return true, nil;
            }
         }
      }

      //let mut otherWork = unwrap other.applyGeneric( alt2type ) default other;
      return self.canSetFrom( processInfo, other, canEvalType, alt2type ), nil;
   }

   /** 表示用文字列取得 */
   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str
   {
      when! alt2type {
         if! let genType = alt2type[ self ] {
            return genType.get_display_stirng_with( genType.$rawTxt, alt2type );
         }
      }
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.txt, nil );
   }


   /** この型と typeInfo が等しいかどうか */
   pub override fn equals(
      processInfo:&ProcessInfo, typeInfo: &TypeInfo,
      alt2type:Map<&TypeInfo,&TypeInfo>!, checkModifer:bool! ): bool
   {
      if self == typeInfo {
         return true;
      }
      if not self.belongClassFlag {
         if! let altType = typeInfo@@@AlternateTypeInfo {
            if not altType.belongClassFlag and
               altType.altIndex == self.altIndex
            {
               // 関数の型パラメータは、インデックスが同じならば同じものとする
               return true;
            }
         }
      }

      when! alt2type {
         return self.canSetFrom( processInfo, typeInfo, nil, alt2type );
      }
      return false;
   }

   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報が宣言されているか？
   */
   pub override fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      return true;
   }

   /** シンプルな型名 */
   pub override fn get_rawTxt(): str {
      return self.txt;
   }
   /** 型の種別 */
   pub override fn get_kind(): TypeInfoKind {
      return .Alternate;
   }
   /** nilable かどうか */
   pub override fn get_nilable(): bool {
      return false;
   }
   /** mutable かどうか */
   pub override fn get_mutMode(): MutMode {
      return .Mut;
   }

   // /** 親の完全限定名を取得する */
   // pub override fn getParentFullName(
   //    typeNameCtrl:&TypeNameCtrl, 
   //    importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   // {
   //    return "";
   // }

   pub override fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, txt = %q, '
         ( SerializeKind.Alternate,
           parentId.id, self.typeId.id, self.txt ) ..
         'accessMode = %d, baseId = %s, '
         ( self.accessMode, serializeInfo.serializeId( self.$baseId ) ) ..
         'belongClassFlag = %s, altIndex = %d, ' (self.belongClassFlag, self.altIndex ));

      stream.write( self.serializeTypeInfoList(
         serializeInfo, "ifList = {", self.interfaceList## ) );
      stream.write( "}\n" );
   }

   pub override fn applyGeneric(
      processInfo:ProcessInfo, alt2typeMap:&Map<&TypeInfo,&TypeInfo>,
      moduleTypeInfo:&TypeInfo ): &TypeInfo!
   {
      return AlternateTypeInfo.getAssign( self, alt2typeMap );
   }
}

let boxRootAltType:&TypeInfo;
boxRootAltType = AlternateTypeInfo.create(
   rootProcessInfo, true, 1, "_T", .Pub, headTypeInfo ## );

pub class BoxTypeInfo extend TypeInfo {
   pri let boxingType: &TypeInfo {pub};
   pri let typeId: &IdInfo { pub };
   pri let itemTypeInfoList: &List<&TypeInfo> {pub};
   pri let accessMode: AccessMode {pub};
   pri let nilableTypeInfo: NilableTypeInfo {pub:&TypeInfo};
   pri let mut imutType:&TypeInfo {pub,local};

   local fn __init( processInfo:ProcessInfo, scope:Scope!,
                    accessMode:AccessMode, boxingType: &TypeInfo )
   {
      super( scope, processInfo );
      self.boxingType = boxingType;
      self.typeId = processInfo.newId( self );
      self.itemTypeInfoList = [ boxingType ];
      self.accessMode = accessMode;

      //processInfo.$idProv.increment();
      self.nilableTypeInfo = new NilableTypeInfo( processInfo, self );
      self.imutType = headTypeInfo;
   }

   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self.nilableTypeInfo;
   }

   pub override fn get_scope(): &Scope! {
      return super();
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Box;
   }
   pub override fn get_aliasSrc() : &TypeInfo {
      return self;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_nonnilableType(): &TypeInfo {
      return self;
   }
   pub override fn get_nilable(): bool {
      return false;
   }
   pub override fn get_extedType(): &TypeInfo {
      return self;
   }
   

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "Nilable<" .. self.boxingType.getTxtWithRaw(
         raw, typeNameCtrl, importInfo, localFlag ) .. ">";
   }

   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt, nil );
   }

   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str {
      return "Nilable<%s>" (self.boxingType.get_display_stirng_with( raw, alt2type ) );
   }

   pub override fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      stream.write(
         '{ skind = %d, typeId = %d, accessMode = %d, boxingType = %d }\n' (
            SerializeKind.Box, self.typeId.id,
            self.accessMode, self.boxingType.$typeId.id ) );
   }

   pub override fn equals(
      processInfo:&ProcessInfo, typeInfo: &TypeInfo,
      alt2type:Map<&TypeInfo,&TypeInfo>!, checkModifer:bool! ): bool
   {
      if! let boxType = typeInfo@@@BoxTypeInfo {
         return self.boxingType.equals(
            processInfo, boxType.boxingType, alt2type , checkModifer );
      }
      return false;
   }

   pub override fn createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      let mut map:Map<&TypeInfo,&TypeInfo> =
         CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( detectFlag );
      if self.boxingType ~= boxRootAltType {
         map[ boxRootAltType ] = self.boxingType;
      }
      return map;
   }

   advertise boxingType;
}


/**
Generic クラスの型確定後の型情報。

Set<T> の Set<int> を表わす型情報。
*/
pub class GenericTypeInfo extend TypeInfo {
   pri let typeId:&IdInfo {pub};
   pri let itemTypeInfoList:&List<&TypeInfo> {pub};
   pri let nilableTypeInfo: NilableTypeInfo {pub:&TypeInfo};
   pri let genSrcTypeInfo:&TypeInfo {pub};
   pri let moduleTypeInfo:&TypeInfo;
   pri let alt2typeMap:&Map<&TypeInfo,&TypeInfo>;
   pri let hasAlter:bool;
   pri let mut imutType:&TypeInfo {pub,local};


   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self.nilableTypeInfo;
   }

   
   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str
   {
      return self.genSrcTypeInfo.get_display_stirng_with( raw, self.alt2typeMap );
   }

   pri fn __init(
      processInfo:ProcessInfo, scope:Scope,
      genSrcTypeInfo:&TypeInfo,
      itemTypeInfoList:&List<&TypeInfo>, moduleTypeInfo:&TypeInfo ) 
   {
      super( scope, processInfo );

      //processInfo.$idProv.increment();
      self.imutType = headTypeInfo;
      self.typeId = processInfo.newId( self );
      self.moduleTypeInfo = moduleTypeInfo;

      self.itemTypeInfoList = itemTypeInfoList;
      self.genSrcTypeInfo = genSrcTypeInfo;

      if #genSrcTypeInfo.$itemTypeInfoList ~= #itemTypeInfoList {
         Util.err( "unmatch generic type number -- %d, %d"
                   (#genSrcTypeInfo.$itemTypeInfoList, #itemTypeInfoList) );
      }
      let mut alt2typeMap:Map<&TypeInfo,&TypeInfo> = {};
      let mut workAlt2typeMap = CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
      let mut hasAlter = false;
      foreach altTypeInfo, index in genSrcTypeInfo.$itemTypeInfoList {
         let itemType = itemTypeInfoList[ index ];
         alt2typeMap[ altTypeInfo ] = itemType;
         if itemType.applyGeneric(
            processInfo, workAlt2typeMap, moduleTypeInfo ) ~= itemType
         {
            hasAlter = true;
         }
      }
      self.hasAlter = hasAlter;
      self.alt2typeMap = alt2typeMap;

      //processInfo.$idProv.increment();
      self.nilableTypeInfo = new NilableTypeInfo( processInfo, self );
   }

   local static fn create(
      processInfo:ProcessInfo, genSrcTypeInfo:&TypeInfo,
      itemTypeInfoList:&List<&TypeInfo>,
      moduleTypeInfo:&TypeInfo ) : GenericTypeInfo, Scope
   {
      let mut scope = TypeInfo.createScope(
         processInfo, nil, .Class, genSrcTypeInfo, nil );
      let mut newType = new GenericTypeInfo(
         processInfo, scope, genSrcTypeInfo, itemTypeInfoList, moduleTypeInfo );
      processInfo.setupImut( newType );
      
      return newType, scope;
   }

   pub override fn getModule(): &TypeInfo {
      return self.moduleTypeInfo;
   }

   /** この型が other を継承しているかどうか */
   pub override fn isInheritFrom(
      processInfo:&ProcessInfo,
      other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool
   {
      let otherSrc = other.$genSrcTypeInfo;

      if not self.genSrcTypeInfo.isInheritFrom( processInfo, otherSrc, alt2type ) {
         // Generic 元が継承していない場合は、この Generic クラスも継承していない
         return false;
      }
      // Generic 元が継承している

      // other は Generic
      let! genOther = other@@@GenericTypeInfo {
         // other は Generic でないので、この時点で確定
         return true;
      };
      let! mut workAlt2type = alt2type {
         workAlt2type = CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
      };
      foreach altType in otherSrc.$itemTypeInfoList {
         // otherSrc の altType に対応する Generic の型を取得し、
         // それの派生状態を確認。
         let! genType = self.alt2typeMap[ altType ] {
            return false;
         };
         let otherGenType = unwrap genOther.alt2typeMap[ altType ];
         // if not genType.isInheritFrom( otherGenType, alt2type ) {
         //    return false;
         // }


         // ここの .SetOp と .SetEq を制御する
         if not otherGenType.canEvalWith( processInfo, genType, .SetEq, workAlt2type ) {
            return false;
         }
      }
      return true;
   }

   pub override fn get_aliasSrc() : &TypeInfo {
      return self;
   }
   /** Modifier の元となる型情報 */
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_extedType(): &TypeInfo {
      return self;
   }

   /** other 型からこの型への canEvalType の評価が可能かどうか */
   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      if other.$nilable {
         return false, "GenericTypeInfo doesn't support nilable.";
      }
      
      if TypeInfo.isMut( self ) and not TypeInfo.isMut( other ) {
         return false, nil;
      }

      let otherSrc = other.$srcTypeInfo;
      if self == otherSrc {
         return true, nil;
      }

      // other のスーパークラスを辿って、一致するか調べる
      let mut work = otherSrc;
      while true {
         if work == headTypeInfo {
            return false, nil;
         }
         foreach genType, altType in work.createAlt2typeMap( false ) {
            alt2type[ altType ] = genType;
         }
         if self.genSrcTypeInfo.equals( processInfo, work.$genSrcTypeInfo, alt2type ## ) {
            break;
         }
         foreach ifType in work.$interfaceList {
            if self.canEvalWith( processInfo, ifType, canEvalType, alt2type ) {
               return true, nil;
            }
         }
         work = work.$baseTypeInfo;
      }

      // 一致する場合、汎化の型も同じか調べる
      if! let otherGen = work@@@GenericTypeInfo {

         let evalType;
         if canEvalType == .SetOp {
            evalType = CanEvalType.SetEq;
         }
         else {
            evalType = canEvalType;
         }
         
         foreach val, key in self.alt2typeMap {
            let otherType = AlternateTypeInfo.getAssign(
               unwrap otherGen.alt2typeMap[ key ], alt2type );
            let ret, mess = val.canEvalWith( processInfo, otherType, evalType, alt2type );
            if not ret {
               return false, mess;
            }
         }
      }
      return true, nil;
   }

   /** この型と typeInfo が等しいかどうか */
   pub override fn equals(
      processInfo:&ProcessInfo, other: &TypeInfo,
      alt2type:Map<&TypeInfo,&TypeInfo>!, checkModifer:bool! ): bool
   {
      if self == other {
         return true;
      }
      if self.$kind ~= self.$kind or
         #self.itemTypeInfoList ~= #other.$itemTypeInfoList
      {
         return false;
      }
      if not (other@@@GenericTypeInfo) {
         return false;
      }
      // if not isGenericType( other ) {
      //    return false;
      // }

      if not self.genSrcTypeInfo.equals(
         processInfo, other.$genSrcTypeInfo, alt2type, checkModifer ) {
         return false;
      }

      foreach otherItem, index in other.$itemTypeInfoList {
         let typeInfo = self.itemTypeInfoList[ index ];
         if not typeInfo.equals( processInfo, otherItem, alt2type, checkModifer ) {
            return false;
         }
      }
      return true;
   }

   pub override fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      stream.write(
         '{ skind = %d, typeId = %d, genSrcTypeId = %s, genTypeList = {' (
            SerializeKind.Generic, self.typeId.id,
            serializeInfo.serializeId( self.genSrcTypeInfo.$typeId ) ) );
      let count = 0;
      foreach genType in self.alt2typeMap {
         if count > 0 {
            stream.write( "," );
         }
         stream.write( serializeInfo.serializeId( genType.$typeId ) );
      }
      stream.write( '} }\n' );
   }

   pub override fn createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      let mut map = self.genSrcTypeInfo.createAlt2typeMap( detectFlag );
      foreach typeInfo, genType in self.alt2typeMap {
         map[ genType ] = typeInfo;
      }
      return map;
   }

   advertise genSrcTypeInfo;
}


pub fn isGenericType( typeInfo: &TypeInfo ) : bool {
   if typeInfo@@@GenericTypeInfo {
      return true;
   }
   return false;
}


pub class ModuleTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: &IdInfo { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   //
   pri let mutable: bool {pub};
   pri let fullName: str;

   pub override fn get_asyncMode() : Async {
      return .Noasync;
   }
   
   pub override fn get_imutType(): &TypeInfo {
      return self;
   }
   local override fn set_imutType(typeInfo:&TypeInfo) mut {
   }

   local fn __init(
      processInfo:ProcessInfo, scope: Scope, externalFlag: bool, txt: str,
      parentInfo: &TypeInfo, mutable:bool,
      typeDataAccessor: TypeDataAccessor )
   {
      super( scope, processInfo );

      self.externalFlag = externalFlag;
      self.rawTxt = txt;
      self.parentInfo = parentInfo;
      self.typeId = processInfo.newId( self );
      self.mutable = mutable;

      typeDataAccessor.$typeData.addChildren( self );
         
      let parentFull = parentInfo.getParentFullName( defaultTypeNameCtrl ## );
      let fullName = "%s.@%s" ( parentFull,txt );
      self.fullName = fullName;

      //processInfo.$idProv.increment();


      scope.set_ownerTypeInfo( self );
   }

   pub override fn equals(
      processInfo:&ProcessInfo, typeInfo: &TypeInfo,
      alt2type:Map<&TypeInfo,&TypeInfo>!, checkModifer:bool! ): bool
   {
      let! other = typeInfo@@@ModuleTypeInfo {
         return false;
      };
      return self.fullName == other.fullName;
   }

   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }

   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self;
   }
   
   pub override fn isModule(): bool {
      return true;
   }

   pub override fn get_accessMode(): AccessMode {
      return AccessMode.Pub;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Module;
   }

   pub override fn getParentId(): &IdInfo {
      return self.parentInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return rawTxt;
   }

   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt, nil );
   }
   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return false, nil;
   }

   pub override fn serialize(
      stream: oStream, serializeInfo: &SerializeInfo ) 
   {
      let txt = "{ skind = %d, parentId = %d, typeId = %d, txt = '%s', "
          ( SerializeKind.Module,
            self.getParentId().id,
            self.typeId.id, self.rawTxt );
      stream.write( txt .. '\n' );
      stream.write( "}\n" );
   }
}

pub alge EnumLiteral {
   Int( val:int ),
   Real( val:real ),
   Str( val:str ),
}
pub fn getEnumLiteralVal( obj:EnumLiteral ) : stem {
   _match obj {
      case .Int( val ) {
         return val;
      }
      case .Real( val ) {
         return val;
      }
      case .Str( val ) {
         return val;
      }
   }
}


pub class EnumValInfo {
   pri let name: str {pub};
   pri let val:EnumLiteral {pub};
   pri let symbolInfo: &SymbolInfo {pub};
}

pub class EnumTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: &IdInfo { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   pri let nilableTypeInfo: TypeInfo { pub& };

   // この enum で格納している値の型
   pri let valTypeInfo: &TypeInfo {pub};


   // enum 値名 -> EnumValInfo
   pri let mut name2EnumValInfo: Map<str,&EnumValInfo> { pub& };
   pri let mut val2EnumValInfo: Map<&stem,&EnumValInfo> { pub& };

   pub override fn get_imutType(): &TypeInfo {
      return self;
   }
   local override fn set_imutType(typeInfo:&TypeInfo) mut {
   }
   
   local fn __init( processInfo:ProcessInfo, scope: Scope, externalFlag:
                    bool, accessMode: AccessMode, txt: str, parentInfo: &TypeInfo!,
                    typeDataAccessor: TypeDataAccessor!, valTypeInfo:&TypeInfo ) 
   {
      super( scope, processInfo );

      self.externalFlag = externalFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default processInfo.$dummyParentType;
      self.typeId = processInfo.newId( self );
      self.name2EnumValInfo = {};
      self.valTypeInfo = valTypeInfo;

      self.val2EnumValInfo = {};


      when! typeDataAccessor {
         typeDataAccessor.$typeData.addChildren( self );
      }
      
      // if! parentInfo {
      //    _exp.addChildren( self );
      // }

      self.nilableTypeInfo = new NilableTypeInfo( processInfo, self );

      scope.set_ownerTypeInfo( self );
   }

   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self.nilableTypeInfo;
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Enum;
   }

   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }
   pub override fn getParentId(): &IdInfo {
      return self.parentInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return rawTxt;
   }

   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>!  ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt, nil );
   }

   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      if self == other.$srcTypeInfo.$aliasSrc {
         return true, nil;
      }
      return false, "%d != %d" (self.$typeId.id,
                                 other.$srcTypeInfo.$aliasSrc.$typeId.id );
   }

   pub fn addEnumValInfo( valInfo:&EnumValInfo ) mut {
      self.name2EnumValInfo[ valInfo.$name ] = valInfo;
      self.val2EnumValInfo[ getEnumLiteralVal( valInfo.$val ) ] = valInfo;
   }

   pub fn getEnumValInfo( name:str ): &EnumValInfo! {
      return self.name2EnumValInfo[ name ];
   }

   pub override fn get_mutMode(): MutMode {
      return .Mut;
   };
}



pub proto class AlgeValInfo;

pub class AlgeTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: &IdInfo { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   pri let nilableTypeInfo: TypeInfo { pub& };

   pri let mut valInfoMap:Map<str,&AlgeValInfo> {pub};
   pri let mut valInfoNum:int {pub};
   pri let mut imutType:&TypeInfo {pub,local};

   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }
   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self.nilableTypeInfo;
   }
   

   local fn __init(
      processInfo:ProcessInfo, scope: Scope, externalFlag: bool,
      accessMode: AccessMode, txt: str,
      parentInfo: &TypeInfo!, typeDataAccessor: TypeDataAccessor! ) 
   {
      super( scope, processInfo );

      self.imutType = headTypeInfo;
      self.externalFlag = externalFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = processInfo.newId( self );
      self.valInfoMap = {};
      self.valInfoNum = 0;

      when! typeDataAccessor {
         typeDataAccessor.$typeData.addChildren( self );
      }
      
      // if! parentInfo {
      //    _exp.addChildren( self );
      // }

      self.nilableTypeInfo = new NilableTypeInfo( processInfo, self );

      scope.set_ownerTypeInfo( self );
   }

   pub fn getValInfo( name:str ) : &AlgeValInfo! {
      return self.valInfoMap[ name ];
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Alge;
   }

   pub override fn getParentId(): &IdInfo {
      return self.parentInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return rawTxt;
   }

   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt, nil );
   }

   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return self == other.$srcTypeInfo.$aliasSrc, nil;
   }

   pub override fn get_mutMode(): MutMode {
      return .Mut;
   };
}

pub class AlgeValInfo {
   pri let name: str {pub};
   pri let typeList:&List<&TypeInfo> {pub};
   pri let algeTpye:&AlgeTypeInfo {pub};
   pri let symbolInfo:&SymbolInfo {pub};

   pub fn serialize( stream: oStream, serializeInfo:&SerializeInfo ) {
      stream.write( "{ name = '%s', typeList = {" (self.name) );
      foreach typeInfo, index in self.typeList {
         if index > 1 {
            stream.write( ", " );
         }
         stream.write( "%s" ( serializeInfo.serializeId( typeInfo.$typeId ) ) );
      }
      stream.write( "} }" );
   }
}

pub fn AlgeTypeInfo.addValInfo( valInfo:&AlgeValInfo ) mut {
   self.valInfoMap[ valInfo.$name ] = valInfo;
   self.valInfoNum = self.valInfoNum + 1;
}


alge OverridingType {
   NoReady,
   NotOverride,
   Override( &TypeInfo )
}

pub class NormalTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // generic のタイプ
   pri let itemTypeInfoList: &List<&TypeInfo> { pub };
   // 引数のタイプ
   pri let argTypeInfoList: &List<&TypeInfo> { pub };
   // 戻り値のタイプ
   pri let retTypeInfoList: &List<&TypeInfo> { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let mut typeId: &IdInfo { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // タイプの種別
   pri let kind: TypeInfoKind { pub };
   // static かどうか
   pri let staticFlag: bool { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   // コンパイラで自動生成された型情報の場合 true。 accessor 等。
   pri let autoFlag: bool { pub };
   /** */
   pri let abstractFlag: bool { pub };

   // 基底クラス。 無効な場合は headTypeInfo。
   pri let baseTypeInfo: &TypeInfo { pub };
   // インタフェースのリスト。
   pri let interfaceList: &List<&TypeInfo> { pub };

   // この型の nilable 版の TypeInfo。 無効な場合は headTypeInfo。
   pri let mut nilableTypeInfo: TypeInfo { pub& };
   // このメソッドの mutMode。
   pri let mut mutMode: MutMode {pub,pub};

   pri let alt2typeMap:&Map<&TypeInfo,&TypeInfo>;
   pri let moduleLang:Types.Lang!;
   pri let mut requirePath:str {pub,local};

   pri let asyncMode: Async {pub};

   /**
   オーバーライド元の TypeInfo。
   */
   let allmut overridingType:&OverridingType;

   pri let mut imutType:&TypeInfo {pub,local};

   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self.nilableTypeInfo;
   }

   pub override fn getOverridingType() : &TypeInfo! {
      _match self.overridingType {
         case .NotOverride {
            return nil;
         }
         case .Override( typeInfo ) {
            return typeInfo;
         }
         case .NoReady {
            let scope = unwrap self.parentInfo.$scope;
            if! let typeInfo = scope.getTypeInfoField(
               self.rawTxt, false, scope, .Normal )
            {
               if! let workType = typeInfo.getOverridingType() {
                  self.overridingType = .Override( workType );
                  return workType;
               } else {
                  self.overridingType = .Override( typeInfo );
                  return typeInfo;
               }
            } else {
               self.overridingType = .NotOverride;
               return nil;
            }
         }
      }
   }

   pub fn switchScopeTo( scope: &Scope ) {
      self.switchScope( scope );
   }
   
   local fn __init(
      processInfo:ProcessInfo, abstractFlag:bool, scope: Scope!,
      baseTypeInfo: &TypeInfo!, interfaceList: &List<&TypeInfo>!,
      autoFlag: bool, externalFlag: bool, staticFlag: bool,
      accessMode: AccessMode, txt: str,
      parentInfo: &TypeInfo!, typeDataAccessor: TypeDataAccessor!, kind: TypeInfoKind,
      itemTypeInfoList: &List<&TypeInfo>!, argTypeInfoList:&List<&TypeInfo>!,
      retTypeInfoList: &List<&TypeInfo>!, mutMode: MutMode!,
      moduleLang:Types.Lang!, asyncMode:Async ) 
   {
      super( scope, processInfo );

      self.imutType = headTypeInfo;
      self.asyncMode = asyncMode;

      if type(kind) ~= "number" {
         Util.printStackTrace();
      }

      if kind == .Method and parentInfo$.hasBase$() {
         self.overridingType = .NoReady;
      } else {
         self.overridingType = .NotOverride;
      }

      self.requirePath = "";
      self.moduleLang = moduleLang;
      self.abstractFlag = abstractFlag;
      self.baseTypeInfo = unwrap baseTypeInfo default headTypeInfo;
      self.interfaceList = unwrap interfaceList default [];
      self.autoFlag = autoFlag;
      self.externalFlag = externalFlag;
      self.staticFlag = staticFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.kind = kind;
      self.itemTypeInfoList = unwrap itemTypeInfoList default [];
      self.argTypeInfoList = unwrap argTypeInfoList default [];
      self.retTypeInfoList = unwrap retTypeInfoList default [];
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.mutMode = unwrap mutMode default MutMode.IMut;

      fn setupAlt2typeMap(): Map<&TypeInfo,&TypeInfo> {

         if self.baseTypeInfo == headTypeInfo and #self.interfaceList == 0 {
            return {};
         }
         let mut alt2typeMap:Map<&TypeInfo,&TypeInfo> = {};
         switch kind {
            case .Set, .Map, .List, .Array, .Box {
               if #self.itemTypeInfoList ~= #self.baseTypeInfo.$itemTypeInfoList {
                  Util.err( "unmatch generic type number -- %d, %d"
                            (#self.itemTypeInfoList,
                              #self.baseTypeInfo.$itemTypeInfoList ) );
               }
               foreach appyType, index in self.itemTypeInfoList {
                  let genType = self.baseTypeInfo.$itemTypeInfoList[ index ];
                  alt2typeMap[ genType ] = appyType;
               }
            }
            case .Class, .IF {
               foreach ifType in self.interfaceList {
                  if! let genericType = ifType@@@GenericTypeInfo {
                     foreach genType, altType in genericType.createAlt2typeMap( false ) {
                        alt2typeMap[ altType ] = genType;
                     }
                  }
               }
            }
         }
         return alt2typeMap;
      }

      self.alt2typeMap = setupAlt2typeMap();


      self.typeId = processInfo.newId( self );
      if kind == .Root {
      }
      else {
         when! typeDataAccessor {
            typeDataAccessor.$typeData.addChildren( self );
         }
         // when! parentInfo {
         //    parentInfo.addChildren( self );
         // }

         let mut hasNilable = false;

         switch ( kind ) {
            case .Prim, .List, .Array, .Set,
                 .Map, .Class, .Stem,
                 .Module, .IF
            {
               hasNilable = true;
            }
            case .Func, .Method, .Form, .FormFunc {
               hasNilable = true;
            }
         }
         if hasNilable {
            self.nilableTypeInfo = new NilableTypeInfo( processInfo, self );
         }
         else {
            self.nilableTypeInfo = self;
         }
      }
   }

   local fn cloneForMeta( processInfo:ProcessInfo ) : NormalTypeInfo {
      let mut newType = new NormalTypeInfo(
         processInfo, self.abstractFlag, nil,
         self.baseTypeInfo, self.interfaceList, self.autoFlag,
         self.externalFlag, self.staticFlag,
         self.accessMode, self.rawTxt,
         self.parentInfo, nil, self.kind,
         self.itemTypeInfoList, self.argTypeInfoList,
         self.retTypeInfoList, self.mutMode,
         self.moduleLang, self.asyncMode );
      newType.typeId = self.typeId;
      return newType;
   }


   pub override fn createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      let mut map:Map<&TypeInfo,&TypeInfo> =
         self.baseTypeInfo.createAlt2typeMap( detectFlag );
      foreach typeInfo, genType in self.alt2typeMap {
         map[ genType ] = typeInfo;
      }
      return map;
   }

   // この型が nilable を表わす型かどうか。
   pub override fn get_nilable(): bool {
      return false;
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn getParentId(): &IdInfo {
      return self.parentInfo.$typeId;
   }

   pub override fn get_baseId(): &IdInfo {
      return self.baseTypeInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, 
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      mut raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      let mut parentTxt = "";
      when! typeNameCtrl {
         parentTxt = self.getParentFullName( typeNameCtrl, importInfo, localFlag );
      }
      let mut name;
      if #self.itemTypeInfoList > 0 {
         let mut txt = raw .. "<";
         foreach typeInfo, index in self.itemTypeInfoList {
            if index ~= 1 {
               txt = txt .. ",";
            }
            txt = txt .. typeInfo.getTxt( typeNameCtrl, importInfo, localFlag );
         }

         name = parentTxt .. txt .. ">";
      }
      else {
         name = parentTxt .. raw;
      }

      return name;
   }


   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>!  ): str {
      switch self.kind {
         case .Func, .Form, .FormFunc, .Method, .Macro {
            let mut txt = raw .. "(";
            foreach argType, index in self.argTypeInfoList {
               if index ~= 1 {
                  txt = txt .. ", ";
               }
               txt = txt .. argType.get_display_stirng();
            }
            txt = txt .. ")";
            foreach retType, index in self.retTypeInfoList {
               if index == 1 {
                  txt = txt .. ": ";
               }
               else {
                  txt = txt .. ", ";
               }
               txt = txt .. retType.get_display_stirng();
            }
            return txt;
         }
      }

      let mut parentTxt = "";
      let mut name;
      if #self.itemTypeInfoList > 0 {
         let mut txt = raw .. "<";
         foreach typeInfo, index in self.itemTypeInfoList {
            if index ~= 1 {
               txt = txt .. ",";
            }
            txt = txt .. typeInfo.get_display_stirng_with( typeInfo.$rawTxt, alt2type );
         }

         name = parentTxt .. txt .. ">";
      }
      else {
         name = parentTxt .. raw;
      }

      return name;
   }

   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt, nil );
   }


   pub override fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      if self.typeId.id == userRootId {
         return;
      }

      let parentId = self.getParentId();

      let mut txt = ```{ skind=%d, parentId = %d, typeId = %d, baseId = %s, txt = '%s',
  abstractFlag = %s, staticFlag = %s, accessMode = %d, kind = %d, mutMode = %d,
  asyncMode = %d,     
```
          ( SerializeKind.Normal,
            parentId.id, self.typeId.id,
            serializeInfo.serializeId( self.$baseId ), self.rawTxt,
            self.abstractFlag, self.staticFlag, self.accessMode,
            self.kind, self.mutMode, self.asyncMode );
      if! self.moduleLang {
         txt = txt .. 'moduleLang = %d, ' (_exp );
      }
      if self.requirePath ~= "" {
         txt = txt .. 'requirePath = "%s", ' (self.requirePath );
      }
      

      let mut children:List<&TypeInfo> = [];
      foreach child in self.$children {
         if serializeInfo.isValidChildren( child.$typeId ) {
            children.insert( child );
         }
      }
      // if! let scope = self.$scope {
      //    switch self.$kind {
      //       case .Set, .List, .Map, .Array {
      //       }
      //       default {
      //          forsort symbolInfo in scope.$symbol2SymbolInfoMap {
      //             _switch symbolInfo.$kind {
      //                case .Typ, .Mtd, .Fun, .Mac {
      //                   let child = symbolInfo.$typeInfo;
      //                   if serializeInfo.isValidChildren( child.$typeId ) {
      //                      children.insert( child );
      //                   }
      //                }
      //                case .Arg, .Var, .Mbr {
      //                }
      //             }
      //          }
      //       }
      //    }
      // }

      

      stream.write(
         txt .. self.serializeTypeInfoList(
            serializeInfo, "itemTypeId = {", self.itemTypeInfoList## ) ..
         self.serializeTypeInfoList(
            serializeInfo, "ifList = {", self.interfaceList## ) ..
         self.serializeTypeInfoList(
            serializeInfo, "argTypeId = {", self.argTypeInfoList## ) ..
         self.serializeTypeInfoList(
            serializeInfo, "retTypeId = {", self.retTypeInfoList## ) ..
         self.serializeTypeInfoList(
            serializeInfo, "children = {", children, true ) .. "}\n" );
   }

   pub fn equalsSub( processInfo:&ProcessInfo, typeInfo: &TypeInfo,
                     alt2type:Map<&TypeInfo,&TypeInfo>!, checkModifer:bool! ): bool
   {
      if self.typeId.equals( typeInfo.$typeId ) {
         return true;
      }

      if typeInfo.$kind == .Alternate {
         return typeInfo.equals( processInfo, self, alt2type, checkModifer );
      }

      if! let aliasType = typeInfo@@@AliasTypeInfo {
         return aliasType.equals( processInfo, self, alt2type, checkModifer );
      }
      

      // プリミティブな設定のチェック
      if self.kind ~= typeInfo.$kind or
         self.staticFlag ~= typeInfo.$staticFlag or
         self.autoFlag ~= typeInfo.$autoFlag or
         self.$nilable ~= typeInfo.$nilable or
         self.rawTxt ~= typeInfo.$rawTxt or
         self.baseTypeInfo ~= typeInfo.$baseTypeInfo
         //  or
         // self ~= typeInfo.$srcTypeInfo
      {
         return false;
      }

      if self.accessMode ~= typeInfo.$accessMode or
         self.parentInfo ~= typeInfo.$parentInfo
      {
         switch self.kind {
            case .List, .Map, .Array, .Set {
               // これらの型情報は、 accessMode に意味はあまりないので無視
            }
            default {
               return false;
            }
         }
      }

      {
         if #self.itemTypeInfoList ~= #typeInfo.$itemTypeInfoList {
            return false;
         }
         foreach item, index in self.itemTypeInfoList {
            if not item.equals(
               processInfo, typeInfo.$itemTypeInfoList[ index ], alt2type, checkModifer )
            {
               return false;
            }
         }
      }

      {
         if #self.retTypeInfoList ~= #typeInfo.$retTypeInfoList {
            return false;
         }
         foreach item, index in self.retTypeInfoList {
            if not item.equals(
               processInfo, typeInfo.$retTypeInfoList[ index ], alt2type, checkModifer )
            {
               return false;
            }
         }
      }

      return true;
   }

   pub override fn equals(
      processInfo:&ProcessInfo, typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
      checkModifer:bool! ): bool
   {
      return self.equalsSub( processInfo, typeInfo, alt2type, checkModifer );
   }
}

pub fn ProcessInfo.duplicate() : ProcessInfo {
   let mut processInfo = new ProcessInfo(
      self.validCheckingMutable, self.idProvBase.clone(),
      self.validExtType, self.validDetailError, (unwrap self.typeInfo2Map).clone() );

   // let mut scope = new Scope( processInfo, nil, false, nil## );
   // processInfo.set_topScope( scope );
   // let mut topType = RootTypeInfo.create( processInfo, processInfo.newIdForSubRoot());
   // scope.set_ownerTypeInfo( topType );
   // foreach typeInfo in (unwrap self.dummyParentType).$children {
   //    topType.$typeData.$children.insert( typeInfo );
   // }
   
   processInfo.orgInfo = self;
   processInfo.idProvExt = self.idProvExt.clone();
   processInfo.idProvSym = self.idProvSym.clone();
   processInfo.idProvScope = self.idProvScope.clone();

   foreach typeInfo, typeId in self.id2TypeInfo {
      let dupTypeInfo:&TypeInfo;
      switch typeInfo.$kind {
         case .Func, .Method {
            if! let funcTypeInfo = typeInfo@@@NormalTypeInfo {
               dupTypeInfo = funcTypeInfo.cloneForMeta( processInfo );            
            } else {
               dupTypeInfo = typeInfo;
            }
         }
         default {
            dupTypeInfo = typeInfo;
         }
      }
      processInfo.id2TypeInfo[ typeId ] = dupTypeInfo;
   }
   return processInfo;
}


pub fn ProcessInfo.createAlternate(
   belongClassFlag:bool, altIndex:int, txt:str, accessMode:AccessMode,
   parentInfo:&TypeInfo, baseTypeInfo: &TypeInfo!,
   interfaceList: &List<&TypeInfo>! ) mut : AlternateTypeInfo, Scope
{
   return AlternateTypeInfo.create(
      self, belongClassFlag, altIndex, txt,
      accessMode, parentInfo, baseTypeInfo, interfaceList )**;
}


// let mut typeInfo2Map = new TypeInfo2Map();

pub fn isExtType( typeInfo:&TypeInfo ): bool {
   return typeInfo.$kind == .Ext or (typeInfo.$kind == .DDD and
                                      typeInfo.$extedType ~= typeInfo );
}

pub fn Scope.addOverrideImut(
   processInfo:ProcessInfo, symbolInfo:&SymbolInfo ) mut
{
   let typeInfo;
   if TypeInfo.isMut( symbolInfo.$typeInfo ) {
      typeInfo = processInfo.createModifier( symbolInfo.$typeInfo, .IMut );
   }
   else {
      typeInfo = symbolInfo.$typeInfo;
   }

   
   self.symbol2SymbolInfoMap[ symbolInfo.$name ] =
      new AccessSymbolInfo( processInfo, symbolInfo, .IMut( typeInfo ), false );
}



pub fn addBuiltin( typeInfo:&TypeInfo, scope:Scope! ) __noasync {
   builtInTypeIdSetWork[ typeInfo.$typeId.id ] =
   new BuiltinTypeInfo( typeInfo, nil, scope );
}
pub fn addBuiltinMut( typeInfo:TypeInfo, scope:Scope! ) __noasync {
   builtInTypeIdSetWork[ typeInfo.$typeId.id ] =
   new BuiltinTypeInfo( typeInfo, typeInfo, scope );
}
addBuiltinMut( headTypeInfoMut, rootScope );

pub static fn TypeInfo.getBuiltinInfo( typeInfo:&TypeInfo ) __noasync : BuiltinTypeInfo {
   if typeInfo.$typeId.$processInfo ~= rootProcessInfoRo {
      Util.err( "not found builtinMut, mismatch processInfo-- %s (%d)"
                (typeInfo.getTxt(##), typeInfo.$typeId.id ) );
   }
   let! mut info = builtInTypeIdSetWork[ typeInfo.$typeId.id ] {
      Util.err( "not found builtinMut -- %s( %d)"
                (typeInfo.getTxt(##), typeInfo.$typeId.id ) );
   };
   return info;
}


pub fn getBuiltinMut( typeInfo:&TypeInfo ) __noasync : TypeInfo {
   let mut info = TypeInfo.getBuiltinInfo( typeInfo );
   let! mut typeInfoMut = info.$typeInfoMut {
      Util.err( "typeInfoMut is nil -- %s (%d)"
                (typeInfo.getTxt(##), typeInfo.$typeId.id ) );
   };
   return typeInfoMut;
}

fn registBuiltin(
   idName: str, typeTxt: str, kind: TypeInfoKind,
   worktypeInfo:&TypeInfo!, typeInfoMut:TypeInfo!,
   nilableTypeInfo:&TypeInfo, scope:Scope! ) __noasync : &TypeInfo
{
   let! typeInfo = worktypeInfo {
      typeInfo = unwrap typeInfoMut;
   };
   let registScope = scope ~= nil;
   //typeInfoKind[ idName ] = typeInfo;
   sym2builtInTypeMapWork[ typeTxt ] = new NormalSymbolInfo(
      rootProcessInfo, SymbolKind.Typ, false, false,
      rootScope, AccessMode.Pub, false, typeTxt, nil, typeInfo, .IMut, true, false );
   if nilableTypeInfo ~= headTypeInfo {
      sym2builtInTypeMapWork[ typeTxt .. "!" ] = new NormalSymbolInfo(
         rootProcessInfo,
         SymbolKind.Typ, false, kind == .Func, rootScope,
         AccessMode.Pub, false, typeTxt, nil, nilableTypeInfo, .IMut, true, false );
   }
   addBuiltin( typeInfo, scope );
   when! typeInfoMut {
      addBuiltinMut( typeInfoMut, scope );
   }
   // builtIn は modifier も作成しておく
   let imutType = rootProcessInfo.createModifier( typeInfo, .IMut );
   addBuiltin( imutType, scope );
   

   if typeInfo.$nilableTypeInfo ~= headTypeInfo and
      typeInfo.$nilableTypeInfo ~= typeInfo
   {
      addBuiltin( typeInfo.$nilableTypeInfo, scope );
      // builtIn は modifier も作成しておく
      let nilImutType =
         rootProcessInfo.createModifier( typeInfo.$nilableTypeInfo, .IMut );
      addBuiltin( nilImutType, scope );
   }


   if registScope {
      rootScope.addClass( rootProcessInfo, typeTxt, nil, typeInfo );
   }

   return typeInfo;
}

local static fn NormalTypeInfo.createBuiltin(
   idName: str, typeTxt: str, kind: TypeInfoKind,
   typeDDD: &TypeInfo!, ifList:&List<&TypeInfo>! ) __noasync mut : &TypeInfo
{
   let mut argTypeList:List<&TypeInfo> = [];
   let mut retTypeList:List<&TypeInfo> = [];
   if typeTxt == "form" {
      if! typeDDD {
         argTypeList = [ _exp ];
         retTypeList = [ _exp ];
      }
   }

   let mut scope:Scope! = nil;
   switch kind {
      case .Array, .Map, .List, .Set, .Class, .Module,
           .IF, .Form, .FormFunc, .Func, .Method, .Macro
      {
         let scopeKind:ScopeKind;
         switch kind {
            case .Class, .IF, .List, .Array, .Set, .Map {
               scopeKind = .Class;
            }
            case .Module {
               scopeKind = .Module;
            }
            default {
               scopeKind = .Other;
            }
         }
         scope = new Scope( rootProcessInfo, rootScope, scopeKind, nil## );
      }
   }

   let mut genTypeList:List<&TypeInfo> = [];
   switch kind {
      case .Array, .List, .Set {
         genTypeList.insert(
            (rootProcessInfo.createAlternate( true, 1, "T", .Pri, headTypeInfo ## )) );
      }
      case .Map {
         genTypeList.insert(
            (rootProcessInfo.createAlternate( true, 1, "K", .Pri, headTypeInfo ## )) );
         genTypeList.insert(
            (rootProcessInfo.createAlternate( true, 2, "V", .Pri, headTypeInfo ## )) );
      }
   }
   let mut info = new NormalTypeInfo(
      rootProcessInfo, false, scope, nil, ifList, false, false, false,
      AccessMode.Pub, typeTxt, headTypeInfoMut, headTypeInfoMut, 
      kind, genTypeList, argTypeList, retTypeList, .Mut, nil, .Async );
   rootProcessInfo.setupImut( info );

   registBuiltin( idName, typeTxt, kind, info, info, headTypeInfo, scope );
   return info;
}

pub let builtinTypeNone:&TypeInfo =
   NormalTypeInfo.createBuiltin( "__None", "", .Prim## );
// 型が確定していない変数の型は、 builtinTypeEmpty とする
pub let builtinTypeEmpty:&TypeInfo =
   NormalTypeInfo.createBuiltin( "__Empty", "::", .Prim## );
pub let builtinTypeNeverRet:&TypeInfo =
   NormalTypeInfo.createBuiltin( "__NRet", "__", .Prim## );
pub let builtinTypeStem:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Stem", "stem" , .Stem## );
pub let builtinTypeStem_ = builtinTypeStem.$nilableTypeInfo;

pub let builtinTypeBool:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Bool", "bool" , .Prim## );
pub let builtinTypeInt:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Int", "int" , .Prim## );
pub let builtinTypeReal:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Real", "real" , .Prim## );
pub let builtinTypeChar:&TypeInfo =
   NormalTypeInfo.createBuiltin( "char", "__char" , .Prim## );
pub let builtinTypeMapping:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Mapping", "Mapping" , .IF## );
pub let builtinTypeRunner:&TypeInfo =
   NormalTypeInfo.createBuiltin( "__Runner", "__Runner" , .IF## );
pub let builtinTypeProcessor:&TypeInfo = NormalTypeInfo.createBuiltin(
   "__Processor", "__Processor" , .IF, nil, [ builtinTypeRunner ] );
pub let builtinTypeAsyncItem:&TypeInfo =
   NormalTypeInfo.createBuiltin( "__AsyncItem", "__AsyncItem" , .IF## );
pub let builtinTypeAbsImmut:&TypeInfo =
   NormalTypeInfo.createBuiltin( "__absimmut", "__absimmut" , .IF## );
pub let builtinTypeString:&TypeInfo =
   NormalTypeInfo.createBuiltin( "String", "str" , .Class, nil, [ builtinTypeMapping ] );
pub let builtinTypeMap:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Map", "Map" , .Map## );
pub let builtinTypeSet:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Set", "Set" , .Set## );
pub let builtinTypeList:&TypeInfo =
   NormalTypeInfo.createBuiltin( "List", "List" , .List## );
pub let builtinTypeArray:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Array", "Array" , .Array## );

immutableTypeSetWork.add( builtinTypeBool );
immutableTypeSetWork.add( builtinTypeInt );
immutableTypeSetWork.add( builtinTypeReal );
immutableTypeSetWork.add( builtinTypeChar );
immutableTypeSetWork.add( builtinTypeString );

pub fn isClass( typeInfo:&TypeInfo ) : bool {
   return typeInfo.$kind == .Class and typeInfo ~= builtinTypeString;
}

pub fn Scope.addIgnoredVar( processInfo:ProcessInfo ) mut {
   self.addLocalVar( processInfo, false, true, "_", nil, builtinTypeEmpty, .Mut );
}

pri fn AlternateTypeInfo.canSetFrom(
   processInfo:&ProcessInfo,
   other:&TypeInfo, canEvalType:CanEvalType!, alt2type:Map<&TypeInfo,&TypeInfo> ): bool
{
   let otherWork = AlternateTypeInfo.getAssign( other, alt2type );
   if self == otherWork {
      return true;
   }

   if! let genType = alt2type[ self ] {
      when! canEvalType {
         return (genType.canEvalWith( processInfo, otherWork, canEvalType, alt2type ));
      }
      return genType.equals( processInfo, otherWork, alt2type ## );
   }
   let workAlt2type;
   if not CanEvalCtrlTypeInfo.isValidApply( alt2type ) {
      if not isClass( otherWork ) and otherWork.$kind ~= .IF {
         return false;
      }
      workAlt2type = CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
   } else {
      workAlt2type = alt2type;
   }

   if self.hasBase() {
      if not other.isInheritFrom( processInfo, self.baseTypeInfo, workAlt2type ) {
         return false;
      }
   };
   foreach ifType in self.interfaceList {
      if not other.isInheritFrom( processInfo, ifType, workAlt2type ) {
         return false;
      }
   }

   workAlt2type[ self ] = otherWork;
   return true;
}


pub override fn NormalSymbolInfo.set_typeInfo(typeInfo:&TypeInfo) {
   if self.name == "_" {
      return;
   }
   self.typeInfo = typeInfo;
}

enum LuavalConvKind {
   /** Lua 内で型として利用できるか？ */
   InLua,
   /** Lua に渡す型として変換可能か？ */
   ToLua,
}

pub let builtinTypeNil:&TypeInfo = registBuiltin(
   "Nil", "nil", .Prim, nil, new NilTypeInfo( rootProcessInfo ), headTypeInfo, nil );


/**
typeInfo の Luaval を生成可能かどうかを調べる。

@param convFlag true の場合、Luaval と LuneScript との値の変換を自動で行なえるかどうか。
@param validToCheck true の場合、 convFlag を利用して typeInfo の型を Luaval として生成可能かどうか調べる。
       通常は true を指定する。 false を指定するのは、例外。
@return 生成可能な場合は nil。 生成できない場合は メッセージを返す。
*/
fn failCreateLuavalWith(
   typeInfo:&TypeInfo, convFlag:LuavalConvKind, validToCheck:bool ) : str!, bool
{
   macro _checkItemType( itemTypeList:__exp ) {
      foreach itemType in ,,itemTypeList {
         let err, work = failCreateLuavalWith( itemType, convFlag, validToCheck );
         when! err {
            return err, false;
         }
         if not work {
            canConv = false;
         }
      }
   }
   if isExtType( typeInfo ) {
      return nil, true;
   }
   let mess = "not support to use the type as Luaval -- %s" (typeInfo.getTxt(##));
   switch typeInfo.$kind {
      case .Nilable {
         return failCreateLuavalWith(
            typeInfo.$nonnilableType, convFlag, validToCheck )**;
      }
      case .Prim {
         return nil, true;
      }
      case .Form, .IF, .DDD, .ExtModule {
         if not validToCheck {
            return nil, false;
         }
         if convFlag ~= .InLua {
            return mess, false;
         }
         return nil, false;
      }
      case .Stem {
         return nil, false;
      }
      case .Class {
         if typeInfo ~= builtinTypeString {
            if not validToCheck {
               return nil, false;
            }
            if convFlag ~= .InLua {
               return mess, false;
            }
            return nil, false;
         }
         return nil, true;
      }
      case .Array, .List, .Map {
         if not validToCheck {
            return nil, false;
         }
         if convFlag ~= .ToLua and isMutable( typeInfo.$mutMode ) {
            return "not support mutable collecion. " .. mess, false;
         }
         // if convFlag {
         //    return mess, false;
         // }
         let mut canConv = true;
         _checkItemType( typeInfo.$itemTypeInfoList );
         canConv = false;
         return nil, canConv;
      }
      case .FormFunc, .Func {
         if not validToCheck {
            return nil, false;
         }
         if convFlag ~= .InLua {
            return mess, false;
         }
         if #typeInfo.$itemTypeInfoList ~= 0 {
            return mess, false;
         }
         let mut canConv = true;
         _checkItemType( typeInfo.$argTypeInfoList );
         _checkItemType( typeInfo.$retTypeInfoList );
         canConv = false;
         return nil, canConv;
      }
   }
   return "not support -- %s:%s" (typeInfo.getTxt(##), typeInfo.$kind.$_txt), false;
}


pub static fn AlternateTypeInfo.getAssign(
   typeInfo:&TypeInfo, alt2type:&Map<&TypeInfo,&TypeInfo> ) : &TypeInfo
{
   if typeInfo.$kind ~= .Alternate {
      return typeInfo;
   }
   let mut otherWork = typeInfo;
   while true {
      if! alt2type[ otherWork ] {
         if _exp ~= otherWork {
            otherWork = _exp;
         }
         else {
            return otherWork;
         }
      }
      else {
         return otherWork;
      }
   }
}




pub fn isStruct( typeInfo:&TypeInfo ) : bool {
   switch typeInfo.$kind {
      case .Class {
         if typeInfo == builtinTypeString {
            return false;
         }
         if typeInfo.$baseTypeInfo ~= headTypeInfo or
            #typeInfo.$interfaceList ~= 0 or
            #typeInfo.$children ~= 1 // children は __init の分
         {
            return false;
         }
         return true;
      }
   }
   return false;
}


pub let builtinTypeBox:&BoxTypeInfo;
{
   let mut boxRootScope = new Scope( rootProcessInfo, rootScope, .Class, nil## );
   let mut work = new BoxTypeInfo( rootProcessInfo, boxRootScope, .Pub, boxRootAltType );
   rootProcessInfo.setupImut( work );
   registBuiltin( "Nilable", "Nilable", .Box, work, work, headTypeInfo, boxRootScope );
   builtinTypeBox = work;
}

pub fn isConditionalbe( processInfo:&ProcessInfo, typeInfo:&TypeInfo ) : bool {
   if typeInfo.$nilable or typeInfo.equals( processInfo, builtinTypeBool, nil ## ) {
      return true;
   }
   return false;
}


//pub static fn NormalTypeInfo.createBox(
pub fn ProcessInfo.createBox(
   accessMode:AccessMode, nonnilableType: &TypeInfo ) mut : &TypeInfo
{
   if! let boxType = self.$typeInfo2Map.BoxMap[ nonnilableType ] {
      return boxType;
   }

   let mut boxType = new BoxTypeInfo( self, nil, accessMode, nonnilableType );
   self.setupImut( boxType );
   
   self.$typeInfo2Map.BoxMap[ nonnilableType ] = boxType;
   return boxType;
}

pub override fn BoxTypeInfo.applyGeneric(
   processInfo:ProcessInfo, alt2typeMap:&Map<&TypeInfo,&TypeInfo>,
   moduleTypeInfo:&TypeInfo ) : &TypeInfo!
{
   let typeInfo = self.boxingType.applyGeneric(
      processInfo, alt2typeMap, moduleTypeInfo );
   if typeInfo == self.boxingType {
      return self;
   }
   // when! typeInfo {
   //    return moduleTypeInfo.getProcessInfo().createBox( self.accessMode, typeInfo );
   // }
   return nil;
}

macro _createType( newType:__exp ) {
   let tmpMutMode;
   if isMutable( mutMode ) {
      tmpMutMode = mutMode;
   } else {
      tmpMutMode = .Mut;
   }
   
   let newTypeFunc = ,,newType;
   let mut typeInfo = newTypeFunc( tmpMutMode );
   self.setupImut( typeInfo );

   if isMutable( mutMode ) {
      return typeInfo;
   }
   return self.createModifier( typeInfo, mutMode );
}


//pub static fn NormalTypeInfo.createSet(
pub fn ProcessInfo.createSet(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   itemTypeInfo: &List<&TypeInfo>, mutMode:MutMode )  mut : &TypeInfo
{
   _createType( fn (workMutMode:MutMode) : TypeInfo {
      return new NormalTypeInfo(
         self, false, nil, builtinTypeSet,
         nil, false, false, false, AccessMode.Pub,
         "Set", self.$dummyParentType, self.$dummyParentType, .Set, itemTypeInfo,
         nil, nil, workMutMode, nil, .Async ); } );
}

//pub static fn NormalTypeInfo.createList(
pub fn ProcessInfo.createList(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   itemTypeInfo: &List<&TypeInfo>, mutMode:MutMode ) mut : &TypeInfo
{
   _createType( fn (workMutMode:MutMode) : TypeInfo {
      return new NormalTypeInfo(
         self, false, nil, builtinTypeList,
         nil, false, false, false, AccessMode.Pub,
         "List", self.$dummyParentType, self.$dummyParentType, .List, itemTypeInfo,
         nil, nil, workMutMode, nil, .Async ); } );
}

//pub static fn NormalTypeInfo.createArray(
pub fn ProcessInfo.createArray(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   itemTypeInfo: &List<&TypeInfo>, mutMode:MutMode ) mut : &TypeInfo
{
   _createType( fn (workMutMode:MutMode) : TypeInfo {
      return new NormalTypeInfo(
         self, false, nil, builtinTypeArray,
         nil, false, false, false, AccessMode.Pub,
         "Array", self.$dummyParentType, self.$dummyParentType, .Array, itemTypeInfo,
         nil, nil, workMutMode, nil, .Async ); } );
}

//pub static fn NormalTypeInfo.createMap(
pub fn ProcessInfo.createMap(
   accessMode: AccessMode, parentInfo: &TypeInfo, keyTypeInfo: &TypeInfo,
   valTypeInfo: &TypeInfo, mutMode:MutMode ) mut : &TypeInfo
{
   _createType( fn (workMutMode:MutMode) : TypeInfo {
      return new NormalTypeInfo(
         self, false, nil, builtinTypeMap,
         nil, false, false, false, AccessMode.Pub,
         "Map", self.$dummyParentType, self.$dummyParentType, .Map,
         [ keyTypeInfo, valTypeInfo ], nil, nil, workMutMode, nil, .Async );
   });
}


pub fn ProcessInfo.createModule(
   scope: Scope, parentInfo: &TypeInfo,
   typeDataAccessor: TypeDataAccessor, externalFlag: bool,
   moduleName: str, mutable:bool ) mut : TypeInfo
{
   // if! sym2builtInTypeMap[ moduleName ] {
   //    return _exp.$typeInfo;
   // }

   if Parser.isLuaKeyword( moduleName ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (moduleName) );
   }

   let mut info = new ModuleTypeInfo(
      self, scope, externalFlag, moduleName, parentInfo, mutable, typeDataAccessor );
   
   self.setupImut( info );
   
   return info;
}

pub fn ProcessInfo.createClassAsync(
   classFlag: bool, abstractFlag: bool, scope: Scope!, baseInfo: &TypeInfo!,
   interfaceList: &List<&TypeInfo>!, genTypeList: &List<&AlternateTypeInfo>,
   parentInfo: &TypeInfo, typeDataAccessor:TypeDataAccessor, externalFlag: bool,
   accessMode: AccessMode, className: str ) mut : TypeInfo
{
   if Parser.isLuaKeyword( className ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (className) );
   }

   let mut info = new NormalTypeInfo(
      self, abstractFlag, scope, baseInfo, interfaceList, false,
      externalFlag, false, accessMode,
      className, parentInfo, typeDataAccessor,
      classFlag and TypeInfoKind.Class or TypeInfoKind.IF,
      genTypeList, nil, nil, .Mut, nil, .Async );
   self.setupImut( info );

   foreach genType in genTypeList {
      genType.updateParentInfo( info );
   }

   return info;
}



pub fn ProcessInfo.createExtModule(
   scope: Scope!, parentInfo: &TypeInfo,
   typeDataAccessor: TypeDataAccessor, externalFlag: bool,
   accessMode: AccessMode, className: str,
   moduleLang:Types.Lang, requirePath:str ) mut : TypeInfo
{
   // if className == "str" {
   //     return sym2builtInTypeMap[ className ]@TypeInfo;
   // }
   // if! sym2builtInTypeMap[ className ] {
   //    return _exp.$typeInfo;
   // }

   if Parser.isLuaKeyword( className ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (className) );
   }

   let mut info = new NormalTypeInfo(
      self, false, scope, nil, nil, false,
      externalFlag, false, accessMode,
      className, parentInfo, typeDataAccessor,
      .ExtModule, nil, nil, nil, .Mut, moduleLang, .Noasync );
   self.setupImut( info );
   info.set_requirePath(requirePath);
   return info;
}


pub fn ProcessInfo.createFuncAsync(
   abstractFlag: bool, builtinFlag:bool, scope: Scope!, kind: TypeInfoKind,
   parentInfo: &TypeInfo, typeDataAccessor:TypeDataAccessor,
   autoFlag: bool, externalFlag: bool, staticFlag: bool,
   accessMode: AccessMode, funcName: str, asyncMode:Async, altTypeList: &List<&TypeInfo>!,
   argTypeList: &List<&TypeInfo>!, retTypeInfoList: &List<&TypeInfo>!,
   mutMode: MutMode ) mut : NormalTypeInfo
{
   if not builtinFlag and Parser.isLuaKeyword( funcName ) {
      Util.err( "This symbol can not use for a function. -- %s" (funcName) );
   }

   let mut info = new NormalTypeInfo(
      self, abstractFlag, scope, nil, nil, autoFlag, externalFlag, staticFlag,
      accessMode, funcName, parentInfo, typeDataAccessor,
      kind, unwrap altTypeList default [], unwrap argTypeList default [],
      unwrap retTypeInfoList default [], mutMode, nil, asyncMode );
   self.setupImut( info );

   when! altTypeList {
      foreach genType in altTypeList {
         if! genType@@@AlternateTypeInfo {
            _exp.updateParentInfo( info );
         }
      }
   }
   
   return info;
}

pub let builtinTypeLnsLoad:&TypeInfo = rootProcessInfo.createFuncAsync(
   false, true, nil, .Func, headTypeInfoMut, headTypeInfoMut, false, true,
   true, .Pub, "_lnsLoad", .Async, nil, [ builtinTypeString, builtinTypeString ],
   [ builtinTypeStem ], .IMut );



//pub static fn NormalTypeInfo.createFunc(
pub fn ProcessInfo.createDummyNameSpace(
   scope: Scope, parentInfo: &TypeInfo, asyncMode:Async ) mut : NormalTypeInfo
{
   let mut info = new NormalTypeInfo(
      self, false, scope, nil, nil, true, false, true,
      .Local, "__scope_%d" (scope.$scopeId), parentInfo, self.$dummyParentType,
      .Func, [], [], [], MutMode.IMut, nil, asyncMode );
   self.setupImut( info );

   return info;
}

//pub static fn NormalTypeInfo.createAdvertiseMethodFrom(
pub fn ProcessInfo.createAdvertiseMethodFrom(
   classTypeInfo:&TypeInfo,
   typeDataAccessor:TypeDataAccessor, typeInfo:&TypeInfo ) mut : &TypeInfo
{
   return self.createFuncAsync(
      false, false, nil, typeInfo.$kind,
      classTypeInfo, typeDataAccessor,
      true, false, false, typeInfo.$accessMode, typeInfo.$rawTxt,
      typeInfo.$asyncMode, typeInfo.$itemTypeInfoList, typeInfo.$argTypeInfoList,
      typeInfo.$retTypeInfoList, typeInfo.$mutMode );
}


pub override fn ModifierTypeInfo.get_nonnilableType(): &TypeInfo {
   let orgType = self.srcTypeInfo.$nonnilableType;
   if TypeInfo.isMut( self ) or not TypeInfo.isMut( orgType ) {
      return orgType;
   }
   // return self.getProcessInfo().createModifier( orgType, .IMut );
   return orgType.$imutType;
}

pub override fn ModifierTypeInfo.get_nilableTypeInfo(): &TypeInfo {
   let orgType = self.srcTypeInfo.$nilableTypeInfo;
   if not TypeInfo.isMut( orgType ) {
      return orgType;
   }
   // return self.getProcessInfo().createModifier( orgType, .IMut );
   return orgType.$imutType;
}

//pub static fn NormalTypeInfo.createAlias(
pub fn ProcessInfo.createAlias(
   processInfo:ProcessInfo, name:str, externalFlag:bool, accessMode:AccessMode,
   parentInfo: &TypeInfo, typeInfo: &TypeInfo ) mut : AliasTypeInfo
{
   let mut newType = new AliasTypeInfo(
      processInfo, name, accessMode, parentInfo, typeInfo.$srcTypeInfo, externalFlag );
   self.setupImut( newType );
   return newType;
}

pub fn Scope.addAlias(
   processInfo:ProcessInfo,
   name:str, pos:&Parser.Position, externalFlag:bool, accessMode:AccessMode,
   parentInfo: &TypeInfo, symbolInfo:&SymbolInfo ) mut : &SymbolInfo!, &SymbolInfo!
{
   let aliasType = processInfo.createAlias(
      processInfo, name, externalFlag, accessMode,
      parentInfo, symbolInfo.$typeInfo.$srcTypeInfo );
   return self.add(
      processInfo, symbolInfo.$kind, false, symbolInfo.$canBeRight,
      name, pos, aliasType, accessMode, true, .IMut, true, false )**;
}

pub fn Scope.addAliasForType(
   processInfo:ProcessInfo, name:str, pos:&Parser.Position!, typeInfo:&TypeInfo ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   let mut skind = SymbolKind.Typ;
   let mut canBeRight = false;
   switch typeInfo.$kind {
      case .Func {
         skind = .Fun;
         canBeRight = true;
      }
      case .Form, .FormFunc {
         canBeRight = true;
      }
      case .Macro {
         skind = .Mac;
      }
   }

   return self.add(
      processInfo, skind, false, canBeRight, name, pos,
      typeInfo, typeInfo.$accessMode, true, .IMut, true, false )**;
}



pub class DDDTypeInfo extend TypeInfo {
   pri let typeInfo: &TypeInfo { pub };
   pri let typeId: &IdInfo { pub };
   pri let externalFlag: bool {pub};
   pri let itemTypeInfoList: &List<&TypeInfo> {pub};
   pri let extedType:&TypeInfo {pub};
   pri let mut imutType:&TypeInfo {pub,local};

   pub fn get_extTypeFlag(): bool {
      return self.extedType ~= self;
   }
   
   pub override fn get_scope(): &Scope! {
      return nil;
   }

   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self;
   }
   
   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }
   /** 名前空間の親 */
   pub override fn get_parentInfo(): &TypeInfo {
      return headTypeInfo;
   }

   local fn __init( processInfo:ProcessInfo, typeInfo:&TypeInfo,
                    externalFlag:bool, extOrgDDType:&DDDTypeInfo! )   
   {
      super( nil, processInfo );
      self.imutType = headTypeInfo;
      
      self.typeId = processInfo.newId( self );
      //self.typeInfo = typeInfo.$nilableTypeInfo;
      self.typeInfo = typeInfo;
      self.externalFlag = externalFlag;
      self.itemTypeInfoList = [ self.typeInfo ];
      let extOrgType;
      when! extOrgDDType {
         extOrgType = extOrgDDType;
         processInfo.$typeInfo2Map.ExtDDDMap[ typeInfo ] = self;
      } else {
         extOrgType = self;
         processInfo.$typeInfo2Map.DDDMap[ typeInfo ] = self;
      }
      self.extedType = extOrgType;
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return self.typeInfo.canEvalWith( processInfo, other, canEvalType, alt2type )**;
   }

   pub override fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      stream.write(
         '{ skind=%d, typeId = %d, itemTypeId = %s, parentId = %d, extTypeFlag = %s }\n'
         ( SerializeKind.DDD, self.typeId.id,
           serializeInfo.serializeId( self.typeInfo.$typeId ),
           headTypeInfo.$typeId.id, self.$extTypeFlag ) );
   }

   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str
   {
      let txt = self.getTxtWithRaw( raw ##);
      return txt;
   }
   pub override fn get_display_stirng(): str {
      let txt = self.get_display_stirng_with( self.$rawTxt, nil );
      return txt;
   }

   pub override fn getModule(): &TypeInfo {
      return self.$typeInfo.getModule();
   }
   pub override fn get_rawTxt(): str {
      return self.getTxt(##);
   }
   pub override fn get_kind(): TypeInfoKind {
      return .DDD;
   }
   pub override fn get_nilable(): bool {
      //return self.typeInfo.$nilable;
      return true;
   }
   pub override fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_mutMode(): MutMode {
      return self.$typeInfo.$mutMode;
   }
   pub override fn get_aliasSrc() : &TypeInfo {
      return self;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_accessMode(): AccessMode {
      // export 出来るように pub 固定にする。
      // accessMode 毎にインスタンスを作ることも出来るが、
      // ほぼ無駄なので pub 固定とする。
      return .Pub;
   }
}


//pub static fn NormalTypeInfo.createDDD(
pub fn ProcessInfo.createDDD(
   mut typeInfo:&TypeInfo, externalFlag:bool, mut extTypeFlag:bool ) mut : &DDDTypeInfo
{
   if typeInfo.$kind == .DDD {
      typeInfo = typeInfo.$itemTypeInfoList[ 1 ];
   }
   if not failCreateLuavalWith( typeInfo, .InLua, true ) and extTypeFlag {
      extTypeFlag = false;
   }

   if typeInfo.$nonnilableType.$kind ~= .Ext and extTypeFlag {
      _match self.createLuaval( typeInfo, true ) {
         case .OK( work, _ ) {
            typeInfo = work;
         }
         case .Err( mess ) {
            Util.err( mess );
         }
      }
   }
   
   
   
   let dddMap;
   if extTypeFlag {
      dddMap = self.$typeInfo2Map.ExtDDDMap;
   } else {
      dddMap = self.$typeInfo2Map.DDDMap;
   }
   if! dddMap[ typeInfo ] {
      if _exp.$typeId.id < userStartId and typeInfo.$typeId.id >= userStartId {
         Util.err( "on cache" );
      }
      return _exp;
   }

   let mut dddType = new DDDTypeInfo( self, typeInfo, externalFlag, nil );
   self.setupImut( dddType );

   if failCreateLuavalWith( typeInfo, .InLua, true ) {
      // dddType 生成時に extTypeFlag の dddType を生成して map に登録しておく
      let mut extDDDType = new DDDTypeInfo( self, typeInfo, externalFlag, dddType );
      self.setupImut( extDDDType );

      if extTypeFlag {
         return extDDDType;
      }
   }

   return dddType;
}



// pub let builtinTypeNil:&TypeInfo = registBuiltin(
//    "Nil", "nil", .Prim, nil, new NilTypeInfo( rootProcessInfo ), headTypeInfo, nil );

   


pub let builtinTypeDDD:&TypeInfo = registBuiltin(
   "DDD", "...", .DDD,
   rootProcessInfo.createDDD( builtinTypeStem_, true, false ), nil, headTypeInfo, nil );
   



pub let builtinTypeForm:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Form", "form" , .Form, builtinTypeDDD ## );
immutableTypeSetWork.add( builtinTypeForm );

pub let builtinTypeSymbol:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Symbol", "sym" , .Prim## );
pub let builtinTypeStat:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Stat", "stat" , .Prim## );
pub let builtinTypeExp:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Exp", "__exp" , .Prim## );
pub let builtinTypeMultiExp:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Exps", "__exps" , .Prim## );
pub let builtinTypeBlockArg:&TypeInfo =
   NormalTypeInfo.createBuiltin( "Block", "__block" , .Prim## );


pub class CombineType {
   let mut ifSet:Set<&TypeInfo>;
   let mut nilable:bool;
   let mut mutMode:MutMode;

   pub fn __init( typeInfo:&TypeInfo ) {
      self.ifSet = (@);
      foreach iftype in typeInfo.$interfaceList {
         self.ifSet.add( iftype );
      }
      self.nilable = typeInfo.$nilable;
      self.mutMode = typeInfo.$mutMode;
   }

   pub fn isInheritFrom(
      processInfo:&ProcessInfo,
      other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool
   {
      foreach ifType in self.ifSet {
         if ifType.isInheritFrom( processInfo, other, alt2type ) {
            return true;
         }
      }
      return false;
   }
   
   pri fn andIfSet(
      processInfo:ProcessInfo,
      ifSet:&Set<&TypeInfo>, alt2type:Map<&TypeInfo,&TypeInfo> ) mut {
      let mut workSet:Set<&TypeInfo> = (@);
      foreach other in ifSet {
         if self.isInheritFrom( processInfo, other, alt2type ) {
            workSet.add( other );
         }
         else {
            foreach ifType in self.ifSet {
               if other.isInheritFrom( processInfo, ifType, alt2type ) {
                  workSet.add( ifType );
               }
            }
         }
      }
      self.ifSet = workSet;
   }

   pub fn createStem( processInfo:ProcessInfo ): &TypeInfo {
      let retType;
      if self.nilable {
         retType = builtinTypeStem_;
      }
      else {
         retType = builtinTypeStem;
      }
      if isMutable( self.mutMode ) {
         return retType;
      }
      return processInfo.createModifier( retType, self.mutMode );
   }

/**
型を合成した結果の型情報を返す。
*/
   pub fn get_typeInfo( processInfo:ProcessInfo ) : &TypeInfo {
      if self.ifSet.len() ~= 1 {
         // 処理を簡単にするため、現状は interface を複数もつ場合は stem 型とする。
         // 本来は、 interface の継承関係を見るべき。
         return self.createStem( processInfo );
      }
      foreach ifType in self.ifSet {
         let mut work = ifType;
         if self.nilable {
            work = work.$nilableTypeInfo;
         }
         if isMutable( self.mutMode ) {
            return work;
         }
         return processInfo.createModifier( work, self.mutMode );
      }
      // 内部エラー
      error( "illegal" );
   }
}


pub alge CommonType {
   Normal( &TypeInfo ),
   Combine( CombineType ),
}


   /**
other と共通する IF の集合をセットする。

@return other と共通の IF に調整した CombineIFTypeInfo を返す。
共通の IF がない場合、 builtinTypeStem を返す。 
   */
pub fn CombineType.andType(
   processInfo:ProcessInfo, other:CommonType,
   alt2type:Map<&TypeInfo,&TypeInfo> ) mut : CommonType
{
   _match other {
      case .Combine( comboInfo ) {
         self.andIfSet( processInfo, comboInfo.ifSet, alt2type );
         if not isMutable( comboInfo.mutMode ) {
            self.mutMode = comboInfo.mutMode;
         }
         return CommonType.Combine( self );
      }
      case .Normal( typeInfo ) {
         if not isMutable( typeInfo.$mutMode ) {
            self.mutMode = typeInfo.$mutMode;
         }
         let mut ifSet:Set<&TypeInfo> = (@);
         if typeInfo.$kind == .IF {
            ifSet.add( typeInfo );
         }
         else {
            foreach iftype in typeInfo.$interfaceList {
               ifSet.add( iftype );
            }
         }
         self.andIfSet( processInfo, ifSet, alt2type );

         if self.ifSet.len() ~= 0 {
            return CommonType.Combine( self );
         }
         return CommonType.Normal( self.createStem( processInfo ) );
      }
   }
}


/**
typeInfo と other 両方の型を受けられる共通の型を返す。

typeInfo と other に互換性がない場合は stem あるいは stem! の型を返す。
*/
pub static fn TypeInfo.getCommonTypeCombo(
   processInfo:ProcessInfo, commonType:CommonType, otherType:CommonType,
   alt2type:Map<&TypeInfo,&TypeInfo> ) : CommonType
{
   let mut typeInfo = builtinTypeNone;
   
   match commonType {
      case .Combine( comb ) {
         return comb.andType( processInfo, otherType, alt2type );
      }
      case .Normal( workTypeInfo ) {
         typeInfo = workTypeInfo;
      }
   }
   
   let mut other = builtinTypeNone;
   match otherType {
      case .Combine( comb ) {
         return comb.andType( processInfo, commonType, alt2type );
      }
      case .Normal( workTypeInfo ) {
         other = workTypeInfo;
      }
   }

   fn getType( mut workType:&TypeInfo ) __trans : CommonType {
      if typeInfo.$nilable or other.$nilable {
         workType = workType.$nilableTypeInfo;
      }
      if not TypeInfo.isMut( typeInfo ) or not TypeInfo.isMut( other ) {
         // どちらかが immutable なら、結果も immutable にする
         workType = processInfo.createModifier( workType, .IMut);
      }
      return CommonType.Normal( workType );
   }
   
   let type1 = typeInfo.$nonnilableType.$srcTypeInfo;
   let type2 = other.$nonnilableType.$srcTypeInfo;

   if type1 == builtinTypeNone {
      return otherType;
   }
   if type2 == builtinTypeNone {
      return commonType;
   }
   
   if type1 == builtinTypeNil {
      return CommonType.Normal( other.$nilableTypeInfo );
   }
   if type2 == builtinTypeNil {
      return CommonType.Normal( typeInfo.$nilableTypeInfo );
   }
   
   
   if type1.canEvalWith( processInfo, type2, .SetOp, alt2type ) {
      return getType( type1 );
   }
   if type2.canEvalWith( processInfo, type1, .SetOp, alt2type ) {
      return getType( type2 );
   }


   let mut mutMode;
   if TypeInfo.isMut( typeInfo ) and TypeInfo.isMut( other ) {
      mutMode = MutMode.Mut;
   }
   else {
      mutMode = MutMode.IMut;
   }
   
   if type1.$kind == type2.$kind {

      fn getCommon( workTypeInfo:&TypeInfo, workOther:&TypeInfo,
                    workAlt2type:Map<&TypeInfo,&TypeInfo> ) __trans : &TypeInfo
      {
         _match TypeInfo.getCommonTypeCombo(
            processInfo, CommonType.Normal( workTypeInfo ),
            CommonType.Normal( workOther ), workAlt2type )
         {
            case .Normal( info ) {
               return info;
            }
            case .Combine( combine ) {
               return combine.get_typeInfo( processInfo );
            }
         }
      }
      
      switch type1.$kind {
         case .List {
            return getType( processInfo.createList(
               .Local, headTypeInfo,
               [ getCommon(
                  type1.$itemTypeInfoList[ 1 ],
                  type2.$itemTypeInfoList[ 1 ], alt2type ) ], mutMode ) );
         }
         case .Array {
            return getType( processInfo.createArray(
               .Local, headTypeInfo,
               [ getCommon(
                  type1.$itemTypeInfoList[ 1 ],
                  type2.$itemTypeInfoList[ 1 ], alt2type ) ], mutMode ) );
         }
         case .Set {
            return getType( processInfo.createSet(
               .Local, headTypeInfo,
               [ getCommon(
                  type1.$itemTypeInfoList[ 1 ],
                  type2.$itemTypeInfoList[ 1 ], alt2type ) ], mutMode ) );
         }
         case .Map {
            return getType( processInfo.createMap(
               .Local, headTypeInfo,
               getCommon(
                  type1.$itemTypeInfoList[ 1 ],
                  type2.$itemTypeInfoList[ 1 ], alt2type ),
               getCommon(
                  type1.$itemTypeInfoList[ 2 ],
                  type2.$itemTypeInfoList[ 2 ], alt2type ), mutMode ) );
         }
      }
   }
   
   let mut work = type1.$baseTypeInfo;

   while work ~= headTypeInfo {
      if work.canEvalWith( processInfo, type2, .SetOp, alt2type ) {
         // 共通している場合はここで返す。
         if typeInfo.$nilable or other.$nilable {
            work = work.$nilableTypeInfo;
         }
         if not isMutable( mutMode ) {
            work = processInfo.createModifier( work, mutMode );
         }
         return CommonType.Normal( work );
      }
      work = work.$baseTypeInfo;
   }

   // 以降は共通していない場合
   let mut combine = new CombineType( typeInfo );
   return combine.andType( processInfo, CommonType.Normal( other ), alt2type );
}


pub static fn TypeInfo.getCommonType(
   processInfo:ProcessInfo, typeInfo:&TypeInfo,
   other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo> ) : &TypeInfo
{
   _match TypeInfo.getCommonTypeCombo(
      processInfo, CommonType.Normal( typeInfo ), CommonType.Normal( other ), alt2type )
   {
      case .Normal( info ) {
         return info;
      }
      case .Combine( combine ) {
         return combine.get_typeInfo( processInfo );
      }
   }
}


pub override fn DDDTypeInfo.getTxt(
   typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
{
   return self.getTxtWithRaw( "...", typeNameCtrl, importInfo, localFlag );
}

pro override fn DDDTypeInfo.getTxtWithRaw(
   raw:str, typeNameCtrl:&TypeNameCtrl!,
   importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
{
   if self.typeInfo == builtinTypeStem_ {
      if self.$extTypeFlag {
         return "Luaval<...>";
      }
      return "...";
   }
   let typeInfo;
   if self.$extTypeFlag {
      typeInfo = self.typeInfo.$extedType;
   } else {
      typeInfo = self.typeInfo;
   }
   let txt = "...<%s>" (typeInfo.getTxt( typeNameCtrl, importInfo, localFlag ));
   if self.$extTypeFlag {
      return "Luaval<%s>" (txt);
   }
   return txt;
}

/**
genTypeList で示す仮パラメータ型を持つクラス型から、
実パラメータ型を itemTypeInfoList とする GenericTypeInfo を生成する。
*/
pub fn ProcessInfo.createGeneric(
   genSrcTypeInfo:&TypeInfo, itemTypeInfoList:&List<&TypeInfo>,
   moduleTypeInfo:&TypeInfo )  mut : GenericTypeInfo, Scope
{
   return GenericTypeInfo.create(
      self, genSrcTypeInfo, itemTypeInfoList, moduleTypeInfo )**;
}


fn applyGenericList(
   processInfo:ProcessInfo, 
   typeList:&List<&TypeInfo>, alt2typeMap:&Map<&TypeInfo,&TypeInfo>,
   moduleTypeInfo:&TypeInfo ) : &List<&TypeInfo>!, bool
{
   let mut typeInfoList:List<&TypeInfo> = [];
   let mut needNew = false;
   foreach srcType in typeList {
      if! let typeInfo = srcType.applyGeneric(
         processInfo, alt2typeMap, moduleTypeInfo )
      {
         typeInfoList.insert( typeInfo );
         if srcType ~= typeInfo {
            needNew = true;
         }
      }
      else {
         return nil, false;
      }
   }
   return typeInfoList, needNew;
}


pub override fn GenericTypeInfo.applyGeneric(
   processInfo:ProcessInfo, 
   alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ) : &TypeInfo!
{
   if self.genSrcTypeInfo.$kind == .Class  {
      let itemTypeInfoList, newFlag = applyGenericList(
         processInfo, self.$itemTypeInfoList, alt2typeMap, moduleTypeInfo );
      when! itemTypeInfoList {
         if newFlag {
            return (processInfo.createGeneric(
               self.genSrcTypeInfo, itemTypeInfoList, moduleTypeInfo ));
         }
      }
   }
   
   let genSrcTypeInfo = self.genSrcTypeInfo.applyGeneric(
      processInfo, alt2typeMap, moduleTypeInfo );
   if genSrcTypeInfo == self.genSrcTypeInfo {
      return self;
   }
   if not self.hasAlter {
      return self;
   }
   
                                        
   
   Util.errorLog( "no support nest generic -- %s" (self.getTxt(##) ) );
   return nil;
}



pub class AbbrTypeInfo extend TypeInfo {
   pri let typeId: &IdInfo { pub };
   pri let rawTxt:str { pub };

   pub override fn get_imutType(): &TypeInfo {
      return self;
   }
   local override fn set_imutType(typeInfo:&TypeInfo) mut {
   }

   pub override fn get_scope(): &Scope! {
      return nil;
   }

   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }
   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self;
   }
   
   /** 名前空間の親 */
   pub override fn get_parentInfo(): &TypeInfo {
      return headTypeInfo;
   }
   
   local fn __init( processInfo:ProcessInfo, rawTxt:str )
   {
      super( nil, processInfo );

      self.typeId = processInfo.newId( self );
      self.rawTxt = rawTxt;
   }

   pub override fn isModule(): bool {
      return false;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return rawTxt;
   }

   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return false, nil;
   }

   pub override fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      Util.err( "illegal call" );
   }

   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt, nil );
   }

   pub override fn getModule(): &TypeInfo {
      return headTypeInfo;
   }
   pub override fn get_kind(): TypeInfoKind {
      return .Abbr;
   }
   pub override fn get_nilable(): bool {
      return true;
   }
   pub override fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_mutMode(): MutMode {
      return .IMut;
   }
   pub override fn get_accessMode(): AccessMode {
      return .Local;
   }
}

pub let builtinTypeAbbr:&TypeInfo = new AbbrTypeInfo( rootProcessInfo, "##" );
pub let builtinTypeAbbrNone:&TypeInfo = new AbbrTypeInfo( rootProcessInfo, "[##]" );




pub class ExtTypeInfo extend TypeInfo {
   pri let typeId: &IdInfo { pub };
   /** 対応する LuneScript のタイプ。 必ず no-nolable になる。 */
   pri let extedType: &TypeInfo { pub };
   pri let nilableTypeInfo: TypeInfo { pub& };
   pri let mut imutType:&TypeInfo {pub,local};

   local override fn get_nilableTypeInfoMut() mut: TypeInfo {
      return self.nilableTypeInfo;
   }

   
   local fn __init( processInfo:ProcessInfo, extedType:&TypeInfo )
   {
      super( nil, processInfo );

      self.typeId = processInfo.newId( self );
      self.extedType = extedType;
      self.imutType = headTypeInfo;

      self.nilableTypeInfo = new NilableTypeInfo( processInfo, self );
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "Luaval<%s>" ( self.extedType.getTxtWithRaw( rawTxt, typeNameCtrl,
                                                         importInfo, localFlag ) );
   }

   pub override fn equals(
      processInfo:&ProcessInfo, typeInfo: &TypeInfo,
      alt2type:Map<&TypeInfo,&TypeInfo>!, checkModifer:bool! ): bool
   {
      if! let extTypeInfo = typeInfo@@@ExtTypeInfo {
         return self.extedType.equals(
            processInfo, extTypeInfo.extedType, alt2type, checkModifer );
      }
      if failCreateLuavalWith( self.extedType, .InLua, false ) {
         return false;
      }
      return self.extedType.equals(
         processInfo, typeInfo, alt2type, checkModifer );
   }

   
   pub override fn canEvalWith(
      processInfo:&ProcessInfo, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      if! let extTypeInfo = other.$nonnilableType@@@ExtTypeInfo {
         let otherExtedType;
         if other.$nilable {
            otherExtedType = extTypeInfo.extedType.$nilableTypeInfo;
         } else {
            otherExtedType = extTypeInfo.extedType;
         }
         return self.extedType.canEvalWith(
            processInfo, otherExtedType, canEvalType, alt2type )**;
      }
      if other.$nilable {
         return false, nil;
      }
      
      if! failCreateLuavalWith( other, .ToLua, true ) {
         return false, _exp;
      }
      return true, nil;
      // if canEvalType == .SetEq {
      //    return false, nil;
      // }
      // return self.extedType.canEvalWith( other, canEvalType, alt2type )**;
   }

   pub override fn serialize( stream: oStream, serializeInfo: &SerializeInfo ) {
      stream.write(
         '{ skind = %d, typeId = %d, extedTypeId = %s }\n' (
            SerializeKind.Ext, self.typeId.id,
            serializeInfo.serializeId( self.extedType.$typeId ) ) );
   }

   pub override fn get_display_stirng_with(
      raw:str, alt2type:&Map<&TypeInfo,&TypeInfo>! ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt, nil );
   }

   pub override fn getModule(): &TypeInfo {
      return headTypeInfo;
   }
   pub override fn get_kind(): TypeInfoKind {
      return .Ext;
   }
   pub override fn get_aliasSrc() : &TypeInfo {
      return self;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_nonnilableType(): &TypeInfo {
      return self;
   }
   pub override fn get_nilable(): bool {
      return false;
   }
   pub override fn applyGeneric(
      processInfo:ProcessInfo, alt2typeMap:&Map<&TypeInfo,&TypeInfo>,
      moduleTypeInfo:&TypeInfo ) : &TypeInfo!
   {
      let typeInfo = self.extedType.applyGeneric(
         processInfo, alt2typeMap, moduleTypeInfo );
      if typeInfo ~= self.extedType {
         Util.err( "not support generics -- %s" (self.extedType.getTxt(##) ) );
      }
      return self;
   }
   

   advertise extedType;
}


//pub static fn NormalTypeInfo.createLuaval( luneType:&TypeInfo ) : LuavalResult
pub fn ProcessInfo.createLuaval(
   luneType:&TypeInfo, validToCheck:bool ) mut : LuavalResult
{
   if not self.validExtType {
      return .OK( luneType, true );
   }

   
   if luneType.$kind == .Method {
      return .OK( luneType, true );
   }
   if isExtType( luneType ) {
      return .OK( luneType, true );
   }
   if! let extType = self.$typeInfo2Map.ExtMap[ luneType ] {
      if extType.$typeId.id < userStartId and luneType.$typeId.id >= userStartId {
         Util.err( "on cache" );
      }
      if extType.$kind == .Ext {
         return .OK( extType, false );
      }
      return .OK( extType, true );
   }

   fn updateCache( typeInfo:&TypeInfo ) {
      self.$typeInfo2Map.ExtMap[ luneType.$nonnilableType ] =
      typeInfo.$nonnilableType;
      self.$typeInfo2Map.ExtMap[ luneType.$nilableTypeInfo ] =
      typeInfo.$nilableTypeInfo;
   }
   
   fn process() : LuavalResult {
      if! let dddType = luneType@@@DDDTypeInfo {
         _match self.createLuaval( dddType.$typeInfo, validToCheck ) {
            case .Err( mess ) {
               Util.err( mess );
            }
            case .OK( workType, _ ) {
               return .OK( self.createDDD(
                  workType, dddType.$externalFlag, true ), false );
            }
         }
      }
      let err:str!, canConv:bool;
      err, canConv = failCreateLuavalWith( luneType, .InLua, validToCheck );
      when! err {
         return .Err( err );
      }
      if canConv {
         return .OK( luneType, true );
      }
      let mut extType = new ExtTypeInfo( self, luneType.$nonnilableType );

      // setupImut の前に updateCache() する。
      // これをしないと、 setupImut() 内の createModifier() から createLuaval() が
      // コールされ、ループしてスタックオーバーフローする。
      updateCache( extType );
      self.setupImut( extType );
      
      
      if luneType.$nilable {
         return .OK( extType.$nilableTypeInfo, false );
      }
      return .OK( extType, false );
   }
   let result = process();
   match result {
      case .OK( typeInfo, _ ) {
         updateCache( typeInfo );
      }
   }
   return result;
}

pub let builtinTypeLua:&TypeInfo;
match rootProcessInfo.createLuaval( builtinTypeStem, true ) {
   case .OK ( typeInfo, _ ) {
      builtinTypeLua = typeInfo;
   }
   default {
      Util.err( "illegal" );
   }
}
registBuiltin( "Luaval", "Luaval", .Ext, builtinTypeLua, nil, headTypeInfo, nil );
pub let builtinTypeDDDLua:&TypeInfo =
   rootProcessInfo.createDDD( builtinTypeStem_, true, true );
registBuiltin( "__LuaDDD", "__LuaDDD", .Ext, builtinTypeDDDLua, nil, headTypeInfo, nil );

pub fn convToExtTypeList(
   processInfo:ProcessInfo, list:&List<&TypeInfo> ) : List<&TypeInfo>!, str
{
   let mut extList:List<&TypeInfo> = [];
   foreach typeInfo in list {
      _match processInfo.createLuaval( typeInfo, true ) {
         case .OK( extType, pass ) {
            extList.insert( extType );
         }
         case .Err( err ) {
            return nil, err;
         }
      }
   }
   return extList, "";
}

/**
and 演算結果の TypeInfo。
hoge and foo or bar の 3 項演算結果の演算結果を得るために使用する。
*/
pub class AndExpTypeInfo extend TypeInfo {
   let exp1:&TypeInfo {pub};
   let exp2:&TypeInfo {pub};
   let result:&TypeInfo {pub};

   pub fn __init( processInfo:ProcessInfo,
                  exp1:&TypeInfo, exp2:&TypeInfo, result:&TypeInfo )
   {
      super( nil, processInfo );
      self.exp1 = exp1;
      self.exp2 = exp2;
      self.result = result;
   }
      
   advertise result;
}


let numberTypeSet:&Set<&TypeInfo> =
    (@
      builtinTypeInt,                          
      builtinTypeChar,                         
      builtinTypeReal
    );

pub fn isNumberType( typeInfo:&TypeInfo ): bool {
   return numberTypeSet.has( typeInfo.$srcTypeInfo );
}


//pub static fn NormalTypeInfo.createEnum(
pub fn ProcessInfo.createEnum(
   scope: Scope, parentInfo: &TypeInfo, typeDataAccessor: TypeDataAccessor, 
   externalFlag: bool, accessMode: AccessMode,
   enumName: str, valTypeInfo:&TypeInfo ) mut : EnumTypeInfo
{
   if Parser.isLuaKeyword( enumName ) {
      Util.err( "This symbol can not use for a enum. -- %s"
                (enumName) );
   }

   let mut info = new EnumTypeInfo(
      self, scope, externalFlag, accessMode, enumName,
      parentInfo, typeDataAccessor, valTypeInfo );
   self.setupImut( info );

   let mut getEnumName = self.createFuncAsync(
      false, true, nil, .Method, info, info,
      true, externalFlag, false, AccessMode.Pub,
      "get__txt", .Async, nil, nil, [ builtinTypeString ], .IMut );
   scope.addMethod( self, nil, getEnumName, AccessMode.Pub, false );

   let mut fromVal = self.createFuncAsync(
      false, true, nil, .Func, info, info,
      true, externalFlag, true, AccessMode.Pub,
      "_from", .Async, nil, [ self.createModifier( valTypeInfo, .IMut ) ],
      [ info.$nilableTypeInfo ], .IMut );
   scope.addMethod( self, nil, fromVal, AccessMode.Pub, true );

   let allListType = self.createList( .Pub, info, [ info ], .IMut );
   let mut allList = self.createFuncAsync(
      false, true, nil, .Func, info, info,
      true, externalFlag, true, AccessMode.Pub,
      "get__allList", .Async, nil, nil,
      [ self.createModifier( allListType, .IMut ) ], .IMut );
   scope.addMethod( self, nil, allList, AccessMode.Pub, true );

   return info;
}

pub override fn EnumTypeInfo.serialize(
   stream: oStream, serializeInfo: &SerializeInfo ) 
{
   let txt = ```{ skind = %d, parentId = %d, typeId = %d, txt = '%s',
accessMode = %d, kind = %d, valTypeId = %d, ```
       ( SerializeKind.Enum,
         self.getParentId().id, self.typeId.id, self.rawTxt,
         self.accessMode, TypeInfoKind.Enum, self.valTypeInfo.$typeId.id );
   stream.write( txt );

   stream.write( "enumValList = {" );
   forsort enumValInfo in self.name2EnumValInfo {
      stream.write( "%s = " (enumValInfo.$name));
      match enumValInfo.$val {
         case .Int( val ) {
            stream.write( "%d," (val) );
         }
         case .Real( val ) {
            stream.write( "%g," (val) );
         }
         case .Str( val ) {
            stream.write( "%q," (val) );
         }
      }
   }
   stream.write( "} }\n" );
}



//pub static fn NormalTypeInfo.createAlge(
pub fn ProcessInfo.createAlge(
   scope: Scope, parentInfo: &TypeInfo, typeDataAccessor: TypeDataAccessor,
   externalFlag: bool,
   accessMode: AccessMode, algeName: str ) mut : AlgeTypeInfo
{
   if Parser.isLuaKeyword( algeName ) {
      Util.err( "This symbol can not use for a alge. -- %s"
                (algeName) );
   }

   let mut info = new AlgeTypeInfo(
      self, scope, externalFlag, accessMode, algeName, parentInfo, typeDataAccessor );
   self.setupImut( info );

   let mut getAlgeName = self.createFuncAsync(
      false, true, nil, .Method, info, info,
      true, externalFlag, false, AccessMode.Pub,
      "get__txt", .Async, nil, nil, [ builtinTypeString ], .IMut );
   scope.addMethod( self, nil, getAlgeName, AccessMode.Pub, false );

   return info;
}

pub override fn AlgeTypeInfo.serialize(
   stream: oStream, serializeInfo: &SerializeInfo ) 
{
   let txt = ```{ skind = %d, parentId = %d, typeId = %d, txt = '%s',
accessMode = %d, kind = %d, ```
       ( SerializeKind.Alge, self.getParentId().id,
         self.typeId.id, self.rawTxt, self.accessMode, TypeInfoKind.Alge );
   stream.write( txt );

   stream.write( "algeValList = {" );
   let mut firstFlag = true;
   forsort algeValInfo in self.valInfoMap {
      if not firstFlag {
         stream.write( "," );
      }
      else {
         firstFlag = false;
      }
      algeValInfo.serialize( stream, serializeInfo );
   }
   stream.write( "} }\n" );
}


// other 型の値を、この型の変数に設定できるか判定する。
pub override fn BoxTypeInfo.canEvalWith(
   processInfo:&ProcessInfo, other:&TypeInfo,
   canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
{
   if self == other {
      return true, nil;
   }
   switch canEvalType {
      case .SetOp, .SetOpIMut, .SetEq {
      }
      default {
         return false, nil;
      }
   }

   if other.$nilable {
      CanEvalCtrlTypeInfo.updateNeedAutoBoxing( alt2type );
      return true, nil;
   }

   if! let otherBoxType = other@@@BoxTypeInfo {
      return self.boxingType.canEvalWith(
         processInfo, otherBoxType.boxingType, canEvalType, alt2type )**;
   }
   

   if self.boxingType.canEvalWith(
      processInfo, other, canEvalType, alt2type ) {
      CanEvalCtrlTypeInfo.updateNeedAutoBoxing( alt2type );
      return true, nil;
   }
   return false, nil;
}


// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NilableTypeInfo.canEvalWith(
   processInfo:&ProcessInfo, other:&TypeInfo,
   canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
{
   //let otherSrc = other.$srcTypeInfo;
   let otherSrc = other;

   if self == builtinTypeStem_ {
      return true, nil;
   }
   
   if otherSrc == builtinTypeNil or otherSrc.$kind == .Abbr {
      if self.$nonnilableType.$kind == .Box {
         return self.$nonnilableType.canEvalWith(
            processInfo, otherSrc, canEvalType, alt2type )**;
      }
      return true, nil;
   }
   if self.typeId.equals( otherSrc.$typeId ) {
      return true, nil;
   }
   if otherSrc.$nilable {
      if otherSrc.$kind == .DDD {
         return self.$nonnilableType.canEvalWith(
            processInfo, otherSrc.$itemTypeInfoList[ 1 ], canEvalType, alt2type )**;
      }
      
      return self.$nonnilableType.canEvalWith(
         processInfo, otherSrc.$nonnilableType, canEvalType, alt2type )**;
   }
   return self.$nonnilableType.canEvalWith(
      processInfo, otherSrc, canEvalType, alt2type )**;
}

macro _checkEqualsItemType(
   type1:sym, type2:sym, index:int, alt2type:sym, destMut:sym, multiFlag:bool )
{
   {
      let retStat1:stat;
      let retStat2:stat;
      
      if multiFlag {
         retStat1 = `{ return false, mess };
         retStat2 = `{ return false, nil };
      }
      else {
         retStat1 = `{ return false };
         retStat2 = `{ return false };
      }
   }
   if #,,type1.$itemTypeInfoList >= ,,index and
      #,,type2.$itemTypeInfoList >= ,,index
   {
      // ここの .SetEq を制御する
      let ret, mess = (,,type1.$itemTypeInfoList[ ,,index ]).canEvalWith(
         processInfo, ,,type2.$itemTypeInfoList[ ,,index ],
         ,,destMut and CanEvalType.SetEq or CanEvalType.SetOpIMut, ,,alt2type );
      if not ret {
         ,,retStat1;
      }
   }
   else {
      ,,retStat2;
   }
};

pub static fn NormalTypeInfo.isAvailableMapping(
   processInfo:&ProcessInfo,
   mut typeInfo:&TypeInfo, checkedTypeMap:Map<&TypeInfo,bool> ): bool
{
   fn isAvailableMappingSub() __trans : bool {
      switch typeInfo.$kind {
         case .Prim, .Enum {
            return true;
         }
         case .Alge {
            let algeTypeInfo = unwrap (typeInfo@@@AlgeTypeInfo);
            foreach valInfo in algeTypeInfo.$valInfoMap {
               foreach paramType in valInfo.$typeList {
                  if not NormalTypeInfo.isAvailableMapping(
                     processInfo, paramType, checkedTypeMap ) {
                     return false;
                  }
               }
            }
            return true;
         }
         case .Stem {
            // stem は mapping 不能なデータもあるが、
            // それは実行時エラーとする。
            return true;
         }
         case .Class, .IF {
            if typeInfo.equals( processInfo, builtinTypeString ##) {
               return true;
            }
            return typeInfo.isInheritFrom( processInfo, builtinTypeMapping, nil );
         }
         case .Alternate {
            return typeInfo.isInheritFrom( processInfo, builtinTypeMapping, nil );
         }
         case .List, .Array, .Set {
            return NormalTypeInfo.isAvailableMapping(
               processInfo, typeInfo.$itemTypeInfoList[1], checkedTypeMap );
         }
         case .Map {
            if NormalTypeInfo.isAvailableMapping(
               processInfo, typeInfo.$itemTypeInfoList[2], checkedTypeMap )
            {
               let keyType = typeInfo.$itemTypeInfoList[1];
               if keyType.equals( processInfo, builtinTypeString ## ) or
                  keyType.$kind == .Prim or keyType.$kind == .Enum
               {
                  return true;
               }
            }
            return false;
         }
         case .Nilable {
            return NormalTypeInfo.isAvailableMapping(
               processInfo, typeInfo.$nonnilableType, checkedTypeMap );
         }
         default {
            return false;
         }
      }
   }

   typeInfo = typeInfo.$srcTypeInfo;
   if! checkedTypeMap[ typeInfo ] {
      return _exp;
   }
   // チェック前は暫定的に true にする
   checkedTypeMap[ typeInfo ] = true;
   let result = isAvailableMappingSub();
   checkedTypeMap[ typeInfo ] = result;
   return result;
}

// other のクラスが、この型のクラスの継承関係にあるか調べる
pub override fn NormalTypeInfo.isInheritFrom(
   processInfo:&ProcessInfo,
   other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool
{
   if self.$typeId.equals( other.$typeId ) {
      return true;
   }
   if ( self.$kind ~= .Class and self.$kind ~= .IF ) or
       ( other.$kind ~= .Class and other.$kind ~= .IF )
   {
      if other == builtinTypeMapping {
         return NormalTypeInfo.isAvailableMapping( processInfo, self, {} ); 
      }
      return false;
   }
   return TypeInfo.isInherit( processInfo, self, other, alt2type );
}


let builtinTypeInfo2Map = rootProcessInfo.$typeInfo2Map.clone();

pub fn createProcessInfo(
   validCheckingMutable:bool, validExtType:bool, validDetailError:bool ) : ProcessInfo
{
   return ProcessInfo.createUser( validCheckingMutable, validExtType,
                                  validDetailError, builtinTypeInfo2Map.clone() );
}

pub fn ProcessInfo.newUser() : ProcessInfo {
   return ProcessInfo.createUser(
      self.validCheckingMutable, self.validExtType,
      self.validDetailError, builtinTypeInfo2Map.clone() );
}


pub form MismatchErrMess(
   index:int, errorMess:str!, 
   dstType:&TypeInfo, srcType:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo> ) __trans :str;

pub enum MatchType {
   Match,
   Warn,
   Error,
}

/**
expTypeList の型から、 dstTypeListOrg の型へ互換性があるかどうか確認する。

@param warnForFollowSrcIndex
   このインデックス以降の expTypeList をチェックする際、
   dstTypeListOrg の型が省略可能な場合 Warn を出す。
@return MatchType 適合結果
@return str メッセージ
*/
static fn TypeInfo.checkMatchTypeMain(
   processInfo:&ProcessInfo, dstTypeList: &List<&TypeInfo>, expTypeList: &List<&TypeInfo>,
   allowDstShort:bool, warnForFollowSrcIndex:int!, alt2type:Map<&TypeInfo,&TypeInfo>,
   mismatchErrMess:MismatchErrMess ) : MatchType, str
{
   macro _checkWarnForFollow( index:sym, dstType:sym, expType:sym ) {
      when! warnForFollowSrcIndex {
         //if warnForFollowSrcIndex <= ,,index and ,,dstType.$nilable {
         if warnForFollowSrcIndex <= ,,index {
            let workMess = "use '**' at arg(%d). %s <- %s"
                ( ,,index, ,,dstType.getTxt( defaultTypeNameCtrl## ),
                  ,,expType.getTxt( defaultTypeNameCtrl## ) );
            return .Warn, workMess;
         }
      }
      if dstType ~= builtinTypeEmpty and
         not isExtType( dstType.$srcTypeInfo.$nonnilableType ) and
         isExtType( expType.$srcTypeInfo.$nonnilableType )
      {
         warnMess = "exp(%d) luaval mismatch %s <- %s" (index, dstType.getTxt(##),
                                                        expType.getTxt(##));
      }
   }


   macro _evalMess( evalMess:__exp ) : str {
      (evalMess and " -- %s" (evalMess) or "")
   }
   
   let mut warnMess:str! = nil;

   

   // index 番以降の dstTypeList の要素が srcType, srcType2nd と等しいか調べる。
   // index 番目と srcType, index + 1 以降と srcType2nd を調べる。
   // dstTypeList[ index ] == srcType
   // dstTypeList[ index + ? ] == srcType2nd
   fn checkDstTypeFrom(
      index:int, srcType:&TypeInfo, srcType2nd:&TypeInfo ) __trans : MatchType, str
   {
      let mut workExpType = srcType;
      for dstIndex = index, #dstTypeList {
         let workDstType = dstTypeList[ dstIndex ];
         let canEval, evalMess = workDstType.canEvalWith(
            processInfo, workExpType, .SetOp, alt2type );
         if not canEval {
            let message = "exp(%d) type mismatch %s <- %s: dst %d%s"
                ( dstIndex, workDstType.getTxt( defaultTypeNameCtrl## ),
                  workExpType.getTxt( defaultTypeNameCtrl## ), dstIndex,
                  _evalMess( evalMess ) );
            return .Error, message;
         }
         elseif workExpType == builtinTypeAbbrNone {
            return .Warn, Code.format( .nothing_define_abbr,
                                       "use '##', instate of '%s'."
                                       (workDstType.getTxt(defaultTypeNameCtrl##)) );
         }

         workExpType = srcType2nd;
      }
      return .Match, "";
   }
   // index 番以降の expTypeList の要素が dstType と等しいか調べる。
   fn checkSrcTypeFrom( index:int, dstType:&TypeInfo ) __trans : MatchType, str
   {
      for srcIndex = index, #expTypeList {
         let expType = expTypeList[ srcIndex ];
         let mut checkType = expType;
         if expType.$kind == .DDD {
            if #expType.$itemTypeInfoList > 0 {
               checkType = expType.$itemTypeInfoList[ 1 ];
            }
            else {
               checkType = builtinTypeStem_;
            }
         }
         elseif srcIndex > index and expType.$kind == .Abbr {
            // 
            return .Error, "must not use '##'";
         }

         let canEval, evalMess = dstType.canEvalWith(
            processInfo, checkType, .SetOp, alt2type );
         if not canEval {
            return .Error, "exp(%d) type mismatch %s <- %s: src: %d%s"
            ( srcIndex, dstType.getTxt( defaultTypeNameCtrl## ),
              expType.getTxt( defaultTypeNameCtrl## ), srcIndex,
              _evalMess( evalMess )  );
         }

         _checkWarnForFollow( srcIndex, dstType, expType );
      }
      return .Match, "";
   }

   if #expTypeList > 0 {
      foreach expType, index in expTypeList {
         if #dstTypeList == 0 {
            return .Error, "over exp. expect:0, actual:%d" ( #expTypeList);
         }
         let dstType = dstTypeList[ index ];
         if #dstTypeList == index {
            // dst の最終引数
            if dstType.$srcTypeInfo.$kind ~= .DDD {
               let isMatch, msg = dstType.canEvalWith(
                  processInfo, expType, .SetOp, alt2type );
               if not isMatch {
                  return .Error, mismatchErrMess( index, msg, dstType,
                                                  expType, alt2type );
               }
               if not allowDstShort and #dstTypeList < #expTypeList {
                  return .Error, "over exp. expect: %d: actual: %d"
                  (#dstTypeList, #expTypeList );
               }
            }
            else {
               // dst の最終引数が ... の場合
               let mut dddItemType = builtinTypeStem_;
               if #dstType.$itemTypeInfoList > 0 {
                  dddItemType = dstType.$itemTypeInfoList[ 1 ];
               }
               let result, mess = checkSrcTypeFrom( index, dddItemType );
               if result ~= .Match {
                  return result, mess;
               }
            }

            _checkWarnForFollow( index, dstType, expType );
            break;
         }
         elseif #expTypeList == index {
            // 最終実引数処理
            let mut srcType = expType;
            let mut srcType2nd = builtinTypeAbbrNone;
            //let mut srcType2nd = builtinTypeNil;
            if expType.$kind == .DDD {
               srcType = builtinTypeStem_;
               srcType2nd = builtinTypeStem_;
               if #expType.$itemTypeInfoList > 0 {
                  srcType = expType.$itemTypeInfoList[ 1 ].$nilableTypeInfo;
                  srcType2nd = srcType;
               }
            }
            elseif expType == builtinTypeAbbr {
               srcType2nd = builtinTypeAbbr;
            }

            let result, mess = checkDstTypeFrom( index, srcType, srcType2nd );
            if result ~= .Match {
               return result, mess;
            }
            _checkWarnForFollow( index, dstType, expType );
            break;
         }
         else {
            let canEval, evalMess = dstType.canEvalWith(
               processInfo, expType, .SetOp, alt2type );
               
            if not canEval {
               return .Error, "exp(%d) type mismatch %s(%s:%d) <- %s(%s:%d)%s"
               ( index,
                 dstType.getTxt( defaultTypeNameCtrl## ),
                 dstType.$kind.$_txt, dstType.$typeId.id,
                 expType.getTxt( defaultTypeNameCtrl## ),
                 expType.$kind.$_txt, expType.$typeId.id,
                 _evalMess( evalMess ) );
            }
            _checkWarnForFollow( index, dstType, expType );
         }
      }
   }
   elseif not allowDstShort {
      foreach dstType, index in dstTypeList {
         if not dstType.canEvalWith( processInfo, builtinTypeNil, .SetOp, alt2type )
         {
            return .Error, "exp(%d) type mismatch %s <- nil: short"
            ( index, dstType.getTxt( defaultTypeNameCtrl## ));
         }
         return .Warn, Code.format( .nothing_define_abbr,
                                    "use '##', instate of '%s'."
                                    (dstType.getTxt( defaultTypeNameCtrl##) ) );
      }
   }

   when! warnMess {
      return .Warn, warnMess;
   }
   
   return .Match, "";
}

pub static fn TypeInfo.checkMatchType(
   processInfo:&ProcessInfo, dstTypeList: &List<&TypeInfo>,
   expTypeList: &List<&TypeInfo>, allowDstShort:bool, warnForFollowSrcIndex:int!,
   alt2type:Map<&TypeInfo,&TypeInfo> ) : MatchType, str
{
   fn mismatchErrMess( index:int, errorMess:str!, dstType:&TypeInfo, srcType:&TypeInfo,
                       alt2typeWork:Map<&TypeInfo,&TypeInfo> )  :str
   {
      // エラーメッセージ用に processInfo を生成する。
      let mut workProcessInfo = ProcessInfo.createUser(
         processInfo.$validCheckingMutable,
         processInfo.$validExtType, processInfo.$validDetailError,
         builtinTypeInfo2Map.clone() );
      let workDstType = applyGenericDefault(
         workProcessInfo, dstType, alt2typeWork, dstType.getModule() );
      let workDstId;
      if isBuiltin( workDstType.$typeId.id ) {
         workDstId = workDstType.$typeId.id;
      } else {
         workDstId = dstType.$typeId.id;
      }
      return "exp(%d) type mismatch %s(%d) <- %s(%d): index %d%s"
          ( index, workDstType.getTxt( defaultTypeNameCtrl## ),
            workDstId, srcType.getTxt(defaultTypeNameCtrl## ),
            srcType.$typeId.id, index,                  
            errorMess and " -- %s" (errorMess) or "(%s)" (dstType.$kind.$_txt));
   }

   return TypeInfo.checkMatchTypeMain(
      processInfo, dstTypeList, expTypeList,
      allowDstShort, warnForFollowSrcIndex, alt2type, mismatchErrMess )**;
}

pub static fn TypeInfo.checkMatchTypeAsync(
   processInfo:&ProcessInfo, dstTypeList: &List<&TypeInfo>, expTypeList: &List<&TypeInfo>,
   allowDstShort:bool, warnForFollowSrcIndex:int!, alt2type:Map<&TypeInfo,&TypeInfo> ) :
   MatchType, str
{
   fn mismatchErrMess( index:int, errorMess:str!, dstType:&TypeInfo, srcType:&TypeInfo,
                       alt2typeWork:Map<&TypeInfo,&TypeInfo> ) __trans :str
   {
      return "exp(%d) type mismatch %s(%d) <- %s(%d): index %d%s"
          ( index, dstType.getTxt( defaultTypeNameCtrl## ),
            dstType.$typeId.id, srcType.getTxt(defaultTypeNameCtrl## ),
            srcType.$typeId.id, index,                  
            errorMess and " -- %s" (errorMess) or "(%s)" (dstType.$kind.$_txt));
   }

   return TypeInfo.checkMatchTypeMain(
      processInfo, dstTypeList, expTypeList,
      allowDstShort, warnForFollowSrcIndex, alt2type, mismatchErrMess )**;
}


/**
typeInfo の関数が、 form と互換があるかどうかチェックする。

form の引数は ... なので、なんでもありになる。
typeInfo の引数がなんでもありでない場合は、互換がなくなるためチェックする。

@param typeInfo チェックする型
*/
fn isSettableToForm( processInfo:&ProcessInfo, typeInfo:&TypeInfo ): bool, str {
   if #typeInfo.$argTypeInfoList > 0 {
      foreach argType, index in typeInfo.$argTypeInfoList {
         if! let dddType = argType@@@DDDTypeInfo {
            if not dddType.$typeInfo.$nilableTypeInfo.equals(
               processInfo, builtinTypeStem_## ) {
               return false, "mismatch arg%d" (index);
            }
         }
         else {
            if not argType.$srcTypeInfo.equals(
               processInfo, builtinTypeStem_ ## ) {
               return false, "mismatch arg%d" (index);
            }
         }
      }
   }
   return true, "";
}

pub static fn TypeInfo.canEvalWithBase(
   processInfo:&ProcessInfo, 
   dest:&TypeInfo, destMut:bool, other:&TypeInfo, canEvalType:CanEvalType,
   alt2type:Map<&TypeInfo,&TypeInfo> ) : bool, str!
{
   // 単純な行番号出力だと、関係ない箇所が変っただけで差分が出るので、
   // この関数の先頭からのオフセットにする。
   // let topLine = __line__;
   // macro _pos() : __exp {
   //    "(err:%d)" (__line__ - topLine)
   // }
   macro _pos() : __exp {
      ""
   }


   // if dest.$asyncMode ~= other.$asyncMode {
   //    return false, "mismatch asyncMode";
   // }
   
   if dest ~= dest.$aliasSrc {
      return dest.$aliasSrc.canEvalWith(
         processInfo, other, canEvalType, alt2type )**;
   }
   
   if dest == builtinTypeExp or dest == builtinTypeMultiExp or
      dest == builtinTypeBlockArg
   {
      if other == builtinTypeMultiExp and dest ~= builtinTypeMultiExp {
         return false, "can't eval from '__exp' to '__exps'.";
      }
      if other.equals( processInfo, builtinTypeAbbr## ) {
         return false, _pos();
      }
      // とりあえず全て OK とする
      return true, nil;
   }
   let otherMut = TypeInfo.isMut( other );
   let mut otherSrc = other.$srcTypeInfo.$aliasSrc;
   if otherSrc.$kind == .DDD {
      if #otherSrc.$itemTypeInfoList > 0 {
         otherSrc = otherSrc.$itemTypeInfoList[ 1 ].$nilableTypeInfo;
      }
      else {
         otherSrc = builtinTypeStem_;
      }
   }

   if otherSrc.$kind == .Alternate {
      if dest.$kind ~= .Alternate {
         otherSrc = AlternateTypeInfo.getAssign( otherSrc, alt2type ).$srcTypeInfo;
      }
   }

   switch canEvalType {
      case .SetEq, .SetOp, .SetOpIMut {
         if dest == builtinTypeEmpty {
            // 代入先の型が確定していない状態
            switch otherSrc {
               case builtinTypeAbbr, builtinTypeAbbrNone {
                  return false, _pos();
               }
            }
            if otherSrc.$kind == .Func {
               // 関数の型推定は未サポート。
               // 関数の代入先は FormFunc あるいは Form であり、
               // それを型推定できないため。
               // 代入先の FormFunc を自動生成すれば対応できなくはないが、
               // その場合は C-lang へのトランスコード対応が必要。
               return false, _pos();
            }
            return true, nil;
         }
         elseif not otherMut and destMut {
            if processInfo.$validCheckingMutable {
               // imut/mut が一致していないものはエラー
               let nonNilOtherType = otherSrc.$nonnilableType;
               switch nonNilOtherType.$kind {
                  case .Set, .Map, .List, .IF, .Alternate {
                     return false, _pos();
                  }
                  case .Class {
                     if builtinTypeString ~= nonNilOtherType {
                        return false, _pos();
                     }
                  }
                  case .Prim {
                     if builtinTypeStem == nonNilOtherType {
                        return false, _pos();
                     }
                  }
               }
            }
         }

         if otherSrc ~= builtinTypeNil and
            otherSrc ~= builtinTypeString and
            otherSrc.$kind ~= .Prim and
            otherSrc.$kind ~= .Func and
            otherSrc.$kind ~= .Method and
            otherSrc.$kind ~= .Form and
            otherSrc.$kind ~= .FormFunc and
            otherSrc.$kind ~= .Enum and
            otherSrc.$kind ~= .Abbr and
            otherSrc.$kind ~= .Alternate and
            otherSrc.$kind ~= .Box and
            not isGenericType( otherSrc ) and
            destMut and not otherMut
         {
            if processInfo.$validCheckingMutable {
               return false, _pos();
            }
         }
      }
   }
   

   if dest == builtinTypeStem_ {
      return true, nil;
   }

   if dest.$srcTypeInfo.$kind == .DDD {
      if #dest.$itemTypeInfoList > 0 {
         return dest.$itemTypeInfoList[ 1 ].canEvalWith(
            processInfo, other, canEvalType, alt2type )**;
      }
      return true, nil;
   }
   if not dest.$nilable and otherSrc.$nilable {
      if canEvalType ~= .Equal {
         if dest.$kind == .Box {
            return dest.canEvalWith(
               processInfo, otherSrc, canEvalType, alt2type )**;
         }
         return false, _pos();
      }
      else {
         otherSrc = otherSrc.$nonnilableType;
      }
   }
   if dest == builtinTypeStem and not otherSrc.$nilable {
      return true, nil;
   }
   if dest == builtinTypeForm and
       ( otherSrc.$kind == .Func or
         otherSrc.$kind == .Form or otherSrc.$kind == .FormFunc )
   {
      if isSettableToForm( processInfo, otherSrc ) {
         return true, nil;
      }
      return false, _pos();
   }
   if otherSrc == builtinTypeNil or otherSrc.$kind == .Abbr {
      if dest.$kind ~= .Nilable {
         return false, _pos();
      }
      return true, nil;
   }
   if dest.$typeId.equals( otherSrc.$typeId ) {
      return true, nil;
   }

   if dest.$kind == .Ext {
      return dest.canEvalWith(
         processInfo, otherSrc, canEvalType, alt2type )**;
   }
   if! let extTypeInfo = otherSrc@@@ExtTypeInfo {
      if canEvalType ~= .SetEq and
         not failCreateLuavalWith( extTypeInfo.$extedType, .ToLua, false )
      {
         otherSrc = extTypeInfo.$extedType;
      }
   }

   if otherSrc.$asyncMode == .Transient {
      if dest.$asyncMode ~= .Transient {
         return false, "mismatch __trans";
      }
   }

   if otherSrc.$typeId.equals( dest.$typeId ) {
      return true, nil;
   }

   
   if dest.$kind ~= otherSrc.$kind {
      if otherSrc.$kind == .Alternate and otherSrc.hasBase() {
         return TypeInfo.canEvalWithBase(
            processInfo, dest, destMut, otherSrc.$baseTypeInfo, canEvalType, alt2type )**;
      }
      
      if dest.$kind == .Nilable {
         let dstNonNil;
         if destMut {
            dstNonNil = dest.$nonnilableType;
         }
         else {
            //dstNonNil = processInfo.createModifier( dest.$nonnilableType, .IMut );
            dstNonNil = dest.$nonnilableType.$imutType;
         }
         
         if otherSrc.$nilable {
            if otherSrc.$kind == .DDD {
               return dstNonNil.canEvalWith(
                  processInfo, otherSrc.$itemTypeInfoList[ 1 ], canEvalType, alt2type )**;
            }
            return dstNonNil.canEvalWith(
               processInfo, otherSrc.$nonnilableType, canEvalType, alt2type )**;
         }
         return dstNonNil.canEvalWith(
            processInfo, otherSrc, canEvalType, alt2type )**;
      }
      elseif isGenericType( dest ) {
         return dest.canEvalWith(
            processInfo, otherSrc, canEvalType, alt2type )**;
      }
      elseif ( dest.$kind == .Class or dest.$kind == .IF ) and
         ( otherSrc.$kind == .Class or otherSrc.$kind == .IF )
      {
         if canEvalType == .SetOp or canEvalType == .SetOpIMut {
            let result = otherSrc.isInheritFrom( processInfo, dest, alt2type );
            if result {
               return result, nil;
            }
            return false, "not inherit %s(%d) <- %s(%d)"
                ( dest.getTxt(##), dest.$typeId.$orgId,
                  otherSrc.getTxt(##), otherSrc.$typeId.$orgId );
         }
         return false, _pos();
      }
      elseif otherSrc.$kind == .Enum {
         let enumTypeInfo = unwrap (otherSrc@@@EnumTypeInfo);
         return dest.canEvalWith(
            processInfo, enumTypeInfo.$valTypeInfo, canEvalType, alt2type )**;
      }
      elseif dest.$kind == .Alternate {
         return dest.canEvalWith(
            processInfo, otherSrc, canEvalType, alt2type )**;
      }
      elseif dest.$kind == .Box {
         return dest.canEvalWith(
            processInfo, otherSrc, canEvalType, alt2type )**;
      }
      elseif dest.$kind == .Form {
         switch otherSrc.$kind {
            case .Form {
               return true, nil;
            }
            case .FormFunc, .Func  {
               if isSettableToForm( processInfo, otherSrc ) {
                  return true, nil;
               }
               return false, _pos();
            }
         }
      }
      elseif dest.$kind == .FormFunc {
         switch otherSrc.$kind {
            case .FormFunc, .Func {
               {
                  let result, mess = TypeInfo.checkMatchTypeAsync(
                     processInfo, dest.$argTypeInfoList, otherSrc.$argTypeInfoList,
                     false, nil, alt2type );
                  if result == .Error {
                     return false, mess;
                  }
               }
               {
                  let result, mess = TypeInfo.checkMatchTypeAsync(
                     processInfo, otherSrc.$argTypeInfoList, dest.$argTypeInfoList,
                     false, nil, alt2type );
                  if result == .Error {
                     return false, mess;
                  }
               }
               {
                  let result, mess = TypeInfo.checkMatchTypeAsync(
                     processInfo, dest.$retTypeInfoList, otherSrc.$retTypeInfoList,
                     false, nil, alt2type );
                  if result == .Error {
                     return false, mess;
                  }
               }
               {
                  let result, mess = TypeInfo.checkMatchTypeAsync(
                     processInfo, otherSrc.$retTypeInfoList, dest.$retTypeInfoList,
                     false, nil, alt2type );
                  if result == .Error {
                     return false, mess;
                  }
               }
               if #dest.$retTypeInfoList ~= #otherSrc.$retTypeInfoList {
                  return false, "argNum %d != %d" ( #dest.$retTypeInfoList,
                                                    #otherSrc.$retTypeInfoList );
               }
               
               return true, nil;
            }
         }
      }
      return false, "illegal type -- %s, %s" (dest.$kind.$_txt, otherSrc.$kind.$_txt);
   }
   // TypeInfoKind が等しい
   switch dest.$kind {
      case .Prim {
         if dest == builtinTypeInt and otherSrc == builtinTypeChar or
            dest == builtinTypeChar and otherSrc == builtinTypeInt
         {
            return true, nil;
         }
         // int から real の代入を暗黙変換を許可すると
         // [ 1, 1.0 ] の型が List<stem> ではなく List<real> なってしまうので
         // 許可しない。
         // if dest == builtinTypeReal and
         //     ( otherSrc == builtinTypeInt or otherSrc == builtinTypeChar )
         // {
         //    return true;
         // }
         return false, _pos();
      }
      case .List, .Array, .Set {
         if otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone {
            // literalMap の [], [@] は互換有りとする
            return true, nil;
         }
         _checkEqualsItemType( dest, otherSrc, 1, alt2type, destMut, true );
         return true, nil;
      }
      case .Map {
         if otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone and
            otherSrc.$itemTypeInfoList[ 2 ] == builtinTypeNone
         {
            // literalMap の {} は互換有りとする
            return true, nil;
         }
         fn check1() __trans : bool! {
            _checkEqualsItemType( dest, otherSrc, 1, alt2type, destMut, false );
            return true;
         }
         fn check2() __trans : bool {
            _checkEqualsItemType( dest, otherSrc, 2, alt2type, destMut, false );
            return true;
         }
         let result1 = check1();
         let result2 = check2();
         if result1 and result2 {
            return true, nil;
         }
         if not result1 and otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone or
            not result2 and otherSrc.$itemTypeInfoList[ 2 ] == builtinTypeNone
         {
            return true, nil;
         }
         return false, _pos();
      }
      case .Class, .IF {
         if isGenericType( dest ) {
            return dest.canEvalWith(
               processInfo, otherSrc, canEvalType, alt2type )**;
         }
         if canEvalType == .SetOp or canEvalType == .SetOpIMut {
            let result = otherSrc.isInheritFrom( processInfo, dest, alt2type );
            if result {
               return result, nil;
            }
            return false, "not inherit %s(%d) <- %s(%d)"
                ( dest.getTxt(##), dest.$typeId.$orgId,
                  otherSrc.getTxt(##), otherSrc.$typeId.$orgId );
         }
         return false, _pos();
         // return otherSrc.isInheritFrom( dest, alt2type );
      }
      case .Form {
         if isSettableToForm( processInfo, otherSrc ) {
            return true, nil;
         }
         return false, _pos();
      }
      case .Func, .FormFunc {
         if #dest.$retTypeInfoList ~= #otherSrc.$retTypeInfoList {
            return false, "argNum %d != %d" ( #dest.$retTypeInfoList,
                                              #otherSrc.$retTypeInfoList );
         }
         let argCheck, argMess = TypeInfo.checkMatchTypeAsync(
            processInfo, dest.$argTypeInfoList,
            otherSrc.$argTypeInfoList, false, nil, alt2type );
         if argCheck == .Error {
            return false, argMess;
         }
         let retCheck, retMess = TypeInfo.checkMatchTypeAsync(
            processInfo, dest.$retTypeInfoList,
            otherSrc.$retTypeInfoList, false, nil, alt2type );
         if retCheck == .Error {
            return false, retMess;
         }
         return true, nil;
      }
      case .Method {
         if #dest.$argTypeInfoList ~= #otherSrc.$argTypeInfoList or
            #dest.$retTypeInfoList ~= #otherSrc.$retTypeInfoList
         {
            return false, _pos();
         }
         foreach argType, index in dest.$argTypeInfoList {
            let otherArgType = otherSrc.$argTypeInfoList[ index ];
            if not argType.equals( processInfo, otherArgType, alt2type, true ) {
               let mess = "unmatch arg(%d) type -- %s, %s"
                   ( index, argType.getTxt(##), otherArgType.getTxt(##) );
               return false, mess;
            }
         }
         foreach retType, index in dest.$retTypeInfoList {
            let otherRetType = otherSrc.$retTypeInfoList[ index ];
            if not retType.equals( processInfo, otherRetType, alt2type, true ) {
               let mess = "unmatch ret(%d) type -- %s, %s, %s"
                   (index, retType.getTxt(##), otherRetType.getTxt(##), dest.getTxt(##) );
               return false, mess;
            }
         }
         if dest.$mutMode ~= otherSrc.$mutMode {
            let mess = "unmatch mutable mode -- %s, %s"
                (dest.$mutMode.$_txt, otherSrc.$mutMode.$_txt );
            return false, mess;
         }
         return true, nil;
      }
      case .Nilable {
         let dstNonNil;
         if destMut {
            dstNonNil = dest.$nonnilableType;
         }
         else {
            //dstNonNil = processInfo.createModifier( dest.$nonnilableType, .IMut );
            dstNonNil = dest.$nonnilableType.$imutType;
         }
         return dstNonNil.canEvalWith(
            processInfo, otherSrc.$nonnilableType, canEvalType, alt2type )**;
      }
      case .Alternate {
         return dest.canEvalWith(
            processInfo, otherSrc, canEvalType, alt2type )**;
      }
      case .Box {
         return dest.canEvalWith(
            processInfo, otherSrc, canEvalType, alt2type )**;
      }
      default {
         return false, _pos();
      }
   }
}


// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NormalTypeInfo.canEvalWith(
   processInfo:&ProcessInfo, other:&TypeInfo,
   canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ) : bool, str!
{
   return TypeInfo.canEvalWithBase(
      processInfo, self, TypeInfo.isMut( self ), other, canEvalType, alt2type )**;
}



pub override fn ModifierTypeInfo.applyGeneric(
   processInfo:ProcessInfo, 
   alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ) : &TypeInfo!
{
   let typeInfo = self.srcTypeInfo.applyGeneric(
      processInfo, alt2typeMap, moduleTypeInfo );
   if typeInfo == self.srcTypeInfo {
      return self;
   }
   when! typeInfo {
      return processInfo.createModifier( typeInfo, .IMut );
   }
   return nil;
}


pub override fn NormalTypeInfo.applyGeneric(
   processInfo:ProcessInfo, 
   alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ) : &TypeInfo!
{
   let! itemTypeInfoList, needNew = applyGenericList(
      processInfo, self.itemTypeInfoList, alt2typeMap, moduleTypeInfo )
   {
      return nil;
   };
   switch self.$kind {
      case .Set {
         if not needNew {
            return self;
         }
         return processInfo.createSet(
            self.accessMode, self.parentInfo, itemTypeInfoList, self.mutMode );
      }
      case .List {
         if not needNew {
            return self;
         }
         return processInfo.createList(
            self.accessMode, self.parentInfo, itemTypeInfoList, self.mutMode );
      }
      case .Array {
         if not needNew {
            return self;
         }
         return processInfo.createArray(
            self.accessMode, self.parentInfo, itemTypeInfoList, self.mutMode );
      }
      case .Map {
         if not needNew {
            return self;
         }
         return processInfo.createMap(
            self.accessMode, self.parentInfo,
            itemTypeInfoList[ 1 ], itemTypeInfoList[ 2 ], self.mutMode );
      }
      // case .Func, .Form, .FormFunc {
      //    let! argTypeInfoList, workArg = applyGenericList(
      //       processInfo, self.argTypeInfoList, alt2typeMap, moduleTypeInfo )
      //    {
      //       return nil;
      //    };
      //    let! retTypeInfoList, workRet = applyGenericList(
      //       processInfo, self.retTypeInfoList, alt2typeMap, moduleTypeInfo )
      //    {
      //       return nil;
      //    };
      //    if needNew or workArg or workRet {
      //       return processInfo.createFunc(
      //          self.abstractFlag, false, nil, self.kind,
      //          self.parentInfo, self.autoFlag, self.externalFlag,
      //          self.staticFlag, self.accessMode, self.rawTxt, self.asyncMode,
      //          itemTypeInfoList, argTypeInfoList, retTypeInfoList, 
      //          TypeInfo.isMut( self ) );
      //    }
      //    return self;
      // }
      default {
         if #self.itemTypeInfoList == 0 {
            return self;
         }
         return nil;
      }
   }
}


pub fn TypeInfo.getFullName(
   typeNameCtrl:&TypeNameCtrl, importInfo:&ModuleInfoManager, localFlag:bool! ) : str
{
   if localFlag and self.isModule() {
      return typeNameCtrl.getModuleName( self, "", importInfo );
   }
   return self.getParentFullName( typeNameCtrl, importInfo, localFlag ) .. self.$rawTxt;
}

pub fn isPrimitive( typeInfo:&TypeInfo ) : bool {
   let srcType = typeInfo.$nonnilableType.$srcTypeInfo;
   switch srcType.$kind {
      case .Prim, .Enum {
         return true;
      }
   }
   if srcType == builtinTypeString {
      return true;
   }
   return false;
}



pub enum BitOpKind {
   And,
   Or,
   Xor,
   LShift,
   RShift,
}

pub let bitBinOpMap = {
   "&": BitOpKind.And,
   "|": BitOpKind.Or,
   "~": BitOpKind.Xor,
   "|>>": BitOpKind.RShift,
   "|<<": BitOpKind.LShift,
};

pub let compOpSet = (@ "==", "~=" );
pub let mathCompOpSet = (@ "<", "<=", ">", ">=" );

pub class RefTypeInfo {
   let pos:Parser.Position {pub};
   let mut itemRefTypeList: List<&RefTypeInfo> {pub};
   let typeInfo:&TypeInfo {pub};
}

class TypeAnalyzer {
   let mut parser:Parser.PushbackParser;
   let parentInfo:&TypeInfo;
   let moduleType:&TypeInfo;
   let moduleScope:&Scope;
   let mut scope:&Scope;
   let scopeAccess:ScopeAccess;
   let mut accessMode: AccessMode;
   let mut parentPub:bool;
   let validMutControl:bool;
   let mut processInfo:ProcessInfo;

   pub fn __init(
      processInfo:ProcessInfo, parentInfo:&TypeInfo, moduleType:&TypeInfo,
      moduleScope:&Scope, scopeAccess:ScopeAccess, validMutControl:bool ) __noasync
   {
      self.processInfo = processInfo;
      self.parentInfo = parentInfo;
      self.moduleType = moduleType;
      self.moduleScope = moduleScope;
      self.scopeAccess = scopeAccess;
      self.validMutControl = validMutControl;

      self.scope = rootScope;
      self.accessMode = .Local;
      self.parentPub = false;
      self.parser = new Parser.DefaultPushbackParser( new Parser.DummyParser() );
   }
   
   pub fn analyzeTypeItemList(
      allowDDD:bool, refFlag: bool, mutFlag: bool,
      typeInfo:&TypeInfo, pos:&Parser.Position ) __noasync mut:
      &RefTypeInfo!, &Parser.Position!, str!;

   fn analyzeTypeSub( allowDDD:bool ) __noasync mut :
      &RefTypeInfo!, &Parser.Position!, str!;

   pub fn analyzeType(
      scope:&Scope, parser:Parser.PushbackParser, accessMode: AccessMode,
      allowDDD:bool, parentPub:bool ) __noasync mut :
      &RefTypeInfo!, &Parser.Position!, str!
   {
      self.scope = scope;
      self.parser = parser;
      self.accessMode = accessMode;
      self.parentPub = parentPub;
      return self.analyzeTypeSub( allowDDD )**;
   }

   pub fn analyzeTypeFromTxt(
      txt:str, scope:&Scope, accessMode: AccessMode, parentPub:bool ) __noasync mut :
      &RefTypeInfo!, &Parser.Position!, str!
   {
      let mut parser = Parser.DefaultPushbackParser.createFromLnsCode( txt, "test" );
      return self.analyzeType( scope, parser, accessMode, true, parentPub )**;
   }
}

pub fn TypeAnalyzer.analyzeTypeSub( allowDDD:bool ) __noasync mut :
   &RefTypeInfo!, &Parser.Position!, str!
{
   let firstToken = self.parser.getTokenNoErr(##);
   let mut token = firstToken;
   let mut refFlag = false;
   if token.txt == "&" {
      refFlag = true;
      token = self.parser.getTokenNoErr(##);
   }
   let mut mutFlag = false;
   if token.txt == "mut" {
      mutFlag = true;
      token = self.parser.getTokenNoErr(##);
   }
   // builtin の型名などは _ で始まることもあるので、シンボル名チェックしない
   // self.checkSymbol( token, .MustNot_ );

   let typeInfo:&TypeInfo;
   if token.txt == "..." {
      // ... は変数シンボルとしても使用するので
      // analyzeExpSymbol で解析すると意図しないシンボルを取ってくる可能性があるため、
      // ここで特別に処理する。
      typeInfo = builtinTypeDDD;
   }
   else {
      let! symbol = self.scope.getSymbolTypeInfo(
         token.txt, self.scope, self.moduleScope, self.scopeAccess )
      {
         return nil, token.pos, "not found type -- " .. token.txt;
      };
      if symbol.$kind ~= .Typ {
         return nil, token.pos, "illegal type -- %s" ( symbol.$name );
      }
      typeInfo = symbol.$typeInfo;
   }
   return self.analyzeTypeItemList(
      allowDDD, refFlag, mutFlag, typeInfo, token.pos )**;
}

pub fn TypeAnalyzer.analyzeTypeItemList(
   allowDDD:bool, refFlag: bool, mutFlag: bool,
   mut typeInfo:&TypeInfo, pos:&Parser.Position ) __noasync mut:
   &RefTypeInfo!, &Parser.Position!, str!
{
   if self.parentPub and
      isPubToExternal( self.accessMode ) and
      not isPubToExternal( typeInfo.$accessMode )
   {
      // 公開する型の中で非公開な型を利用するのは NG
      return nil, pos, "This type must be public. -- %s" (typeInfo.getTxt(##) );
   }
   

   let mut token = self.parser.getTokenNoErr(##);
   
   if token.consecutive and token.txt == "!" {
      typeInfo = typeInfo.$nilableTypeInfo;
      token = self.parser.getTokenNoErr(##);
   }

   macro _checkToken( workToken:sym, oneChar:str ) {
      {}
      if ,,workToken.txt ~= ,,oneChar {
         return nil, ,,workToken.pos, "not found -- ']'";
      }
   }
   
   let mut genericRefList: List<&RefTypeInfo> = [];
   while true {
      if token.txt == '[' or token.txt == '[@' {
         if token.txt == '[' {
            typeInfo = self.processInfo.createList(
               self.accessMode, self.parentInfo, [ typeInfo ], .Mut );
         }
         else {
            typeInfo = self.processInfo.createArray(
               self.accessMode, self.parentInfo, [ typeInfo ], .Mut );
         }
         token = self.parser.getTokenNoErr(##);
         _checkToken( token, ']' );
      }
      elseif token.txt == "<" {
         let mut genericList: List<&TypeInfo> = [];
         let mut nextToken: &Parser.Token = Parser.getEofToken();
         repeat {
            let refType = self.analyzeTypeSub( false );
            when! refType {
               genericRefList.insert( refType );
               genericList.insert( refType.$typeInfo );
            }
            nextToken = self.parser.getTokenNoErr(##);
         } nextToken.txt ~= ",";
         _checkToken( nextToken, '>' );

         macro _checkAlternateTypeCount( count:__exp ) {
            if #genericList ~= ,,count {
               return nil, pos, "generic type count is unmatch. -- %d" (#genericList);
            }
         }

         switch typeInfo.$kind {
            case .Map {
               if #genericList ~= 2 {
                  return nil, pos, "Key or value type is unknown";
               }
               else {
                  typeInfo = self.processInfo.createMap(
                     self.accessMode, self.parentInfo,
                     genericList[ 1 ], genericList[ 2 ], .Mut );
               }
            }
            case .List {
               _checkAlternateTypeCount( 1 );
               typeInfo = self.processInfo.createList(
                  self.accessMode, self.parentInfo, genericList, .Mut );
            }
            case .Array {
               _checkAlternateTypeCount( 1 );
               typeInfo = self.processInfo.createArray(
                  self.accessMode, self.parentInfo, genericList, .Mut );
            }
            case .Set {
               _checkAlternateTypeCount( 1 );
               typeInfo = self.processInfo.createSet(
                  self.accessMode, self.parentInfo, genericList, .Mut );
            }
            case .DDD {
               _checkAlternateTypeCount( 1 );
               typeInfo = self.processInfo.createDDD( genericList[1], false, false );
            }
            case .Class, .IF {
               _checkAlternateTypeCount( #typeInfo.$itemTypeInfoList );
               foreach itemType in genericList {
                  // let altType =
                  //    unwrap typeInfo.$itemTypeInfoList[ index ]@@@AlternateTypeInfo;
                  if itemType.$nilable {
                     let mess = "can't use nilable type -- %s" (itemType.getTxt(##));
                     return nil, pos, mess;
                  }
               }
               typeInfo = self.processInfo.createGeneric(
                  typeInfo, genericList, self.moduleType );
            }
            case .Box {
               _checkAlternateTypeCount( 1 );
               typeInfo = self.processInfo.createBox( self.accessMode, genericList[1] );
            }
            case .Ext {
               _checkAlternateTypeCount( 1 );
               match self.processInfo.createLuaval( genericList[1], true ) {
                  case .OK ( extTypeInfo, _ ) {
                     typeInfo = extTypeInfo;
                  }
                  case .Err( err ) {
                     return nil, pos, err;
                  }
               }
            }
            default {
               return nil , pos, "not support generic: %s" (typeInfo.getTxt(##));
            }
         }
      }
      else {
         self.parser.pushback();
         break;
      }
      token = self.parser.getTokenNoErr(##);
   }
   if token.txt == "!" {
      typeInfo = typeInfo.get_nilableTypeInfo();
      self.parser.getTokenNoErr(##);
   }

   if not allowDDD {
      if typeInfo.$kind == .DDD {
         return nil, pos, "invalid type. -- '%s'" (typeInfo.getTxt(##));
      }
   }

   if refFlag {
      if self.validMutControl {
         typeInfo = self.processInfo.createModifier( typeInfo, .IMut );
      }
   }

   return new RefTypeInfo( pos, genericRefList, typeInfo ), nil, nil;
}

__test case1(ctrl) {
   print( rootProcessInfo.$idProvBase.id, rootProcessInfo.$idProvExt.id );
   
   let builtinMap = {
      "$$": headTypeInfo,
      "Array": builtinTypeArray,
      "List": builtinTypeList,
      "Mapping": builtinTypeMapping,
      "Nilable": builtinTypeBox,
      "Set": builtinTypeSet,
      "form": builtinTypeForm,
      "str": builtinTypeString
   };
   forsort typeInfo, name in builtinMap {
      if not __t._eq( ctrl, typeInfo, rootScope.getTypeInfoChild( name ) ) {
         print( "NG:", name );
      }
   }
   let mut alt2typeMap = CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );

   let mut processInfo = ProcessInfo.createUser(
      true, true, false, builtinTypeInfo2Map.clone() );
   let mut testScope = new Scope( processInfo, rootScope, .Other ## );



   macro _checkTypeAnalyzer(typeTxt:str,typeInfo:__exp ) {
      {}
      {
         let mut analyzer = new TypeAnalyzer(
            processInfo, headTypeInfo, headTypeInfo, testScope, .Normal, true );
         let refType =
            analyzer.analyzeTypeFromTxt( ,,typeTxt, testScope, .Local, false );
         when! refType {
            if not __t._isTM( ctrl, ,,typeTxt,
                              refType.$typeInfo.equals( processInfo, ,,typeInfo ## ) )
            {
               print( refType.$typeInfo.getTxt(##) );
            }
         }
         else {
            __t._err( ctrl, "refType is nil -- " .. ,,typeTxt );
         }
      }
   }
   _checkTypeAnalyzer( "int", builtinTypeInt );
   _checkTypeAnalyzer( "int!", builtinTypeInt.$nilableTypeInfo );
   _checkTypeAnalyzer( "&int", processInfo.createModifier( builtinTypeInt, .IMut ) );
   _checkTypeAnalyzer( "...", builtinTypeDDD );
   _checkTypeAnalyzer( "...<int>", processInfo.createDDD( builtinTypeInt, true, false ) );
   {
      let workType;
      match processInfo.createLuaval( builtinTypeForm, true ) {
         case .OK ( extTypeInfo, _ ) {
            workType = extTypeInfo;
         }
         case .Err( _ ) {
            workType = builtinTypeNone;
         }
      }
      _checkTypeAnalyzer( "Luaval<form>", workType );
   }

   let intListType =
      processInfo.createList( .Local, headTypeInfo, [ builtinTypeInt ], .Mut );
   _checkTypeAnalyzer( "List<int>", intListType );
   _checkTypeAnalyzer( "List<int>!", intListType.$nilableTypeInfo );

   fn getType( typeTxt:str ) __noasync :&TypeInfo! {
      let mut analyzer = new TypeAnalyzer(
         processInfo, headTypeInfo, headTypeInfo, testScope, .Normal, true );
      let refType = analyzer.analyzeTypeFromTxt( typeTxt, testScope, .Local, false );
      return refType$.$typeInfo;
   }

   // type2 から type1 の型への canEvalWith() の結果が ok になるか ng になるか。
   // 別の表現をすると type2 から type1 への代入が出来るかどうか。出来る場合は OK
   macro _checkCanEvalWith(type1:str,type2:str,exp:str) {
      {
         let opSym:str;
         if exp == "OK" {
            opSym = "_isTM";
         }
         else {
            opSym = "_isNotTM";
         }
      }
      {
         if! let typeInfo1, typeInfo2 = getType( ,,type1 ), getType( ,,type2 ) {
            __t.,,,opSym(
               ctrl, "%s <- %s" (,,type1, ,,type2),
               (typeInfo1.canEvalWith( processInfo, typeInfo2, .SetOp, alt2typeMap )));
         }
         else {
            __t._err( ctrl, "not found type -- %s, %s" (,,type1, ,,type2) );
         }
      }
   }

   // int 同士の canEvalWith
   _checkCanEvalWith( "int", "int", "OK" );
   _checkCanEvalWith( "int!", "int", "OK" );
   _checkCanEvalWith( "int", "int!", "NG" );
   _checkCanEvalWith( "&int", "int", "OK" );
   _checkCanEvalWith( "&int!", "int", "OK" );
   _checkCanEvalWith( "int", "&int", "OK" ); // int は int <- &int が可能
   _checkCanEvalWith( "int", "&int!", "NG" );


   // int と str の canEvalWith
   _checkCanEvalWith( "int", "str", "NG" );
   _checkCanEvalWith( "int!", "str", "NG" );
   _checkCanEvalWith( "int", "str!", "NG" );
   _checkCanEvalWith( "&int", "str", "NG" );
   _checkCanEvalWith( "&int!", "str", "NG" );
   _checkCanEvalWith( "int", "&str", "NG" );
   _checkCanEvalWith( "int", "&str!", "NG" );


   // Super と Sub の canEvalWith
   let superType = processInfo.createClassAsync(
      true, false, new Scope( processInfo, rootScope, .Class ## ),
      nil, nil, [], headTypeInfoMut, headTypeInfoMut, false, .Local, "Super" );
   testScope.addClass( processInfo, "Super", nil, superType );   
   let subType = processInfo.createClassAsync(
      true, false, new Scope( processInfo, rootScope, .Class ## ),
      superType, nil, [], headTypeInfoMut, headTypeInfoMut, false, .Local, "Sub" );
   testScope.addClass( processInfo, "Sub", nil, subType );   

   _checkCanEvalWith( "Super", "Sub", "OK" );
   _checkCanEvalWith( "Super", "Sub!", "NG" );
   _checkCanEvalWith( "Super!", "Sub", "OK" );
   _checkCanEvalWith( "Super!", "Sub!", "OK" );
   _checkCanEvalWith( "&Super", "Sub", "OK" );
   _checkCanEvalWith( "&Super", "Sub!", "NG" );
   _checkCanEvalWith( "&Super!", "Sub", "OK" );
   _checkCanEvalWith( "&Super!", "Sub!", "OK" );
   _checkCanEvalWith( "Super", "&Sub", "NG" );
   _checkCanEvalWith( "Super", "&Sub!", "NG" );
   _checkCanEvalWith( "&Super", "&Sub", "OK" );
   _checkCanEvalWith( "&Super", "&Sub!", "NG" );
   _checkCanEvalWith( "&Super!", "&Sub", "OK" );
   _checkCanEvalWith( "&Super!", "&Sub!", "OK" );
   

   // List<int> 同士の canEvalWith
   _checkCanEvalWith( "List<int>", "List<int>", "OK" );
   _checkCanEvalWith( "List<int>!", "List<int>", "OK" );
   _checkCanEvalWith( "List<int>", "List<int>!", "NG" );
   _checkCanEvalWith( "&List<int>", "List<int>", "OK" );
   _checkCanEvalWith( "&List<int>!", "List<int>", "OK" );
   _checkCanEvalWith( "List<int>", "&List<int>", "NG" );
   _checkCanEvalWith( "List<int>", "&List<int>!", "NG" );

   // List<int> と List<str> の canEvalWith
   _checkCanEvalWith( "List<int>", "List<str>", "NG" );
   _checkCanEvalWith( "List<int>!", "List<str>", "NG" );
   _checkCanEvalWith( "List<int>", "List<str>!", "NG" );
   _checkCanEvalWith( "&List<int>", "List<str>", "NG" );
   _checkCanEvalWith( "&List<int>!", "List<str>", "NG" );
   _checkCanEvalWith( "List<int>", "&List<str>", "NG" );
   _checkCanEvalWith( "List<int>", "&List<str>!", "NG" );

   // List<Super> と List<Sub> の canEvalWith

   // Mutable な generics は、継承関係のある型パラメータでもエラー
   _checkCanEvalWith( "List<Super>", "List<Sub>", "NG" );
   _checkCanEvalWith( "List<Super>", "List<Sub>!", "NG" );
   _checkCanEvalWith( "List<Super>!", "List<Sub>", "NG" );
   _checkCanEvalWith( "List<Super>!", "List<Sub>!", "NG" );
   _checkCanEvalWith( "List<&Super>", "List<Sub>", "NG" );
   _checkCanEvalWith( "List<&Super>", "List<Sub>!", "NG" );
   _checkCanEvalWith( "List<&Super>!", "List<Sub>", "NG" );
   _checkCanEvalWith( "List<&Super>!", "List<Sub>!", "NG" );
   _checkCanEvalWith( "List<Super>", "List<&Sub>", "NG" );
   _checkCanEvalWith( "List<Super>", "List<&Sub>!", "NG" );
   _checkCanEvalWith( "List<&Super>", "List<&Sub>", "NG" );
   _checkCanEvalWith( "List<&Super>", "List<&Sub>!", "NG" );
   _checkCanEvalWith( "List<&Super>!", "List<&Sub>", "NG" );
   _checkCanEvalWith( "List<&Super>!", "List<&Sub>!", "NG" );

   // Imutable な generics は、継承関係のある型パラメータで OK
   _checkCanEvalWith( "&List<Super>", "List<Sub>", "OK" );
   _checkCanEvalWith( "&List<Super>", "List<Sub>!", "NG" );
   _checkCanEvalWith( "&List<Super>!", "List<Sub>", "OK" );
   _checkCanEvalWith( "&List<Super>!", "List<Sub>!", "OK" );
   _checkCanEvalWith( "&List<&Super>", "List<Sub>", "OK" );
   _checkCanEvalWith( "&List<&Super>", "List<Sub>!", "NG" );
   _checkCanEvalWith( "&List<&Super>!", "List<Sub>", "OK" );
   _checkCanEvalWith( "&List<&Super>!", "List<Sub>!", "OK" );
   _checkCanEvalWith( "&List<Super>", "List<&Sub>", "NG" );
   _checkCanEvalWith( "&List<Super>", "List<&Sub>!", "NG" );
   _checkCanEvalWith( "&List<&Super>", "List<&Sub>", "OK" );
   _checkCanEvalWith( "&List<&Super>", "List<&Sub>!", "NG" );
   _checkCanEvalWith( "&List<&Super>!", "List<&Sub>", "OK" );
   _checkCanEvalWith( "&List<&Super>!", "List<&Sub>!", "OK" );


   // Hoge<int> と Hoge<int> の canEvalWith
   let mut genTypeList:List<AlternateTypeInfo> = [];
   let mut alter = processInfo.createAlternate( true, 1, "T", .Pri, headTypeInfo ## );
   genTypeList.insert( alter );
   let hogeType = processInfo.createClassAsync(
      true, false, new Scope( processInfo, rootScope, .Class ## ),
      nil, nil, genTypeList, headTypeInfoMut, headTypeInfoMut, false, .Local, "Hoge" );
   testScope.addClass( processInfo, "Hoge", nil, hogeType );

   _checkCanEvalWith( "Hoge<int>", "Hoge<int>", "OK" );
   _checkCanEvalWith( "Hoge<int>!", "Hoge<int>", "OK" );
   _checkCanEvalWith( "Hoge<int>", "Hoge<int>!", "NG" );
   _checkCanEvalWith( "&Hoge<int>", "Hoge<int>", "OK" );
   _checkCanEvalWith( "&Hoge<int>!", "Hoge<int>", "OK" );
   _checkCanEvalWith( "Hoge<int>", "&Hoge<int>", "NG" );
   _checkCanEvalWith( "Hoge<int>", "&Hoge<int>!", "NG" );

   // // // Hoge<Super> と Hoge<Super> の canEvalWith
   _checkCanEvalWith( "Hoge<Super>", "Hoge<Super>", "OK" );
   _checkCanEvalWith( "Hoge<Super>!", "Hoge<Super>", "OK" );
   _checkCanEvalWith( "Hoge<Super>", "Hoge<Super>!", "NG" );
   _checkCanEvalWith( "&Hoge<Super>", "Hoge<Super>", "OK" );
   _checkCanEvalWith( "&Hoge<Super>!", "Hoge<Super>", "OK" );
   _checkCanEvalWith( "Hoge<Super>", "&Hoge<Super>", "NG" );
   _checkCanEvalWith( "Hoge<Super>", "&Hoge<Super>!", "NG" );

   // // Hoge<Super> と Hoge<Sub> の canEvalWith

   // Mutable な generics は、継承関係のある型パラメータでもエラー
   _checkCanEvalWith( "Hoge<Super>", "Hoge<Sub>", "NG" );
   _checkCanEvalWith( "Hoge<Super>", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<Super>!", "Hoge<Sub>", "NG" );
   _checkCanEvalWith( "Hoge<Super>!", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<&Super>", "Hoge<Sub>", "NG" );
   _checkCanEvalWith( "Hoge<&Super>", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<&Super>!", "Hoge<Sub>", "NG" );
   _checkCanEvalWith( "Hoge<&Super>!", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<Super>", "Hoge<&Sub>", "NG" );
   _checkCanEvalWith( "Hoge<Super>", "Hoge<&Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<&Super>", "Hoge<&Sub>", "NG" );
   _checkCanEvalWith( "Hoge<&Super>", "Hoge<&Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<&Super>!", "Hoge<&Sub>", "NG" );
   _checkCanEvalWith( "Hoge<&Super>!", "Hoge<&Sub>!", "NG" );
   
   // Imutable な generics は、継承関係のある型パラメータで OK
   _checkCanEvalWith( "&Hoge<Super>", "Hoge<Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<Super>", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "&Hoge<Super>!", "Hoge<Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<Super>!", "Hoge<Sub>!", "OK" );
   _checkCanEvalWith( "&Hoge<&Super>", "Hoge<Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<&Super>", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "&Hoge<&Super>!", "Hoge<Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<&Super>!", "Hoge<Sub>!", "OK" );
   _checkCanEvalWith( "&Hoge<Super>", "Hoge<&Sub>", "NG" );
   _checkCanEvalWith( "&Hoge<Super>", "Hoge<&Sub>!", "NG" );
   _checkCanEvalWith( "&Hoge<&Super>", "Hoge<&Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<&Super>", "Hoge<&Sub>!", "NG" );
   _checkCanEvalWith( "&Hoge<&Super>!", "Hoge<&Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<&Super>!", "Hoge<&Sub>!", "OK" );
}
