/*
MIT License

Copyright (c) 2019 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

_lune_control default_async_all;
//_lune_control use_macro_special_var;

import lune.base.Parser;
import lune.base.Util;
import lune.base.frontInterface;
import lune.base.Ast;
import lune.base.LuneControl;
import lune.base.Types;

class SimpleModuleInfoManager extend (Ast.ModuleInfoManager)
{
   pro let mut moduleInfoManager:&Ast.ModuleInfoManager;
   pri let mut moduleInfoManagerHist:List<&Ast.ModuleInfoManager>;
   
   pub fn __init(moduleInfoManager:&Ast.ModuleInfoManager!) {
      when! moduleInfoManager {
         self.moduleInfoManager = moduleInfoManager;
      }
      else {
         self.moduleInfoManager = Ast.DummyModuleInfoManager.$instance;
      }
      self.moduleInfoManagerHist = [];
   }

   pub fn push( moduleInfoManager:&Ast.ModuleInfoManager ) mut {
      self.moduleInfoManagerHist.insert( self.moduleInfoManager );
      self.moduleInfoManager = moduleInfoManager;
   }

   pub fn pop() mut {
      self.moduleInfoManager = self.moduleInfoManagerHist[ #self.moduleInfoManagerHist ];
      self.moduleInfoManagerHist.remove(##);
   }
   
   advertise moduleInfoManager;
}

pub class Filter<T>  {
   pri let mut moduleInfoManager:SimpleModuleInfoManager;
   pri let typeNameCtrl:&Ast.TypeNameCtrl {pub};
   pri let errorOnDefault:bool;
   pri let mut optStack:List<T> {pub&};

   pro fn __init( errorOnDefault:bool,
                  moduleTypeInfo:&Ast.TypeInfo!,
                  moduleInfoManager:&Ast.ModuleInfoManager! )
   {
      self.errorOnDefault = errorOnDefault;
      self.moduleInfoManager = new SimpleModuleInfoManager( moduleInfoManager );
      fn process ():&Ast.TypeNameCtrl {
         when! moduleTypeInfo {
            return new Ast.TypeNameCtrl( moduleTypeInfo );
         }
         return Ast.defaultTypeNameCtrl;
      };
      self.typeNameCtrl = process();
      self.optStack = [];
   }

   pri fn pushOpt( opt:T ) mut {
      self.optStack.insert( opt );
   }
   pri fn popOpt( opt:T ) mut {
      self.optStack.remove(##);
   }

   pro fn get_moduleInfoManager() : &Ast.ModuleInfoManager {
      return self.moduleInfoManager;
   }

   pub fn getFull( typeInfo:&Ast.TypeInfo, localFlag:bool ) : str {
      return typeInfo.getFullName( self.typeNameCtrl, self.moduleInfoManager, localFlag );
   }
}

/**
制御中断要因。
Node を実行した際に、次の Node に処理が中断せずに遷移するかどうか。

優先度の高い順に宣言する。
*/
pub enum BreakKind {
   /** 遷移する */
   None,
   /** break で中断する */
   Break,
   /** return で中断する */
   Return,
   /** 処理は戻らない */
   NeverRet,
}

pub enum CheckBreakMode {
   /** フローを解析する */
   Normal,
   /** フローを解析する (return 有無の解析)  */
   Return,
   /** フローを解析しない */
   IgnoreFlow,
   /** フローを解析しない (return 有無の解析) */
   IgnoreFlowReturn,
}


pub alge Literal {
   Nil,
   Int( val:int ),
   Real( val:real ),
   Str( val:str ),
   Bool( val:bool ),
   Symbol( val:str ),
   Field( val:&List<str> ),
   LIST( val:&List<&Literal> ),
   ARRAY( val:&List<&Literal> ),
   SET( val:&List<&Literal> ),
   MAP( val:&Map<&Literal,&Literal> ),
}

pub fn getLiteralObj( obj:&Literal ):stem! {
   _match obj {
      case .Nil {
         return nil;
      }     
      case .Int( val ) {
         return val;
      }     
      case .Real( val ) {
         return val;
      }     
      case .Str( val ) {
         return val;
      }     
      case .Bool( val ) {
         return val;
      }     
      case .Symbol( val ) {
         return val;
      }
      case .Field( val ) {
         return val;
      }
      case .LIST( val ) {
         return val;
      }     
      case .ARRAY( val ) {
         return val;
      }     
      case .SET( val ) {
         return val;
      }     
      case .MAP( val ) {
         return val;
      }
   }
}

pub proto abstract class Node;

pub enum NodeVisitMode {
   /** 子ノードがある場合、子ノードに visit する */
   Child,
   /** 子ノードがあっても無視し、同じ階層のノードに visit する */
   Next,
   /** 以降、ノードへの visit は行なわない */
   End,
}

/**
ノードを辿る際のコールバック関数

@param node 現在のノード
@param parent 親ノード
@param releation 親ノードのフィールド名
*/
pub form NodeVisitor( node:&Node, parent:&Node, relation:str, depth:int ): NodeVisitMode;

macro _procVisitor( child:__exp, parent:__exp, name:str ) {
   {}
    if not alreadySet.has( ,,child ) {
       alreadySet.add( ,,child );
       _switch visitor( ,,child, ,,parent, ,,name, depth ) {
          case .Child {
             if not ,,child.visit( visitor, depth + 1, alreadySet ) {
                return false;
             }
          }
          case .End {
             return false;
          }
          case .Next {
             // pass
          }
       }
    }
}


pub abstract class Node {
   pri let managerId: int;
   pri let id: int;
   pri let kind: int { pub };
   /** この Node の領域開始位置 */
   pri let pos: &Parser.Position { pub };
   pri let expTypeList: &List<&Ast.TypeInfo> { pub };
   let mut commentList: List<&Parser.Token>! { pub& };
   let mut tailComment: &Parser.Token! { pub&,pub };
   /** L-Value として扱われる Node の場合 true  */
   pro let allmut isLValue:bool {pub};
   /** このノードがマクロの引数として使用される場合 */
   let macroArgFlag:bool {pub};
   /** testblock 内の Node かどうか。*/
   let inTestBlock:bool {pub};

   pub fn comp( node:&Node ) : int {
      if self.managerId < node.managerId {
         return -1;
      }
      if self.managerId > node.managerId {
         return 1;
      }
      if self.id < node.id {
         return -1;
      }
      if self.id > node.id {
         return 1;
      }
      return 0;
   }

   pub fn getIdTxt() : str {
      return "%d_%d" (self.managerId,self.id);
   }
   
   pub fn get_effectivePos(): &Parser.Position {
      return self.pos;
   }
   
   pub fn setLValue() mut {
      self.isLValue = true;
   }

   pub fn getPrefix() : &Node! {
      return nil;
   }

   pub fn __init(
      managerId:int, id: int, kind: int, pos: &Parser.Position,
      inTestBlock:bool,  macroArgFlag:bool, expTypeList: &List<&Ast.TypeInfo> )
   {
      self.isLValue = false;
      self.managerId = managerId;
      self.id = id;
      self.kind = kind;
      self.pos = pos;
      self.inTestBlock = inTestBlock;
      self.expTypeList = expTypeList;
      self.commentList = nil;
      self.tailComment = nil;
      self.macroArgFlag = macroArgFlag;
   }

   pub fn addComment( commentList: &List<&Parser.Token> ) mut {
      if #commentList ~= 0 {
         let mut workList;
         if! self.commentList {
            workList = _exp;
         }
         else {
            workList = [];
            self.commentList = workList;
         }
         foreach comment in commentList {
            workList.insert( comment );
         }
      }
   }
   
   pub fn get_expType(): &Ast.TypeInfo {
      if #self.expTypeList == 0 {
         return Ast.builtinTypeNone;
      }
      return self.expTypeList[ 1 ];
   }; 

   pro fn addTokenList( list:List<&Parser.Token>, kind:Parser.TokenKind, txt:str ) {
      list.insert( new Parser.Token( kind, txt, self.pos, false ## ) );
   }
   
   pub fn setupLiteralTokenList( list: List<&Parser.Token> ): bool {
      return false;
   }
   
   pub fn getLiteral(): Literal!, str! {
      return nil, nil;
   }
   pub fn processFilter<OPT>( filter: Filter<OPT>, opt:OPT ) {
   }
   /** 代入式の左辺になれるかどうか */
   pub fn canBeLeft(): bool {
      return false;
   };     
   /** 代入式の右辺になれるかどうか */
   pub fn canBeRight( processInfo:Ast.ProcessInfo ): bool {
      return false;
   }
   /** 単体で文になれるかどうか */
   pub fn canBeStatement(): bool {
      return false;
   }
   /**
制御の中断種別を得る。

全てのケースで return で終っている場合や、 error() などをコールしている場合など。

@param checkMode モード
*/
   pub fn getBreakKind( checkMode:CheckBreakMode ): BreakKind {
      return .None;
   }

   pub fn getSymbolInfo(): &List<&Ast.SymbolInfo>;

   /** このノードで nil 条件演算子を使用しているか。 */
   pub fn hasNilAccess(): bool {
      return false;
   }

   /**
_declNodeClass ではカバーできない visit() のカスタマイズ用

@param visitor コールバック
@param depth 階層
@return visit を継続する場合 true
   */ 
   pub fn visitSub( visitor:NodeVisitor, depth:int, alreadySet:Set<&Node> ) : bool {
      return true;
   }

   /** _declNodeClass で自動で定義される。 */
   pub abstract fn visit( visitor:NodeVisitor, depth:int, alreadySet:Set<&Node> ): bool;
}



pub class NamespaceInfo {
   pub let name: str;
   pub let scope: Ast.Scope;
   pub let typeInfo: &Ast.TypeInfo;
}


pub proto abstract class MacroEval;
pub proto class ExpListNode extend Node;
pub proto class DeclArgNode extend Node;
pub proto class BlockNode extend Node;
pub proto class DeclClassNode extend Node;

pub class DeclMacroInfo {
   pri let pubFlag: bool {pub};
   pri let name: &Parser.Token { pub };
   pri let argList: List<&DeclArgNode> { pub };
   /** macro-statment の BlockNode */
   pri let stmtBlock: &BlockNode! { pub };
   /** expand-statemnt の token リスト */
   pri let tokenList: List<&Parser.Token> { pub };
}

let mut nodeKind2NameMapWork: Map<int,str> = {};
let nodeKind2NameMap = nodeKind2NameMapWork;
let mut nodeKindSeed = 0;

fn regKind( name:str ) __noasync : int {
   let kind = nodeKindSeed;
   nodeKindSeed = nodeKindSeed + 1;
   nodeKind2NameMapWork[ kind ] = name;
   return kind;
}

pub fn getNodeKindName( kind: int ): str {
   return unwrap nodeKind2NameMap[ kind ];
}

pro fn Filter.defaultProcess( node: &Node, opt:T ) mut {
   if self.errorOnDefault {
      Util.err( "not implement yet -- %s" ( getNodeKindName( node.$kind ) ) );
   }
}

// let nodeKindNone = regKind( 'None' );
// let nodeKindImport = regKind( 'Import' );
// let nodeKindRoot = regKind( 'Root' );
// let nodeKindRefType = regKind( 'RefType' );
// let nodeKindIf = regKind( 'If' );
// let nodeKindSwitch = regKind( 'Switch' );
// let nodeKindWhile = regKind( 'While' );
// let nodeKindRepeat = regKind( 'Repeat' );
// let nodeKindFor = regKind( 'For' );
// let nodeKindApply = regKind( 'Apply' );
// let nodeKindForeach = regKind( 'Foreach' );
// let nodeKindForsort = regKind( 'Forsort' );
// let nodeKindReturn = regKind( 'Return' );
// let nodeKindBreak = regKind( 'Break' );
// let nodeKindExpNew = regKind( 'ExpNew' );
// let nodeKindExpList = regKind( 'ExpList' );
// let nodeKindExpRef = regKind( 'ExpRef' );
// let nodeKindExpOp2 = regKind( 'ExpOp2' );
// let nodeKindExpCast = regKind( 'ExpCast' );
// let nodeKindExpOp1 = regKind( 'ExpOp1' );
// let nodeKindExpRefItem = regKind( 'ExpRefItem' );
// let nodeKindExpCall = regKind( 'ExpCall' );
// let nodeKindExpCallSuper = regKind( 'ExpCallSuper' );
// let nodeKindExpDDD = regKind( 'ExpDDD' );
// let nodeKindExpParen = regKind( 'ExpParen' );
// let nodeKindExpMacroExp = regKind( 'ExpMacroExp' ); // macro expand
// let nodeKindExpMacroStat = regKind( 'ExpMacroStat' ); // `{}
// let nodeKindBlock = regKind( 'Block' );
// let nodeKindStmtExp = regKind( 'StmtExp' );
// let nodeKindRefField = regKind( 'RefField' );
// let nodeKindDeclVar = regKind( 'DeclVar' );
// let nodeKindDeclFunc = regKind( 'DeclFunc' );
// let nodeKindDeclMethod = regKind( 'DeclMethod' );
// let nodeKindDeclConstr = regKind( 'DeclConstr' );
// let nodeKindDeclMember = regKind( 'DeclMember' );
// let nodeKindDeclArg = regKind( 'DeclArg' );
// let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
// let nodeKindDeclClass = regKind( 'DeclClass' );
// let nodeKindDeclMacro = regKind( 'DeclMacro' );
// let nodeKindLiteralNil = regKind( 'LiteralNil' );
// let nodeKindLiteralChar = regKind( 'LiteralChar' );
// let nodeKindLiteralInt = regKind( 'LiteralInt' );
// let nodeKindLiteralReal = regKind( 'LiteralReal' );
// let nodeKindLiteralArray = regKind( 'LiteralArray' );
// let nodeKindLiteralList = regKind( 'LiteralList' );
// let nodeKindLiteralMap = regKind( 'LiteralMap' );
// let nodeKindLiteralString = regKind( 'LiteralString' );
// let nodeKindLiteralBool = regKind( 'LiteralBool' );
// let nodeKindLiteralSymbol = regKind( 'LiteralSymbol' );

pub class NodeManager {
   let mut nodeKind2NodeList:Map<int,List<&Node>>;
   let mut idSeed:int;
   let mut managerId:int {pub,pub};

   pub fn __init() {
      self.managerId = 0;
      self.idSeed = 0;
      self.nodeKind2NodeList = {};
      foreach _, kind in nodeKind2NameMap {
         if not self.nodeKind2NodeList[ kind ] {
            self.nodeKind2NodeList[ kind ] = [];
         }
      }
   }

   pub fn nextId() mut : int {
      self.idSeed = self.idSeed + 1;
      return self.idSeed;
   }

   pub fn getList(kind:int) : &List<&Node> {
      let! list = self.nodeKind2NodeList[ kind ] {
         return [];
      };
      return list;
   }
   pub fn addNode(node:&Node) mut {
      let! mut list = self.nodeKind2NodeList[ node.$kind ] {
         list = [];
         self.nodeKind2NodeList[ node.$kind ] = list;
      };
      list.insert( node );
   }
   pub fn delNode(node:&Node) mut {
      let! mut list = self.nodeKind2NodeList[ node.$kind ] {
         return;
      };
      let mut findIndex = -1;
      foreach item, index in list {
         if item == node {
            findIndex = index;
            break;
         }
      }
      if findIndex ~= -1 {
         list.remove( findIndex );
      }
   }

   pub fn addFrom( nodeManager:&NodeManager ) mut {
      foreach list, nodeKind in nodeManager.nodeKind2NodeList {
         let! mut dstList = self.nodeKind2NodeList[ nodeKind ] {
            dstList = [];
            self.nodeKind2NodeList[ nodeKind ] = dstList;
         };
         foreach node in list {
            dstList.insert( node );
         }
      }
   }
}

pub class NodeKind {
}


/**
Node を定義するマクロ。

@param baseName Node の名称。 実際には "%sNode" (baseName) になる。
@param superClass 親クラス
@param canBeLeftFlag canBeLeft() の戻り値。
   nil を指定すると、別途 canBeLeft() を定義する必要がある。
@param canBeRightFlag canBeRight() の戻り値。   
   nil を指定すると、別途 canBeRight() を定義する必要がある。
@param canBeStatementFlag canBeStatement() の戻り値。
   nil を指定すると、別途 canBeStatement() を定義する必要がある。
@param fieldInfoList 定義する Node のフィールドのリスト。
   key: フィールド名。 val: フィールドの型名  の Map のリスト。
   フィールドの順番を保証するために、 Map のリストとしている。
   フィールドの順番が、コンストラクタの順番になるため。
   フィールドの型名に Node を含むものは、
   子ノードのフィールドとして visit() で辿る対象とする。
   ただし、フィールド名の先頭に @ があるものは、除外する。
*/
macro _declNodeClass(
   baseName:str, superClass:sym, canBeLeftFlag:bool!, canBeRightFlag:bool!,
   canBeStatementFlag:bool!, fieldInfoList:Map<str,str>[] )
{
   {
      let className = ,,,"%sNode" (baseName);
      let nodeKindSym = ,,,"%s" (baseName);
      let nodeKindGetter = ,,,"get_%s" (baseName);

      let mut nodeKindList:List<str>;
      if! let mut workNodeKindList = __var.nodeKindList {
         nodeKindList = workNodeKindList@@List<str>;
      }
      else {
         nodeKindList = [];
         __var.nodeKindList = nodeKindList;
      };
      let nodeId = #nodeKindList;
      nodeKindList.insert( baseName );

      let mut fieldStatList:stat[] = [];
      let mut argList:stat[] = [];
      let mut argSymList:stat[] = [];
      let mut initStatList:stat[] = [];
      let mut relateStat:stat[] = [];

      let mut visitStatList:List<stat> = [];
      
      foreach fieldInfo in fieldInfoList {
         foreach typeName, workName in fieldInfo {
            let fieldName = workName.gsub( "^@", "" );
            fieldStatList.insert( `{
               pri let mut ,,,fieldName : ,,,typeName { pub };
            });  
            argList.insert( `{ ,,,fieldName: ,,,typeName, } );
            argSymList.insert( `{, ,,,fieldName } );
            initStatList.insert( `{ self.,,,fieldName = ,,,fieldName; } );

            switch fieldName {
               case "nilAccess" {
                  fieldStatList.insert( `{
                     pub override fn hasNilAccess():bool {
                        return self.nilAccess;
                     }
                  });
               }
            }
               
            

            // 子 Node を列挙する処理
            if not workName.find( "^@"## ) {
               if typeName.find( "DeclFuncInfo" ## ) {
                  visitStatList.insert( `{
                     {
                        foreach argNode in self.,,,fieldName~~.$argList {
                           _procVisitor( argNode, self, "arg" );
                        }
                        foreach retTypeNode in self.,,,fieldName~~.$retTypeNodeList {
                           _procVisitor( retTypeNode, self, "retType" );
                        }
                        if! let body = self.,,,fieldName~~.$body {
                           _procVisitor( body, self, ,,fieldName );
                        }
                     }
                  });
               } elseif typeName.find( "Node" ## ) {
                  let oneVisitStat = `{
                     _procVisitor( child, self, ,,fieldName );
                  };

                  fn processNilable( varName:str, statVar:stat ) __trans {
                     if typeName.find( "!$" ## ) {
                        visitStatList.insert( `{
                           {
                              if! let ,,,varName = self.,,,fieldName {
                                 ,,statVar;
                              }
                           }
                        });
                     }
                     else {
                        visitStatList.insert( `{
                           {
                              let ,,,varName = self.,,,fieldName;
                              ,,statVar;
                           }
                        } );
                     }
                  }
                  
                  if typeName.find( "List<" ## ) {
                     let workStat = `{
                        foreach child in list {
                           ,,oneVisitStat;
                        }
                     };
                     processNilable( "list", workStat );
                  }
                  elseif typeName.find( "Map<" ## ) {
                     let workStat = `{
                        foreach val, key in map {
                           {
                              let child = key;
                              ,,oneVisitStat;
                           }
                           {
                              let child = val;
                              ,,oneVisitStat;
                           }
                        }
                     };
                     processNilable( "map", workStat );
                     
                  }
                  else {
                     processNilable( "child", oneVisitStat );
                  }
               }
            }
         }
      }

      fieldStatList.insert( `{
         pub override fn processFilter<OPT>( filter: Filter<OPT>, opt:OPT )  {
            filter.,,,"process%s" (baseName) (self, opt );
         } } );

      when! canBeRightFlag {
         fieldStatList.insert( `{
            pub override fn canBeRight( processInfo:Ast.ProcessInfo ):bool {
               return ,,, canBeRightFlag;
            } } );
      }
      when! canBeLeftFlag {
         fieldStatList.insert( `{
            pub override fn canBeLeft():bool {
               return ,,, canBeLeftFlag;
            } } );
      }
      when! canBeStatementFlag {
         fieldStatList.insert( `{
            pub override fn canBeStatement():bool {
               return ,,, canBeStatementFlag;
            } } );
      }
      
      let superStat = `{
         super( managerId, id, ,,nodeId, pos, inTestBlock, macroArgFlag, typeList );
      };

      if baseName ~= "Block" {
         relateStat.insert( `{
            pub fn Filter. ,,,"process%s" (baseName) ( node: &,,className, opt:T )  mut {
               self.pushOpt( opt );
               self.defaultProcess( node, opt );
               self.popOpt( opt );
            };
         } );
      }
      else {
         relateStat.insert( `{
            pub fn Filter. ,,,"process%s" (baseName) ( node: &,,className, opt:T )  mut;
         } );
      }
      
      relateStat.insert( `{
         pub fn NodeManager. ,,,"get%sList" (,,,,className) () : &List<&,,className> {
            return self.getList( ,,nodeId )@@List<&,,className>;
         }
      } );

      
   }

   pub static fn NodeKind.,,nodeKindGetter (): int {
      return ,,nodeId;
   }
   
   pub proto class ,,className extend ,,superClass;
   regKind( ,,baseName );
   ,,relateStat;
   pub class ,,className extend ,,superClass {
      ,,fieldStatList;
      pro fn __init( managerId:int, id:int, pos: &Parser.Position,
                     inTestBlock:bool, macroArgFlag:bool,   
                     typeList: &List<&Ast.TypeInfo>, ,,argList ) {
         ,,superStat;
         ,,initStatList;
      }
      pub static fn create( nodeMan:NodeManager, pos: &Parser.Position,
                            inTestBlock:bool, macroArgFlag:bool,          
                            typeList: &List<&Ast.TypeInfo>, ,,argList ) : ,,className
      {
         let mut node = new ,,className(
            nodeMan.$managerId,
            nodeMan.nextId(), pos, inTestBlock, macroArgFlag, typeList ,,argSymList );
         nodeMan.addNode( node );
         return node;
      }

      pub override fn visit( visitor:NodeVisitor, depth:int, alreadySet:Set<&Node> ): bool {
         ,,visitStatList;
         return self.visitSub( visitor, depth + 1, alreadySet );
      }
   }
}

_declNodeClass( "None", Node, false, false, true, []);

_declNodeClass( "Shebang", Node, false, false, true,
                [ { "cmd": "str" } ]
);

/** AST からソースに変換する際に、動的にノードを生成する際に使用する */
_declNodeClass( "ConvStat", Node, false, false, false,
                [ { "txt": "str" } ]
);



_declNodeClass( "BlankLine", Node, false, false, true,
                [ { "lineNum": "int" } ]
);
_declNodeClass( "Subfile", Node, false, false, true,
                [ { "usePath": "str!" } ]);
pub enum LazyLoad {
   Off,
   On,
   Auto,
}

pub class ImportInfo {
   let pos:&Parser.Position {pub};
   let modulePath: str {pub};
   let lazy: LazyLoad {pub};
   let assignName: str {pub};
   let assigned: bool {pub};
   let symbolInfo: &Ast.SymbolInfo {pub};
   let moduleTypeInfo: &Ast.TypeInfo {pub};
}
_declNodeClass( "Import", Node, false, false, true,
                [ { "info": "&ImportInfo" } ]
);


pub proto class ProvideNode extend Node;

/**
マクロの expand-statement で使用する変数情報。

マクロの引数か、 macro-statment で宣言した変数。
*/
pub class MacroValInfo {
   /**
変数に格納された値。

この値には、プリミティブな値(int/real/str/bool)か、プリティブな値のリストが格納される。

なお、 型の builtinTypeStat の変数には、 List<str> が格納される。

つまり次の場合、

---
let work:stat = `{ 1 + 1; };
let workList:List<stat> = [ stat ];
---

ここで work に対応する MacroValInfo.val には List<str> のデータが格納され、
ここで workList に対応する MacroValInfo.val には List<List<str>> のデータが格納される。

*/
   pub let val: &stem!;
   //pub let val: stem!;
   /** マクロ内での変数の型 */
   pub let typeInfo: &Ast.TypeInfo;
   /** 実引数のノード。 この変数がマクロの引数の場合に有効。 */
   pub let argNode: &Node!;
}

pub class MacroArgInfo {
   pri let name:str {pub};
   pri let typeInfo: &Ast.TypeInfo {pub};
}

/**
macro-statment に定義した処理を表わす関数。

@param macro-statment 処理に渡す引数を格納したマップ。
       マクロの変数名 → 値。
@return - macro-statment 処理で定義した macro-expand に渡す変数を格納したマップ
       マクロの変数名 → 値。
       macro-expand に渡す変数名 → 値。
*/
pub form macroStatmentProc( macroArg:&Map<str,&stem> ): &Map<str,&stem>;

pub alge MacroStatement {
   /** */
   Import( name:str, argNameList:&List<str>, luaCode:str!, baseDir:str! ),
   Local(Luaval<macroStatmentProc>),
}
pub abstract class MacroInfo {
   let mut func: Luaval<macroStatmentProc>! {pub, pub};
   let symbol2MacroValInfoMap: &Map<str,MacroValInfo> {pub};
   pub abstract fn getArgList():&List<&MacroArgInfo>;
   pub abstract fn getTokenList():&List<&Parser.Token>;
   pub abstract fn get_name():str;
}

_declNodeClass( "Root", Node, false, false, false,
                [ { "children": "&List<&Node>" },
                  { "moduleScope": "&Ast.Scope" },
                  { "globalScope": "&Ast.Scope" },
                  { "useModuleMacroSet": "&Set<&Ast.TypeInfo>" },
                  { "moduleId": "&frontInterface.ModuleId" },
                  { "processInfo": "Ast.ProcessInfo" },
                  { "moduleTypeInfo": "&Ast.TypeInfo" },
                  { "provideNode": "&ProvideNode!" },
                  { "luneHelperInfo": "&frontInterface.LuneHelperInfo" },
                  { "@nodeManager": "&NodeManager" },
                  { "importModule2moduleInfo": "&Map<&Ast.TypeInfo,&frontInterface.ExportInfo>" },
                  { "typeId2MacroInfo": "&Map<&Ast.IdInfo,&MacroInfo>" },
                  { "typeId2ClassMap": "&Map<&Ast.IdInfo,&NamespaceInfo>" } ]
);

pub fn RootNode.set_provide( node: ProvideNode ) mut {
   self.provideNode = node;
}

_declNodeClass( "RefType", Node, false, false, false,
                [ { "name": "&Node" },
                  { "itemNodeList": "&List<&Node>" },
                  { "mutMode": "Ast.MutMode!" },
                  { "array": "str" } ]
);

pub enum BlockKind {
   If,
   Elseif,
   Else,
   While,
   Switch,
   Match,
   Repeat,
   For,
   Apply,
   Foreach,
   Macro,
   Func,
   Default,
   Block,
   Macro,
   LetUnwrap,
   LetUnwrapThenDo,
   IfUnwrap,
   When,
   Test,
   AsyncLock,
}

_declNodeClass( "Block", Node, false, false, true,
                [ { "blockKind": "BlockKind" },
                  { "scope": "&Ast.Scope" },
                  { "stmtList": "List<&Node>" } ]
);

pub enum ScopeKind {
   Root,
}
_declNodeClass( "Scope", Node, false, false, true,
                [ { "scopeKind": "ScopeKind" },
                  { "scope": "&Ast.Scope" },
                  { "symbolList": "&List<&Ast.SymbolInfo>" },
                  { "block": "BlockNode" } ]
);


macro _setBreakKind(work:sym, kind:sym, returnNoneStat:__exp, checkMode:sym ) {
   // {
   //    let noneStat:stat;
   //    if returnNoneStat {
   //       noneStat = `{ return .None };
   //    }
   //    else {
   //       noneStat = `{};
   //    }
   // }
   if ,,checkMode == .IgnoreFlowReturn {
      if ,, work == .Return {
         return .Return;
      }
      if ,, work == .NeverRet {
         return .NeverRet;
      }
   }
   else {
      switch ,,work {
         case .None {
            if ,,checkMode == .Normal or ,,checkMode == .Return {
               if ,,returnNoneStat {
                  return .None;
               }
            }
         }
         default {
            if ,,kind == .None or ,,kind > work {
               kind = work;               
            }
         }
      }
   }
}

fn getBreakKindForStmtList( checkMode:CheckBreakMode, stmtList:&List<&Node> ): BreakKind {
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in stmtList {
         if stmt.$kind ~= NodeKind.$BlankLine {
            let work = stmt.getBreakKind( checkMode );
            _setBreakKind(work, kind, false, checkMode );
         }
      }
      return kind;
   }

   if #stmtList > 0 {
      for index = #stmtList, 1, -1 {
         let stmt = stmtList[ index ];
         if stmt.$kind ~= NodeKind.$BlankLine {
            return stmt.getBreakKind( checkMode );
         }
      }
   }
   return .None;
   
}


pub override fn BlockNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   return getBreakKindForStmtList( checkMode, self.stmtList );
}

pub enum IfKind {
   If,
   ElseIf,
   Else,
}

pub class IfStmtInfo {
   pri let kind: IfKind { pub };
   pri let exp: &Node { pub };
   pri let block: &BlockNode { pub };
}
_declNodeClass( "If", Node, false, false, true,
                [{ "stmtList": "List<&IfStmtInfo>" } ]
);


pub override fn IfNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut hasElseFlag = false;
   let mut kind = BreakKind.None;
   foreach stmtInfo in self.stmtList {
      let work = stmtInfo.$block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      if stmtInfo.$kind == .Else {
         hasElseFlag = true;
      }
   }
   if hasElseFlag or ( checkMode ~= .Normal and checkMode ~= .Return ) {
      return kind;
   }
   
   return .None;
}

pub override fn IfNode.visitSub(
   visitor:NodeVisitor, depth:int, alreadySet:Set<&Node> ) : bool
{
   foreach stmt in self.$stmtList {
      _procVisitor( stmt.$exp, self, "exp" );
      _procVisitor( stmt.$block, self, "block" );
   }
   return true;
}
 
pub class MRetExp {
   /** 多値のノード */
   let exp:&Node {pub};
   /** ExpListNode 中の exp のインデックス */
   let index:int {pub};
}

_declNodeClass( "ExpList", Node, nil, nil, false,
                [ { "expList": "&List<&Node>" },
                  // 多値使用している exp。
                  // nil の場合は多値未使用。
                  { "mRetExp": "&MRetExp!" },
                  // '**' を明示している場合 true。
                  { "followOn": "bool" } ]
);
pub override fn ExpListNode.canBeLeft():bool {
   foreach expNode in self.$expList {
      if not expNode.canBeLeft() {
         return false;
      }
   }
   return true;
}
pub override fn ExpListNode.canBeRight( processInfo:Ast.ProcessInfo ):bool {
   foreach expNode in self.$expList {
      if not expNode.canBeRight( processInfo ) {
         return false;
      }
   }
   return true;
}
pub override fn ExpListNode.setLValue() mut {
   foreach expNode in self.$expList {
      expNode.isLValue = true;
   }
}


/**
この ExpListNode の index 番目の要素の型を返す。

index 番目の型が DDD の場合、DDD を返す。
具体的には ...<int> の場合、 ...<int> を返す。

index がこのリストの要素の数を越えた場合で、
かつ最終要素が DDD の場合、その DDD が保持する型を返す。
具体的には ...<int> の場合、 int! を返す。
*/
pub fn ExpListNode.getExpTypeAt( index:int ) : &Ast.TypeInfo {
   if index > #self.$expTypeList {
      let lastExpType = self.$expTypeList[ #self.$expTypeList ];
      if! let dddTypeInfo = lastExpType@@@Ast.DDDTypeInfo {
         return dddTypeInfo.$typeInfo.$nilableTypeInfo;
      }
      return Ast.builtinTypeNil;
   }
   return self.$expTypeList[ index ];
}

/**
この ExpListNode の index 番目の要素の型を返す。

index 番目の型が DDD の場合、その DDD が保持する型を返す。
具体的には ...<int> の場合、 int! を返す。
index がこのリストの要素の数を越えた場合で、
かつ最終要素が DDD の場合、その DDD が保持する型を返す。
具体的には ...<int> の場合、 int! を返す。
*/
pub fn ExpListNode.getExpTypeNoDDDAt( index:int ) : &Ast.TypeInfo {
   if index >= #self.$expTypeList {
      let lastExpType = self.$expTypeList[ #self.$expTypeList ];
      if! let dddTypeInfo = lastExpType@@@Ast.DDDTypeInfo {
         return dddTypeInfo.$typeInfo.$nilableTypeInfo;
      }
      if index == #self.$expTypeList {
         return lastExpType;
      }
      return Ast.builtinTypeNil;
   }
   return self.$expTypeList[ index ];
}

pub class CaseInfo {
   pri let expList: &ExpListNode { pub };
   pri let block: &BlockNode { pub };
}
pub enum CaseKind {
   /** 全ての条件を網羅していない */
   Lack,
   /** 全ての条件を網羅している */
   Full,
   /** 全ての条件を網羅している必要がある */
   MustFull,
}
_declNodeClass( "Switch", Node, false, false, true,
                [ { "idInNS": "int" },
                  { "exp": "&Node" },
                  { "caseList": "List<&CaseInfo>" },
                  { "default": "&BlockNode!" },
                  // case で全ての条件が網羅されているかどうか
                  { "caseKind": "CaseKind"},
                  // default ブロックがある場合、 default_ で宣言している。
                  { "failSafeDefault": "bool" }
                ]
);

pub override fn SwitchNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   let mut kind = BreakKind.None;
   let fullCase = self.caseKind ~= .Lack;
   foreach caseInfo in self.caseList {
      let work = caseInfo.$block.getBreakKind( checkMode );
      let goNext = (work == .None) or not fullCase;
      _setBreakKind( work, kind, goNext, checkMode );
   }
   if! let block = self.default {
      let work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }

   if fullCase {
      return kind;
   }
   if kind == .Break {
      // いずれかの条件がマッチして break するなら、
      // switch 文の結果を break として扱わないと、
      // while true {} 内の switch が while ループを抜けないことになってしまう。
      // よって fullCase でない場合も break は返す。
      return kind;
   }
   
   return .None;
}

pub override fn SwitchNode.visitSub(
   visitor:NodeVisitor, depth:int, alreadySet:Set<&Node> ) : bool
{
   foreach caseInfo in self.caseList {
      _procVisitor( caseInfo.$expList, self, "expList" );
      _procVisitor( caseInfo.$block, self, "block" );
   }
   return true;
}


macro _declLoopGetBreakKind( node:sym, blockMem:sym ) {

   pub override fn ,,node.getBreakKind( checkMode:CheckBreakMode ): BreakKind
   {  
      //let mut kind = BreakKind.None;
      if checkMode ~= .Normal and checkMode ~= .Return {
         return self. ,,blockMem .getBreakKind( checkMode );
      }
      return .None;
   }  
}

_declNodeClass( "While", Node, false, false, true,
                [ { "exp": "&Node" },
                  { "infinit": "bool" },
                  { "block": "&BlockNode" } ]
);

_declNodeClass( "Repeat", Node, false, false, true,
                [ { "block": "&BlockNode" },
                  { "exp": "&Node" } ]
);

_declLoopGetBreakKind( RepeatNode, block );

_declNodeClass( "For", Node, false, false, true,
                [ { "idInNS": "int" },
                  { "block": "&BlockNode" },
                  { "val": "&Ast.SymbolInfo" },
                  { "init": "&Node" },
                  { "to": "&Node" },
                  { "delta": "&Node!" }] 
);

_declLoopGetBreakKind( ForNode, block );


_declNodeClass( "Apply", Node, false, false, true,
                [ { "idInNS": "int" },
                  { "varList": "&List<&Ast.SymbolInfo>" },
                  { "expList": "&ExpListNode" },
                  { "block": "&BlockNode" } ]
);

_declLoopGetBreakKind( ApplyNode, block );


_declNodeClass( "Foreach", Node, false, false, true,
                [ { "idInNS": "int" },
                  { "val": "&Ast.SymbolInfo" },
                  { "key": "&Ast.SymbolInfo!" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declLoopGetBreakKind( ForeachNode, block );


_declNodeClass( "Forsort", Node, false, false, true,
                [ { "idInNS": "int" },
                  { "val": "&Ast.SymbolInfo" },
                  { "key": "&Ast.SymbolInfo!" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" },
                  { "sort": "bool" } ]
);

_declLoopGetBreakKind( ForsortNode, block );


_declNodeClass( "Return", Node, false, false, true,
                [ { "expList": "&ExpListNode!" } ]
);
pub override fn ReturnNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   return .Return;
}

_declNodeClass( "Break", Node, false, false, true, [] );

pub override fn BreakNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   return .Break;
}

_declNodeClass( "Provide", Node, false, false, true,
                [ { "symbol": "&Ast.SymbolInfo" } ]
);

_declNodeClass( "ExpNew", Node, false, true, true,
                [ { "symbol": "&Node" },
                  { "ctorTypeInfo": "&Ast.TypeInfo" },
                  { "argList": "&ExpListNode!" } ]
);

_declNodeClass( "ExpUnwrap", Node, false, true, false,
                [ { "exp": "&Node" },
                  { "default": "&Node!" } ]
);

_declNodeClass( "ExpRef", Node, nil, nil, false,
                //[ { "symbolInfo": "&Ast.SymbolInfo" } ]
                [ { "symbolInfo": "&Ast.SymbolInfo" } ]
);

pub override fn ExpRefNode.canBeLeft():bool {
   return self.$symbolInfo.$canBeLeft;
}

pub override fn ExpRefNode.canBeRight( processInfo:Ast.ProcessInfo ):bool {
   return self.$symbolInfo.$canBeRight and self.$symbolInfo.$hasValueFlag;
   //return self.$symbolInfo.$canBeRight;
}

/**
値の設定

リスト、マップの要素の設定は、 このノードではなく ExpSetItem で管理する。
*/
_declNodeClass( "ExpSetVal", Node, false, false, true,
                [ { "exp1": "&Node" },
                  { "exp2": "&ExpListNode" },
                  // 代入先のシンボルリスト
                  { "LeftSymList": "&List<&Ast.SymbolInfo>" },
                  // この代入によって値を初期化されるシンボル
                  { "initSymSet": "&Set<&Ast.SymbolInfo>" } ]
);

pub alge IndexVal {
   NodeIdx( &Node ),
   SymIdx( str ),
}

// 要素の設定
_declNodeClass( "ExpSetItem", Node, false, false, true,
                // 要素を保持する値
                [ { "val": "&Node" },
                  // 要素のインデックス
                  { "index": "IndexVal" },
                  // 設定する値
                  { "exp2": "&Node" }
                ]
);

_declNodeClass( "ExpOp2", Node, false, true, false,
                [ { "op": "&Parser.Token" },
                  { "exp1": "&Node" },
                  { "exp2": "&Node" } ]
);

_declNodeClass( "UnwrapSet", Node, false, false, true,
                [ { "dstExpList": "&ExpListNode" },
                  { "srcExpList": "&ExpListNode" },
                  { "unwrapBlock": "&BlockNode!" } ]              
);

_declNodeClass( "IfUnwrap", Node, false, false, true,
                [ { "varSymList": "&List<&Ast.SymbolInfo>" },
                  { "expList": "&ExpListNode" },
                  { "block": "&BlockNode" },
                  { "nilBlock": "&BlockNode!" } ]
);

pub override fn IfUnwrapNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut kind = self.block.getBreakKind( checkMode );
   let mut work = kind;
   _setBreakKind( work, kind, true, checkMode );
   if! let block = self.nilBlock {
      work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }
   return .None;
}


pub class UnwrapSymbolPair {
   let src:&Ast.SymbolInfo {pub};
   let dst:&Ast.SymbolInfo {pub};
}

_declNodeClass( "When", Node, false, false, true,
                [ //{ "varNameList": "List<&str>" },
                  //{ "expNodeList": "List<&Node>" },
                  { "symPairList": "List<&UnwrapSymbolPair>" },
                  { "block": "&BlockNode" },
                  { "elseBlock": "&BlockNode!" } ]
);

pub override fn WhenNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut kind = self.block.getBreakKind( checkMode );
   let mut work = kind;
   _setBreakKind( work, kind, true, checkMode );
   if! let block = self.elseBlock {
      work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }
   return .None;
}

pub enum CastKind {
   /** 通常キャスト */
   Normal,
   /** 強制キャスト */
   Force,
   /** 暗黙キャスト */
   Implicit,
}

/**
ExpCastNode の expType は、 castKind によって異なる。

具体的には、
Implicit の場合、 exp の型がそのまま入る。
Implicit 以外の場合、キャスト後の型が入る。
*/
_declNodeClass( "ExpCast", Node, false, true, false,
                [ { "exp": "&Node" },
                  // キャスト後の型
                  { "castType": "&Ast.TypeInfo" },
                  // キャスト後の型を指定している Node。
                  // ソース上に指定がない場合は nil。
                  { "castTypeNode": "&RefTypeNode!" },
                  { "castOpe" : "str" },
                  { "castKind": "CastKind" } ]
);

pub override fn ExpCastNode.getPrefix() : &Node! {
   return self.exp.getPrefix();
}
pub override fn ExpCastNode.getLiteral(): Literal!, str! {
   return self.exp.getLiteral()**;
}
pub override fn ExpCastNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   return self.exp.setupLiteralTokenList( list );
}



_declNodeClass( "ExpToDDD", Node, false, true, false,
                //[ { "expList": "&List<&Node>" } ]
                [ { "expList": "&ExpListNode" } ]
);

_declNodeClass( "ExpSubDDD", Node, false, true, false,
                [ { "src": "&Node" },
                  { "remainIndex": "int" } ]
);


pub enum MacroMode {
   /** マクロ処理なし */
   None,
   /** マクロの展開モード */
   Expand,
   /** マクロ呼び出し時の引数解析モード */
   AnalyzeArg,
}

_declNodeClass( "ExpOp1", Node, false, true, false,
                [ { "op": "&Parser.Token" },
                  { "macroMode": "MacroMode" },
                  { "exp": "&Node" } ]
);

_declNodeClass( "ExpRefItem", Node, nil, true, false,
                [ { "val": "&Node" },
                  { "nilAccess": "bool" },
                  { "symbol": "str!" },
                  { "index": "&Node!" } ]
);
pub override fn ExpRefItemNode.getPrefix() : &Node! {
   return self.val;
}
pub override fn ExpRefItemNode.canBeLeft(): bool {
   if self.val.$expType == Ast.builtinTypeStem {
      return false;
   }
   //return self.$expType.$mutable;
   return Ast.TypeInfo.isMut( self.$val.$expType ) and not self.nilAccess;
}

_declNodeClass( "ExpCall", Node, false, nil, true,
                [ { "func": "&Node" },
                  { "errorFunc": "bool" },
                  { "nilAccess": "bool" },
                  { "argList": "&ExpListNode!" } ]
);
pub override fn ExpCallNode.get_effectivePos(): &Parser.Position {
   return self.func.$effectivePos;
}
pub override fn ExpCallNode.getPrefix() : &Node! {
   return self.func;
}

pub override fn ExpCallNode.canBeRight( processInfo:Ast.ProcessInfo ):bool {
   let expType = self.$expType;
   if expType.equals( processInfo, Ast.builtinTypeNone## ) or
      expType.equals( processInfo, Ast.builtinTypeNeverRet## )
   {
      return false;
   }
   return true;
}


pub override fn ExpCallNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   if self.errorFunc {
      return .NeverRet;
   }
   return .None;
}

// 多値戻り値の先頭
_declNodeClass( "ExpMRet", Node, false, true, false,
                [ { "mRet": "&Node" } ]
);
pub override fn ExpMRetNode.getPrefix(): &Node! {
   return self.mRet.getPrefix();
}

// 多値戻り値の index 番目 ( index >= 2 )
_declNodeClass( "ExpAccessMRet", Node, false, true, false,
                [ { "mRet": "&Node" },
                  { "index": "int" } ]
);
pub override fn ExpAccessMRetNode.getPrefix() : &Node! {
   return self.mRet.getPrefix();
}
// 多値戻り値の先頭だけ使用する場合
_declNodeClass( "ExpMultiTo1", Node, false, true, false,
                [ { "exp": "&Node" } ]
);
pub override fn ExpMultiTo1Node.getPrefix() : &Node! {
   return self.exp.getPrefix();
}

_declNodeClass( "ExpParen", Node, false, true, false,
                [ { "exp": "&Node" } ]
);
pub override fn ExpParenNode.getPrefix() : &Node! {
   return self.exp.getPrefix();
}

pub override fn ExpParenNode.getSymbolInfo(): &List<&Ast.SymbolInfo> {
   return self.exp.getSymbolInfo();
}


/** マクロ展開後のノード */
_declNodeClass( "ExpMacroExp", Node, false, nil, true,
                [ { "macroType": "&Ast.TypeInfo" },
                  { "stmtList": "List<&Node>" } ]
);

pub override fn ExpMacroExpNode.canBeRight( processInfo:Ast.ProcessInfo ):bool {
   return self.$expType ~= Ast.builtinTypeNone;
}

pub override fn ExpMacroExpNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   return getBreakKindForStmtList( checkMode, self.stmtList );
}

pub enum MacroStatKind {
   Stat,
   Exp,
}

_declNodeClass( "ExpMacroStat", Node, false, true, false,
                [ { "expStrList": "List<&Node>" } ]
);

_declNodeClass( "ExpMacroArgExp", Node, false, true, false,
                [ { "codeTxt": "str" } ]
);


_declNodeClass( "StmtExp", Node, false, true, nil,
                [ { "exp": "&Node" } ]
);
pub override fn StmtExpNode.canBeStatement():bool {
   return self.$exp.canBeStatement();
}

pub override fn StmtExpNode.getBreakKind( checkMode:CheckBreakMode ):BreakKind {
   return self.$exp.getBreakKind( checkMode );
}

_declNodeClass( "ExpMacroStatList", Node, false, true, false,
                [ { "exp": "&Node" } ]
);


_declNodeClass( "ExpOmitEnum", Node, true, true, false,
                [ { "valToken": "&Parser.Token" },
                  { "valInfo": "&Ast.EnumValInfo" },
                  { "aliasType": "&Ast.AliasTypeInfo!" },
                  { "enumTypeInfo": "&Ast.EnumTypeInfo" }]
);

_declNodeClass( "RefField", Node, nil, nil, false,
                [ { "field": "&Parser.Token" },
                  //{ "overrideCanBeLeft": "bool!" },
                  { "symbolInfo": "&Ast.SymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "&Node" }] 
);
pub override fn RefFieldNode.get_effectivePos(): &Parser.Position {
   return self.field.pos;
}
pub override fn RefFieldNode.getPrefix() : &Node! {
   return self.prefix;
}
pub override fn RefFieldNode.canBeLeft():bool {
   // if not Ast.isMutable( self.prefix.$expType.$mutMode ) {
   //    if self.$symbolInfo$.$mutMode == .AllMut {
   //       return true;
   //    }
   //    return false;
   // }
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return false;
}
pub override fn RefFieldNode.canBeRight( processInfo:Ast.ProcessInfo ):bool {
   if! self.$symbolInfo {
      if! let prefix = self.$prefix@@@ExpRefNode {
         if prefix.$symbolInfo.$name == "self" {
            // コンストラクタでメンバ初期化前にアクセスできないように
            return _exp.$canBeRight and _exp.$hasValueFlag;
         }
      }
      return _exp.$canBeRight;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return true;
}

_declNodeClass( "GetField", Node, false, true, false,
                [ { "field": "&Parser.Token" },
                  //{ "overrideCanBeLeft": "bool!" },
                  { "symbolInfo": "&Ast.SymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "&Node" },
                  { "getterTypeInfo": "&Ast.TypeInfo" } ]               
);
pub override fn GetFieldNode.get_effectivePos(): &Parser.Position {
   return self.field.pos;
}
pub override fn GetFieldNode.getPrefix() : &Node! {
   return self.prefix;
}



_declNodeClass( "Alias", Node, false, false, true,
                [ {"newSymbol": "&Ast.SymbolInfo" },
                  {"srcNode": "&Node" },
                  {"typeInfo": "&Ast.TypeInfo" } ] );

pub class VarInfo {
   pri let name: &Parser.Token { pub };
   // 宣言している型。 宣言していない場合は nil
   pri let refType: &RefTypeNode! { pub };
   // 実際の型。
   pri let actualType: &Ast.TypeInfo { pub };
}

pub enum DeclVarMode {
   Let,
   Sync,
   Unwrap,
}

_declNodeClass( "DeclVar", Node, false, false, true,
                [ { "mode": "DeclVarMode" },
                  { "accessMode": "Ast.AccessMode" },
                  { "staticFlag": "bool" },
                  { "varList": "&List<&VarInfo>" },
                  { "expList": "&ExpListNode!" },
                  { "symbolInfoList": "&List<&Ast.SymbolInfo>"},
                  /** 初期化されていない場合は builtinTypeEmpty が入っている型情報 */ 
                  { "typeInfoList": "&List<&Ast.TypeInfo>" },
                  { "unwrapFlag": "bool" },
                  { "unwrapBlock": "&BlockNode!" },
                  { "thenBlock": "&BlockNode!" },
                  { "syncVarList": "&List<&Ast.SymbolInfo>" },
                  { "syncBlock": "&BlockNode!" } ]
);

pub override fn DeclVarNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   // if checkMode ~= .Normal and checkMode ~= .Return {
   //    if! let block = self.unwrapBlock {
   //       let kind = block.getBreakKind( checkMode );
   //       switch kind {
   //          case .Return, .NeverRet, .Break {
   //             return kind;
   //          }
   //       }
   //    }
   //    if! let block = self.thenBlock {
   //       let kind = block.getBreakKind( checkMode );
   //       switch kind {
   //          case .Return, .NeverRet, .Break {
   //             return kind;
   //          }
   //       }
   //    }
   //    if! let block = self.syncBlock {
   //       let kind = block.getBreakKind( checkMode );
   //       switch kind {
   //          case .Return, .NeverRet, .Break {
   //             return kind;
   //          }
   //       }
   //    }
   //    return .None;
   // }
   // else {
   //    let mut kind = BreakKind.None;
   //    let mut work = BreakKind.None;
   //    if! let block = self.unwrapBlock {
   //       work = block.getBreakKind( checkMode );
   //       _setBreakKind( work, kind, true, checkMode );
   //       if! let thenBlock = self.thenBlock {
   //          work = thenBlock.getBreakKind( checkMode );
   //          _setBreakKind( work, kind, true, checkMode );
   //          if! let syncBlock = self.syncBlock {
   //             work = syncBlock.getBreakKind( checkMode );
   //             _setBreakKind( work, kind, true, checkMode );
   //             return kind;
   //          }     
   //       }  
   //    }
   //    return .None;
   // }
   
   let mut kind = BreakKind.None;
   let mut work = BreakKind.None;
   if! let block = self.unwrapBlock {
      work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      if! let thenBlock = self.thenBlock {
         work = thenBlock.getBreakKind( checkMode );
         _setBreakKind( work, kind, true, checkMode );
         if! let syncBlock = self.syncBlock {
            work = syncBlock.getBreakKind( checkMode );
            _setBreakKind( work, kind, true, checkMode );
         }
         return kind;
      }
      if checkMode ~= .Normal and checkMode ~= .Return {
         return kind;
      }
   }
   return .None;
}

pub override fn DeclVarNode.visitSub(
   visitor:NodeVisitor, depth:int, alreadySet:Set<&Node> ) : bool
{
   foreach varInfo in self.varList {
      if! let refTypeNode = varInfo.$refType {
         _procVisitor( refTypeNode, self, "refType" ); 
      }
   }
   return true;
}



pub enum FuncKind {
   /** 関数定義 */
   Func,
   /** メドッ定義 */
   Mtd,
   /** コンストラクタ定義 */
   Ctor,
   /** デストラクタ定義 */
   Dstr,
   /** クラスの __init ブロック */
   InitBlock,
   /** from 宣言 */
   Form,
}

pub class DeclFuncInfo {
   let kind:FuncKind { pub };
   /** この関数がメソッドの場合、このメソッドを保持するクラスの型 */
   let classTypeInfo: &Ast.TypeInfo! { pub };
   /** このメソッドを保持するクラスを定義するノード。 クラスが builtin の場合 nil。 */
   let declClassNode: &DeclClassNode! {pub};
   /** class 定義の外で定義したメソッドの場合 true */
   let outsizeOfClass: bool {pub};
   let name: &Parser.Token! { pub };
   let symbol: &Ast.SymbolInfo! { pub };
   let argList: &List<&Node> { pub };
   let staticFlag: bool { pub };
   let accessMode: Ast.AccessMode { pub };
   let asyncMode: Ast.Async! {pub};
   let mut body: &BlockNode! { pub, pub };
   let retTypeInfoList: &List<&Ast.TypeInfo> { pub };
   let retTypeNodeList: &List<&RefTypeNode> { pub };
   let mut has__func__Symbol:bool { pub, pub };
   let overrideFlag: bool { pub };
   // この関数を構成する stmt 数。
   let mut stmtNum:int {pub,pub};
}

pub static fn DeclFuncInfo.createFrom(
   info:&DeclFuncInfo, name:&Parser.Token, symbol: &Ast.SymbolInfo ): DeclFuncInfo
{
   return new DeclFuncInfo(
      info.$kind, info.classTypeInfo, info.declClassNode, info.outsizeOfClass,
      name, symbol, info.argList, info.staticFlag, info.accessMode,
      info.asyncMode, info.body, info.retTypeInfoList, info.retTypeNodeList,
      info.has__func__Symbol, info.overrideFlag, info.stmtNum );
}

_declNodeClass( "DeclForm", Node, false, false, true,
                [ { "declInfo": "&DeclFuncInfo" } ]
);

_declNodeClass( "DeclFunc", Node, false, nil, nil,
                [ { "declInfo": "&DeclFuncInfo" } ]
);
pub override fn DeclFuncNode.canBeRight( processInfo:Ast.ProcessInfo ):bool {
   // anonymous 関数なら r-value に成れる
   return self.declInfo.$name == nil;
}
pub override fn DeclFuncNode.canBeStatement():bool {
   // anonymous 関数以外なら statement に成れる
   return not (self.declInfo.$name == nil);
}



_declNodeClass( "DeclMethod", Node, false, false, true,
                [ { "declInfo": "&DeclFuncInfo" } ]
);

_declNodeClass( "ProtoMethod", Node, false, false, true,
                [ { "declInfo": "&DeclFuncInfo" } ]
);

_declNodeClass( "DeclConstr", Node, false, false, true,
                [ { "declInfo": "&DeclFuncInfo" } ]
);

_declNodeClass( "DeclDestr", Node, false, false, true,
                [ { "declInfo": "&DeclFuncInfo" } ]
);

_declNodeClass( "ExpCallSuperCtor", Node, false, false, true,
                [ { "superType": "&Ast.TypeInfo" },
                  { "methodType": "&Ast.TypeInfo" },
                  { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "ExpCallSuper", Node, false, nil, true,
                [ { "superType": "&Ast.TypeInfo" },
                  { "methodType": "&Ast.TypeInfo" },
                  { "expList": "&ExpListNode!" } ]
);
pub override fn ExpCallSuperNode.canBeRight( processInfo:Ast.ProcessInfo ):bool {
   return self.$expType ~= Ast.builtinTypeNone;
}

pub enum LockKind {
   /** __asyncLock */
   AsyncLock,
   /** __luago。 __noasync から lua を実行する場合。 */
   LuaGo,
   /** __luaLock。  __async から __noasync に切り替えて lua を実行する場合。 */
   LuaLock,
   /** __unsafe。 __async のまま lua を実行する場合  */
   Unsafe,
}
_declNodeClass( "AsyncLock", Node, false, false, true,
                [ { "lockKind": "LockKind" },
                  { "block": "&BlockNode" } ]
);

_declNodeClass( "Request", Node, false, true, true,
                [ { "processor": "&Node" },
                  { "exp": "&Node" } ]
);

_declNodeClass( "DeclMember", Node, false, false, true,
                [ { "name": "&Parser.Token" },
                  { "refType": "&RefTypeNode" },
                  { "symbolInfo": "&Ast.SymbolInfo" },
                  { "classType" : "&Ast.TypeInfo" },
                  { "staticFlag": "bool" },
                  { "accessMode": "Ast.AccessMode" },
                  { "getterMutable": "bool" },
                  { "getterMode": "Ast.AccessMode" },
                  { "getterToken": "&Types.Token!" },
                  { "getterRetType": "&Ast.TypeInfo" },
                  { "setterMode": "Ast.AccessMode" },
                  { "setterToken": "&Types.Token!" } ]
);

pub fn DeclMemberNode.getGetterSym() : &Ast.SymbolInfo! {
   if self.getterMode ~= .None {
      return self.classType.$scope$.getSymbolInfoChild$( "get_%s" (self.name.txt) );
   }
   return nil;
}

pub fn DeclMemberNode.getSetterSym() : &Ast.SymbolInfo! {
   if self.setterMode ~= .None {
      return self.classType.$scope$.getSymbolInfoChild$( "set_%s" (self.name.txt) );
   }
   return nil;
}

_declNodeClass( "DeclArg", Node, false, false, false,
                [ { "name": "&Parser.Token" },
                  { "symbolInfo": "&Ast.SymbolInfo" },
                  { "argType": "&RefTypeNode!" } ]
);

_declNodeClass( "DeclArgDDD", Node, false, false, false, [] );

pub class AdvertiseInfo {
   pri let mut member: &DeclMemberNode { pub };
   pri let prefix: str {pub};
   pri let pos: &Parser.Position {pub};
};
_declNodeClass( "DeclAdvertise", Node, false, false, false,
                [ { "advInfo" : "&AdvertiseInfo" } ] );


pub class ClassInheritInfo {
   let base: &RefTypeNode! {pub};
   let impliments: &List<&RefTypeNode> {pub};

   pub fn visit( parent:&Node, visitor:NodeVisitor,
                 depth:int, alreadySet:Set<&Node> ) : bool
   {
      if! let base = self.base {
         _procVisitor( base, parent, "base" );
      }
      foreach ifTypeNode in self.impliments {
         _procVisitor( ifTypeNode, parent, "ifTypeNode" );
      }
      return true;
   }
}

_declNodeClass( "ProtoClass", Node, false, false, true,
                [ { "name": "&Parser.Token" },
                  { "inheritInfo": "&ClassInheritInfo" } ] );

pub override fn ProtoClassNode.visitSub(
   visitor:NodeVisitor, depth:int, alreadySet:Set<&Node> ) : bool
{
   return self.inheritInfo.visit( self, visitor, depth, alreadySet );
}
   
pub class ClassInitBlockInfo {
   pri let mut func: &DeclMethodNode! {pub,pub};
}
_declNodeClass( "DeclClass", Node, false, false, true,
                [ { "accessMode": "Ast.AccessMode" },
                  { "name": "&Parser.Token" },
                  { "inheritInfo": "&ClassInheritInfo" },
                  { "hasPrototype": "bool" },
                  { "gluePrefix": "str!" },
                  { "moduleName": "&Parser.Token!" },
                  // module を定義している言語。 nil の場合、変換先の言語と同じ。
                  { "lang": "Types.Lang!" },
                  { "lazyLoad": "LazyLoad" },
                  // default__init_old で、旧形式のコンストラクタが使用されている場合 true
                  { "hasOldCtor": "bool" },
                  /**
                  クラス宣言内の全 Statement のリスト。
                  クラス宣言外で宣言しているメソッド等は含まない。
                  */               
                  { "allStmtList": "&List<&Node>" },
                  /** クラス内で新しく型宣言している Node のリスト */
                  { "declStmtList": "&List<&Node>" },
                  /**
                  メンバー、メソッド宣言の Node リスト。
                  クラス宣言外部で宣言することもあるので mut。
                  */               
                  { "fieldList": "List<&Node>" },
                  /** メンバー宣言の Node リスト */
                  { "memberList": "&List<&DeclMemberNode>" },
                  { "scope": "&Ast.Scope" },
                  //{ "initStmtList": "List<&Node>" },
                  { "initBlock": "&ClassInitBlockInfo" },
                  { "advertiseList": "&List<&AdvertiseInfo>" },
                  { "trustList": "&List<&Ast.TypeInfo>" },
                  /**
                  コンストラクタで初期化されていないメンバ。nil で初期化する必要がある。
                  */                
                  { "uninitMemberList": "&List<&Ast.SymbolInfo>" },
                  /**
                  クラス宣言の外部で宣言しているメソッド名の Set。
                  クラス宣言外部で宣言するので mut。
                   */                 
                  { "outerMethodSet": "Set<str>" } ]
);

pub override fn DeclClassNode.visitSub(
   visitor:NodeVisitor, depth:int, alreadySet:Set<&Node> ) : bool
{
   return self.inheritInfo.visit( self, visitor, depth, alreadySet );
}

pub fn DeclClassNode.isModule() : bool {
   return self.moduleName ~= nil;
}

/**
このクラスで定義しているメソッド名のセットを返す。 advertise を除く。
*/
pub fn DeclClassNode.createMethodNameSetWithoutAdv() : &Set<str> {
   let mut methodNameSet: Set<str> = (@);
   if self.$expType.$kind ~= .IF {
      foreach field in self.$fieldList {
         if field.$kind == NodeKind.$DeclConstr {
            methodNameSet.add( "__init" );
         }
         if field.$kind == NodeKind.$DeclDestr {
            methodNameSet.add( "__free" );
         }
         if! let methodNode = field@@@DeclMethodNode {
            let methodNameToken = unwrap methodNode.$declInfo.$name;
            methodNameSet.add( methodNameToken.txt );
         }
      }
      foreach memberNode in self.$memberList {
         let memberName = memberNode.$name.txt;
         if memberNode.$getterMode ~= .None {
            methodNameSet.add( "get_" .. memberName );
         }
         if memberNode.$setterMode ~= .None {
            methodNameSet.add( "set_" .. memberName );
         }
      }
   }
   return methodNameSet;
}

pub fn DeclClassNode.setHasOldCtor() mut {
   self.hasOldCtor = true;
}

pub fn DeclClassNode.hasUserInit() : bool {
   let scope = unwrap self.$expType.$scope;
   let initFuncType = unwrap scope.getTypeInfoField( "__init", true, scope, .Normal );
   return not initFuncType.$autoFlag;
}

_declNodeClass( "DeclEnum", Node, false, false, true,
                [ { "enumType": "&Ast.EnumTypeInfo" },
                  { "accessMode": "Ast.AccessMode" },
                  { "name": "&Parser.Token" },
                  { "valueNameList": "List<&Parser.Token>" },
                  { "scope": "&Ast.Scope" } ]
);

pub class AlgeValParamInfo {
   let name:&Types.Token! {pub};
   let typeRef:&RefTypeNode {pub};
}
pub class DeclAlgeValInfo {
   let valSym:&Ast.SymbolInfo {pub};
   let paramList:&List<&AlgeValParamInfo> {pub};
}
_declNodeClass( "DeclAlge", Node, false, false, true,
                [ { "accessMode": "Ast.AccessMode" },
                  { "algeType": "&Ast.AlgeTypeInfo"},
                  { "name": "&Parser.Token" },
                  { "algeValList": "&List<&DeclAlgeValInfo>" },
                  { "scope": "&Ast.Scope" } ]
);

pub override fn DeclAlgeNode.visitSub(
   visitor:NodeVisitor, depth:int, alreadySet:Set<&Node> ) : bool
{
   foreach valInfo in self.algeValList {
      foreach paramInfo in valInfo.$paramList {
         _procVisitor( paramInfo.$typeRef, self, "typeRef" );
      }
   }
   return true;
}



_declNodeClass( "NewAlgeVal", Node, false, true, false,
                [ { "name": "&Parser.Token" },
                  { "prefix": "&Node!" },
                  { "algeTypeInfo": "&Ast.AlgeTypeInfo" },
                  { "valInfo": "&Ast.AlgeValInfo" },
                  { "paramList": "&List<&Node>" } ]
);

_declNodeClass( "LuneControl", Node, false, false, true,
                [ {"pragma": "LuneControl.Pragma"} ]
);


pub class MatchCase {
   pri let valInfo: &Ast.AlgeValInfo {pub};
   pri let valExpRef: &ExpRefNode {pub};
   pri let valParamNameList: &List<&Ast.SymbolInfo> {pub};
   pri let block: &BlockNode {pub};
}

_declNodeClass( "Match", Node, false, false, true,
                [ { "idInNS": "int" },
                  { "val": "&Node" },
                  { "algeTypeInfo": "&Ast.AlgeTypeInfo" },
                  { "caseList": "&List<&MatchCase>" },
                  { "defaultBlock": "&Node!" },
                  // case で全ての条件が網羅されているかどうか
                  { "caseKind": "CaseKind"},
                  // default ブロックがある場合、 default_ で宣言している。
                  { "failSafeDefault": "bool" }
                ]              
);
pub override fn MatchNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   let mut kind = BreakKind.None;
   let fullCase = self.caseKind ~= .Lack;
   foreach caseInfo in self.caseList {
      let work = caseInfo.$block.getBreakKind( checkMode );
      let goNext = (work == .None) or not fullCase;
      _setBreakKind( work, kind, goNext, checkMode );
   }
   if! let block = self.defaultBlock {
      let work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }

   if fullCase {
      return kind;
   }
   return .None;
}

pub override fn MatchNode.visitSub(
   visitor:NodeVisitor, depth:int, alreadySet:Set<&Node> ) : bool
{
   foreach caseInfo in self.caseList {
      _procVisitor( caseInfo.$valExpRef, self, "valExpRef" ); 
      _procVisitor( caseInfo.$block, self, "block" ); 
   }
   return true;
}




_declNodeClass( "LuneKind", Node, false, true, false,
                [ { "exp": "&Node" } ]
);

_declNodeClass( "DeclMacro", Node, false, false, true,
                [ { "declInfo": "DeclMacroInfo" } ]
);

pub abstract class MacroEval {
   //_lune_control default_noasync_this_class;
   
   // pub abstract fn evalFromCode(
   //    processInfo:Ast.ProcessInfo, name:str,
   //    argNameList:&List<str>, code:str!, baseDir:str! ) : Luaval<macroStatmentProc>;
   // pub abstract fn eval(
   //    processInfo:Ast.ProcessInfo,
   //    macroNode: DeclMacroNode, baseDir:str! ) : Luaval<macroStatmentProc>;

   pub abstract fn evalFromCodeToLuaCode(
      processInfo:Ast.ProcessInfo, name:str, argNameList:&List<str>, code:str! ) : str;
   pub abstract fn evalToLuaCode(
      processInfo:Ast.ProcessInfo, macroNode: DeclMacroNode ) : str;
}


_declNodeClass( "TestCase", Node, false, false, true,
                [ { "name": "&Parser.Token" },
                  { "impNode": "&Node" },
                  { "ctrlName": "str"},
                  { "block": "&BlockNode" } ]
);

_declNodeClass( "TestBlock", Node, false, false, true,
                [ { "stmtList": "List<&Node>" } ]
);

pub fn TestBlockNode.isInnerPos( pos:&Parser.Position ) : bool {
   if self.$pos.streamName == pos.streamName and self.$pos.lineNo < pos.lineNo and
      #self.$stmtList > 0 and self.$stmtList[ 1 ].$pos.lineNo >= pos.lineNo
   {
      return true;
   }
   return false;
}

_declNodeClass( "Abbr", Node, false, true, false,
                [ {} ]
);


_declNodeClass( "Boxing", Node, false, true, false,
                [ { "src": "&Node" } ]
);

_declNodeClass( "Unboxing", Node, false, true, false,
                [ { "src": "&Node" } ]
);

_declNodeClass( "LiteralNil", Node, false, true, false, [] );

_declNodeClass( "LiteralChar", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralInt", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralReal", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "real" } ]
);

_declNodeClass( "LiteralArray", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "LiteralList", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "LiteralSet", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

pub class PairItem {
   pri let key: &Node { pub };
   pri let val: &Node { pub };
}
_declNodeClass( "LiteralMap", Node, false, true, false,
                [ { "map": "Map<&Node,&Node>" },
                  { "pairList": "List<&PairItem>" } ]
);

_declNodeClass( "LiteralString", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  // 文字列リテラルの %s に対する各パラメータ
                  { "orgParam": "&ExpListNode!" },
                  // 上記 orgParam を ... に変換した時のパラメータ
                  { "dddParam": "&ExpListNode!" } ]
);

_declNodeClass( "LiteralBool", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

_declNodeClass( "LiteralSymbol", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

pub fn Node.getSymbolInfo(): &List<&Ast.SymbolInfo> {
   fn processExpNode( node: &Node ): &List<&Ast.SymbolInfo> {
      switch ( node.$kind ) {
         case NodeKind.$ExpRef {
            return [(unwrap (node@@@ExpRefNode)).$symbolInfo];
         }
         case NodeKind.$RefField {
            if! let refFieldNode = node@@@RefFieldNode {
               if refFieldNode.$nilAccess {
                  // nilAccess の場合、シンボルの型情報が変るので
                  // そのまま symbolInfo を返すと不整合が発生するので
                  // ここでは暫定的に空を返す
                  return [];
               }
               if! refFieldNode.$symbolInfo {
                  return [_exp];
               }
            }
         }
         // case NodeKind.$GetField {
         //    if! let getFieldNode = node@@@GetFieldNode {
         //       if! getFieldNode.$symbolInfo {
         //          return [_exp];
         //       }
         //    }
         // }
         case NodeKind.$ExpList {
            if! let expListNode = node@@@ExpListNode {
               let mut list: List<&Ast.SymbolInfo> = [];
               foreach expNode, index in expListNode.$expList {
                  if index == #expListNode.$expList {
                     foreach symbolInfo in processExpNode( expNode ) {
                        list.insert( symbolInfo );
                     }  
                  }  
                  else {
                     foreach symbolInfo in processExpNode( expNode ) {
                        list.insert( symbolInfo );
                        break;
                     }  
                  }  
               }
               return list;
            }
         }
         case NodeKind.$RefType {
            if! let refTypeNode = node@@@RefTypeNode {
               return refTypeNode.$name.getSymbolInfo();
            }
         }
      }
      return [];
   }
   return processExpNode( self );
}


pub override fn WhileNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in self.block.$stmtList {
         if stmt.$kind ~= NodeKind.$BlankLine {
            let work = stmt.getBreakKind( checkMode );
            _setBreakKind(work, kind, false, checkMode );
         }
      }
      if kind == .Break {
         return .None;
      }
      return kind;
   }
   else {
      // if self.exp.$expType.$nilable {
      //    return .None;
      // }
      // if self.exp.$expType.equals( Ast.builtinTypeBool ## ) {
      //    if! let boolNode = self.exp@@@LiteralBoolNode {
      //       if boolNode.$token.txt == "false" {
      //          return .None;
      //       }  
      //    }
      //    else {
      //       return .None;
      //    }        
      // }
      // 条件式が次のもの以外は無条件ループ。
      //  - nilable でない
      //  - bool 型の式でない
      //  - false でもない
      if not self.infinit {
         return .None;
      }

      // 無条件ループ用のフロー解析に変更する。
      let mut mode = CheckBreakMode.IgnoreFlow;
      // if checkMode == .Return {
      //    mode = .IgnoreFlowReturn;
      // }
      let mut kind = BreakKind.None;
      foreach stmt in self.block.$stmtList {
         if stmt.$kind ~= NodeKind.$BlankLine {
            let work = stmt.getBreakKind( mode );
            _setBreakKind(work, kind, false, mode );
         }
      }
      if kind == .Break {
         return .None;
      }
      if kind == .Return {
         return .Return;
      }
      return .NeverRet;
   }
}


pub override fn LiteralNilNode.getLiteral(): Literal!, str! {
   return .Nil, nil;
}
pub override fn LiteralNilNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   self.addTokenList( list, .Symb, "nil" );
   return true;
}


pub override fn LiteralCharNode.getLiteral(): Literal!, str! {
   return .Int( self.num ), nil;
}
pub override fn LiteralCharNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   self.addTokenList( list, .Char, "%d" (self.num) );
   return true;
}

pub override fn LiteralIntNode.getLiteral(): Literal!, str! {
   return .Int( self.num ), nil;
}
pub override fn LiteralIntNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   self.addTokenList( list, .Int, "%d" (self.num) );
   return true;
}

pub override fn LiteralRealNode.getLiteral(): Literal!, str! {
   return .Real( self.num ), nil;
}
pub override fn LiteralRealNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   self.addTokenList( list, .Real, "%g" (self.num) );
   return true;
}

pub override fn LiteralArrayNode.getLiteral(): Literal!, str! {
   let mut literalList:List<Literal> = [];
   if! self.expList {
      foreach node in _exp.get_expList() {
         let literal, mess = node.getLiteral();
         when! literal {
            literalList.insert( literal );
         }
         else {
            return nil, mess;
         }
      } 
   }
   return .ARRAY( literalList ), nil;
}

pub override fn LiteralArrayNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Dlmt, "[@" );
   if! self.expList {
      foreach node, index in _exp.get_expList() {
         if index > 1 {
            self.addTokenList( list, .Dlmt, "," );
         }
         if not node.setupLiteralTokenList( list ) {
            return false;
         }
      } 
   }
   self.addTokenList( list, .Dlmt, "]" );
   return true;
}

pub override fn LiteralListNode.getLiteral(): Literal!, str! {
   let mut literalList:List<Literal> = [];
   if! self.expList {
      foreach node in _exp.get_expList() {
         let literal, mess = node.getLiteral();
         when! literal {
            literalList.insert( literal );
         }
         else {
            return nil, mess;
         }
      } 
   }
   return .LIST( literalList ), nil;
}

pub override fn LiteralListNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Dlmt, "[" );
   if! self.expList {
      foreach node, index in _exp.get_expList() {
         if index > 1 {
            self.addTokenList( list, .Dlmt, "," );
         }
         if not node.setupLiteralTokenList( list ) {
            return false;
         }
      } 
   }
   self.addTokenList( list, .Dlmt, "]" );
   return true;
}


pub override fn LiteralSetNode.getLiteral(): Literal!, str! {
   let mut literalList:List<Literal> = [];
   if! self.expList {
      foreach node in _exp.get_expList() {
         let literal, mess = node.getLiteral();
         when! literal {
            literalList.insert( literal );
         }
         else {
            return nil, mess;
         }
      } 
   }
   return .SET( literalList ), nil;
}

pub override fn LiteralSetNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Dlmt, "(@" );
   if! self.expList {
      foreach node, index in _exp.get_expList() {
         if index > 1 {
            self.addTokenList( list, .Dlmt, "," );
         }
         if not node.setupLiteralTokenList( list ) {
            return false;
         }
      } 
   }
   self.addTokenList( list, .Dlmt, ")" );
   return true;
}

pub override fn LiteralMapNode.getLiteral(): Literal!, str! {
   let mut litMap:Map<&Literal,&Literal> = {};
   foreach val, key in self.map {
      let keyLiteral, keyMess = key.getLiteral();
      let valLiteral, valMess = val.getLiteral();
      when! keyLiteral, valLiteral {
         litMap[ keyLiteral ] = valLiteral;
      }
      else {
         if not keyLiteral {
            return nil, keyMess;
         }
         if not valLiteral {
            return nil, valMess;
         }
      }
   }
   return .MAP( litMap ), nil;
}

pub override fn LiteralMapNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Dlmt, "{" );

   let mut lit2valNode:Map<stem,&Node> = {};
   foreach _, key in self.map {
      let literal = key.getLiteral();
      when! literal {
         match literal {
            case .Int( param ) {
               lit2valNode[ param ] = key;
            }
            case .Str( param ) {
               lit2valNode[ param ] = key;
            }
            case .Real( param ) {
               lit2valNode[ param ] = key;
            }
            default {
               return false;
            }
         }
      }
   }
   
   forsort key, _ in lit2valNode {
      if not key.setupLiteralTokenList( list ) {
         return false;
      }
      self.addTokenList( list, .Dlmt, ":" );
      if not self.map[ key ]$.setupLiteralTokenList$( list ) {
         return false;
      }
      self.addTokenList( list, .Dlmt, "," );
   }
   self.addTokenList( list, .Dlmt, "}" );
   return true;
}


pub override fn LiteralStringNode.getLiteral(): Literal!, str! {
   let mut txt = self.token.txt;
   if string.find( txt, '^```' ##) {
      txt = txt.sub( 4, -4 );
   }
   else {
      txt = txt.sub( 2, -2 );
   }

   if! let param = self.$orgParam {
      let argList = param.$expList;

      let mut paramList:List<stem!> = [];
      foreach argNode in argList {
         let arg, mess = argNode.getLiteral();
         when! arg {
            paramList[ #paramList + 1 ] = getLiteralObj( arg );
         }
         else {
            return nil, mess;
         }
      }
      txt = string.format( txt, paramList.unpack() );
   }
   return .Str(txt), nil;
}

pub override fn LiteralStringNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Str, self.token.txt );
   if! let param = self.$orgParam {
      self.addTokenList( list, .Dlmt, "(" );
      foreach argNode, index in param.$expList {
         if index > 1 {
            self.addTokenList( list, .Dlmt, "," );
         }
         if not argNode.setupLiteralTokenList( list ) {
            return false;
         }
      }
      self.addTokenList( list, .Dlmt, ")" );
   }
   return true;
}

pub override fn LiteralBoolNode.getLiteral(): Literal!, str! {
   return .Bool( self.token.txt == "true" ), nil;
}

pub override fn LiteralBoolNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Kywd, self.token.txt );
   return true;
}


pub override fn LiteralSymbolNode.getLiteral(): Literal!, str! {
   return .Symbol(self.token.txt), nil;
}

pub override fn LiteralSymbolNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Symb, self.token.txt );
   return true;
}


fn enumLiteral2Literal( obj:&Ast.EnumLiteral ) : Literal!, str! {
   _match obj {
      case .Int( val ) {
         return Literal.Int( val ), nil;
      }
      case .Real( val ) {
         return Literal.Real( val ), nil;
      }
      case .Str( val ) {
         return Literal.Str( val ), nil;
      }
   }
}


pub override fn RefFieldNode.getLiteral(): Literal!, str! {
   let typeInfo = self.$expType;
   if! let enumTypeInfo = typeInfo.$aliasSrc@@@Ast.EnumTypeInfo {
      if self.prefix.$expType.$aliasSrc@@@Ast.EnumTypeInfo {
         let enumval = unwrap enumTypeInfo.getEnumValInfo( self.field.txt );
         return enumLiteral2Literal( enumval.$val )**;
      }
   }
   
   let mut tokenList:List<str> = [];
   let literal, mess = self.prefix.getLiteral();
   when! literal {
      match literal {
         case .Symbol( symbol ) {
            tokenList.insert( symbol );
         }
         case .Field( symList ) {
            foreach symbol in symList {
               tokenList.insert( symbol );
            }
         }
         default {
            return nil, "not support -- %s" (literal.$_txt) ;
         }
      }
      if self.nilAccess {
         tokenList.insert( "$." );
      }
      else {
         tokenList.insert( "." );
      }
      tokenList.insert( self.field.txt );
      return .Field( tokenList ), nil;
   }
   return nil, mess;
}

pub override fn ExpMacroStatNode.getLiteral(): Literal!, str!
{
   let mut txt = "";
   foreach token in self.expStrList {
      let literal = token.getLiteral();
      when! literal {
         match literal {
            case .Str( work ) {
               txt = "%s%s" (txt, work );
            }
         }
      }
      else {
         return nil, "illegal literal -- %s" ( getNodeKindName( token.$kind ) );
      }
   }
   return .Str( txt ), nil;
}

pub override fn ExpMacroArgExpNode.getLiteral(): Literal!, str!
{
   return .Str( self.$codeTxt ), nil;
}


pub override fn ExpRefNode.getLiteral(): Literal!, str! {
   let typeInfo = self.symbolInfo.$typeInfo;
   if! let enumTypeInfo = typeInfo.$aliasSrc@@@Ast.EnumTypeInfo {
      // この getLiteral() 処理は、次のケースのみ有効。
      // enum Hoge {
      //   Val0,
      //   Val1 = Val0 + 1, // <<--- この Val0 が ExpRefNode になる。
      // }
      if self.symbolInfo.$kind == .Mbr and
         self.symbolInfo.$namespaceTypeInfo.$kind == .Enum
      {
         let enumval = unwrap enumTypeInfo.getEnumValInfo( self.symbolInfo.$name );
         return enumLiteral2Literal( enumval.$val )**;
      }
   }

   return nil, "unsupport refnode -- %s" (typeInfo.getTxt(##));
}

pub override fn ExpOmitEnumNode.getLiteral(): Literal!, str! {
   //let enumTypeInfo = self.enumTypeInfo;

   let enumval = self.valInfo;
   return enumLiteral2Literal( enumval.$val )**;
   
}

pub override fn ExpOmitEnumNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   //let enumTypeInfo = self.enumTypeInfo;

   let enumval = self.valInfo;
   self.addTokenList( list, .Dlmt, "." );

   self.addTokenList( list, .Symb, (enumval.$val.$_txt.gsub( ".*%.", "")) );
   return true;
}

fn ExpOp2Node.getValType( node:&Node ): bool, int, real, str, &Ast.TypeInfo {
   let! literal = node.getLiteral() {
      return false, 0, 0.0, "", Ast.headTypeInfo;
   };

   let mut intVal, mut realVal, mut strVal = 0, 0.0, "";
   let mut retTypeInfo = Ast.builtinTypeNone;

   // fn getEnum( txt:str, typeInfo:&Ast.TypeInfo ) {
   //    if! let enumTypeInfo = typeInfo@@@Ast.EnumTypeInfo {
   //       let valInfo = unwrap enumTypeInfo.getEnumValInfo( txt );
   //       match valInfo.$val {
   //          case .Int( val ) {
   //             intVal = val;
   //             realVal = val@@real;
   //          }
   //          case .Real( val ) {
   //             realVal = val;
   //          }
   //          case .Str( val ) {
   //             strVal = val;
   //          }
   //       }
   //       retTypeInfo = enumTypeInfo.$valTypeInfo;
   //    }
   // }
   
   match literal {
      case .Int( val ) {
         intVal = val;
         realVal = val@@real;
         retTypeInfo = Ast.builtinTypeInt;
      }
      case .Real( val ) {
         realVal = val;
         intVal = val@@int;
         retTypeInfo = Ast.builtinTypeReal;
      }
      case .Str( val ) {
         strVal = val;
         retTypeInfo = Ast.builtinTypeString;
      }
      default {
         return false, 0, 0.0, "", Ast.headTypeInfo;
      }
   }
   return true, intVal, realVal, strVal, retTypeInfo;
}


pub override fn ExpOp2Node.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   let literal = self.getLiteral();
   when! literal {
      match literal {
         case .Int( val ) {
            self.addTokenList( list, .Int, "%d" (val) );
         }
         case .Real( val ) {
            self.addTokenList( list, .Real, "%g" (val) );
         }
         case .Str( val ) {
            self.addTokenList( list, .Str, "%q" (val) );
         }
         default {
            return false;
         }
      }
      return true;
   }
   else {
      return false;
   }
}


pub override fn ExpOp2Node.getLiteral(): Literal!, str! {

   let ret1, int1, real1, str1, type1 = self.getValType( self.$exp1 );
   let ret2, int2, real2, str2, type2 = self.getValType( self.$exp2 );

   if not ret1 {
      return nil, "not support literal -- %s" ( getNodeKindName( self.$exp1.$kind ) );
   }
   if not ret2 {
      return nil, "not support literal -- %s" ( getNodeKindName( self.$exp2.$kind ) );
   }


   if ( type1 == Ast.builtinTypeInt or type1 == Ast.builtinTypeReal ) and
      ( type2 == Ast.builtinTypeInt or type2 == Ast.builtinTypeReal )
   {
      let mut retType = Ast.builtinTypeInt;
      if type1 == Ast.builtinTypeReal or type2 == Ast.builtinTypeReal {
         retType = Ast.builtinTypeReal;
      }

      switch ( self.op.txt ) {
         case "+" {
            if retType == Ast.builtinTypeInt {
               return .Int( int1 + int2 ), nil;
            }
            return .Real( real1 + real2 ), nil;
         }
         case "-" {
            if retType == Ast.builtinTypeInt {
               return .Int( int1 - int2 ), nil;
            }
            return .Real( real1 - real2), nil;
         }
         case "*" {
            if retType == Ast.builtinTypeInt {
               return .Int( int1 * int2 ), nil;
            }
            return .Real( real1 * real2), nil;
         }
         case "/" {
            if retType == Ast.builtinTypeInt {
               return .Int( int1 / int2 ), nil;
            }
            return .Real( real1 / real2), nil;
         }
      }
   }
   elseif type1 == Ast.builtinTypeString and type2 == Ast.builtinTypeString {
      if self.op.txt == ".." {
         return .Str( str1 .. str2 ), nil;
      }
   }

   let mess = "not support literal operation -- %s %s %s"
       (type1.getTxt(##), self.op.txt, type2.getTxt(##) );
   return nil, mess;
}

pub class DefMacroInfo extend MacroInfo {
   pub let declInfo: &DeclMacroInfo;
   pri let mut argList:List<&MacroArgInfo>;

   pub override fn get_name():str {
      return self.declInfo.$name.txt;
   }
   
   pub override fn getArgList():&List<&MacroArgInfo> {
      return self.argList;
   }
   pub override fn getTokenList():&List<&Parser.Token>{
      return self.declInfo.$tokenList;
   }
   
   pub fn __init( func: Luaval<macroStatmentProc>!, declInfo: &DeclMacroInfo,
                  symbol2MacroValInfoMap: &Map<str,MacroValInfo> )
   {
      super( func, symbol2MacroValInfoMap );
      self.declInfo = declInfo;
      self.argList = [];
      foreach argNode in declInfo.$argList {
         if argNode.get_kind() == NodeKind.$DeclArg {
            //let argType = argNode.$argType.$expType;
            let argType = argNode.$expType;
            let argName = argNode.$name.txt;
            self.argList.insert( new MacroArgInfo( argName, argType ) );
         }
      }
   }
}

pub class ExportInfo extend frontInterface.ExportInfo {
   let typeId2DefMacroInfo:&Map<&Ast.IdInfo, &MacroInfo> {pub};
}
pub override fn ExportInfo.assign( assignName: str ) : frontInterface.ExportInfo
{
   let mut info = new ExportInfo( 
      self.$moduleTypeInfo, self.$provideInfo, self.$processInfo,
      self.$globalSymbolList, self.$importedAliasMap, self.$moduleId,
      self.$fullName, assignName, self.$streamName, {},
      self.typeId2DefMacroInfo );
   info.set_importId2localTypeInfoMap( self.$importId2localTypeInfoMap );
   return info;
}


pub fn NodeManager.MultiTo1(node:&Node) mut : &Node {
   let expType = node.$expType;
   if #node.$expTypeList > 1 {
      return ExpMultiTo1Node.create(
         self, node.$pos, node.$inTestBlock, node.$macroArgFlag, [ expType ], node );
   }
   elseif expType.$kind == .DDD {
      return ExpMultiTo1Node.create(
         self, node.$pos, node.$inTestBlock, node.$macroArgFlag,
         expType.$itemTypeInfoList, node );
   }
   return node;
}

pub fn Filter.processBlockSub( node: &BlockNode, opt:T )  mut {
}

pub fn Filter.processBlock( node: &BlockNode, opt:T )  mut {
   self.moduleInfoManager.push( node.$scope );

   self.processBlockSub( node, opt );

   self.moduleInfoManager.pop();
}

/**
指定のノードが 多値のノードか調べる

@param node ノード
@return 多値の場合 true
*/
pub fn hasMultiValNode( node:&Node ): bool {
   return #node.$expTypeList > 1 or node.$expType.$kind == .DDD;
}


macro _declNodeKindEnum() {
   {
      let mut statList:List<stat> = [];
      if! let workNodeKindList = __var.nodeKindList {
         foreach kind in workNodeKindList@@List<str> {
            statList.insert( `{ ,,,kind, } );
         }
      };
   }
   pub enum nodeKindEnum {
      ,,statList
   }
}
_declNodeKindEnum();


pub fn getUnwraped( node:&Node ) : &Node {
   if! let work = node@@@ExpMRetNode {
      return getUnwraped( work.$mRet );
   }
   if! let work = node@@@ExpParenNode {
      return getUnwraped( work.$exp );
   }
   return node;
}

pub fn getCastUnwraped( node:&Node ) : &Node {
   if! let work = node@@@ExpCastNode {
      return getUnwraped( work.$exp );
   }
   return node;
}

__test {
   pub fn createTestNodes() : RootNode {
      let mut parser = Parser.DefaultPushbackParser.createFromLnsCode(
         "print( 'hoge' );", "test" );

      let mut processInfo = Ast.createProcessInfo( true, true, false );
      let mut scope = new Ast.Scope( processInfo, nil, .Other ##);

      let printToken = parser.getTokenNoErr(##); // print
      parser.getTokenNoErr(##); // (
      let hogeToken = parser.getTokenNoErr(##); // 'hoge'
      parser.getTokenNoErr(##); // )
      parser.getTokenNoErr(##); // ;

      let symbol = unwrap scope.addFunc(
         processInfo, nil, Ast.builtinTypeForm, .Global, true, false);

      let mut nodeManager = new NodeManager();

      let strNode = LiteralStringNode.create( 
         nodeManager, hogeToken.pos, false, false,
         [ Ast.builtinTypeString ], hogeToken, nil, nil );
      let argListNode = ExpListNode.create(
         nodeManager, hogeToken.pos, false, false, strNode.$expTypeList,
         [ strNode ], nil, false );
      let refNode = ExpRefNode.create(
         nodeManager, printToken.pos, false, false, [ symbol.$typeInfo ], symbol );
      let callNode = ExpCallNode.create(
         nodeManager, printToken.pos, false, false, [ Ast.builtinTypeNone ],
         refNode, false, false, argListNode );
      let stmtExp = StmtExpNode.create(
         nodeManager, callNode.$pos, false, false, [ Ast.builtinTypeNone ], callNode );

      let moduleInfo = Ast.headTypeInfo;


      return RootNode.create(
         nodeManager, stmtExp.$pos, false, false, [ Ast.builtinTypeNone ],
         [ stmtExp ], scope, scope, (@), frontInterface.ModuleId.createId(0.0, 0),
         processInfo, moduleInfo, nil,
         new frontInterface.LuneHelperInfo(), nodeManager, {}, {}, {});
   }
}

__test case1(ctrl) {

   let rootNode = createTestNodes();

   __t._isNotT( ctrl, rootNode.canBeLeft() );
}
