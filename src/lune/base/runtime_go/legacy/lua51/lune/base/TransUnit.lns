/*
MIT License

Copyright (c) 2018, 2019 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

_lune_control default_async_all;

subfile use lune.base.TransUnitDecl;
subfile use lune.base.TransUnitExp;
subfile use lune.base.TransUnitStatementList;
subfile use lune.base.TransUnitTest;

import lune.base.Types;
import lune.base.Meta;
import lune.base.Parser;
import lune.base.Util;
import lune.base.Ast;
import lune.base.Nodes;
import lune.base.Writer;
import lune.base.frontInterface;
import lune.base.LuaVer;
import lune.base.Option;
import lune.base.Code;
import lune.base.Log;
import lune.base.LuneControl;
import lune.base.Macro;
import lune.base.TransUnitIF;
import lune.base.Builtin;
import lune.base.Import;
import lune.base.AstInfo;


_lune_control ignore_symbol_;


alias DeclClassMode = TransUnitIF.DeclClassMode;

enum DeclFuncMode {
   Func,
   Class,
   Module,
   Glue,
}

enum ExpSymbolMode {
   Symbol,
   Fn,
   Field,
   FieldNil,
   Get,
   GetNil,
}

pub enum AnalyzeMode {
   Compile,
   Diag,
   Complete,
   Inquire,
}

enum DefaultAsyncMode {
   /** noasync */
   NoAsync,
   /** 関数が async */
   AsyncFunc,
   /** 全て async */
   AsyncAll,
}

class AccessSymPos {
   pri let symbol:&Ast.SymbolInfo {pub};
   pri let pos:&Parser.Position {pub};
}

class RefAccessSymPos {
   pri let symbol:&Ast.SymbolInfo {pub};
   pri let pos:&Parser.Position! {pub};
}

fn clearThePosForModToRef(
   scope:&Ast.Scope, moduleScope:&Ast.Scope ) : &List<RefAccessSymPos>
{
   let mut list:List<RefAccessSymPos> = [];
   scope.filterSymbolTypeInfo(
      scope, moduleScope, .Normal,
      fn ( symInfo:&Ast.SymbolInfo ) __trans : bool {
         if symInfo.$kind == .Var {
            list.insert( new RefAccessSymPos( symInfo, symInfo.$posForModToRef ) );
            symInfo.set_posForModToRef(nil);
         }
         return true;
      });
   return list;
}

/**
初期値を持たない変数について、次処理を行なう。

- 変数の型を確定させる
- 変数の初期値未確定パス検知

ブロック毎にこのインスタンスを生成し、ブロック終了時にシンボルの型を確定する。
*/
class TentativeSymbol {
   /** ブロックで初期値をセットしたシンボルの集合。 */
   pri let mut symbolSet:Set<&Ast.SymbolInfo>;
   /**
初期値をセットした変数の集合。
symbolSet は、 merge でクリアされるが、 initSymSet は保持される。
 */
   pri let mut initSymSet:Set<&Ast.SymbolInfo> {pub&};
   /**
以前のブロックで初期値をセットしたシンボルの集合。
 
例えば、 if {} else {} などの条件分岐するブロックで、
if のブロックを解析中の情報は symbolSet で管理し、
if のブロックを解析終了時に symbolSet を oldSymbolSet にセットする。
そして else のブロックを解析し symbolSet で管理する。
両方が終った所で oldSymbolSet と symbolSet で共通するシンボルの値が確定する。
    */  
   pri let mut oldSymbolSet:Set<&Ast.SymbolInfo>!;

   

   /** 親ブロックを管理する TentativeSymbol */
   pri let mut parent:TentativeSymbol!;
   pri let mut scope:&Ast.Scope {pub};
   pri let mut skipFlag:bool;
   pri let loopFlag:bool;
   pri let mut accessSymList:List<&AccessSymPos> {pub&};

   /** ブロックで値をセットしたシンボルの集合。 */
   pri let mut modSymbolSet:Set<&Ast.SymbolInfo>;
   /** アクセスしたシンボルのセット */
   pri let mut accessSymSet:Set<&Ast.SymbolInfo>;

   /** このブロック処理直前のアクセス可能なローカル変数の posForModToRef を保持。 */
   pri let sym2posForModToRef:&List<RefAccessSymPos>;

   pub fn __init( parent:TentativeSymbol!, scope:&Ast.Scope, moduleScope:&Ast.Scope,
                  loopFlag:bool, refAccessSymPosList:&List<RefAccessSymPos>! )
   { 
      self.symbolSet = (@);
      self.oldSymbolSet = nil;
      self.parent = parent;
      self.scope = scope;
      self.skipFlag = false;
      self.loopFlag = loopFlag;
      self.accessSymList = [];
      self.initSymSet = (@);

      self.accessSymSet = (@);
      self.modSymbolSet = (@);


      let list;
      when! refAccessSymPosList {
         list = refAccessSymPosList;
      } else {
         if loopFlag {
            list = clearThePosForModToRef( scope, moduleScope );
         } else {
            list = [];
         }
      }
      self.sym2posForModToRef = list;
   }

   pub fn modSym( accessSym:&Ast.SymbolInfo ) mut {
      self.modSymbolSet.add( accessSym.getOrg() );
   }
   pub fn addAccessSym( accessSym:&Ast.SymbolInfo ) mut {
      self.accessSymSet.add( accessSym.getOrg() );
   }
   
   /**
このブロック内でアクセスしている未初期化シンボルを登録する。

未初期化シンボルへのアクセスがないかを検出するために利用する。
   */
   pub fn addAccessSymPos( accessSym:&AccessSymPos ) mut {
      self.accessSymList.insert( accessSym );
   }
   /**
   このブロック内でアクセスしているシンボルの登録をクリアする。
   */
   pub fn clearAccessSym() mut {
      if #self.accessSymList ~= 0 {
         self.accessSymList = [];
      }
   }

   /**
指定のシンボルに値をセット済みかどうかチェックする。
セット済みの場合、セット済み集合から除外する。

@return セット済みの場合 true
   */
   pub fn checkAndExclude( mut symbolInfo:&Ast.SymbolInfo ) mut : bool {
      symbolInfo = symbolInfo.getOrg();
      if self.symbolSet.has( symbolInfo ) {
         self.symbolSet.del( symbolInfo );
         return true;
      }
      return false;
   }

   /**
値をセットしたシンボルを登録する。   
   */
   pub fn regist( symbolInfo:&Ast.SymbolInfo, pos:&Parser.Position ) mut : bool {
      self.symbolSet.add( symbolInfo.getOrg() );
      self.initSymSet.add( symbolInfo.getOrg() );
      symbolInfo.set_hasValueFlag( true );

      if self.$scope.isInnerOf( symbolInfo.$scope ) {
         if not symbolInfo.$mutable {
            let mut work = self;
            while true {
               if! work.parent {
                  if work.scope == symbolInfo.$scope {
                     break;
                  }
                  if work.loopFlag {
                     // loop 内で immutable な変数へのセットはサポートしない
                     return false;
                  }
                  work = _exp;
               }
               else {
                  break;
               }
            }
         }
      }

      return true;
   }

   /**
break でそのブロック自体を抜ける場合、
そこまで解析した情報は無意味になる。
よって解析情報を捨てることを通知する。
   */
   pub fn skip() mut {
      foreach symbolInfo in self.symbolSet {
         symbolInfo.clearValue();
      }
      self.skipFlag = true;
   }

   /**
   oldSymbolSet と symbolSet に共通するシンボルを確定し、
   確定した情報を symbolSet にセットする。

@return bool self.symbolSet が有効な場合 true
     */   
   fn merge( finishFlag:bool ) mut : bool {
      if self.skipFlag {
         self.skipFlag = false;
         if! let other = self.oldSymbolSet {
            self.symbolSet = other.clone();
         }
         if finishFlag {
            foreach symbolInfo in self.symbolSet {
               symbolInfo.updateValue( symbolInfo.$posForLatestMod );
            }
         }
         return self.oldSymbolSet ~= nil;
      }
      if! let other = self.oldSymbolSet {
         let mut mergedSet = self.symbolSet.clone().and( other );
         if finishFlag {
            foreach symbolInfo in self.symbolSet.clone().or( other ).sub( mergedSet ) {
               symbolInfo.clearValue();
            }
         }
         else {
            foreach symbolInfo in self.symbolSet.clone().or( other ) {
               symbolInfo.clearValue();
            }
         }
         self.symbolSet = mergedSet;
      }
      else {
         if not finishFlag {
            foreach symbolInfo in self.symbolSet {
               symbolInfo.clearValue();
            }
         }
      }
      return true;
   }

   pub fn syncPos() mut {
      if self.loopFlag {
         // loop を抜けた後の変数アクセス判定を行なうために、
         // アクセスとセット両方している変数は、
         // セット位置とアクセス位置を一緒にする。
         // foreach symbol in self.accessSymSet {
         //    if self.modSymbolSet.has( symbol ) and
         //       self.sym2posForModToRef[ symbol ] ~= symbol.$posForModToRef
         foreach info in self.sym2posForModToRef {
            let symbol = info.$symbol;
            if symbol.$posForModToRef {
               symbol.set_posForModToRef( symbol.$posForLatestMod );
            } else {
               symbol.set_posForModToRef( info.$pos );
            }
         }
      }
   }
   
   /*
ブロックの解析処理を終了する。
 
if {} else {} の if のブロック終了時は、 else のブロックが残っているので、
complete は false を指定する。
   */
   pub fn finish( complete:bool ) mut : TentativeSymbol! {
      self.syncPos();
      self.merge( true );
      if! let mut parent = self.parent {
         if complete {
            foreach symbolInfo in self.symbolSet {
               if symbolInfo.$hasValueFlag {
                  if parent.scope.isInnerOf( symbolInfo.$scope ) {
                     parent.symbolSet.add( symbolInfo );
                  }
               }
            }
         }
         else {
            foreach symbolInfo in self.symbolSet {
               symbolInfo.clearValue();
            }
         }

         macro _syncToParent( set:sym ) {
            foreach symbolInfo in self.,,set {
               if symbolInfo.$scope ~= self.scope {
                  parent.,,set.add( symbolInfo );
               }
            }
         }

         _syncToParent( initSymSet );
         _syncToParent( accessSymSet );
         _syncToParent( modSymbolSet );
         return parent;
      }

      return nil;
   }

   pub fn newSet( scope:&Ast.Scope ) mut {
      if self.merge( false ) {
         self.oldSymbolSet = self.symbolSet;
      }
      self.symbolSet = (@);
      self.scope = scope;
   }
}

enum AnalyzingState {
   Other,
   /** コンストラクタ */
   Constructor,
   /** class の __init ブロック */
   InitBlock,
   /** class の static method */
   ClassMethod,
   /** その他の 関数, メソッド */
   Func,
}

/**
expNode から dstType に代入する際に、
暗黙型キャストが必要かどうかをチェックする。

必要な場合は、 変換を行なう ExpCastNode を返す。

*/
form checkImplicitCastCallback( dstType:&Ast.TypeInfo, expNode:&Nodes.Node ): &Nodes.Node!;

class ClosureFun {
   /** 関数シンボル */
   let symbol:&Ast.SymbolInfo;
   /** 関数シンボルにアクセスしているスコープ */
   let mut fromScope:Ast.Scope;

   /**
   アクセスしている関数シンボルがクロージャかどうか判定し、
   クロージャなら、このシンボルもクロージャとして登録する。

   @return クロージャだったら true
   */
   pub fn check() mut : bool {
      if! self.symbol.$typeInfo.$scope$.$closureSymList {
         if #_exp > 0 {
            self.fromScope.setClosure( self.symbol );
            return true;
         }
      }
      return false;
   }

   /**
指定の ClosureFun のリストの関数シンボルアクセスがクロージャかどうかの判定処理を行なう。
   */
   pub static fn checkList( list:List<ClosureFun> ) {
      let mut workList = list;
      let mut remainList:List<ClosureFun> = [];
      while true {
         let mut update = false;
         foreach closureFun in workList {
            if closureFun.check() {
               update = true;
            }
            else {
               remainList.insert( closureFun );
            }
         }
         if not update {
            break;
         }
         workList = remainList;
         remainList = [];
      }
   }
   
}


/**
analyzeExpSymbol で解析した参照シンボルと、
その時点の posForLatestMod 情報を保持する。

analyzeExpSymbol() 実行時点では、
そのシンボルへの書き込みアクセスか参照アクセスかが確定しないため、
一旦このクラスで保持しておいて、
確定後に情報を更新するために利用する。

なお、代入の左辺以外で利用される analyzeExpSymbol() は全て参照なので、
参照として確定している場合は、このクラスは利用せずに直接情報を反映する。
*/
class AccessSymbolSet {
   let mut accessSym2Pos:Map<&Ast.SymbolInfo,&Parser.Position> {pub&};
   pub fn __init() {
      self.accessSym2Pos = {};
   }
   pub fn add( symbol:&Ast.SymbolInfo ) mut {
      self.accessSym2Pos[ symbol ] = symbol.$posForLatestMod;
   }
   pub fn applyPos( excludeSymList:&Set<&Ast.SymbolInfo>! ) mut {
      let! set = excludeSymList {
         set = (@);
      };
      foreach pos, symbol in self.accessSym2Pos {
         if not set.has( symbol.getOrg() ) {
            symbol.set_posForModToRef( pos );
         }
      }
   }
}

class AccessSymbolSetQueue {
   let mut queue:List<AccessSymbolSet>;
   pub fn __init() {
      self.queue = [];
   }
   pub fn push() mut {
      self.queue.insert( new AccessSymbolSet() );
   }
   pub fn pop( symbolList:&Set<&Ast.SymbolInfo>! ) mut {
      self.queue[ #self.queue ].applyPos( symbolList );
      self.queue.remove(##);
   }
   pub fn add( symbol:&Ast.SymbolInfo ) mut {
      self.queue[ #self.queue ].add( symbol );
   }
   pub fn getMap() : &Map<&Ast.SymbolInfo,&Parser.Position> {
      return self.queue[ #self.queue ].$accessSym2Pos;
   }
}

pub class TransUnit extend TransUnitIF.TransUnitBase (Parser.PushbackParser) {

   /** 解析状態 */
   pri let mut analyzingStateQueue:List<AnalyzingState>;

   pri let mut importModuleInfo: frontInterface.ImportModuleInfo;

   /** true の場合は mut 制御が有効 */
   pri let mut validMutControl: bool;
   pri let modifier:TransUnitIF.Modifier;

   /** モジュール名 */
   pri let mut moduleName: str;
   pri let mut moduleType: &Ast.TypeInfo;

   // pri let mut globalScope: Ast.Scope;
   pri let mut topScope: Ast.Scope;
   /** モジュールの最上位スコープ */
   pri let mut moduleScope: Ast.Scope;
   /** macro-statement の最上位スコープ */
   pri let mut macroScope: Ast.Scope!;

   /** */
   pri let mut tentativeSymbol:TentativeSymbol;

   /** クラスの型情報 -> そのクラスを宣言しているノード */
   pri let mut typeInfo2ClassNode: Map<&Ast.TypeInfo,Nodes.DeclClassNode>;
   /** パーサー */
   pri let mut parser: Parser.DefaultPushbackParser;
   pri fn setParser( parser:Parser.DefaultPushbackParser ) mut {
      self.parser = parser;
   }
   
   /** コメントリスト */
   pri let mut commentCtrl: Parser.CommentCtrl;
   
   /** 解析警告メッセージ */
   pri let mut warnMessList: str[] { pub };


   /** このモジュール内から直接 import しているモジュールのセット */
   pri let mut importModuleSet: Set<&Ast.TypeInfo>;
   
   /** subfile 名のリスト */
   pri let mut subfileList: str[];

   /** __func__ シンボルを持つ関数 TypeInfo の set */
   pri let mut has__func__Symbol: Set<&Ast.TypeInfo>;

   /** 解析モード */
   pri let analyzeMode: AnalyzeMode;
   /** 解析対象位置 */
   pri let analyzePos: &Parser.Position;
   /** 解析対象モジュール */
   pri let analyzeModule: str;

   pri let mut helperInfo:frontInterface.LuneHelperInfo;

   /** provide ノード */
   pri let mut provideNode: Nodes.ProvideNode!;
   /** NodeKind -> Node[]  */
   pri let mut nodeManager: Nodes.NodeManager;

   /**
トランスコンパイル先の lua バージョン
   */
   pri let targetLuaVer:&LuaVer.LuaVerInfo;

   pri let moduleId:&frontInterface.ModuleId;

   /** true の場合、 _ で始まるシンボル名チェックをしない */
   pri let mut ignoreToCheckSymbol_:bool;

   pri let ctrl_info: &Types.TransCtrlInfo;

   pri let mut macroCtrl:Macro.MacroCtrl;
   /** マクロを展開する際にマクロを評価する MacroEval のオブジェクト */
   pri let macroEval: &Nodes.MacroEval;
   
   
   // pri let mut typeNameCtrl:&Ast.TypeNameCtrl;

   pri let mut scopeAccess:Ast.ScopeAccess;

   /** クロージャ候補の関数情報リスト */
   let mut closureFunList:List<ClosureFun>;

   /** advertise 宣言されているメンバの型の Set */
   let mut advertisedTypeSet:Set<&Ast.TypeInfo>;

   let mut accessSymbolSetQueue:AccessSymbolSetQueue;

   // local let processInfo:Ast.ProcessInfo;

   let mut importCtrl:Import.Import!;

   /**
インポートしているモジュール内で定義している alias 情報。

alias で置き換えている元の Type → alias の型
   */
   let importedAliasMap: Map<&Ast.TypeInfo,&Ast.AliasTypeInfo> {pub&};

   /** async 宣言のデフォルト */
   let mut defaultAsyncMode: DefaultAsyncMode;

   let class2defaultAsyncMode: Map<&Ast.TypeInfo,DefaultAsyncMode>;


   /** 引数解析中の static method の Scope */
   let mut analyzingStaticMethodArgsScope:&Ast.Scope!;

   let builtinFunc:&Builtin.BuiltinFuncType;

   let mut stdinFile:&Types.StdinFile!;

   let mut baseDir:str!;

   let mut inTestBlock:bool;

   static fn getSuperParam( ctrl_info: &Types.TransCtrlInfo ) : 
      &Types.TransCtrlInfo, Ast.ProcessInfo
   {
      let mut processInfo = Ast.createProcessInfo(
         ctrl_info.validCheckingMutable,
         ctrl_info.validLuaval, ctrl_info.validAstDetailError );
      return ctrl_info, processInfo;
   }
   
   pub fn __init( moduleId:&frontInterface.ModuleId,
                  importModuleInfo:&frontInterface.ImportModuleInfo,
                  macroEval: &Nodes.MacroEval, analyzeModule:str!, mode:AnalyzeMode!,
                  pos:&Parser.Position!, targetLuaVer:&LuaVer.LuaVerInfo,
                  ctrl_info: &Types.TransCtrlInfo,
                  builtinFunc:&Builtin.BuiltinFuncType) 
   {
      super( TransUnit.getSuperParam( ctrl_info )** );

      self.inTestBlock = false;
      self.baseDir = nil;
      self.stdinFile = nil;
      self.builtinFunc = builtinFunc;
      self.analyzingStaticMethodArgsScope = nil;
      self.class2defaultAsyncMode = {};
      let defaultAsyncMode:DefaultAsyncMode;
      if ctrl_info.defaultAsync {
         defaultAsyncMode = .AsyncAll;
      } else {
         defaultAsyncMode = .NoAsync;
      }
      self.defaultAsyncMode = defaultAsyncMode;
      self.importedAliasMap = {};
      self.importModuleSet = (@);
      self.accessSymbolSetQueue = new AccessSymbolSetQueue();
      self.advertisedTypeSet = (@);
      self.closureFunList = [];
      self.scopeAccess = .Normal;
      self.macroEval = macroEval;
      self.macroCtrl = new Macro.MacroCtrl( macroEval );
      self.analyzingStateQueue = [];
      self.ctrl_info = ctrl_info;
      self.ignoreToCheckSymbol_ = false;
      self.moduleId = moduleId;
      self.helperInfo = new frontInterface.LuneHelperInfo();
      self.targetLuaVer = targetLuaVer;
      self.importModuleInfo = importModuleInfo.clone();
      self.has__func__Symbol = (@);
      self.nodeManager = new Nodes.NodeManager();
      self.macroScope = nil;
      self.validMutControl = true;
      self.modifier = new TransUnitIF.Modifier(
         self.validMutControl, self.processInfo );
      self.moduleName = "";
      self.moduleType = Ast.headTypeInfo;
      self.parser = new Parser.DefaultPushbackParser( new Parser.DummyParser() );
      self.subfileList = [];
      self.topScope = self.scope;
      self.moduleScope = self.scope;

      self.tentativeSymbol = new TentativeSymbol(
         nil, self.globalScope, self.moduleScope, false, nil );

      self.typeInfo2ClassNode = {};
      self.commentCtrl = new Parser.CommentCtrl();
      self.warnMessList = [];
      self.analyzeMode = unwrap mode default AnalyzeMode.Compile;
      self.analyzePos = unwrap pos default self.createPosition( 0, 0 );
      self.analyzeModule = unwrap analyzeModule default "";
      self.provideNode = nil;

      self.importCtrl = nil;
   }

   pub override fn getLatestPos() __async : &Parser.Position {
      return self.parser.getLastPos();
   }

   pri fn pushAnalyzingState( state:AnalyzingState ) mut {
      self.analyzingStateQueue.insert( state );
   }

   pri fn popAnalyzingState() mut {
      if #self.analyzingStateQueue == 0 {
         self.error( "underflow analyzingStateQueue" );
      }
      self.analyzingStateQueue.remove(##);
   }

   pri fn inAnalyzingState( state:AnalyzingState ): bool {
      if #self.analyzingStateQueue > 0 {
         return self.analyzingStateQueue[ #self.analyzingStateQueue ] == state;
      }
      return false;
   }

   pri fn addWarnMess( pos: &Parser.Position, mess: str ) __async mut {
      self.warnMessList.insert(
         "%s:%d:%d: warning: %s" ( self.parser.getStreamName(),
                                   pos.lineNo, pos.column, mess ) );
   }

   pri fn addWarnErrMess( pos:&Parser.Position, err:bool, mess: str ) __async mut {
      if err {
         self.addErrMess( pos, mess );
      }
      else {
         self.addWarnMess( pos, mess );
      }
   }
   
   fn getNSInfo( typeInfo:&Ast.TypeInfo ) mut : TransUnitIF.NSInfo {
      let! mut nsInfo = self.nsInfoMap[ typeInfo ] {
         self.error( "not found TypeInfo -- %s" (typeInfo.getTxt(##)) );
      };
      return nsInfo;
   }

   fn getNSType( typeInfo:&Ast.TypeInfo ) mut : Ast.TypeInfo {
      return self.getNSInfo( typeInfo ).$typeInfo;
   }

   /** scope を名前空間に属させるためのダミーの関数を定義 */
   fn createDummyNS( scope:Ast.Scope, pos:&Parser.Position, asyncMode:Ast.Async ) mut {
      let mut dummyType = self.processInfo.createDummyNameSpace(
         scope, Ast.headTypeInfo, asyncMode );
      self.newNSInfo( dummyType, pos );
   }

   

   pri fn prepareTentativeSymbol(
      scope:&Ast.Scope, loopFlag:bool, list:&List<RefAccessSymPos>! ) mut
   {
      self.tentativeSymbol = new TentativeSymbol(
         self.tentativeSymbol, scope, self.moduleScope, loopFlag, list );
   }

   pri fn checkAccesSym() mut {
      foreach accessSym in self.tentativeSymbol.$accessSymList {
         let symbolInfo = accessSym.$symbol;
         if not symbolInfo.$hasValueFlag {
            self.addErrMess(
               accessSym.$pos,
               "This can't access variable have no value -- %s" (symbolInfo.$name) );
         }
      }

      self.tentativeSymbol.clearAccessSym();
   }
   
   pri fn finishTentativeSymbol( complete:bool ) mut {
      self.checkAccesSym();
      let mut tentativeSymbol = self.tentativeSymbol;
      self.tentativeSymbol = unwrap tentativeSymbol.finish( complete );

      {
         let mut errSymMap:Map<str,&Ast.SymbolInfo> = {};
         foreach symbolInfo in tentativeSymbol.$initSymSet {
            if tentativeSymbol.$scope.$parent == symbolInfo.$scope {
               if not symbolInfo.$hasValueFlag {
                  errSymMap[ symbolInfo.$name ] = symbolInfo;
               }
            }
         }
         forsort symbolInfo in errSymMap {
            self.addErrMess(
               self.parser.getLastPos(),
               "There is the case no initialized value for '%s'"
               (symbolInfo.$name) );
         }
      }

      if tentativeSymbol.$scope.$validCheckingUnaccess {
         forsort symbolInfo in tentativeSymbol.$scope.$symbol2SymbolInfoMap {
            if ( not symbolInfo.$posForModToRef or
                 symbolInfo.$posForModToRef ~= symbolInfo.$posForLatestMod ) and
                ( symbolInfo.$kind == .Var or symbolInfo.$kind == .Fun ) and
               not Ast.isPubToExternal( symbolInfo.$accessMode ) and
               not symbolInfo.$name.find( "^_"## )
            {
               if! let pos = symbolInfo.$posForLatestMod or symbolInfo.$pos {
                  self.addWarnMess( pos, "'%s' var isn't accessed" (symbolInfo.$name) );
               }
            }
         }
      }
   }

   pri fn mergeTentativeSymbol( scope:&Ast.Scope ) mut {
      self.checkAccesSym();
      self.tentativeSymbol.newSet( scope );
   }


   pri fn getCurrentClass() : &Ast.TypeInfo {
      let typeInfo = Ast.headTypeInfo;
      let mut scope = self.scope;
      repeat {
         if! scope.$ownerTypeInfo {
            if _exp.$kind == .Class or _exp.$kind == .Module or _exp.$kind == .IF {
               return _exp;
            }
         }
         scope = scope.$parent;
      } scope.isRoot();
      return typeInfo;
   }

   fn getCurrentNSInfo() mut : TransUnitIF.NSInfo {
      return self.getNSInfo( self.getCurrentNamespaceTypeInfo() );
   }

   pri fn pushExtModule(
      externalFlag: bool, name:str, accessMode:Ast.AccessMode, pos:&Parser.Position,
      lazy:bool, lang:Types.Lang, requirePath:str ) mut : TransUnitIF.NSInfo
   {

      let modName = name;
      if! self.scope.getTypeInfoChild( modName ) {
         self.addErrMess( pos, "multiple define -- %s" (name) );
      }

      let mut parentInfo = self.getCurrentNamespaceTypeInfoMut();
      let mut parentScope = self.scope;
      let mut scope = self.pushScope( true ## );
      let mut typeInfo = self.processInfo.createExtModule(
         scope, parentInfo, externalFlag,
         accessMode, name, lang, requirePath );

      parentScope.addExtModule( self.processInfo, name, pos, typeInfo, lazy, lang );

      if not self.typeId2ClassMap[ typeInfo.$typeId ] {
         let namespace = new Nodes.NamespaceInfo( modName, self.scope, typeInfo );
         self.typeId2ClassMap[ typeInfo.$typeId ] = namespace;
      }

      return self.newNSInfo( typeInfo, pos );
   }


   pub fn pushbackStr( name: str, statement: str, pos:&Types.Position ) __async mut;
   pri fn analyzeDecl( accessMode: Ast.AccessMode, staticFlag:
                       bool, firstToken: &Parser.Token,
                       token: &Parser.Token ) mut: Nodes.Node!;
   pri fn analyzeDeclVar(
      mode:Nodes.DeclVarMode,
      accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut: Nodes.Node;
   pri fn analyzeDeclFunc(
      declFuncMode: DeclFuncMode, asyncLocked:bool, abstractFlag: bool,
      overrideFlag: bool, accessMode: Ast.AccessMode, staticFlag: bool,
      mut classTypeInfo: &Ast.TypeInfo!,
      firstToken: &Parser.Token, name: &Parser.Token! ) mut : Nodes.Node;
   pri fn analyzeDeclClass(
      abstractFlag:bool, classAccessMode: Ast.AccessMode,
      classToken: &Parser.Token, mode:DeclClassMode ) mut : Nodes.DeclClassNode;
   pri fn analyzeExp(
      allowNoneType:bool, skipOp2Flag: bool, canLeftExp:bool,
      opLevel: int!, expectType:&Ast.TypeInfo! ) mut : Nodes.Node;
   pri fn analyzeExpOneRVal(
      allowNoneType:bool, skipOp2Flag: bool, opLevel: int!,        
      expectType:&Ast.TypeInfo! ) mut : Nodes.Node;
   pri fn analyzeStatement( termTxt: str! ) mut : Nodes.Node!;
   pri fn analyzeExpSymbol(
      firstToken: &Parser.Token, token: &Parser.Token, mode: ExpSymbolMode,
      prefixExp: &Nodes.Node!, skipFlag: bool, canLeftExp:bool ) mut : Nodes.Node;
   pri fn analyzeExpList(
      allowNoneType:bool, skipOp2Flag: bool, canLeftExp:bool, expNode: &Nodes.Node!,
      expectTypeList: &List<&Ast.TypeInfo>!, contExpect: bool! ) mut : Nodes.ExpListNode;
   pri fn analyzeIfUnwrap( firstToken: &Parser.Token ) mut : Nodes.IfUnwrapNode;
   pub fn getTokenNoErr() __async mut : &Parser.Token;
   pri fn analyzeRefTypeWithSymbol(
      accessMode: Ast.AccessMode, allowDDD:bool, mutMode:Ast.MutMode!,
      symbolNode:&Nodes.Node, parentPub:bool ) mut: Nodes.RefTypeNode;

   pri fn checkAlgeComp( token:&Parser.Token, algeTypeInfo: &Ast.AlgeTypeInfo );


   fn evalMacroOp(
      firstToken: &Parser.Token, macroTypeInfo: &Ast.TypeInfo,
      expList: &Nodes.ExpListNode!, evalMacroCallback:Macro.EvalMacroCallback ) mut;
   fn prepareExpCall(
      position:&Parser.Position, funcTypeInfo:&Ast.TypeInfo,
      genericTypeList:&List<&Ast.TypeInfo>, genericsClass:&Ast.TypeInfo ) mut:
      Map<&Ast.TypeInfo,&Ast.TypeInfo>, &Nodes.ExpListNode!;

   fn isTargetTokenPos( txt:str, pos:&Parser.Position ) : bool {
      if self.analyzePos.lineNo == pos.lineNo and
         self.analyzePos.column >= pos.column and
         self.analyzePos.column <= pos.column + #txt
      {
         return true;
      }
      return false;
   }

   fn isTargetToken( token:&Parser.Token ) : bool {
      return self.isTargetTokenPos( token.txt, token.pos );
   }

   fn dumpSymbolType( accessMode:Ast.AccessMode, name:str, typeInfo:&Ast.TypeInfo ) {
      let mut writer = new Writer.JSON( io.stdout );
      writer.startParent( "lunescript", false );
      writer.startParent( "inquire", false );
      writer.write( "access", Ast.accessMode2txt( accessMode ) );
      writer.write( "name", name );
      writer.write( "type", typeInfo.getTxt( self.typeNameCtrl## ) );
      writer.write( "typeKind", typeInfo.$kind.$_txt );
      writer.write( "static", "%s" (typeInfo.$staticFlag) );
      writer.write( "display", typeInfo.$get_display_stirng_with( typeInfo.$rawTxt, nil ) );
      writer.endElement();
      writer.endElement();
      writer.fin();
      os.exit( 0 );
   }

   fn errorShadowingOp(
      pos:&Parser.Position, symbolInfo:&Ast.SymbolInfo!, errFlag:bool ) mut
   {
      when! symbolInfo {
         let symPos = symbolInfo.$pos;
         when! symPos {
            let mess = "This symbol is shadowed from %d:%d -- %s"
                (pos.lineNo, pos.column, symbolInfo.$name );
            self.addWarnErrMess( symPos, errFlag, mess );
         }
         let mess = "shadowing symbol of %s -- %s"
            (symPos and "%s:%s" (symPos$.lineNo, symPos$.column) or "external",
              symbolInfo.$name );
         self.addWarnErrMess( pos, errFlag, mess );
      }
   }
   
   
   fn errorShadowing( pos:&Parser.Position, symbolInfo:&Ast.SymbolInfo! ) mut {
      self.errorShadowingOp( pos, symbolInfo,not self.ctrl_info.warningShadowing );
   }
   
   pri fn checkShadowing( pos:&Parser.Position, name:str, scope:&Ast.Scope ) mut {
      if name == "_" {
         return;
      }
      let! symbolInfo = self.scope.getSymbolTypeInfo(
         name, scope, self.moduleScope, self.scopeAccess )
      {
         return;
      };

      self.errorShadowing( pos, symbolInfo );
   }

   
   pri fn addLocalVar(
      pos:&Parser.Position, argFlag:bool, canBeLeft:bool, name:str,
      typeInfo: &Ast.TypeInfo, mutable:Ast.MutMode, allowShadow:bool! ) mut:
      &Ast.SymbolInfo
   {
      if not allowShadow {
         self.checkShadowing( pos, name, self.scope );
      }

      if self.analyzeMode == .Inquire and self.isTargetTokenPos( name, pos ) {
         self.dumpSymbolType( .Local, name, typeInfo );
      }
      
      return unwrap self.scope.addLocalVar(
         self.processInfo, argFlag, canBeLeft, name, pos, typeInfo, mutable );
   }


   fn checkImplicitCast(
      alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo>, validCastToGen:bool,
      dstTypeList:&List<&Ast.TypeInfo>, expListNode:&Nodes.ExpListNode,
      callback:checkImplicitCastCallback ) mut : Nodes.ExpListNode!;
}

fn TransUnit.canBeAsyncParam( typeInfo:&Ast.TypeInfo ) : bool {
   if typeInfo.$nilableTypeInfo.$srcTypeInfo.$genSrcTypeInfo == self.builtinFunc.__pipe_ {
      return true;
   }
   return Ast.TypeInfo.canBeAsyncParam( typeInfo );
}


/** 最高優先度 */
let mut opTopLevel = 0;

fn setupOpLevel() : &Map<str,int>, &Map<str,int> {
   let op2levelMap:Map<str,int> = {};
   let op1levelMap:Map<str,int> = {};
   
   let mut opLevelBase = 0;
   fn regOpLevel( opnum: int, opList: str[@] ) __trans {
      opLevelBase = opLevelBase + 1;
      if opnum == 1 {
         foreach op in opList {
            op1levelMap[ op ] = opLevelBase;
         }
      }
      else {
         foreach op in opList {
            op2levelMap[ op ] = opLevelBase;
         }
      }
   }
   regOpLevel( 2, [@ "=" ] );
   regOpLevel( 2, [@ "or" ] );
   regOpLevel( 2, [@ "and" ] );
   regOpLevel( 2, [@ "<", ">", "<=", ">=", "~=", "==" ] );
   regOpLevel( 2, [@ "|" ] );
   regOpLevel( 2, [@ "~" ] );
   regOpLevel( 2, [@ "&" ] );
   regOpLevel( 2, [@ "|<<", "|>>" ] );
   regOpLevel( 2, [@ ".." ] );
   regOpLevel( 2, [@ "+", "-" ] );
   regOpLevel( 2, [@ "*", "/", "//", "%" ] );
   regOpLevel( 1, [@ "`", ",,", ",,,", ",,,," ] );
   regOpLevel( 1, [@ "not", "#", "-", "~" ] );
   regOpLevel( 1, [@ "^" ] );

   opTopLevel = opLevelBase + 1;

   return op2levelMap, op1levelMap;
}

let op2levelMap, op1levelMap = setupOpLevel();



let quotedChar2Code = {
   'a' : 7,    // \a
   'b' : 8,    // \b
   't' : 9,    // \t
   'n' : 10,   // \t
   'v' : 11,   // \v
   'f' : 12,   // \f
   'r' : 13,   // \r
   '\\' : ?\\, // \\
   '"' : ?\",  // "
   "'" : ?\',  // '
};

fn TransUnit.createModifier(
   typeInfo:&Ast.TypeInfo, mutMode: Ast.MutMode ) __async mut : &Ast.TypeInfo
{
   if not self.validMutControl {
      return typeInfo;
   }
   return self.processInfo.createModifier( typeInfo, mutMode );
}

fn TransUnit.createExtType(
   pos:&Parser.Position, typeInfo:&Ast.TypeInfo ) mut :&Ast.TypeInfo
{
   _match self.processInfo.createLuaval( typeInfo, true ) {
      case .OK( work, _ ) {
         return work;
      }
      case .Err( err ) {
         self.addErrMess( pos, "not support -- %s" ( err ) );
         return typeInfo;
      }
   }
}


pub override fn TransUnit.errorAt( pos:&Parser.Position, mess: str ) __async mut : __ {
   self.addErrMess( pos, mess);

   foreach errmess in self.errMessList {
      Util.errorLog( errmess );
   }
   foreach warnmess in self.warnMessList {
      Util.errorLog( warnmess );
   }
   if self.macroCtrl.$analyzeInfo.$mode ~= .None {
      print( "------ near code -----", self.macroCtrl.$analyzeInfo.$mode.$_txt );
      print( self.parser.getNearCode() );
      print( "------" );
   }
   
   Util.err( "has error" );
}

fn TransUnit.createNoneNode( pos: &Parser.Position ) mut : Nodes.Node {
   return Nodes.NoneNode.create(
      self.nodeManager, pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ] );
}

pub fn TransUnit.pushbackToken( token: &Parser.Token ) __async mut {
   self.parser.pushbackToken( token );
}


pub fn TransUnit.newPushback( tokenList: List<&Parser.Token> ) __async mut {
   self.parser.newPushback( tokenList );
}

pub fn TransUnit.getStreamName() __async : str {
   return self.parser.getStreamName();
}

pub fn TransUnit.createPosition( lineNo: int, column: int ) __async : &Parser.Position {
   return self.parser.createPosition( lineNo, column );
}

fn TransUnit.getTokenNoErr() __async mut : &Parser.Token
{
   let mut token;

   let mut commentList:List<&Parser.Token> = [];
   let mut workToken = self.parser.getTokenNoErr();
   while workToken.kind == Parser.TokenKind.Cmnt {
      commentList.insert( workToken );
      workToken = self.parser.getTokenNoErr();
   }
   if workToken.$kind ~= .Eof {
      token = workToken;
      if self.macroCtrl.$analyzeInfo.$mode ~= .None {
         token = self.macroCtrl.expandMacroVal(
            self.typeNameCtrl, self.scope, self, token );
      }
      if not self.ctrl_info.compatComment {
         self.commentCtrl.addDirect( commentList );
      }
   }
   else {
      token = Parser.getEofToken();
      self.commentCtrl.addDirect( commentList );
   }

   if #token.$commentList > 0 {
      self.commentCtrl.add( token );
   }

   return token;
}



fn TransUnit.getToken( allowEof:bool! ) mut : &Parser.Token {
   let token = self.getTokenNoErr();
   if token == Parser.getEofToken() {
      if allowEof {
         return Parser.getEofToken();
      }
      self.error( "EOF" );
   };

   return token;
}

pub fn TransUnit.pushback() __async mut {
   self.parser.pushback();
}

fn TransUnit.pushbackStr( name: str, statement: str, pos:&Types.Position ) __async mut {
   self.parser.pushbackStr( name, statement, pos );
}

enum SymbolMode {
   /** _ で始まるシンボル */
   Must_,
   /** _ で始まってはいけないシンボル */
   MustNot_,
   /** _ で始まってはいけないシンボル。ただし _ は許可 */
   MustNot_Or_,
}

let specialSymbolSet = (@
   "__init",
   "__free",
   "__",
   "_exp"
);

/** ユーザ定義のシンボルとして許可しないキーワード */
let builtinKeywordSet = (@ "self", "super" );

/**
指定 token をシンボルとして利用可能かチェックする。
*/
fn TransUnit.checkSymbol( token: &Parser.Token, mode:SymbolMode ) mut : &Parser.Token {
   if token.kind ~= Parser.TokenKind.Symb and
      token.kind ~= Parser.TokenKind.Kywd and
      token.kind ~= Parser.TokenKind.Type
   {
      self.addErrMess( token.pos, "illegal symbol -- '%s'" ( token.txt) );
   }
   let frontChar = token.txt[1];
   if mode == .Must_ and frontChar ~= ?_ {
      self.addErrMess(
         token.pos, "macro name must begin with '_' -- '%s'" ( token.txt ) );
   }
   elseif mode ~= .Must_ and frontChar == ?_ {
      if not self.ignoreToCheckSymbol_ {
         if mode == .MustNot_Or_ and token.txt == "_" {
            //
         }
         elseif not specialSymbolSet.has( token.txt ) {
            self.addErrMess(
               token.pos, "symbol must not begin with '_' -- '%s'" ( token.txt ) );
         }
      }
   }
   elseif builtinKeywordSet.has( token.txt ) {
      self.addErrMess(
         token.pos, "this symbol is special keyword -- %s" (token.txt) );
   }
   elseif Parser.isLuaKeyword( token.txt ) or
      Parser.isOp2( token.txt ) or Parser.isOp1( token.txt )
   {
      self.addErrMess(
         token.pos, "this symbol is lua keyword -- %s" (token.txt) );
   }
   return token;
}

fn TransUnit.getSymbolToken(mode:SymbolMode) mut : &Parser.Token {
   return self.checkSymbol( self.getToken(##), mode );
}


fn TransUnit.checkToken( token: &Parser.Token, txt: str ) mut : &Parser.Token {
   if token.txt ~= txt {
      self.error( "not found -- %s. expects %s" ( txt, token.txt ) );
   }
   return token;
}

fn TransUnit.checkNextToken( txt: str ) mut : &Parser.Token {
   return self.checkToken( self.getToken(##), txt );
}

/**
次のトークンが、スペースの空きがなく、連続したトークンであるか確認する。

@return &Parser.Token 次のトークン
@return bool 連続したトークンだった場合 true
*/
fn TransUnit.getContinueToken() mut : &Parser.Token, bool {
   let token = self.getToken(##);
   return token, token.consecutive;
}


fn TransUnit.getDefaultAsync(
   kind:&Ast.TypeInfoKind,
   classTypeInfo:&Ast.TypeInfo!, asyncMode:Ast.Async! ) : Ast.Async
{
   when! asyncMode {
      return asyncMode;
   }

   fn process( defaultAsyncMode:DefaultAsyncMode ) : Ast.Async {
      _switch defaultAsyncMode {
         case .AsyncAll, .AsyncFunc {
            return .Async;
         }
         case .NoAsync {
            return .Noasync;
         }
      }
   }

   when! classTypeInfo {
      if! self.class2defaultAsyncMode[ classTypeInfo ] {
         return process( _exp );
      }
   }
   
   switch kind {
      case .Method {
         if self.defaultAsyncMode == .AsyncAll {
            return .Async;
         }
      }
      case .Func, .FormFunc {
         return process( self.defaultAsyncMode );
      }
   }
   return .Noasync;
}

/**
termTxt が表われるまで statement を解析し、 stmtList に格納する。

@param stmtList 解析した statement を格納するリスト
@param firstSwitchingParser Parser を切り替えた初回の処理かどうか。
@param termTxt 終端文字列。 nil の場合は EOF まで解析する。
@return Nodes.Node! 最後に解析した statement
@return int 最後に解析した statement の直前の行
*/
fn TransUnit.analyzeStatementList(
   stmtList: List<&Nodes.Node>,
   mut firstSwitchingParser:bool, termTxt: str! ) mut : Nodes.Node!, int
{
   let mut breakKind = Nodes.BreakKind.None;
   if #stmtList > 0 {
      breakKind = stmtList[ #stmtList ].getBreakKind( .Normal );
   }

   let mut parser2lastLineMap:Map<&Parser.PushbackParser,int> = {};
   fn getLastLineNo() __trans : int {
      if! let lastLineNo = parser2lastLineMap[ self.parser ] {
         return lastLineNo;
      }
      return self.parser.getLastPos().lineNo;
   }
   fn setLastLineNo( lineNo:int ) __trans {
      parser2lastLineMap[ self.parser ] = lineNo;
   }
   
   let mut lastStatement:Nodes.Node! = nil;
   let mut lastLineNo = getLastLineNo();

   // コメントが、直前の文の末尾と同じ行にあるかどうか調べ、
   // 同じ行にある場合は、直前の文のコメントとしてセットする
   fn setTailComment( statement:Nodes.Node! ) __trans: int
   {
      let blank;
      let mut commentList = self.commentCtrl.$commentList;
      if #commentList > 0 {
         when! lastStatement {
            let mut tailComment:&Parser.Token! = nil;
            foreach comment in commentList {
               if comment.pos.lineNo == lastStatement.$pos.lineNo {
                  if not tailComment {
                     lastStatement.set_tailComment( comment );
                     tailComment = comment;
                  }
                  else {
                     // 1行に複数のコメントがあるのはエラー
                     // self.addErrMess(
                     //    comment.pos,
                     //    "there are multi comment per line. -- %s" (comment.txt) );
                  }
               }
               // if! let invalidComment = self.commentCtrl.hasInvalidComment() {
               //    // 1行に複数のコメントがあるのはエラー
               //    // self.addErrMess(
               //    //    invalidComment.pos,
               //    //    "there are multi comment per line. -- %s" (invalidComment.txt) );
               // }
            }
            if tailComment {
               commentList.remove( 1 );
            }
         }
      }
      if #commentList > 0 {
         blank = commentList[ 1 ].pos.lineNo - commentList[ 1 ].getLineCount() - lastLineNo;
      }
      else {
         when! statement {
            blank = statement.$pos.lineNo - lastLineNo;
         }
         else {
            blank = self.parser.getLastPos().lineNo - lastLineNo;
         }
      }
      return blank;
   }

   while true {
      lastLineNo = getLastLineNo();
      let mut statement = self.analyzeStatement( termTxt );
      when! statement {
         if breakKind ~= .None {
            if statement.$kind ~= Nodes.NodeKind.$BlankLine {
               self.addErrMess(
                  statement.$pos,
                  "This statement is not reached -- %s" (breakKind.$_txt) );
            }
         }

         // 空白行と、コメントの処理
         let blank = setTailComment( statement );
         if blank > 1 and not firstSwitchingParser {
            stmtList.insert(
               Nodes.BlankLineNode.create(
                  self.nodeManager, self.createPosition( lastLineNo + 1, 0 ),
                  self.inTestBlock, self.macroCtrl.isInAnalyzeArgMode(),
                  [ Ast.builtinTypeNone ], blank - 1 ) );
         }
         setLastLineNo( self.parser.getLastPos().lineNo );
         if firstSwitchingParser {
            firstSwitchingParser = false;
         }

         stmtList.insert( statement );
         lastStatement = statement;
         if statement.$kind ~= Nodes.NodeKind.$BlankLine {
            breakKind = statement.getBreakKind( .Normal );
         }
         
         statement.addComment( self.commentCtrl.$commentList );
         self.commentCtrl.clear();
      }
      else {
         setTailComment( nil );
         break;   
      }
   }
   return lastStatement, lastLineNo;
}

fn TransUnit.analyzeStatementListSubfile( stmtList: List<&Nodes.Node> ) mut : &Nodes.Node! {
   let statement = self.analyzeStatement(##);

   if! statement {
      if _exp.$kind ~= Nodes.NodeKind.$Subfile {
         self.error( "subfile must have 'subfile' declaration at top." );
      }
   }
   else {
      self.error( "subfile must have 'subfile' declaration at top." );
   }

   return (self.analyzeStatementList( stmtList, true ## ));
}

fn TransUnit.supportLang( lang:LuneControl.Code ) : bool {
   foreach pragma in self.helperInfo.pragmaSet {
      match pragma {
         case .limit_conv_code( codeSet ) {
            return codeSet.has( lang );
         }
      }
   }
   return true;
}

fn TransUnit.analyzeLuneControl(
   firstToken: &Parser.Token ) mut : Nodes.LuneControlNode!
{
   let mut node:Nodes.LuneControlNode! = nil;
   let nextToken = self.getToken(##);

   let pragma;
   switch ( nextToken.txt ) {
      case "disable_mut_control" {
         self.validMutControl = false;
         self.modifier.set_validMutControl( false );
         pragma = LuneControl.Pragma.disable_mut_control;
      }
      case "ignore_symbol_" {
         self.ignoreToCheckSymbol_ = true;
         pragma = LuneControl.Pragma.ignore_symbol_;
      }
      case "load__lune_module" {
         pragma = LuneControl.Pragma.load__lune_module;
      }
      case "limit_conv_code" {
         let mut codeSet:Set<LuneControl.Code> = (@);
         while true {
            let token = self.getToken(##);
            if token.txt == ";" {
               self.pushback();
               break;
            }
            if! let code = LuneControl.Code._from( token.txt ) {
               codeSet.add( code );
            }
            else {
               self.addErrMess( token.pos, "illegal code -- '%s'" (token.txt ) );
            }
         }
         pragma = LuneControl.Pragma.limit_conv_code( codeSet );
      }
      case "use_async" {
         pragma = LuneControl.Pragma.use_async;
      }
      case "run_async_pipe" {
         if not self.helperInfo.pragmaSet.has( LuneControl.Pragma.use_async ) {
            self.addErrMess( nextToken.pos, "must set '_lune_control use_async'" );
         }
         
         let nowMethod = self.getCurrentNamespaceTypeInfo();
         let nowClass = nowMethod.$parentInfo;
         let mut valid = false;
         if nowMethod.$kind == .Method and Ast.isClass( nowClass ) {
            if! let loopMethod = nowClass.$scope$.getTypeInfoChild$( "loop" ) {
               if loopMethod.$kind == .Method and #loopMethod.$argTypeInfoList == 0 {
                  valid = true;
               }
            } 
         }
         if valid {
            pragma = LuneControl.Pragma.run_async_pipe;
         } else {
            self.addErrMess(
               nextToken.pos, 
               "this option only use in method of the class have loop method." );
            return nil;
         }
      }
      case "default_async_func" {
         pragma = LuneControl.Pragma.default_async_func;
         self.defaultAsyncMode = .AsyncFunc;
      }
      case "default_async_all" {
         pragma = LuneControl.Pragma.default_async_all;
         self.defaultAsyncMode = .AsyncAll;
      }
      default {
         self.addErrMess( nextToken.pos, "unknown option -- %s" (nextToken.txt) );
         self.checkNextToken( ";" );
         return nil;
      }
   }

   node = Nodes.LuneControlNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], pragma );
   self.helperInfo.pragmaSet.add( pragma );

   self.checkNextToken( ";" );
   return node;
}

enum TentativeMode {
   /** 関数定義の本体ブロックなど、独立したブロックの最外ブロックに使用する */
   Ignore,
   /** for 文などのループ処理のブロックで使用する */
   Loop,
   /** 単純なブロック文など、一つのブロックで完結する場合に使用する */
   Simple,
   /** if else などの複数ブロックの、if など先頭のブロックで使用する */
   Start,
   /** if elseif else などの複数ブロックの、elseif などの途中のブロックで使用する */
   Merge,
   /** if else などの複数ブロックの、 else などの最後のブロックで使用する */
   Finish,
}

fn TransUnit.analyzeBlock(
   blockKind: Nodes.BlockKind, tentativeMode:TentativeMode, scope: Ast.Scope!,
   refAccessSymPosList:&List<RefAccessSymPos>! ) mut : Nodes.BlockNode
{
   let mut backScope = self.scope;
   when! scope {
      self.scope = scope;
   }
   else {
      self.pushScope( false ## );
   }
   let mut blockScope = self.scope;

   blockScope.addIgnoredVar( self.processInfo );

   let mut nsInfo = self.getCurrentNSInfo();

   switch tentativeMode {
      case .Loop {
         self.prepareTentativeSymbol( self.scope, true, refAccessSymPosList );
      }
      case .Simple, .Start, .Ignore {
         self.prepareTentativeSymbol( self.scope, false, nil );
      }
      case .Merge, .Finish {
         self.mergeTentativeSymbol( self.scope );
      }
   }

   let mut loopFlag = false;
   switch blockKind {
      case .For, .Apply, .While, .Repeat, .Foreach {
         loopFlag = true;
         nsInfo.$loopScopeQueue.insert( self.scope );
      }
   }

   let mut stmtList:List<&Nodes.Node> = [];
   
   let token = self.checkNextToken( "{" );

   self.analyzeStatementList( stmtList, false, "}" );

   self.checkNextToken( "}" );

   
   if loopFlag {
      nsInfo.$loopScopeQueue.remove(##);
   }
   

   when! scope {
      self.scope = backScope;
   }
   else {
      self.popScope();
   }

   let mut node = Nodes.BlockNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      blockKind, blockScope, stmtList );

   if node.getBreakKind( .Normal ) ~= .None {
      self.tentativeSymbol.skip();
   }

   if blockKind ~= .Repeat {
      switch tentativeMode {
         case .Simple, .Finish {
            self.finishTentativeSymbol( true );
         }
         case .Ignore, .Loop {
            self.finishTentativeSymbol( false );
         }
      }
   }

   return node;
}

fn TransUnit.analyzeImportFor(
   pos: &Parser.Position, modulePath:str, assignName:str,
   assigned:bool, lazyLoad:Nodes.LazyLoad ) mut : Nodes.ImportNode
{
   let mut backupScope = self.scope;
   // スコープをルートに変更
   self.scope = self.topScope;

   let macroMode;
   let nearCode:str!;
   if self.macroCtrl.$analyzeInfo.$mode ~= .None {
      macroMode = self.macroCtrl.$analyzeInfo.$mode.$_txt;
      nearCode = self.parser.getNearCode();
   } else {
      macroMode = "";
      nearCode = nil;
   }

   let! mut importObj = self.importCtrl {
      importObj = new Import.Import(
         self.getLatestPos(),
         self.importModuleInfo,
         self.moduleType,
         self.macroCtrl,
         self.typeNameCtrl,
         self.importedAliasMap,
         self.baseDir,
         self.validMutControl );
      self.importCtrl = importObj;
   };

   let moduleLoaderParam = new Import.ModuleLoaderParam(
      self.ctrl_info,
      self.processInfo,
      self.getLatestPos(),
      macroMode,
      nearCode,
      self.validMutControl,
      self.macroEval );
   let mut moduleLoader = importObj.processImport(
      modulePath, moduleLoaderParam );
   
   let moduleInfo;
   __asyncLock {
      let work, err = importObj.loadModuleInfo( moduleLoader );
      when! work {
         moduleInfo = work;
      } else {
         self.error( err );
      }
   }

   foreach symbol in moduleInfo.$exportInfo.$globalSymbolList {
      self.globalScope.addSymbolInfo( self.processInfo, symbol );
   }

   
   // スコープを元に戻す
   self.scope = backupScope;


   // モジュールの末尾のシンボルでスコープに登録する。
   // 例えば hoge.foo.bar をインポートした場合、 bar をスコープに登録する

   let provideInfo = moduleInfo.$exportInfo.$provideInfo;
   let moduleTypeInfo = provideInfo.$typeInfo;
   self.scope.addModule( moduleTypeInfo, moduleInfo.assign( assignName ) );

   let moduleSymbolKind = provideInfo.$symbolKind;
   let mut moduleSymbolInfo:&Ast.SymbolInfo!, shadowing = self.scope.add(
      self.processInfo, moduleSymbolKind, false, false, assignName, pos,
      moduleTypeInfo, .Local, true,
      provideInfo.$mutable and Ast.MutMode.Mut or Ast.MutMode.IMut,
      true, lazyLoad ~= .Off );

   when! shadowing {
      let err = shadowing.$typeInfo ~= moduleTypeInfo;
      self.errorShadowingOp( pos, shadowing, err );
      if err {
         self.error( "failed to import -- %s" (modulePath) );
      }
      moduleSymbolInfo = shadowing;
   }
  
   when! moduleSymbolInfo {
      let info = new Nodes.ImportInfo( pos, modulePath, lazyLoad, assignName,
                                       assigned, moduleSymbolInfo, moduleTypeInfo );
      return Nodes.ImportNode.create(
         self.nodeManager, pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ moduleTypeInfo ], info );
   }
   self.error( "failed to import -- %s" (modulePath) );
}


fn TransUnit.analyzeImport( opeToken: &Parser.Token ) mut : Nodes.ImportNode {
   let lazyLoad:Nodes.LazyLoad;
   if self.getToken(##).txt == "." {
      let modeToken = self.getToken(##);
      switch modeToken.txt {
         case "l" {
            lazyLoad = .On;
         }
         case "d" {
            lazyLoad = .Off;
         }
         default {
            lazyLoad = .Off;
            self.error( "illegal import mode -- %s" (modeToken.txt) );
         }
      }
   } else {
      self.pushback();
      if self.ctrl_info.defaultLazy {
         lazyLoad = .Auto;
      } else {
         lazyLoad = .Off;
      }
   }
   if lazyLoad ~= .Off {
      self.helperInfo.useLazyLoad = true;
   }
   

   let mut moduleToken = self.getToken(##);
   let mut modulePath = moduleToken.txt;
   let mut nextToken:&Parser.Token = moduleToken;

   while true {
      nextToken = self.getToken(##);
      switch nextToken.txt {
         case ".", "/", ":" {
            let demilit = nextToken.txt;
            nextToken = self.getToken(##);
            moduleToken = nextToken;
            modulePath = "%s%s%s" ( modulePath, demilit, moduleToken.txt );
         }
         default {
            break;
         }
      }
   }
   let mut assignName = moduleToken;
   let assigned;
   if nextToken.txt == "as" {
      assignName = self.getSymbolToken( .MustNot_ );
      nextToken = self.getToken(##);
      assigned = true;
   } else {
      assigned = false;
   }
   self.checkToken( nextToken, ";" );

   let mut node;

   __asyncLock {
      node = self.analyzeImportFor(
         opeToken.pos, modulePath, assignName.txt, assigned, lazyLoad );
   }
   self.importModuleSet.add( node.$expType );
   
   return node;
}


fn TransUnit.analyzeTestCase( firstToken:&Parser.Token ) mut : Nodes.TestCaseNode
{
   let mut newScope = self.pushScope( false ## );

   let importNode;

   __asyncLock {
      importNode = self.analyzeImportFor(
         firstToken.pos, "lune.base.Testing", "__t", false, .Off );
   }
   
   let nameToken = self.getSymbolToken( .MustNot_ );

   self.checkNextToken( "(" );

   let ctrlToken = self.getSymbolToken( .MustNot_ );
   let ctrlName = ctrlToken.txt;
   self.checkNextToken( ")" );

   let moduleType = importNode.$expType;
   let! ctrlType = moduleType.$scope$.getTypeInfoChild$( "Ctrl" ) {
      self.error( "not found Testing.Ctrl class" );
   };
   self.addLocalVar(
      ctrlToken.pos, true, false, ctrlToken.txt, ctrlType, .IMut, false );

   self.scopeAccess = .Full;

   self.inTestBlock = true;
   let block = self.analyzeBlock( .Test, .Ignore, newScope, nil );
   self.inTestBlock = false;
   

   self.scopeAccess = .Normal;

   self.popScope();
   
   return Nodes.TestCaseNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], nameToken, importNode, ctrlName, block );
}

fn TransUnit.skipBlock() mut {
   let mut blockDepth = 0;
   while true {
      let token = self.getToken( ## );
      switch token.txt {
         case "{" {
            blockDepth = blockDepth + 1;
         }
         case "}" {
            blockDepth = blockDepth - 1;
            if blockDepth == 0 {
               break;
            }
         }
         default {
         }
      }
   }
}


fn TransUnit.analyzeTest( firstToken:&Parser.Token ) mut : Nodes.Node
{
   let nextToken = self.getToken( ## );
   if nextToken.txt ~= "{" {
      self.pushback();
      return self.analyzeTestCase( firstToken );
   }
   self.checkToken( nextToken, "{" );

   self.inTestBlock = true;
   
   let mut stmtList:List<&Nodes.Node> = [];
   self.analyzeStatementList( stmtList, false, "}" );
   self.checkNextToken( "}" );

   self.inTestBlock = false;
   

   return Nodes.TestBlockNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], stmtList );
}


fn TransUnit.analyzeSubfile( token: &Parser.Token ) __noasync mut : Nodes.SubfileNode {
   if self.scope ~= self.moduleScope {
      self.error( "'module' must be top scope." );
   }


   let mode = self.getToken(##);

   let mut moduleName = "";
   while true {
      let nextToken = self.getToken(##);
      if nextToken.txt == ";" {
         break;
      }
      if moduleName == "" {
         moduleName = nextToken.txt;
      }
      else {
         moduleName = "%s%s" (moduleName, nextToken.txt);
      }
   }
   let mut usePath:str! = nil;
   if moduleName == "" {
      self.addErrMess( token.pos, "illegal subfile" );
   }
   else {
      if mode.txt == "use" {
         usePath = moduleName;
         if frontInterface.searchModule( moduleName, self.baseDir, nil ) {
            self.subfileList.insert( moduleName );
         }
         else {
            self.addErrMess(
               token.pos, "not found subfile -- %s" ( moduleName ) );
         }
      }
      elseif mode.txt == "owner" {
         if frontInterface.getLuaModulePath(
            self.moduleName, self.baseDir ) ~= moduleName
         {
            self.addErrMess(
               token.pos,
               "illegal owner module -- %s, %s"
               ( moduleName, self.moduleName ) );
         }
      }
      else {
         self.addErrMess( mode.pos, "illegal module mode -- %s" ( mode.txt ) );
      }
   }
   return Nodes.SubfileNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], usePath );
}

fn TransUnit.analyzeAsyncLock( asyncToken: &Parser.Token ) mut : Nodes.Node {

   let mut nsInfo = self.getNSInfo( self.getCurrentNamespaceTypeInfo() );
   if nsInfo.isLockedAsync() {
      self.addErrMess( asyncToken.pos, "can't nest __asyncLock." );
   }
   
   nsInfo.incLock();
   
   let block = self.analyzeBlock( .AsyncLock, .Simple, nil, nil );

   nsInfo.decLock();
   
   return Nodes.AsyncLockNode.create(
      self.nodeManager, asyncToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], block );
}

fn TransUnit.analyzeIf( token: &Parser.Token ) mut : Nodes.Node {
   let mut nextToken, continueFlag = self.getContinueToken();
   if continueFlag and nextToken.txt == "!" {
      return self.analyzeIfUnwrap( token );
   }
   self.pushback();

   let mut list:Nodes.IfStmtInfo[] = [];
   let ifExp = self.analyzeExpOneRVal( false, false ## );
   list.insert( new Nodes.IfStmtInfo( .If, ifExp,
                                      self.analyzeBlock( .If, .Start ## ) ) );

   fn checkCond( condExp:&Nodes.Node ) {
      switch condExp.$expType.$kind {
         case .Nilable, .Stem {
            ;
         }
         case .Prim {
            if not condExp.$expType.equals( self.processInfo, Ast.builtinTypeBool ## ) {
               self.addErrMess(
                  condExp.$pos, "This exp never be false -- %s"
                  ( condExp.$expType.getTxt(##)) );
            }
         }
         default {
            self.addErrMess(
               condExp.$pos, "This exp never be false -- %s"
               ( condExp.$expType.getTxt(##)) );
         }
      }
   }
   checkCond( ifExp );

   nextToken = self.getToken( true );
   if nextToken.txt == "elseif" {
      while nextToken.txt == "elseif" {
         let condExp = self.analyzeExpOneRVal( false, false ## );
         list.insert( new Nodes.IfStmtInfo( .ElseIf, condExp,
                                            self.analyzeBlock( .Elseif, .Merge ## ) ));
         checkCond( condExp );
         nextToken = self.getToken( true );
      }
   }

   if nextToken.txt == "else" {
      list.insert( new Nodes.IfStmtInfo(
         .Else, self.createNoneNode( nextToken.pos ),
         self.analyzeBlock( .Else, .Finish ## ) ));
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   return Nodes.IfNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], list );
}

/**
default 部分の処理を行なう。
*/
fn TransUnit.processCaseDefault(
   firstToken:&Parser.Token, mut caseKind:Nodes.CaseKind,
   nextToken:&Parser.Token, hasCase:bool ) mut :
Nodes.BlockNode!, bool
{
   let keyword = firstToken.txt.gsub( "_", "" );
   let fullKeyword = "_%s" (keyword);
   if firstToken.txt == fullKeyword and caseKind ~= .MustFull {
      self.addErrMess( firstToken.pos,
                       "This '%s' hasn't enough 'case' condition." (keyword));
   }
   
   let mut defaultBlock: Nodes.BlockNode! = nil;
   let mut failSafeDefault = false;
   if nextToken.txt == "default" or nextToken.txt == "_default" {
      if firstToken.txt == fullKeyword {
         self.addErrMess(
            nextToken.pos, "'_%s' can't have default." (keyword));
      }
   
      if nextToken.txt == "_default" {
         failSafeDefault = true;
      }
      elseif caseKind == .Full {
         self.addWarnMess(
            nextToken.pos,
            "This '%s' has full case. This 'default' is no reach." (keyword) );
      }
      defaultBlock = self.analyzeBlock(
         .Default, not hasCase and TentativeMode.Simple or TentativeMode.Finish ## );
   }
   else {
      if hasCase {
         self.finishTentativeSymbol( caseKind ~= .Lack );
      }
      self.pushback();
   }
   self.checkNextToken( "}" );

   if not hasCase {
      self.addWarnMess( firstToken.pos,
                        "'%s' should have 'case' blocks." (keyword));
      if defaultBlock {
         self.addErrMess(
            firstToken.pos,
            "'%s' must have 'case' blocks when have 'default' block." (keyword) );
      }
   }

   return defaultBlock, failSafeDefault;
}

fn TransUnit.analyzeSwitch( firstToken: &Parser.Token ) mut : Nodes.SwitchNode {
   let exp = self.analyzeExpOneRVal( false, false ## );

   self.checkNextToken( "{" );

   let mut caseList: Nodes.CaseInfo[] = [];

   let mut condObjSet:Set<&stem> = (@);
   let mut condSymIdSet:Set<int> = (@);
   let mut hasNilCond = false;
   
   let mut nextToken = self.getToken(##);
   let mut firstFlag = true;
   while ( nextToken.txt == "case" ) {
      self.checkToken( nextToken, "case" );
      let condexpList = self.analyzeExpList(
         false, false, false, nil, [ exp.$expType ], true );
      let condBock = self.analyzeBlock(
         .Switch, firstFlag and TentativeMode.Start or TentativeMode.Merge ## );
      if firstFlag {
         firstFlag = false;
      }

      foreach condExp in condexpList.$expList {
         // 同じ case 条件が無いかチェック
         if condExp.$expType.$nilable {
            if hasNilCond {
               self.addWarnMess( condExp.$pos, "multiple case with nil or nilable" );
            } else {
               hasNilCond = true;
            }
         }
         if! let condLiteral = condExp.getLiteral() {
            let literalObj = Nodes.getLiteralObj( condLiteral );
            when! literalObj {
               if condObjSet.has( literalObj ) {
                  self.addErrMess( condExp.$pos, "multiple case exp -- %s" (literalObj) );
               }
               else {
                  condObjSet.add( literalObj );
               }
            }
         } else {
            if! let expRef = condExp@@@Nodes.ExpRefNode {
               let symInfo = expRef.$symbolInfo;
               if condSymIdSet.has( symInfo.$symbolId ) {
                  self.addErrMess(
                     condExp.$pos, "multiple case exp -- %s" (symInfo.$name));
               }
               else {
                  condSymIdSet.add( symInfo.$symbolId );
               }
            }
         }
         
         // switch の式と case の条件の型の不一致チェック
         if not exp.$expType.canEvalWith(
            self.processInfo, condExp.$expType, .Equal, {} )
         {
            self.addErrMess(
               condExp.$pos,
               "case exp unmatch type -- %s <- %s"
               (exp.$expType.getTxt(##), condExp.$expType.getTxt(##)) );
         }
      }

      
      caseList.insert( new Nodes.CaseInfo( condexpList, condBock ) );
      nextToken = self.getToken(##);
   }

   let mut caseKind:Nodes.CaseKind;
   if! let enumType = exp.$expType.$srcTypeInfo.$aliasSrc@@@Ast.EnumTypeInfo {
      // enum 値の switch の場合、全ての case をチェックしているかどうかを調べる
      let mut miss = false;
      foreach enumVal in enumType.$name2EnumValInfo {
         if not condObjSet.has( Ast.getEnumLiteralVal( enumVal.$val ) ) {
            miss = true;
            break;
         }
      }
      if not miss {
         if firstToken.txt == "_switch" {
            caseKind = .MustFull;
         }
         else {
            caseKind = .Full;
         }
      }
      else {
         caseKind = .Lack;
      }
   }
   else {
      caseKind = .Lack;
      if firstToken.txt == "_switch" {
         self.addErrMess( exp.$pos, "The condition of '_switch' must be enum." );
      }
   }

   let defaultBlock, failSafeDefault = self.processCaseDefault(
      firstToken, caseKind, nextToken, #caseList ~= 0 );
   
   return Nodes.SwitchNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], exp, caseList, defaultBlock, caseKind, failSafeDefault );
}


fn TransUnit.analyzeMatch( firstToken: &Parser.Token ) mut : Nodes.MatchNode {
   let exp = self.analyzeExpOneRVal( false, false ## );

   let! algeTypeInfo = exp.$expType.$srcTypeInfo@@@Ast.AlgeTypeInfo {
      self.error( "match must have alge value -- %s" (exp.$expType.getTxt(##)) );
   };

   if not self.moduleType.equals(
      self.processInfo, algeTypeInfo.getModule() ## )
   {
      if not self.importModuleSet.has( algeTypeInfo.getModule() ) {
         // alge を宣言しているモジュールを import していない場合
         let fullname = algeTypeInfo.getFullName(
            self.typeNameCtrl, self.scope, true );
         self.addErrMess(
            firstToken.pos,              
            "need to import module -- %s (%s)"
            ( fullname, algeTypeInfo.getTxt(##) ) );
      }
   }  
   
   
   self.checkNextToken( "{" );

   let mut caseList: List<&Nodes.MatchCase> = [];
   let mut algeValNameSet: Set<str> = (@);

   let mut nextToken = self.getToken(##);
   let mut firstFlag = true;
   while ( nextToken.txt == "case" ) {
      self.checkNextToken( "." );
      let valNameToken = self.getToken(##);

      self.checkAlgeComp( valNameToken, algeTypeInfo );

      let! valInfo = algeTypeInfo.getValInfo( valNameToken.txt ) {
         self.error( "not found val -- %s" (valNameToken.txt) );
      };
      if algeValNameSet.has( valNameToken.txt ) {
         self.addErrMess( valNameToken.pos, "multiple val -- %s" (valNameToken.txt) );
      }
      algeValNameSet.add( valNameToken.txt );
      
      let mut valParamNameList:List<&Ast.SymbolInfo> = [];
      nextToken = self.getToken(##);
      let mut blockScope = self.pushScope( false ## );
      if nextToken.txt == "(" {
         foreach paramType in valInfo.$typeList {
            let paramName = self.getSymbolToken( .MustNot_Or_ );
            self.checkShadowing( paramName.pos, paramName.txt, self.scope );

            let mut workType = paramType;
            if Ast.TypeInfo.isMut( paramType ) and
               not Ast.TypeInfo.isMut( exp.$expType )
            {
               workType = self.createModifier( workType, .IMut );
            }
            valParamNameList.insert(
               self.addLocalVar(
                  paramName.pos, false, false, paramName.txt, workType, .IMut ## ));
            nextToken = self.getToken(##);
            if nextToken.txt ~= "," {
               break;
            }
         }
         self.checkToken( nextToken, ")" );
      }
      else {
         self.pushback();
      }
      if #valParamNameList ~= #valInfo.$typeList {
         self.addErrMess( valNameToken.pos,
                          "unmatch param -- %d != %d"
                          (#valParamNameList, #valInfo.$typeList ) );
      }
      let mode = firstFlag and TentativeMode.Start or TentativeMode.Merge;
         
      let block = self.analyzeBlock( .Match, mode, blockScope, nil );
      if firstFlag {
         firstFlag = false;
      }
      self.popScope();
      let valRefNode = Nodes.ExpRefNode.create(
         self.nodeManager, valNameToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ valInfo.$algeTpye ],
         valInfo.$symbolInfo );
      let matchCase = new Nodes.MatchCase( valInfo, valRefNode, valParamNameList, block );

      caseList.insert( matchCase );
      nextToken = self.getToken(##);
   }

   let mut caseKind:Nodes.CaseKind;
   if algeValNameSet.len() == algeTypeInfo.$valInfoNum {
      if firstToken.txt == "_match" { 
         caseKind = .MustFull;
      } else {
         caseKind = .Full;
      }
   } else {
      caseKind = .Lack;
   }

   let defaultBlock, failSafeDefault = self.processCaseDefault(
      firstToken, caseKind, nextToken, #caseList ~= 0 );
   
   return Nodes.MatchNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], exp, algeTypeInfo, caseList, defaultBlock,
      caseKind, failSafeDefault );
}



fn TransUnit.analyzeWhile( token: &Parser.Token ) mut : Nodes.WhileNode {

   let refAccessSymPosList = clearThePosForModToRef( self.scope, self.moduleScope );
   
   let cond = self.analyzeExpOneRVal( false, false## );
   let mut infinit = false;
   if cond.$expType == Ast.builtinTypeBool {
      if! let literal = cond.getLiteral() {
         match literal {
            case .Bool( val ) {
               infinit = val;
            }
         }
      }
   } elseif not cond.$expType.$nilable {
      infinit = true;
   }
   
   return Nodes.WhileNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], cond, infinit,
      self.analyzeBlock( .While, .Loop, nil, refAccessSymPosList ) );
}

fn TransUnit.analyzeRepeat( token: &Parser.Token ) mut : Nodes.RepeatNode {
   let mut scope = self.pushScope( false## );
   let mut node = Nodes.RepeatNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      self.analyzeBlock( .Repeat, .Loop, scope, nil ),
      self.analyzeExpOneRVal( false, false ## ) );

   // repeat は、ブロックの後に条件があって、
   // その条件でブロック内のシンボルにアクセスできるので、
   // finishTentativeSymbol はここで行なう。
   self.finishTentativeSymbol( false );
      
   self.popScope();

   self.checkNextToken( ";" );
   return node;
}

fn TransUnit.analyzeFor( firstToken: &Parser.Token ) mut : Nodes.ForNode {

   let mut scope = self.pushScope( false## );

   let val = self.getToken(##);
   if val.kind ~= Parser.TokenKind.Symb {
      self.error( "not symbol" );
   }
   self.checkNextToken( "=" );
   let mut exp1 = self.analyzeExpOneRVal( false, false## );
   if not Ast.isNumberType( exp1.$expType ) {
      self.addErrMess( exp1.$pos,
                       "exp1 is not number -- %s" (exp1.$expType.getTxt(##)) );
   }
   self.checkNextToken( "," );
   let exp2 = self.analyzeExpOneRVal( false, false## );
   if not Ast.isNumberType( exp2.$expType ) {
      self.addErrMess( exp2.$pos,
                       "exp2 is not number -- %s" (exp2.$expType.getTxt(##)) );
   }
   let token = self.getToken(##);
   let mut exp3:Nodes.Node! = nil;
   if token.txt == "," {
      exp3 = self.analyzeExpOneRVal( false, false## );
      if! exp3 {
         if not Ast.isNumberType( _exp.$expType ) {
            self.addErrMess( _exp.$pos,
                             "exp is not number -- %s" (_exp.$expType.getTxt(##)) );
         }
      }

   }
   else {
      self.pushback();
   }

   if exp1.$expType == Ast.builtinTypeInt and
      exp2.$expType == Ast.builtinTypeReal or
      exp3$.$expType == Ast.builtinTypeReal
   {
      // いずれかが real の場合、 exp1 を real にキャストする
      exp1 = Nodes.ExpCastNode.create(
         self.nodeManager, exp1.$pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeReal ],
         exp1, Ast.builtinTypeReal, .Force );
   }


   let mut nsInfo = self.getCurrentNSInfo();
   let symbolInfo = nsInfo.registerSym( self.addLocalVar(
      val.pos, false, true, val.txt, exp1.$expType, .IMut## ) );

   let mut node = Nodes.ForNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      self.analyzeBlock( .For, .Loop, scope, nil ),
      symbolInfo, exp1, exp2, exp3 );
   self.popScope();

   return node;
}

fn TransUnit.analyzeApply( token: &Parser.Token ) mut : Nodes.ApplyNode {
   let mut scope = self.pushScope( false## );
   let mut varList:List<&Parser.Token> = [];
   let mut nextToken:&Parser.Token = Parser.getEofToken();
   repeat {
      let var = self.getSymbolToken( .MustNot_Or_ );
      if var.kind ~= Parser.TokenKind.Symb {
         self.error( "illegal symbol" );
      }
      varList.insert( var );
      nextToken = self.getToken(##);
   } nextToken.txt ~= ",";
   self.checkToken( nextToken, "of" );

   let expListNode = self.analyzeExpList( false, false, false ## );

   let mut itFunc = Ast.builtinTypeNone;
   
   let expTypeList = expListNode.$expTypeList;
   if #expTypeList < 3 {
      self.addErrMess( expListNode.$pos, "apply must have 3 values -- %s" (#expTypeList) );
   }
   else {
      itFunc = expTypeList[ 1 ].$extedType;
   }

   let mut itemTypeList:List<&Ast.TypeInfo> = [];
   let mut defaultItemType = Ast.builtinTypeStem_;

   let mut readyFlag = false;
   if! let callNode = Nodes.getUnwraped( expListNode.$expList[ 1 ] )@@@Nodes.ExpCallNode {
      let callFuncType = callNode.$func.$expType;
      if callFuncType.equals( self.processInfo, self.builtinFunc.str_gmatch ## ) or
         callFuncType.equals( self.processInfo, self.builtinFunc.string_gmatch ## )
      {
         itemTypeList.insert( Ast.builtinTypeString );
         defaultItemType = Ast.builtinTypeString.$nilableTypeInfo;
         readyFlag = true;
      }
   }

   if not readyFlag {
      switch itFunc.$kind {
         case .Func, .FormFunc, .Form {
         }
         default {
            self.addErrMess(
               expListNode.$pos,
               "The 1st value must be iterator function. -- %s" (itFunc.getTxt(##)) );
         }
      }
      
      if #itFunc.$argTypeInfoList ~= 2 {
         self.addErrMess(
            expListNode.$pos,
            "iterator function must has two arguments. -- %s" (itFunc.getTxt(##)) );
      }
      else {
         let arg2Type = itFunc.$argTypeInfoList[ 2 ];
         if not arg2Type.$nilable {
            self.addErrMess(
               expListNode.$pos,
               "the 2nd argument of iterator function must be nilable. -- %s"
               (itFunc.getTxt(##)) );
         }
      }
      
      if #itFunc.$retTypeInfoList == 0 {
         self.addErrMess( expListNode.$pos, "iterator function must return value." );
      }
      else {
         let iteRetType = itFunc.$retTypeInfoList[ 1 ];
         if not iteRetType.$nilable {
            self.addErrMess(
               expListNode.$pos,
               "iterator function must return nilable type at 1st." );
         }
      }
      
      foreach itemType, index in itFunc.$retTypeInfoList {
         let mut workType = itemType;
         if index == 1 {
            if itemType.$nilable {
               workType = workType.$nonnilableType;
            }
         }
         itemTypeList.insert( workType );
      }
   }


   let nsInfo = self.getCurrentNSInfo();
   let mut varSymList:List<&Ast.SymbolInfo> = [];
   foreach var, index in varList {
      let mut itemType = defaultItemType;
      if index <= #itemTypeList {
         itemType = itemTypeList[ index ];
      }
      varSymList.insert( nsInfo.registerSym(
         self.addLocalVar( var.pos, false, true, var.txt, itemType, .IMut## ) ) );
   }
   

   let block = self.analyzeBlock( .Apply, .Loop, scope, nil );
   self.popScope();

   return Nodes.ApplyNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      varSymList, expListNode, block );
}

fn TransUnit.convToExtTypeList(
   pos:&Parser.Position,
   typeInfo:&Ast.TypeInfo, list:&List<&Ast.TypeInfo> ) mut : &List<&Ast.TypeInfo>
{
   if typeInfo.$nonnilableType.$kind ~= .Ext {
      return list;
   }
   let newList, mess = Ast.convToExtTypeList( self.processInfo, list );
   when! newList {
      return newList;
   }
   self.addErrMess( pos, mess );
   return list;
}


fn TransUnit.analyzeForeach( token: &Parser.Token, sortFlag: bool ) mut : Nodes.Node {
   let mut scope = self.pushScope( false## );
   let mut mainSymToken:&Parser.Token = Parser.getEofToken();
   let mut subSymToken:&Parser.Token! = nil;
   let mut mainSym:&Ast.SymbolInfo;
   let mut subSym:&Ast.SymbolInfo! = nil;
   let mut nextToken:&Parser.Token = Parser.getEofToken();
   for index = 1, 2 {
      let symbol = self.getToken(##);
      if symbol.kind ~= Parser.TokenKind.Symb {
         self.error( "illegal symbol" );
      }
      if index == 1 {
         mainSymToken = symbol;
      }
      else {
         subSymToken = symbol;
      }
      nextToken = self.getToken(##);
      if nextToken.txt ~= "," {
         break;
      }
   }
   self.checkToken( nextToken, "in" );


   
   let exp = self.analyzeExpOneRVal( false, false## );
   if exp.$expType.$kind == .Ext {
      let nsInfo = self.getCurrentNSInfo();
      if not nsInfo.canAccessNoasync() {
         // __noasync 以外で Luaval にはアクセスできない。
         self.addErrMess(
            exp.$pos,
            "can't access the luaval with the foreach on __async. -- %s in %s"
            (exp.$expType.getTxt(##), nsInfo.$typeInfo.getTxt(##)) );
      }
   }

   fn checkSortType( sortKeyType:&Ast.TypeInfo ) {
      if sortFlag {
         switch sortKeyType.$srcTypeInfo.$extedType {
            case Ast.builtinTypeString,
                 Ast.builtinTypeInt,
                 Ast.builtinTypeReal,
                 // stem はソートできる保証はないが、
                 // ここでエラーにすると LiteralMapNode.setupLiteralTokenList に
                 // 影響があるので、 ここではエラーとしない。
                 Ast.builtinTypeStem
            {
            }
            default {
               self.addErrMess(
                  exp.$pos,
                  "This type can't use forsort -- %s" ( sortKeyType.getTxt(##) ) );
            }
         }
      }
   }
   

   let mut nsInfo = self.getCurrentNSInfo();
  
   let expType = exp.$expType.$extedType;
   let itemTypeInfoList = self.convToExtTypeList(
      token.pos, exp.$expType, expType.$itemTypeInfoList );
   switch expType.$kind {
      case .Map {
         mainSym = nsInfo.registerSym( self.addLocalVar( 
            mainSymToken.pos, false, true,
            mainSymToken.txt, itemTypeInfoList[ 2 ], .IMut## ) );
         if! subSymToken {
            subSym = nsInfo.registerSym( self.addLocalVar(
               _exp.$pos, false, true, _exp.txt, itemTypeInfoList[ 1 ], .IMut## ) );
         }
         checkSortType( itemTypeInfoList[ 1 ] );
      }
      case .Set {
         when! subSymToken {
            self.addErrMess( subSymToken.pos, "Set can't use index" );
         }
         mainSym = nsInfo.registerSym( self.addLocalVar(
            mainSymToken.pos, false, true,
            mainSymToken.txt, itemTypeInfoList[ 1 ], .IMut## ) );
         checkSortType( itemTypeInfoList[ 1 ] );
      }
      case .List, .Array {
         if sortFlag {
            self.addErrMess( exp.$pos, "'%s' doesn't support forsort."
                             (expType.$kind.$_txt) );
         }
         mainSym = nsInfo.registerSym( self.addLocalVar(
            mainSymToken.pos, false, true,
            mainSymToken.txt, itemTypeInfoList[ 1 ], .IMut## ) );
         if! subSymToken {
            subSym = nsInfo.registerSym( self.addLocalVar(
               _exp.pos, false, false, _exp.txt, Ast.builtinTypeInt, .IMut## ) );
         }
      }
      default {
         self.errorAt(
            exp.$pos, "unknown kind type of exp for foreach -- %s" (expType.getTxt(##)) );
      }
   }

   let mut seqSym:str! = nil;
   if! let refNode = exp@@@Nodes.ExpRefNode {
      // foreach の sequential データを保持する変数は imut にする。
      let seqSymbol = refNode.$symbolInfo;
      if seqSymbol.$mutable or Ast.TypeInfo.isMut( seqSymbol.$typeInfo ) {
         scope.addOverrideImut( self.processInfo, seqSymbol );
         seqSym = seqSymbol.$name;
      }
   }
   
   let block = self.analyzeBlock( .Foreach, .Loop, scope, nil );

   when! seqSym {
      scope.remove( seqSym );
   }

   self.popScope();

   if sortFlag {
      return Nodes.ForsortNode.create(
         self.nodeManager, token.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         mainSym, subSym, exp, block, sortFlag );
   }
   else {
      return Nodes.ForeachNode.create(
         self.nodeManager, token.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         mainSym, subSym, exp, block );
   }
}

fn TransUnit.analyzeProvide( firstToken: &Parser.Token ) mut : Nodes.ProvideNode {
   let token = self.getSymbolToken( .MustNot_ );
   let symbolNode = self.analyzeExpSymbol(
      firstToken, token, .Symbol, nil, true, false );
   self.checkNextToken( ";" );

   let symbolInfoList = symbolNode.getSymbolInfo();
   if #symbolInfoList ~= 1 {
      self.error( "'provide' must be symbol." );
   }
   let symbolInfo = symbolInfoList[ 1 ];


   let mut node = Nodes.ProvideNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], symbolInfo );
   if self.provideNode {
      self.addErrMess( firstToken.pos, "multiple provide" );
   }
   self.provideNode = node;


   if symbolInfo.$accessMode ~= .Pub {
      self.addErrMess( firstToken.pos,
                       "provide variable must be 'pub'.  -- %s"
                       (symbolInfo.$accessMode));
   }

   return node;
}

fn TransUnit.analyzeScope( firstToken: &Parser.Token ) mut : Nodes.ScopeNode {

   let mut nextToken = self.getToken(##);
   let scopeKind:Nodes.ScopeKind;
   switch nextToken.txt {
      case "root" {
         scopeKind = .Root;
      }
      default {
         self.error( "illegal scope kind. -- %s" (nextToken.txt) );
      }
   }

   let mut symList:List<&Ast.SymbolInfo> = [];
   nextToken = self.getToken( ## );
   if nextToken.txt == "(" {
      nextToken = self.getToken( ## );
      while nextToken.txt ~= ")" {
         let symbolNode = self.analyzeExpSymbol(
            nextToken, nextToken, .Symbol, nil, true, false );
         let workSymList = symbolNode.getSymbolInfo();
         if #workSymList > 0 {
            //let symbol = workSymList[ 1 ];
            symList.insert( workSymList[ 1 ] );
         }
         nextToken = self.getToken( ## );
         switch nextToken.txt {
            case ")" {
            }
            case "," {
               nextToken = self.getToken( ## );
            }
            default {
               self.error(
                  "illegal token: expects ')' or ',' but -- %s" (nextToken.txt) );
            }
         }
      }
   }
   else {
      self.pushback();
   }

   let asyncMode = self.getDefaultAsync( .Func, nil, nil );
   
   // スコープを切り替え
   let mut bakScope = self.scope;
   self.scope = self.topScope;
   let mut localScope = self.pushScope( false ## );

   // 名前空間に属させるためのダミーの関数を定義
   self.createDummyNS( localScope, nextToken.pos, asyncMode );

   // 継承するシンボル情報をスコープに設定設定
   foreach symInfo in symList {
      self.scope.addAlias(
         self.processInfo, symInfo.$name, nextToken.pos, false, symInfo.$accessMode,
         symInfo.$typeInfo.$parentInfo, symInfo );
   }
   

   let mut block = self.analyzeBlock( .Block, TentativeMode.Simple ## );
   let mut node = Nodes.ScopeNode.create( 
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], scopeKind, self.scope, symList, block );

   // スコープを戻す
   self.scope = bakScope;
   
   return node;
}
