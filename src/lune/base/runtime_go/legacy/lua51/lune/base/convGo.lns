/*
MIT License

Copyright (c) 2018,2020 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Ver;
import lune.base.Ast;
import lune.base.Nodes;
import lune.base.Util;
import lune.base.TransUnit;
//import lune.base.LuaMod;
import lune.base.LuaVer;
import lune.base.Parser;
import lune.base.LuneControl;
import lune.base.Types;
import lune.base.Option as LnsOpt;

let MaxNilAccNum = 3;

pub class Opt {
   pub let parent:&Nodes.Node;
   pub fn __init( parent:&Nodes.Node ) {
      self.parent = parent;
   }
}

/** 変換プロセス */
enum ProcessMode {
   /** モジュールスコープの変数の宣言 */
   DeclTopScopeVar,
   /** */
   DeclClass,
   /** クロージャではない関数定義 */
   NonClosureFuncDecl,
   /** 通常処理 */
   Main,
}

class Env {
   pri let mut stack:List<&Nodes.Node>;
   pub fn __init() {
      self.stack = [];
   }
   pub fn push( node:&Nodes.Node ) mut {
      self.stack.insert( node );
   }
   pub fn pop() mut {
      self.stack.remove(##);
   }
   pub fn getLuavm( threading:bool ) : str {
      if #self.stack == 0 {
         if threading {
            return "self.LnsEnv.LuaVM";
         } else {
            return "Lns_getVM()";
         }
      } else {
         return "Lns_getVMSync()";
      }
   }
   pub fn getEnv( threading:bool ) : str {
      if #self.stack == 0 {
         if threading {
            return "self.LnsEnv";
         } else {
            return "Lns_GetEnv()";
         }
      } else {
            return "Lns_GetEnvSync()";
      }
   }
}

fn isMain(funcType:&Ast.TypeInfo) : bool {
   if funcType.$kind == .Func and funcType.$rawTxt == "__main" and
      funcType.$accessMode == .Pub
   {
      return true;
   }
   return false;
}


pub class Option {
   local let packageName:str {pub};
   local let appName:str {pub};
   local let mainModule:str {pub};
}

class convFilter extend Nodes.Filter<Opt> {
   pri let mut stream:Util.SimpleSourceOStream;
   let mut processMode:ProcessMode;
   let mut processModeStack:List<ProcessMode>;
   pri let moduleTypeInfo:&Ast.TypeInfo;
   pri let moduleScope:&Ast.Scope;
   pri let mut builtin2runtime:&Map<&Ast.TypeInfo,str>;
   pri let mut type2gotypeMap:&Map<&Ast.TypeInfo,str>;
   pri let mut nodeManager:Nodes.NodeManager;
   pri let mut enableTest:bool;
   let mut processInfo:Ast.ProcessInfo;
   pri let noneNode:Nodes.NoneNode;
   let option:&Option;
   let modDir:str;
   let mut module2PackSym:Map<&Ast.TypeInfo,str>;
   let mut env:Env;
   let mut moduleType2SymbolMap:Map<&Ast.TypeInfo,&Ast.SymbolInfo>;

   pub fn __init( enableTest:bool, streamName: str, stream: oStream,
                  ast:TransUnit.ASTInfo, option:&Option )
   {
      super(true, ast.$moduleTypeInfo, ast.$moduleTypeInfo.$scope);

      self.moduleType2SymbolMap = {};
      self.env = new Env();
      self.option = option;
      self.processInfo = ast.$processInfo;
      self.stream = new Util.SimpleSourceOStream( stream, nil, 4 );
      self.processMode = .Main;
      self.processModeStack = [];
      self.moduleTypeInfo = ast.$moduleTypeInfo;
      self.moduleScope = unwrap ast.$moduleTypeInfo.$scope;
      self.builtin2runtime = {};
      self.type2gotypeMap = {};
      self.nodeManager = new Nodes.NodeManager();
      self.enableTest = enableTest;
      self.module2PackSym = {};

      let modDir = self.moduleTypeInfo.getParentFullName(
         self.$typeNameCtrl, self.$moduleInfoManager, false );
      self.modDir = modDir.gsub( "@", "" ).gsub( "%.$", "" );

      self.noneNode = Nodes.NoneNode.create(
         self.nodeManager, Parser.noneToken.pos, false,
         [ Ast.builtinTypeNone ] );
   }

   fn getVM( threading:bool, typeInfo:&Ast.TypeInfo ) : str! {
      let! txt = self.builtin2runtime[ typeInfo ] {
         return nil;
      };
      return (txt.gsub( "GETVM", self.env.getLuavm( threading ) ));
   }
   
   fn pushProcessMode( mode:ProcessMode ) mut {
      self.processModeStack.insert( self.processMode );
      self.processMode = mode;
   }
   fn popProcessMode() mut {
      self.processMode = self.processModeStack[ #self.processModeStack ];
      self.processModeStack.remove(##);
   }

   pro fn isPubType( typeInfo:&Ast.TypeInfo ) : bool {
      if Ast.isPubToExternal( typeInfo.$accessMode ) {
         if typeInfo.$kind == .Func {
            switch typeInfo.$parentInfo.$kind {
               case .Class, .Enum {
                  return self.isPubType( typeInfo.$parentInfo );
               }
            }
         }
         return true;
      }
      return typeInfo.getModule() ~= self.moduleTypeInfo;
   }
   pro fn isPubSym( symbol:&Ast.SymbolInfo ) : bool {
      if Ast.isPubToExternal( symbol.$accessMode ) {
         return true;
      }
      return symbol.getModule() ~= self.moduleTypeInfo;
   }
   
   pro fn isExtType( typeInfo:&Ast.TypeInfo ) : bool {
      return typeInfo.getModule() ~= self.moduleTypeInfo;
   }
   pro fn isExtSymbol( symbol:&Ast.SymbolInfo ) : bool {
      return symbol.getModule() ~= self.moduleTypeInfo;
   }

   advertise stream;
}

let ignoreNodeInInnerBlockSet =
    (@
      Nodes.NodeKind.$DeclAlge,         
      Nodes.NodeKind.$DeclEnum,
      //Nodes.NodeKind.$DeclClass,        
      Nodes.NodeKind.$DeclMethod,       
      Nodes.NodeKind.$DeclForm,         
      Nodes.NodeKind.$DeclMacro,        
      //Nodes.NodeKind.$TestBlock,
      Nodes.NodeKind.$TestCase
    );

fn filter( node: &Nodes.Node, filter: convFilter,
           parent: &Nodes.Node )
{
   node.processFilter( filter, new Opt( parent ) );
}

fn isAnyType( typeInfo:&Ast.TypeInfo ): bool {
   let work = typeInfo.$srcTypeInfo;
   if typeInfo.$nilable or work == Ast.builtinTypeStem {
      return true;
   }
   switch typeInfo.$kind {
      case .Stem, .Alge {
         return true;
      }
      case .Alternate {
         if typeInfo.hasBase() {
            return isAnyType( typeInfo.$baseTypeInfo );
         }
         return true;
      }
      case .Ext {
         if typeInfo.$extedType.$kind == .Stem {
            return true;
         }
      }
   }
   return false;
}

fn isClosure( typeInfo:&Ast.TypeInfo ): bool {
   let! scope = typeInfo.$scope {
      return false;
   };
   return #scope.$closureSymList > 0;
}

let golanKeywordSet =
    (@
      "func", "select",
      "defer", "go",
      "chan", "package",
      "const", "fallthrough",
      "range", "continue",
      "var", "map",
      "default"
    );

alge SymbolKind {
   // 引数
   Arg,
   // 変数
   Var( &Ast.SymbolInfo ),
   // メンバ
   Member( external:bool ),
   // 関数・メソッド
   Func( &Ast.TypeInfo ),
   // クラス
   Type( &Ast.TypeInfo, needPrefix:bool ),
   //
   Static( &Ast.TypeInfo ),
   // その他
   Normal,
}

fn concatGLSym( name:str, external:bool ) : str {
   if external {
      let mut frontChar = name[ 1 ];
      let front;
      if frontChar >= ?a and frontChar <= ?z {
         front = "%c" ( ?A + frontChar - ?a );
      } elseif frontChar >= ?A and frontChar <= ?Z {
         front = name.sub( 1, 1 );
      } else {
         front = "G%c" ( frontChar );
      }
      return front .. name.sub( 2## );
   }
   return name;  
   //return (external and "G" or "l") .. name;
}

pub fn outputGoMain( appName:str, mod:str, testing:bool, path:str!,
                     opt:&LnsOpt.RuntimeOpt ):str!
{
  
   let mut lune_path = "main.go";
   when! path {
      if path ~= "" {
         lune_path = path;
      }
   }
   let! mut fileObj = io.open( lune_path, "w" ) {
      return "failed to open -- %s" ( lune_path );
   };

   let base_mainCode = ```
package main

import . "github.com/ifritJP/LuneScript/src/lune/base/runtime_go"
//IMPORT_MAIN:

//IMPORT:
////TEST:import . "lns/lune/base"

func main() {
    Lns_InitModOnce($opt)
    //TEST:Lns_Testing_init()
    Lns_init()
    //TEST:Testing_run( "" )
    //TEST:Testing_outputAllResult(Lns_io_stdout)
}
```;

   let mainMod = mod.gsub( ".*%.", "" );
   let mut code = base_mainCode;
   if mod ~= mainMod {
      // 実行するメインモジュールが別ディレクトリの場合、
      // そのパッケージを import する。
      let importPath = mod.gsub( "%.[^%.]+$", "" ).gsub( "%.", "/" );
      code = code.gsub( "//IMPORT_MAIN:", 'import . "%s/%s"' (appName,importPath) );
   } 

   if testing {
      code = code.gsub( "Lns_init", "Lns_%s_init" (mainMod));
      code = code.gsub( "//TEST:", "" );
      code = code.gsub( 'run%( "" %)', 'run( "lune.base.%s" )' (mainMod) );
      code = code.gsub(
         '//IMPORT:', 'import . "github.com/ifritJP/LuneScript/src/lune/base"' );
   } else {
      code = code.gsub(
         "Lns_init%(%)", "Lns_RunMain( %s___main )" (concatGLSym( mainMod, true )));
   }
   _switch opt.$int2strMode {
      case .Int2strModeNeed0 {
         code = code.gsub( "$opt", "LnsRuntimeOpt{ Int2strModeNeed0 }" );
      }
      case .Int2strModeUnneed0 {
         code = code.gsub( "$opt", "LnsRuntimeOpt{ Int2strModeUnneed0 }" );
      }
      case .Int2strModeDepend {
         code = code.gsub( "$opt", "LnsRuntimeOpt{ Int2strModeDepend }" );
      }
   }
   
   fileObj.write( code );

   return nil;
}


/**
モジュールのトップスコープ以外で定義されている型かどうかを確認する。
*/
fn isInnerDeclType( typeInfo:&Ast.TypeInfo ) : bool {
   if typeInfo.$kind == .FormFunc {
      return typeInfo.$parentInfo.$kind ~= .Module;
   }
      
   if typeInfo.$parentInfo.$kind ~= .Module or
      typeInfo.$scope$.$parent$.$ownerTypeInfo == nil
   {
      return true;
   }
   return false;
}

fn convFilter.getCanonicalName( typeInfo:&Ast.TypeInfo, localFlag:bool ): str {
   let mut enumName = typeInfo.getFullName(
      self.$typeNameCtrl, self.$moduleInfoManager, localFlag );
   return "%s" ( (enumName.gsub( "&", "" )) );
}


fn convFilter.getModuleName( typeInfo:&Ast.TypeInfo, assign:bool ) : str {
   if typeInfo == Ast.headTypeInfo {
      return "";
   }
   let moduleType = typeInfo.getModule();
   if assign {
      if! let symbolInfo = self.moduleType2SymbolMap[ moduleType ] {
         return symbolInfo.$name;
      }
   }
   return (moduleType.$rawTxt.gsub( "@", "" ));
}

fn convFilter.concatSymWithType( name:str, typeInfo:&Ast.TypeInfo ) : str {
   let modName = self.getModuleName( typeInfo.getModule(), false );
   let typeName;
   if modName == "" {
      typeName = name;
   } else {
      typeName = "%s_%s" (modName, name );
   }
   return concatGLSym( typeName, self.isPubType( typeInfo ) );
}

fn convFilter.isSamePackageExtModule( typeInfo:&Ast.TypeInfo ) : bool {
   let! extModuleType =
      typeInfo.$srcTypeInfo.$nonnilableType.$aliasSrc@@@Ast.NormalTypeInfo
   {
      Util.err( "illegal type -- %s" (typeInfo.getTxt(##)) );
   };
   let requireParent = extModuleType.$requirePath.gsub( "[^%.]+$", "" );
   let moduleParent = self.getFull( self.moduleTypeInfo, false ).
      gsub( "[^@%.]+$", "" ).gsub( "@", "" );
   return requireParent == moduleParent;
}

fn convFilter.isSameModDir( moduleTypeInfo:&Ast.TypeInfo ) : bool {
   if moduleTypeInfo.$parentInfo == self.moduleTypeInfo.$parentInfo {
      return true;
   }
   return false;
}

fn convFilter.isSamePackage( typeInfo:&Ast.TypeInfo ) : bool {
   if typeInfo.$kind == .ExtModule {
      return self.isSamePackageExtModule( typeInfo );
   }
   return self.isSameModDir( typeInfo );
}

fn convFilter.needPrefix( typeInfo:&Ast.TypeInfo ) : bool {
   if Ast.isBuiltin( typeInfo.$typeId ) {
      return false;
   }
   return not self.isSamePackage( typeInfo );
}


fn convFilter.getSymbol( kind:SymbolKind, name:str ) : str {
   let mut symbolName;
   if golanKeywordSet.has( name ) {
      symbolName = "_%s" (name);
   }
   else {
      symbolName = name;
   }

   _match kind {
      case .Arg {
         return symbolName;
      }
      case .Var( symbolInfo ) {
         let modName = self.moduleTypeInfo.$rawTxt.gsub( "@", "" );
         if symbolInfo.getModule() ~= self.moduleTypeInfo and symbolInfo.$staticFlag {
            symbolName = "%s_%s" (self.getModuleName(symbolInfo.getModule(), false),
                                   symbolInfo.$name );
         }
         elseif name == "__mod__" {
            symbolName = "%s__mod__" (modName);
         } elseif symbolInfo.$scope == self.moduleScope {
            symbolName = concatGLSym( "%s_" (modName) .. symbolName,
                                      Ast.isPubToExternal( symbolInfo.$accessMode ) );
         } elseif not symbolInfo.$posForModToRef {
            if symbolName ~= "__func__" {
               symbolName = "_";
            }
         }
         if self.needPrefix( symbolInfo.getModule() ) {
            symbolName = "%s.%s" ( self.getModuleName( symbolInfo.getModule(), true ),
                                   symbolName );                      
         }
      }
      case .Member( external ) {
         symbolName = concatGLSym( symbolName, external );
      }
      case .Func( typeInfo ) {
         if typeInfo.$kind == .Method {
            switch symbolName {
               case "_toMap" {
                  return "ToMap";
               }
               default {
                  symbolName = concatGLSym(
                     symbolName, Ast.isPubToExternal( typeInfo.$accessMode ) );
               }
            }
         }
         else {
            let mut prefix:str! = nil;
            switch typeInfo.$parentInfo.$kind {
               case .Module, .Func, .Method {
                  if isInnerDeclType( typeInfo ) {
                     // inner 関数定義の場合、クロージャかどうか判定し、
                     // クロージャでない場合は、関数として定義する。
                     if not isClosure( typeInfo ) {
                        let parentName = typeInfo.getParentFullName(
                           self.$typeNameCtrl, self.$moduleInfoManager, true );
                        symbolName = "%s_%s_%d_"
                            (parentName.gsub( "[%.@]", "_" ), symbolName,
                              typeInfo.$typeId );
                     }
                  } else {
                     if not Ast.isBuiltin( typeInfo.$typeId ) and
                        not self.isPubType( typeInfo )
                     {
                        symbolName = "%s_%d_" (symbolName, typeInfo.$typeId);
                     }
                     symbolName = self.concatSymWithType( symbolName, typeInfo );
                  }
               }
               case .Enum, .Class {
                  let parentInfo = typeInfo.$parentInfo;
                  symbolName = "%s_%s"
                      ( self.getSymbol( .Type( parentInfo, false ), parentInfo.$rawTxt ),
                        symbolName );
                  if not self.isPubType( typeInfo ) {
                     symbolName = "%s_%d_" (symbolName, typeInfo.$typeId);
                  }
               }
               case .ExtModule {
                  symbolName = concatGLSym( symbolName, true );
                  if not self.isSamePackageExtModule( typeInfo.$parentInfo ) {
                     prefix = typeInfo.$parentInfo.$rawTxt;
                  }
               }
               default {
                  Util.err( "%s: not support -- %s:%s"
                            ( __func__,  typeInfo.getFullName(
                               self.$typeNameCtrl, self.$moduleInfoManager, true ),
                              typeInfo.$parentInfo.$kind.$_txt ) );
               }
            }
            if not prefix {
               if self.needPrefix( typeInfo.getModule() ) {
                  prefix = self.getModuleName( typeInfo, true );
               }
            }
            when! prefix {
               symbolName = "%s.%s" ( prefix, symbolName );
            }
         }
      }
      case .Type( typeInfo, needPrefix ) {
         if typeInfo.$kind == .FormFunc {
            return self.getSymbol( .Func( typeInfo ), symbolName );
         }
         let mut workName;
         if isInnerDeclType( typeInfo ) and not Ast.isBuiltin( typeInfo.$typeId ) {
            workName = "%s%d" (name, typeInfo.$typeId );
         } else {
            workName = symbolName;
         }
         symbolName = self.concatSymWithType( workName, typeInfo );
         if needPrefix and self.needPrefix( typeInfo.getModule() ) {
            symbolName = "%s.%s" ( self.getModuleName( typeInfo, true ), symbolName );
         }
      }
      case .Static( typeInfo ) {
         let mut workName = self.getSymbol( .Type( typeInfo, true ), typeInfo.$rawTxt );
         symbolName = "%s__%s" (workName, name); 
      }
      case .Normal {
      }
   }
   
   return symbolName;
}

fn convFilter.getTypeSymbol( typeInfo:&Ast.TypeInfo ) : str {
   let orgType = typeInfo.$srcTypeInfo.$nonnilableType.$aliasSrc;
   return self.getSymbol( .Type( orgType, false ), orgType.$rawTxt );
}

/**
typeInfo のシンボルを取得する。

typeInfo が外部モジュールで定義されている場合、その外部モジュール名を付加する。
*/
fn convFilter.getTypeSymbolWithPrefix( typeInfo:&Ast.TypeInfo ) : str {
   let orgType = typeInfo.$srcTypeInfo.$nonnilableType.$aliasSrc;
   return self.getSymbol( .Type( orgType, true ), orgType.$rawTxt );
}


fn convFilter.getConstrSymbol( typeInfo:&Ast.TypeInfo ) : str {
   return "Init%s" ( self.getTypeSymbol( typeInfo ) );
}

fn convFilter.getFuncSymbol( typeInfo:&Ast.TypeInfo ) : str {
   if typeInfo.$kind == .Method and typeInfo.$staticFlag {
      return self.getSymbol( .Static( typeInfo.$parentInfo ), typeInfo.$rawTxt );
   }
   return self.getSymbol(
      .Func( typeInfo ),
      typeInfo.$rawTxt == "" and "_anonymous" or typeInfo.$rawTxt );
}

fn convFilter.getAlgeSymbol( valInfo:&Ast.AlgeValInfo ): str {
   return self.getSymbol( .Static( valInfo.$algeTpye ), valInfo.$name );
}

fn convFilter.getSymbolSym( symbolInfo:&Ast.SymbolInfo ) : str {
   switch symbolInfo.$kind {
      case .Fun, .Mtd {
         return self.getFuncSymbol( symbolInfo.$typeInfo );
      }
      case .Arg {
         return self.getSymbol( .Arg, symbolInfo.$name );
      }
      case .Var {
         return self.getSymbol( .Var( symbolInfo ), symbolInfo.$name );
      }
      case .Mbr {
         if symbolInfo.$staticFlag {
            return self.getSymbol( .Static( symbolInfo.$namespaceTypeInfo ),
                                   symbolInfo.$name );
         }
         return self.getSymbol( .Member( Ast.isPubToExternal( symbolInfo.$accessMode ) ),
                                symbolInfo.$name );
      }
      case .Typ {
         if symbolInfo.$typeInfo@@@Ast.AliasTypeInfo {
            return self.getSymbol( .Var( symbolInfo ), symbolInfo.$name );
         }
         return self.getTypeSymbol( symbolInfo.$typeInfo );
      }
      default {
         Util.err( "not support -- %s" (symbolInfo.$kind.$_txt) );
      }
   }
}

fn convFilter.getAccessorSym( accessMode:&Ast.AccessMode, name:str ) : str {
   return self.getSymbol( .Member( Ast.isPubToExternal( accessMode ) ), name );
}

fn convFilter.outputSymbol( kind:SymbolKind, name:str ) {
   self.write( self.getSymbol( kind, name ) );
}

fn convFilter.getConv2formName( node:&Nodes.Node ) : str {
   return "conv2Form%d" (node.$id);
}

fn convFilter.getConvGenericsName( node:&Nodes.Node ) : str {
   return "lns_convGenerics%d" (node.$id);
}


fn convFilter.getModuleSym( moduleTypeInfo:&Ast.TypeInfo, addDot:bool ) : str {
   if! let packSym = self.module2PackSym[ moduleTypeInfo ] {
      if addDot {
         return "%s." ( packSym );
      }
      return packSym;
   }
   return "";
}

/**
区切り記号で囲んでいる文字列を C の文字列に変換する。
*/
fn str2gostr( txt:str ) : str {
   let mut work = txt;
   if string.find( work, '^```' ## ) {
      work = work.sub( 4, -4 ).gsub( "^\n", "" );
      work = Parser.quoteStr( work );
   }
   elseif string.find( work, "^'" ## ) {
      work = Parser.convFromRawToStr( work ).gsub( '"', '\\"' );
      work = '"%s"' (work);
   }
   //work = work.gsub( "\\\n", "\\n" );
   
   return work;
}

fn getOrgTypeInfo( typeInfo:&Ast.TypeInfo ) : &Ast.TypeInfo {
   if! let enumType = typeInfo.$srcTypeInfo.$nonnilableType.$aliasSrc@@@Ast.EnumTypeInfo {
      return enumType.$valTypeInfo;
   }
   return typeInfo.$srcTypeInfo.$nonnilableType;
}

fn convFilter.type2gotypeOrg( typeInfo:&Ast.TypeInfo, addClassAster:bool ) : str {
   if typeInfo.$kind == .DDD {
      return "[]LnsAny";
   }
   if isAnyType( typeInfo ) {
      return "LnsAny";
   }
   let orgType = getOrgTypeInfo( typeInfo );
   if! let goType = self.type2gotypeMap[ orgType ] {
      return goType;
   }

   switch orgType.$kind {
      case .Ext {
         if orgType.$extedType.$kind == .Stem {
            return "LnsAny";
         }
         return "*Lns_luaValue";
      }
      case .List, .Array {
         return "*LnsList";
      }
      case .Set {
         return "*LnsSet";
      }
      case .Map {
         return "*LnsMap";
      }
      case .Form {
         // if orgType == Ast.builtinTypeLoadedFunc {
         //    return "*Lns_luaValue";
         // }
         return "LnsForm";
      }
      case .FormFunc {
         return self.getFuncSymbol( typeInfo );
      }
      case .Class {
         if typeInfo.$genSrcTypeInfo == TransUnit.getBuiltinFunc().__pipe_ {
            return "*Lns__pipe";
         }
         let mut symbol = self.getTypeSymbolWithPrefix( typeInfo );
         //symbol = self.getModuleSym( typeInfo.getModule(), true ) .. symbol;
         if addClassAster {
            return "*" .. symbol;
         }
         return symbol;
      }
      case .IF {
         return self.getTypeSymbolWithPrefix( typeInfo );
      }
      case .Alternate {
         return self.type2gotypeOrg( typeInfo.$baseTypeInfo, addClassAster );
      }
   }
   Util.err( "not support yet -- %s" (typeInfo.getTxt(##) ) );
}

fn convFilter.type2gotype( typeInfo:&Ast.TypeInfo ) : str {
   return self.type2gotypeOrg( typeInfo, true );
}


fn getExpType( expListNode:&Nodes.ExpListNode, index:int ) : &Ast.TypeInfo {
   let list = expListNode.$expTypeList;
   if #list >= index {
      return list[ index ];
   }
   Util.err( "not support yet -- %s, %d: %d" (__func__, expListNode.$pos.lineNo, index ) );
}

// LnsAny から dstType への型変換用コードを出力する
fn convFilter.outputAny2Type( dstType:&Ast.TypeInfo ) {
   if not isAnyType( dstType ) and dstType.$kind ~= .Alternate {
      self.write( ".(%s)" (self.type2gotype( dstType )) );
   }
}

// LnsAny から dstType への型変換用コードを出力する
fn convFilter.outputStem2Type( dstType:&Ast.TypeInfo ) {
   if dstType.$kind == .Alternate and dstType.hasBase() {
      self.write( ".(%s)" (self.type2gotype( dstType )) );
   } elseif dstType.$kind == .Class and dstType ~= Ast.builtinTypeString {
      self.write( ".(%sDownCast).To%s()"
                  (self.getTypeSymbolWithPrefix( dstType ),
                    self.getTypeSymbol( dstType )) );
   } else {
      self.outputAny2Type( dstType );
   }
}

// fn convFilter.outputAlt2Type( dstType:&Ast.TypeInfo ) {
//    if dstType.$kind == .Alternate and dstType.hasBase() {
//       self.write( ".(%s)" (self.type2gotype( dstType )) );
//    } else {
//       self.outputStem2Type( dstType );
//    }
// }

macro _declIgnoreNode( name:sym )
{
   {
      let methodName = "process%s" (,,,,name);
      let nodeName = "%sNode" (,,,,name);
   }
   pub override fn convFilter.,,,methodName (
      node: &Nodes.,,,nodeName, opt: Opt ) mut
   {
   }
}

_declIgnoreNode( BlankLine );
_declIgnoreNode( None );

pub override fn convFilter.processImport(
   node: &Nodes.ImportNode, opt: Opt ) mut
{
   if node.$modulePath == "lune.base.Depend" {
      // Depend は builtin しているので、関連モジュールはここで処理する
      self.writeln( "Lns_LuaVer_init()" );
   }

   if not self.isSameModDir( node.$moduleTypeInfo ) and
      not Ast.isBuiltin( node.$moduleTypeInfo.$typeId )
   {
      self.write( "%s." (self.getModuleName( node.$moduleTypeInfo, true )) );
   } 
   self.writeln( "Lns_%s_init()" (self.getModuleName( node.$moduleTypeInfo, false )) );
}

fn convFilter.needConvFormFunc( node:&Nodes.ExpCastNode ) mut : bool {
   let castType = node.$castType.$extedType.$nonnilableType;
   if castType.$kind ~= .FormFunc {
      return false;
   }

   let funcType = node.$exp.$expType.$extedType;
   if #castType.$argTypeInfoList ~= #funcType.$argTypeInfoList or
      #castType.$retTypeInfoList ~= #funcType.$retTypeInfoList
   {
      return true;
   }
   foreach argType, index in castType.$argTypeInfoList {
      if not argType.equals( self.processInfo, funcType.$argTypeInfoList[ index ] ## )
      {
         return true;
      }
   }
   foreach retType, index in castType.$retTypeInfoList {
      if not retType.equals( self.processInfo, funcType.$retTypeInfoList[ index ] ## )
      {
         return true;
      }
   }
   return false;
}


/**
outputImplicitCast 処理で、何らかの変換処理が必要かどうかを調べる。

@return 必要な場合 true
*/
fn needConvCast( dstType:&Ast.TypeInfo, srcType:&Ast.TypeInfo ) : bool {
   switch dstType.$kind {
      case .Nilable {
         return needConvCast( dstType.$nonnilableType, srcType );
      }
      case .Class {
         if dstType == Ast.builtinTypeString or
            srcType.$genSrcTypeInfo.$srcTypeInfo.$nonnilableType ==
            dstType.$genSrcTypeInfo.$srcTypeInfo.$nonnilableType
         {
            return false;
         } else {
            return true;
         }
      }
      case .IF {
         return false;
      }
      case .FormFunc {
         return true;
      }
      case .Alternate {
         if not dstType.hasBase() {
            return false;
         } else {
            return needConvCast( dstType.$baseTypeInfo, srcType );
         }
      }
      case .Form {
         return true;
      }
      case .Prim {
         if not dstType.$nilable {
            switch dstType {
               case Ast.builtinTypeInt {
                  return true;
               }
               case Ast.builtinTypeReal {
                  return true;
               }
               default {
                  return false;
               }
            }
         } else {
            return false;
         }
      }
      default {
         if srcType.$kind == .Class and srcType ~= Ast.builtinTypeString {
            return true;
         } else {
            return false;
         }
      }
   }
}

/**
暗黙キャストの処理。
*/
fn convFilter.outputImplicitCast(
   castType:&Ast.TypeInfo, node: &Nodes.Node, parent: &Nodes.ExpCastNode ) mut {
   switch castType.$kind {
      case .Nilable {
         self.outputImplicitCast( castType.$nonnilableType, node, parent );
      }
      case .Class {
         if castType == Ast.builtinTypeString or
            node.$expType.$kind == .Alternate or
            node.$expType.$genSrcTypeInfo.$srcTypeInfo.$nonnilableType ==
            castType.$genSrcTypeInfo.$srcTypeInfo.$nonnilableType
         {
            filter( node, self, parent );
         } else {
            if isAnyType( node.$expType ) {
               self.write( "%sDownCastF(" (self.getTypeSymbolWithPrefix( castType ) ) );
               filter( node, self, parent );
               self.write( ")" );
            }
            else {
               self.write( "&" );
               filter( node, self, parent );
               self.write( ".%s" (self.getTypeSymbol( castType ) ) );
            }
         }
      }
      case .IF {
         filter( node, self, parent );
         if Ast.isClass( node.$expType ) {
            self.write( ".FP" );
         }
      }
      case .FormFunc {
         let expType = node.$expType;
         if self.needConvFormFunc( parent ) {
            self.write( "%s(" (self.getConv2formName( parent )) );
            filter( node, self, parent );
            self.write( ")");
         }
         else {
            self.write( "%s(" (self.getTypeSymbol( castType )) );
            filter( node, self, parent );
            self.write( ")");
         }
      }
      case .Alternate {
         if not castType.hasBase() {
            if Ast.isClass( node.$expType.$nonnilableType ) {
               self.write( "%s2Stem("
                           (self.getTypeSymbolWithPrefix( node.$expType.$nonnilableType )) );
               filter( node, self, parent );
               self.write( ")" );
            } else {
               filter( node, self, parent );
            }
         } else {
            self.outputImplicitCast( castType.$baseTypeInfo, node, parent );
         }
      }
      case .Form {
         self.write( "%s(" (self.getConv2formName( parent )) );
         filter( node, self, parent );
         self.write( ")" );
      }
      case .Prim {
         if not node.$expType.$nilable {
            switch castType {
               case Ast.builtinTypeInt {
                  self.write( "LnsInt(" );
                  filter( node, self, parent );
                  self.write( ")" );
               }
               case Ast.builtinTypeReal {
                  self.write( "LnsReal(" );
                  filter( node, self, parent );
                  self.write( ")" );
               }
               default {
                  filter( node, self, parent );
               }
            }
         } else {
            filter( node, self, parent );
         }
      }
      default {
         if node.$expType.$nilable and Ast.isClass( node.$expType.$nonnilableType ) {
            self.write( "%s2Stem("
                        (self.getTypeSymbolWithPrefix( node.$expType.$nonnilableType )) );
            filter( node, self, parent );
            self.write( ")" );
         } else {
            filter( node, self, parent );
            if node.$expType.$kind == .Class and
               node.$expType ~= Ast.builtinTypeString
            {
               self.write( ".FP" );
            }
         }
      }
   }
}

// ExpList を Go に展開する時のパターン
enum ExpListKind {
   // ExpList をそのまま展開する
   Direct,
   // []LnsAny として展開する
   Slice,
   // 変換関数が必要
   Conv,
}

fn getExpListKind( dstTypeList:&List<&Ast.TypeInfo>,
                   node:&Nodes.ExpListNode ): ExpListKind
{
   if #dstTypeList < #node.$expList {
      if dstTypeList[ #dstTypeList ].$kind ~= .DDD {
         return .Conv;
      }
   }
   
   if #dstTypeList > 1 and node.$mRetExp {
      foreach exp in node.$expList {
         if! let castNode = exp@@@Nodes.ExpCastNode {
            if needConvCast( castNode.$castType, castNode.$exp.$expType ) {
               return .Conv;
            }
         }
      }
   }
   
   let mut lastExp = node.$expList[ #node.$expList ];
   let hasAbbr;
   if lastExp.$expType.$kind == .Abbr {
      hasAbbr = true;
      if #node.$expList < 2 {
         return .Direct;
      }
      lastExp = node.$expList[ #node.$expList - 1 ];
   }
   else {
      hasAbbr = false;
   }
   
   if lastExp@@@Nodes.ExpToDDDNode {
      // 仮引数に ... がある場合
      let! mRetExp = node.$mRetExp {
         return .Slice;
      };
      if mRetExp.$index == 1 and dstTypeList[ mRetExp.$index ].$kind == .DDD {
         return .Slice;
      }
      return .Conv;
   }

   // 仮引数に ... がない場合
   if lastExp.$expType.$kind == .DDD {
      // 実引数に ... がある場合
      let! mRetExp = node.$mRetExp {
         return .Slice;
      };
      if mRetExp.$index == 1 and dstTypeList[ mRetExp.$index ].$kind == .DDD {
         return .Direct;
      }
   }
   else {
      // 実引数に ... がない場合
      let! mRetExp = node.$mRetExp {
         // 実引数に多値がない場合
         return .Direct;
      };
      // 実引数に多値がある場合
      if not hasAbbr and mRetExp.$index == 1 {
         // 引数に省略がなく、実引数が多値だけの場合
         return .Direct;
      }
   }
   return .Conv;
}

fn convFilter.getConvExpName( nodeId:int, argListNode:&Nodes.ExpListNode ): str
{
   return "%s_convExp%d"  ( self.moduleTypeInfo.$rawTxt.gsub( "@", "" ), nodeId);
}

fn convFilter.processConvExp( nodeId:int, dstTypeList:&List<&Ast.TypeInfo>,
                              argListNode:&Nodes.ExpListNode! ) mut
{
   let! argList = argListNode {
      return;
   };
   
   if getExpListKind( dstTypeList, argList ) ~= .Conv {
      return;
   };

   let mut expList = argList.$expList;
   let mRetIndex = argList.$mRetExp$.$index;

   if not mRetIndex {
      if expList[ #expList ].$expType.$kind == .Abbr {
      } else {
         return;
      }
   };

   let mut workList:List<&Nodes.Node> = [];
   foreach exp in expList {
      let workExp = Nodes.getUnwraped( exp );
      if workExp.$expType.$kind == .Abbr {
         break;
      }
      workList.insert( workExp );
   }
   expList = workList;

   self.writeln( "// for %d" (argList.$pos.lineNo) );
   self.write( "func %s(" (self.getConvExpName( nodeId, argList )) );

   foreach argExp, index in expList {
      if! let exp2ddd = argExp@@@Nodes.ExpToDDDNode {
         foreach exp in exp2ddd.$expList.$expList {
            if index ~= 1 {
               self.write( ", " );
            }
            self.write( "arg%d " (index) );
            self.write( self.type2gotype( exp.$expType ) );
         }
      }
      else {
         if index ~= 1 {
            self.write( ", " );
         }
         if mRetIndex == index {
            self.write( "arg%d []LnsAny" (index) );
            break;
         }
         else {
            self.write( "arg%d " (index) );
            if! let castNode = argExp@@@Nodes.ExpCastNode {
               self.write( self.type2gotype( castNode.$castType ) );
            } else {
               self.write( self.type2gotype( argExp.$expType ) );
            }
         }
      }
   }
   self.write( ") " );

   fn getRetType( retType:&Ast.TypeInfo, index:int ) : &Ast.TypeInfo {
      if retType == Ast.builtinTypeEmpty {
         return argList.getExpTypeNoDDDAt( index );
      }
      return retType;
   }

   let mut retTypeList:List<&Ast.TypeInfo> = [];
   foreach dstType, index in dstTypeList {
      retTypeList.insert( getRetType( dstType, index ) );
   }
      
   
   // 関数戻り値の型宣言
   if #retTypeList >= 2 {
      self.write( "(" );
      foreach retType, index in retTypeList {
         if index ~= 1 {
            self.write( ", " );
         }
         self.write( self.type2gotype( getRetType( retType, index ) ) );
      }
      self.writeln( ") {" );
   }
   elseif #retTypeList == 1 {
      self.write( self.type2gotype( getRetType( retTypeList[ 1 ], 1 ) ) );
      self.writeln( " {" );
   }
   else {
      self.writeln( " {" );
   }

   // 変換コード
   self.write( "    return " );

   when! mRetIndex {
      let mut restIndex:int! = nil;
      foreach retType, index in retTypeList {
         if index ~= 1 {
            self.write( ", " );
         }
         if retType.$kind == .DDD {
            restIndex = index;
            break;
         }
         if index >= mRetIndex {
            let mut wrote = false;
            if index <= #expList {
               let exp = expList[ index ];
               if! let castNode = exp@@@Nodes.ExpCastNode {
                  let statNode = Nodes.ConvStatNode.create(
                     self.nodeManager, exp.$pos, false, [ exp.$expType ],
                     "Lns_getFromMulti( arg%d, 0 )" (index) );
                  self.outputImplicitCast( castNode.$castType, statNode, castNode );
                  wrote = true;
               }
            }
            if not wrote {
               self.write( "Lns_getFromMulti( arg%d, %d )" (mRetIndex, index - mRetIndex) );
               self.outputAny2Type( retType);
            }
         }
         else {
            self.write( "arg%d" (index ) );
         }
      }
      when! restIndex {
         self.write( "Lns_2DDD( " );
         foreach _, index in expList {
            if index >= restIndex {
               if index < #expList {
                  self.write( "arg%d" (index));
               } else {
                  self.write( "arg%d[%d:]" (mRetIndex, index - mRetIndex ));
                  break;
               }
            }
         }
         self.writeln( ")" );
      }
      else {
         self.writeln( "" );
      }
   } else {
      foreach _, index in retTypeList {
         if index ~= 1 {
            self.write( ", " );
         }
         if index <= #expList {
            self.write( "arg%d" (index ) );
         } else {
            self.write( "nil" );
         }
      }
      self.writeln( "" );
   }

   
   self.writeln( "}" );
}

fn convFilter.outputNilAccCall( node: &Nodes.ExpCallNode ) mut {
   if not node.hasNilAccess() {
      return;
   }
   if #node.$expTypeList > MaxNilAccNum {
      let mut anys = "LnsAny";
      let mut nils = "nil";
      let mut lists = "list[0]";
      for count = 2, #node.$expTypeList {
         anys = "%s,LnsAny" (anys);
         nils = "%s,nil" (nils);
         lists = "%s,list[%d]" (lists, count - 1);
      }
      let name = "%s_%d" (self.moduleTypeInfo.$rawTxt.gsub( "@", "" ), node.$id);
      self.write(
      ```
func lns_NilAccCall_%s( env *LnsEnv, call func () (%s) ) bool {
    return env.NilAccPush( Lns_2DDD( call() ) )
}
func lns_NilAccFinCall_%s( ret LnsAny ) (%s) {
    if Lns_IsNil( ret ) {
        return %s
    }
    list := ret.([]LnsAny)
    return %s
}
``` ( name, anys, name, anys, nils, lists) );
   }
}

fn isRetGenerics( node: &Nodes.ExpCallNode ):bool {
   let funcType = node.$func.$expType;
   foreach retType, index in funcType.$retTypeInfoList {
      if retType.$kind == .Alternate and not isAnyType( node.$expTypeList[ index ] )
      {
         return true;
      }
   }
   return false;
}

fn convFilter.processGenericsCall( node:&Nodes.ExpCallNode ) mut {
   if not isRetGenerics( node ) or #node.$expTypeList < 2 {
      return;
   }
   let srcTypeList = node.$func.$expType.$retTypeInfoList;
   let dstTypeList = node.$expTypeList;
   let mut srcTxt = "arg1 %s" (self.type2gotype( srcTypeList[ 1 ] ));
   let mut dstTxt = "%s" (self.type2gotype( dstTypeList[ 1 ] ));

   for index = 2, #srcTypeList {
      srcTxt = "%s,arg%d %s" (srcTxt, index, self.type2gotype( srcTypeList[ index ] ) );
   }
   for index = 2, #dstTypeList {
      dstTxt = "%s,%s" (dstTxt, self.type2gotype( dstTypeList[ index ] ) );
   }
   self.writeln(
      "func %s(%s) (%s) {" (self.getConvGenericsName( node ), srcTxt, dstTxt) );
   self.pushIndent(##);
   self.write( "return " );
   foreach dstType, index in dstTypeList {
      if index > 1 {
         self.write( ", " );
      }
      if index > #srcTypeList {
         self.write( "nil" );
      } else {
         self.write( "arg%d" (index) );
         let srcType = srcTypeList[ index ];
         if srcType.$kind == .Alternate {
            self.outputAny2Type( dstType );
         }
      }
   }
   self.writeln( "" );
   self.popIndent();
   self.writeln( "}" );
}

alge FuncInfo {
   DeclInfo( node:&Nodes.Node, &Nodes.DeclFuncInfo ),
   Type( &Ast.TypeInfo ),
   WithClass( classType:&Ast.TypeInfo, methodType:&Ast.TypeInfo )
}

fn convFilter.outputRetType(retTypeList:&List<&Ast.TypeInfo>) mut {
   switch #retTypeList {
      case 0 {
         self.write( "" );
      }
      case 1 {
         if retTypeList[ 1 ] ~= Ast.builtinTypeNeverRet {
            self.write( " " .. self.type2gotype( retTypeList[1] ) );
         }
      }
      default {
         // 多値返却
         self.write( "(" );
         foreach retType, index in retTypeList {
            if index ~= 1 {
               self.write( ", " );
            }
            self.write( self.type2gotype( retType ) );
         }
         self.write( ")" );
      }
   }
}

class FuncConv {
   let mut argList:List<&Ast.SymbolInfo> {pub};
   let retList:&List<&Ast.TypeInfo> {pub};
   pub fn __init(retList:&List<&Ast.TypeInfo> ) {
      self.argList = [];
      self.retList = retList;
   }
}

pub fn convFilter.outputDeclFunc( funcInfo:FuncInfo ) mut : &FuncConv {
   let typeInfo;
   let name:str!;
   let prefixType;
   let extFlag;
   _match funcInfo {
      case .DeclInfo( node, workDeclInfo ) {
         extFlag = false;
         typeInfo = node.$expType;
         prefixType = typeInfo.$parentInfo;
         if not workDeclInfo.$name {
            if self.processMode == .NonClosureFuncDecl {
               name = "_anonymous";
            }
            else {
               name = nil;
            }
         } else {
            name = typeInfo.$rawTxt;
         }
      }
      case .Type( workTypeInfo ) {
         extFlag = workTypeInfo.$kind == .Ext;
         typeInfo = workTypeInfo;
         prefixType = typeInfo.$parentInfo;
         name = typeInfo.$rawTxt;
      }
      case .WithClass( classType, methodType ) {
         extFlag = false;
         typeInfo = methodType;
         prefixType = classType;
         name = typeInfo.$rawTxt;
      }
   }
   
   if isClosure( typeInfo ) {
      self.write( "func" );
   }
   else {
      if typeInfo.$kind == .Method {
         self.write( "func " );
         self.write( "(self *" );
         self.write( self.getTypeSymbol( prefixType ) );
         self.write( ") " );
      }
      else {
         self.write( "func " );
      }

      if typeInfo.$extedType.$kind ~= .FormFunc {
         when! name {
            self.outputSymbol( .Func( typeInfo ), name );
         }
      }
   }

   self.write( "(" );

   let! workType = typeInfo.getOverridingType() {
      workType = typeInfo;
   };

   let retTypeList:&List<&Ast.TypeInfo>;
   if extFlag {
      retTypeList = unwrap Ast.convToExtTypeList(
         self.processInfo, workType.$retTypeInfoList );
   } else {
      retTypeList = workType.$retTypeInfoList;
   }
                
   let mut funcConv = new FuncConv( retTypeList );
   
   _match funcInfo {
      case .DeclInfo( node, declInfo ) {
         foreach arg, index in declInfo.$argList {
            if index ~= 1 {
               self.write( "," );
            }
            let argType = workType.$argTypeInfoList[ index ];
            if argType.$nonnilableType.$kind == .Alternate {
               if! let argNode = arg@@@Nodes.DeclArgNode {
                  let argName = self.getSymbolSym( argNode.$symbolInfo);
                  self.write( "_%s " (argName) );
                  self.write( self.type2gotype( argType ) );
                  //filter( unwrap argNode.$argType, self, argNode );
                  funcConv.$argList.insert( argNode.$symbolInfo );
               } else {
                  filter( arg, self, node );
               }
            } else {
               filter( arg, self, node );
            }
         }
      }
      case .Type( _ ) {
         foreach argType, index in workType.$argTypeInfoList {
            if index ~= 1 {
               self.write( "," );
            }
            self.write( "arg%d %s" (index, self.type2gotype( argType ) ) );
         }
      }
      case .WithClass( _, _ ) {
         foreach argType, index in workType.$argTypeInfoList {
            if index ~= 1 {
               self.write( "," );
            }
            self.write( "arg%d %s" (index, self.type2gotype( argType ) ) );
         }
      }
   }
   self.write( ")" );

   self.outputRetType( retTypeList );

   return funcConv;
}

fn convFilter.outputConvToForm( node:&Nodes.ExpCastNode ) mut {
   let castType = node.$castType.$nonnilableType.$extedType;
   if castType.$kind ~= .Form {
      return;
   }

   let funcType = node.$exp.$expType.$extedType;
   if node.$exp.$expType.$kind == .Ext and funcType.$srcTypeInfo.$kind == .Form
   {
      self.writeln(
```      
func %s( luaform LnsAny ) LnsForm {
    return func (argList []LnsAny) []LnsAny {
        return %s.RunLoadedfunc( luaform.(*Lns_luaValue), argList )
    }
}``` (self.getConv2formName( node ), self.env.getLuavm( node.$exp.isThreading() ) ) );
      return;
   }
   
   self.writeln( "// for %d: %s"
                 (node.$pos.lineNo, Nodes.getNodeKindName( node.$kind )));
   self.write( "func %s( src func (" (self.getConv2formName( node )) );
   foreach argType, index in funcType.$argTypeInfoList {
      if index > 1 {
         self.write( ", " );
      }
      self.write( "arg%d %s" (index, self.type2gotype( argType )) );
   }
   self.write( ")" );
   self.outputRetType( funcType.$retTypeInfoList );
   self.writeln( ") LnsForm {" );

   self.pushIndent(##);
   self.writeln(
      "return func (argList []LnsAny) []LnsAny {" );

   self.pushIndent(##);
   if #funcType.$retTypeInfoList > 0 {
      self.write ( "return " );
      if #funcType.$argTypeInfoList > 0 {
         self.write ( "Lns_2DDD(" );
      }
   }
   self.write( "src(" );   
   foreach argType, index in funcType.$argTypeInfoList {
      if index > 1 {
         self.write( ", " );
      }
      if argType.$kind == .DDD {
         self.write( "argList[ %d: ]" (index - 1) );
         break;
      }
      
      self.write( "Lns_getFromMulti( argList, %d )" (index - 1 ) );
   }
   self.write( ")" );
   if #funcType.$retTypeInfoList > 0 {
      if #funcType.$argTypeInfoList > 0 {
         self.writeln( ")" );
      } else {
         self.writeln( "" );
      }
   } else {
      self.writeln( "" );
      self.writeln( "return []LnsAny{}" );
   }
   self.popIndent();
   self.writeln( "}" );
   
   self.popIndent();
   self.writeln( "}" );
}

pub override fn convFilter.processConvStat(
   node: &Nodes.ConvStatNode, opt: Opt ) mut
{
   self.write( node.$txt );
}

fn convFilter.outputTopScopeVar( node: &Nodes.DeclVarNode ) mut {
   foreach symbolInfo in node.$symbolInfoList {
      if symbolInfo.$scope == self.moduleScope and node.$mode == .Let {
         self.writeln( "var %s %s" ( self.getSymbolSym( symbolInfo ),
                                     self.type2gotype( symbolInfo.$typeInfo ) ) );
      }
   }
}

fn convFilter.outputConvExt( funcNode:&Nodes.Node ) {
   if! let fieldNode = funcNode@@@Nodes.RefFieldNode {
      if fieldNode.$prefix.$expType.$nonnilableType.$kind ~= .Ext {
         return;
      }
   } else {
      return;
   }
   self.write( "func Lns_callExt%d( args []LnsAny ) (" (funcNode.$id) );
   foreach retType, index in funcNode.$expType.$retTypeInfoList {
      if index > 1 {
         self.write( "," );
      }
      self.write( self.type2gotype( retType ) );
   }
   self.writeln( ") {" );
   self.write( "    return " );
   foreach _, index in funcNode.$expType.$retTypeInfoList {
      if index > 1 {
         self.write( "," );
      }
      self.write( "Lns_getFromMulti( args, %d )" (index - 1) );
   }
   self.writeln( "" );
   self.writeln( "}" );
}

fn convFilter.outputModule( moduleTypeInfo:&Ast.TypeInfo, addDot:bool ) {
   self.write( self.getModuleSym( moduleTypeInfo, addDot ) );
}

fn getModulePrefix( node:&Nodes.ImportNode ) : str {
   if node.$assigned {
      return "%s." (node.$assignName);
   }
   let mod = node.$moduleTypeInfo.$parentInfo.$rawTxt.gsub("@", "");
   if mod == "" {
      return "main.";
   }
   return "%s." (mod);
}

fn convFilter.outputModuleImport( node:&Nodes.DeclClassNode ) mut {
   if node.$expType.$kind ~= .ExtModule or
      ( node.$lang ~= .Go and node.$lang ~= .Same ) or
      self.isSamePackageExtModule( node.$expType )
   {
      return;
   }

   let normalType = unwrap node.$expType@@@Ast.NormalTypeInfo;
   self.write( "import %s " ( node.$expType.$rawTxt ) );

   let mod = normalType.$requirePath.gsub( "%.[^%.]+$", "" );
   if mod.find( "^go/"## ) {
      let workMod = mod.gsub( "^go/", "" ).gsub( "%.", "/").gsub( ":", "." );
      self.writeln( '"%s"' (workMod) );
   } else {
      let path = normalType.$requirePath.gsub( "%.", "/" ).gsub( ":", "." );
      self.writeln( '"%s/%s"' ( self.option.$appName, path ) );
   }
}


fn convFilter.outputImport( node:&Nodes.ImportNode ) mut {
   if self.isSameModDir( node.$moduleTypeInfo ) or
      Ast.isBuiltin( node.$moduleTypeInfo.$typeId )
   {
      return;
   }
   

   self.write( "import " );
   let packSym = node.$assignName;
   if node.$modulePath.find( "^go/"## ) {
      let workMod = node.$modulePath.gsub( "^go/", "" ).gsub( "%.", "/").gsub( ":", "." );
      self.writeln( '%s "%s"' (packSym,(workMod.gsub( "/[^/]+$", "" ))) );
   } else {
      let modulePath, count = node.$modulePath.gsub( "([^%.]+)%.[^%.]+$", "/%1" );
      if count == 0 {
         self.writeln( '%s "%s"' (packSym,self.option.appName));
      } else {
         let modDir = modulePath.gsub( "/", "" );
         self.writeln(
            '%s "%s/%s"' (packSym, self.option.appName, (modDir.gsub( "%.", "/" )) ) );
      }
   }

   self.module2PackSym[ node.$moduleTypeInfo ] = packSym;
}

pub override fn convFilter.processRoot(
   node: &Nodes.RootNode, opt: Opt ) mut
{
   foreach importNode in node.$nodeManager.getImportNodeList() {
      self.moduleType2SymbolMap[ importNode.$moduleTypeInfo ] = importNode.$symbolInfo;
   }
   
   foreach pragma in node.$luneHelperInfo.pragmaSet {
      match pragma {
         case .limit_conv_code( codeSet ) {
            if not codeSet.has( LuneControl.Code.Go ) {
               self.writeln( "// This code is transcompiled by LuneScript." );
               self.writeln( "package %s" (self.option.packageName) );
               return;
            }
         }
      }
   }
   
   fn isUsingInTest( aNode:&Nodes.Node ) : bool {
      foreach testBlock in node.$nodeManager.getTestBlockNodeList() {
         if testBlock.isInnerPos( aNode.$pos ) {
            return true;
         }
      }
      return false;
   }

   form ProcNode( workNode:&Nodes.Node );
   
   macro _filter( list:__exp, proc:__exp ) {
      {}
      {
         let procNode = ,,proc;
         foreach tmpNode in ,,list {
            if self.enableTest or not isUsingInTest( tmpNode ) {
               procNode( tmpNode );
            }
         }
      }
   }
   
   let builtinFuncs = TransUnit.getBuiltinFunc();
   macro _makemap( nameMap:Map<str,List<str>> ) {
      {
         let mut itemStatList:List<stat> = [];
         foreach nameList, key in nameMap {
            switch key {
               case "str" {
                  foreach name in nameList {
                     {
                        let fieldName = "str_%s" (name);
                        let runtime = "GETVM.String_%s" (name);
                        itemStatList.insert( `{ builtinFuncs.,,,fieldName: ,,runtime, } );
                     }
                     {
                        let fieldName = "string_%s" (name);
                        let runtime = "GETVM.String_%s" (name);
                        itemStatList.insert( `{ builtinFuncs.,,,fieldName: ,,runtime, } );
                     }
                  }
               }
            }
         }
      }
      let mut builtin2runtime = {
         ,,itemStatList
         Ast.builtinTypeNone: ""
      };
   }
   _makemap( { "str": [ "gsub", "find", "byte", "format", "rep", "gmatch",
                        "sub", "lower", "upper", "reverse" ] } );

   builtin2runtime[ builtinFuncs.lns_error ] = "panic";
   builtin2runtime[ builtinFuncs.lns_print ] = "Lns_print";
   builtin2runtime[ builtinFuncs.lns_type ] = "Lns_type";
   builtin2runtime[ builtinFuncs.lns_require ] = "Lns_require";
   builtin2runtime[ builtinFuncs.lns_tonumber ] = "Lns_tonumber";
   builtin2runtime[ builtinFuncs.lns__load ] = "GETVM.Load";
   builtin2runtime[ builtinFuncs.lns_loadfile ] = "GETVM.Loadfile";
   builtin2runtime[ builtinFuncs.lns_expandLuavalMap ] = "GETVM.ExpandLuavalMap";

   builtin2runtime[ builtinFuncs.string_dump ] = "GETVM.String_dump";
   
   builtin2runtime[ builtinFuncs.io_open ] = "Lns_io_open";
   builtin2runtime[ builtinFuncs.io_popen ] = "GETVM.IO_popen";
   builtin2runtime[ builtinFuncs.package_searchpath ] = "GETVM.Package_searchpath";
   builtin2runtime[ builtinFuncs.os_clock ] = "GETVM.OS_clock";
   builtin2runtime[ builtinFuncs.os_exit ] = "GETVM.OS_exit";
   builtin2runtime[ builtinFuncs.os_remove ] = "GETVM.OS_remove";
   builtin2runtime[ builtinFuncs.os_date ] = "GETVM.OS_date";
   builtin2runtime[ builtinFuncs.os_time ] = "GETVM.OS_time";
   builtin2runtime[ builtinFuncs.os_difftime ] = "GETVM.OS_difftime";
   builtin2runtime[ builtinFuncs.os_rename ]= "GETVM.OS_rename";
   builtin2runtime[ builtinFuncs.math_random ] = "GETVM.Math_random";
   builtin2runtime[ builtinFuncs.math_randomseed ] = "GETVM.Math_randomseed";
   
   
   self.builtin2runtime = builtin2runtime;


   self.type2gotypeMap = {
      Ast.builtinTypeInt : "LnsInt",
      Ast.builtinTypeReal : "LnsReal",
      Ast.builtinTypeStem : "LnsAny",
      Ast.builtinTypeString : "string",
      Ast.builtinTypeBool : "bool",
      builtinFuncs.ostream_: "Lns_oStream",
      builtinFuncs.istream_: "Lns_iStream",
      builtinFuncs.luastream_ : "Lns_luaStream",
   };

   
   self.writeln( "// This code is transcompiled by LuneScript." );
   self.writeln( "package %s" (self.option.packageName) );
   self.writeln( 'import . "github.com/ifritJP/LuneScript/src/lune/base/runtime_go"');


   foreach workNode in node.$nodeManager.getImportNodeList() {
      self.outputImport( workNode );
   }
   foreach workNode in node.$nodeManager.getDeclClassNodeList() {
      self.outputModuleImport( workNode );
   }


   let initModVar = "init_%s" (self.getModuleName(node.$moduleTypeInfo, false));
   self.writeln( "var %s bool" (initModVar) );

   
   self.pushProcessMode( .DeclTopScopeVar );
   let modSym = unwrap self.moduleScope.getSymbolInfoChild( "__mod__" );
   self.writeln( "var %s string" (self.getSymbolSym( modSym )) );

   _filter( node.$nodeManager.getDeclEnumNodeList(),
            fn ( workNode:&Nodes.Node ) {
               filter( workNode, self, node );
            } );
   foreach workNode in node.$nodeManager.getDeclVarNodeList() {
      self.outputTopScopeVar( workNode );
   }
   self.popProcessMode();

   _filter( node.$nodeManager.getDeclAlgeNodeList(),
            fn ( workNode:&Nodes.Node ) {
               filter( workNode, self, node );
            } );
   _filter( node.$nodeManager.getDeclFormNodeList(),
            fn ( workNode:&Nodes.Node ) {
               filter( workNode, self, node );
            } );
   _filter( node.$nodeManager.getExpCallNodeList(),
            fn ( workNode:&Nodes.ExpCallNode ) {
               self.processGenericsCall( workNode );
               self.outputNilAccCall( workNode );
               self.outputConvExt( workNode.$func );
            } );
   _filter( node.$nodeManager.getExpCastNodeList(),
            fn ( workNode:&Nodes.ExpCastNode ) {
               self.outputConvToForm( workNode );
            } );
   _filter( node.$nodeManager.getTestCaseNodeList(),
            fn ( workNode:&Nodes.Node ) {
               filter( workNode, self, node );
            } );
   _filter( node.$nodeManager.getIfUnwrapNodeList(),
            fn ( workNode:&Nodes.IfUnwrapNode ) {
               let mut symTypeList:List<&Ast.TypeInfo> = [];
               for _ = 1, #workNode.$varSymList {
                  symTypeList.insert( Ast.builtinTypeStem_ );
               }
               self.processConvExp( workNode.$id, symTypeList, workNode.$expList );
            } );
   _filter( node.$nodeManager.getExpSetValNodeList(),
            fn ( workNode:&Nodes.ExpSetValNode ) {
               self.processConvExp(
                  workNode.$id, workNode.$exp1.$expTypeList, workNode.$exp2 );
            });
   
   _filter( node.$nodeManager.getExpCallNodeList(),
            fn ( workNode:&Nodes.ExpCallNode ) {
               self.processConvExp(
                  workNode.$id,     
                  workNode.$func.$expType.$argTypeInfoList,
                  workNode.$argList );
            } );
   _filter( node.$nodeManager.getDeclVarNodeList(),
            fn ( workNode:&Nodes.DeclVarNode ) {
               let mut typeList:List<&Ast.TypeInfo> = [];
               if! let expList = workNode.$expList {
                  foreach symbolInfo, index in workNode.$symbolInfoList {
                     if workNode.$mode == .Let or workNode.$mode == .Unwrap {
                        if workNode.$unwrapFlag {
                           typeList.insert( expList.getExpTypeNoDDDAt( index ) );
                        } else {
                           typeList.insert( symbolInfo.$typeInfo );
                        }
                     }
                  }
                  self.processConvExp( workNode.$id, typeList, expList );
               }
            } );
   _filter( node.$nodeManager.getAliasNodeList(),
            fn ( workNode:&Nodes.AliasNode) {
               self.writeln( "type %s = %s"
                             ( self.getSymbolSym( workNode.$newSymbol ),
                               self.getTypeSymbol( workNode.$typeInfo.$aliasSrc ) ) );
            } );
   
   self.pushProcessMode( .NonClosureFuncDecl );
   _filter( node.$nodeManager.getDeclFuncNodeList(),
            fn ( workNode:&Nodes.Node ) {
               filter( workNode, self, node );
               self.writeln( "" );
            } );
   self.popProcessMode();

   self.pushProcessMode( .DeclClass );
   _filter( node.$nodeManager.getDeclClassNodeList(),
            fn ( workNode:&Nodes.Node ) {
               filter( workNode, self, node );
               self.writeln( "" );
            } );
   self.popProcessMode();


   self.writeln(
      "func Lns_%s_init() {" (self.getModuleName( node.$moduleTypeInfo, false)) );
   self.pushIndent( ## );

   self.writeln( "if %s { return }" (initModVar) );
   self.writeln( "%s = true" (initModVar));

   self.writeln( '%s = "%s"' (self.getSymbolSym( modSym ),
                               node.$moduleTypeInfo.getFullName(
                                  self.$typeNameCtrl, self.$moduleInfoManager ##)));

   self.writeln( "Lns_InitMod()");


   let modulePath = node.$moduleTypeInfo.getFullName(
      self.$typeNameCtrl, self.$moduleInfoManager ##).gsub( "@", "" );
   let moduleName = self.getModuleName( node.$moduleTypeInfo, false );
   
   
   if self.enableTest {
      foreach workNode in node.$nodeManager.getTestCaseNodeList() {
         self.writeln(
            'Testing_registerTestcase( "%s", "%s", lns_test_%s_%s )'
            ( modulePath, workNode.$name.txt, moduleName, workNode.$name.txt ) );
      }
   }

   foreach child in node.$children {
      if not ignoreNodeInInnerBlockSet.has( child.$kind ) {
         filter( child, self, node );
      }
   }

   self.popIndent();
   self.writeln( "}" );

   if self.option.mainModule ==
      self.getCanonicalName( self.moduleTypeInfo, false ).gsub( "@", "" ) {
      // このモジュールが main の場合
      let mut hasMain = false;
      foreach workNode in node.$nodeManager.getDeclFuncNodeList() {
         if isMain( workNode.$expType ) {
            hasMain = true;
            break;
         }
      }
      if not hasMain {
         // main 関数を定義していない場合
         let moduleSym = self.getModuleName( self.moduleTypeInfo, false );
         self.writeln(
            "func %s___main(args *LnsList) LnsInt {"
            ( concatGLSym( moduleSym, true ) ) );
         self.writeln( "Lns_%s_init()" (moduleSym) );
         self.writeln( "return 0" );
         self.writeln( "}" );
      }
   }

   self.writeln( "func init() {" );
   self.pushIndent( ## );
   self.writeln( "%s = false" (initModVar) );
   self.popIndent();
   self.writeln( "}" );
}

pub override fn convFilter.processSubfile(
   node: &Nodes.SubfileNode, opt: Opt ) mut
{
   //Util.err( "not support -- %s" (__func__) );
}

pub override fn convFilter.processEnv(
   node: &Nodes.EnvNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   self.writeln( "Lns_LockEnvSync()" );
   self.popIndent();

   self.env.push( node );
   
   filter( node.$block, self, node );


   self.env.pop();
   
   self.pushIndent(##);
   self.writeln( "Lns_UnlockEnvSync()" );
   self.popIndent();
   self.writeln( "}" );
}

pub override fn convFilter.processBlockSub(
   node: &Nodes.BlockNode, opt: Opt ) mut
{
   switch node.$blockKind {
      case .Block {
         self.writeln( "{" );
      }
   }

   self.pushProcessMode( .Main );
   self.pushIndent(##);
   foreach child in node.$stmtList {
      if not ignoreNodeInInnerBlockSet.has( child.$kind ) {
         filter( child, self, node );
      }
   }
   self.popIndent();
   self.popProcessMode();

   switch node.$blockKind {
      case .Block {
         self.writeln( "}" );
      }
   }
}

fn convFilter.expList2Slice( subList:&Nodes.ExpListNode, toStem:bool ) mut {
   fn processExp( exp:&Nodes.Node ) {
      if toStem and Ast.isClass( exp.$expType ){
         self.write( "%s2Stem(" (self.getTypeSymbolWithPrefix( exp.$expType.$nonnilableType )));
         filter( Nodes.getCastUnwraped( exp ), self, subList );
         self.write( ")" );
      } else {
         filter( exp, self, subList );
      }
   }
   
   let mRetIndex = subList.$mRetExp$.$index;
   if mRetIndex and mRetIndex == 1 {
      let subExp = subList.$expList[ 1 ];
      if subExp.$expType.$kind ~= .DDD {
         self.write( "Lns_2DDD(" );
         processExp( subExp );
         self.write( ")" );
      }
      else {
         processExp( subExp );
      }
   }
   else {
      if mRetIndex and mRetIndex ~= 1 {
         self.write( "append( " );
      }
      self.write( "[]LnsAny{" );
      foreach subExp, subIndex in subList.$expList {
         if mRetIndex == subIndex {
            if mRetIndex ~= 1 {
               self.write( "}, " );
            }
            if subExp.$expType.$kind ~= .DDD {
               self.write( "Lns_2DDD(" );
               processExp( subExp );
               self.write( ")" );
            }
            else {
               processExp( subExp );
            }
            self.write( "..." );
            break;
         }
         if subIndex ~= 1 {
            self.write( ', ' );
         }
         processExp( subExp );
      }
      if mRetIndex and mRetIndex ~= 1 {
         self.write( ")" );
      }
      else {
         self.write( "}" );
      }
   }
}

/**
expListNode の式を go で扱える型に変換する。

processRoot() で、processConvExp() を実行しておく。
*/
fn convFilter.processSetFromExpList(
   convArgFuncName:str,
   dstTypeList:&List<&Ast.TypeInfo>, expListNode:&Nodes.ExpListNode ) mut
{
   switch getExpListKind( dstTypeList, expListNode ) {
      case .Conv {
         self.write( "%s(" ( convArgFuncName ) );
         let mRetIndex = expListNode.$mRetExp$.$index;

         foreach exp, index in expListNode.$expList {
            if exp.$expType.$kind == .Abbr {
               break;
            }
            if index ~= 1 {
               self.write( ', ' );
            }
            if mRetIndex == index {
               self.write( "Lns_2DDD(" );
               filter( Nodes.getCastUnwraped( exp ), self, expListNode );
               self.write( ")" );
               break;
            }
            filter( exp, self, expListNode );
            if expListNode.$mRetExp$.$index == index {
               break;
            }
         }
         self.write( ")" );
      }
      case .Slice {
         foreach argType, index in dstTypeList {
            if index ~= 1 {
               self.write( ', ' );
            }
            if #expListNode.$expList >= index {
               let argExp = expListNode.$expList[ index ];

               if! let exp2ddd = argExp@@@Nodes.ExpToDDDNode {
                  self.expList2Slice( exp2ddd.$expList, false );
               }
               else {
                  if argExp.$expType.$kind == .Abbr {
                     if argType.$kind == .DDD {
                        self.write( "[]LnsAny{}" );
                     }
                     else {
                        self.write( "nil" );
                     }
                  }
                  else {
                     filter( argExp, self, expListNode );
                  }
               }
            }
            else {
               self.write( "[]LnsAny{}" );
            }
         }
      }
      case .Direct {
         let mRetIndex = expListNode.$mRetExp$.$index;
         foreach dstType, index in dstTypeList {
            if mRetIndex == index - 1 {
               break;
            }
            if index ~= 1 {
               self.write( ', ' );
            }
            let exp:&Nodes.Node;
            if #expListNode.$expList < index {
               exp = self.noneNode;
            } else {
               exp = expListNode.$expList[ index ];
            }
            if index == #dstTypeList and dstType.$kind == .DDD {
               // 関数の最終仮引数が DDD の場合、
               // []LnsAny に変換する
               if #expListNode.$expList < index or exp.$expType.$kind == .Abbr {
                  self.write( "[]LnsAny{}" );
               }
               else {
                  filter( exp, self, expListNode );
               }
            } else {
               if #expListNode.$expList < index or exp.$expType.$kind == .Abbr {
                  // 最終実引数より後は、引数を省略している
                  self.write( "nil" );
               }
               elseif expListNode.$expTypeList[ index ].$kind == .DDD {
                  self.write( "Lns_car(" );
                  filter( exp, self, expListNode );
                  self.write( ")" );
               }
               else {
                  filter( exp, self, expListNode );
               }
            }
         }
      }
   }
}

pub override fn convFilter.processStmtExp(
   node: &Nodes.StmtExpNode, opt: Opt ) mut
{
   filter( node.$exp, self, node );
   self.writeln( "" );
}

pub override fn convFilter.processDeclAlge(
   node: &Nodes.DeclAlgeNode, opt: Opt ) mut
{
   self.writeln( "// decl alge -- %s" (node.$expType.getTxt(##) ) );
   self.writeln( "type %s = LnsAny" ( self.getTypeSymbol( node.$algeType ) ) );
                                  
   forsort valInfo in node.$algeType.$valInfoMap {
      let algeSym = self.getAlgeSymbol( valInfo );
      self.writeln( "type %s struct{" (algeSym) );
      foreach paramType, index in valInfo.$typeList {
         self.writeln( "Val%d %s" (index, self.type2gotype(paramType) ) );
      }
      self.writeln( "}" );
      if #valInfo.$typeList == 0 {
         self.writeln( "var %s_Obj = &%s{}" (algeSym,algeSym) );
      }
      self.writeln( "func (self *%s) GetTxt() string {" (algeSym) );
      self.writeln( 'return "%s.%s"' (node.$algeType.$rawTxt, valInfo.$name) );
      self.writeln( "}" );
   }
}

pub override fn convFilter.processNewAlgeVal(
   node: &Nodes.NewAlgeValNode, opt: Opt ) mut
{
   let algeSym = self.getAlgeSymbol( node.$valInfo );
   if #node.$valInfo.$typeList == 0 {
      self.write( "%s_Obj" (algeSym) );
   }
   else {
      self.write( "&%s{" (algeSym) );
      foreach param, index in node.$paramList {
         if index > 1 {
            self.write( ", " );
         }
         filter( param, self, node );
      }
      self.write( "}" );
   }
}

pub override fn convFilter.processDeclMember(
   node: &Nodes.DeclMemberNode, opt: Opt ) mut
{
   self.outputSymbol( .Member( Ast.isPubToExternal( node.$accessMode ) ),
                      node.$name.txt );
   self.write( " %s" ( self.type2gotype( node.$refType.$expType ) ) );
   self.writeln( "" );
}

pub override fn convFilter.processExpMacroExp(
   node: &Nodes.ExpMacroExpNode, opt: Opt ) mut
{
   foreach stmt in node.$stmtList {
      if not ignoreNodeInInnerBlockSet.has( stmt.$kind ) {
         filter( stmt, self, node );
      }
   }
}

pub override fn convFilter.processDeclMacro(
   node: &Nodes.DeclMacroNode, opt: Opt ) mut
{
   //Util.err( "not support -- %s" (__func__) );
}

pub override fn convFilter.processExpMacroStat(
   node: &Nodes.ExpMacroStatNode, opt: Opt ) mut
{
   Util.err( "not support -- %s" (__func__) );
}

fn convFilter.outputDeclFuncArg(funcType:&Ast.TypeInfo) mut {
   foreach argType, index in funcType.$argTypeInfoList {
      if index ~= 1 {
         self.write( ", " );
      }
      self.write( "arg%d " ( index ));
      self.write( self.type2gotype( argType ) );
   }
}


pub override fn convFilter.processDeclConstr(
   node: &Nodes.DeclConstrNode, opt: Opt ) mut
{
   let classType = node.$expType.$parentInfo;
   let className = self.getTypeSymbol( classType );
   self.writeln( "// %d: %s" (node.$pos.lineNo, Nodes.getNodeKindName( node.$kind )));
   self.write( "func (self *%s) %s(" (className, self.getConstrSymbol( classType )) );
   foreach arg, index in node.$declInfo.$argList {
      if index ~= 1 {
         self.write( "," );
      }
      filter( arg, self, node );
   }
   self.writeln( ") {" );

   filter( unwrap node.$declInfo.$body, self, node );

   self.writeln( "}" );
}

pub override fn convFilter.processDeclDestr(
   node: &Nodes.DeclDestrNode, opt: Opt ) mut
{
   Util.err( "not support -- %s" (__func__) );
}

pub override fn convFilter.processExpCallSuperCtor(
   node: &Nodes.ExpCallSuperCtorNode, opt: Opt ) mut
{
   self.write( "self.%s(" ( self.getConstrSymbol( node.$superType ) ) );
   if! let argList = node.$expList {
      self.processSetFromExpList( self.getConvExpName( node.$id, argList ), 
                                  node.$methodType.$argTypeInfoList, argList );
   }
   self.writeln( ")" );
}

pub override fn convFilter.processExpCallSuper(
   node: &Nodes.ExpCallSuperNode, opt: Opt ) mut
{
   self.write( "self.%s.%s(" ( self.getTypeSymbol( node.$methodType.$parentInfo ),
                               self.getFuncSymbol( node.$methodType ) ) );
   if! let argList = node.$expList {
      self.processSetFromExpList( self.getConvExpName( node.$id, argList ), 
                                  node.$methodType.$argTypeInfoList, argList );
   }
   self.write( ")" );
}

fn convFilter.outputDummyReturn( retTypeInfoList:&List<&Ast.TypeInfo> ) mut {
   self.writeln( "// insert a dummy" );
   self.write( "    return " );
   foreach retType, index in retTypeInfoList {
      if index > 1 {
         self.write( "," );
      }
      if isAnyType( retType ) {
         self.write( "nil" );
      } else {
         switch getOrgTypeInfo( retType ) {
            case Ast.builtinTypeInt {
               self.write( "0" );
            }
            case Ast.builtinTypeReal {
               self.write( "0.0" );
            }
            case Ast.builtinTypeBool {
               self.write( "false" );
            }
            case Ast.builtinTypeString {
               self.write( '""' );
            }
            default {
               self.write( "nil" );
            }
         }
      }
   }
   self.writeln( "" );
}

pub fn convFilter.outputDeclFuncInfo(
   node: &Nodes.Node, declInfo:&Nodes.DeclFuncInfo ) mut
{
   let funcType = node.$expType;
   if funcType.$abstractFlag {
      return;
   }
   if declInfo.$name and not isClosure( funcType ) {
      self.writeln( "// %d: decl %s"
                    (node.$pos.lineNo, self.getCanonicalName( funcType, false )) );
   }
   let convFunc = self.outputDeclFunc( .DeclInfo( node, declInfo ) );

   self.writeln( " {" );

   self.pushIndent(##);

   if isMain( funcType ) {
      self.writeln( "Lns_%s_init()" (self.getModuleName( self.$moduleTypeInfo, false )) );
   }
   
   if declInfo.$has__func__Symbol {
      let mut nameSpace = self.getCanonicalName( funcType.$parentInfo, false );
      let funcName;
      if! let name = declInfo.$name {
         funcName = name.txt;
      } else {
         funcName = "<anonymous>";
      }
      let funcSym_ = unwrap funcType.$scope$.getSymbolInfoChild$( "__func__" );
      self.writeln( '%s := "%s.%s"' (self.getSymbolSym(funcSym_), nameSpace, funcName) );
   }

   
   foreach convArg in convFunc.$argList {
      if convArg.$posForModToRef {
         self.write( "%s := _%s" ( self.getSymbolSym( convArg ),
                                     self.getSymbolSym( convArg )) );
         self.outputAny2Type( convArg.$typeInfo );
         self.writeln( "" );
      }
   }
   
   self.popIndent();
   
   if! let body = declInfo.$body {
      filter( body, self, node );

      let retTypeInfoList = funcType.$retTypeInfoList;
      if #retTypeInfoList > 0 and
         retTypeInfoList[ #retTypeInfoList ] ~= Ast.builtinTypeNeverRet
      {
         // go に変換すると、 switch や match などのフロー解析が出来ず、
         // return 不要かどうかの判断ができないため、
         // 最後に return がない関数は、ダミーで return を追加する。
         let mut needReturn = false;
         for index = #body.$stmtList, 1, -1 {
            let statment = body.$stmtList[ index ];
            switch statment.$kind {
               case Nodes.NodeKind.$BlankLine {
               }
               case Nodes.NodeKind.$Return {
                  break;
               }
               default {
                  needReturn = true;
                  break;
               }
            }
         }
         if needReturn {
            self.outputDummyReturn( funcType.$retTypeInfoList );
         }
      }
   }
   self.write( "}" );
   if declInfo.$name {
      self.writeln( "" );
   }
}


pub override fn convFilter.processDeclMethod(
   node: &Nodes.DeclMethodNode, opt: Opt ) mut
{
   self.outputDeclFuncInfo( node, node.$declInfo );
}

pub override fn convFilter.processProtoMethod(
   node: &Nodes.ProtoMethodNode, opt: Opt ) mut
{
   //Util.err( "not support -- %s" (__func__) );
}

fn convFilter.getEnumGetTxtSym( enumType:&Ast.EnumTypeInfo ) : str {
   return "%s_getTxt" (self.getTypeSymbol( enumType ));
}

pub override fn convFilter.processDeclEnum(
   node: &Nodes.DeclEnumNode, opt: Opt ) mut
{
   switch self.processMode {
      case .DeclTopScopeVar {
         self.writeln( "// decl enum -- %s " (node.$enumType.getTxt(##)) );
         self.writeln( "type %s = %s" ( self.getTypeSymbol( node.$enumType ),
                                        self.type2gotype( node.$enumType ) ) );
         
         forsort valInfo in node.$enumType.$name2EnumValInfo {
            self.write( "const %s = "
                        (self.getSymbol( .Static( node.$enumType ), valInfo.$name )) );
            _match valInfo.$val {
               case .Int( val ) {
                  self.write( "%d" (val) );
               }
               case .Real( val ) {
                  self.write( "%g" (val) );
               }
               case .Str( val ) {
                  self.write( str2gostr( '"%s"' (val) ) );
               }
            }
            self.writeln( "" );
         }

         // list
         let listName = "%sList_" (self.getTypeSymbol( node.$enumType ));
         self.writeln( "var %s = NewLnsList( []LnsAny {" (listName) );
         foreach valName in node.$valueNameList {
            self.writeln( "  %s," ( self.getSymbol( .Static( node.$enumType ),
                                                    valName.txt ) ) );
         }
         self.writeln( "})" );

         let scope = unwrap node.$enumType.$scope;
         self.outputDeclFunc( .Type( unwrap scope.getTypeInfoChild( "get__allList" ) ) );
         self.writeln( "{" );
         self.pushIndent( ## );
         self.writeln( "return %s" (listName));
         self.popIndent();
         self.writeln( "}" );

         // map
         let mapName = "%sMap_" (self.getTypeSymbol( node.$enumType ));
         self.writeln( "var %s = map[%s]string {"
            (mapName, self.type2gotype( node.$enumType.$valTypeInfo)) );
         forsort valInfo in node.$enumType.$name2EnumValInfo {
            self.writeln( '  %s: "%s.%s",'
                          ( self.getSymbol(              
                             .Static( node.$enumType ), valInfo.$name ),
                            node.$expType.$rawTxt, valInfo.$name ) );
         }
         self.writeln( "}" );

         self.outputDeclFunc( .Type( unwrap scope.getTypeInfoChild( "_from" ) ) );
         self.writeln( "{" );
         self.pushIndent( ## );
         self.writeln( "if _, ok := %s[arg1]; ok { return arg1 }"(mapName) );
         self.writeln( "return nil" );
         self.popIndent();
         self.writeln( "}" );

         self.writeln( "" ); 
         self.writeln( "func %s(arg1 %s) string {"
            ( self.getEnumGetTxtSym( node.$enumType ),
              self.type2gotype( node.$enumType.$valTypeInfo )) );
         self.pushIndent( ## );
         self.writeln( "return %s[arg1];" (mapName) );
         self.popIndent();
         self.writeln( "}" );
      }
      default {
      }
   }
}



pub override fn convFilter.processUnwrapSet(
   node: &Nodes.UnwrapSetNode, opt: Opt ) mut
{
   Util.err( "not support -- %s" (__func__) );
}

pub override fn convFilter.processIfUnwrap(
   node: &Nodes.IfUnwrapNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent( ## );

   let mut tempTypeList:List<&Ast.TypeInfo> = [];
   // 一旦 nil かどうかを確認するために、テンポラリ変数にセット
   foreach varSym, index in node.$varSymList {
      if index > 1 {
         self.write( ", " );
      }
      if varSym.$name == "_" {
         self.write( "_" );
      } else {
         self.write( "_" .. self.getSymbolSym( varSym ) );
      }
      tempTypeList.insert( Ast.builtinTypeStem_ );
   }
   if getExpListKind( tempTypeList, node.$expList ) == .Direct {
      for _ =  #node.$varSymList + 1, #node.$expList.$expTypeList {
         self.write( ", _" );
      }
   }
   self.write( " := " );
   self.processSetFromExpList(
      self.getConvExpName( node.$id, node.$expList ),
      tempTypeList, node.$expList );
   self.writeln( "" );

   // テンポラリ変数が nil かどうかを確認
   self.write( "if " );
   let mut hasSym = false;
   foreach varSym in node.$varSymList {
      if varSym.$name ~= "_" {
         if hasSym {
            self.write( " && " );
         }
         self.write( "_%s != nil" ( self.getSymbolSym( varSym ) ) );
         hasSym = true;
      }
   }
   self.writeln( " {" );

   // nil でなければ値を入れなおす
   self.pushIndent( ## );
   foreach varSym, index in node.$varSymList {
      if varSym.$name ~= "_" {
         if varSym.hasAccess() {
            self.write( "%s := _%s" ( self.getSymbolSym( varSym ),
                                      self.getSymbolSym( varSym )) );    
            if node.$expList.getExpTypeNoDDDAt( index ).$nilable {
               self.outputAny2Type( varSym.$typeInfo );
            }
            self.writeln( "" );
         }
      }
   }
   self.popIndent();
   
   filter( node.$block, self, node );

   if! let nilBlock = node.$nilBlock {
      self.writeln( "} else {" );

      filter( nilBlock, self, node );
      
      self.writeln("}" );
   }
   else {
      self.writeln("}" );
   }
   
   self.popIndent();
   self.write( "}" );
   self.writeln( "" );
}

fn convFilter.outputLetVar( node: &Nodes.DeclVarNode ) mut {
   fn declVar() {
      if node.$symbolInfoList[ 1 ].$scope == self.moduleScope {
         // モジュールスコープの変数宣言はここでは行なわない。
         // outputTopScopeVar で処理する。       
         return;
      }
      foreach symbolInfo in node.$symbolInfoList {
         if symbolInfo.$posForModToRef {
            self.writeln( "var %s %s" ( self.getSymbolSym( symbolInfo ),
                                        self.type2gotype( symbolInfo.$typeInfo ) ) );
         }
      }
   }


   if node.$unwrapFlag {
      if! let expList, unwrapBlock = node.$expList, node.$unwrapBlock {
         if node.$symbolInfoList[ 1 ].$scope ~= self.moduleScope {
            declVar();
         }

         // 一旦テンポラリに入れる
         self.writeln( "" );
         self.writeln( "{" );
         self.pushIndent(##);
         foreach varInfo, index in node.$varList {
            if index ~= 1 {
               self.write( ", " );
            }
            self.write( "_%s" ( varInfo.$name.txt ) );
         }

         let mut tmpVarTypeList:List<&Ast.TypeInfo> = [];
         foreach _, index in node.$symbolInfoList {
            tmpVarTypeList.insert( expList.getExpTypeNoDDDAt( index ) );
         }
         
         if getExpListKind( tmpVarTypeList, expList ) == .Direct {
            for _ =  #tmpVarTypeList + 1, #expList.$expTypeList {
               self.write( ", _" );
            }
         }
         self.write( " := " );
         self.processSetFromExpList(
            self.getConvExpName( node.$id, expList ), tmpVarTypeList, expList );
         self.writeln( "" );

         // テンポラリに nil が含まれるか確認する
         self.write( "if " );
         let mut hasCond = false;
         foreach varInfo, index in node.$varList {
            if expList.getExpTypeNoDDDAt( index ).$nilable {
               if hasCond {
                  self.write( " || " );
               }
               self.write( "_%s == nil" (varInfo.$name.txt) );
               hasCond = true;
            }
         }
         self.writeln( "{" );
         
         filter( unwrapBlock, self, node );

         if! let thenBlock = node.$thenBlock {
            self.writeln( "} else {" );
            self.pushIndent(##);
            foreach varInfo, index in node.$symbolInfoList {
               self.write( "%s = _%s" (self.getSymbolSym( varInfo ), varInfo.$name) );
               if expList.getExpTypeNoDDDAt( index ).$nilable {
                  self.outputAny2Type( varInfo.$typeInfo );
               }
               self.writeln( "" );
            }
            self.popIndent();
            filter( thenBlock, self, node );
            self.writeln( "}" );
         }
         else {
            self.writeln( "} else {" );
            self.pushIndent(##);
            foreach varInfo, index in node.$symbolInfoList {
               self.write( "%s = _%s" (self.getSymbolSym( varInfo ), varInfo.$name) );
               if expList.getExpTypeNoDDDAt( index ).$nilable {
                  self.outputAny2Type( varInfo.$typeInfo );
               }
               self.writeln( "" );
            }
            self.popIndent();
            self.writeln( "}" );
         }
         
         
         self.popIndent();
         self.writeln( "}" );
      }
   }
   else {
      declVar();

      if! let expList = node.$expList {
         let mut varTypeList:List<&Ast.TypeInfo> = [];
         foreach symbolInfo, index in node.$symbolInfoList {
            varTypeList.insert( symbolInfo.$typeInfo );
            if index > 1 {
               self.write( "," );
            }
            if symbolInfo.$posForModToRef or
               Ast.isPubToExternal( symbolInfo.$accessMode )
            {
               self.write( "%s" ( self.getSymbolSym( symbolInfo ) ) );
            } else {
               self.write( "_" );
            }
         }
         
         if getExpListKind( varTypeList, expList ) == .Direct {
            for _ =  #varTypeList + 1, #expList.$expTypeList {
               self.write( ", _" );
            }
         }
         self.write( " = " );
         self.processSetFromExpList(
            self.getConvExpName( node.$id, expList ), varTypeList, expList );
         self.writeln( "" );   
      }
   }
}

pub override fn convFilter.processDeclVar(
   node: &Nodes.DeclVarNode, opt: Opt ) mut
{
   switch node.$mode {
      case .Let {
         self.outputLetVar( node );
      }
      case .Unwrap {
         self.writeln( "{" );
         self.pushIndent( ## );
         foreach varSym in node.$symbolInfoList {
            self.writeln( "var _%s LnsAny" (varSym.$name) );
         }
         let! expList = node.$expList {
            Util.err( "illegal" );
         };

         fn setVals() {
            foreach varSym, index in node.$symbolInfoList {
               self.write( "%s = _%s" (self.getSymbolSym( varSym ), varSym.$name) );
               if expList.getExpTypeNoDDDAt( index ).$nilable {
                  self.outputAny2Type( varSym.$typeInfo );
               }
               self.writeln( "" );
            }
         }
         
         let mut typeList:List<&Ast.TypeInfo> = [];
         foreach varSym, index in node.$symbolInfoList {
            typeList.insert( varSym.$typeInfo );
            if index > 1 {
               self.write( "," );
            }
            self.write( "_%s" (varSym.$name ));
         }
         if getExpListKind( typeList, expList ) == .Direct {
            for _ = #node.$symbolInfoList + 1, #expList.$expTypeList {
               self.write( ",_" );
            }
         }
         self.write( " = " );
         self.processSetFromExpList(
            self.getConvExpName( node.$id, expList ), typeList,  expList );
         self.writeln( "" );
         self.write( "if " );
         let mut hasCond = false;
         foreach varSym, index in node.$symbolInfoList {
            if expList.getExpTypeNoDDDAt( index ).$nilable {
               if hasCond {
                  self.write( " || " );
               }
               self.write( "_%s == nil" (varSym.$name) );
               hasCond = true;
            }
         }
         self.writeln( " {" );
         filter( unwrap node.$unwrapBlock, self, node );
         if! let thenBlock = node.$thenBlock {
            self.writeln( "} else {" );
            self.pushIndent( ## );
            setVals();
            self.popIndent();
            filter( thenBlock, self, node );
            self.writeln( "}" );
         }
         else {
            self.writeln( "}" );
            setVals();
         }
         self.popIndent();

         self.writeln( "}" );
      }
      default {
         Util.err( "not support -- %s" (__func__) );
      }
   }
}


pub override fn convFilter.processWhen(
   node: &Nodes.WhenNode, opt: Opt ) mut
{
   self.write( "if " );
   foreach symPair, index in node.$symPairList {
      if index > 1 {
         self.write( " && " );
      }
      self.write( "%s != nil" ( self.getSymbolSym( symPair.$src ) ) );
      symPair.$dst.set_convModuleParam( true );
   }
   self.writeln( "{" );
   self.pushIndent(##);
   foreach symPair in node.$symPairList {
      if symPair.$dst.$posForModToRef {
         self.write( "%s_%d := %s" (symPair.$dst.$name, symPair.$dst.$symbolId,
                                     self.getSymbolSym( symPair.$src ) ) );
         self.outputAny2Type( symPair.$dst.$typeInfo );
         self.writeln( "" );
      }
   }
   self.popIndent();

   
   filter( node.$block, self, node );

   if! let elseBlock = node.$elseBlock {
      self.writeln( "} else {" );
      filter( elseBlock, self, node );
      self.write( "}" );
   }
   else {
      self.write( "}" );
   }
   self.writeln( "" );
}

pub override fn convFilter.processDeclArg(
   node: &Nodes.DeclArgNode, opt: Opt ) mut
{
   self.write( "%s " (self.getSymbolSym( node.$symbolInfo) ) );
   filter( unwrap node.$argType, self, node );
}

pub override fn convFilter.processDeclArgDDD(
   node: &Nodes.DeclArgDDDNode, opt: Opt ) mut
{
   self.write( "ddd []LnsAny" );
}

pub override fn convFilter.processExpSubDDD(
   node: &Nodes.ExpSubDDDNode, opt:Opt ) mut
{
   Util.err( "not support -- %s" (__func__) );
}


pub override fn convFilter.processDeclForm(
   node: &Nodes.DeclFormNode, opt: Opt ) mut
{
   self.write( "type %s " (self.getFuncSymbol( node.$expType )) );
   self.outputDeclFunc( .Type( node.$expType ) );
   self.writeln( "" );
   //(self.getTypeSymbol( node.$expType ) ) );
}

pub override fn convFilter.processDeclFunc(
   node: &Nodes.DeclFuncNode, opt: Opt ) mut
{
   if! let funcSym = node.$declInfo.$symbol {
      if not funcSym.$posForModToRef and
         not Ast.isPubToExternal( funcSym.$accessMode )
      {
         // アクセスのない関数は定義しない
         return;
      }
   }
   let funcType = node.$expType;
   if ( self.processMode == .NonClosureFuncDecl ) == isClosure( node.$expType ) {
      if self.processMode ~= .NonClosureFuncDecl and not node.$declInfo.$symbol {
         self.write( self.getFuncSymbol( funcType ) );
      }
      return;
   }
   if isClosure( funcType ) {
      if! let funcSym = node.$declInfo.$symbol {
         self.write( "var " );
         self.outputSymbol( .Func( funcType ), funcSym.$name );
         self.write( " ");
         self.outputDeclFunc( .DeclInfo( node, node.$declInfo ) );
         self.writeln( "" );
         self.outputSymbol( .Func( funcType ), funcSym.$name );
         self.write( " = " );
      }
   }
   self.outputDeclFuncInfo( node, node.$declInfo );
}

pub override fn convFilter.processRefType(
   node: &Nodes.RefTypeNode, opt: Opt ) mut
{
   self.write( self.type2gotype( node.$expType ) );
   // // 型名出力は、元々 self.type2gotype() を使用していたが、
   // // これだと 外部パッケージ の型にアクセスしているケースに対応できない。
   // // そこで、外部パッケージにアクセスする型 (prefix が nil でないもの) は、
   // // node.$name を処理する。
   // // 一方で、 node.name は nilable の情報を含まないため、
   // // nilable の場合は self.type2gotype() を利用する。
   
   // if node.$expType.$nilable or not node.$name.getPrefix() {
   //    self.write( self.type2gotype( node.$expType ) );
   //    return;
   // }

   // if node.$name.$expType.$kind == .Class {
   //    self.write( "*" );
   // }
   // filter( node.$name, self, node );
}

fn convFilter.processCond( node:&Nodes.Node, parent:&Nodes.Node ) mut {
   if node.$expType ~= Ast.builtinTypeBool {
      self.write( "Lns_isCondTrue( " );
      filter( node, self, parent );
      self.write( ")" );
   } else {
      filter( node, self, parent );
   }
}
   

pub override fn convFilter.processIf(
   node: &Nodes.IfNode, opt: Opt ) mut
{
   foreach stmt in node.$stmtList {
      switch stmt.$kind {
         case .If {
            self.write( "if " );
            self.processCond( stmt.$exp, node );
            self.writeln( "{" );
            filter( stmt.$block, self, node );
         }
         case .ElseIf {
            self.write( "} else if " );
            self.processCond( stmt.$exp, node );
            self.writeln( "{" );
            filter( stmt.$block, self, node );
         }
         case .Else {
            self.writeln( "} else { " );
            filter( stmt.$block, self, node );
         }
      }
   }
   self.writeln( "}" );
}

pub override fn convFilter.processSwitch(
   node: &Nodes.SwitchNode, opt: Opt ) mut
{
   let valName = "_switch%d" (node.$id);
   self.write( "if %s := " (valName) );
   filter( node.$exp, self, node );
   self.write( "; " );

   foreach caseNode, caseIndex in node.$caseList {
      if caseIndex ~= 1 {
         self.write( "} else if " );
      }
      foreach exp, index in caseNode.$expList.$expList {
         if index ~= 1 {
            self.write( " || " );
         }
         self.write( "%s == " (valName) );
         filter( exp, self, caseNode.$expList );
      }
      self.writeln( " {" );

      filter( caseNode.$block, self, node );
   }

   if! let defaultBlock = node.$default {
      self.writeln( "} else {" );
      filter( defaultBlock, self, node );
   }

   self.writeln( "}" );
}


pub override fn convFilter.processMatch(
   node: &Nodes.MatchNode, opt: Opt ) mut
{
   fn hasAccessing(): bool {
      foreach caseInfo in node.$caseList {
         foreach symbol, _ in caseInfo.$valParamNameList {
            if symbol.$posForModToRef {
               return true;
            }
         }
      }
      return false;
   }
   let val;
   if hasAccessing() {
      val = "_exp%d" (node.$id);
      self.write( "switch %s := " (val) );
   } else {
      val = ""; 
      self.write( "switch " );
   }
   filter( node.$val, self, node );
   self.writeln( ".(type) {" );
   foreach caseInfo in node.$caseList {
      self.writeln( "case *%s:" (self.getAlgeSymbol( caseInfo.$valInfo) ) );
      foreach symbol, index in caseInfo.$valParamNameList {
         if symbol.$posForModToRef {
            self.writeln( "%s := %s.Val%d" (self.getSymbolSym( symbol ), val, index) );
         }
      }
      filter( caseInfo.$block, self, node );
   }
   if! let defaultBlock = node.$defaultBlock {
      self.writeln ( "default:" );
      filter( defaultBlock, self, node );
   }
   self.writeln( "}" );
}


pub override fn convFilter.processWhile(
   node: &Nodes.WhileNode, opt: Opt ) mut
{
   self.write( "for " );
   if not node.$infinit {
      self.processCond( node.$exp, node );
   }
   self.writeln( " {" );

   filter( node.$block, self, node );

   self.writeln( "}" );
}

pub override fn convFilter.processRepeat(
   node: &Nodes.RepeatNode, opt: Opt ) mut
{
   self.writeln( "for {" );

   filter( node.$block, self, node );

   self.pushIndent( ## );

   self.write( "if " );
   self.processCond( node.$exp, node );
   self.writeln( "{ break }" );
   
   self.popIndent();

   self.writeln( "}" );
}

pub override fn convFilter.processFor(
   node: &Nodes.ForNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent( ## );

   
   let fromSym = "_from%d" (node.$id);
   let toSym = "_to%d" (node.$id);
   let deltaSym = "_delta%d" (node.$id);
   let workSym = "_work%d" (node.$id);

   let valType = "%s" (self.type2gotype(node.$init.$expType) );
   self.write( "var %s %s = " (fromSym,valType) );
   filter( node.$init, self, node );
   self.writeln( "" );

   self.write( "var %s %s = " (toSym,valType));
   filter( node.$to, self, node );
   self.writeln( "" );

   if! let delta = node.$delta {
      self.writeln( "%s := %s" (workSym, fromSym) );
      self.write( "%s := " (deltaSym) );
      filter( delta, self, node );
      self.writeln( "" );

      self.writeln( "for {" );

      self.pushIndent( ## );
      self.writeln( "if %s > 0 {" (deltaSym) );
      self.writeln( "   if %s > %s { break }" (workSym, toSym) );
      self.writeln( "} else {" );
      self.writeln( "   if %s < %s { break }" (workSym, toSym));
      self.writeln( "}" );
      self.popIndent();
   }
   else {
      self.writeln(
         "for %s := %s; %s <= %s; %s++ {"
         (workSym, fromSym, workSym, toSym, workSym ) );
   }

   self.pushIndent(##);
   if node.$val.$posForModToRef {
      self.writeln( "%s := %s" (node.$val.$name, workSym ) );
   }
   self.popIndent();

   filter( node.$block, self, node );

   if node.$delta {
      self.pushIndent( ## );
      self.writeln( "%s += %s" (workSym, deltaSym) );
      self.popIndent();
   }
   
   self.writeln( "}" );


   self.popIndent();
   self.writeln( "}" );
}

pub override fn convFilter.processApply(
   node: &Nodes.ApplyNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent( ## );

   
   let formSym = "_form%d" (node.$id);
   let paramSym = "_param%d" (node.$id);
   let prevSym = "_prev%d" (node.$id);

   if node.$expList.$mRetExp {
      self.write( "%s, %s, %s := " (formSym, paramSym, prevSym) );
      filter( node.$expList, self, node );
      self.writeln( "" );
   } else {
      self.write( "%s, %s, %s := " (formSym, paramSym, prevSym) );
      filter( node.$expList.$expList[1], self, node.$expList );
      self.write( "," );
      filter( node.$expList.$expList[2], self, node.$expList );
      self.write( ", LnsAny(" );
      filter( node.$expList.$expList[3], self, node.$expList );
      self.writeln( ")" );
   }

   self.writeln( "for {" );
   self.pushIndent(##);

   let mut setTxt = prevSym;
   for index = 2, #node.$varList {
      let symInfo = node.$varList[ index ];
      self.writeln( "var %s %s" ( self.getSymbolSym( symInfo ),
                                  self.type2gotype( symInfo.$typeInfo ) ) );
      setTxt = "%s, %s" ( setTxt, self.getSymbolSym( symInfo ) );
   }
   if node.$expList.$expType.$kind == .Ext {
      let workSym = "_work%d" (node.$id);
      self.writeln(
         "%s := %s.(*Lns_luaValue).Call( Lns_2DDD( %s, %s ) )"
         (workSym, formSym, paramSym, prevSym ) );
      self.write( "%s = " (setTxt));
      foreach _, index in node.$varList {
         if index > 1 {
            self.write( "," );
         }
         self.write( "Lns_getFromMulti(%s,%d)" (workSym, index - 1 ) );
      }
      self.writeln( "" );
   } else {
      self.writeln( "%s = %s( %s, %s )" (setTxt, formSym, paramSym, prevSym) );
   }
   self.writeln(
      "if Lns_IsNil( %s ) { break }" (prevSym) );
   let topSymInfo = node.$varList[1];
   if topSymInfo.$name ~= "_" {
      self.writeln(
         "%s := %s.(%s)"
         ( self.getSymbolSym( topSymInfo), prevSym,
           self.type2gotype( topSymInfo.$typeInfo )) );
   }
   self.popIndent();
   
   filter( node.$block, self, node );

   self.writeln( "}" );


   self.popIndent();
   self.writeln( "}" );
}

fn convFilter.outputForeachLua(
   node: &Nodes.Node, sortFlag:bool, exp:&Nodes.Node,
   val:&Ast.SymbolInfo, key:&Ast.SymbolInfo!, block:&Nodes.BlockNode ) mut
{
   switch exp.$expType.$extedType.$kind {
      case .List, .Map {
         self.writeln( "{" );
         self.pushIndent( ## );
         let tmpExp = "_exp%d" (node.$id);
         let tmpKey = "_key%d" (node.$id);
         let tmpVal = "_val%d" (node.$id);
         let tmpIndex = "_index%d" (node.$id);
         let sorted = "_sorted%d" (node.$id);
         self.write( "%s := " (tmpExp) );
         filter( exp, self, node );
         self.writeln( "" );

         let tmpValName;
         if val.hasAccess() {
            tmpValName = tmpVal;
         } else {
            tmpValName = "_";
         }
         if sortFlag {
            self.writeln(
               "%s := %s.SortMapKeyList( %s )"
               (sorted, self.env.getLuavm( node.isThreading()), tmpExp) );
            self.writeln( "%s, %s := %s.Get1stFromMap()"
               (tmpIndex,tmpKey, sorted) );
            self.writeln( "for %s != nil {" (tmpIndex));
            self.pushIndent( ## );
         } else {
            self.writeln( "%s, %s := %s.Get1stFromMap()"
               (tmpKey,tmpValName,tmpExp) );
            self.writeln( "for %s != nil {" (tmpKey));
            self.pushIndent( ## );
         }
         if! let keySym = key {
            if keySym.hasAccess() {
               self.write( "%s := %s" ( self.getSymbolSym( keySym ), tmpKey ) );
               self.outputAny2Type( keySym.$typeInfo );
               self.writeln( "" );
            }
         }
         if val.hasAccess() {
            if sortFlag {
               self.write(
                  "%s := %s.GetAt( %s )"
                  (self.getSymbolSym( val ), tmpExp, tmpKey) );
            } else {
               self.write( "%s := %s" ( self.getSymbolSym( val ), tmpVal ) );
            }
            self.outputAny2Type( val.$typeInfo );
            self.writeln( "" );
         }
         self.popIndent();

         filter( block, self, node );

         self.pushIndent( ## );
         if not sortFlag {
            self.write( "%s, %s = " (tmpKey, tmpValName));
            self.writeln( "%s.NextFromMap( %s )" (tmpExp,tmpKey) );
         } else {
            self.write( "%s, %s = " (tmpIndex, tmpKey));
            self.writeln( "%s.NextFromMap( %s )" (sorted,tmpIndex));
         }

         self.popIndent();
         
         self.writeln( "}" );
         self.popIndent();
         self.writeln( "}" );
      }
      default {  
         Util.err( "not support -- %s" (__func__) );
      }
   }
}

pub override fn convFilter.processForeach(
   node: &Nodes.ForeachNode, opt: Opt ) mut
{
   if node.$exp.$expType.$srcTypeInfo.$kind == .Ext {
      self.outputForeachLua( node, false, node.$exp, node.$val, node.$key, node.$block );
      return;
   }

   macro _keyItemDecl( typeName:__exp ) {
      if ,,typeName ~= "_" {
         self.write( "_%s" (,,typeName) );
      } else {
         self.write( "%s" (,,typeName) );
      }
   }
   macro _keyItemSet( typeSym:sym, typeName:__exp ) {
      if ,,typeName ~= "_" {
         self.write( "%s := _%s" (,,typeName, ,,typeName) );
         self.outputStem2Type( ,,typeSym );
         self.writeln( "" );
      }
   }

   let hasAccessLoopSym = node.$key$.$posForModToRef or node.$val.$posForModToRef;
   
   self.write( "for " );
   let loopExpType = node.$exp.$expType;
   switch loopExpType.$kind {
      case .List, .Array {
         let valName = self.getSymbolSym( node.$val );
         let itemType = loopExpType.$itemTypeInfoList[ 1 ];
         if hasAccessLoopSym {
            if! let key = node.$key {
               _keyItemDecl( key.$name );
               self.write( ", " );
            }
            else {
               self.write( "_, " );
            }
            
            _keyItemDecl( valName );
            self.write( " := " );
         }
         self.write( "range( " );
         filter( node.$exp, self, node );
         self.writeln( ".Items ) {" );
         self.pushIndent( ## );
         if! let key = node.$key {
            if key.$posForModToRef {
               self.writeln( "%s := _%s + 1" (self.getSymbolSym( key ), key.$name) );
            }
         }
         _keyItemSet( itemType, valName );
         self.popIndent();
      }
      case .Map {
         let valName = self.getSymbolSym( node.$val );
         let itemType = loopExpType.$itemTypeInfoList[ 2 ];
         let keyType = loopExpType.$itemTypeInfoList[ 1 ];
         if hasAccessLoopSym {
            if! let key = node.$key {
               _keyItemDecl( key.$name );
               self.write( ", " );
            }
            else {
               self.write( "_, " );
            }
            
            _keyItemDecl( valName );
            self.write( " := " );
         }
         self.write( "range( " );
         filter( node.$exp, self, node );
         self.writeln( ".Items ) {" );
         self.pushIndent( ## );
         if! let key = node.$key {
            _keyItemSet( keyType, key.$name );
         }
         _keyItemSet( itemType, valName );
         self.popIndent();
      }
      case .Set {
         let valType = loopExpType.$itemTypeInfoList[ 1 ];
         let valName = self.getSymbolSym( node.$val );
         if hasAccessLoopSym {
            _keyItemDecl( valName );
            self.write( " := " );
         }
         self.write( "range( " );
         filter( node.$exp, self, node );
         self.writeln( ".Items ) {" );
         self.pushIndent( ## );
         _keyItemSet( valType, valName );
         self.popIndent();
      }
      default {
         Util.err( "not support -- %s" (__func__) );
      }
   }
   filter( node.$block, self, node );
   self.write( "}" );
   self.writeln( "" );
}

let type2LnsItemKindMap = {
   Ast.builtinTypeInt : "LnsItemKindInt",
   Ast.builtinTypeReal : "LnsItemKindReal",
   Ast.builtinTypeString : "LnsItemKindStr"
};

fn getLnsItemKind( typeInfo:&Ast.TypeInfo ): str {
   if! let kind = type2LnsItemKindMap[ typeInfo ] {
      return kind;
   }
   return "LnsItemKindStem";
}


pub override fn convFilter.processForsort(
   node: &Nodes.ForsortNode, opt: Opt ) mut
{
   if node.$exp.$expType.$srcTypeInfo.$kind == .Ext {
      self.outputForeachLua( node, true, node.$exp, node.$val, node.$key, node.$block );
      return;
   }
   
   let keySym:&Ast.SymbolInfo!;
   let valSym:&Ast.SymbolInfo!;
   let keyTypeInfo = node.$exp.$expType.$itemTypeInfoList[ 1 ];
   if node.$exp.$expType.$kind == .Set {
      keySym = node.$val;
      valSym = node.$key;
   }
   else {
      keySym = node.$key;
      valSym = node.$val;
   }

   
   self.writeln( "{" );
   self.pushIndent(##);
   let collSym = "__collection%d" (node.$id);
   self.write( "%s := " (collSym) );
   filter( node.$exp,  self, node );
   self.writeln( "" );
   let sortSym = "__sorted%d" (node.$id);
   self.write( "%s := %s." (sortSym, collSym) );
   switch keyTypeInfo {
      case Ast.builtinTypeInt {
         self.writeln( "CreateKeyListInt()" );
      }
      case Ast.builtinTypeReal {
         self.writeln( "CreateKeyListReal()" );
      }
      case Ast.builtinTypeString {
         self.writeln( "CreateKeyListStr()" );
      }
      default {
         self.writeln( "CreateKeyListStem()" );
      }
   }
   self.writeln( "%s.Sort( %s, nil )" (sortSym, getLnsItemKind( keyTypeInfo ) ) );


   self.write( "for _, " );
   let mut key = "__key%d" (node.$id);
   when! keySym {
      key = "%s" (self.getSymbolSym( keySym ));
   }
   self.write( "_%s" (key) );
   self.writeln( " := range( %s.Items ) {" (sortSym) );
   self.pushIndent(##);
   when! valSym {
      if valSym.$posForModToRef {
         self.write( "%s := %s.Items[ _%s ]"
            ( self.getSymbolSym( valSym ), collSym, key ) );
         self.outputStem2Type( valSym.$typeInfo );
         self.writeln( "" );
      }
   }
   when! keySym {
      if keySym.$posForModToRef {
         self.write( "%s := _%s" (key, key));
         self.outputStem2Type( keySym.$typeInfo );
         self.writeln( "" );
      }
   }
   self.popIndent();
   
   filter( node.$block, self, node );
   //self.popIndent();
   self.writeln( "}" );
   self.popIndent();
   self.writeln( "}" );
}

pub override fn convFilter.processExpUnwrap(
   node: &Nodes.ExpUnwrapNode, opt: Opt ) mut
{
   if! let def = node.$default {
      self.write( "Lns_unwrapDefault( " );
      filter( node.$exp, self, node );
      self.write( ", " );
      filter( def, self, node );
   } else {
      self.write( "Lns_unwrap( " );
      filter( node.$exp, self, node );
   }
   self.write( ")" );
   self.outputAny2Type( node.$expType );
}

pub override fn convFilter.processExpToDDD( node: &Nodes.ExpToDDDNode, opt: Opt ) mut
{
   if node.$expList.$mRetExp {
      filter( node.$expList, self, node );
   }
   else {
      self.write ( "[]LnsAny{ " );
      filter( node.$expList, self, node );
      self.write ( "}" );
   }
}

pub override fn convFilter.processExpNew(
   node: &Nodes.ExpNewNode, opt: Opt ) mut
{
   let className = self.getTypeSymbol( node.$expType );
   if self.isSamePackage( node.$expType.getModule() ) {
      self.write( "New%s(" ( className ) );
   } else {
      if! let refTypeNode = node.$symbol@@@Nodes.RefTypeNode {
         if! let refNode = refTypeNode.$name@@@Nodes.RefFieldNode {
            filter( refNode.$prefix, self, node );
            self.write( "." );
         }
      }
      self.write( "New%s(" ( className ) );
   }
   if! let argList = node.$argList {
      let scope = unwrap node.$expType.$scope;
      let initFuncType = unwrap scope.getTypeInfoField( "__init", true, scope, .Normal );
      
      self.processSetFromExpList(
         self.getConvExpName( node.$id, argList ), 
         initFuncType.$argTypeInfoList, argList );
   }
   self.write( ")" );
}

fn convFilter.outputIFMethods( node: &Nodes.DeclClassNode ) mut {
   self.pushIndent(##);

   let mut name2MtdType:Map<str,&Ast.TypeInfo> = {};
   let scope = unwrap node.$expType.$scope;
   scope.filterTypeInfoField(
      true, scope, .Normal, fn ( symbolInfo:&Ast.SymbolInfo ): bool {
         if symbolInfo.$kind == .Mtd and symbolInfo.$name ~= "__init" and
            not symbolInfo.$staticFlag
         {
            name2MtdType[ symbolInfo.$name ] = symbolInfo.$typeInfo;
         }
         return true;
      });
   forsort typeInfo, name in name2MtdType {
      self.write( "%s(" (self.getSymbol( .Func( typeInfo ), name) ));
      foreach argType, index in typeInfo.$argTypeInfoList {
         if index ~= 1 {
            self.write( ", " );
         }
         self.write( "arg%d %s" (index, self.type2gotype(argType) ) );
      }
      self.write( ")" );
      self.outputRetType( typeInfo.$retTypeInfoList );
      self.writeln( "" );
   }
   
   self.popIndent();
}

fn convFilter.outputMethodIF( node: &Nodes.DeclClassNode ) mut {
   self.write( "type " );
   self.write( self.getTypeSymbol( node.$expType ) );
   self.writeln( "Mtd interface {" );

   self.outputIFMethods( node );
   
   self.writeln( "}" );
}

fn convFilter.outputInterfaceType( node: &Nodes.DeclClassNode ) mut {
   self.writeln(
      "type %s interface {" (self.getTypeSymbol( node.$expType ) ) );

   self.pushIndent(##);

   self.outputIFMethods( node );
   
   self.popIndent();

   self.writeln( "}" );

   let typeName = self.type2gotype( node.$expType );
   self.writeln( "func Lns_cast2%s( obj LnsAny ) LnsAny {" (typeName ) );
   self.writeln( "    if _, ok := obj.(%s); ok { " (typeName) );
   self.writeln( "        return obj" );
   self.writeln( "    }" );
   self.writeln( "    return nil" );
   self.writeln( "}");

   
}



fn convFilter.outputClassType( node: &Nodes.DeclClassNode ) mut {
// type Parent struct {
//     val1 int
//     FP ParentMtd
// }
   
   self.write( "type " );
   self.write( self.getTypeSymbol( node.$expType ) );
   self.writeln( " struct {" );

   self.pushIndent(##);

   if node.$expType.hasBase() {
      let superClassType = node.$expType.$baseTypeInfo;
      self.writeln( self.getTypeSymbolWithPrefix( superClassType ) );
   }
   
   foreach memberNode in node.$memberList {
      filter( memberNode, self, node );
   }
   self.write( "FP " );
   self.write( self.getTypeSymbol( node.$expType ) );
   self.writeln( "Mtd" );

   self.popIndent();

   self.writeln( "}" );
}

fn convFilter.outputToStem( node: &Nodes.DeclClassNode ) mut {
   self.writeln(
      "func %s2Stem( obj LnsAny ) LnsAny {" ( self.getTypeSymbolWithPrefix( node.$expType) ) );
   self.pushIndent( ## );
   self.writeln( "if obj == nil {" );
   self.writeln( "    return nil" );
   self.writeln( "}" );
   self.writeln( "return obj.(%s).FP" (self.type2gotype( node.$expType) ) );
   self.popIndent();
   self.writeln( "}" );
}


fn convFilter.outputDownCast( node: &Nodes.DeclClassNode ) mut {
   let symbol = self.getTypeSymbol( node.$expType );
   self.write( "type " );
   self.writeln( "%sDownCast interface {" (symbol) );
   self.pushIndent( ## );
   self.write( "To" );
   self.write( symbol );
   self.write( "() *" );
   self.write( symbol );
   self.writeln( "" );
   self.popIndent();
   self.writeln( "}" );

   self.writeln( "func %sDownCastF( multi ...LnsAny ) LnsAny {" (symbol ));
   self.pushIndent( ## );
   self.writeln( "if len( multi ) == 0 { return nil }" );
   self.writeln( "obj := multi[ 0 ]" );
   self.writeln( "if ddd, ok := multi[ 0 ].([]LnsAny); ok { obj = ddd[0] }" );
   self.writeln( "work, ok := obj.(%sDownCast)"
                 (self.getTypeSymbolWithPrefix( node.$expType )) );
   self.writeln( "if ok { return work.To%s() }" (symbol) );
   self.writeln( "return nil" );
   self.popIndent();
   self.writeln( "}" );
}

fn convFilter.outputCastReceiver( node: &Nodes.DeclClassNode ) mut {
   self.write( "func (obj *" );
   self.write( self.getTypeSymbol( node.$expType ) );
   self.write( ") To" );
   self.write( self.getTypeSymbol( node.$expType ) );
   self.write( "() *" );
   self.write( self.getTypeSymbol( node.$expType ) );
   self.writeln( " {" );
   self.pushIndent(##);
   self.writeln( "return obj" );
   self.popIndent();
   self.writeln( "}" );
}

fn convFilter.outputNewSetup( objName:str, classType:&Ast.TypeInfo ) mut
{
   let className = self.getTypeSymbol( classType );
   self.writeln( "%s := &%s{}" (objName, className) );
   self.writeln( "%s.FP = %s" (objName,objName) );

   {
      let mut workType = classType;
      while workType.hasBase() {
         workType = workType.$baseTypeInfo;
         
         let superName = self.getTypeSymbol( workType );
         self.writeln( "%s.%s.FP = %s" (objName, superName, objName) );
      }
   }
}

fn convFilter.outputConstructor( node: &Nodes.DeclClassNode ) mut
{
   let scope = unwrap node.$expType.$scope;
   let initFuncType = unwrap scope.getTypeInfoField( "__init", true, scope, .Normal );

   let className = self.getTypeSymbol( node.$expType );
   let ctorName = self.getConstrSymbol( node.$expType );

   if not node.$expType.$abstractFlag {
      self.write( "func New%s(" ( className ) );
      self.outputDeclFuncArg( initFuncType );
      self.writeln( ") *%s {" (className) );
      self.pushIndent(##);
      self.outputNewSetup( "obj", node.$expType );
      self.write( "obj.%s(" (ctorName));
      foreach _, index in initFuncType.$argTypeInfoList {
         if index ~= 1 {
            self.write( ", " );
         }
         self.write( "arg%d" ( index ));
      }
      self.writeln( ")" );
      self.writeln( "return obj" );
      self.popIndent();

      self.writeln( "}" );
   }

   
   if not node.hasUserInit() {
      // default constructor
      self.write( "func (self *%s) %s(" (className, ctorName) );

      self.outputDeclFuncArg( initFuncType );
      self.writeln( ") {" );
      self.pushIndent(##);


      // super を呼ぶ
      let superArgNum;
      if node.$expType.hasBase() {
         let superType = node.$expType.$baseTypeInfo;
         let baseScope = unwrap superType.$scope;
         let baseInitFuncType = unwrap baseScope.getTypeInfoField(
            "__init", true, baseScope, .Normal );
         let superName = self.getTypeSymbol( superType );
         self.write( "self.%s.%s( "
                     (superName, self.getConstrSymbol( superType ) ) );
         for index = 1, #baseInitFuncType.$argTypeInfoList {
            if index ~= 1 {
               self.write( "," );
            }
            if node.$hasOldCtor {
               self.write( "nil" );
            } else {
               self.write( "arg%d" (index) );
            }
         }
         self.writeln( ")" );
         if node.$hasOldCtor {
            superArgNum = 0;
         } else {
            superArgNum = #baseInitFuncType.$argTypeInfoList;
         }
      }
      else {
         superArgNum = 0;
      }

      // メンバをセットする
      let mut argIndex = superArgNum + 1;
      foreach memberNode in node.$memberList {
         if not memberNode.$staticFlag {
            self.writeln(
               "self.%s = arg%d"
               ( self.getSymbol(
                  .Member( Ast.isPubToExternal( memberNode.$accessMode ) ),
                  memberNode.$name.txt ), argIndex ));
            argIndex = argIndex + 1;
         }
      }
      
      self.popIndent();
      self.writeln( "}" );
   }
}

pub fn convFilter.outputAccessor( node: &Nodes.DeclClassNode ) mut
{
   let classType = node.$expType;
   if classType.$kind == .IF {
      return;
   }

   foreach memberNode in node.$memberList {
      let memberNameToken = memberNode.get_name();
      let memberName = memberNameToken.txt;
      let memberSym = memberNode.$symbolInfo;

      if memberNode.get_getterMode() ~= .None {
         let getterName = "get_%s" (memberName);
         let getterSym = unwrap classType.$scope$.getSymbolInfoChild$( getterName );
         self.outputDeclFunc( .Type( getterSym.$typeInfo ) );

         let retType = getterSym.$typeInfo.$retTypeInfoList[1].$srcTypeInfo;
         self.write( "{ return " );

         let prefix;
         if memberSym.$staticFlag {
            prefix = "";
         } else {
            prefix = "self.";
         }
         
         if retType.$srcTypeInfo ~= memberSym.$typeInfo.$srcTypeInfo {
            if retType.$kind == .IF {
               if Ast.isClass( memberSym.$typeInfo.$srcTypeInfo ) {
                  self.write( "%s%s.FP" (prefix, self.getSymbolSym( memberSym)) );
               }
            } elseif Ast.isClass( retType ) {
               self.write( "&%s%s.%s"
                           ( prefix, self.getSymbolSym( memberSym),
                             self.getTypeSymbol( retType ) ) );
            } elseif retType.$kind == .Alternate and retType.hasBase() {
               self.write( "%s%s.FP" (prefix, self.getSymbolSym( memberSym)) );
               self.outputStem2Type( retType );
            } else {
               if isAnyType( retType ) and Ast.isClass( memberSym.$typeInfo ) {
                  self.write( "%s%s.FP" (prefix, self.getSymbolSym( memberSym)) );
               }
               else {
                  Util.err( "not support" );
               }
            }
         } else {
            self.write( "%s%s" ( prefix, self.getSymbolSym( memberSym)) );
         }
         self.writeln( " }" );
      }
      if memberNode.get_setterMode() ~= .None {
         let setterName = "set_%s" (memberName);
         let setterSym = unwrap classType.$scope$.getSymbolInfoChild$( setterName );
         self.outputDeclFunc( .Type( setterSym.$typeInfo ) );
         self.write( "{ self.%s = arg1 " ( self.getSymbolSym( memberSym)) );
         self.writeln( "}" );
      }
   }
}

fn convFilter.outputStaticMember( node: &Nodes.DeclClassNode ) mut {
   if self.processMode == .DeclClass {
      foreach memberNode in node.$memberList {
         if memberNode.$staticFlag {
            self.writeln(
               "var %s %s" ( self.getSymbol( .Static( node.$expType ),
                                             memberNode.$name.txt ),
                             self.type2gotype( memberNode.$expType ) ) );
         }
      }
      if! let initBlock = node.$initBlock.$func {
         filter( initBlock  , self, node );
         self.writeln( "" );
      }
   }
   else {
      if! let initBlock = node.$initBlock.$func {
         self.writeln( "%s()" (self.getFuncSymbol( initBlock.$expType ) ) );
      }
   }
}

let type2FromStemNameMap = {
   Ast.builtinTypeInt:"Lns_ToInt",
   Ast.builtinTypeReal:"Lns_ToReal",
   Ast.builtinTypeBool:"Lns_ToBool",
   Ast.builtinTypeString:"Lns_ToStr",
   Ast.builtinTypeStem:"Lns_ToStem"
};
fn convFilter.getFromStemName(typeInfo:&Ast.TypeInfo) : str {
   let workTypeInfo = getOrgTypeInfo( typeInfo );
   if! let name = type2FromStemNameMap[ workTypeInfo ] {
      return name;
   }
   switch workTypeInfo.$kind {
      case .List, .Array {
         return "Lns_ToList";
      }
      case .Set {
         return "Lns_ToSet";
      }
      case .Map {
         return "Lns_ToLnsMap";
      }
      case .Class {
         return "%s_FromMap" (self.getTypeSymbol(workTypeInfo));
      }
      default {
         Util.err( "%s: not support -- %s" (__func__, workTypeInfo.$kind.$_txt ) );
      }
   }
}

fn convFilter.outputConvItemTypeList( itemTypeInfoList:&List<&Ast.TypeInfo>,
                                      alt2type:&Map<&Ast.TypeInfo,&Ast.TypeInfo>! ) mut;

fn convFilter.outputConvItemType(
   typeInfo:&Ast.TypeInfo, alt2type:&Map<&Ast.TypeInfo,&Ast.TypeInfo>! ) mut
{
   let mut workTypeInfo = typeInfo.$srcTypeInfo.$nonnilableType;
   if typeInfo.$srcTypeInfo.$nonnilableType.$kind == .Alternate {
      when! alt2type {
         if! let alt = alt2type[ workTypeInfo ] {
            workTypeInfo = alt;
         }
      }
   }

   if! let altType = workTypeInfo@@@Ast.AlternateTypeInfo {
      self.write( 'paramList[%d]' (altType.$altIndex - 1 ) );
   } else {
      self.writeln( "Lns_ToObjParam{" );
      self.pushIndent(##);
      self.write(
         "%sSub, %s," (self.getFromStemName( workTypeInfo ), typeInfo.$nilable ) );
      self.outputConvItemTypeList( workTypeInfo.$itemTypeInfoList, alt2type );
      self.popIndent();
      self.write( "}" );
   }
}

fn convFilter.outputConvItemTypeList( itemTypeInfoList:&List<&Ast.TypeInfo>,
                                      alt2type:&Map<&Ast.TypeInfo,&Ast.TypeInfo>! ) mut
{
   if #itemTypeInfoList > 0 {
      self.write( "[]Lns_ToObjParam{" );
      self.pushIndent(##);
      foreach itemType, index in itemTypeInfoList {
         if index > 1 {
            self.write( "," );
         }

         self.outputConvItemType( itemType, alt2type );
      }
      self.popIndent();
      self.write( "}" );
   } else {
      self.write( "nil" );
   }
}

fn convFilter.outputAlter2MapFunc( alt2Map:&Map<&Ast.TypeInfo,&Ast.TypeInfo>) mut
{
   self.write( "{" );

   foreach assinType, altType in alt2Map {
      if altType.$kind == .Alternate {
         if assinType.$kind == .Alternate {
            Util.err( "not support: %s" (__func__) );
         }
         else {
            self.outputConvItemType( assinType, alt2Map );
         }
      }
   }

   self.write( "}" );
}


fn convFilter.outputAsyncItem( node: &Nodes.DeclClassNode ) mut {
   let classType = node.$expType;
   let classScope = unwrap classType.$scope;
   let createSym = unwrap classScope.getSymbolInfoChild( "_createPipe" );
   self.outputDeclFunc( .WithClass( classType, createSym.$typeInfo ) );
   self.writeln( "{" );
   self.writeln( "   return NewLnspipe( arg1 )" );
   self.writeln( "}" );
}

fn convFilter.outputMapping( node: &Nodes.DeclClassNode ) mut {
   let classType = node.$expType;
   let className = self.getTypeSymbol( classType );
   self.writeln( "func (self *%s) ToMapSetup( obj *LnsMap ) *LnsMap {" (className) );
   self.pushIndent( ## );
   foreach memberNode in node.$memberList {
      if not memberNode.$staticFlag {
         self.writeln(
            'obj.Items["%s"] = Lns_ToCollection( self.%s )'
            ( memberNode.$symbolInfo.$name,
              self.getSymbolSym( memberNode.$symbolInfo ) ) );
         }
   }
   if classType.hasBase() {
      self.writeln( "return self.%s.ToMapSetup( obj )"
         (self.getTypeSymbol( classType.$baseTypeInfo) ) );
   } else {
      self.writeln( "return obj" );
   }
   self.popIndent();
   self.writeln( "}" );
   self.writeln( "func (self *%s) ToMap() *LnsMap {" (className) );
   self.writeln( "    return self.ToMapSetup( NewLnsMap( map[LnsAny]LnsAny{} ) )" );
   self.writeln( "}" );


   let fromStemName = self.getFromStemName(classType);
   
   let classScope = unwrap classType.$scope;
   if not classType.$abstractFlag {
      {
         let fromMapSym = unwrap classScope.getSymbolInfoChild( "_fromMap" );
         self.writeln(
            "func %s(arg1 LnsAny, paramList []Lns_ToObjParam)(LnsAny, LnsAny){"
            (self.getSymbolSym( fromMapSym ) ) );
         self.writeln( "   return %s( arg1, paramList )" (fromStemName) );
         self.writeln( "}" );
      }
      {
         let fromStemSym = unwrap classScope.getSymbolInfoChild( "_fromStem" );
         self.writeln(
            "func %s(arg1 LnsAny, paramList []Lns_ToObjParam)(LnsAny, LnsAny){"
            (self.getSymbolSym( fromStemSym ) ) );
         self.writeln( "   return %s( arg1, paramList )" (fromStemName) );
         self.writeln( "}" );
      }
      
      
      self.writeln(
         "func %s( obj LnsAny, paramList []Lns_ToObjParam ) (LnsAny, LnsAny) {"
         (fromStemName ));
      self.pushIndent(##);
      self.writeln( "_,conv,mess := %sSub(obj,false, paramList);"
         (fromStemName ));
      self.writeln( "return conv,mess" );
      self.popIndent();
      self.writeln( "}" );
      
      self.writeln(
         "func %sSub( obj LnsAny, nilable bool, paramList []Lns_ToObjParam ) (bool, LnsAny, LnsAny) {"
         (fromStemName ));
      self.pushIndent( ## );
      self.writeln( "var objMap *LnsMap" );
      self.writeln( "if work, ok := obj.(*LnsMap); !ok {" );
      self.writeln( '   return false, nil, "no map -- " + Lns_ToString(obj)' );
      self.writeln( "} else {" );
      self.writeln( '   objMap = work' );
      self.writeln( "}" );
      self.outputNewSetup( "newObj", classType );
      self.writeln( "return %sMain( newObj, objMap, paramList )" (fromStemName) );
      self.popIndent();
      self.writeln( "}" );
   }


   self.writeln(
      "func %sMain( newObj %s, objMap *LnsMap, paramList []Lns_ToObjParam ) (bool, LnsAny, LnsAny) {"
      (fromStemName, self.type2gotype(classType) ));
   self.pushIndent(##);
   
   if classType.hasBase() {
      self.writeln(
         "if ok,_,mess := %sMain( &newObj.%s, objMap, paramList ); !ok {"
         (self.getFromStemName(classType.$baseTypeInfo),
           self.getTypeSymbol(classType.$baseTypeInfo )) );
      self.writeln( "    return false,nil,mess" );
      self.writeln( "}" );
   }
   
   foreach memberNode in node.$memberList {
      if not memberNode.$staticFlag {
         let memberName = self.getSymbolSym( memberNode.$symbolInfo );
         self.write( "if ok,conv,mess := " );
         if memberNode.$expType.$nonnilableType.$kind == .Alternate {
            foreach itemType, index in classType.$itemTypeInfoList {
               if itemType == memberNode.$expType.$srcTypeInfo {
                  self.write(
                     'paramList[%d].Func( objMap.Items["%s"], %s, paramList[%d].Child'
                     (index - 1, memberNode.$symbolInfo.$name,
                       memberNode.$expType.$nilable, index - 1 ) );
               }
            }
         }
         else {
            self.write(
               '%sSub( objMap.Items["%s"], %s, '
               ( self.getFromStemName(memberNode.$expType),
                 memberNode.$symbolInfo.$name,      
                 memberNode.$expType.$nilable ));
            self.outputConvItemTypeList( memberNode.$expType.$itemTypeInfoList, nil );
         }
         self.writeln( "); !ok {" );
         self.writeln( '   return false,nil,"%s:" + mess.(string)'
                       (memberNode.$symbolInfo.$name) );
         self.writeln( "} else {" );
         self.write( "   newObj.%s = conv" (memberName) );
         self.outputAny2Type( memberNode.$expType );
         self.writeln( "" );
         self.writeln( "}" );
      }
   }
   self.writeln( "return true, newObj, nil" );
   self.popIndent();
   self.writeln( "}" );
}

fn convFilter.outputDummyAbstractMethod(
   classType:&Ast.TypeInfo, methodType:&Ast.TypeInfo ) mut
{
   self.outputDeclFunc( .WithClass( classType, methodType ) );
   self.writeln( "{" );
   self.outputDummyReturn( methodType.$retTypeInfoList );
   self.writeln( "}" );
}
   


fn convFilter.outputDummyAbstractMethodOfClass( classType:&Ast.TypeInfo ) mut
{
   // abstract を処理するダミーのメソッドを定義する。
   // これをしないと、 superObj = subObj の代入が出来ない

   let mut name2typeMap:Map<str,&Ast.TypeInfo> = {};
   
   let scope = unwrap classType.$scope;
   scope.filterSymbolInfoIfField(
      scope, .Normal,
      fn ( symbolInfo:&Ast.SymbolInfo ): bool {
         if symbolInfo.$kind == .Mtd and symbolInfo.$typeInfo.$abstractFlag {
            if! let methodType = scope.getTypeInfoChild( symbolInfo.$name ) {
               if methodType.$abstractFlag {
                  name2typeMap[ symbolInfo.$name ] = symbolInfo.$typeInfo;
               }
            }
            else {
               name2typeMap[ symbolInfo.$name ] = symbolInfo.$typeInfo;
            }
         }
         return true;
      });

   forsort methodType in name2typeMap {
      self.outputDummyAbstractMethod( classType, methodType );
   }
}


fn convFilter.outputAdvertise( node: &Nodes.DeclClassNode ) mut
{
   let methodNameSet = node.createMethodNameSetWithoutAdv();
   foreach adv in node.$advertiseList {
      if adv.$prefix ~= "" {
         Util.err( "%s: not support advertise with prefix" (__func__) );
      }
      if! let scope = adv.$member.$expType.$scope {
         scope.filterTypeInfoField(
            true, scope, .Normal,
            fn ( symbol:&Ast.SymbolInfo ): bool {
               if symbol.$kind == .Mtd and symbol.$name ~= "__init" and
                  not methodNameSet.has( symbol.$name ) and not symbol.$staticFlag
               {
                  let funcType = symbol.$typeInfo;
                  self.outputDeclFunc( .WithClass( node.$expType, funcType ) );
                  self.writeln( " {" );
                  if #funcType.$retTypeInfoList > 0 {
                     self.write( "    return " );
                  }
                  self.write(
                     "self.%s. " ( self.getSymbolSym( adv.$member.$symbolInfo ) ) );
                  if adv.$member.$expType.$kind == .Class {
                     self.write( "FP." );
                  }
                  self.write( "%s( " (self.getSymbolSym( symbol )) );
                  foreach _, index in funcType.$argTypeInfoList {
                     if index > 1 {
                        self.write( "," );
                     }
                     self.write( "arg%d" (index) );
                  }
                  self.writeln( ")" );
                  self.writeln( "}" );
               }
               return true;
            });
      }
   }
}

pub override fn convFilter.processProtoClass(
   node: &Nodes.ProtoClassNode, opt: Opt ) mut
{
}

pub override fn convFilter.processDeclClass(
   node: &Nodes.DeclClassNode, opt: Opt ) mut
{
   if node.isModule() {
      return;
   }
   if self.processMode == .DeclClass {
      switch node.$expType.$kind {
         case .Class {
            self.writeln( "// declaration Class -- %s" (node.$expType.$rawTxt) );
            self.outputStaticMember( node );
            self.outputMethodIF( node );
            self.outputClassType( node );
            self.outputToStem( node );
            self.outputDownCast( node );
            self.outputCastReceiver( node );
            self.outputConstructor( node );
            self.outputAccessor( node );
            self.outputDummyAbstractMethodOfClass( node.$expType );
            self.outputAdvertise( node );

            if node.$expType.isInheritFrom(
               self.processInfo, Ast.builtinTypeMapping, nil ) {
               self.outputMapping( node );
            }

            if node.$expType.isInheritFrom(
               self.processInfo, Ast.builtinTypeAsyncItem, nil ) {
               self.outputAsyncItem( node );
            }
            
            foreach fieldNode in node.$fieldList {
               if fieldNode@@@Nodes.DeclMemberNode {
                  // ここではメンバーを処理しない
               } else {
                  filter( fieldNode, self, node );
                  self.writeln( "" );
               }
            }
         }
         case .IF {
            self.outputInterfaceType( node );
         }
         default {
            Util.err(
               "%s: not support -- %s:%d"
               (__func__, node.$expType.$kind.$_txt, node.$pos.lineNo ) );
         }
      }
   }
   else {
      self.outputStaticMember( node );
   }
}


alge CallKind {
   /** 通常処理 */
   Normal,
   /** ランタイム呼び出し */
   RuntimeCall(prefixNode:&Nodes.Node),
   /** form 呼び出し */
   FormCall,
   /** Sort 呼び出し */
   SortCall( itemType:&Ast.TypeInfo ),
   /** */
   RunLoaded,
   /** */
   BuiltinCall( packName:str, funcName:str ),
   /** */
   LuaCall,
}

/**
関数呼び出し処理。

以下も処理する。
- nilAccess の解決。
- ビルトイン関数の解決

@param callId 関数呼び出しノードの ID
@param node 関数呼び出しのノード
@param prefixNode メソッド呼び出し時のオブジェクトノード
@param funcSymbol 呼び出し関数シンボル
@return bool true の時、関数呼び出し処理に追加の ")" が必要
@return CallKind 関数コールの種別
*/
pub fn convFilter.outputCallPrefix(
   threading:bool, callId:int, node:&Nodes.Node,
   prefixNode:&Nodes.Node!, funcSymbol:&Ast.SymbolInfo ) mut : bool, CallKind
{
   let funcType = funcSymbol.$typeInfo;
   let nilAccName = "%s_%d" (self.moduleTypeInfo.$rawTxt.gsub( "@", "" ), callId );

   let mut callKind:CallKind = .Normal;
   
   let extCallFlag;
   when! prefixNode {
      extCallFlag = prefixNode.$expType.$nonnilableType.$kind == .Ext;
   } else {
      extCallFlag = false;
   }
   if extCallFlag {
      callKind = .LuaCall;
   }

   let getEnvTxt = self.env.getEnv( threading );
   fn processNilAcc( workPrefixNode:&Nodes.Node ) {
      if not node.hasNilAccess() {
         return;
      }
      let retNum = #funcType.$retTypeInfoList;
      switch retNum {
         case 0 {
            self.write( "Lns_NilAccCall0( %s, func () {" (getEnvTxt) );
         }
         case 1 {

            self.write( "Lns_NilAccCall1( %s, func () LnsAny { return " (getEnvTxt));
         }
         default {
            if retNum <= MaxNilAccNum {
               let mut anys = "LnsAny";
               for _ = 2, retNum {
                  anys = "%s,LnsAny" (anys);
               }
               self.write(
                  "Lns_NilAccCall%d( %s, func () (%s) { return "
                  (retNum, getEnvTxt, anys) );
            }
            else {
               let mut args = "LnsAny";
               for _ = 2, retNum {
                  args = "%s,LnsAny" (args);
               }
               self.write(
                  "lns_NilAccCall_%s( %s, func () (%s) { return "
                  (nilAccName, getEnvTxt, args) );
            }
         }
      }
      if extCallFlag {
         if #funcType.$retTypeInfoList > 1 {
            self.write( "Lns_callExt%d( " (node.$id) );
         }
      }

      self.write(
         "%s.NilAccPop().(%s)"
         (getEnvTxt, self.type2gotype( workPrefixNode.$expType.$nonnilableType ) ) );
   }

   let mut closeParen = false;
   when! prefixNode {
      if node.hasNilAccess() {
         if #funcType.$retTypeInfoList >= 2 {
            // 多値になるケースでは、
            // prefixNode の hasNilAccess に関係なく必ず値の変換を行なう
            if #funcType.$retTypeInfoList <= MaxNilAccNum {
               self.write( "Lns_NilAccFinCall%d( " (#funcType.$retTypeInfoList) );
            }
            else {
               self.write( "lns_NilAccFinCall_%s(" (nilAccName) );
            }
            closeParen = true;
         }
      }

      let prefixType = prefixNode.$expType.$nonnilableType;
      
      if prefixType == Ast.builtinTypeString {
         if node.hasNilAccess() {
            Util.err( "not support nilAccName" );
         }
         if! let runtime = self.getVM( threading, funcType ) {
            callKind = .RuntimeCall( prefixNode );
            self.write( runtime );
         }
      } else {
         if not funcType.$staticFlag or funcSymbol.$kind == .Mbr
         {
            if node.hasNilAccess() {
               if not prefixNode.hasNilAccess() {
                  self.write( "%s.NilAccFin(" (getEnvTxt));
                  self.write( "%s.NilAccPush(" (getEnvTxt) );
                  filter( prefixNode, self, node );
                  self.writeln( ") && " );
               } else {
                  filter( prefixNode, self, node );
                  self.writeln( "&&" );
               }
            } else {
               if extCallFlag {
                  if #funcType.$retTypeInfoList > 1 {
                     self.write( "Lns_callExt%d( " (node.$id) );
                  }
               }
               filter( prefixNode, self, node );
            }
         } else {
            // self.outputModule( funcType.getModule(), true );
         }

         processNilAcc( prefixNode );
         if prefixType.$kind == .Ext {
            self.write( '.CallMethod( "%s", Lns_2DDD' (funcSymbol.$name) );
         } else {
            let prefixKind;
            if prefixType.$kind == .Alternate and prefixType.hasBase()
            {
               prefixKind = prefixType.$baseTypeInfo.$kind;
            } else {
               prefixKind = prefixType.$kind;
            }
            
            if Ast.isBuiltin( funcType.$typeId ) {
               switch prefixKind {
                  case .Class {
                     // class は継承があるので FP 経由で実行する
                     self.write( ".FP.%s"( self.getSymbolSym( funcSymbol ) ) );
                  }
                  default {
                     let builtinFuncs = TransUnit.getBuiltinFunc();
                     if! let runtime = self.getVM( threading, funcType ) {
                        self.write ( runtime );
                     }
                     else {
                        switch funcType {
                           case builtinFuncs.list_sort, builtinFuncs.array_sort {
                              callKind = .SortCall( prefixType.$itemTypeInfoList[ 1 ] );
                           }
                        }
                        self.write( ".%s"( self.getSymbolSym( funcSymbol ) ) );
                     }
                  }
               }
            } else {
               switch funcType.$kind {
                  case .Method {
                     switch prefixKind {
                        case .Class {
                           // class は継承があるので FP 経由で実行する
                           self.write( ".FP.%s"( self.getSymbolSym( funcSymbol ) ) );
                        }
                        default {
                           self.write( ".%s"( self.getSymbolSym( funcSymbol ) ) );
                        }
                     }
                  }
                  default {
                     if funcSymbol.$kind == .Mbr {
                        self.write( "." );
                     }
                     self.write( self.getSymbolSym( funcSymbol ) );
                  }
               }
            }
         }
      }
   }

   return closeParen, callKind;
}

pub override fn convFilter.processExpCall(
   node: &Nodes.ExpCallNode, opt: Opt ) mut
{
   let funcType = node.$func.$expType.$nonnilableType;

   if funcType.$kind == .Method and
      funcType.$parentInfo.$kind == .Enum and
      funcType.$rawTxt == "get__txt"
   {
      self.write( "%s("
                  (self.getEnumGetTxtSym(
                     unwrap funcType.$parentInfo.$aliasSrc@@@Ast.EnumTypeInfo ) ));
      let! fieldNode = node.$func@@@Nodes.RefFieldNode {
         Util.err( "not support -- __func__" );
      };
      
      filter( fieldNode.$prefix, self, node );
      self.write( ")" );
      return;
   }


   let retGenerics;
   if opt.parent.$kind == Nodes.NodeKind.$StmtExp {
      // このノードの親が SmmtExp なら call(); の形で戻り値は捨てられている
      retGenerics = false;
   } else {
      // この関数の戻り値が捨てられないなら、
      // generics 化処理の必要性の有無をチェックする。
      retGenerics = isRetGenerics( node );
      if retGenerics and #funcType.$retTypeInfoList ~= 1 {
         self.write( "%s(" (self.getConvGenericsName( node )) );
      }
   }


   let mut closeParen = false;
   let mut callKind:CallKind = .Normal;
   let withPrefix;
   if! let fieldNode = node.$func@@@Nodes.RefFieldNode {
      withPrefix = true;
      closeParen, callKind = self.outputCallPrefix(
         node.isThreading(), node.$id,
         fieldNode, fieldNode.$prefix, unwrap fieldNode.$symbolInfo );
   } else {
      withPrefix = false;
      if Ast.isBuiltin( funcType.$typeId ) {
         let builtinFuncs = TransUnit.getBuiltinFunc();

         if! let runtime = self.getVM( node.isThreading(), funcType ) {
            self.write( runtime );
         } else {
            switch funcType.$srcTypeInfo {
               case Ast.builtinTypeForm {
                  filter( node.$func, self, node );
                  callKind = .FormCall;
               }
               // case Ast.builtinTypeLoadedFunc {
               //    self.write( "Lns_getVM().RunLoadedfunc" );
               //    callKind = .RunLoaded;
               // }
               default {
                  Util.err( "%s: not support -- %s:%d"
                     (__func__, funcType.getTxt(##), node.$pos.lineNo) );
               }
            }
         }
      } else {
         if funcType.$kind == .Ext {
            self.write( "%s.RunLoadedfunc" (self.env.getLuavm( node.isThreading() )) );
            callKind = .RunLoaded;
         } else {
            filter( node.$func, self, node );
         }
      }
   }

   self.write( "(" );

   let mut closeTxt:str! = nil;
   match callKind {
      case .RuntimeCall(prefixNode) {
         filter( prefixNode, self, node.$func );
         if node.$argList {
            self.write( "," );
         }
      }
      case .FormCall {
         self.write( "Lns_2DDD(" );
      }
      case .RunLoaded {
         filter( node.$func, self, node );
         self.write( "," );
         if not node.$argList {
            self.write( "[]LnsAny{}" );
         } else {
            self.write( "Lns_2DDD(" );
            closeTxt = ")";
         }
      }
      case .SortCall( typeInfo ) {
         self.write( "%s, " (getLnsItemKind( typeInfo )) );
      }
      case .BuiltinCall( packName, funcname ) {
         closeTxt = "}";
         self.write( '"%s", "%s"' (packName, funcname) );
         if node.$argList {
            self.write( ", []LnsAny{" );
         }
      }
      case .LuaCall {
         closeTxt = ")";
      }
   }

   if! let argList = node.$argList {
      self.processSetFromExpList(
         self.getConvExpName( node.$id, argList ), 
         funcType.$argTypeInfoList, argList );
   }

   if funcType.$kind == .Func and
      funcType.$staticFlag and
      funcType.$parentInfo.isInheritFrom(
         self.processInfo, Ast.builtinTypeMapping ## ) and
       (funcType.$rawTxt == "_fromMap" or funcType.$rawTxt == "_fromStem")
   {
      let! fieldNode = node.$func@@@Nodes.RefFieldNode {
         Util.err( "not support -- __func__" );
      };
      self.write( "," );
      
      self.outputConvItemTypeList(
         funcType.$parentInfo.$itemTypeInfoList,
         fieldNode.$prefix.$expType.createAlt2typeMap( false ));
   }

   when! closeTxt {
      self.write( closeTxt );
   }
   self.write( ")" );
   if callKind == .LuaCall or callKind == .RunLoaded {
      if #funcType.$retTypeInfoList == 1 {
         if opt.parent.$kind ~= Nodes.NodeKind.$StmtExp {
            self.write( "[0]" );
            let retTypeList = unwrap Ast.convToExtTypeList(
               self.processInfo, funcType.$retTypeInfoList );
            self.outputAny2Type( retTypeList[ 1 ] );
         }
      } elseif #funcType.$retTypeInfoList > 1 {
         self.write( ")" );
      }
   }


   if retGenerics {
      // generics の解決
      if #funcType.$retTypeInfoList == 1 {
         let retType = funcType.$retTypeInfoList[ 1 ];
         if isAnyType( retType ) {
            if not isAnyType( node.$expType ) {
               self.outputAny2Type( node.$expType );
            }
         } elseif retType.$kind == .Alternate {
            if retType.$srcTypeInfo ~= node.$expType.$srcTypeInfo {
               self.write( ".FP" );
               self.outputStem2Type( node.$expType );
            }
         }
      } else {
         self.write( ")" );
      }
   }

   if withPrefix and node.hasNilAccess() {
      self.write( "})" );
      self.write( "/* %d:%d */" (node.$pos.lineNo, node.$pos.column) );
      
      if opt.parent.hasNilAccess() {
         // self.writeln(" && // " );
      } else {
         self.write( ")" );
      }
      if closeParen {
         self.write( ")" );
      }
   }

   if callKind == .FormCall {
      self.write( ")" );
   }
}

pub override fn convFilter.processExpMRet(
   node: &Nodes.ExpMRetNode, opt:Opt ) mut
{
   filter( node.$mRet, self, node );
}


pub override fn convFilter.processExpAccessMRet(
   node: &Nodes.ExpAccessMRetNode, opt:Opt ) mut

{
   //Util.err( "not support -- %s" (__func__) );
}


pub override fn convFilter.processExpList(
   node: &Nodes.ExpListNode, opt: Opt ) mut
{
   foreach exp, index in node.$expList {
      if index ~= 1 {
         self.write( ", " );
      }
      if! let mRetExp = node.$mRetExp {
         if mRetExp.$index == index {
            if index == 1 or exp.$expType.$kind == .DDD {
               filter( exp, self, node );
            }
            else {
               self.write( "Lns_2DDD(" );
               filter( exp, self, node );
               self.write( ")" );
            }
            break;
         }
      }
      filter( exp, self, node );
   }
}

pub override fn convFilter.processExpOp1(
   node: &Nodes.ExpOp1Node, opt: Opt ) mut
{
   switch node.$op.txt {
      case "~" {
         self.write( "^" );
         filter( node.$exp, self, node );
      }
      case "+", "-" {
         self.write( node.$op.txt );
         filter( node.$exp, self, node );
      }
      case "not" {
         self.write( "Lns_op_not(" );
         filter( node.$exp, self, node );
         self.write( ")" );
      }
      case "#" {
         switch node.$exp.$expType.$kind {
            case .List {
               filter( node.$exp, self, node );
               self.write( ".Len()" );
            }
            case .Ext {
               switch node.$exp.$expType.$extedType.$kind {
                  case .List {
                     filter( node.$exp, self, node );
                     self.write( ".Len()" );
                  }
                  default {
                     Util.err( "%s: not support -- %s"
                               (__func__, node.$exp.$expType.getTxt(##)) );
                  }
               }
            }
            default {
               self.write( "len(" );
               filter( node.$exp, self, node );
               self.write( ")" );
            }
         }
      }
      default {
         Util.err( "%s: not support -- %s" (__func__, node.$op.txt) );
      }
   }
}

pub override fn convFilter.processExpMultiTo1(
   node: &Nodes.ExpMultiTo1Node, opt: Opt ) mut
{
   self.write( "Lns_car(" );
   filter( node.$exp, self, node );
   // if node.$exp.$expType.$kind == .DDD {
   //    self.write( "..." );
   // }
   self.write( ")" );
   self.outputAny2Type( node.$expType );
}

pub override fn convFilter.processExpCast(
   node: &Nodes.ExpCastNode, opt: Opt ) mut
{
   switch node.$castKind {
      case .Force {
         if isAnyType( node.$exp.$expType ) {
            switch node.$castType {
               case Ast.builtinTypeInt {
                  self.write( "Lns_forceCastInt(" );
                  filter( node.$exp, self, node );
                  self.write( ")" );
               }
               case Ast.builtinTypeReal {
                  self.write( "Lns_forceCastReal(" );
                  filter( node.$exp, self, node );
                  self.write( ")" );
               }
               default {
                  filter( node.$exp, self, node );
                  self.outputAny2Type( node.$castType );
               }
            }
         }
         else {
            self.write( "(%s)(" (self.type2gotype( node.$castType ) ) );
            filter( node.$exp, self, node );
            self.write( ")" );
         }
      }
      case .Implicit {
         if #node.$exp.$expTypeList > 1 {
            filter( node.$exp, self, node );
         } else {
            self.outputImplicitCast( node.$castType, node.$exp, node );
         }
      }
      case .Normal {
         let typeName = self.getTypeSymbolWithPrefix( node.$castType );
         let castType = node.$castType.$nonnilableType;
         if castType.$kind == .Class and
            castType ~= Ast.builtinTypeString
         {
            self.write( "%sDownCastF(" (typeName) );
            filter( node.$exp, self, node );
            if node.$exp.$expType.$kind == .Class and
               node.$exp.$expType ~= Ast.builtinTypeString
            {
               self.write( ".FP" );
            }
            self.write( ")" );
         } else {
            self.write( "Lns_cast2%s( " (self.type2gotype( castType ) ) );
            filter( node.$exp, self, node );
            self.write( ")" );
         }
      }
   }
}


pub override fn convFilter.processExpParen(
   node: &Nodes.ExpParenNode, opt: Opt ) mut
{
   if #node.$exp.$expTypeList >= 2 {
      self.write( "Lns_car(" );
      filter( node.$exp, self, node );
      self.write( ")" );
      self.outputAny2Type( node.$expType );
   }
   else {
      self.write( "(" );
      filter( node.$exp, self, node );
      self.write( ")" );
   }
}


pub override fn convFilter.processExpSetVal(
   node: &Nodes.ExpSetValNode, opt: Opt ) mut
{
   filter( node.$exp1, self, node );
   if getExpListKind( node.$exp1.$expTypeList, node.$exp2 ) == .Direct {
      for _ = #node.$exp1.$expTypeList + 1, #node.$exp2.$expTypeList {
         self.write( ",_" );
      }
   }
   self.write( " = " );
   self.processSetFromExpList(
      self.getConvExpName( node.$id, node.$exp2 ), node.$exp1.$expTypeList, node.$exp2 );
   self.writeln( "" );
}

pub override fn convFilter.processExpSetItem(
   node: &Nodes.ExpSetItemNode, opt: Opt ) mut
{
   filter( node.$val, self, node );
   self.write( ".Set(" );
   _match node.$index {
      case .NodeIdx( index ) {
         filter( index, self, node );
      }
      case .SymIdx( index ) {
         self.write( '"%s"' (index) );
      }
   }
   self.write( "," );
   filter( node.$exp2, self, node );
   self.write( ")" );
}

fn convFilter.processAndOr( node: &Nodes.ExpOp2Node,
                            opTxt: str, parent: &Nodes.Node ) mut
{
   fn isAndOr( exp:&Nodes.Node ) : bool {
      if! let parentNode = exp@@@Nodes.ExpOp2Node {
         switch parentNode.$op.txt {
            case "and", "or" {
               return true;
            }
         }
      }
      return false;
   }

   let getEnvTxt = self.env.getEnv( node.isThreading() );
   let mut firstFlag = not isAndOr( parent );
   if firstFlag {
      self.writeln( "%s.PopVal( %s.IncStack() ||"  (getEnvTxt,getEnvTxt));
      self.pushIndent( ## );
   }

   let opCC;
   if opTxt == "and" {
      opCC = "&&";
   }
   else {
      opCC = "||";
   }
   
   if isAndOr( node.$exp1 ) {
      filter( node.$exp1, self, node );
   }
   else {
      self.write( "%s.SetStackVal( " (getEnvTxt));
      filter( node.$exp1, self, node );
      self.write( ") " );
   }
   self.writeln( opCC );
   if isAndOr( node.$exp2 ) {
      filter( node.$exp2, self, node );
   }
   else {
      self.write( "%s.SetStackVal( " (getEnvTxt));
      filter( node.$exp2, self, node );
      self.write( ") " );
   }

   if firstFlag {
      self.write( ")" );

      self.outputAny2Type( node.$expType );
      self.popIndent();
   }
}

let op2map = {
   "..": "+",
   "~=": "!=",
};


pub override fn convFilter.processExpOp2(
   node: &Nodes.ExpOp2Node, opt: Opt ) mut
{
   let mut opTxt = node.$op.txt;

   switch opTxt {
      case "and", "or" {
         self.processAndOr( node, opTxt, opt.parent );
      }
      case ".." {
         filter( node.$exp1, self, node );
         self.write( " + " );
         filter( node.$exp2, self, node );
      }
      default {
         if! Ast.bitBinOpMap[ opTxt ] {
            // ビット演算の処理
            switch _exp {
               case .LShift {
                  opTxt = "<<";
               }
               case .RShift {
                  opTxt = ">>";
               }
            }
            //self.accessPrimVal( node.$exp1, node );
            filter( node.$exp1, self, node );
            self.write( " " .. opTxt .. " " );
            //self.accessPrimVal( node.$exp2, node );
            filter( node.$exp2, self, node );
         }
         else {
            filter( node.$exp1, self, node );
            if! let op = op2map[ opTxt ] {
               self.write( " %s " (op) );
            } else {
               self.write( " %s " (opTxt) );
            }
            //self.accessPrimVal( node.$exp2, node );
            filter( node.$exp2, self, node );
         }
      }
   }
}

pub override fn convFilter.processExpRef(
   node: &Nodes.ExpRefNode, opt: Opt ) mut
{
   if node.$expType.$kind == .DDD {
      self.write( "ddd" );
   }
   else {
      if node.$symbolInfo.$convModuleParam {
         self.write( "%s_%d" (node.$symbolInfo.$name, node.$symbolInfo.$symbolId ) );
      }
      else {
         switch node.$symbolInfo.$kind {
            case .Var, .Arg {
               self.write( self.getSymbolSym( node.$symbolInfo ) );
            }
            case .Fun {
               if Ast.isBuiltin( node.$expType.$typeId ) {
                  let builtinFunc = TransUnit.getBuiltinFunc();
                  switch node.$expType {
                     case builtinFunc.lns_print {
                        self.write( "Lns_print" );
                     }
                     default {
                        Util.err( "%s: not support -- %s"
                                  (__func__, node.$symbolInfo.$name) );
                     }
                  }
               } else {
                  self.write( self.getSymbol( .Func( node.$expType ),
                                              node.$symbolInfo.$name ) );
               }
            }
            case .Typ {
               if node.$expType.$kind == .Module {
                  self.write( node.$symbolInfo.$name );
               } else {
                  self.write( self.getTypeSymbol( node.$expType ));
                  //self.write( self.type2gotypeOrg( node.$expType, false ) );
               }
            }
            default {
               self.write( node.$symbolInfo.$name );
            }
         }
      }
   }
}

pub override fn convFilter.processExpRefItem(
   node: &Nodes.ExpRefItemNode, opt: Opt ) mut
{
   let getEnvTxt = self.env.getEnv( node.isThreading());
   let prefixType = node.$val.$expType.$nonnilableType;
   switch prefixType.$kind {
      case .Ext {
         if node.$nilAccess {
            self.write( "%s.NilAccFin( %s.NilAccPush( " (getEnvTxt, getEnvTxt) );
            filter( node.$val, self, node );
            self.write( ") && " );
            self.write(
               "%s.NilAccPush( %s.NilAccPop().(*Lns_luaValue)"
               (getEnvTxt, getEnvTxt ) );
         } else {
            filter( node.$val, self, node );
            if prefixType.$extedType.$kind == .Stem {
               self.write( ".(*Lns_luaValue)" );
            }
         }
         self.write( ".GetAt(" );
         if! let index = node.$index {
            filter( index, self, node );
         } else {
            self.write( '"%s"' (str2gostr( unwrap node.$symbol)) );
         }
         self.write( ")" );
         self.outputStem2Type( node.$expType );
      }
      case .List, .Array {
         if node.$nilAccess {
            if not node.$val.hasNilAccess() {
               self.writeln( "%s.NilAccFin( %s.NilAccPush(" (getEnvTxt, getEnvTxt) );
               filter( node.$val, self, node );
               self.writeln( ") && " );
            } else {
               filter( node.$val, self, node );
               self.writeln( "&&" );
            }
            self.write( "%s.NilAccPush( %s.NilAccPop().(*LnsList)"
                        (getEnvTxt, getEnvTxt));
            self.write( ".GetAt(" );
            filter( unwrap node.$index, self, node );
            self.write( ")" );
            self.outputStem2Type( node.$expType );
            self.write( "))" );
         } else {
            filter( node.$val, self, node );
            self.write( ".GetAt(" );
            filter( unwrap node.$index, self, node );
            self.write( ")" );
            self.outputStem2Type( node.$expType );
         }
      }
      case .Map {
         if node.$nilAccess {
            if not node.$val.hasNilAccess() {
               self.writeln( "%s.NilAccFin( %s.NilAccPush(" (getEnvTxt,getEnvTxt));
               filter( node.$val, self, node );
               self.writeln( ") && " );
            } else {
               filter( node.$val, self, node );
               self.writeln( "&&" );
            }
            self.write( "%s.NilAccPush( %s.NilAccPop().(*LnsMap)" (getEnvTxt,getEnvTxt));
         } else {
            filter( node.$val, self, node );
            if prefixType.$kind == .Stem {
               self.write( ".(*LnsMap)" );
            }
         }
         self.write( ".Items[" );
         if! let index = node.$index {
            filter( index, self, node );
         } else {
            self.write( '"%s"' (str2gostr( unwrap node.$symbol)) );
         }
         self.write( "]" );
         self.outputStem2Type( node.$expType );
         if node.$nilAccess {
            self.write( "))" );
         }
      }
      case .Stem {
         self.write( "Lns_FromStemGetAt(" );
         filter( node.$val, self, node );
         self.write( "," );
         if! let index = node.$index {
            filter( index, self, node );
         } else {
            self.write( '"%s"' (str2gostr( unwrap node.$symbol)) );
         }
         self.write( ", %s )" (node.$nilAccess) );
         self.outputStem2Type( node.$expType );
      }
      default {
         if prefixType == Ast.builtinTypeString {
            self.write( "LnsInt(" );
            filter( node.$val, self, node );
            self.write( "[" );
            filter( unwrap node.$index, self, node );
            self.write( "-1])" );
            
         } else {
            Util.err( "%s: not support -- %d, %s"
                      (__func__, node.$pos.lineNo, prefixType.$kind.$_txt) );
         }
      }
   }
}

pub override fn convFilter.processRefField(
   node: &Nodes.RefFieldNode, opt: Opt ) mut
{
   if node.$prefix.$expType.$kind == .Enum and node.$expType.$kind == .Enum {
      self.write( self.getSymbol( .Static( node.$expType ), node.$field.txt ) );
      return;
   }
   if! let symbol = node.$symbolInfo {
      let orgSym = symbol.getOrg();
      let builtinFuncs = TransUnit.getBuiltinFunc();
      if builtinFuncs.$allSymbolSet.has( orgSym ) {
         self.write( "Lns_%s_%s" ( node.$prefix.$expType.$rawTxt.gsub( "@", "" ),
                                   orgSym.$name ) );                  
         return;
      }

      if symbol.$staticFlag {
         //self.outputModule( symbol.getModule(), true );
         self.write( self.getSymbolSym( symbol ) );
         return;
      }
   }

   let getEnvTxt = self.env.getEnv( node.isThreading() );

   let openParenNum;
   if not node.hasNilAccess() {
      openParenNum = 0;
      if not node.$prefix.hasNilAccess() {
         filter( node.$prefix, self, node );
      } else {
         Util.err( "%s: not support" ( __func__ ) );
      }
   } else {
      if not node.$prefix.hasNilAccess() {
         self.write( "%s.NilAccFin(" (getEnvTxt));
         self.write( "%s.NilAccPush(" (getEnvTxt));
         filter( node.$prefix, self, node );
         self.writeln( ") && " );
      } else {
         filter( node.$prefix, self, node );
         self.writeln( "&&" );
      }
      self.write( "%s.NilAccPush(" (getEnvTxt));
      if opt.parent.hasNilAccess() {
         openParenNum = 1;
      } else {
         openParenNum = 2;
      }
      self.write(
         "%s.NilAccPop().(%s)"
         (getEnvTxt, self.type2gotype( node.$prefix.$expType.$nonnilableType ) ));
   }

   
   self.write( "." );
   if! let symbol = node.$symbolInfo {
      if node.$prefix.$expType.$kind == .Ext {
         self.write( 'GetAt( "%s" )' (symbol.$name) );
         self.outputAny2Type( node.$expType );
      } else {
         self.write( self.getSymbolSym( symbol ) );
         let orgSym = symbol.getOrg();
         if orgSym.$kind == .Mbr and orgSym.$typeInfo.$kind == .Alternate and
            isAnyType( orgSym.$typeInfo )
         {
            self.outputAny2Type( node.$expType );
         }
      }
   } else {
      Util.err( "not support -- %s" (__func__) );
   }
  

   for _ = 1, openParenNum {
      self.write( ")" );
   }
}

pub override fn convFilter.processExpOmitEnum(
   node: &Nodes.ExpOmitEnumNode, opt: Opt ) mut
{
   self.write( self.getSymbol( .Static( node.$expType.$aliasSrc ), node.$valInfo.$name ) );
}

pub override fn convFilter.processGetField(
   node: &Nodes.GetFieldNode, opt: Opt ) mut
{
   if! let symbolInfo = node.$symbolInfo {
      if symbolInfo.$kind == .Mtd and symbolInfo.$name == "get__txt" {
         if! let enumType = symbolInfo.$namespaceTypeInfo@@@Ast.EnumTypeInfo {
            self.write( "%s( " (self.getEnumGetTxtSym( enumType ) ) );
            filter( node.$prefix, self, node );
            self.write( ")" );
            return;
         }
         if symbolInfo.$namespaceTypeInfo@@@Ast.AlgeTypeInfo {
            filter( node.$prefix, self, node );
            self.write( ".(LnsAlgeVal).GetTxt()" );
            return;
         }
      }

      if symbolInfo.$staticFlag {
         self.write( self.getSymbolSym( symbolInfo ) );
         self.write( "()" );
      } else {
         let closeParen = self.outputCallPrefix(
            node.isThreading(), node.$id, node, node.$prefix, symbolInfo );
         self.write( "()" );
         let retType = symbolInfo.$typeInfo.$retTypeInfoList[1];
         if retType.$kind == .Alternate and not retType.hasBase() {
            self.outputAny2Type( node.$expType );
         }
         
         
         if node.hasNilAccess() {
            self.write("})" );
            if opt.parent.hasNilAccess() {
               // self.writeln(" && // " );
            } else {
               self.write( ")" );
            }
         }
         if closeParen {
            self.write( ")" );
         }
      }
   } else {
      Util.err( "not support -- %s" (__func__) );
   }
}


pub override fn convFilter.processReturn(
   node: &Nodes.ReturnNode, opt: Opt ) mut
{
   self.write( "return " );
   if! let expList = node.$expList {
      filter( expList, self, node );
   }
   self.writeln( "" );
}

pub override fn convFilter.processTestCase( node: &Nodes.TestCaseNode, opt: Opt ) mut
{
   if not self.enableTest {
      return;
   }
   self.writeln(
      "func lns_test_%s_%s( %s *Testing_Ctrl ) {"
      ( self.getModuleName( self.$moduleTypeInfo, false),
        node.$name.txt, node.$ctrlName ) );

   filter( node.$block, self, node );
   
   self.writeln( "}" );
}

pub override fn convFilter.processTestBlock(
   node: &Nodes.TestBlockNode, opt: Opt ) mut
{
   let stmtList = node.$stmtList;
   foreach statement in stmtList {
      if not ignoreNodeInInnerBlockSet.has( statement.$kind ) {
         filter( statement, self, node );
      }
   }
};


pub override fn convFilter.processProvide(
   node: &Nodes.ProvideNode, opt: Opt ) mut
{
   Util.err( "not support -- %s" (__func__) );
}

pub override fn convFilter.processAlias(
   node: &Nodes.AliasNode, opt: Opt ) mut
{
}

pub override fn convFilter.processBoxing(
   node: &Nodes.BoxingNode, opt: Opt ) mut
{
   Util.err( "not support -- %s" (__func__) );
}

pub override fn convFilter.processUnboxing(
   node: &Nodes.UnboxingNode, opt: Opt ) mut
{
   Util.err( "not support -- %s" (__func__) );
}

pub override fn convFilter.processLiteralList(
   node: &Nodes.LiteralListNode, opt: Opt ) mut
{
   self.write( "NewLnsList(" );
   if! let expList = node.$expList {
      self.expList2Slice( expList, true );
   }
   else {
      self.write( "[]LnsAny{}" );
   }
   self.write( ")" );
}

pub override fn convFilter.processLiteralSet(
   node: &Nodes.LiteralSetNode, opt: Opt ) mut
{
   self.write( "NewLnsSet(" );
   if! let expList = node.$expList {
      self.expList2Slice( expList, true );
   }
   else {
      self.write( "[]LnsAny{}" );
   }
   self.write( ")" );
}


pub override fn convFilter.processLiteralMap(
   node: &Nodes.LiteralMapNode, opt: Opt ) mut
{
   let mut hasNilable = false;
   self.write( "NewLnsMap( map[LnsAny]LnsAny{" );
   foreach pair in node.$pairList {
      if pair.$key.$kind == Nodes.NodeKind.get_LiteralNil() or
         pair.$val.$kind == Nodes.NodeKind.get_LiteralNil()
      {
         // nil を除外
      } else {
         if pair.$key.$expType.$kind == .Nilable or pair.$val.$expType.$kind == .Nilable
         {
            // nilable の値を含む map は、後で nil の値を除外するため記録しておく
            hasNilable = true;
         }
         filter( pair.$key, self, node );
         self.write( ":" );
         filter( pair.$val, self, node );
         self.write( "," );
      }
   }
   self.write( "})" );
   if hasNilable {
      self.write( ".Correct()" );
   }
}

pub override fn convFilter.processLiteralArray(
   node: &Nodes.LiteralArrayNode, opt: Opt ) mut
{
   // list で代用する
   self.write( "NewLnsList(" );
   if! let expList = node.$expList {
      self.expList2Slice( expList, true );
   }
   else {
      self.write( "[]LnsAny{}" );
   }
   self.write( ")" );
}

pub override fn convFilter.processLiteralChar(
   node: &Nodes.LiteralCharNode, opt: Opt ) mut
{
   self.write( string.format( "%d", node.$num ) );
}

pub override fn convFilter.processLiteralInt(
   node: &Nodes.LiteralIntNode, opt: Opt ) mut
{
   self.write( node.$token.txt );
}

pub override fn convFilter.processLiteralReal(
   node: &Nodes.LiteralRealNode, opt: Opt ) mut
{
   self.write( node.$token.txt );
}

pub override fn convFilter.processLiteralString(
   node: &Nodes.LiteralStringNode, opt: Opt ) mut
{
   let txt = node.$token.txt;
   if! let expList = node.$dddParam {
      self.write( '%s.String_format(%s, '
                  (self.env.getLuavm( node.isThreading() ), str2gostr(txt)));
      self.processSetFromExpList(
         self.getConvExpName( node.$id, expList ),  [ Ast.builtinTypeDDD ], expList );
      self.write( ")" );
   } else {
      self.write( '%s' (str2gostr(txt)) );
   }
}

pub override fn convFilter.processLiteralBool(
   node: &Nodes.LiteralBoolNode, opt: Opt ) mut
{
   self.write( node.$token.txt );
}

pub override fn convFilter.processLiteralNil(
   node: &Nodes.LiteralNilNode, opt: Opt ) mut
{
   self.write( "nil" );
}

pub override fn convFilter.processBreak(
   node: &Nodes.BreakNode, opt: Opt ) mut
{
   self.write( "break" );
   self.writeln( "" );
}

pub override fn convFilter.processLiteralSymbol(
   node: &Nodes.LiteralSymbolNode, opt: Opt ) mut
{
   Util.err( "not support -- %s" (__func__) );
}

pub override fn convFilter.processLuneControl(
   node: &Nodes.LuneControlNode, opt: Opt ) mut
{
   _match node.$pragma {
      case .default__init {
      }
      case .default__init_old {
      }
      case .disable_mut_control {
      }
      case .ignore_symbol_ {
      }
      case .load__lune_module {
      }
      case .limit_conv_code( _ ) {
      }
      case .use_async {
      }
      case .run_async_pipe {
         //self.writeln( "go self.FP.Loop()" );
         self.writeln( "go self.LoopMain()" );
      }
   }
}

pub override fn convFilter.processAbbr(
   node: &Nodes.AbbrNode, opt: Opt ) mut
{
   Util.err(
      "not support -- %s:%d"
      (__func__, node.$pos.lineNo ) );
}

pub fn createFilter(
   enableTest:bool, streamName: str,
   stream: oStream, ast:TransUnit.ASTInfo, option:&Option ) : Nodes.Filter<Opt>
{
   return new convFilter( enableTest, streamName, stream, ast, option );
}

__test {
   import lune.base.convLua;

   fn Ast2Code( streamName:str, ast:TransUnit.ASTInfo ) : str
   {
      let mut stream = new Util.memStream();

      let mut conv = createFilter( false, streamName, stream, ast,
                                   new Option( "lns", "lnsgo", "" ) );

      ast.$node.processFilter( conv, new Opt( ast.$node ));

      return stream.$txt;
   }
}

__test case1(ctrl ) {
   import lune.base.Option;
   
   LuaVer.setCurVer( 53 );
   
   let scriptPath = "test.lns";
   let option = Option.createDefaultOption( [scriptPath], nil );
   let mut ast = convLua.createAst( scriptPath, convLua.getTestLnsCode(), option );
   let goCode = Ast2Code( scriptPath, ast);
   print( goCode );
}
