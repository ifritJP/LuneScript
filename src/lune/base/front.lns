import lune.base.frontInterface;
import lune.base.Parser;
import lune.base.convLua;
import lune.base.TransUnit;
import lune.base.Util;
import lune.base.Option;
import lune.base.dumpNode;

global fn _luneGetLocal( varName:str ):stem!
{
   let mut index = 1;
   while true {
      let name, val = debug.getlocal( 3, index );
      if name == varName {
	 return val;
      }     
      if not name {
	 break;
      }     
      //print( name, val )
      index = index + 1;
   }  
   error( "not found -- " .. varName );
}

global fn _luneSym2Str( val:stem! ):str! {
   if! val {
      if type( _exp ) ~= "table" {
         return string.format( "%s", _exp );
      }

      let mut txt = "";
      foreach item in _exp@@str[] {
         txt = txt .. item;
      }
      return txt;
   }
   return nil;
}

class Front extend (frontInterface.frontInterface) {
   let option:Option.Option;
   let mut loadedMap:Map<str,Map<str,stem>>;
   let mut loadedMetaMap:Map<str,stem>;
   let mut convertedMap:Map<str,str>;

   pub fn loadModule( mod:str ): stem, stem;
   pub fn loadMeta( mod:str ): stem;
   pub fn searchModule( mod:str ): str;
   pub fn error( message:str );
}

fn Front.error( message:str ) {
   Util.errorLog( message );
   Util.printStackTrace();
   os.exit( 1 );
}

fn Front.loadLua( path:str ):stem {
   let chunk, err = loadfile( path );
   if! err {
      Util.errorLog( _exp );
   }
   if! chunk {
      return _exp();
   }
   error( "failed to error" );
}

fn createPaser( path:str, mod:str ): Parser.Parser
{
   let parser = Parser.StreamParser.create( path, false, mod );
   if! parser {
      return _exp;
   }
   error( "failed to open " .. path );
}

fn Front.createAst( path:str, mod:str, analyzeModule:str!,
                    analyzeMode:str!, pos:&Parser.Position! ): &TransUnit.ASTInfo
{
   let mut transUnit = new TransUnit.TransUnit(
      new convLua.MacroEvalImp( self.option.mode ), analyzeModule, analyzeMode, pos );
   return transUnit.createAST( createPaser( path, mod ), false, mod );
}

fn convert(
   ast:&TransUnit.ASTInfo, streamName:str,
   mut stream:oStream, mut metaStream:oStream, convMode:str, inMacro:bool )  
{
   let mut conv = new convLua.convFilter(
      streamName, stream, metaStream, convMode, inMacro, ast.$moduleTypeInfo );
   ast.$node.processFilter( conv, nil, 0 );
}

fn loadFromTxt( txt:str ): stem {
   //--print( txt )
   let chunk, err = load( txt );
   if! err {
      print( _exp );
   }     
   if! chunk {
      return _exp();
   }
   error( "failed to error" );
}


fn Front.loadFile( path:str, mod:str, onlyMeta:bool ): stem, stem
{
   let ast = self.createAst( path, mod, mod );
   
   let mut stream = new Util.memStream();
   let mut metaStream = new Util.memStream();

   convert( ast, path, stream, metaStream, "exe", false );
   
   let mut meta = loadFromTxt( metaStream.$txt );
   if onlyMeta {
      return meta, stream.$txt;
   }
   return meta, loadFromTxt( stream.$txt );
}

fn Front.searchModule( mod:str ): str! {
   let mut lnsSearchPath = package.path;
   lnsSearchPath = string.gsub( lnsSearchPath, "%.lua", ".lns" );
   return package.searchpath( mod, lnsSearchPath );
}
      
fn Front.loadModule( mod:str ) mut : stem!, stem {
   if self.loadedMap[ mod ] == nil {
      if! self.convertedMap[ mod ] {
         if not self.loadedMetaMap[ mod ] {
            error( "nothing meta -- %s" ( mod ) );
         }

	 let mut info:Map<str,stem> = {};
	 info.mod = loadFromTxt( _exp );
	 info.meta = self.loadedMetaMap[ mod ];

	 self.loadedMap[ mod ] = info;
      }
      else {
         if! let lnsPath = self.searchModule( mod ) {
            let mut luaPath:str! = string.gsub( lnsPath, "%.lns$", ".lua" );
            let mut luaSearchPath = package.path;
            let bakSearchPath = package.path;

            if! self.option.outputDir {
	       luaSearchPath = string.format( "%s/?.lua;%s", _exp, package.path );
	       luaPath = package.searchpath( mod, luaSearchPath );
	       package.path = luaSearchPath;
            }     

            let mut loadVal:stem! = nil;
            if! luaPath {
               if Util.getReadyCode( lnsPath, _exp ) {
	          let metaPath = string.gsub( _exp, "%.lua$", ".meta" );
	          if Util.getReadyCode( lnsPath, metaPath ) {
	             loadVal = self.loadLua( _exp );
	             let meta = self.loadLua( metaPath );

	             let mut info:Map<str,stem> = {};
	             info.mod = loadVal;
	             info.meta = meta;
	             self.loadedMap[ mod ] = info;
                  }           
               }  
            }  
            if self.option.outputDir {
	       package.path = bakSearchPath;
            }  
            if loadVal == nil {
	       let meta, workVal = self.loadFile( lnsPath, mod, false );
	       let mut info:Map<str,stem> = {};
	       info.mod = workVal;
	       info.meta = meta;

	       self.loadedMap[ mod ] = info;
            }  
         }
      }
   }
   if! self.loadedMap[ mod ] {
      return unwrap _exp.mod, unwrap _exp.meta;
   }
   error( "load error, %s" ( mod ) );
}


fn Front.loadMeta( mod:str ) mut : stem {
   if self.loadedMetaMap[ mod ] == nil {
      if! self.loadedMap[ mod ] {
         self.loadedMetaMap[ mod ] = _exp.meta;
      }
      else {
         if! let lnsPath = self.searchModule( mod ) {
            let mut luaPath:str! = string.gsub( lnsPath, "%.lns$", ".lua" );
            let mut luaSearchPath = package.path;
            let bakSearchPath = package.path;

            if! self.option.outputDir {
	       luaSearchPath = string.format( "%s/?.lua;%s", _exp, package.path );
	       luaPath = package.searchpath( mod, luaSearchPath );
	       package.path = luaSearchPath;
            }  

            let mut meta:stem! = nil;
            if! luaPath {
               if Util.getReadyCode( lnsPath, _exp ) {
	          let metaPath = string.gsub( _exp, "%.lua$", ".meta" );
	          if Util.getReadyCode( lnsPath, metaPath ) {
	             meta = self.loadLua( metaPath );
	             self.loadedMetaMap[ mod ] = meta;
                  }  
               }  
            }  
            if self.option.outputDir {
	       package.path = bakSearchPath;
            }  
            if meta == nil {
	       let metawork, luaTxt = self.loadFile( lnsPath, mod, true );
               meta = metawork;
	       self.loadedMetaMap[ mod ] = metawork;
               self.convertedMap[ mod ] = luaTxt@@str;
            }  
         }
      }
   }
   if! self.loadedMetaMap[ mod ] {
      return unwrap _exp;
   }
   error( "load error, %s" ( mod ) );
}


pub fn Front.exec() mut
{
   let mut mod = string.gsub( self.option.scriptPath, "/", "." );
   mod = string.gsub( mod, "%.lns$", "" );
   
   switch self.option.mode {
      case "token" {
         let mut parser = createPaser( self.option.scriptPath, mod );
         while true {
            let! token = parser.getToken() {
               break;
            };
            print( token.kind, token.pos.lineNo, token.pos.column, token.txt );
         }
      }
      case "ast" {
         Util.profile(
	    self.option.validProf,
	    fn() {
	       let ast = self.createAst( self.option.scriptPath, mod );
	       ast.$node.processFilter( new dumpNode.dumpFilter(), "", 0 );
	    }, self.option.scriptPath .. ".profi" );
      }
      case "diag" {
         Util.setErrorCode( 0 );
         self.createAst( self.option.scriptPath, mod, nil, "diag" );
      }
      case "comp" {
         self.createAst( self.option.scriptPath, mod,
		         self.option.analyzeModule, "comp", self.option.analyzePos );
      }
      case "lua", "LUA" {
         let ast = self.createAst( self.option.scriptPath, mod );
         convert( ast, self.option.scriptPath,
                  io.stdout, io.stdout, self.option.mode, false );
      }
      case "save", "SAVE" {
         Util.profile(           
	    self.option.validProf,       
      	    fn () {
	       let ast = self.createAst( self.option.scriptPath, mod );
	       let mut luaPath = self.option.scriptPath.gsub( "%.lns$", ".lua" );
	       let mut metaPath = self.option.scriptPath.gsub( "%.lns$", ".meta" );
	       if self.option.outputDir {
	          let filename = mod.gsub( "%.", "/" );
	          luaPath = string.format(
                     "%s/%s.lua", self.option.outputDir, filename );
	          metaPath = string.format(
                     "%s/%s.meta", self.option.outputDir, filename );          
	       }
	       
	       if luaPath ~= self.option.scriptPath {
	          let! mut fileObj = io.open( luaPath, "w" ) {
                     error( "write open error -- %s" (luaPath) );
                  };
	          let mut stream = fileObj;

	          let mut metaFileObj:oStream! = nil;
	          let mut metaStream:oStream = stream;
	          if self.option.mode == "SAVE" {
                     if! io.open( metaPath, "w" ) {
		        metaStream = _exp;
                     }
                     else {
                        error( "write open error -- %s" (metaPath) );
                     }
                  }
	             
	          convert( ast, self.option.scriptPath,
                           stream, metaStream, self.option.mode, false );
	          fileObj.close();
	          if! metaFileObj {     
		     _exp.close();
	          }
               }
      	    }, self.option.scriptPath .. ".profi" );
      }
      case "exe" {
         self.loadModule( mod );
      }
      default {
         print( "illegal mode" );
      }        
   }
   
}

pub fn exec( args: str[] ) {
   let version = tonumber( _VERSION.gsub( "^[^%d]+", "" ), nil );

   if version < 5.2 {
      io.stderr.write(
         string.format( "LuneScript doesn't support this lua version(%s). %s\n",
		        version, "please use the version after 5.2.") );
      os.exit( 1 );
   }  
   
   let mut option = Option.analyze( args );
   let mut front = new Front( option, {}, {}, {} );
   frontInterface.setFront( front );

   front.exec();
}
