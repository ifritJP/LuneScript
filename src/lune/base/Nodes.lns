/*
MIT License

Copyright (c) 2019 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Parser;
import lune.base.Util;
import lune.base.frontInterface;
import lune.base.Ast;
import lune.base.LuneControl;

class SimpleModuleInfoManager extend (Ast.ModuleInfoManager)
{
   pro let mut moduleInfoManager:&Ast.ModuleInfoManager;
   pri let mut moduleInfoManagerHist:List<&Ast.ModuleInfoManager>;
   
   pub fn __init(moduleInfoManager:&Ast.ModuleInfoManager!) {
      when! moduleInfoManager {
         self.moduleInfoManager = moduleInfoManager;
      }
      else {
         self.moduleInfoManager = Ast.DummyModuleInfoManager.$instance;
      }
      self.moduleInfoManagerHist = [];
   }

   pub fn push( moduleInfoManager:&Ast.ModuleInfoManager ) mut {
      self.moduleInfoManagerHist.insert( self.moduleInfoManager );
      self.moduleInfoManager = moduleInfoManager;
   }

   pub fn pop() mut {
      self.moduleInfoManager = self.moduleInfoManagerHist[ #self.moduleInfoManagerHist ];
      self.moduleInfoManagerHist.remove(##);
   }
   
   advertise moduleInfoManager;
}

pub class Filter<T>  {
   pri let mut moduleInfoManager:SimpleModuleInfoManager;
   pri let typeNameCtrl:&Ast.TypeNameCtrl {pub};

   pro fn __init( moduleTypeInfo:&Ast.TypeInfo!,
                  moduleInfoManager:&Ast.ModuleInfoManager! )
   {
      self.moduleInfoManager = new SimpleModuleInfoManager( moduleInfoManager );
      fn process ():&Ast.TypeNameCtrl {
         when! moduleTypeInfo {
            return new Ast.TypeNameCtrl( moduleTypeInfo );
         }
         return Ast.defaultTypeNameCtrl;
      };
      self.typeNameCtrl = process();
   }

   pro fn get_moduleInfoManager() : &Ast.ModuleInfoManager {
      return self.moduleInfoManager;
   }
}

/**
制御中断要因。
Node を実行した際に、次の Node に処理が中断せずに遷移するかどうか。

優先度の高い順に宣言する。
*/
pub enum BreakKind {
   /** 遷移する */
   None,
   /** break で中断する */
   Break,
   /** return で中断する */
   Return,
   /** 処理は戻らない */
   NeverRet,
}

pub enum CheckBreakMode {
   /** フローを解析する */
   Normal,
   /** フローを解析する (return 有無の解析)  */
   Return,
   /** フローを解析しない */
   IgnoreFlow,
   /** フローを解析しない (return 有無の解析) */
   IgnoreFlowReturn,
}


pub alge Literal {
   Nil,
   Int( val:int ),
   Real( val:real ),
   Str( val:str ),
   Bool( val:bool ),
   Symbol( val:str ),
   Field( val:&List<str> ),
   LIST( val:&List<&Literal> ),
   ARRAY( val:&List<&Literal> ),
   SET( val:&List<&Literal> ),
   MAP( val:&Map<&Literal,&Literal> ),
}

pub fn getLiteralObj( obj:&Literal ):stem! {
   match obj {
      case .Nil {
         return nil;
      }     
      case .Int( val ) {
         return val;
      }     
      case .Real( val ) {
         return val;
      }     
      case .Str( val ) {
         return val;
      }     
      case .Bool( val ) {
         return val;
      }     
      case .Symbol( val ) {
         return val;
      }
      case .Field( val ) {
         return val;
      }
      case .LIST( val ) {
         return val;
      }     
      case .ARRAY( val ) {
         return val;
      }     
      case .SET( val ) {
         return val;
      }     
      case .MAP( val ) {
         return val;
      }
   }
   Util.errorLog( "unknown literal obj -- " .. obj.$_txt );
   return nil;
}

pub proto abstract class Node;

pub enum NodeVisitMode {
   /** 子ノードがある場合、子ノードに visit する */
   Child,
   /** 子ノードがあっても無視し、同じ階層のノードに visit する */
   Next,
   /** 以降、ノードへの visit は行なわない */
   End,
}

/**
ノードを辿る際のコールバック関数

@param node 現在のノード
@param parent 親ノード
@param releation 親ノードのフィールド名
*/
pub form NodeVisitor( node:&Node, parent:&Node, relation:str, depth:int ): NodeVisitMode;

pub abstract class Node {
   pri let id: int { pub };
   pri let kind: int { pub };
   pri let pos: &Parser.Position { pub };
   pri let expTypeList: &List<&Ast.TypeInfo> { pub };
   let mut commentList: List<&Parser.Token>! { pub& };
   let mut tailComment: &Parser.Token! { pub&,pub };

   pub fn __init( id: int, kind: int,
                  pos: &Parser.Position, expTypeList: &List<&Ast.TypeInfo> )
   {
      self.id = id;
      self.kind = kind;
      self.pos = pos;
      self.expTypeList = expTypeList;
      self.commentList = nil;
      self.tailComment = nil;
   }

   pub fn addComment( commentList: &List<&Parser.Token> ) mut {
      if #commentList ~= 0 {
         let mut workList;
         if! self.commentList {
            workList = _exp;
         }
         else {
            workList = [];
            self.commentList = workList;
         }
         foreach comment in commentList {
            workList.insert( comment );
         }
      }
   }
   
   pub fn get_expType(): &Ast.TypeInfo {
      if #self.expTypeList == 0 {
         return Ast.builtinTypeNone;
      }
      return self.expTypeList[ 1 ];
   }; 

   pro fn addTokenList( list:List<&Parser.Token>, kind:Parser.TokenKind, txt:str ) {
      list.insert( new Parser.Token( kind, txt, self.pos, false ## ) );
   }
   
   pub fn setupLiteralTokenList( list: List<&Parser.Token> ): bool {
      return false;
   }
   
   pub fn getLiteral(): Literal!, str! {
      return nil, nil;
   }
   pub fn processFilter<OPT>( filter: Filter<OPT>, opt:OPT ) {
   }
   /** 代入式の左辺になれるかどうか */
   pub fn canBeLeft(): bool {
      return false;
   };     
   /** 代入式の右辺になれるかどうか */
   pub fn canBeRight(): bool {
      return false;
   }
   /** 単体で文になれるかどうか */
   pub fn canBeStatement(): bool {
      return false;
   }
   /**
制御の中断種別を得る。

全てのケースで return で終っている場合や、 error() などをコールしている場合など。

@param checkMode モード
*/
   pub fn getBreakKind( checkMode:CheckBreakMode ): BreakKind {
      return .None;
   }

   pub fn getSymbolInfo(): &List<&Ast.AccessSymbolInfo>;
   

   pub abstract fn visit( visitor:NodeVisitor, depth:int ): bool;
}



pub class NamespaceInfo {
   pub let name: str;
   pub let scope: Ast.Scope;
   pub let typeInfo: &Ast.TypeInfo;
}


pub proto abstract class MacroEval;
pub proto class ExpListNode extend Node;
pub proto class DeclArgNode extend Node;
pub proto class BlockNode extend Node;

pub class DeclMacroInfo {
   pri let pubFlag: bool {pub};
   pri let name: &Parser.Token { pub };
   pri let argList: List<&DeclArgNode> { pub };
   /** macro-statment の BlockNode */
   pri let stmtBlock: &BlockNode! { pub };
   /** expand-statemnt の token リスト */
   pri let tokenList: List<&Parser.Token> { pub };
}

let mut nodeKind2NameMap: Map<int,str> = {};
let mut nodeKindSeed = 1;
pub let mut nodeKind: Map<str,int> = {};

fn regKind( name:str ): int {
   let kind = nodeKindSeed;
   nodeKindSeed = nodeKindSeed + 1;
   nodeKind2NameMap[ kind ] = name;
   nodeKind[ name ] = kind;
   return kind;
}

pub fn getNodeKindName( kind: int ): str {
   return unwrap nodeKind2NameMap[ kind ];
}

// let nodeKindNone = regKind( 'None' );
// let nodeKindImport = regKind( 'Import' );
// let nodeKindRoot = regKind( 'Root' );
// let nodeKindRefType = regKind( 'RefType' );
// let nodeKindIf = regKind( 'If' );
// let nodeKindSwitch = regKind( 'Switch' );
// let nodeKindWhile = regKind( 'While' );
// let nodeKindRepeat = regKind( 'Repeat' );
// let nodeKindFor = regKind( 'For' );
// let nodeKindApply = regKind( 'Apply' );
// let nodeKindForeach = regKind( 'Foreach' );
// let nodeKindForsort = regKind( 'Forsort' );
// let nodeKindReturn = regKind( 'Return' );
// let nodeKindBreak = regKind( 'Break' );
// let nodeKindExpNew = regKind( 'ExpNew' );
// let nodeKindExpList = regKind( 'ExpList' );
// let nodeKindExpRef = regKind( 'ExpRef' );
// let nodeKindExpOp2 = regKind( 'ExpOp2' );
// let nodeKindExpCast = regKind( 'ExpCast' );
// let nodeKindExpOp1 = regKind( 'ExpOp1' );
// let nodeKindExpRefItem = regKind( 'ExpRefItem' );
// let nodeKindExpCall = regKind( 'ExpCall' );
// let nodeKindExpCallSuper = regKind( 'ExpCallSuper' );
// let nodeKindExpDDD = regKind( 'ExpDDD' );
// let nodeKindExpParen = regKind( 'ExpParen' );
// let nodeKindExpMacroExp = regKind( 'ExpMacroExp' ); // macro expand
// let nodeKindExpMacroStat = regKind( 'ExpMacroStat' ); // `{}
// let nodeKindBlock = regKind( 'Block' );
// let nodeKindStmtExp = regKind( 'StmtExp' );
// let nodeKindRefField = regKind( 'RefField' );
// let nodeKindDeclVar = regKind( 'DeclVar' );
// let nodeKindDeclFunc = regKind( 'DeclFunc' );
// let nodeKindDeclMethod = regKind( 'DeclMethod' );
// let nodeKindDeclConstr = regKind( 'DeclConstr' );
// let nodeKindDeclMember = regKind( 'DeclMember' );
// let nodeKindDeclArg = regKind( 'DeclArg' );
// let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
// let nodeKindDeclClass = regKind( 'DeclClass' );
// let nodeKindDeclMacro = regKind( 'DeclMacro' );
// let nodeKindLiteralNil = regKind( 'LiteralNil' );
// let nodeKindLiteralChar = regKind( 'LiteralChar' );
// let nodeKindLiteralInt = regKind( 'LiteralInt' );
// let nodeKindLiteralReal = regKind( 'LiteralReal' );
// let nodeKindLiteralArray = regKind( 'LiteralArray' );
// let nodeKindLiteralList = regKind( 'LiteralList' );
// let nodeKindLiteralMap = regKind( 'LiteralMap' );
// let nodeKindLiteralString = regKind( 'LiteralString' );
// let nodeKindLiteralBool = regKind( 'LiteralBool' );
// let nodeKindLiteralSymbol = regKind( 'LiteralSymbol' );

pub class NodeManager {
   let mut nodeKind2NodeList:Map<int,List<&Node>>;
   let mut idSeed:int;

   pub fn __init() {
      self.idSeed = 0;
      self.nodeKind2NodeList = {};
      foreach kind in nodeKind {
         if not self.nodeKind2NodeList[ kind ] {
            self.nodeKind2NodeList[ kind ] = [];
         }
      }
   }

   pub fn nextId() mut : int {
      self.idSeed = self.idSeed + 1;
      return self.idSeed;
   }

   pub fn getList(kind:int) : &List<&Node> {
      let! list = self.nodeKind2NodeList[ kind ] {
         return [];
      };
      return list;
   }
   pub fn addNode(node:&Node) mut {
      let! mut list = self.nodeKind2NodeList[ node.$kind ] {
         list = [];
         self.nodeKind2NodeList[ node.$kind ] = list;
      };
      list.insert( node );
   }
   pub fn delNode(node:&Node) mut {
      let! mut list = self.nodeKind2NodeList[ node.$kind ] {
         return;
      };
      let mut findIndex = -1;
      foreach item, index in list {
         if item == node {
            findIndex = index;
            break;
         }
      }
      if findIndex ~= -1 {
         list.remove( findIndex );
      }
   }
}

pub class NodeKind {
}


/**
Node を定義するマクロ。

@param baseName Node の名称。 実際には "%sNode" (baseName) になる。
@param super 親クラス
@param canBeLeftFlag canBeLeft() の戻り値。
   nil を指定すると、別途 canBeLeft() を定義する必要がある。
@param canBeRightFlag canBeRight() の戻り値。   
   nil を指定すると、別途 canBeRight() を定義する必要がある。
@param canBeStatementFlag canBeStatement() の戻り値。
   nil を指定すると、別途 canBeStatement() を定義する必要がある。
@param fieldInfoList 定義する Node のフィールドのリスト。
   key: フィールド名。 val: フィールドの型名  の Map のリスト。
   フィールドの順番を保証するために、 Map のリストとしている。
   フィールドの順番が、コンストラクタの順番になるため。
   フィールドの型名に Node を含むものは、
   子ノードのフィールドとして visit() で辿る対象とする。
   ただし、フィールド名の先頭に @ があるものは、除外する。
*/
macro _declNodeClass(
   baseName:str, super:sym, canBeLeftFlag:bool!, canBeRightFlag:bool!,
   canBeStatementFlag:bool!, fieldInfoList:Map<str,str>[] )
{
   {
      let className = ,,,"%sNode" (baseName);
      let nodeKindSym = ,,,"%s" (baseName);
      let nodeKindGetter = ,,,"get_%s" (baseName);

      let mut fieldStatList:stat[] = [];
      let mut argList:stat[] = [];
      let mut argSymList:stat[] = [];
      let mut initStatList:stat[] = [];
      let mut relateStat:stat[] = [];

      let mut visitStatList:List<stat> = [];
      
      foreach fieldInfo in fieldInfoList {
         foreach typeName, workName in fieldInfo {
            let fieldName = workName.gsub( "^@", "" );
            fieldStatList.insert( `{
               pri let mut ,,,fieldName : ,,,typeName { pub };
            });  
            argList.insert( `{ ,,,fieldName: ,,,typeName, } );
            argSymList.insert( `{, ,,,fieldName } );
            initStatList.insert( `{ self.,,,fieldName = ,,,fieldName; } );

            // 子 Node を列挙する処理
            if typeName.find( "Node" ## ) and not workName.find( "^@"## ) {
               let oneVisitStat = `{
                  switch visitor( child, self, ,,fieldName, depth ) {
                     case NodeVisitMode.Child {
                        if not child.visit( visitor, depth + 1 ) {
                           return false;
                        }
                     }
                     case NodeVisitMode.End {
                        return false;
                     }
                  }
               };

               fn processNilable( varName:str, statVar:stat ) {
                  if typeName.find( "!$" ## ) {
                     visitStatList.insert( `{
                        {
                           if! let ,,,varName = self.,,,fieldName {
                              ,,statVar;
                           }
                        }
                     });
                  }
                  else {
                     visitStatList.insert( `{
                        {
                           let ,,,varName = self.,,,fieldName;
                           ,,statVar;
                        }
                     } );
                  }
               }
               
               if typeName.find( "List<" ## ) {
                  let workStat = `{
                     foreach child in list {
                        ,,oneVisitStat;
                     }
                  };
                  processNilable( "list", workStat );
               }
               elseif typeName.find( "Map<" ## ) {
                  let workStat = `{
                     foreach val, key in map {
                        {
                           let child = key;
                           ,,oneVisitStat;
                        }
                        {
                           let child = val;
                           ,,oneVisitStat;
                        }
                     }
                  };
                  processNilable( "map", workStat );
                  
               }
               else {
                  processNilable( "child", oneVisitStat );
               }
            }
         }
      }

      fieldStatList.insert( `{
         pub override fn processFilter<OPT>( filter: Filter<OPT>, opt:OPT ) {
            filter.,,,"process%s" (baseName) (self, opt );
         } } );

      if! canBeRightFlag {
         fieldStatList.insert( `{
            pub override fn canBeRight():bool {
               return ,,, canBeRightFlag;
            } } );
      }
      if! canBeLeftFlag {
         fieldStatList.insert( `{
            pub override fn canBeLeft():bool {
               return ,,, canBeLeftFlag;
            } } );
      }
      if! canBeStatementFlag {
         fieldStatList.insert( `{
            pub override fn canBeStatement():bool {
               return ,,, canBeStatementFlag;
            } } );
      }
      
      let superStat = `{
         super( id, unwrap nodeKind. ,,nodeKindSym, pos, typeList );
      };

      if baseName ~= "Block" {
         relateStat.insert( `{
            pub fn Filter. ,,,"process%s" (baseName) ( node: &,,className, opt:T ) mut {
            };
         } );
      }
      else {
         relateStat.insert( `{
            pub fn Filter. ,,,"process%s" (baseName) ( node: &,,className, opt:T ) mut;
         } );
      }
      
      relateStat.insert( `{
         pub fn NodeManager. ,,,"get%sList" (,,,,className) () : &List<&,,className> {
            return self.getList( unwrap nodeKind. ,,nodeKindSym )@@List<&,,className>;
         }
      } );

      
   }

   pub static fn NodeKind.,,nodeKindGetter (): int {
      return unwrap nodeKind. ,,nodeKindSym;
   }
   
   pub proto class ,,className extend ,,super;
   regKind( ,,baseName );
   ,,relateStat;
   pub class ,,className extend ,,super {
      ,,fieldStatList;
      pro fn __init( id:int, pos: &Parser.Position, typeList: &List<&Ast.TypeInfo>, ,,argList ) {
         ,,superStat;
         ,,initStatList;
      }
      pub static fn create( nodeMan:NodeManager, pos: &Parser.Position,
                            typeList: &List<&Ast.TypeInfo>, ,,argList ) : ,,className
      {
         let mut node = new ,,className( nodeMan.nextId(), pos, typeList ,,argSymList );
         nodeMan.addNode( node );
         return node;
      }

      pub override fn visit( visitor:NodeVisitor, depth:int ): bool {
         ,,visitStatList;
         return true;
      }
   }
}

_declNodeClass( "None", Node, false, false, true, []);
_declNodeClass( "BlankLine", Node, false, false, true,
                [ { "lineNum": "int" } ]
);
_declNodeClass( "Subfile", Node, false, false, true,
                [ { "usePath": "str!" } ]);
_declNodeClass( "Import", Node, false, false, true,
                [ { "modulePath": "str" },
                  { "assignName": "str" },
                  { "symbolInfo": "&Ast.SymbolInfo" },
                  { "moduleTypeInfo": "&Ast.TypeInfo" } ]
);


pub proto class ProvideNode extend Node;

pub class LuneHelperInfo {
   pub let mut useNilAccess:bool;
   pub let mut useUnwrapExp:bool;
   pub let mut hasMappingClassDef:bool;
   pub let mut useLoad:bool;
   pub let mut useUnpack:bool;
   pub let mut useAlge:bool;
   pub let mut useSet:bool;
   pub let mut callAnonymous:bool;
}

pub class ModuleInfo extend (Ast.ModuleInfoIF) {
   pri let fullName:str{ pub };
   pri let localTypeInfo2importIdMap:Map<&Ast.TypeInfo,int> { pub };
   pri let mut importId2localTypeInfoMap:Map<int,&Ast.TypeInfo> { pub& };
   pri let assignName:str{ pub };
   pri let moduleId:&frontInterface.ModuleId {pub};

   pub fn __init( fullName:str, assignName:str, idMap:&Map<&Ast.TypeInfo,int>,
                  moduleId:&frontInterface.ModuleId )
   {
      self.moduleId = moduleId;
      self.fullName = fullName;
      self.assignName = assignName;
      self.localTypeInfo2importIdMap = idMap;
      self.importId2localTypeInfoMap = {};
      foreach importId, typeInfo in idMap {
         self.importId2localTypeInfoMap[ importId ] = typeInfo;
      }
   }

   pub fn get_modulePath(): str {
      return self.fullName;
   }

   pub fn assign( assignName: str ): ModuleInfo {
      return new ModuleInfo(
         self.fullName, assignName, self.localTypeInfo2importIdMap, self.moduleId );
   }
}

// pub fn TypeInfo.getFullName( importInfo:&Map<&Ast.TypeInfo,&Ast.ModuleInfoIF>, localFlag:bool! ) : str {
//    return self.getParentFullName( importInfo, localFlag ) .. self.$rawTxt;
// }


// pub class ProcessInfo {
//    let mut idProvier:Ast.IdProvider {pub};
//    let mut idProvierExt:Ast.IdProvider {pub};
//    let mut typeInfo2ModifierMap:Map<&Ast.TypeInfo,&Ast.TypeInfo> {pub};
//    let mut typeInfo2BoxMap:Map<&Ast.TypeInfo,&Ast.TypeInfo> {pub};
//    let mut typeInfo2DDDMap:Map<&Ast.TypeInfo,&Ast.DDDTypeInfo> {pub};
// }


/**
マクロの expand-statement で使用する変数情報。

マクロの引数か、 macro-statment で宣言した変数。
*/
pub class MacroValInfo {
   /**
変数に格納された値。

この値には、プリミティブな値(int/real/str/bool)か、プリティブな値のリストが格納される。

なお、 型の builtinTypeStat の変数には、 List<str> が格納される。

つまり次の場合、

---
let work:stat = `{ 1 + 1; };
let workList:List<stat> = [ stat ];
---

ここで work に対応する MacroValInfo.val には List<str> のデータが格納され、
ここで workList に対応する MacroValInfo.val には List<List<str>> のデータが格納される。

   */
   pub let val: stem!;
   /** マクロ内での変数の型 */
   pub let typeInfo: Ast.TypeInfo;
   /** 実引数のノード。 この変数がマクロの引数の場合に有効。 */
   pub let argNode: &Node!;
}

pub class MacroArgInfo {
   pri let name:str {pub};
   pri let typeInfo: &Ast.TypeInfo {pub};
}

/**
macro-statment に定義した処理を表わす関数。

@param macro-statment 処理に渡す引数を格納したマップ。
       マクロの変数名 → 値。
@return - macro-statment 処理で定義した macro-expand に渡す変数を格納したマップ
       マクロの変数名 → 値。
       macro-expand に渡す変数名 → 値。
*/
pub form macroStatmentProc( macroArg:&Map<str,&stem> ): &Map<str,&stem>;

pub abstract class MacroInfo {
   pub let func: macroStatmentProc;
   pub let symbol2MacroValInfoMap: Map<str,MacroValInfo>;
   pub abstract fn getArgList():&List<&MacroArgInfo>;
   pub abstract fn getTokenList():&List<&Parser.Token>;
   pub abstract fn get_name():str;
}

_declNodeClass( "Root", Node, false, false, false,
                [ { "children": "&List<&Node>" },
                  { "moduleScope": "&Ast.Scope" },
                  { "useModuleMacroSet": "&Set<&Ast.TypeInfo>" },
                  { "moduleId": "&frontInterface.ModuleId" },
                  { "processInfo": "Ast.ProcessInfo" },
                  { "moduleTypeInfo": "&Ast.TypeInfo" },
                  { "provideNode": "&ProvideNode!" },
                  { "luneHelperInfo": "&LuneHelperInfo" },
                  { "@nodeManager": "&NodeManager" },
                  { "importModule2moduleInfo": "&Map<&Ast.TypeInfo,&ModuleInfo>" },
                  { "typeId2MacroInfo": "&Map<int,&MacroInfo>" },
                  { "typeId2ClassMap": "&Map<int,&NamespaceInfo>" } ]
);

pub fn RootNode.set_provide( node: ProvideNode ) mut {
   self.provideNode = node;
}

_declNodeClass( "RefType", Node, false, false, false,
                [ { "name": "&Node" },
                  { "refFlag": "bool" },
                  { "mutFlag": "bool" },
                  { "array": "str" } ]
);

pub enum BlockKind {
   If,
   Elseif,
   Else,
   While,
   Switch,
   Match,
   Repeat,
   For,
   Apply,
   Foreach,
   Macro,
   Func,
   Default,
   Block,
   Macro,
   LetUnwrap,
   IfUnwrap,
   When,
   Test,
}

_declNodeClass( "Block", Node, false, false, true,
                [ { "blockKind": "BlockKind" },
                  { "scope": "&Ast.Scope" },
                  { "stmtList": "List<&Node>" } ]
);


macro _setBreakKind(work:sym, kind:sym, returnNoneStat:bool, checkMode:sym ) {
   {
      let mut noneStat:stat[] = [];
      if returnNoneStat {
         noneStat.insert( `{ return .None } );
      }
   }

   if ,,checkMode == .IgnoreFlowReturn {
      if ,, work == .Return {
         return .Return;
      }
      if ,, work == .NeverRet {
         return .NeverRet;
      }
   }
   else {
      switch ,,work {
         case .None {
            if ,,checkMode == .Normal or ,,checkMode == .Return {
               ,,noneStat;
            }
         }
         default {
            if ,,kind == .None or ,,kind > work {
               kind = work;               
            }
         }
      }
   }
}


pub override fn BlockNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in self.stmtList {
         let work = stmt.getBreakKind( checkMode );
         _setBreakKind(work, kind, false, checkMode );
      }
      return kind;
   }
   else {
      if #self.stmtList > 0 {
         let node = self.stmtList[ #self.stmtList ];
         return node.getBreakKind( checkMode );
      }
   }
   return .None;
}

pub enum IfKind {
   If,
   ElseIf,
   Else,
}

pub class IfStmtInfo {
   pri let kind: IfKind { pub };
   pri let exp: Node { pub };
   pri let block: BlockNode { pub };
}
_declNodeClass( "If", Node, false, false, true,
                [{ "stmtList": "List<&IfStmtInfo>" } ]
);


pub override fn IfNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut hasElseFlag = false;
   let mut kind = BreakKind.None;
   foreach stmtInfo in self.stmtList {
      let work = stmtInfo.$block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      if stmtInfo.$kind == .Else {
         hasElseFlag = true;
      }
   }
   if hasElseFlag or ( checkMode ~= .Normal and checkMode ~= .Return ) {
      return kind;
   }
   
   return .None;
}

pub class MRetExp {
   let exp:&Node {pub};
   let index:int {pub};
}

_declNodeClass( "ExpList", Node, nil, nil, false,
                [ { "expList": "&List<&Node>" },
                  // 多値使用している exp。
                  // nil の場合は多値未使用。
                  { "mRetExp": "&MRetExp!" },
                  // '**' を明示している場合 true。
                  { "followOn": "bool" } ]
);
pub override fn ExpListNode.canBeLeft():bool {
   foreach expNode in self.$expList {
      if not expNode.canBeLeft() {
         return false;
      }
   }
   return true;
}
pub override fn ExpListNode.canBeRight():bool {
   foreach expNode in self.$expList {
      if not expNode.canBeRight() {
         return false;
      }
   }
   return true;
}


pub class CaseInfo {
   pri let expList: ExpListNode { pub };
   pri let block: BlockNode { pub };
}
_declNodeClass( "Switch", Node, false, false, true,
                [ { "exp": "&Node" },
                  { "caseList": "List<&CaseInfo>" },
                  { "default": "&BlockNode!" } ]
);

pub override fn SwitchNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   let mut kind = BreakKind.None;
   foreach caseInfo in self.caseList {
      let work = caseInfo.$block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
   }
   if! let block = self.default {
      let work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }

   return .None;
}


macro _declLoopGetBreakKind( node:sym, blockMem:sym ) {

   pub override fn ,,node.getBreakKind( checkMode:CheckBreakMode ): BreakKind
   {  
      let mut kind = BreakKind.None;
      if checkMode ~= .Normal and checkMode ~= .Return {
         return self. ,,blockMem .getBreakKind( checkMode );
      }
      return .None;
   }  
}

_declNodeClass( "While", Node, false, false, true,
                [ { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declNodeClass( "Repeat", Node, false, false, true,
                [ { "block": "&BlockNode" },
                  { "exp": "&Node" } ]
);

_declLoopGetBreakKind( RepeatNode, block );

_declNodeClass( "For", Node, false, false, true,
                [ { "block": "&BlockNode" },
                  { "val": "&Ast.SymbolInfo" },
                  { "init": "&Node" },
                  { "to": "&Node" },
                  { "delta": "&Node!" }] 
);

_declLoopGetBreakKind( ForNode, block );


_declNodeClass( "Apply", Node, false, false, true,
                [ { "varList": "List<&Parser.Token>" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declLoopGetBreakKind( ApplyNode, block );


_declNodeClass( "Foreach", Node, false, false, true,
                [ { "val": "&Parser.Token!" },
                  { "key": "&Parser.Token!" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declLoopGetBreakKind( ForeachNode, block );


_declNodeClass( "Forsort", Node, false, false, true,
                [ { "val": "&Parser.Token" },
                  { "key": "&Parser.Token!" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" },
                  { "sort": "bool" } ]
);

_declLoopGetBreakKind( ForsortNode, block );


_declNodeClass( "Return", Node, false, false, true,
                [ { "expList": "&ExpListNode!" } ]
);
pub override fn ReturnNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   return .Return;
}

_declNodeClass( "Break", Node, false, false, true, [] );

pub override fn BreakNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   return .Break;
}

_declNodeClass( "Provide", Node, false, false, true,
                [ { "symbol": "&Ast.SymbolInfo" } ]
);

_declNodeClass( "ExpNew", Node, false, true, true,
                [ { "symbol": "&Node" },
                  { "ctorTypeInfo": "&Ast.TypeInfo" },
                  { "argList": "&ExpListNode!" } ]
);

_declNodeClass( "ExpUnwrap", Node, false, true, false,
                [ { "exp": "&Node" },
                  { "default": "&Node!" } ]
);

_declNodeClass( "ExpRef", Node, nil, nil, false,
                [ { "token": "&Parser.Token" },
                  { "symbolInfo": "&Ast.AccessSymbolInfo" } ]
);

pub override fn ExpRefNode.canBeLeft():bool {
   return self.$symbolInfo.$canBeLeft;
}

pub override fn ExpRefNode.canBeRight():bool {
   return self.$symbolInfo.$canBeRight and self.$symbolInfo.$hasValueFlag;
   //return self.$symbolInfo.$canBeRight;
}

_declNodeClass( "ExpOp2", Node, false, true, nil,
                [ { "op": "&Parser.Token" },
                  { "exp1": "&Node" },
                  { "exp2": "&Node" } ]
);

pub override fn ExpOp2Node.canBeStatement():bool {
   return self.$op.txt == '=';
}


_declNodeClass( "UnwrapSet", Node, false, false, true,
                [ { "dstExpList": "&ExpListNode" },
                  { "srcExpList": "&ExpListNode" },
                  { "unwrapBlock": "&BlockNode!" } ]              
);

_declNodeClass( "IfUnwrap", Node, false, false, true,
                [ { "varSymList": "&List<&Ast.SymbolInfo>" },
                  { "expList": "&ExpListNode" },
                  { "block": "&BlockNode" },
                  { "nilBlock": "&BlockNode!" } ]
);

pub override fn IfUnwrapNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut kind = self.block.getBreakKind( checkMode );
   let mut work = kind;
   _setBreakKind( work, kind, true, checkMode );
   if! let block = self.nilBlock {
      work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }
   return .None;
}


pub class UnwrapSymbolPair {
   let src:&Ast.SymbolInfo {pub};
   let dst:&Ast.SymbolInfo {pub};
}

_declNodeClass( "When", Node, false, false, true,
                [ //{ "varNameList": "List<&str>" },
                  //{ "expNodeList": "List<&Node>" },
                  { "symPairList": "List<&UnwrapSymbolPair>" },
                  { "block": "&BlockNode" },
                  { "elseBlock": "&BlockNode!" } ]
);

pub override fn WhenNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut kind = self.block.getBreakKind( checkMode );
   let mut work = kind;
   _setBreakKind( work, kind, true, checkMode );
   if! let block = self.elseBlock {
      work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }
   return .None;
}

pub enum CastKind {
   /** 通常キャスト */
   Normal,
   /** 強制キャスト */
   Force,
   /** 暗黙キャスト */
   Implicit,
}

/**
ExpCastNode の expType は、 castKind によって異なる。

具体的には、
Implicit の場合、 exp の型がそのまま入る。
Implicit 以外の場合、キャスト後の型が入る。
*/
_declNodeClass( "ExpCast", Node, false, true, false,
                [ { "exp": "&Node" },
                  // キャスト後の型
                  { "castType": "&Ast.TypeInfo" },
                  { "castKind": "CastKind" } ]
);

pub override fn ExpCastNode.getLiteral(): Literal!, str! {
   return self.exp.getLiteral()**;
}
pub override fn ExpCastNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   return self.exp.setupLiteralTokenList( list );
}



_declNodeClass( "ExpToDDD", Node, false, true, false,
                //[ { "expList": "&List<&Node>" } ]
                [ { "expList": "&ExpListNode" } ]
);

_declNodeClass( "ExpSubDDD", Node, false, true, false,
                [ { "src": "&Node" },
                  { "remainIndex": "int" } ]
);


pub enum MacroMode {
   /** マクロ処理なし */
   None,
   /** マクロの展開モード */
   Expand,
   /** マクロ呼び出し時の引数解析モード */
   AnalyzeArg,
}

_declNodeClass( "ExpOp1", Node, false, true, false,
                [ { "op": "&Parser.Token" },
                  { "macroMode": "MacroMode" },
                  { "exp": "&Node" } ]
);

_declNodeClass( "ExpRefItem", Node, nil, true, false,
                [ { "val": "&Node" },
                  { "nilAccess": "bool" },
                  { "symbol": "str!" },
                  { "index": "&Node!" } ]
);
pub override fn ExpRefItemNode.canBeLeft(): bool {
   if self.val.$expType == Ast.builtinTypeStem {
      return false;
   }
   //return self.$expType.$mutable;
   return Ast.TypeInfo.isMut( self.$val.$expType ) and not self.nilAccess;
}

_declNodeClass( "ExpCall", Node, false, nil, true,
                [ { "func": "&Node" },
                  { "errorFunc": "bool" },
                  { "nilAccess": "bool" },
                  { "argList": "&ExpListNode!" } ]
);
pub override fn ExpCallNode.canBeRight():bool {
   let expType = self.$expType;
   if expType.equals( Ast.builtinTypeNone## ) or
      expType.equals( Ast.builtinTypeNeverRet## )
   {
      return false;
   }
   return true;
}


pub override fn ExpCallNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   if self.errorFunc {
      return .NeverRet;
   }
   return .None;
}

// 多値戻り値の index 番目 ( index >= 2 )
_declNodeClass( "ExpAccessMRet", Node, false, true, false,
                [ { "mRet": "&Node" },
                  { "index": "int" } ]
);

// 多値戻り値の先頭だけ使用する場合
_declNodeClass( "ExpMultiTo1", Node, false, true, false,
                [ { "exp": "&Node" } ]
);


_declNodeClass( "ExpDDD", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

_declNodeClass( "ExpParen", Node, false, true, false,
                [ { "exp": "&Node" } ]
);
pub override fn ExpParenNode.getSymbolInfo(): &List<&Ast.AccessSymbolInfo> {
   return self.exp.getSymbolInfo();
}


/** マクロ展開 */
_declNodeClass( "ExpMacroExp", Node, false, nil, true,
                [ { "stmtList": "List<&Node>" } ]
);

pub override fn ExpMacroExpNode.canBeRight():bool {
   return self.$expType ~= Ast.builtinTypeNone;
}

pub override fn ExpMacroExpNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in self.stmtList {
         let work = stmt.getBreakKind( checkMode );
         _setBreakKind(work, kind, false, checkMode );
      }
      return kind;
   }
   else {
      if #self.stmtList > 0 {
         return self.stmtList[ #self.stmtList ].getBreakKind( checkMode );
      }
   }
   return .None;
}

pub enum MacroStatKind {
   Stat,
   Exp,
}

_declNodeClass( "ExpMacroStat", Node, false, true, false,
                [ { "expStrList": "List<&Node>" } ]
);

_declNodeClass( "ExpMacroArgExp", Node, false, true, false,
                [ { "codeTxt": "str" } ]
);


_declNodeClass( "StmtExp", Node, false, true, nil,
                [ { "exp": "&Node" } ]
);
pub override fn StmtExpNode.canBeStatement():bool {
   return self.$exp.canBeStatement();
}

pub override fn StmtExpNode.getBreakKind( checkMode:CheckBreakMode ):BreakKind {
   return self.$exp.getBreakKind( checkMode );
}

_declNodeClass( "ExpMacroStatList", Node, false, true, false,
                [ { "exp": "&Node" } ]
);


_declNodeClass( "ExpOmitEnum", Node, true, true, false,
                [ { "valToken": "&Parser.Token" },
                  { "valInfo": "&Ast.EnumValInfo" },
                  { "enumTypeInfo": "&Ast.EnumTypeInfo" }]
);

_declNodeClass( "RefField", Node, nil, nil, false,
                [ { "field": "&Parser.Token" },
                  //{ "overrideCanBeLeft": "bool!" },
                  { "symbolInfo": "&Ast.AccessSymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "&Node" }] 
);
pub override fn RefFieldNode.canBeLeft():bool {
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return false;
}
pub override fn RefFieldNode.canBeRight():bool {
   if! self.$symbolInfo {
      return _exp.$canBeRight;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return true;
}

_declNodeClass( "GetField", Node, nil, true, false,
                [ { "field": "&Parser.Token" },
                  //{ "overrideCanBeLeft": "bool!" },
                  { "symbolInfo": "&Ast.AccessSymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "&Node" },
                  { "getterTypeInfo": "&Ast.TypeInfo" } ]               
);
pub override fn GetFieldNode.canBeLeft():bool {
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return false;
}


_declNodeClass( "Alias", Node, false, false, true,
                [ {"newName": "str" },
                  {"srcNode": "&Node" },
                  {"typeInfo": "&Ast.TypeInfo" } ] );

pub class VarInfo {
   pri let name: &Parser.Token { pub };
   // 宣言している型。 宣言していない場合は nil
   pri let refType: RefTypeNode! { pub };
   // 実際の型。
   pri let actualType: Ast.TypeInfo { pub };
}

pub enum DeclVarMode {
   Let,
   Sync,
   Unwrap,
}

_declNodeClass( "DeclVar", Node, false, false, true,
                [ { "mode": "DeclVarMode" },
                  { "accessMode": "Ast.AccessMode" },
                  { "staticFlag": "bool" },
                  { "varList": "&List<&VarInfo>" },
                  { "expList": "&ExpListNode!" },
                  { "symbolInfoList": "&List<&Ast.SymbolInfo>"},
                  { "typeInfoList": "&List<&Ast.TypeInfo>" },
                  { "unwrapFlag": "bool" },
                  { "unwrapBlock": "&BlockNode!" },
                  { "thenBlock": "&BlockNode!" },
                  { "syncVarList": "&List<&VarInfo>" },
                  { "syncBlock": "&BlockNode!" } ]
);

pub override fn DeclVarNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   // if checkMode ~= .Normal and checkMode ~= .Return {
   //    if! let block = self.unwrapBlock {
   //       let kind = block.getBreakKind( checkMode );
   //       switch kind {
   //          case .Return, .NeverRet, .Break {
   //             return kind;
   //          }
   //       }
   //    }
   //    if! let block = self.thenBlock {
   //       let kind = block.getBreakKind( checkMode );
   //       switch kind {
   //          case .Return, .NeverRet, .Break {
   //             return kind;
   //          }
   //       }
   //    }
   //    if! let block = self.syncBlock {
   //       let kind = block.getBreakKind( checkMode );
   //       switch kind {
   //          case .Return, .NeverRet, .Break {
   //             return kind;
   //          }
   //       }
   //    }
   //    return .None;
   // }
   // else {
   //    let mut kind = BreakKind.None;
   //    let mut work = BreakKind.None;
   //    if! let block = self.unwrapBlock {
   //       work = block.getBreakKind( checkMode );
   //       _setBreakKind( work, kind, true, checkMode );
   //       if! let thenBlock = self.thenBlock {
   //          work = thenBlock.getBreakKind( checkMode );
   //          _setBreakKind( work, kind, true, checkMode );
   //          if! let syncBlock = self.syncBlock {
   //             work = syncBlock.getBreakKind( checkMode );
   //             _setBreakKind( work, kind, true, checkMode );
   //             return kind;
   //          }     
   //       }  
   //    }
   //    return .None;
   // }
   
   let mut kind = BreakKind.None;
   let mut work = BreakKind.None;
   if! let block = self.unwrapBlock {
      work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      if! let thenBlock = self.thenBlock {
         work = thenBlock.getBreakKind( checkMode );
         _setBreakKind( work, kind, true, checkMode );
         if! let syncBlock = self.syncBlock {
            work = syncBlock.getBreakKind( checkMode );
            _setBreakKind( work, kind, true, checkMode );
         }
         return kind;
      }
      if checkMode ~= .Normal and checkMode ~= .Return {
         return kind;
      }
   }
   return .None;
}


_declNodeClass( "DeclForm", Node, false, false, true,
                [ { "argList": "&List<&Node>" } ]
);

pub enum FuncKind {
   /** 関数定義 */
   Func,
   /** メドッ定義 */
   Mtd,
   /** コンストラクタ定義 */
   Ctor,
   /** デストラクタ定義 */
   Dstr,
   /** クラスの __init ブロック */
   InitBlock,
}

pub class DeclFuncInfo {
   let kind:FuncKind { pub };
   let classTypeInfo: &Ast.TypeInfo! { pub };
   let name: &Parser.Token! { pub };
   let argList: &List<&Node> { pub };
   let staticFlag: bool { pub };
   let accessMode: Ast.AccessMode { pub };
   let body: &BlockNode! { pub };
   let retTypeInfoList: &List<&Ast.TypeInfo> { pub };
   let has__func__Symbol:bool { pub };
}

pub static fn DeclFuncInfo.createFrom(
   info:&DeclFuncInfo, name:&Parser.Token ): DeclFuncInfo
{
   return new DeclFuncInfo(
      info.$kind, info.classTypeInfo, name, info.argList, info.staticFlag,
      info.accessMode, info.body, info.retTypeInfoList, info.has__func__Symbol );
}

_declNodeClass( "DeclFunc", Node, false, nil, true,
                [ { "declInfo": "&DeclFuncInfo" } ]
);
pub override fn DeclFuncNode.canBeRight():bool {
   // anonymous 関数なら r-value に成れる
   return self.declInfo.$name == nil;
}



_declNodeClass( "DeclMethod", Node, false, false, true,
                [ { "declInfo": "&DeclFuncInfo" } ]
);

_declNodeClass( "DeclConstr", Node, false, false, true,
                [ { "declInfo": "&DeclFuncInfo" } ]
);

_declNodeClass( "DeclDestr", Node, false, false, true,
                [ { "declInfo": "&DeclFuncInfo" } ]
);

_declNodeClass( "ExpCallSuper", Node, false, false, true,
                [ { "superType": "&Ast.TypeInfo" },
                  { "methodType": "&Ast.TypeInfo" },
                  { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "DeclMember", Node, false, false, true,
                [ { "name": "&Parser.Token" },
                  { "refType": "&RefTypeNode" },
                  { "symbolInfo": "&Ast.SymbolInfo" },
                  { "classType" : "&Ast.TypeInfo" },
                  { "staticFlag": "bool" },
                  { "accessMode": "Ast.AccessMode" },
                  { "getterMutable": "bool" },
                  { "getterMode": "Ast.AccessMode" },
                  { "getterRetType": "&Ast.TypeInfo" },
                  { "setterMode": "Ast.AccessMode" } ]
);

_declNodeClass( "DeclArg", Node, false, false, false,
                [ { "name": "&Parser.Token" },
                  { "symbolInfo": "&Ast.SymbolInfo" } ]
                  //{ "argType": "&RefTypeNode" } ]
);

_declNodeClass( "DeclArgDDD", Node, false, false, false, [] );

pub class AdvertiseInfo {
   pri let mut member: &DeclMemberNode { pub };
   pri let prefix: str {pub};
   pri let pos: &Parser.Position {pub};
};
pub class ClassInitBlockInfo {
   pri let mut func: &DeclMethodNode! {pub,pub};
}
_declNodeClass( "DeclClass", Node, false, false, true,
                [ { "accessMode": "Ast.AccessMode" },
                  { "name": "&Parser.Token" },
                  { "gluePrefix": "str!" },
                  { "declStmtList": "List<&Node>" },
                  { "fieldList": "List<&Node>" },
                  { "moduleName": "&Parser.Token!" },
                  { "memberList": "List<&DeclMemberNode>" },
                  { "scope": "&Ast.Scope" },
                  //{ "initStmtList": "List<&Node>" },
                  { "initBlock": "&ClassInitBlockInfo" },
                  { "advertiseList": "List<&AdvertiseInfo>" },
                  { "trustList": "List<&Ast.TypeInfo>" },
                  { "outerMethodSet": "Set<str>" } ]
);

pub fn DeclClassNode.hasUserInit() : bool {
   let scope = unwrap self.$expType.$scope;
   let initFuncType = unwrap scope.getTypeInfoField( "__init", true, scope, .Normal );
   return not initFuncType.$autoFlag;
}

_declNodeClass( "DeclEnum", Node, false, false, true,
                [ { "accessMode": "Ast.AccessMode" },
                  { "name": "&Parser.Token" },
                  { "valueNameList": "List<&Parser.Token>" },
                  { "scope": "&Ast.Scope" } ]
);

_declNodeClass( "DeclAlge", Node, false, false, true,
                [ { "accessMode": "Ast.AccessMode" },
                  { "algeType": "&Ast.AlgeTypeInfo"},
                  { "scope": "&Ast.Scope" } ]
);


_declNodeClass( "NewAlgeVal", Node, false, true, false,
                [ { "name": "&Parser.Token" },
                  { "prefix": "&Node!" },
                  { "algeTypeInfo": "&Ast.AlgeTypeInfo" },
                  { "valInfo": "&Ast.AlgeValInfo" },
                  { "paramList": "&List<&Node>" } ]
);

_declNodeClass( "LuneControl", Node, false, false, true,
                [ {"pragma": "LuneControl.Pragma"} ]
);


pub class MatchCase {
   pri let valInfo: &Ast.AlgeValInfo {pub};
   pri let valParamNameList: &List<str> {pub};
   pri let block: &BlockNode {pub};
}

_declNodeClass( "Match", Node, false, false, true,
                [ { "val": "&Node" },
                  { "algeTypeInfo": "&Ast.AlgeTypeInfo" },
                  { "caseList": "&List<&MatchCase>" },
                  { "defaultBlock": "&Node!" }
                ]              
);

_declNodeClass( "LuneKind", Node, false, true, false,
                [ { "exp": "&Node" } ]
);

_declNodeClass( "DeclMacro", Node, false, false, true,
                [ { "declInfo": "DeclMacroInfo" } ]
);



pub abstract class MacroEval {
   pub abstract fn evalFromCode(
      name:str, argNameList:&List<str>, code:str! ): macroStatmentProc;
   pub abstract fn eval( macroNode: DeclMacroNode ): macroStatmentProc;
}


_declNodeClass( "TestBlock", Node, false, false, true,
                [ { "name": "&Parser.Token" },
                  { "block": "&BlockNode" } ]
);


_declNodeClass( "Abbr", Node, false, true, false,
                [ {} ]
);


_declNodeClass( "Boxing", Node, false, true, false,
                [ { "src": "&Node" } ]
);

_declNodeClass( "Unboxing", Node, false, true, false,
                [ { "src": "&Node" } ]
);

_declNodeClass( "LiteralNil", Node, false, true, false, [] );

_declNodeClass( "LiteralChar", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralInt", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralReal", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "real" } ]
);

_declNodeClass( "LiteralArray", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "LiteralList", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "LiteralSet", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

pub class PairItem {
   pri let key: Node { pub };
   pri let val: Node { pub };
}
_declNodeClass( "LiteralMap", Node, false, true, false,
                [ { "map": "Map<&Node,&Node>" },
                  { "pairList": "List<&PairItem>" } ]
);

_declNodeClass( "LiteralString", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "LiteralBool", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

_declNodeClass( "LiteralSymbol", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

pub fn Node.getSymbolInfo(): &List<&Ast.AccessSymbolInfo> {
   fn processExpNode( node: &Node ): &List<&Ast.AccessSymbolInfo> {
      switch ( node.$kind ) {
         case NodeKind.$ExpRef {
            return [(unwrap (node@@@ExpRefNode)).$symbolInfo];
         }
         case NodeKind.$RefField {
            if! let refFieldNode = node@@@RefFieldNode {
               if! refFieldNode.$symbolInfo {
                  return [_exp];
               }
            }
         }
         // case NodeKind.$GetField {
         //    if! let getFieldNode = node@@@GetFieldNode {
         //       if! getFieldNode.$symbolInfo {
         //          return [_exp];
         //       }
         //    }
         // }
         case NodeKind.$ExpList {
            if! let expListNode = node@@@ExpListNode {
               let mut list: List<&Ast.AccessSymbolInfo> = [];
               foreach expNode, index in expListNode.$expList {
                  if index == #expListNode.$expList {
                     foreach symbolInfo in processExpNode( expNode ) {
                        list.insert( symbolInfo );
                     }  
                  }  
                  else {
                     foreach symbolInfo in processExpNode( expNode ) {
                        list.insert( symbolInfo );
                        break;
                     }  
                  }  
               }
               return list;
            }
         }
         case NodeKind.$RefType {
            if! let refTypeNode = node@@@RefTypeNode {
               return refTypeNode.$name.getSymbolInfo();
            }
         }
      }
      return [];
   }
   return processExpNode( self );
}


pub override fn WhileNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in self.block.$stmtList {
         let work = stmt.getBreakKind( checkMode );
         _setBreakKind(work, kind, false, checkMode );
      }
      if kind == .Break {
         return .None;
      }
      return kind;
   }
   else {
      if self.exp.$expType.$nilable {
         return .None;
      }
      if self.exp.$expType.equals( Ast.builtinTypeBool ## ) {
         if! let boolNode = self.exp@@@LiteralBoolNode {
            if boolNode.$token.txt == "false" {
               return .None;
            }  
         }
         else {
            return .None;
         }        
      }
      // 条件式が次のもの以外は無条件ループ。
      //  - nilable でない
      //  - bool 型の式でない
      //  - false でもない
      

      // 無条件ループ用のフロー解析に変更する。
      let mut mode = CheckBreakMode.IgnoreFlow;
      // if checkMode == .Return {
      //    mode = .IgnoreFlowReturn;
      // }
      let mut kind = BreakKind.None;
      foreach stmt in self.block.$stmtList {
         let work = stmt.getBreakKind( mode );
         
         _setBreakKind(work, kind, false, mode );
      }
      if kind == .Break {
         return .None;
      }
      if kind == .Return {
         return .Return;
      }
      return .NeverRet;
   }
}


pub override fn LiteralNilNode.getLiteral(): Literal!, str! {
   return .Nil, nil;
}
pub override fn LiteralNilNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   self.addTokenList( list, .Symb, "nil" );
   return true;
}


pub override fn LiteralCharNode.getLiteral(): Literal!, str! {
   return .Int( self.num ), nil;
}
pub override fn LiteralCharNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   self.addTokenList( list, .Char, "%d" (self.num) );
   return true;
}

pub override fn LiteralIntNode.getLiteral(): Literal!, str! {
   return .Int( self.num ), nil;
}
pub override fn LiteralIntNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   self.addTokenList( list, .Int, "%d" (self.num) );
   return true;
}

pub override fn LiteralRealNode.getLiteral(): Literal!, str! {
   return .Real( self.num ), nil;
}
pub override fn LiteralRealNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool {
   self.addTokenList( list, .Real, "%g" (self.num) );
   return true;
}

pub override fn LiteralArrayNode.getLiteral(): Literal!, str! {
   let mut literalList:List<Literal> = [];
   if! self.expList {
      foreach node in _exp.get_expList() {
         let literal, mess = node.getLiteral();
         when! literal {
            literalList.insert( literal );
         }
         else {
            return nil, mess;
         }
      } 
   }
   return .ARRAY( literalList ), nil;
}

pub override fn LiteralArrayNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Dlmt, "[@" );
   if! self.expList {
      foreach node, index in _exp.get_expList() {
         if index > 1 {
            self.addTokenList( list, .Dlmt, "," );
         }
         if not node.setupLiteralTokenList( list ) {
            return false;
         }
      } 
   }
   self.addTokenList( list, .Dlmt, "]" );
   return true;
}

pub override fn LiteralListNode.getLiteral(): Literal!, str! {
   let mut literalList:List<Literal> = [];
   if! self.expList {
      foreach node in _exp.get_expList() {
         let literal, mess = node.getLiteral();
         when! literal {
            literalList.insert( literal );
         }
         else {
            return nil, mess;
         }
      } 
   }
   return .LIST( literalList ), nil;
}

pub override fn LiteralListNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Dlmt, "[" );
   if! self.expList {
      foreach node, index in _exp.get_expList() {
         if index > 1 {
            self.addTokenList( list, .Dlmt, "," );
         }
         if not node.setupLiteralTokenList( list ) {
            return false;
         }
      } 
   }
   self.addTokenList( list, .Dlmt, "]" );
   return true;
}


pub override fn LiteralSetNode.getLiteral(): Literal!, str! {
   let mut literalList:List<Literal> = [];
   if! self.expList {
      foreach node in _exp.get_expList() {
         let literal, mess = node.getLiteral();
         when! literal {
            literalList.insert( literal );
         }
         else {
            return nil, mess;
         }
      } 
   }
   return .SET( literalList ), nil;
}

pub override fn LiteralSetNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Dlmt, "(@" );
   if! self.expList {
      foreach node, index in _exp.get_expList() {
         if index > 1 {
            self.addTokenList( list, .Dlmt, "," );
         }
         if not node.setupLiteralTokenList( list ) {
            return false;
         }
      } 
   }
   self.addTokenList( list, .Dlmt, ")" );
   return true;
}

pub override fn LiteralMapNode.getLiteral(): Literal!, str! {
   let mut litMap:Map<&Literal,&Literal> = {};
   foreach val, key in self.map {
      let keyLiteral, keyMess = key.getLiteral();
      let valLiteral, valMess = val.getLiteral();
      when! keyLiteral, valLiteral {
         litMap[ keyLiteral ] = valLiteral;
      }
      else {
         if not keyLiteral {
            return nil, keyMess;
         }
         if not valLiteral {
            return nil, valMess;
         }
      }
   }
   return .MAP( litMap ), nil;
}

pub override fn LiteralMapNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Dlmt, "{" );

   let mut lit2valNode:Map<stem,&Node> = {};
   foreach val, key in self.map {
      let literal = key.getLiteral();
      when! literal {
         match literal {
            case .Int( param ) {
               lit2valNode[ param ] = key;
            }
            case .Str( param ) {
               lit2valNode[ param ] = key;
            }
            case .Real( param ) {
               lit2valNode[ param ] = key;
            }
            default {
               return false;
            }
         }
      }
   }
   
   forsort key, literal in lit2valNode {
      if not key.setupLiteralTokenList( list ) {
         return false;
      }
      self.addTokenList( list, .Dlmt, ":" );
      if not self.map[ key ]$.setupLiteralTokenList$( list ) {
         return false;
      }
      self.addTokenList( list, .Dlmt, "," );
   }
   self.addTokenList( list, .Dlmt, "}" );
   return true;
}


pub override fn LiteralStringNode.getLiteral(): Literal!, str! {
   let mut txt = self.token.txt;
   if string.find( txt, '^```' ##) {
      txt = txt.sub( 4, -4 );
   }
   else {
      txt = txt.sub( 2, -2 );
   }

   if! let expList = self.$expList {
      let argList = expList.$expList;

      let mut paramList:List<stem!> = [];
      foreach argNode in argList {
         let arg, mess = argNode.getLiteral();
         when! arg {
            paramList[ #paramList + 1 ] = getLiteralObj( arg );
         }
         else {
            return nil, mess;
         }
      }
      txt = string.format( txt, paramList.unpack() );
   }
   return .Str(txt), nil;
}

pub override fn LiteralStringNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Str, self.token.txt );
   if! let expList = self.$expList {
      self.addTokenList( list, .Dlmt, self.token.txt );
      foreach argNode, index in expList.$expList {
         if index > 1 {
            self.addTokenList( list, .Dlmt, "," );
         }
         if not argNode.setupLiteralTokenList( list ) {
            return false;
         }
      }
   }
   return true;
}

pub override fn LiteralBoolNode.getLiteral(): Literal!, str! {
   return .Bool( self.token.txt == "true" ), nil;
}

pub override fn LiteralBoolNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Symb, self.token.txt );
   return true;
}


pub override fn LiteralSymbolNode.getLiteral(): Literal!, str! {
   return .Symbol(self.token.txt), nil;
}

pub override fn LiteralSymbolNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   self.addTokenList( list, .Symb, self.token.txt );
   return true;
}


pub override fn RefFieldNode.getLiteral(): Literal!, str! {
   let mut tokenList:List<str> = [];
   let literal, mess = self.prefix.getLiteral();
   when! literal {
      match literal {
         case .Symbol( symbol ) {
            tokenList.insert( symbol );
         }
         case .Field( symList ) {
            foreach symbol in symList {
               tokenList.insert( symbol );
            }
         }
         default {
            return nil, "not support -- %s" (literal.$_txt) ;
         }
      }
      if self.nilAccess {
         tokenList.insert( "$." );
      }
      else {
         tokenList.insert( "." );
      }
      tokenList.insert( self.field.txt );
      return .Field( tokenList ), nil;
   }
   return nil, mess;
}

pub override fn ExpMacroStatNode.getLiteral(): Literal!, str!
{
   let mut txt = "";
   foreach token in self.expStrList {
      let literal, mess = token.getLiteral();
      when! literal {
         match literal {
            case .Str( work ) {
               txt = "%s%s" (txt, work );
            }
         }
      }
      else {
         return nil, "illegal literal -- %s" ( getNodeKindName( token.$kind ) );
      }
   }
   return .Str( txt ), nil;
}

pub override fn ExpMacroArgExpNode.getLiteral(): Literal!, str!
{
   return .Str( self.$codeTxt ), nil;
}


fn enumLiteral2Literal( obj:&Ast.EnumLiteral ) : Literal!, str! {
   match obj {
      case .Int( val ) {
         return Literal.Int( val ), nil;
      }
      case .Real( val ) {
         return Literal.Real( val ), nil;
      }
      case .Str( val ) {
         return Literal.Str( val ), nil;
      }
   }
   return nil, "illegal enum: " .. obj.$_txt;
}

pub override fn ExpRefNode.getLiteral(): Literal!, str! {
   let typeInfo = self.symbolInfo.$typeInfo;
   if! let enumTypeInfo = typeInfo@@@Ast.EnumTypeInfo {
      let enumval = unwrap enumTypeInfo.getEnumValInfo( self.symbolInfo.$name );
      return enumLiteral2Literal( enumval.$val )**;
   }

   return nil, "unsupport refnode -- %s" (typeInfo.getTxt(##));
}

pub override fn ExpOmitEnumNode.getLiteral(): Literal!, str! {
   let enumTypeInfo = self.enumTypeInfo;

   let enumval = self.valInfo;
   return enumLiteral2Literal( enumval.$val )**;
   
}

pub override fn ExpOmitEnumNode.setupLiteralTokenList( list: List<&Parser.Token> ): bool
{
   let enumTypeInfo = self.enumTypeInfo;

   let enumval = self.valInfo;
   self.addTokenList( list, .Dlmt, "." );

   self.addTokenList( list, .Symb, (enumval.$val.$_txt.gsub( ".*%.", "")) );
   return true;
}

pub override fn ExpOp2Node.getLiteral(): Literal!, str! {

   fn getValType( node:&Node ): bool, int, real, str, &Ast.TypeInfo {
      let! literal = node.getLiteral() {
         return false, 0, 0.0, "", Ast.headTypeInfo;
      };

      let mut intVal, mut realVal, mut strVal = 0, 0.0, "";
      let mut retTypeInfo = Ast.builtinTypeNone;

      fn getEnum( txt:str, typeInfo:&Ast.TypeInfo ) {
         if! let enumTypeInfo = typeInfo@@@Ast.EnumTypeInfo {
            let valInfo = unwrap enumTypeInfo.getEnumValInfo( txt );
            match valInfo.$val {
               case .Int( val ) {
                  intVal = val;
                  realVal = val@@real;
               }
               case .Real( val ) {
                  realVal = val;
               }
               case .Str( val ) {
                  strVal = val;
               }
            }
            retTypeInfo = enumTypeInfo.$valTypeInfo;
         }
      }
      
      match literal {
         case .Int( val ) {
            intVal = val;
            realVal = val@@real;
            retTypeInfo = Ast.builtinTypeInt;
         }
         case .Real( val ) {
            realVal = val;
            intVal = val@@int;
            retTypeInfo = Ast.builtinTypeReal;
         }
         case .Str( val ) {
            strVal = val;
            retTypeInfo = Ast.builtinTypeString;
         }
         default {
            return false, 0, 0.0, "", Ast.headTypeInfo;
         }
      }
      return true, intVal, realVal, strVal, retTypeInfo;
   }
   
   let ret1, int1, real1, str1, type1 = getValType( self.$exp1 );
   let ret2, int2, real2, str2, type2 = getValType( self.$exp2 );

   if not ret1 {
      return nil, "not support literal -- %s" ( getNodeKindName( self.$exp1.$kind ) );
   }
   if not ret2 {
      return nil, "not support literal -- %s" ( getNodeKindName( self.$exp2.$kind ) );
   }


   if ( type1 == Ast.builtinTypeInt or type1 == Ast.builtinTypeReal ) and
      ( type2 == Ast.builtinTypeInt or type2 == Ast.builtinTypeReal )
   {
      let mut retType = Ast.builtinTypeInt;
      if type1 == Ast.builtinTypeReal or type2 == Ast.builtinTypeReal {
         retType = Ast.builtinTypeReal;
      }

      switch ( self.op.txt ) {
         case "+" {
            if retType == Ast.builtinTypeInt {
               return .Int( int1 + int2 ), nil;
            }
            return .Real( real1 + real2 ), nil;
         }
         case "-" {
            if retType == Ast.builtinTypeInt {
               return .Int( int1 - int2 ), nil;
            }
            return .Real( real1 - real2), nil;
         }
         case "*" {
            if retType == Ast.builtinTypeInt {
               return .Int( int1 * int2 ), nil;
            }
            return .Real( real1 * real2), nil;
         }
         case "/" {
            if retType == Ast.builtinTypeInt {
               return .Int( int1 / int2 ), nil;
            }
            return .Real( real1 / real2), nil;
         }
      }
   }
   elseif type1 == Ast.builtinTypeString and type2 == Ast.builtinTypeString {
      if self.op.txt == ".." {
         return .Str( str1 .. str2 ), nil;
      }
   }

   let mess = "not support literal operation -- %s %s %s"
       (type1.getTxt(##), self.op.txt, type2.getTxt(##) );
   return nil, mess;
}

pub class DefMacroInfo extend MacroInfo {
   pub let declInfo: DeclMacroInfo;
   pri let mut argList:List<&MacroArgInfo>;

   pub override fn get_name():str {
      return self.declInfo.$name.txt;
   }
   
   pub override fn getArgList():&List<&MacroArgInfo> {
      return self.argList;
   }
   pub override fn getTokenList():&List<&Parser.Token>{
      return self.declInfo.$tokenList;
   }
   
   pub fn __init( func: macroStatmentProc, declInfo: DeclMacroInfo, 
                  symbol2MacroValInfoMap: Map<str,MacroValInfo> )
   {
      super( func, symbol2MacroValInfoMap );
      self.declInfo = declInfo;
      self.argList = [];
      foreach argNode in declInfo.$argList {
         if argNode.get_kind() == NodeKind.$DeclArg {
            //let argType = argNode.$argType.$expType;
            let argType = argNode.$expType;
            let argName = argNode.$name.txt;
            self.argList.insert( new MacroArgInfo( argName, argType ) );
         }
      }
   }
}

pub fn NodeManager.MultiTo1(node:&Node) mut : &Node {
   let expType = node.$expType;
   if #node.$expTypeList > 1 {
      return ExpMultiTo1Node.create( self, node.$pos, [ expType ], node );
   }
   elseif expType.$kind == .DDD {
      return ExpMultiTo1Node.create( self, node.$pos, expType.$itemTypeInfoList, node );
   }
   return node;
}

pub fn Filter.processBlockSub( node: &BlockNode, opt:T ) mut {
}

pub fn Filter.processBlock( node: &BlockNode, opt:T ) mut {
   self.moduleInfoManager.push( node.$scope );

   self.processBlockSub( node, opt );

   self.moduleInfoManager.pop();
}

/**
指定のノードが 多値のノードか調べる

@param node ノード
@return 多値の場合 true
*/
pub fn hasMultiValNode( node:&Node ): bool {
   return #node.$expTypeList > 1 or node.$expType.$kind == .DDD;
}
