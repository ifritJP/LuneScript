/*
MIT License

Copyright (c) 2018, 2019 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Types;
import lune.base.Meta;
import lune.base.Tokenizer;
import lune.base.Util;
import lune.base.Ast;
import lune.base.Macro;
import lune.base.Nodes;
import lune.base.frontInterface;
import lune.base.Log;
import lune.base.Runner;

import lune.base.TransUnitIF;

_lune_control ignore_symbol_;
_lune_control default_strict_generics;


pub proto class ModuleLoader extend Runner.Runner(frontInterface.ModuleLoader);
   

proto abstract class _TypeInfo extend (Mapping);

class ImportParam {
   pub let pos:&Tokenizer.Position;
   pub let modifier:TransUnitIF.Modifier;
   pub let mut processInfo:Ast.ProcessInfo;
   pub let mut typeId2Scope:Map<int,Ast.Scope>;
   pub let mut typeId2TypeInfo:Map<int,&Ast.TypeInfo>;
   pub let mut typeId2TypeDataAccessor:Map<int,Ast.TypeDataAccessor>;
   pub let mut importedAliasMap: Map<&Ast.TypeInfo,&Ast.AliasTypeInfo>;
   pub let lazyModuleSet:&Set<int>;
   pub let metaInfo:Luaval<&Meta._MetaInfo>;
   pub let scope:Ast.Scope;
   pub let moduleTypeInfo: &Ast.TypeInfo;
   pub let scopeAccess:Ast.ScopeAccess;

   pri let typeId2AtomMap:Map<int,&_TypeInfo>;
   pri let dependLibId2DependInfo:&Map<int,&frontInterface.ExportInfo>;
}

abstract class _TypeInfo extend (Mapping) {
   pub let skind: Ast.SerializeKind;
   pub let typeId: int;
   pub fn __init() {
      self.typeId = Ast.userRootId;
      self.skind = .Normal;
   }

   /**
このインスタンスから TypeInfo を生成する。

@param param 作業情報
@return Ast.TypeInfo! 生成した型情報。 失敗した場合は nil。
@return str! エラー情報。成功した場合は nil。
   */
   pro abstract fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!;

   pub fn createTypeInfoCache( param:ImportParam ) : &Ast.TypeInfo!, str! {
      if! let typeInfo = param.typeId2TypeInfo[ self.typeId ] {
         return typeInfo, nil;
      }
      let typeInfo, mess = self.createTypeInfo( param );
      when! typeInfo {
         param.typeId2TypeInfo[ self.typeId ] = typeInfo;
         typeInfo.$typeId.set_orgId( self.typeId );
      }
      return typeInfo, mess;
   }
}

pub fn ImportParam.getTypeInfo(typeId:int) mut :&Ast.TypeInfo!, str! {
   if! let typeInfo = self.typeId2TypeInfo[ typeId ] {
      return typeInfo, nil;
   }
   if! let atom = self.typeId2AtomMap[ typeId ] {
      let typeInfo, mess = atom.createTypeInfoCache( self );
      when! typeInfo {
         self.typeId2TypeInfo[ typeId ] = typeInfo;
      }
      return typeInfo, mess;
   }
   return nil, nil;
}

pub fn ImportParam.getTypeDataAccessor(typeId:int) mut :
   Ast.TypeDataAccessor, &Ast.TypeInfo
{
   let typeInfo, mess = self.getTypeInfo( typeId );
   when! typeInfo {
      let! mut typeDataAccessor = self.typeId2TypeDataAccessor[ typeId ] {
         Util.err( "not found TypeDataAccessor for %d: %s" // バグ
                   (typeId, typeInfo.getTxt(##)) );
      };
      return typeDataAccessor, typeInfo;
   }
   Util.err( "not found TypeDataAccessor for %d: %s" (typeId, mess or "") ); // バグ
}


class _IdInfo extend (Mapping) {
   pub let id:int;
   pub let mod:int;
}

pub fn ImportParam.getTypeInfoFrom(typeId:&_IdInfo) mut :&Ast.TypeInfo!, str! {
   if typeId.mod == 0 {
      return self.getTypeInfo( typeId.id )**;
   }
   if typeId.mod == frontInterface.getRootDependModId() {
      return Ast.getRootProcessInfoRo().getTypeInfo( typeId.id), nil;
   }
   let! exportInfo = self.dependLibId2DependInfo[ typeId.mod ] {
      Util.err( "%s, %d, %d" (self.moduleTypeInfo.getTxt(##), typeId.mod, typeId.id) ); // バグ
   };
   if! let typeInfo = exportInfo.$importId2localTypeInfoMap[ typeId.id ] {
      return typeInfo, nil;
   }
   if! let typeInfo = exportInfo.$processInfo.getTypeInfo( typeId.id ) {
      return typeInfo, nil;
   }
   return nil, "not found type -- %s, %d, %d"
       (self.moduleTypeInfo.getTxt(##), typeId.mod, typeId.id);
}


class _TypeInfoNilable extend _TypeInfo {
   pub let orgTypeId:&_IdInfo;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let! orgTypeInfo = param.getTypeInfoFrom( self.orgTypeId ) {
         Util.err( "failed to createTypeInfo -- self.orgTypeId = (%d,%d)" // バグ
                   ( self.orgTypeId.mod, self.orgTypeId.id ) );
      };
      let mut newTypeInfo = orgTypeInfo.get_nilableTypeInfo();
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      newTypeInfo.$typeId.set_orgId( self.typeId );
      return newTypeInfo,nil;
   }
}

class _TypeInfoAlias extend _TypeInfo {
   pub let parentId:int;
   pri let rawTxt:str;
   pri let srcTypeId:&_IdInfo;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let srcTypeInfo = unwrap param.getTypeInfoFrom( self.srcTypeId );
      let mut newTypeInfo = param.processInfo.createAlias(
         param.processInfo, self.rawTxt, true, .Pub, param.moduleTypeInfo, srcTypeInfo );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      param.typeId2TypeDataAccessor[ self.typeId ] = newTypeInfo;

      newTypeInfo.$typeId.set_orgId( self.typeId );

      // param.typeId2Scope で親のスコースを取得するために、
      // param.getTypeInfo() しておく。
      if not param.getTypeInfo( self.parentId ) {
         return nil, "%s: not found parentInfo %d %s" ( __func__,
                                                        self.parentId, self.rawTxt );
      };

      let! mut parentScope = param.typeId2Scope[ self.parentId ] {
         return nil, "%s: not found parentScope %s %s" ( __func__,
                                                     self.parentId, self.rawTxt );
      };
      parentScope.addAliasForType( param.processInfo, self.rawTxt, nil, newTypeInfo );
      param.importedAliasMap[ srcTypeInfo ] = newTypeInfo;

      return newTypeInfo,nil;
   }
}


class _TypeInfoDDD extend _TypeInfo {
   pub let parentId:int;
   pub let itemTypeId: &_IdInfo;
   pub let extTypeFlag:bool;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      //let itemTypeInfo = unwrap param.typeId2TypeInfo[ self.itemTypeId ];
      let itemTypeInfo = unwrap param.getTypeInfoFrom( self.itemTypeId );
      let newTypeInfo = param.processInfo.createDDD(
         itemTypeInfo, true, self.extTypeFlag );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;

      newTypeInfo.$typeId.set_orgId( self.typeId );
      return newTypeInfo,nil;
   }
}


class _TypeInfoAlternate extend _TypeInfo {
   pub let parentId:int;
   pub let txt:str;
   pub let accessMode:Ast.AccessMode;
   pub let baseId: &_IdInfo;
   pub let ifList:&List<&_IdInfo>;
   pub let belongClassFlag:bool;
   pub let altIndex:int;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let baseInfo = unwrap param.getTypeInfoFrom( self.baseId );
      let mut interfaceList:List<&Ast.TypeInfo> = [];
      foreach ifTypeId in self.ifList {
         //interfaceList.insert( unwrap param.typeId2TypeInfo[ ifTypeId ] );
         interfaceList.insert( unwrap param.getTypeInfoFrom( ifTypeId ) );
      }
      let mut newTypeInfo = param.processInfo.createAlternate(
         self.belongClassFlag, self.altIndex,
         self.txt, self.accessMode, param.moduleTypeInfo, baseInfo, interfaceList ## );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      param.typeId2TypeDataAccessor[ self.typeId ] = newTypeInfo;
      newTypeInfo.$typeId.set_orgId( self.typeId );
      return newTypeInfo, nil;
   }
}

class _TypeInfoGeneric extend _TypeInfo {
   pub let genSrcTypeId:&_IdInfo;
   pub let genTypeList:&List<&_IdInfo>;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let genSrcTypeInfo = unwrap param.getTypeInfoFrom( self.genSrcTypeId );
      let mut genTypeList:List<&Ast.TypeInfo> = [];
      foreach typeId in self.genTypeList {
         genTypeList.insert( unwrap param.getTypeInfoFrom( typeId ) );
      }
      let mut newTypeInfo, mut scope = param.processInfo.createGeneric(
         genSrcTypeInfo, genTypeList, param.moduleTypeInfo );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      param.typeId2TypeDataAccessor[ self.typeId ] = newTypeInfo;
      
      newTypeInfo.$typeId.set_orgId( self.typeId );
      param.typeId2Scope[ self.typeId ] = scope;
      return newTypeInfo, nil;
   }
}

class _TypeInfoBox extend _TypeInfo {
   pub let accessMode:Ast.AccessMode;
   pub let boxingType:int;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let boxingType = unwrap param.getTypeInfo( self.boxingType );
      let newTypeInfo = param.processInfo.createBox( self.accessMode, boxingType );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;

      newTypeInfo.$typeId.set_orgId( self.typeId );
      return newTypeInfo, nil;
   }
}

class _TypeInfoExt extend _TypeInfo {
   pub let extedTypeId:&_IdInfo;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let extedType = unwrap param.getTypeInfoFrom( self.extedTypeId );
      let newTypeInfo;
      _match param.processInfo.createLuaval( extedType, true ) {
         case .OK( extType, _ ) {
            newTypeInfo = extType;
         }
         case .Err( mess ) {
            Util.err( mess ); // バグ
         }
      }
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      newTypeInfo.$typeId.set_orgId( self.typeId );
      return newTypeInfo, nil;
   }
}


class _TypeInfoModifier extend _TypeInfo {
   pub let srcTypeId:&_IdInfo;
   pub let mutMode:Ast.MutMode;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      //let! srcTypeInfo = param.typeId2TypeInfo[ self.srcTypeId ] {
      let! srcTypeInfo = param.getTypeInfoFrom( self.srcTypeId ) {
         return nil, "not found srcType -- %d" ( self.srcTypeId.id );
      };
      let newTypeInfo = param.modifier.createModifier( srcTypeInfo, self.mutMode );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      newTypeInfo.$typeId.set_orgId( self.typeId );
      return newTypeInfo, nil;
   }
}

class _TypeInfoModule extend _TypeInfo {
   pub let parentId:int;
   pub let txt:str;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let mut parentInfo:&Ast.TypeInfo = Ast.headTypeInfo;
      if self.parentId ~= Ast.userRootId {
         //let! workTypeInfo = param.typeId2TypeInfo[ self.parentId ] {
         let! workTypeInfo = param.getTypeInfo( self.parentId ) {
            Util.err( "not found parentInfo %d %s" // バグ
                      ( self.parentId, self.txt ) );
         };
         parentInfo = workTypeInfo;
      }
      let! mut parentScope = param.typeId2Scope[ self.parentId ] {
         return nil, "%s: not found parentScope %s %s" ( __func__, self.parentId,
                                                         self.txt );
      };

      let mut newTypeInfo = parentScope.getTypeInfoChild( self.txt );
      if! newTypeInfo {
         // ここには入らないはず
         Util.err( "internal error" ); // バグ
         // param.typeId2Scope[ self.typeId ] = Ast.getScope( _exp );
         // if not _exp.$scope {
         //    return nil, "not found scope %s %d %s %s %s" ( parentScope, self.parentId,
         //                                                   self.typeId,
         //                                                   self.txt, _exp.getTxt(##) );
         // }
         // param.typeId2TypeInfo[ self.typeId ] = _exp;
         // _exp.$typeId.set_orgId( self.typeId );
      }
      else {
         let mut scope = new Ast.Scope( param.processInfo, parentScope, .Module, nil ## );

         let mut mutable = false;
         __luago {
            if self.typeId == param.metaInfo.__moduleTypeId {
               mutable = param.metaInfo.__moduleMutable;
            }
         }

         let mut parentTypeDataAccessor =
            param.getTypeDataAccessor( parentInfo.$typeId.id );
         let workTypeInfo = param.processInfo.createModule(
            scope, parentInfo, parentTypeDataAccessor, true, self.txt, mutable );

         newTypeInfo = workTypeInfo;
         param.typeId2Scope[ self.typeId ] = scope;
         param.typeId2TypeInfo[ self.typeId ] = workTypeInfo;
         workTypeInfo.$typeId.set_orgId( self.typeId );
         parentScope.addClass( param.processInfo, self.txt, nil, workTypeInfo );

         
         Log._log(
            .Info,
            `{ return "new module -- %s, %s, %d, %d, %d"
               ( self.txt,
                 workTypeInfo.getFullName( Ast.defaultTypeNameCtrl, parentScope, false ),
                 self.typeId, workTypeInfo.$typeId.id, parentScope.$scopeId ); } );
      }
      return newTypeInfo, nil;
   }
}

class _TypeInfoNormal extend _TypeInfo {
   pub let parentId:int;
   pub let finalFlag: bool;
   pub let abstractFlag: bool;
   pub let baseId: &_IdInfo;
   pub let txt:str;
   pub let staticFlag:bool;
   pub let accessMode:Ast.AccessMode;
   pub let kind:Ast.TypeInfoKind;
   pub let mutMode: Ast.MutMode;
   pub let asyncMode: Ast.Async;
   pub let ifList: &List<&_IdInfo>;
   pub let itemTypeId: &List<&_IdInfo>;
   pub let argTypeId: &List<&_IdInfo>;
   pub let retTypeId: &List<&_IdInfo>;
   pub let children: &List<&_IdInfo>;
   pub let moduleLang:Types.Lang!;
   pub let requirePath:str!;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let mut newTypeInfo:&Ast.TypeInfo! = nil;
      if self.parentId ~= Ast.userRootId or
         not Ast.getBuiltInTypeIdMap()[ self.typeId ] or
         self.kind == Ast.TypeInfoKind.List or
         self.kind == Ast.TypeInfoKind.Array or
         self.kind == Ast.TypeInfoKind.Map or
         self.kind == Ast.TypeInfoKind.Set
      {
         let mut parentInfo:&Ast.TypeInfo = Ast.headTypeInfo;
         if self.parentId ~= Ast.userRootId {
            //let! workTypeInfo = param.typeId2TypeInfo[ self.parentId ] {
            let! workTypeInfo = param.getTypeInfo( self.parentId ) {
               return nil, "not found parentInfo %d %s" ( self.parentId, self.txt );
            };
            parentInfo = workTypeInfo;
         }

         let mut itemTypeInfo:List<&Ast.TypeInfo> = [];
         foreach typeId in self.itemTypeId {
            //itemTypeInfo.insert( unwrap param.typeId2TypeInfo[ typeId ] );
            itemTypeInfo.insert( unwrap param.getTypeInfoFrom( typeId ) );
         }
         let mut argTypeInfo:List<&Ast.TypeInfo> = [];
         foreach typeId, index in self.argTypeId {
            //if! let argType = param.typeId2TypeInfo[ typeId ] {
            let argType, mess = param.getTypeInfoFrom( typeId );
            when! argType {
               argTypeInfo.insert( argType );
            }
            else {
               let errmess = "not found arg (index:%d) -- %s.%s, %d, %d. %s"
                   ( index, parentInfo.getTxt(##), self.txt, typeId.id,
                     #self.argTypeId, mess );
               return nil, errmess;
            }
         }
         let mut retTypeInfo:List<&Ast.TypeInfo> = [];
         foreach typeId in self.retTypeId {
            //retTypeInfo.insert( unwrap param.typeId2TypeInfo[ typeId ] );
            retTypeInfo.insert( unwrap param.getTypeInfoFrom( typeId ) );
         }

         //let baseInfo = unwrap param.typeId2TypeInfo[ self.baseId ];
         let baseInfo = unwrap param.getTypeInfoFrom( self.baseId );
         let mut interfaceList:List<&Ast.TypeInfo> = [];
         foreach ifTypeId in self.ifList {
            //interfaceList.insert( unwrap param.typeId2TypeInfo[ ifTypeId ] );
            interfaceList.insert( unwrap param.getTypeInfoFrom( ifTypeId ) );
         }

         let! mut parentScope = param.typeId2Scope[ self.parentId ] {
            return nil, "%s: not found parentScope %s %s" ( __func__,
                                                            self.parentId, self.txt );
         };

         if self.txt ~= "" {
            newTypeInfo = parentScope.getTypeInfoChild( self.txt );
         }
         if newTypeInfo and ( self.kind == Ast.TypeInfoKind.Class or
                              self.kind == Ast.TypeInfoKind.ExtModule or
                              self.kind == Ast.TypeInfoKind.IF )
         {
            Util.err("internal error"); // バグ
            // 登録済みのクラスはないはず。
         }
         else {
            fn postProcess( workTypeInfo:&Ast.TypeInfo, scope:Ast.Scope! ) __trans {
               newTypeInfo = workTypeInfo;
               
               when! scope {
                  param.typeId2Scope[ self.typeId ] = scope;
               }
               param.typeId2TypeInfo[ self.typeId ] = workTypeInfo;

               workTypeInfo.$typeId.set_orgId( self.typeId );
            }
            
            switch self.kind {
               case .Class, .IF {
                  Log._log(
                     .Debug,         
                     `{ return "new type -- %d, %s -- %s, %d"
                        (self.parentId, self.txt, 
                          parentScope.$ownerTypeInfo$.getFullName$(
                             Ast.defaultTypeNameCtrl, parentScope, false ) or "nil",
                          parentScope.$ownerTypeInfo$.$typeId$.id or -1 ); } );
                  
                  
                  let baseScope = unwrap baseInfo.$scope;
                  let mut ifScopeList:List<&Ast.Scope> = [];
                  foreach ifType in interfaceList {
                     ifScopeList.insert( unwrap ifType.$scope );
                  }

                  let mut scope = new Ast.Scope(
                     param.processInfo, parentScope, .Class, baseScope, ifScopeList );

                  let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
                  foreach itemType in itemTypeInfo {
                     altTypeList.insert( unwrap (itemType@@@Ast.AlternateTypeInfo) );
                  }

                  let mut parentTypeDataAccessor =
                     param.getTypeDataAccessor( self.parentId );
                  let mut workTypeInfo = param.processInfo.createClassAsync(
                     self.kind == Ast.TypeInfoKind.Class,
                     self.finalFlag, self.abstractFlag,   
                     scope, baseInfo, interfaceList, altTypeList,
                     parentInfo, parentTypeDataAccessor, true, .Pub, self.txt );
                  parentScope.addClassLazy(
                     param.processInfo, self.txt, nil,
                     workTypeInfo, param.lazyModuleSet.has( self.typeId ) );

                  postProcess( workTypeInfo, scope );

                  param.typeId2TypeDataAccessor[ self.typeId ] = workTypeInfo;
                  
               }
               case .ExtModule {
                  Log._log(
                     .Debug,         
                     `{ return "new type -- %d, %s -- %s, %d"
                        (self.parentId, self.txt, 
                          parentScope.$ownerTypeInfo$.getFullName$(
                             Ast.defaultTypeNameCtrl, parentScope, false ) or "nil",
                          parentScope.$ownerTypeInfo$.$typeId$.id or -1 ); } );
                  
                  
                  let mut scope = new Ast.Scope(
                     param.processInfo, parentScope, .Module, nil, [] );

                  let mut parentTypeDataAccessor =
                     param.getTypeDataAccessor( self.parentId );
                  let mut workTypeInfo = param.processInfo.createExtModule(
                     scope, parentInfo, parentTypeDataAccessor, true, .Pub, self.txt,
                     unwrap self.moduleLang, unwrap self.requirePath );
                  parentScope.addExtModule(
                     param.processInfo, self.txt, nil, workTypeInfo,
                     param.lazyModuleSet.has( self.typeId ), unwrap self.moduleLang );

                  postProcess( workTypeInfo, scope );

                  param.typeId2TypeDataAccessor[ self.typeId ] = workTypeInfo;
                  
               }
               case .Func, .Method, .FormFunc, .Macro {
                  let typeInfoKind = self.kind;
                  let accessMode = self.accessMode;

                  let mut workTypeInfo:&Ast.TypeInfo;
                  let mut scope:Ast.Scope! = nil;
                  // if self.kind ~= Ast.TypeInfoKind.FormFunc {
                  //    scope = new Ast.Scope(
                  //       param.processInfo, parentScope, .Other, nil ## );
                  // }
                  scope = new Ast.Scope(
                     param.processInfo, parentScope, .Other, nil ## );

                  let mut parentTypeDataAccessor =
                     param.getTypeDataAccessor( self.parentId );
                  let mut workTypeInfoMut = param.processInfo.createFuncAsync(
                     self.abstractFlag, false, scope, typeInfoKind,
                     parentInfo, parentTypeDataAccessor, false, true, self.staticFlag,
                     accessMode, self.txt, self.asyncMode,
                     itemTypeInfo, argTypeInfo, retTypeInfo, self.mutMode );
                  param.typeId2TypeDataAccessor[ self.typeId ] = workTypeInfoMut;

                  postProcess( workTypeInfoMut, scope );

                  switch self.kind {
                     case .Func, .Method, .Macro, .FormFunc {
                        let mut symbolKind = Ast.SymbolKind.Fun;
                        switch self.kind {
                           case .Method {
                              symbolKind = Ast.SymbolKind.Mtd;
                           }
                           case .Macro {
                              symbolKind = Ast.SymbolKind.Mac;
                           }
                           case .FormFunc {
                              symbolKind = Ast.SymbolKind.Typ;
                           }
                        }
                        let mut workParentScope =
                           unwrap param.typeId2Scope[ self.parentId ];
                        workParentScope.add(
                           param.processInfo, symbolKind, false, self.kind == .Func,
                           self.txt, nil, workTypeInfoMut, accessMode,
                           self.staticFlag, self.mutMode, true, false );
                     }
                  }
               }
               case .Set {
                  let workTypeInfo = param.processInfo.createSet_(
                     Ast.builtinTypeSet_.$rawTxt == self.txt,
                     self.accessMode, parentInfo, itemTypeInfo, self.mutMode );
                  postProcess( workTypeInfo, nil );
               }
               case .List {
                  let workTypeInfo = param.processInfo.createList_(
                     Ast.builtinTypeList_.$rawTxt == self.txt,
                     self.accessMode, parentInfo, itemTypeInfo, self.mutMode );
                  postProcess( workTypeInfo, nil );
               }
               case .Array {
                  let workTypeInfo = param.processInfo.createArray(
                     self.accessMode, parentInfo,
                     itemTypeInfo, self.mutMode );
                  postProcess( workTypeInfo, nil );
               }
               case .Map {
                  let workTypeInfo = param.processInfo.createMap_(
                     Ast.builtinTypeMap_.$rawTxt == self.txt,
                     self.accessMode, parentInfo,
                     itemTypeInfo[1], itemTypeInfo[2], self.mutMode );
                  postProcess( workTypeInfo, nil );
               }
               default {
                  Util.err( "illegal kind -- %s" (self.kind.$_txt) ); // バグ
               }
            }
         }
      }
      else {
         newTypeInfo = param.scope.getTypeInfo(
            self.txt, param.scope, false, param.scopeAccess );
         when! newTypeInfo {
            param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
            newTypeInfo.$typeId.set_orgId( self.typeId );
         } else {
            foreach val, key in self._toMap() {
               Util.errorLog( "error: illegal self %s:%s" ( key, val ) );
            }
         }
      }
      return newTypeInfo, nil;
   }
}

class _TypeInfoEnum extend _TypeInfo {
   pub let parentId: int;
   pub let txt:str;
   pub let accessMode:Ast.AccessMode;
   pub let valTypeId:int;
   pub let enumValList: Map<str,stem>;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let accessMode = unwrap Ast.AccessMode._from( self.accessMode );
      //let parentInfo = unwrap param.typeId2TypeInfo[ self.parentId ];
      let mut parentTypeDataAccessor, parentInfo =
         param.getTypeDataAccessor( self.parentId );
      let mut parentScope = unwrap param.typeId2Scope[ self.parentId ];
      let mut scope = new Ast.Scope( param.processInfo, parentScope, .Class, nil ## );

      param.typeId2Scope[ self.typeId ] = scope;
      let valTypeInfo = unwrap param.getTypeInfo( self.valTypeId );
      let mut enumTypeInfo = param.processInfo.createEnum(
         scope, parentInfo, parentTypeDataAccessor,
         true, accessMode, self.txt, valTypeInfo );
      let newTypeInfo = enumTypeInfo;
      param.typeId2TypeInfo[ self.typeId ] = enumTypeInfo;
      param.typeId2TypeDataAccessor[ self.typeId ] = enumTypeInfo;
      enumTypeInfo.$typeId.set_orgId( self.typeId );

      fn getEnumLiteral( val:stem ) : Ast.EnumLiteral! {
         switch valTypeInfo {
            case Ast.builtinTypeInt {
               return Ast.EnumLiteral.Int( val@@int );
            }
            case Ast.builtinTypeReal {
               return Ast.EnumLiteral.Real( val@@real );
            }
            case Ast.builtinTypeString {
               return Ast.EnumLiteral.Str( val@@str );
            }
         }
         return nil;
      }
      foreach valData, valName in self.enumValList {
         let! val = getEnumLiteral( valData ) {
            return nil, "unknown enum val type -- %s" (valTypeInfo.getTxt(##));
         };
         let evalValSym = unwrap scope.addEnumVal(
            param.processInfo, valName, nil, enumTypeInfo );
         enumTypeInfo.addEnumValInfo( new Ast.EnumValInfo( valName, val, evalValSym ) );
      }
      parentScope.addEnum( param.processInfo, accessMode, self.txt, nil, enumTypeInfo );
      return newTypeInfo, nil;
   }
}

class _TypeInfoAlgeVal extend (Mapping) {
   pub let name:str;
   pub let typeList:&List<&_IdInfo>;
}

class _TypeInfoAlge extend _TypeInfo {
   pub let parentId: int;
   pub let txt:str;
   pub let accessMode:Ast.AccessMode;
   pub let algeValList: &List<&_TypeInfoAlgeVal>;
   pub let itemTypeId:&List<&_IdInfo>;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let accessMode = unwrap Ast.AccessMode._from( self.accessMode );
      //let parentInfo = unwrap param.typeId2TypeInfo[ self.parentId ];
      let mut parentTypeDataAccessor, parentInfo =
         param.getTypeDataAccessor( self.parentId );
      //let mut name2AlgeValInfo:Map<str,Ast.AlgeValInfo> = {};
      let mut parentScope = unwrap param.typeId2Scope[ self.parentId ];
      let mut scope = new Ast.Scope(
         param.processInfo, parentScope, .Class, nil ## );

      let itemTypeInfo:List<&Ast.TypeInfo> = [];
      foreach typeId in self.itemTypeId {
         //itemTypeInfo.insert( unwrap param.typeId2TypeInfo[ typeId ] );
         itemTypeInfo.insert( unwrap param.getTypeInfoFrom( typeId ) );
      }
      
      param.typeId2Scope[ self.typeId ] = scope;
      let mut algeTypeInfo = param.processInfo.createAlge(
         scope, parentInfo, parentTypeDataAccessor, true, accessMode, self.txt,
         itemTypeInfo );
      let newTypeInfo = algeTypeInfo;
      param.typeId2TypeInfo[ self.typeId ] = algeTypeInfo;
      param.typeId2TypeDataAccessor[ self.typeId ] = algeTypeInfo;

      algeTypeInfo.$typeId.set_orgId( self.typeId );
      foreach valInfo in self.algeValList {
         let mut typeInfoList:List<&Ast.TypeInfo> = [];
         foreach orgTypeId in valInfo.typeList {
            //typeInfoList.insert( unwrap param.typeId2TypeInfo[ orgTypeId ] );
            typeInfoList.insert( unwrap param.getTypeInfoFrom( orgTypeId ) );
         }
         let algeValSym = scope.addAlgeVal(
            param.processInfo, valInfo.name, nil, algeTypeInfo );
         let algeVal = new Ast.AlgeValInfo(
            valInfo.name, typeInfoList, algeTypeInfo, unwrap algeValSym );
         algeTypeInfo.addValInfo( algeVal );
      }
      parentScope.addAlge( param.processInfo, accessMode, self.txt, nil, algeTypeInfo );
      return newTypeInfo, nil;
   }
}

class _TypeInfoTuple extend _TypeInfo {
   pub let parentId: int;
   pub let accessMode:Ast.AccessMode;
   pub let itemTypeId:&List<&_IdInfo>;

   pro override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let accessMode = unwrap Ast.AccessMode._from( self.accessMode );
      //let parentInfo = unwrap param.typeId2TypeInfo[ self.parentId ];
      // let mut parentTypeDataAccessor, parentInfo =
      //    param.getTypeDataAccessor( self.parentId );
      //let mut name2TupleValInfo:Map<str,Ast.TupleValInfo> = {};
      let mut parentScope = unwrap param.typeId2Scope[ self.parentId ];
      let mut scope = new Ast.Scope(
         param.processInfo, parentScope, .Class, nil ## );

      let itemTypeInfo:List<&Ast.TypeInfo> = [];
      foreach typeId in self.itemTypeId {
         //itemTypeInfo.insert( unwrap param.typeId2TypeInfo[ typeId ] );
         itemTypeInfo.insert( unwrap param.getTypeInfoFrom( typeId ) );
      }
      
      param.typeId2Scope[ self.typeId ] = scope;
      let mut tupleTypeInfo = param.processInfo.createTuple(
         true, accessMode, itemTypeInfo );
      let newTypeInfo = tupleTypeInfo;
      param.typeId2TypeInfo[ self.typeId ] = tupleTypeInfo;
      param.typeId2TypeDataAccessor[ self.typeId ] = tupleTypeInfo;

      tupleTypeInfo.$typeId.set_orgId( self.typeId );

      return newTypeInfo, nil;
   }
}

/**
modulePath で指定されたモジュールからメタ情報を読み込み、型情報を反映する。

@param modulePath モジュール名。 例: 'hoge.foo.bar'
@return 読み込んだメタ情報
@return メタ情報内の typeId -> TypeInfo の Map
@return インポート後の typeId -> メタ情報内の typeId の Map
*/
class DependModuleInfo {
   let id:int;
   let metaTypeId2TypeInfoMap:&Map<int,&Ast.TypeInfo>;

   pub fn getTypeInfo( metaTypeId:int ):&Ast.TypeInfo {
      return unwrap self.metaTypeId2TypeInfoMap[ metaTypeId ];
   }
}

pub class ModuleLoaderParam {
   let ctrl_info: &Types.TransCtrlInfo {pub};
   let processInfo:&Ast.ProcessInfo {pub};
   let latestPos:&Tokenizer.Position {pub};
   let macroMode:str {pub};
   let nearCode:str! {pub};
   let validMutControl:bool {pub};
   let macroEval:&Nodes.MacroEval {pub};
}

form LoaderFunc() __async;
// 非同期化できるように準備をしておくが、
// ここで単純に非同期化すると大量のスレッドが出来てしまいそうなので、
// 形だけ作っておく。

class ModuleLoaderResult {
   local let mut exportInfo:&frontInterface.ExportInfo! {pub};
   local let modulePath:str;
   local let fullModulePath:str;
   local let baseDir:str!;
   local let mut err:str;
   local let depth:int;
   /**
インポートしているモジュール内で定義している alias 情報。

alias で置き換えている元の Type → alias の型
   */
   local let importedAliasMap: Map<&Ast.TypeInfo,&Ast.AliasTypeInfo>;
}

pub class ModuleLoader extend Runner.Runner(frontInterface.ModuleLoader) {
   let mut moduleMeta:frontInterface.ModuleMeta!;
   let result:ModuleLoaderResult;
   let validMutControl:bool;
   let curPos:&Tokenizer.Position;
   let moduleLoaderParam:&ModuleLoaderParam;
   let mut importModuleInfo:frontInterface.ImportModuleInfo;
   let fullModulePath:str;
   
   let macroCtrl:Macro.MacroCtrl;
   

   let transUnitIF:TransUnitIF.TransUnitIF;
   let globalScope:Ast.Scope;
   
   let loaderFunc:LoaderFunc;
   let importProcessInfo:Ast.ProcessInfo;
   let mut syncFlag:__lns.Sync.Flag!;
   let frontAccessor:frontInterface.FrontAccessor;

   fn processImportFromFile(
      processInfo:Ast.ProcessInfo, lnsPath:str, metaInfoStem:Luaval<&stem>,
      fullModulePath:str, mut modulePath:str, nameList:&List<str>,
      baseDir:str!, depth:int ) mut : &frontInterface.ModuleInfo!, str;
   fn processImportMain(
      processInfo:Ast.ProcessInfo, baseDir:str!,
      mut modulePath:str, depth:int ) mut : ModuleLoader;

   fn applyExportInfo( exportInfo:&frontInterface.ExportInfo! ) mut {
      when! exportInfo {
         if! let work = exportInfo@@@Nodes.ExportInfo {
            self.macroCtrl.importMacroInfo( work.$typeId2DefMacroInfo );
         }
         foreach val, key in exportInfo.$importedAliasMap {
            self.result.importedAliasMap[key] = val;
         }
      }
   }

   
   fn craeteModuleInfo(
      moduleMeta:frontInterface.ModuleMeta ) mut : &frontInterface.ExportInfo!, str
   {
      _match moduleMeta.$metaOrModule {
         case .Module( _, exportInfo ) {
            self.applyExportInfo( exportInfo );
            return exportInfo, "";
         }
         case .Export( exportInfo ) {
            self.applyExportInfo( exportInfo );
            return exportInfo, "";
         }
         case .MetaRaw( metaInfo ) {
            self.importModuleInfo.add( self.result.modulePath );
            self.importProcessInfo.switchIdProvier( .Ext );

            let mut nameList = Util.splitStr(self.result.modulePath, '[^%./:]+' );

            let! moduleInfo, err = self.processImportFromFile(
               self.importProcessInfo, moduleMeta.$lnsPath, metaInfo,
               self.result.fullModulePath, self.result.modulePath,
               nameList, self.result.baseDir, self.result.depth )
            {
               return nil, err;
            };

            self.importProcessInfo.switchIdProvier( .Base );
            self.importModuleInfo.remove();
            
            return moduleInfo.$exportInfo, "";
         }
      }
   }

   
   pub fn __init(
      frontAccessor:frontInterface.FrontAccessor,
      enableAsync:bool, exportInfo:&frontInterface.ExportInfo!,
      workImportModuleInfo: &frontInterface.ImportModuleInfo,
      modulePath:str, fullModulePath:str, baseDir:str!,
      moduleLoaderParam:&ModuleLoaderParam,
      depth:int ) __async
   {
      super();

      self.frontAccessor = frontAccessor;
      self.syncFlag = nil;
      self.moduleLoaderParam = moduleLoaderParam;
      self.result = new ModuleLoaderResult( 
         exportInfo, 
         modulePath,
         fullModulePath,
         baseDir,
         "",
         depth,
         {} );
      
      self.moduleMeta = nil;
      self.validMutControl = moduleLoaderParam.$validMutControl;
      self.curPos = moduleLoaderParam.$latestPos;
      self.macroCtrl = new Macro.MacroCtrl(
         moduleLoaderParam.$macroEval,
         moduleLoaderParam.$ctrl_info.validMacroAsync, frontAccessor );
      self.importModuleInfo = workImportModuleInfo.clone();
      self.fullModulePath = fullModulePath;

      self.importProcessInfo = moduleLoaderParam.$processInfo.newUser();

      let mut simpleTransUnit = new TransUnitIF.SimpeTransUnit(
         moduleLoaderParam.$ctrl_info, self.importProcessInfo,
         moduleLoaderParam.$latestPos,
         moduleLoaderParam.$macroMode, moduleLoaderParam.$nearCode );

      self.transUnitIF = simpleTransUnit;
      self.globalScope = simpleTransUnit.$globalScope;
      

      self.loaderFunc = fn () __async {
         if not self.result.exportInfo {
            if not self.importModuleInfo.add( fullModulePath ) {
               self.result.err = "recursive import: %s -> %s"
               ( self.importModuleInfo.getFull(), fullModulePath );
            } else {
               __asyncLock {
                  if! self.frontAccessor.loadMeta(
                     self.importModuleInfo.clone(), modulePath,
                     fullModulePath, baseDir, self )
                  {
                     let mut moduleMeta = _exp;
                     self.result.exportInfo, self.result.err =
                        self.craeteModuleInfo( moduleMeta );
                  } else {
                     self.result.err = "failed to load meta -- %s on %s"
                     (  fullModulePath, baseDir or "./" );
                  }
               }
               self.importModuleInfo.remove();
            }
         }
      };

      if enableAsync {
         self.start( __lns.runMode.Sync, "ModuleLoader - %s" (fullModulePath) );
      } else {
         // loaderFunc() を実行中に、別のスレッドで LoadMeta されると、
         // loaderFunc() が終わっていないので、 getExportInfo() が nil になってしまう。
         // また、 runner は動いていないので __join は素通しされる。
         // 仮に事前に start させて __join が素通しされないようにしても、
         // その場合、いつまで runMain() 処理を持続させるかで flag が必要になる。
         // それなら、 runner を無駄に起動させずに、 flag をここでセットする。
         self.syncFlag = __lns.Sync.createFlag();
         self.loaderFunc();
         self.syncFlag$.set$();
      }
   }

   pro override fn runMain() __async mut {
      self.loaderFunc();
   }

   local fn getResult() mut : &ModuleLoaderResult {
      __join( self );
      self.syncFlag$.wait$();
      
      return self.result;
   }

   pub fn getExportInfo() __async mut : &frontInterface.ExportInfo! {
      __join( self );
      self.syncFlag$.wait$();
      
      if not self.result.$exportInfo {
         Log._log2( Log.Level.Err,
                    "exportInfo is nil -- %s" (self.fullModulePath) );
      }
      return self.result.$exportInfo;
   }
}

fn ModuleLoader.processImportFromFile(
   processInfo:Ast.ProcessInfo, lnsPath:str, metaInfoStem:Luaval<&stem>,
   fullModulePath:str, mut modulePath:str,
   nameList:&List<str>, baseDir:str!, depth:int ) mut
: &frontInterface.ModuleInfo!, str
{
   let mut dependLibId2DependInfo:Map<int,&frontInterface.ExportInfo> = {};
   let mut err:str! = nil;
   let metaInfo;
   __luago {
      metaInfo = metaInfoStem@@=Meta._MetaInfo;
      Log._log2( .Info, "%s processing" (fullModulePath) );



      // 依存するモジュールのメタ情報を読み込み
      {
         let loaderMap:Map<ModuleLoader,int> = {};
         forsort dependInfo, dependName in metaInfo.__dependModuleMap {
            let mut workProcessInfo = processInfo.newUser();
            let mut moduleLoader = self.processImportMain(
               workProcessInfo, baseDir, dependName, depth + 1 );
            let typeId = (unwrap dependInfo.typeId)@@int;
            loaderMap[ moduleLoader ] = typeId;
         }
         foreach typeId, moduleLoader in loaderMap {
            let result = moduleLoader.getResult();
            if! result.exportInfo {
               self.applyExportInfo( _exp );
               dependLibId2DependInfo[ typeId ] = _exp;
            } else {
               err = result.err;
               break;
            };
         }
      }
   }
   when! err { 
      return nil, err;
   }

   let moduleInfo:&frontInterface.ModuleInfo;
   __luago {
      // 型情報の登録
      
      // meta情報内の typeId -> typeInfo
      let mut typeId2TypeInfo: Map<int,&Ast.TypeInfo> = {};
      let mut typeId2TypeDataAccessor: Map<int,Ast.TypeDataAccessor> = {};
      //typeId2TypeInfo[ Ast.builtinRootId ] = Ast.headTypeInfo;
      typeId2TypeInfo[ Ast.userRootId ] = processInfo.$dummyParentType;
      let mut typeId2Scope: Map<int,Ast.Scope> = {};
      typeId2Scope[ Ast.userRootId ] = processInfo.$topScope;

      // 依存するモジュールの typeInfo と、 meta 情報内の typeId との紐付け
      foreach dependIdInfo, typeId in metaInfo.__dependIdMap {
         let dependInfo = unwrap dependLibId2DependInfo[ unwrap dependIdInfo[ 1 ] ];
         let typeInfo = unwrap dependInfo.getTypeInfo( unwrap dependIdInfo[ 2 ] );
         typeId2TypeInfo[ typeId ] = typeInfo;
         // 依存モジュールのスコープに mutable でアセスすることはない
         // if! Ast.getScope( typeInfo ) {
         //    typeId2Scope[ typeId ] = _exp;
         // }
      }

      let mut moduleTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
      foreach moduleName, index in nameList {
         let mut mutable = false;
         if index == #nameList {
            mutable = metaInfo.__moduleMutable;
         }
         let mut nsInfo = self.transUnitIF.pushModule(
            processInfo, true, moduleName, mutable );
         moduleTypeInfo = nsInfo.$typeInfo;
         let typeId = unwrap metaInfo.__moduleHierarchy[ #nameList - index + 1 ];
         typeId2TypeInfo[ typeId ] = moduleTypeInfo;
         typeId2TypeDataAccessor[ typeId ] = nsInfo.$typeDataAccessor;
         typeId2Scope[ typeId ] = self.transUnitIF.$scope;
      }
      foreach _ in nameList {
         self.transUnitIF.popModule();
      }

      //self.moduleName2Info[ fullModulePath ] = metaInfo;

      foreach symbolInfo in Ast.getSym2builtInTypeMap() {
         typeId2TypeInfo[ symbolInfo.$typeInfo.get_typeId().id ] = symbolInfo.$typeInfo;
      }
      foreach builtinTypeInfo in Ast.getBuiltInTypeIdMap() {
         let typeInfo = builtinTypeInfo.$typeInfo;
         typeId2TypeInfo[ typeInfo.$typeId.id ] = typeInfo;
      }


      let mut newId2OldIdMap: Map<&Ast.TypeInfo,int> = {};

      let mut _typeInfoList:List<_TypeInfo> = [];
      let mut id2atomMap:Map<int,_TypeInfo> = {};
      let mut _typeInfoNormalList:List<_TypeInfoNormal> = [];
      foreach atomInfoLua in metaInfo.__typeInfoList {
         let! workAtomInfo = expandLuavalMap( atomInfoLua ) { 
            self.transUnitIF.error( "illegal atomInfo" ); // バグ
         };
         let atomInfo = workAtomInfo@@_Map<str,&stem>;
         if! let skind = atomInfo.skind {
            let mut actInfo:_TypeInfo! = nil;
            let mut mess:str! = nil;
            let kind = unwrap Ast.SerializeKind._from( skind@@int );
            _switch kind {
               case .Enum {
                  actInfo, mess = _TypeInfoEnum._fromMap( atomInfo );
               }
               case .Alge {
                  actInfo, mess = _TypeInfoAlge._fromMap( atomInfo );
                  //self.helperInfo.useAlge = true;
               }
               case .Tuple {
                  actInfo, mess = _TypeInfoTuple._fromMap( atomInfo );
               }
               case .Module {
                  actInfo, mess = _TypeInfoModule._fromMap( atomInfo );
               }
               case .Normal {
                  let workInfo;
                  workInfo, mess = _TypeInfoNormal._fromMap( atomInfo );
                  when! workInfo {
                     _typeInfoNormalList.insert( workInfo );
                  }
                  actInfo = workInfo;
               }
               case .Nilable {
                  actInfo, mess = _TypeInfoNilable._fromMap( atomInfo );
               }
               case .Alias {
                  actInfo, mess = _TypeInfoAlias._fromMap( atomInfo );
               }
               case .DDD {
                  actInfo, mess = _TypeInfoDDD._fromMap( atomInfo );
               }
               case .Alternate {
                  actInfo, mess = _TypeInfoAlternate._fromMap( atomInfo );
               }
               case .Generic {
                  actInfo, mess = _TypeInfoGeneric._fromMap( atomInfo );
               }
               case .Modifier {
                  actInfo, mess = _TypeInfoModifier._fromMap( atomInfo );
               }
               case .Box {
                  actInfo, mess = _TypeInfoBox._fromMap( atomInfo );
               }
               case .Ext {
                  actInfo, mess = _TypeInfoExt._fromMap( atomInfo );
               }
            }
            when! actInfo {
               _typeInfoList.insert( actInfo );
               id2atomMap[ actInfo.typeId ] = actInfo;
            }
            else {
               foreach val, key in atomInfo {
                  Util.errorLog( "table: %s:%s" (key,val) );
               }
               when! mess {
                  Util.errorLog( mess );
               }
               Util.err( "_TypeInfo.%s._fromMap error" (kind.$_txt) ); // バグ
            }
         }
      }


      let mut orgId2MacroTypeInfo:Map<int,&Ast.TypeInfo> = {};

      let mut lazyModuleSet:Set<int> = (@);
      foreach typeId in metaInfo.__lazyModuleList {
         lazyModuleSet.add( typeId );
      }

      let modifier:TransUnitIF.Modifier =
         new TransUnitIF.Modifier( self.validMutControl, processInfo );
      
      
      // 初めに child 以外で TypeInfo を登録
      let mut importParam = new ImportParam(
         self.curPos, modifier, processInfo, typeId2Scope,
         typeId2TypeInfo, typeId2TypeDataAccessor, {},
         lazyModuleSet, metaInfo, self.transUnitIF.$scope,
         moduleTypeInfo, .Normal, id2atomMap, dependLibId2DependInfo );

      foreach atomInfo in _typeInfoList {
         let newTypeInfo, errMess = atomInfo.createTypeInfoCache( importParam );
         if! errMess {
            Util.err( "Failed to createType -- %s: %s(%d): %s" // バグ
                      ( fullModulePath, atomInfo.skind.$_txt, atomInfo.typeId, _exp ) );
         }
         when! newTypeInfo {
            if newTypeInfo.$kind == .Macro {
               orgId2MacroTypeInfo[ atomInfo.typeId ] = newTypeInfo;
            }
            if newTypeInfo.$kind == .Set {
               //self.helperInfo.useSet = true;
            }
            if newTypeInfo.$accessMode == .Global {
               switch newTypeInfo.$kind {
                  case .IF, .Class {
                     self.globalScope.addClass(
                        processInfo, newTypeInfo.$rawTxt, nil, newTypeInfo );
                  }
                  case .Func {
                     self.globalScope.addFunc(
                        processInfo,
                        nil, newTypeInfo, .Global, newTypeInfo.$staticFlag,
                        Ast.TypeInfo.isMut( newTypeInfo) );
                  }
                  case .Enum {
                     self.globalScope.addEnum(
                        processInfo, .Global, newTypeInfo.$rawTxt, nil, newTypeInfo );
                  }
                  case .Nilable {
                     ; // nop
                  }
                  default {
                     Util.err( "%s: not support kind -- %s" // バグ
                               (__func__, newTypeInfo.$kind.$_txt) );
                  }
               }
            }
         }
      }

      // 次に child を登録
      foreach atomInfo in _typeInfoNormalList {
         if #atomInfo.children > 0 {
            importParam.getTypeInfo( atomInfo.typeId );
            let mut scope = unwrap typeId2Scope[ atomInfo.typeId ];
            foreach childId in atomInfo.children {
               let! typeInfo = importParam.getTypeInfoFrom( childId ) {
                  Util.err( "not found childId -- %s, %d, %s(%d)" // バグ
                            (fullModulePath, childId.id,
                              atomInfo.txt, atomInfo.typeId ) );
               };
               let mut symbolKind = Ast.SymbolKind.Typ;
               let mut addFlag = true;
               switch typeInfo.$kind {
                  case .Func {
                     symbolKind = .Fun;
                  }
                  case .Form, .FormFunc {
                     symbolKind = .Typ;
                  }
                  case .Method {
                     symbolKind = .Mtd;
                  }
                  case .Class, .Module
                  {
                     symbolKind = .Typ;
                  }
                  case .Enum {
                     addFlag = false;
                  }
               }

               if addFlag {
                  scope.add(
                     processInfo, symbolKind, false, typeInfo.$kind == .Func,
                     typeInfo.getTxt(##), nil, typeInfo, typeInfo.$accessMode,
                     typeInfo.$staticFlag, typeInfo.$mutMode, true, false );
               }
            }
         }
      }

      // インポート後の TypeId と インポート前の TypeId の紐付け
      foreach typeInfo, typeId in typeId2TypeInfo {
         newId2OldIdMap[ typeInfo ] = typeId;
      }

      // メンバーの登録
      fn registMember( classTypeId: int ) {
         let mut skip = false;
         __luago {
            if metaInfo.__dependIdMap[ classTypeId ] {
               skip = true;
            }
         }
         if skip {
            return;
         }

         __luago {
            let mut classTypeInfo = unwrap typeId2TypeInfo[ classTypeId ];

            //let mut backupScope = self.scope;
            
            switch ( classTypeInfo.$kind ) {
               case .Class, .ExtModule {
                  let mut scope = unwrap typeId2Scope[ classTypeId ];
                  self.transUnitIF.pushClassScope(
                     self.curPos, classTypeInfo, scope );
                  
                  if! metaInfo.__typeId2ClassInfoMap[ classTypeId ] {
                     let! classInfo = expandLuavalMap( _exp ) {
                        self.transUnitIF.error( "illegal val" ); // バグ
                     };
                     foreach fieldInfo, fieldName in classInfo@@_Map<str,_Map<str,stem>> {
                        if! let typeId = _IdInfo._fromStem(
                           expandLuavalMap( fieldInfo.typeId ) )
                        {
                           let fieldTypeInfo =
                              unwrap importParam.getTypeInfoFrom( typeId );
                           let symbolInfo = self.transUnitIF.$scope.addMember(
                              processInfo, fieldName, nil, fieldTypeInfo,
                              unwrap Ast.AccessMode._from(
                                 (unwrap fieldInfo.accessMode)@@int ),
                              fieldInfo.staticFlag and true or false,
                              unwrap Ast.MutMode._from(
                                 (unwrap fieldInfo.mutMode)@@int ) );
                        }
                        else {
                           self.transUnitIF.error( "not found fieldInfo.typeId" ); // バグ
                        }
                     }
                  }
                  else {
                     self.transUnitIF.error( // バグ
                        "not found class -- %s: %d, %s"
                        (fullModulePath, classTypeId, classTypeInfo.getTxt(##)) );
                  }
               }
               case .Module {
                  self.transUnitIF.pushModuleLow(
                     processInfo, true, classTypeInfo.getTxt(##),
                     Ast.TypeInfo.isMut( classTypeInfo ) );
                  Log._log3(
                     .Debug,         
                     "push module -- %s, %s, %d, %d, %d"
                     ( classTypeInfo.getTxt(##),
                       self.transUnitIF.$scope.$ownerTypeInfo$.getFullName$(
                          Ast.defaultTypeNameCtrl,
                          self.transUnitIF.$scope, false ) or "nil",
                       self.transUnitIF.$scope.$ownerTypeInfo$.$typeId$.id or -1,
                       classTypeInfo.$typeId.id,
                       self.transUnitIF.$scope.$parent.$scopeId ) );
               }
            }

            foreach child in classTypeInfo.get_children() {
               if child.get_kind() == .Class or
                  child.get_kind() == .ExtModule or
                  child.get_kind() == .Module or
                  child.get_kind() == .IF
               {
                  let oldId = newId2OldIdMap[ child ];
                  if oldId {
                     registMember( unwrap oldId );
                  }
               }
            }

            switch classTypeInfo.$kind {
               case .Class, .ExtModule {
                  self.transUnitIF.popClass();
               }
               case .Module {
                  self.transUnitIF.popModule();
               }
            }
         }
      }
      foreach atomInfo in _typeInfoList {
         if! let workInfo = atomInfo@@@_TypeInfoNormal {
            if workInfo.parentId == Ast.userRootId {
               registMember( atomInfo.typeId );
            }
         } else {
            if! let workInfo = atomInfo@@@_TypeInfoModule {
               if workInfo.parentId == Ast.userRootId {
                  registMember( atomInfo.typeId );
               }
            }
         }
      }


      foreach moduleName, index in nameList {
         let mut mutable = false;
         if index == #nameList {
            mutable = metaInfo.__moduleMutable;
         }
         self.transUnitIF.pushModuleLow( processInfo, true, moduleName, mutable );
      }

      class VarNameInfo extend (Mapping) {
         pub let typeId:_IdInfo;
         pub let accessMode:Ast.AccessMode;
         pub let mutable:bool;
      }

      // 変数登録
      foreach varInfo, varName in metaInfo.__varName2InfoMap {
         //if! let typeId = _IdInfo._fromStem( expandLuavalMap( varInfo.typeId ) ) {
         if! let varNameInfo = VarNameInfo._fromStem( expandLuavalMap( varInfo ) ) {
            let typeId = varNameInfo.typeId;
            let mut scope;
            if varNameInfo.accessMode == Ast.AccessMode.Global {
               scope = self.globalScope;
            } else {
               scope = self.transUnitIF.$scope;
            }
            //scope = self.transUnitIF.$scope;

            scope.addExportedVar(
               processInfo, varNameInfo.mutable, varNameInfo.accessMode, varName,
               nil, unwrap importParam.getTypeInfoFrom( typeId ),
               varNameInfo.mutable and Ast.MutMode.Mut or Ast.MutMode.IMut );
         }
         else {
            self.transUnitIF.error( "illegal varInfo.typeId" ); // バグ
         }
      }

      // マクロ登録
      let importedMacroInfoMap:Map<&Ast.IdInfo,&Nodes.MacroInfo> = {};
      foreach macroInfoStem, orgTypeId in metaInfo.__macroName2InfoMap {
         self.macroCtrl.importMacro(
            processInfo, lnsPath,
            expandLuavalMap( macroInfoStem ), unwrap orgId2MacroTypeInfo[ orgTypeId ],
            typeId2TypeInfo, importedMacroInfoMap, baseDir );
      }

      let globalSymbolList:List<&Ast.SymbolInfo> = [];
      //foreach symbolInfo in self.transUnitIF.$scope.$symbol2SymbolInfoMap {
      foreach symbolInfo in self.globalScope.$symbol2SymbolInfoMap {
         if symbolInfo.$accessMode == .Global {
            globalSymbolList.insert( symbolInfo );
         }
      }

      foreach _ in nameList {
         self.transUnitIF.popModule();
      }

      if depth == 1 {
         // トランスコンパイル対象から直接インポートされている場合
         foreach val, key in importParam.importedAliasMap {
            self.result.importedAliasMap[key] = val;
         }
      }

      let moduleProvideInfo = new frontInterface.ModuleProvideInfo(
         unwrap typeId2TypeInfo[ metaInfo.__moduleTypeId ],
         unwrap Ast.SymbolKind._from( metaInfo.__moduleSymbolKind ),
         metaInfo.__moduleMutable );

      let mut exportInfo = new Nodes.ExportInfo(
         moduleTypeInfo, moduleProvideInfo, processInfo,
         globalSymbolList,
         importParam.importedAliasMap,
         frontInterface.ModuleId.createIdFromTxt( metaInfo.__buildId ),
         fullModulePath, nameList[#nameList], lnsPath, newId2OldIdMap,
         importedMacroInfoMap );
      
      moduleInfo = new frontInterface.ModuleInfo( exportInfo );
   }
   return moduleInfo, "";
}

pub class Import {
   let importModuleInfo: frontInterface.ImportModuleInfo;
   let moduleType: &Ast.TypeInfo;
   //let globalScope: Ast.Scope;
   let macroCtrl:Macro.MacroCtrl;
   let typeNameCtrl:&Ast.TypeNameCtrl;

   /**
インポートしているモジュールの TypeInfo -> シンボル情報。
import しているモジュールから、さらに import しているサブモジュールも含まれる。
   */ 
   let importModule2ExportInfo: Map<&Ast.TypeInfo,&frontInterface.ExportInfo> {pub&};
   /**
インポートしているモジュール内で定義している alias 情報。

alias で置き換えている元の Type → alias の型
   */
   let importedAliasMap: Map<&Ast.TypeInfo,&Ast.AliasTypeInfo>;
   let importModuleName2ModuleInfo: Map<str,&frontInterface.ExportInfo>;

   //let validMutControl: bool;

   //let curPos:&Tokenizer.Position;
   let baseDir:str!;
   let frontAccessor:frontInterface.FrontAccessor;
   
   pub fn __init( frontAccessor:frontInterface.FrontAccessor,
                  curPos:&Tokenizer.Position,
                  //transUnitIF:TransUnitIF.TransUnitBase,
                  importModuleInfo: frontInterface.ImportModuleInfo,
                  moduleType: &Ast.TypeInfo,
                  macroCtrl:Macro.MacroCtrl,
                  typeNameCtrl:&Ast.TypeNameCtrl,
                  importedAliasMap: Map<&Ast.TypeInfo,&Ast.AliasTypeInfo>,
                  baseDir:str!,
                  
                  validMutControl:bool ) __async
   {
      self.frontAccessor = frontAccessor;
      self.baseDir = baseDir;
      self.importModuleInfo = importModuleInfo;
      self.moduleType = moduleType;
      self.macroCtrl = macroCtrl;
      self.typeNameCtrl = typeNameCtrl;
      self.importedAliasMap = importedAliasMap;

      self.importModule2ExportInfo = {};
      self.importModuleName2ModuleInfo = {};
   }
}

pub fn Import.createModuleLoader(
   frontAccessor:frontInterface.FrontAccessor,
   mut baseDir:str!, mut modulePath:str,
   moduleLoaderParam:&ModuleLoaderParam, depth:int ) __async mut : ModuleLoader
{
   let fullModulePath;

   __asyncLock {
      //modulePath, baseDir, fullModulePath = frontInterface.getLuaModulePath( modulePath, baseDir );
      modulePath, baseDir, fullModulePath = self.frontAccessor.getLuaModulePath( modulePath, baseDir );
   }
   
   Log._log( .Info, `{ return "%s -> %s start on %s"
                       ( self.moduleType.getTxt( self.typeNameCtrl## ),
                         fullModulePath, baseDir); } );


   let mut exportInfo = self.importModuleName2ModuleInfo[ fullModulePath ];

   when! exportInfo {
      Log._log( .Info, `{ return "%s already" (fullModulePath); } );

      if depth == 1 {
         self.importModule2ExportInfo[ exportInfo.$moduleTypeInfo ] = exportInfo;
      }
      
      foreach val, key in exportInfo.$importedAliasMap {
         self.importedAliasMap[key] = val;
      }
   }


   return new ModuleLoader(
      frontAccessor, false, exportInfo, self.importModuleInfo,
      modulePath, fullModulePath, baseDir, moduleLoaderParam, depth );
}



pub fn Import.loadModuleInfo( moduleLoader:ModuleLoader ) mut :
   &frontInterface.ExportInfo!, str
{
   let result = moduleLoader.getResult();
   
   let! mut exportInfo = result.exportInfo {
      return nil, result.$err;
   };
   
   let fullModulePath = result.$fullModulePath;
   let depth = result.$depth;
   


   if! let work = exportInfo@@@Nodes.ExportInfo {
      self.macroCtrl.importMacroInfo( work.$typeId2DefMacroInfo );
   }
   foreach val, key in exportInfo.$importedAliasMap {
      self.importedAliasMap[key] = val;
   }
   foreach val, key in result.importedAliasMap {
      self.importedAliasMap[key] = val;
   }
   

   
   if depth == 1 {
      self.importModule2ExportInfo[ exportInfo.$moduleTypeInfo ] = exportInfo;
   }
   self.importModuleName2ModuleInfo[ fullModulePath ] = exportInfo;

   
   Log._log( .Info, `{ return "%s complete" (fullModulePath); } );

   return exportInfo, "";
}

fn ModuleLoader.processImportMain(
   processInfo:Ast.ProcessInfo, mut baseDir:str!,
   mut modulePath:str, depth:int ) mut : ModuleLoader
{
   let fullModulePath;
   modulePath, baseDir, fullModulePath =
      self.frontAccessor.getLuaModulePath( modulePath, baseDir );
      //frontInterface.getLuaModulePath( modulePath, baseDir );
   
   Log._log( .Info, `{ return "%s -> %s start on %s"
                       ( self.result.fullModulePath, fullModulePath, baseDir); } );


   let mut moduleLoader = new ModuleLoader(
      self.frontAccessor, false, nil, self.importModuleInfo,
      modulePath, fullModulePath, baseDir, self.moduleLoaderParam, depth );
   return moduleLoader;
}

pub fn Import.processImport(
   modulePath:str, moduleLoaderParam:&ModuleLoaderParam ) __async mut : ModuleLoader
{
   let mut moduleLoader = self.createModuleLoader(
      self.frontAccessor, self.baseDir, modulePath, moduleLoaderParam, 1 );

   return moduleLoader;
}
