/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Ast;
import lune.base.Util;
import lune.base.TransUnit;
import lune.base.frontInterface;
import lune.base.LuaMod;

class PubVerInfo {
   pub let staticFlag: bool;
   pub let accessMode: Ast.AccessMode;
   pub let mutable:bool;
   pub let typeInfo: &Ast.TypeInfo;
};

class PubFuncInfo {
   pub let accessMode: Ast.AccessMode;
   pub let typeInfo: &Ast.TypeInfo;
}

pub enum ConvMode {
   /** lns ソースを実行する */
   Exec,
   /** lua への変換を行なう */
   Convert,
   /** lua への変換と、 Meta 情報生成を行なう */
   ConvMeta,
}

let hasBitOpFlag = _VERSION.gsub( "^[^%d]+", "" ).find( "^5%.3" ) ~= nil;

enum BitOpKind {
   And,
   Or,
   Xor,
   LShift,
   RShift,
}

let bitBinOpMap = {
   "&": BitOpKind.And,
   "|": BitOpKind.Or,
   "~": BitOpKind.Xor,
   "|>>": BitOpKind.RShift,
   "|<<": BitOpKind.LShift,
};

class convFilter extend Ast.Filter (oStream) {
   pri let streamName: str;
   pri let mut stream: oStream;
   pri let mut metaStream: oStream;
   pri let mut outMetaFlag: bool;
   pri let mut typeInfo2ModuleName: Map<&Ast.TypeInfo,str>;
   pri let convMode: ConvMode;
   pri let inMacro: bool;
   pri let mut indentQueue: List<int>;
   pri let mut curLineNo: int;
   // クラス TypeId → TypeInfo
   pri let mut classId2TypeInfo: Map<int,&Ast.TypeInfo>;
   // クラス TypeId → Member Node List
   pri let mut classId2MemberList: Map<str,List<&Ast.DeclMemberNode>>;
   // enum TypeId -> EnumTypeInfo
   pri let mut pubEnumId2EnumTypeInfo: Map<int,&Ast.EnumTypeInfo>;
   // public 変数名 → 変数情報
   pri let mut pubVarName2InfoMap: Map<str,PubVerInfo>;
   // public 関数名 → 関数情報
   pri let mut pubFuncName2InfoMap: Map<str,PubFuncInfo>;
   pri let mut needIndent: bool;
   pri let mut macroDepth: int;
   pri let mut macroVarSymMap: Map<&Ast.SymbolInfo,bool>;
   pri let moduleTypeInfo: &Ast.TypeInfo;
   pri let moduleSymbolKind: Ast.SymbolKind;
   pri let mut needModuleObj: bool;
   pri let separateLuneModule: bool;

   
   pub fn __init( streamName: str, stream: oStream, metaStream: oStream,
                  convMode: ConvMode, inMacro: bool, moduleTypeInfo: &Ast.TypeInfo,
                  moduleSymbolKind: Ast.SymbolKind, separateLuneModule:bool ) 
   {
      //Util.errorLog( "__init: %s" (mode) );
      self.macroVarSymMap = {};
      self.needModuleObj = true;
      self.indentQueue = [ 0 ];
      self.moduleSymbolKind = moduleSymbolKind;
      self.macroDepth = 0;
      self.streamName = streamName;
      self.stream = stream;
      self.metaStream = metaStream;
      self.outMetaFlag = false;
      self.typeInfo2ModuleName = {};
      self.convMode = convMode;
      self.inMacro = inMacro;
      self.curLineNo = 1;
      self.classId2TypeInfo = {};
      self.classId2MemberList = {};
      self.pubVarName2InfoMap = {};
      self.pubFuncName2InfoMap = {};
      self.pubEnumId2EnumTypeInfo = {};
      self.needIndent = false;
      self.moduleTypeInfo = moduleTypeInfo;
      self.separateLuneModule = separateLuneModule;
   }

   fn get_indent(): int {
      if #self.indentQueue > 0 {
         return self.indentQueue[ #self.indentQueue ];
      }
      return 0;
   }

   fn getFullName( typeInfo:&Ast.TypeInfo ): str {
      let mut enumName = typeInfo.getFullName( self.typeInfo2ModuleName, true );
      return "%s" (enumName.gsub( "&", "" ) );
   }

   fn getCanonicalName( typeInfo:&Ast.TypeInfo ): str {
      return self.getFullName( typeInfo );
   }

   pub fn close() mut {
   }
   pub fn flush() mut {
   }
   pub fn writeRaw( txt: str ) mut {
      let mut stream = self.stream;
      if self.outMetaFlag {
         stream = self.metaStream;
      }  
      
      if self.needIndent {
         stream.write( string.rep( " ", self.$indent ) );
         self.needIndent = false;
      }  

      apply cr of string.gmatch( txt, "\n" ) {
         self.curLineNo = self.curLineNo + 1;
      }
      stream.write( txt );
   }

   pub fn write( mut txt: str ) mut {
      while true {
         if! let index = string.find( txt, "\n" ) {
            self.writeRaw( txt.sub( 1, index ) );
            txt = txt.sub( index + 1 );
         }
         else {
            break;
         }
      }
      if #txt > 0 {
         self.writeRaw( txt );
      }
   }
}

fn filter( node: &Ast.Node, filter: convFilter,
           parent: &Ast.Node )
{
   node.processFilter( filter, parent );
}

let stepIndent = 3;

let mut builtInModuleSet:Map<str,bool> = {};
builtInModuleSet[ "io" ] = true;
builtInModuleSet[ "string" ] = true;
builtInModuleSet[ "table" ] = true;
builtInModuleSet[ "math" ] = true;
builtInModuleSet[ "debug" ] = true;
//builtInModuleSet[ "_luneScript" ] = true;


fn convFilter.pushIndent( newIndent:int! ) mut {
   let indent = unwrap newIndent default self.$indent + stepIndent;
   self.indentQueue.insert( indent );
}

fn convFilter.popIndent() mut {
   if #self.indentQueue == 0 {
      Util.err( "self.indentQueue == 0" );
   }
   self.indentQueue.remove();
}


fn convFilter.writeln( txt: str ) mut {
   self.write( txt );
   self.write( "\n" );
   self.needIndent = true;
}

pub override fn convFilter.processNone(
   node: Ast.NoneNode, parent: &Ast.Node ) mut 
{
   //self.writeln( "-- none" );
};

pub override fn convFilter.processImport( 
   node: Ast.ImportNode, parent: &Ast.Node ) mut
{
   let module = node.get_modulePath();
   let moduleName = string.gsub( module, ".*%.", "" );
   self.typeInfo2ModuleName[ node.$moduleTypeInfo ] = module;
   //if self.convMode == "exe" or self.convMode == "ast" {
   if self.convMode == .Exec {
      self.write(
         "local %s = __luneScript:loadModule( '%s' )" ( moduleName, module) );
   }
   else {
      self.write( "local %s = require( '%s' )" ( moduleName, module ) );
   }
};


/**
メタ情報を出力する。

メタ情報は次の情報から成る。

- モジュールが依存(import)している外部モジュール情報
  - 外部モジュール識別番号
  - 外部モジュール名
  - このモジュールが公開している型の一部に、外部モジュールの情報を利用しているかどうか
- モジュール内で定義している pub な型情報
- モジュールが利用している外部モジュール内の型情報
  - 外部モジュール識別番号
  - このモジュール内の型識別番号
  - 外部モジュール内の型識別番号

@param node RootNode
*/
fn convFilter.outputMeta( node: Ast.RootNode ) mut
{
   if self.convMode == .Convert {
      return;
   }
   // switch self.convMode {
   //    case "lua", "save" {
   //       return;
   //    }
   // }

   self.outMetaFlag = true;

   if self.stream ~= self.metaStream {
      self.writeln( "local _moduleObj = {}" );
   }
   
   self.writeln( "----- meta -----" );

   let mut importModuleType2Index:Map<&Ast.TypeInfo,int> = {};
   let mut importNameMap:Map<str,&Ast.TypeInfo> = {};
   {
      // foreach importName, typeInfo in self.typeInfo2ModuleName {
      //    importNameMap[ importName ] = typeInfo;
      // }

      foreach moduleInfo, typeInfo in node.$importModule2moduleInfo {
         importNameMap[ moduleInfo.$fullName ] = typeInfo;
      }
      
      let mut index = 0;
      forsort typeInfo, importName in importNameMap {
         index = index + 1;
         importModuleType2Index[ typeInfo ] = index;
      }
   }

   let mut typeId2TypeInfo: Map<int,Ast.TypeInfo> = {};
   let mut typeId2UseFlag: Map<int,bool> = {};


   let mut pickupClassMap: Map<int,Ast.TypeInfo> = {};

   fn checkExportTypeInfo( typeInfo:&Ast.TypeInfo ): bool! {
      let moduleTypeInfo = typeInfo.getModule();
      let typeId = typeInfo.$typeId;
      return typeId2TypeInfo[ typeId ] and not Ast.isBuiltin( typeId ) and
          ( moduleTypeInfo.hasRouteNamespaceFrom( node.$moduleTypeInfo ) or
            typeInfo.$srcTypeInfo ~= typeInfo or
            moduleTypeInfo.equals( Ast.headTypeInfo ) );
   }
   
   // 公開される型情報を typeId2TypeInfo にピックアップする
   fn pickupTypeId( typeInfo: &Ast.TypeInfo, forceFlag: bool!, pickupChildFlag: bool! ) {
      if typeInfo.get_typeId() == Ast.rootTypeId {
         return;
      }
      // if not forceFlag and typeInfo.get_accessMode() ~= .Pub {
      //    return;
      // }
      if not forceFlag and not Ast.isPubToExternal( typeInfo.$accessMode ) {
         return;
      }

      if typeId2TypeInfo[ typeInfo.get_typeId() ] {
         if pickupChildFlag and not typeInfo.$nilable {
	    foreach itemTypeInfo in typeInfo.get_children() {
               if Ast.isPubToExternal( itemTypeInfo.$accessMode ) and
                   ( itemTypeInfo.get_kind() == Ast.TypeInfoKind.Class or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.IF or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.Func or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.Method )
               {
                  pickupTypeId( itemTypeInfo, true, true );
               }
	    }
         }
         return;
      }

      typeId2TypeInfo[ typeInfo.get_typeId() ] = typeInfo;
      
      if typeInfo.$nilable {
	 pickupTypeId( typeInfo.get_orgTypeInfo(), true, false );
      }
      else {
         if typeInfo.$kind == Ast.TypeInfoKind.Class or
            typeInfo.$kind == Ast.TypeInfoKind.IF
         {           
            pickupClassMap[ typeInfo.$typeId ] = typeInfo;
         }

         let parentInfo = typeInfo.get_parentInfo();
         pickupTypeId( parentInfo, true, false );
         
         let baseInfo = typeInfo.get_baseTypeInfo();
         if baseInfo.$typeId ~= Ast.rootTypeId {
            pickupTypeId( baseInfo, true, true );
         }
         
	 let mut typeInfoList: &List<&Ast.TypeInfo> = typeInfo.get_itemTypeInfoList();
         if typeInfoList {
	    foreach itemTypeInfo in typeInfoList {
               pickupTypeId( itemTypeInfo, true, false );
	    }
         }
	 typeInfoList = typeInfo.get_argTypeInfoList();
         if typeInfoList {
	    foreach itemTypeInfo in typeInfoList {
               pickupTypeId( itemTypeInfo, true, false );
	    }
         }
	 typeInfoList = typeInfo.get_retTypeInfoList();
         if typeInfoList {
	    foreach itemTypeInfo in typeInfoList {
               pickupTypeId( itemTypeInfo, true, true );
	    }
         }
         if pickupChildFlag {
	    foreach itemTypeInfo in typeInfo.get_children() {
               if itemTypeInfo.$accessMode == .Pub and
                   ( itemTypeInfo.get_kind() == Ast.TypeInfoKind.Class or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.IF or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.Func or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.Method )
               {
                  pickupTypeId( itemTypeInfo, true, true );
               }
	    }
         }

         pickupTypeId( typeInfo.get_nilableTypeInfo(), true, false );
      }
   }

   let mut classId2TypeInfo:Map<int,&Ast.TypeInfo> = {};

   let mut validChildrenSet:Map<&Ast.TypeInfo, Map<int,&Ast.TypeInfo>> = {};

   {
      let mut typeInfo = self.moduleTypeInfo;
      while typeInfo ~= Ast.headTypeInfo {
         validChildrenSet[ typeInfo.$parentInfo ] = { typeInfo.$typeId: typeInfo };
         typeInfo = typeInfo.$parentInfo;
      }
      pickupTypeId( self.moduleTypeInfo, true );
   }
   
   let typeId2ClassMap = node.get_typeId2ClassMap();
   foreach namespaceInfo in typeId2ClassMap {
      if namespaceInfo.typeInfo.get_accessMode() == .Pub and
         not namespaceInfo.typeInfo.$externalFlag
      {
         pickupClassMap[ namespaceInfo.typeInfo.$typeId ] = namespaceInfo.typeInfo;
      }
   }
   classId2TypeInfo = self.classId2TypeInfo;

   self.writeln( "local _typeId2ClassInfoMap = {}" );
   self.writeln( "_moduleObj._typeId2ClassInfoMap = _typeId2ClassInfoMap" );

   forsort classTypeInfo, classTypeId in classId2TypeInfo {
      if classTypeInfo.$accessMode == .Pub {
         pickupTypeId( classTypeInfo, true,
                       validChildrenSet[ classTypeInfo ] == nil and
                       not classTypeInfo.$externalFlag );    
         pickupClassMap[ classTypeId ] = nil;

         self.writeln( "do" );
         self.pushIndent();
         self.writeln( "local _classInfo%d = {}" (classTypeId) );
         self.writeln( "_typeId2ClassInfoMap[ %d ] = _classInfo%d"
                       (classTypeId, classTypeId) );

         
         foreach memberNode in unwrap self.classId2MemberList[ classTypeId ] {
            if memberNode.$accessMode ~= .Pri {
               let memberName = memberNode.$name.txt;
               let memberTypeInfo:Ast.TypeInfo = memberNode.get_expType();
               self.writeln( "_classInfo%d.%s = {" ( classTypeId, memberName ) );
               self.writeln(
                  "  name='%s', staticFlag = %s, " ( memberName,
                                                     memberNode.$staticFlag ) ..
                  "accessMode = '%s', typeId = %d }"
                  ( memberNode.$accessMode, memberTypeInfo.get_typeId() ) );

               pickupTypeId( memberTypeInfo, true );
            }  
         }  

         self.popIndent();
         self.writeln( "end" );
      }
   }


   let mut pickupedClassMap: Map<int,Ast.TypeInfo> = {};
   while true {
      let mut workClassMap: Map<int,Ast.TypeInfo> = {};
      let mut hasWorkClassFlag = false;
      foreach classTypeInfo, classTypeId in pickupClassMap {
         if not pickupedClassMap[ classTypeId ] {
            pickupedClassMap[ classTypeId ] = classTypeInfo;
            workClassMap[ classTypeId ] = classTypeInfo;
            hasWorkClassFlag = true;
         }  
      }

      if not hasWorkClassFlag {
         break;
      }
      forsort classTypeInfo, classTypeId in workClassMap {
         let scope = unwrap classTypeInfo.$scope;

         if not Ast.isBuiltin( classTypeId ) {
            pickupTypeId( classTypeInfo, true,
                          validChildrenSet[ classTypeInfo ] == nil and
                          not classTypeInfo.$externalFlag );

            if checkExportTypeInfo( classTypeInfo ) {
               let className = classTypeInfo.getTxt();
               self.writeln( "do" );
               self.pushIndent();
               self.writeln( "local _classInfo%s = {}" (classTypeId) );
               self.writeln( "_typeId2ClassInfoMap[ %d ] = _classInfo%d"
                             ( classTypeId, classTypeId) );
               
               forsort symbolInfo, fieldName in scope.$symbol2SymbolInfoMap {
                  let typeInfo = symbolInfo.$typeInfo;
                  if symbolInfo.$kind == Ast.SymbolKind.Mbr or
                     symbolInfo.$kind == Ast.SymbolKind.Var //or
                  //symbolInfo.$kind == Ast.SymbolKind.Typ
                  {
                     if symbolInfo.$accessMode == .Pub {
                        self.writeln( "_classInfo%d.%s = {" ( classTypeId, fieldName ) );
                        self.writeln(
                           "  name='%s', staticFlag = %s, "
                           ( fieldName,  symbolInfo.$staticFlag ) ..
                           "accessMode = %d, typeId = %d }"
                           ( symbolInfo.$accessMode, typeInfo.get_typeId() ) );
                        pickupTypeId( typeInfo );
                     }
                  }
               }

               self.popIndent();
               self.writeln( "end" );
            }
         }
      }
   }

   self.writeln( "local _varName2InfoMap = {}" );
   self.writeln( "_moduleObj._varName2InfoMap = _varName2InfoMap" );

   forsort varInfo, varName in self.pubVarName2InfoMap {
      self.writeln( string.format( "_varName2InfoMap.%s = {", varName ) );
      self.writeln(
         "  name='%s', accessMode = %d, typeId = %d, mutable = %s }"
         ( varName, varInfo.accessMode, varInfo.typeInfo.$typeId, true ) );
      pickupTypeId( varInfo.$typeInfo, true );
   }

   forsort funcInfo, funcName in self.pubFuncName2InfoMap {
      pickupTypeId( funcInfo.$typeInfo, true );
   }

   self.writeln( "local _typeInfoList = {}" );
   self.writeln( "_moduleObj._typeInfoList = _typeInfoList" );
   
   let mut listIndex = 1;

   let mut wroteTypeIdSet:Map<int,bool> = {};
   fn outputTypeInfo( typeInfo: Ast.TypeInfo ) {
      switch typeInfo.$kind {
         case .Class, .IF {
            switch typeInfo.$accessMode {
               case .Pub, .Pro, .Global {
               }
               default {
                  Util.errorLog( "skip: %s %s"
                                 (self.getFullName( typeInfo )) );  
                  return;
               }
            }
         }
      }
      let typeId = typeInfo.get_typeId();
      if wroteTypeIdSet[ typeId ] {
         return;
      }
      wroteTypeIdSet[ typeId ] = true;
      if checkExportTypeInfo( typeInfo ) {
         self.write( "_typeInfoList[%d] = " (listIndex) );
         listIndex = listIndex + 1;

         let mut validChildren = validChildrenSet[ typeInfo ];
         if not validChildren {
            validChildren = typeId2TypeInfo;
         }
         typeInfo.serialize( self, validChildren );
      }
      else {
         // self.writeln( "--[[ %s, %s" ( moduleTypeInfo.getTxt(),
         //                               node.$moduleTypeInfo.getTxt() ), baseIndent );  
         // typeInfo.serialize( self, nil );
         // self.writeln( "]]", baseIndent );
      }
   }

   foreach typeInfo, typeId in self.pubEnumId2EnumTypeInfo {
      typeId2TypeInfo[ typeId ] = typeInfo;
   }


   self.writeln( "local _dependIdMap = {}" );
   self.writeln( "_moduleObj._dependIdMap = _dependIdMap" );
   let mut exportNeedModuleTypeInfo:Map<&Ast.TypeInfo,bool> = {};
   forsort typeInfo, typeId in typeId2TypeInfo {
      outputTypeInfo( typeInfo );
      let moduleTypeInfo = typeInfo.getModule();
      exportNeedModuleTypeInfo[ moduleTypeInfo ] = true;
      if! let moduleIndex = importModuleType2Index[ moduleTypeInfo ] {
         let moduleInfo = unwrap node.$importModule2moduleInfo[ moduleTypeInfo ];
         if! let extId = moduleInfo.$localTypeInfo2importIdMap[ typeInfo ] {
            let mut valid = false;
            if typeInfo.$srcTypeInfo ~= typeInfo {
               valid = true;
            }
            else {
               let mut orgTypeInfo:&Ast.TypeInfo = typeInfo;
               if typeInfo.$nilable {
                  orgTypeInfo = typeInfo.$orgTypeInfo;
               }
               switch orgTypeInfo.$kind {
                  case .IF, .Map, .Enum, .List, .Array, .Class, .Module {
                     valid = true;
                  }
                  // default {
                  //    Util.errorLog( "hoge: %s:%d(%s)"
                  //       ( typeInfo.getTxt(), typeInfo.$typeId, typeInfo.$kind.$_txt ) );
                  // }
               }
            }
            if valid {
               self.writeln(
                  // "_dependIdMap[ %d ] = { %d, %d }"
                  // ( typeInfo.$typeId, moduleIndex, extId ),
                  "_dependIdMap[ %d ] = { %d, %d } -- %s"
                  ( typeInfo.$typeId, moduleIndex, extId, typeInfo.getTxt() ) );
            }
         }
      }
   }

   self.writeln( "local _dependModuleMap = {}" );
   self.writeln( "_moduleObj._dependModuleMap = _dependModuleMap" );

   
   forsort moduleTypeInfo, name in importNameMap {
      self.writeln(
         "_dependModuleMap[ '%s' ] = { id = %d, use = %s }"
         ( name, unwrap importModuleType2Index[ moduleTypeInfo ],
           exportNeedModuleTypeInfo[ moduleTypeInfo ] or false ) );
   }
   
   let mut moduleTypeInfo = self.moduleTypeInfo;
   let mut moduleSymbolKind = Ast.SymbolKind.Typ;
   if! node.$provideNode {
      moduleTypeInfo = _exp.$symbol.$typeInfo;
      moduleSymbolKind = _exp.$symbol.$kind;
   }
   self.writeln( "_moduleObj._moduleTypeId = %d" (moduleTypeInfo.$typeId ) );
   self.writeln( "_moduleObj._moduleSymbolKind = %d" (moduleSymbolKind) );
   self.writeln( "_moduleObj._moduleMutable = %s" (moduleTypeInfo.$mutable ) );

   self.writeln( "----- meta -----" );

   if self.stream ~= self.metaStream {
      self.writeln( "return _moduleObj" );
   }

   self.outMetaFlag = false;
}

pub override fn convFilter.processRoot( 
   node: Ast.RootNode, parent: &Ast.Node ) mut
{
   self.writeln( "--%s" ( self.streamName ) );

   self.needModuleObj = node.$provideNode == nil;
   
   if self.needModuleObj {
      self.writeln( "local _moduleObj = {}" );
   }
   self.writeln(
      "local __mod__ = '%s'" (node.$moduleTypeInfo.getFullName({})) );

   if self.separateLuneModule {
      self.writeln( '_lune = require( "lune.base._lune" )' );
   }
   else {
      self.writeln( ```
if not _lune then
   _lune = {}
end``` );
      
      if node.$luneHelperInfo.$useNilAccess {
         self.writeln( LuaMod.getCode( .NilAcc ) );
      }
      if node.$luneHelperInfo.$useUnwrapExp {
         self.writeln( LuaMod.getCode( .Unwrap ) );
      }
      if node.$luneHelperInfo.$hasMappingClassDef {
         self.writeln( LuaMod.getCode( .Mapping ));
      }
   }

   let children:List<&Ast.Node> = node.get_children();

   foreach child in children {
      filter( child, self, node );
      self.writeln( "" );
   }  

   self.outputMeta( node );

   if! node.$provideNode {
      self.write( "return " );
      self.write( _exp.$symbol.$name );
      //filter( _exp.$symbol, self, node, baseIndent );
      self.writeln( "" );
   }  
   else { 
      self.writeln( "return _moduleObj" );
   }  
}; 

pub override fn convFilter.processSubfile( 
   node: Ast.SubfileNode, parent: &Ast.Node ) mut
{
}


pub override fn convFilter.processBlock( 
   node: Ast.BlockNode, parent: &Ast.Node ) mut
{
   let mut word = "";
   switch node.get_blockKind() {
      case .If, .Elseif {
         word = "then";
      }
      case .Else {
         word = "";
      }
      case .While {
         word = "do";
      }  
      case .Repeat {
         word = "";
      }  
      case .For {
         word = "do";
      }
      case .Apply {
         word = "do";
      }
      case .Foreach {
         word = "do";
      }  
      case .Macro {
         word = "";
      }  
      case .Func {
         word = "";
      }  
      case .Default {
         word = "";
      }  
      case .Block {
         word = "do";
      }  
      case .Macro {
         word = "";
      }  
      case .LetUnwrap {
         word = "";
      }  
      case .IfUnwrap {
         word = "";
      }
   }
   self.writeln( word );
   self.pushIndent();
   let stmtList = node.get_stmtList();
   foreach statement in stmtList {
      filter( statement, self, node );
      self.writeln( "" );
   }

   self.popIndent();
   if node.get_blockKind() == .Block {
      self.writeln( "end" );
   }
};

pub override fn convFilter.processStmtExp( 
   node: Ast.StmtExpNode, parent: &Ast.Node ) mut
{
   filter( node.get_exp(),  self, node );
};

pub override fn convFilter.processDeclEnum(
   node: Ast.DeclEnumNode, parent: &Ast.Node ) mut
{
   let mut access = node.$accessMode == .Global and "" or "local ";
   let mut enumFullName = node.$name.txt;
   let typeInfo = node.$expType@@Ast.EnumTypeInfo;
   let parentInfo = typeInfo.$parentInfo;
   let mut isTopNS = true;
   if parentInfo ~= Ast.headTypeInfo and parentInfo.$kind == .Class {
      enumFullName = "%s.%s" (self.getFullName( parentInfo ), enumFullName );
      access = "";
      isTopNS = false;
   }
   
   
   self.writeln( "%s%s = {}" (access, enumFullName) );
   if isTopNS and node.$accessMode == .Pub {
      if self.needModuleObj {
         self.writeln( "_moduleObj.%s = %s" ( enumFullName, enumFullName ) );
      }
   }
   

   if typeInfo.$accessMode == .Pub {
      self.pubEnumId2EnumTypeInfo[ typeInfo.$typeId ] = typeInfo;
   }

   self.writeln( "%s._val2NameMap = {}" (enumFullName) );
   self.writeln( ```function %s:_getTxt( val )
   local name = self._val2NameMap[ val ]
   if name then
      return string.format( "%s.%%s", name )
   end
   return string.format( "illegal val -- %%s", val )
end 
function %s._from( val )
   if %s._val2NameMap[ val ] then
      return val
   end
   return nil
end 
    ``` (enumFullName, enumFullName,
          enumFullName, enumFullName ) );
   self.writeln( 
```
%s.__allList = {}
function %s.get__allList()
   return %s.__allList
end
``` (enumFullName, enumFullName, enumFullName ) );
   
   foreach valName, index in node.$valueNameList {
      let valInfo = unwrap typeInfo.getEnumValInfo( valName.txt );
      let mut valTxt = "%s" (valInfo.$val);
      if typeInfo.$valTypeInfo.equals( Ast.builtinTypeString ) {
         valTxt = "'%s'" (valInfo.$val);
      }
      self.writeln( "%s.%s = %s" (enumFullName, valName.txt, valTxt ) );

      self.writeln( "%s._val2NameMap[%s] = '%s'"
         (enumFullName, valTxt, valName.txt ) );
      self.writeln( "%s.__allList[%d] = %s.%s"
         (enumFullName, index, enumFullName, valName.txt ) );
   }
}


fn convFilter.getDestrClass( classTypeInfo:&Ast.TypeInfo ) : Ast.TypeInfo!
{
   let mut typeInfo = classTypeInfo;
   while not typeInfo.equals( Ast.headTypeInfo ) {
      let scope = unwrap typeInfo.$scope;
      if! scope.getTypeInfoChild( "__free" ) {
         return typeInfo;
      }
      typeInfo = typeInfo.$baseTypeInfo;
   }
   return nil;
}

pub override fn convFilter.processDeclClass( 
   node: Ast.DeclClassNode, parent: &Ast.Node ) mut
{
   let nodeInfo = node;
   let classNameToken = nodeInfo.get_name();
   let className = classNameToken.txt;
   let classTypeInfo = node.get_expType();
   let classTypeId = classTypeInfo.$typeId;

   if nodeInfo.get_accessMode() == .Pub {
      self.classId2TypeInfo[ classTypeId ] = classTypeInfo;
   }
   self.classId2MemberList[ classTypeId ] = nodeInfo.get_memberList();

   if! node.$moduleName {
      self.write(
         string.format( "local %s = require( %s )", className, _exp.txt ) );
      switch node.$accessMode {
         case .Pub, .Pro {
            if self.needModuleObj {
               self.writeln( "" );
               self.write( "_moduleObj.%s = %s" (className, className ) );
            }
         }
      }
      return;
   }
   self.writeln( string.format( "local %s = {}", className ) );
   
   let baseInfo = node.get_expType().get_baseTypeInfo();
   if baseInfo.get_typeId() ~= Ast.rootTypeId {
      self.writeln(
         "setmetatable( %s, { __index = %s } )"
         ( className, self.getFullName( unwrap baseInfo ) ) );
   }
   
   if nodeInfo.get_accessMode() == .Pub {
      if self.needModuleObj {
         self.writeln( string.format( "_moduleObj.%s = %s", className, className ) );
      }
   }

   foreach declNode in node.$declStmtList {
      filter( declNode, self, node );
   }

   
   let mut hasConstrFlag = false;
   let mut hasDestrFlag = false;
   let mut memberList: List<&Ast.DeclMemberNode> = [];
   let fieldList: List<&Ast.Node> = nodeInfo.get_fieldList();
   let outerMethodSet: Map<str,bool> = nodeInfo.get_outerMethodSet();
   let mut methodNameSet: Map<str,bool> = {};
   foreach field in fieldList {
      let mut ignoreFlag = false;
      if field.$kind == Ast.NodeKind.$DeclConstr {
         hasConstrFlag = true;
         methodNameSet[ "__init" ] = true;
      }
      if field.$kind == Ast.NodeKind.$DeclDestr {
         hasDestrFlag = true;
         methodNameSet[ "__free" ] = true;
      }
      if field.$kind == Ast.NodeKind.$DeclMember {
         let declMemberNode = field@@Ast.DeclMemberNode;
         if not declMemberNode.$staticFlag {
            memberList.insert( declMemberNode );
         }
      }
      if field.$kind == Ast.NodeKind.$DeclMethod {
         let methodNode = field@@Ast.DeclMethodNode;
         let declInfo = methodNode.get_declInfo();
         let methodNameToken = unwrap declInfo.get_name();
         if outerMethodSet[ methodNameToken.txt ] {
            ignoreFlag = true;
         }
         methodNameSet[ methodNameToken.txt ] = true;
      }

      if ( not ignoreFlag ) {
         filter( field, self, node );
      }
   }

   let mut destTxt = "";
   if! self.getDestrClass( node.get_expType() ) {
      destTxt = ", __gc = %s.__free" (_exp.getTxt());
   }
   
   self.writeln(```
function %s.setmeta( obj )
  setmetatable( obj, { __index = %s %s } )
end```
      ( className, className, destTxt ) );
   
   if not hasConstrFlag {
      methodNameSet[ "__init" ] = true;
      let mut argTxt = "";
      foreach member, index in memberList {
         if index > 1 {
            argTxt = argTxt .. ", ";
         }
         argTxt = argTxt .. member.$name.txt;
      }


      self.writeln( ```
function %s.new( %s )
   local obj = {}
   %s.setmeta( obj )
   if obj.__init then
      obj:__init( %s )
   end        
   return obj 
end         
function %s:__init( %s ) 
```
            ( className, argTxt, className,
              argTxt, className, argTxt ) );
      self.pushIndent();
      foreach member in memberList {
         let memberName = member.$name.txt;
         self.writeln( string.format( "self.%s = %s", memberName, memberName ));
      }
      self.popIndent();
      self.writeln( 'end' );
   }

   // accessor
   let scope = nodeInfo.get_scope();
   foreach memberNode in nodeInfo.$memberList {
      let memberNameToken = memberNode.get_name();
      let memberName = memberNameToken.txt;
      let getterName = "get_" .. memberName;
      // let typeInfo = scope.getTypeInfo( getterName, scope, false );
      // let autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
      let mut autoFlag = not methodNameSet[ getterName ];
      let prefix = memberNode.$staticFlag and className or "self";
      if memberNode.get_getterMode() ~= .None and autoFlag
      {       
         self.writeln( ```
function %s:%s()       
   return %s.%s         
end``` ( className, getterName, prefix, memberName ) );
         methodNameSet[ getterName ] = true;
      }                
      let setterName = "set_" .. memberName;
      //typeInfo = scope.getTypeInfo( setterName, scope, false );
      //autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
      autoFlag = not methodNameSet[ setterName ];
      if memberNode.get_setterMode() ~= .None and autoFlag
      {                
         self.writeln( ```
function %s:%s( %s )   
   %s.%s = %s              
end``` ( className, setterName, memberName, prefix, memberName, memberName ) ); 
         methodNameSet[ setterName ] = true;
      }                   
   }                      

   // advertise
   foreach advertiseInfo in node.$advertiseList {
      let memberName = advertiseInfo.$member.$name.txt;
      let mut memberType = advertiseInfo.$member.$expType;
      foreach child in memberType.$children {
         if child.$kind == Ast.TypeInfoKind.Method and
            child.$accessMode ~= .Pri and
            not child.$staticFlag
         {     
            let childName = advertiseInfo.$prefix .. child.getTxt();
            if not methodNameSet[ childName ] {
               self.writeln( ```
function %s:%s( ... )
   return self.%s:%s( ... )
end       
``` (className, childName, memberName, childName) );
            }     
         }  
      }
   }  

   // init block
   if #nodeInfo.$initStmtList > 0 {
      self.writeln( "do" );
      self.pushIndent();
      foreach initStmt in nodeInfo.$initStmtList {
         filter( initStmt, self, node );
         self.writeln( "" );
      }  
      self.popIndent();
      self.writeln( "end" );
   }

   // Mapping
   if classTypeInfo.isInheritFrom( TransUnit.typeInfoMappingIF ) {
      self.writeln( ```
function %s:_toMap()
  return self
end
function %s._fromMap( val )
  local obj, mes = %s._fromMapSub( {}, val )
  if obj then
     %s.setmeta( obj )
  end
  return obj, mes
end
function %s._fromStem( val )
  return %s._fromMap( val )
end
``` (classTypeInfo.getTxt(), classTypeInfo.getTxt(),
      classTypeInfo.getTxt(), classTypeInfo.getTxt(),
      classTypeInfo.getTxt(), classTypeInfo.getTxt() ));
      
      self.writeln( 'function %s._fromMapSub( obj, val )' (classTypeInfo.getTxt() ));
      
      if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
         self.writeln( ```
   local result, mes = %s._fromMapSub( obj, val )
   if not result then
      return nil, mes
   end
``` (self.getFullName( classTypeInfo.$baseTypeInfo )) );
      }

      self.writeln( '   local memInfo = {}' );

      fn getMapInfo( typeInfo:&Ast.TypeInfo ): str, bool, str {
         let mut orgTypeInfo = typeInfo.$srcTypeInfo;
         if typeInfo.$nilable {
            orgTypeInfo = typeInfo.$orgTypeInfo;
         }
         

         let mut child = "{}";
         let mut funcTxt = "";
         switch orgTypeInfo.$kind {
            case .Stem {
               funcTxt = '_lune._toStem';
            }
            case .Class, .IF {
               if not orgTypeInfo.equals( Ast.builtinTypeString ) {
                  funcTxt = '%s._fromMap' (self.getFullName(orgTypeInfo));
               }
               else {
                  funcTxt = '_lune._toStr';
               }
            }
            case .Enum {
               funcTxt = '%s._from' (self.getFullName(orgTypeInfo));
            }
            case .Prim {
               switch orgTypeInfo {
                  case Ast.builtinTypeInt {
                     funcTxt = '_lune._toInt';
                  }
                  case Ast.builtinTypeReal {
                     funcTxt = '_lune._toReal';
                  }
                  case Ast.builtinTypeBool {
                     funcTxt = '_lune._toBool';
                  }
                  default {
                     Util.err( "unknown type -- %s" (orgTypeInfo.getTxt()) );
                  }
               }
            }
            case .Map {
               funcTxt = '_lune._toMap';
               let itemList = orgTypeInfo.$itemTypeInfoList;
               let keyFuncTxt, keyNilable, keyChild = getMapInfo( itemList[1] );
               let valFuncTxt, valNilable, valChild = getMapInfo( itemList[2] );

               child = "{ { func = %s, nilable = %s, child = %s }, \n"
                   (keyFuncTxt, keyNilable, keyChild) ..
                  "{ func = %s, nilable = %s, child = %s } }"
                   (valFuncTxt, valNilable, valChild);
            }
            case .List, .Array {
               funcTxt = '_lune._toList';
               let itemList = orgTypeInfo.$itemTypeInfoList;
               let valFuncTxt, valNilable, valChild = getMapInfo( itemList[1] );

               child = "{ { func = %s, nilable = %s, child = %s } }"
                   (valFuncTxt, valNilable, valChild);
            }
         }
         return funcTxt, typeInfo.$nilable, child;
      }

      
      foreach memberNode in node.$memberList {
         let funcTxt, nilable, child = getMapInfo( memberNode.$expType );
         self.writeln(
            '   table.insert( memInfo, { name = "%s", func = %s, nilable = %s, child = %s } )'
            ( memberNode.$name.txt, funcTxt, nilable, child ) );
      }
      
      self.writeln( ```
   local result, mess = _lune._fromMap( obj, val, memInfo )
   if not result then
      return nil, mess
   end
   return obj
end``` (classTypeInfo.getTxt() ));
   }
};    

pub override fn convFilter.processDeclMember( 
   node: Ast.DeclMemberNode, parent: &Ast.Node ) mut
{
   // dump( baseIndent, node, node.info.name.txt )
   // node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};

pub override fn convFilter.processExpMacroExp( 
   node: Ast.ExpMacroExpNode, parent: &Ast.Node ) mut
{
   let stmtList = node.get_stmtList();
   if  stmtList {
      foreach stmt in stmtList {
         filter( stmt, self, node );
         self.writeln( "" );
      }    
   } 
};

pub override fn convFilter.processDeclMacro( 
   node: Ast.DeclMacroNode, parent: &Ast.Node ) mut
{
   if self.inMacro {
      let nodeInfo = node.get_declInfo();
      let name = nodeInfo.get_name();

      self.write( "local function %s(" ( name.txt ) );

      // let argTxt = "";
      // foreach arg, index in nodeInfo.get_argList() {
      //    if index > 1 {
      //       self.write( ", " );
      //       argTxt = argTxt .. ", ";
      //    }   
      //    filter( arg, self, node, baseIndent );
      //    if arg.get_kind() == Ast.NodeKind.$DeclArg {
      //       argTxt = argTxt .. (arg@@Ast.DeclArgNode).$name.txt;
      //    }
      //    else {
      //       error( "not support ... in macro %s" ( node.get_declInfo().$name.txt ) );
      //    }
      // }

      // self.writeln( ")", baseIndent );

      self.writeln( "__macroArgs )" );
      self.pushIndent();
      foreach arg, index in nodeInfo.get_argList() {
         let argName = arg.$name.txt;
         self.writeln( "local %s = __macroArgs.%s"
                       (argName, argName ) );
      } 

      self.writeln( "local macroVar = {}" );
      self.writeln( "macroVar._names = {}" );

      self.macroDepth = self.macroDepth + 1;

      if! nodeInfo.get_ast() {
         filter( _exp, self, node );
      }
      
      self.macroDepth = self.macroDepth - 1;
      
      self.writeln( "" );
      self.writeln( "return macroVar" );
      self.popIndent();
      self.writeln( "end" );
      self.writeln( "return %s" ( name.txt ) );
   }      
};        

pub override fn convFilter.processExpMacroStat( 
   node: Ast.ExpMacroStatNode, parent: &Ast.Node ) mut
{
   if #node.$expStrList == 0 {
      self.write( "''" );
   }
   else {
      foreach token, index in node.$expStrList {
         if index ~= 1 {
            self.write( '..' );
         }    
         
         filter( token, self, node );
      }
   }
};    


pub override fn convFilter.processExpNew( 
   node: Ast.ExpNewNode, parent: &Ast.Node ) mut
{
   filter( node.get_symbol(),  self, node );
   self.write( ".new(" );
   if! node.get_argList() {
      filter( _exp,  self, node );
   } 
   self.write( ")" );
};

fn convFilter.process__func__symbol(
   has__func__Symbol:bool, classType:&Ast.TypeInfo, mut funcName:str ) mut
{
   if has__func__Symbol {
      let mut nameSpace = "";
      if classType ~= Ast.headTypeInfo {
         nameSpace = self.getFullName( classType );
      }
      if funcName == "" {
         funcName = "<anonymous>";
      }
      self.writeln( "local __func__ = '%s.%s'" (nameSpace, funcName) );
   }  
}

pub override fn convFilter.processDeclConstr( 
   node: Ast.DeclConstrNode, parent: &Ast.Node ) mut
{
   let declInfo = node.get_declInfo();
   let classTypeInfo = unwrap declInfo.$classTypeInfo;
   let className = self.getFullName( classTypeInfo );
   self.write( string.format( "function %s.new( ", className ) );

   let mut argTxt = "";
   let argList = declInfo.get_argList();
   foreach arg, index in argList {
      if index > 1 {
         self.write( ", " );
         argTxt = argTxt .. ", ";
      } 
      filter( arg, self, node );

      if arg.get_kind() == Ast.NodeKind.$DeclArg {
         argTxt = argTxt .. (arg@@Ast.DeclArgNode).$name.txt;
      }
      else {
         let name = unwrap node.get_declInfo().$name;
         Util.err( "not support ... in macro -- %s" (name.txt) );
      }
   }  
   self.writeln( " )" );
   self.pushIndent();
   self.writeln( "local obj = {}" );
   self.writeln( "%s.setmeta( obj )" ( className ) );
   self.writeln( string.format( "if obj.__init then obj:__init( %s ); end", argTxt ) );
   self.writeln( "return obj" );
   self.popIndent();
   self.writeln( "end" );


   // foreach refType, index in declInfo.retTypeList {
   //    if index > 1 {
   //   self.write( ", " )
   //    }
   //filter( //    refType,  self, node, baseIndent )
   // }
   self.write( string.format( "function %s:__init(%s) ", className, argTxt ) );
   if! declInfo.$body {
      self.process__func__symbol(
         declInfo.$has__func__Symbol, node.$expType.$parentInfo, "__init" );
      
      filter( _exp,  self, node );
   }
   self.writeln( "end" );
};

pub override fn convFilter.processDeclDestr( 
   node: Ast.DeclDestrNode, parent: &Ast.Node ) mut
{
   self.writeln( "function %s.__free( self )"
      ( node.$declInfo.$classTypeInfo$.getTxt$() ) );

   self.process__func__symbol(
      node.$declInfo.$has__func__Symbol, node.$expType.$parentInfo, "__free" );
   
   filter( unwrap node.$declInfo.$body, self, node );

   let classTypeInfo = node.$expType.$parentInfo;
   if! self.getDestrClass( classTypeInfo.$baseTypeInfo ) {
      self.writeln( "%s.__free( self )" (_exp.getTxt() ) );
   }

   self.writeln( "end" );
}


pub override fn convFilter.processExpCallSuper( 
   node: Ast.ExpCallSuperNode, parent: &Ast.Node ) mut
{
   let typeInfo:Ast.TypeInfo = node.get_superType();
   self.write( "%s.__init( self " ( self.getFullName( typeInfo ) ) );              

   if! node.$expList {
      self.write( "," );
      filter( _exp, self, node );
   }
   self.writeln( ")" );
};  

pub override fn convFilter.processDeclMethod( 
   node: Ast.DeclMethodNode, parent: &Ast.Node ) mut
{
   let declInfo = node.get_declInfo();
   let mut delimit = ":";
   if declInfo.get_staticFlag() {
      delimit = ".";
   }  
   let methodNodeToken = unwrap declInfo.get_name();
   let methodName = methodNodeToken.txt;
   let classTypeInfo = unwrap declInfo.$classTypeInfo;
   self.write( "function %s%s%s( "
               ( self.getFullName( classTypeInfo ), delimit, methodName ) );

   let argList = declInfo.get_argList();
   foreach arg, index in argList {
      if index > 1 {
         self.write( ", " );
      } 
      filter( arg, self, node );
   }
   self.writeln( " )" );
   if! declInfo.$body {
      self.process__func__symbol(
         declInfo.$has__func__Symbol, node.$expType.$parentInfo, methodName );
      filter( _exp, self, node );
   }
   self.writeln( "end" );
};    


pub override fn convFilter.processUnwrapSet(
   node: Ast.UnwrapSetNode, parent: &Ast.Node ) mut
{
   let dstExpList = node.$dstExpList;
   filter( dstExpList, self, node );
   self.write( " = " );
   filter( node.$srcExpList, self, node );
   self.writeln( "" );

   self.write( "if " );
   foreach expNode, index in dstExpList.$expList {
      if index > 1 {
         self.write( " or " );
      }   
      self.write( "nil == " );
      filter( expNode, self, node );
   }  
   self.writeln( " then" );
   self.pushIndent();

   foreach expNode, index in dstExpList.$expList {
      self.write( "local _exp%d = " (index));
      filter( expNode, self, node );
      self.writeln( "" );
   } 

   if node.$unwrapBlock {
      filter( unwrap node.$unwrapBlock, self, node );
   }
   self.popIndent();
   self.writeln( "end" );
}   

pub override fn convFilter.processIfUnwrap(
   node: Ast.IfUnwrapNode, parent: &Ast.Node ) mut
{
   self.writeln( "do" );
   self.pushIndent();
   self.write( "local " );
   foreach varName, index in node.$varNameList {
      self.write( varName );
      if index ~= #node.$varNameList {
         self.write( ", " );
      }
   }
   self.write( " = " );

   foreach expNode, index in node.$expNodeList {
      filter( expNode, self, node );
      if index ~= #node.$expNodeList {
         self.write( ", " );
      }
   }
   self.writeln( "" );

   self.write( "if " );
   foreach varName, index in node.$varNameList {
      self.write( "%s ~= nil" (varName) );
      if index ~= #node.$varNameList {
         self.write( " and " );
      }
   }
   self.write( " then" );
   
   filter( node.$block, self, node );


   if! node.$nilBlock {
      self.write( "else" );
      filter( _exp, self, node );
   }
   self.writeln( "end" );
   self.popIndent();
   self.writeln( "end" );
}       


pub override fn convFilter.processWhen(
   node: Ast.WhenNode, parent: &Ast.Node ) mut
{
   self.write( "if " );
   foreach varName, index in node.$varNameList {
      self.write( "%s ~= nil" (varName) );
      if index ~= #node.$varNameList {
         self.write( " and " );
      }
   }
   self.write( " then" );
   
   filter( node.$block, self, node );

   if! node.$elseBlock {
      self.write( "else" );
      filter( _exp, self, node );
   }
   self.writeln( "end" );
}       


pub override fn convFilter.processDeclVar( 
   node: Ast.DeclVarNode, parent: &Ast.Node ) mut
{
   if node.$syncBlock {
      self.writeln( "do" );
      self.pushIndent();
      foreach varInfo in node.$syncVarList {
         self.writeln( "local _sync_%s" (varInfo.$name.txt) );
      }   
      self.writeln( "do" );
      self.pushIndent();
   }

   if node.$mode ~= .Unwrap and node.get_accessMode() ~= .Global {
      self.write( "local " );
   }

   let varList = node.get_varList();
   foreach var, index in varList  {
      if index > 1 {
         self.write( ", " );
      } 
      self.write( var.$name.txt );
   } 

   if! node.get_expList() {
      self.write( " = " );
      filter( _exp, self, node );
   }
   else {
      self.writeln( "" );
   }

   if! node.$unwrapBlock {
      self.writeln( "" );
      self.write( "if " );
      foreach var, index in varList {
         if index > 1 {
            self.write( " or " );
         }   
         self.write( " nil == " .. var.$name.txt );
      }
      self.writeln( " then" );
      self.pushIndent();

      foreach var, index in varList  {
         self.writeln( "local _%s = %s" (var.$name.txt, var.$name.txt ) );
      }
      self.popIndent();

      filter( _exp, self, node );

      if! let thenBlock = node.$thenBlock {     
         self.writeln( "else" );
         self.pushIndent();
	 filter( thenBlock, self, node );
         self.popIndent();
      };
      
      self.writeln( "end" );
   }   

   if! node.$syncBlock {
      filter( _exp, self, node);

      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s = %s" (varInfo.$name.txt, varInfo.$name.txt) );
      }
      self.popIndent();
      self.writeln( "end" );
      
      foreach varInfo in node.$syncVarList {
         self.writeln( "%s = _sync_%s" (varInfo.$name.txt, varInfo.$name.txt) );
      }
      self.popIndent();
      self.writeln( "end" );
   }    
   

   if node.get_accessMode() == .Pub {
      self.writeln( "" );
      foreach var, index in varList {
         let name: str = var.$name.txt;
         if self.needModuleObj {
            self.writeln( "_moduleObj.%s = %s" ( name, name ) );
         }
         self.pubVarName2InfoMap[ name ] = new PubVerInfo(
            node.$staticFlag, node.$accessMode,
            node.$symbolInfoList[ index ].$mutable, node.$typeInfoList[ index ] );
      }
   }  

   if self.macroDepth > 0 {
      self.writeln( "" );
      foreach symbolInfo, index in node.$symbolInfoList {
         let varName = symbolInfo.$name;
         self.writeln( "table.insert( macroVar._names, '%s' )" ( varName ) );
         self.writeln( "macroVar.%s = %s" ( varName, varName ) );
         self.macroVarSymMap[ symbolInfo ] = true;
      }
   }  
};    

pub override fn convFilter.processDeclArg( 
   node: Ast.DeclArgNode, parent: &Ast.Node ) mut
{
   self.write( string.format( "%s", node.get_name().txt ) );

   // filter( // node.info.argType,  self, node, baseIndent )
}; 

pub override fn convFilter.processDeclArgDDD( 
   node: Ast.DeclArgDDDNode, parent: &Ast.Node ) mut
{
   self.write( "..." );
};

pub override fn convFilter.processExpDDD( 
   node: Ast.ExpDDDNode, parent: &Ast.Node ) mut
{
   self.write( "..." );
};

pub override fn convFilter.processDeclFunc( 
   node: Ast.DeclFuncNode, parent: &Ast.Node ) mut
{
   let declInfo = node.get_declInfo();
   let nameToken = declInfo.get_name();
   let mut name = "";
   if! nameToken {
      name = _exp.txt;
   }  
   let mut letTxt = "";
   if declInfo.get_accessMode() ~= .Global and #name ~= 0 {
      letTxt = "local ";
   }  
   self.write( string.format( "%sfunction %s( ", letTxt, name ) );

   let argList = declInfo.get_argList();
   foreach arg, index in argList {
      if index > 1 {
         self.write( ", " );
      } 
      filter( arg, self, node );
   }
   self.writeln( " )" );
   // foreach refType, index in declInfo.get_retTypeList() {
   //    if index > 1 {
   //   self.write( ", " )
   //    }
   //filter( //    refType,  self, node, baseIndent )
   // }

   if! declInfo.$body {
      self.process__func__symbol(
         declInfo.$has__func__Symbol, node.$expType.$parentInfo, name );
      filter( _exp,  self, node );
   }
   self.writeln( "end" );

   //if declInfo.get_accessMode() == .Pub {
   let expType: Ast.TypeInfo = node.get_expType();
   if expType.get_accessMode() == .Pub {
      if self.needModuleObj {
         self.write( "_moduleObj.%s = %s" ( name, name ) );
      }

      self.pubFuncName2InfoMap[ name ] = new PubFuncInfo(
         declInfo.get_accessMode(), node.get_expType() );
   }   
};     

pub override fn convFilter.processRefType( 
   node: Ast.RefTypeNode, parent: &Ast.Node ) mut
{
   self.write( (node.get_refFlag() and "&" or "") ..
               (node.get_mutFlag() and "mut " or "") );
   filter( node.get_name(),  self, node );
   if node.get_array() == "array" {
      self.write( "[@]" );
   }
   elseif node.get_array() == "list" {
      self.write( "[]" );
   }
}; 

pub override fn convFilter.processIf( 
   node: Ast.IfNode, parent: &Ast.Node ) mut
{
   let valList = node.get_stmtList();
   foreach val, index in valList {
      if index == 1 {
         self.write( "if " );
         filter( val.$exp,  self, node );
      }    
      elseif val.$kind == .ElseIf {
         self.write( "elseif " );
         filter( val.$exp,  self, node );
      }   
      else {
         self.writeln( "else" );
      }  
      self.write( " " );
      filter( val.$block, self, node );
   }
   self.writeln( "end" );
};   

pub override fn convFilter.processSwitch( 
   node: Ast.SwitchNode, parent: &Ast.Node ) mut
{
   self.writeln( "do" );
   self.pushIndent();
   self.write( "local _switchExp = " );
   filter( node.get_exp(),  self, node );
   self.writeln( "" );

   foreach caseInfo, index in node.get_caseList() {
      if index == 1 {
         self.write( "if " );
      } 
      else {
         self.write( "elseif " );
      }
      let expList = caseInfo.get_expList();
      foreach expNode, listIndex in expList.get_expList() {
         if listIndex ~= 1 {
            self.write( " or " );
         }  

         self.write( "_switchExp == " );
         filter( expNode, self, node );
      }   
      self.write( " then" );
      filter( caseInfo.$block, self, node );
   }       
   if! node.get_default() {
      self.writeln( "else " );
      self.pushIndent();
      filter( _exp, self, node );
      self.popIndent();
   }
   self.writeln( "end" );
   self.popIndent();
   
   self.writeln( "end" );
};  

pub override fn convFilter.processWhile( 
   node: Ast.WhileNode, parent: &Ast.Node ) mut
{
   self.write( "while " );

   filter( node.get_exp(), self, node );
   self.write( " " );
   filter( node.get_block(), self, node );
   self.writeln( "end" );
};   

pub override fn convFilter.processRepeat( 
   node: Ast.RepeatNode, parent: &Ast.Node ) mut
{
   self.write( "repeat " );
   filter( node.get_block(),  self, node );
   self.write( "until " );
   filter( node.get_exp(),  self, node );
};

pub override fn convFilter.processFor( 
   node: Ast.ForNode, parent: &Ast.Node ) mut
{
   self.write( string.format( "for %s = ", node.get_val().txt ) );
   filter( node.get_init(),  self, node );
   self.write( ", " );
   filter( node.get_to(),  self, node );
   if! node.get_delta() {
      self.write( ", " );
      filter( _exp,  self, node );
   }
   self.write( " " );
   filter( node.get_block(),  self, node );
   self.writeln( "end" );
};   

pub override fn convFilter.processApply( 
   node: Ast.ApplyNode, parent: &Ast.Node ) mut
{
   self.write( "for " );
   let varList = node.get_varList();
   foreach var, index in varList {
      if index > 1 {
         self.write( ", " );
      }   
      self.write( var.txt );
   }
   self.write( " in " );
   filter( node.$exp,  self, node );
   self.write( " " );
   filter( node.$block,  self, node );
   self.writeln( "end" );
};    

pub override fn convFilter.processForeach( 
   node: Ast.ForeachNode, parent: &Ast.Node ) mut
{
   self.write( "for " );
   if! node.$key {
      self.write( _exp.txt );
   }
   else {
      self.write( "__index" );
   }
   self.write( ", " );
   self.write( node.$val.txt );

   self.write( " in pairs( " );
   filter( node.$exp,  self, node );
   self.write( " ) " );
   filter( node.$block,  self, node );
   self.writeln( "end" );
};    

pub override fn convFilter.processForsort( 
   node: Ast.ForsortNode, parent: &Ast.Node ) mut
{
   self.writeln( "do" );
   self.pushIndent();
   self.writeln( "local __sorted = {}" );
   self.write( "local __map = " );
   filter( node.$exp,  self, node );
   self.writeln( "" );
   self.writeln( "for __key in pairs( __map ) do" );
   self.pushIndent();
   self.writeln( "table.insert( __sorted, __key )" );
   self.popIndent();
   self.writeln( "end" );

   self.writeln( "table.sort( __sorted )" );


   self.write( "for __index, " );
   let mut key = "__key";
   if! node.$key {
      key = _exp.txt;
   }
   self.write( key );
   self.writeln( " in ipairs( __sorted ) do" );
   self.pushIndent();
   self.writeln( string.format( "%s = __map[ %s ]", node.$val.txt, key ) );
   filter( node.$block, self, node );
   //self.popIndent();
   self.writeln( "end" );
   self.popIndent();
   self.writeln( "end" );
   self.popIndent();
   self.writeln( "end" );
};


pub override fn convFilter.processExpUnwrap(
   node: Ast.ExpUnwrapNode, parent: &Ast.Node ) mut
{
   if! node.$default {
      self.write( '_lune.unwrapDefault( ' );
      filter( node.$exp, self, node );
      self.write( ', ' );
      filter( _exp, self, node );
      self.write( ')');
   }
   else {
      self.write( '_lune.unwrap( ' );
      filter( node.$exp, self, node );
      self.write( ')');
   } 
}    


pub override fn convFilter.processExpCall( 
   node: Ast.ExpCallNode, parent: &Ast.Node ) mut
{
   let mut wroteFuncFlag = false;
   let mut setArgFlag = false;

   macro _fieldCall( fieldClass:sym ) {
      let fieldNode = node.$func@@Ast. ,,fieldClass;
      let prefixNode = fieldNode.$prefix;
      let prefixType = prefixNode.$expType;
      if node.$nilAccess {
         wroteFuncFlag = true;
         setArgFlag = true;
         if prefixType.$kind == Ast.TypeInfoKind.List {
            self.write( "_lune.nilacc( table.%s, nil, 'list', " (fieldNode.$field.txt ) );
            filter( prefixNode, self, fieldNode );
         }
         else {
            self.write( "_lune.nilacc( " );
            filter( prefixNode, self, fieldNode );
            self.write( ", '%s', 'callmtd' " (fieldNode.$field.txt ) );
         } 
      }
      else {
         if prefixType.$kind == Ast.TypeInfoKind.List {
            setArgFlag = true;
            wroteFuncFlag = true;
            self.write( "table.%s( " (fieldNode.$field.txt ) );
            filter( prefixNode, self, fieldNode );
         }
         elseif prefixType.$kind == Ast.TypeInfoKind.Enum {
            wroteFuncFlag = true;
            let fieldExpType = fieldNode.$expType;
            let canonicalName = self.getCanonicalName( prefixType );
            let mut methodName = fieldNode.$field.txt;
            let mut delimit = ":";
            if methodName == "get__txt" {
               methodName = "_getTxt";
            }
            if fieldExpType.$kind == .Func {
               delimit = ".";
            }
            self.write( "%s%s%s( " (canonicalName, delimit, methodName ) );
            if fieldExpType.$staticFlag {
               setArgFlag = false;
            }
            else {
               filter( prefixNode, self, fieldNode );
               setArgFlag = true;
            }
         }  
      }     
      
   }
   
   if node.$func.$kind == Ast.NodeKind.$RefField {
      _fieldCall( RefFieldNode );
   }
   

   if not wroteFuncFlag {
      if node.$nilAccess {
         self.write( "_lune.nilacc( " );
         filter( node.$func, self, node );
         self.write( ", nil, 'call'" );
         wroteFuncFlag = true;
      }
      else {
         filter( node.$func, self, node );
         self.write( "( " );
      }
   }  

   
   if! node.$argList {
      if wroteFuncFlag and setArgFlag {
         if #_exp.$expList > 0 {
            self.write( ", " );
         }    
      } 
      filter( _exp,  self, node );
   }
   self.write( " )" );
};   


pub override fn convFilter.processExpList( 
   node: Ast.ExpListNode, parent: &Ast.Node ) mut
{
   let expList = node.get_expList();
   //let expList = node.$expList;
   foreach exp, index in expList {
      if index > 1 {
         self.write( ", " );
      }    
      filter( exp, self, node );
   } 
};


pub override fn convFilter.processExpOp1( 
   node: Ast.ExpOp1Node, parent: &Ast.Node ) mut
{
   let mut op = node.$op.txt;
   // if op == ",,," or op == ",,,," {
   //     filter( node.$exp,  self, node );
   // }
   if op == ",,," {
      filter( node.$exp,  self, node );
   }  
   elseif op == ",,,," {
      if node.$macroMode == .Expand {
         filter( node.$exp,  self, node );
      }     
      else {
         self.write( "_luneSym2Str( " );
         filter( node.$exp,  self, node );
         self.write( " )" );
      }   
   }
   elseif op == ",," {
      self.write( "_luneGetLocal( " );
      filter( node.$exp,  self, node );
      self.write( " )" );
   }
   elseif op == "~" {
      if hasBitOpFlag {
         self.write( op );
         filter( node.$exp,  self, node );
      }
      else {
         self.write( "bit32.bnot( " );
         filter( node.$exp,  self, node );
         self.write( " )" );
      }
   }
   else {
      if op == "not" {
         op = op .. " ";
      }
      self.write( op );
      filter( node.$exp,  self, node );
   } 
};   

pub override fn convFilter.processExpCast( 
   node: Ast.ExpCastNode, parent: &Ast.Node ) mut
{
   if node.$expType.equals( Ast.builtinTypeInt ) {
      self.write( "math.floor(" );
      filter( node.$exp,  self, node );
      self.write( ")" );
   }
   else {
      filter( node.$exp,  self, node );
   }
};


pub override fn convFilter.processExpParen( 
   node: Ast.ExpParenNode, parent: &Ast.Node ) mut
{
   self.write( "(" );
   filter( node.$exp,  self, node );
   self.write( " )" );
};

pub override fn convFilter.processExpOp2( 
   node: Ast.ExpOp2Node, parent: &Ast.Node ) mut
{
   let mut intCast = false;
   if node.$expType.equals( Ast.builtinTypeInt ) and node.$op.txt == "/" {
      intCast = true;
      self.write( "math.floor(" );
   }

   let mut opTxt = node.$op.txt;

   if! bitBinOpMap[ opTxt ] {
      // ビット演算の処理
      if hasBitOpFlag {
         // ビット演算子を持っている場合
         switch _exp {
            case .LShift {
               opTxt = "<<";
            }  
            case .RShift {
               opTxt = ">>";
            }  
         }
         filter( node.$exp1,  self, node );
         self.write( " " .. opTxt .. " " );
         filter( node.$exp2,  self, node );
      }
      else {
         // ビット演算子を持っていない場合、ビット演算モジュールに置き換え
         let mut binfunc = "";
         let mut exp2Mod = "";
         switch _exp {
            case .And {
               binfunc = "band";
            }
            case .Or {
               binfunc = "bor";
            }
            case .Xor {
               binfunc = "bxor";
            }
            case .LShift {
               binfunc = "lshift";
            }
            case .RShift {
               binfunc = "lshift";
               exp2Mod = "-";
            }
            default {
               Util.err( "illegal op -- %s" (opTxt) );
            }
         }
         self.write( "bit32.%s(" (binfunc) );
         filter( node.$exp1,  self, node );
         self.write( ", " );
         self.write( exp2Mod );
         filter( node.$exp2,  self, node );
         self.write( " )" );
      }
   }
   else {
      filter( node.$exp1,  self, node );
      self.write( " " .. opTxt .. " " );
      filter( node.$exp2,  self, node );
   }  

   if intCast {
      self.write( ")" );
   }
};  

pub override fn convFilter.processExpRef( 
   node: Ast.ExpRefNode, parent: &Ast.Node ) mut
{
   if self.macroVarSymMap[ node.$symbolInfo.getOrg() ] {
      self.write( "macroVar." );
   }
   else {
      if node.$symbolInfo.$accessMode == .Pub and
         node.$symbolInfo.$kind == Ast.SymbolKind.Var
      {  
         if self.needModuleObj {
            self.write( "_moduleObj." );
         }  
      }
   }
   self.write( node.$token.txt );
};

pub override fn convFilter.processExpRefItem( 
   node: Ast.ExpRefItemNode, parent: &Ast.Node ) mut
{
   if node.$nilAccess {
      self.write( "_lune.nilacc( " );
      filter( node.$val, self, node );
      self.write( ", nil, 'item', " );
      if! node.$index {
         filter( _exp, self, node );
      }
      else {
         self.write( "'%s'" ( unwrap node.$symbol ) );
      }
      self.write( ")" );
   }
   else {
      if node.$val.$expType.equals( Ast.builtinTypeString ) {
         self.write( "string.byte( " );
         filter( node.$val, self, node );
         self.write( ", " );
         if! node.$index {
            filter( _exp, self, node );
         }
         else {
            error( "index is nil" );
         }
         self.write( " )" );
      }
      else {
         filter( node.$val, self, node );
         self.write( "[" );
         if! node.$index {
            filter( _exp, self, node );
         }
         else {
            self.write( "'%s'" ( unwrap node.$symbol ) );
         }
         self.write( "]" );
      } 
   }    
};      

pub override fn convFilter.processRefField( 
   node: Ast.RefFieldNode, parent: &Ast.Node ) mut
{
   let prefix = node.get_prefix();

   if node.$nilAccess {
      self.write( '_lune.nilacc( ' );
      filter( prefix,  self, node );
      self.write( ', "%s" )' (node.$field.txt) );
   } 
   else {
      filter( prefix,  self, node );
      
      let mut delimit = ".";
      if parent.$kind == Ast.NodeKind.$ExpCall {
         if node.get_expType().get_kind() == Ast.TypeInfoKind.Method {
            delimit = ":";
         }
         else {
            delimit = ".";
         }   
      }  
      let fieldToken = node.get_field();
      self.write( delimit .. fieldToken.txt );
   }   
};     

pub override fn convFilter.processExpOmitEnum( 
   node: &Ast.ExpOmitEnumNode, parent: &Ast.Node ) mut
{
   self.write( "%s.%s" ( self.getFullName( node.$expType ), node.$valToken.txt ) );
};

pub override fn convFilter.processGetField(
   node: Ast.GetFieldNode, parent: &Ast.Node ) mut
{
   let prefixNode = node.get_prefix();
   let prefixType = prefixNode.$expType;
   let mut fieldTxt = node.get_field().txt;
   if fieldTxt == "_txt" and prefixType.$kind == Ast.TypeInfoKind.Enum {
      self.write( "%s:_getTxt( " (self.getFullName( prefixType ) ) );
      filter( prefixNode, self, node );
      self.writeln( ")" );
   }
   else {
      filter( prefixNode,  self, node );
      let mut delimit = ".";
      if node.get_getterTypeInfo().get_kind() == Ast.TypeInfoKind.Method {
         delimit = ":";
      }   
      else {
         delimit = ".";
      }   
      if node.get_getterTypeInfo() {
         fieldTxt = "get_%s()" ( fieldTxt );
      }   
      self.write( delimit .. fieldTxt );
   }
};  


pub override fn convFilter.processReturn( 
   node: Ast.ReturnNode, parent: &Ast.Node ) mut
{
   self.write( "return " );

   if! node.$expList {
      filter( _exp,  self, node );
   }
}; 

pub override fn convFilter.processProvide(
   node: Ast.ProvideNode, parent:&Ast.Node ) mut
{
}


pub override fn convFilter.processLiteralList( 
   node: Ast.LiteralListNode, parent: &Ast.Node ) mut
{
   self.write( "{" );

   if! node.$expList {
      filter( _exp, self, node );
   }

   self.write( "}" );
};  

pub override fn convFilter.processLiteralMap( 
   node: Ast.LiteralMapNode, parent: &Ast.Node ) mut
{
   self.write( "{" );
   let pairList = node.$pairList;
   foreach pair, index in pairList {
      if index > 1 {
         self.write( ", " );
      }   
      self.write( "[" );
      filter( pair.$key, self, node );
      self.write( "] = " );
      filter( pair.$val, self, node );
   }

   self.write( "}" );
};  


pub override fn convFilter.processLiteralArray( 
   node: Ast.LiteralArrayNode, parent: &Ast.Node ) mut
{
   self.write( "{" );

   if! node.$expList {
      filter( _exp, self, node );
   }

   self.write( "}" );
};  


pub override fn convFilter.processLiteralChar( 
   node: Ast.LiteralCharNode, parent: &Ast.Node ) mut
{
   self.write( string.format( "%g", node.$num ) );
};

pub override fn convFilter.processLiteralInt( 
   node: Ast.LiteralIntNode, parent: &Ast.Node ) mut
{
   //self.write( string.format( "%d", node.$num ) );
   self.write( node.$token.txt );

};

pub override fn convFilter.processLiteralReal( 
   node: Ast.LiteralRealNode, parent: &Ast.Node ) mut
{
   //self.write( string.format( "%s", node.$num ) );
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralString( 
   node: Ast.LiteralStringNode, parent: &Ast.Node ) mut
{
   let mut txt = node.get_token().txt;
   if string.find( txt, '^```' ) {
      txt = '[==[' .. txt.sub( 4, -4 ) .. ']==]';
   }  
   let argList = node.get_argList();
   if #argList > 0 {
      self.write( string.format( 'string.format( %s, ', txt ) );
      foreach val, index in argList {
         if index > 1 {
            self.write( ", " );
         }      
         filter( val,  self, node );
      }   
      self.write( ")" );
   }
   else {
      self.write( txt );
   }
};  

pub override fn convFilter.processLiteralBool( 
   node: Ast.LiteralBoolNode, parent: &Ast.Node ) mut
{
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralNil( 
   node: Ast.LiteralNilNode, parent: &Ast.Node ) mut
{
   self.write( "nil" );
};

pub override fn convFilter.processBreak( 
   node: Ast.BreakNode, parent: &Ast.Node ) mut
{
   self.write( "break" );
};

pub override fn convFilter.processLiteralSymbol( 
   node: Ast.LiteralSymbolNode, parent: &Ast.Node ) mut
{
   self.write( '%s' ( node.$token.txt ) );
};


pub fn createFilter(
   streamName: str, stream: oStream, metaStream: oStream,
   convMode: ConvMode, inMacro: bool, moduleTypeInfo: &Ast.TypeInfo,
   moduleSymbolKind: &Ast.SymbolKind, separateLuneModule:bool ) : Ast.Filter
{
   return new convFilter(
      streamName, stream, metaStream,
      convMode, inMacro, moduleTypeInfo, moduleSymbolKind, separateLuneModule );
}


pub class MacroEvalImp extend Ast.MacroEval {
   pri let mode: str;

   pub override fn eval( node: Ast.DeclMacroNode ): form
   {   
      let mut oStream = new Util.memStream();
      let mut conv = new convFilter(
         "macro", oStream, oStream, .Exec, true, Ast.headTypeInfo, .Typ, false );

      conv.processDeclMacro( node, node );

      //Util.errorLog( 'hoooo: %s' (oStream.get_txt()) );

      let mut newEnv:Map<str,stem> = {};
      foreach val, key in _ENV {
         newEnv[ key ] = val;
      }
      newEnv[ "_lnsLoad" ] = fn ( name:str, txt:str ): stem {
         let metaInfo, mut val = frontInterface.loadFromLnsTxt( name, txt, false );
         return val;
      };
      
      let chunk, err = load( oStream.get_txt(), "", "bt", newEnv );
      if err {
         Util.err( err );
      }
      if! chunk {
         let mod = _exp();
         if not mod {
            Util.err( "macro load error" );
         }   
         return (unwrap mod)@@form;
      }
      Util.err( "failed to load -- " .. node.$declInfo.$name );
   }  
}     
