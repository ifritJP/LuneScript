/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Ast;
import lune.base.Util;

class PubVerInfo {
   pub let staticFlag: bool;
   pub let accessMode: str;
   pub let typeInfo: Ast.TypeInfo;
};

class PubFuncInfo {
   pub let accessMode: str;
   pub let typeInfo: Ast.TypeInfo;
}

pub class convFilter extend Ast.Filter (oStream) {
   pri let streamName: str;
   pri let stream: oStream;
   pri let metaStream: oStream;
   pri let outMetaFlag: bool;
   pri let moduleName2Info: Map<str,stem>;
   pri let convMode: str;
   pri let inMacro: bool;
   pri let indent: int;
   pri let curLineNo: int;
   // クラス TypeId → TypeInfo
   pri let classId2TypeInfo: Map<int,Ast.TypeInfo>;
   // クラス TypeId → Member Node List
   pri let classId2MemberList: Map<str,Ast.DeclMemberNode[]>;
   // public 変数名 → 変数情報
   pri let pubVarName2InfoMap: Map<str,PubVerInfo>;
   // public 関数名 → 関数情報
   pri let pubFuncName2InfoMap: Map<str,PubFuncInfo>;
   pri let needIndent: bool;
   pri let macroDepth: int;
   
   pub fn __init( streamName: str, stream: oStream,
                  metaStream: oStream,
                  convMode: str, inMacro: bool )
   {
      //Util.errorLog( "__init: %s" (mode) );
      self.macroDepth = 0;
      self.streamName = streamName;
      self.stream = stream;
      self.metaStream = metaStream;
      self.outMetaFlag = false;
      self.moduleName2Info = {};
      self.convMode = convMode;
      self.inMacro = inMacro;
      self.indent = 0;
      self.curLineNo = 1;
      self.classId2TypeInfo = {};
      self.classId2MemberList = {};
      self.pubVarName2InfoMap = {};
      self.pubFuncName2InfoMap = {};
      self.needIndent = false;
   }
}

fn filter( node: Ast.Node, filter: convFilter,
           parent: Ast.Node, baseIndent:int )
{
   node.processFilter( filter, parent, baseIndent );
}

let stepIndent = 2;

let builtInModuleSet:Map<str,bool> = {};
builtInModuleSet[ "io" ] = true;
builtInModuleSet[ "string" ] = true;
builtInModuleSet[ "table" ] = true;
builtInModuleSet[ "math" ] = true;
builtInModuleSet[ "debug" ] = true;
builtInModuleSet[ "_luneScript" ] = true;

fn convFilter.write( txt: str ) {
   let stream = self.stream;
   if self.outMetaFlag {
      stream = self.metaStream;
   }
   
   if self.needIndent {
      stream.write( string.rep( " ", self.indent ) );
      self.needIndent = false;
   }

   apply cr of string.gmatch( txt, "\n" ) {
      self.curLineNo = self.curLineNo + 1;
   }
   stream.write( txt );
}

fn convFilter.setIndent( indent: int ) {
   self.indent = indent;
}

fn convFilter.writeln( txt: str, baseIndent: int ) {
   self.write( txt );
   self.write( "\n" );
   self.needIndent = true;
   self.indent = baseIndent;
}

pub override fn convFilter.processNone(
   node: Ast.NoneNode, parent: Ast.Node, baseIndent:int )
{
   self.writeln( "-- none", baseIndent );
};

pub override fn convFilter.processImport( 
   node: Ast.ImportNode, parent: Ast.Node, baseIndent:int )
{
   let module = node.get_modulePath();
   let moduleName = string.gsub( module, ".*%.", "" );
   //let moduleInfo = require( module );
   let moduleInfo = true;
   self.moduleName2Info[ moduleName ] = moduleInfo;
   if self.convMode == "exe" or self.convMode == "ast"  {
      self.writeln(
         "local %s = _luneScript.loadModule( '%s' )" ( moduleName, module),
         baseIndent );
   }
   else {
      self.writeln( "local %s = require( '%s' )" ( moduleName, module ),
                    baseIndent );
   }
};

fn convFilter.outputMeta( node: Ast.RootNode, baseIndent: int )
{
   switch self.convMode {
      case "lua", "save" {
         return;
      }
   }

   self.outMetaFlag = true;

   if self.stream ~= self.metaStream {
      self.writeln( "local moduleObj = {}", baseIndent );
   }
   
   self.writeln( "----- meta -----", baseIndent );

   let typeId2TypeInfo: Map<int,Ast.TypeInfo> = {};
   let typeId2UseFlag: Map<int,bool> = {};


   let pickupClassMap: Map<int,Ast.TypeInfo> = {};
   
   // 公開される型情報を typeId2TypeInfo にピックアップする
   fn pickupTypeId( typeInfo: Ast.TypeInfo, forceFlag: bool! ) {
      if typeInfo {
         if typeInfo.get_typeId() == Ast.rootTypeId {
            return;
         }
         if not forceFlag and typeInfo.get_accessMode() ~= "pub" {
            return;
         }
         if typeId2TypeInfo[ typeInfo.get_typeId() ] {
            return;
         }

         typeId2TypeInfo[ typeInfo.get_typeId() ] = typeInfo;
	 if typeInfo.get_nilable() {
	    pickupTypeId( typeInfo.get_orgTypeInfo(), true );
	 }
	 else {
            if typeInfo.$kind == Ast.TypeInfoKindClass or
               typeInfo.$kind == Ast.TypeInfoKindIF {          
               pickupClassMap[ typeInfo.$typeId ] = typeInfo;
            }
            
            let parentInfo = typeInfo.get_parentInfo();
            pickupTypeId( parentInfo, true );

            let baseInfo = typeInfo.get_baseTypeInfo();
            if baseInfo.$typeId ~= Ast.rootTypeId {
               pickupTypeId( baseInfo, true );
            }
            
	    let typeInfoList: Ast.TypeInfo[] = typeInfo.get_itemTypeInfoList();
            if typeInfoList {
	       foreach itemTypeInfo in typeInfoList {
                  pickupTypeId( itemTypeInfo, true );
	       }
            }
	    typeInfoList = typeInfo.get_argTypeInfoList();
            if typeInfoList {
	       foreach itemTypeInfo in typeInfoList {
                  pickupTypeId( itemTypeInfo, true );
	       }
            }
	    typeInfoList = typeInfo.get_retTypeInfoList();
            if typeInfoList {
	       foreach itemTypeInfo in typeInfoList {
                  pickupTypeId( itemTypeInfo, true );
	       }
            }
	    typeInfoList = typeInfo.get_children();
            if typeInfoList {
	       foreach itemTypeInfo in typeInfoList {
                  if itemTypeInfo.get_kind() == Ast.TypeInfoKindClass or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKindIF or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKindFunc or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKindMethod
                  {                       
                     pickupTypeId( itemTypeInfo );
                  }
	       }
            }

            pickupTypeId( typeInfo.get_nilableTypeInfo(), true );
	 }
      }
   }

   
   let typeId2ClassMap = node.get_typeId2ClassMap();
   foreach namespaceInfo in typeId2ClassMap {
      if namespaceInfo.typeInfo.get_accessMode() == "pub" {
         pickupClassMap[ namespaceInfo.typeInfo.$typeId ] = namespaceInfo.typeInfo;
      }
   }


   self.writeln( "local _typeId2ClassInfoMap = {}", baseIndent );
   self.writeln( "moduleObj._typeId2ClassInfoMap = _typeId2ClassInfoMap",
                 baseIndent );
   // self.writeln( "local _className2InfoMap = {}", baseIndent );
   // self.writeln( "moduleObj._className2InfoMap = _className2InfoMap",
   //               baseIndent );     

   forsort classTypeInfo, classTypeId in self.classId2TypeInfo {
      pickupTypeId( classTypeInfo );
      pickupClassMap[ classTypeId ] = nil;

      
      self.writeln( "do", baseIndent + stepIndent );
      self.writeln( "local _classInfo%d = {}" (classTypeId), baseIndent + stepIndent );
      // self.writeln( "_className2InfoMap.%s = _classInfo%d" (className, classTypeId),
      //               baseIndent + stepIndent );
      self.writeln( "_typeId2ClassInfoMap[ %d ] = _classInfo%d"
                    (classTypeId, classTypeId), baseIndent + stepIndent );

      
      foreach memberNode in unwrap self.classId2MemberList[ classTypeId ] {
         if memberNode.$accessMode ~= "pri" {
            let memberName = memberNode.$name.txt;
            let memberTypeInfo:Ast.TypeInfo = memberNode.get_expType();
            self.writeln( "_classInfo%d.%s = {" ( classTypeId, memberName ),
                          baseIndent + stepIndent );
            self.writeln(
               "  name='%s', staticFlag = %s, " ( memberName,
                                                  memberNode.$staticFlag ) ..
               "accessMode = '%s', typeId = %d }"
               ( memberNode.$accessMode,
                 memberTypeInfo.get_typeId() ),
               baseIndent + stepIndent );

            pickupTypeId( memberTypeInfo, true );
         }
      }
      
      self.writeln( "end", baseIndent );
   }


   forsort classTypeInfo, classTypeId in pickupClassMap {
      let scope = unwrap classTypeInfo.$scope;

      if not Ast.isBuiltin( classTypeId ) {
         let className = classTypeInfo.getTxt();
         self.writeln( "do", baseIndent + stepIndent );
         self.writeln( "local _classInfo%s = {}"
                       (classTypeId), baseIndent + stepIndent );
         // self.writeln( "_className2InfoMap.%s = _classInfo%d"
         //               (className, classTypeId), baseIndent + stepIndent );
         self.writeln( "_typeId2ClassInfoMap[ %d ] = _classInfo%d"
                       ( classTypeId, classTypeId), baseIndent + stepIndent );
         

         pickupTypeId( classTypeInfo );

         forsort symbolInfo, fieldName in scope.$symbol2TypeInfoMap {
            let typeInfo = symbolInfo.$typeInfo;
            if symbolInfo.$kind == Ast.SymbolKind.Mbr or
               symbolInfo.$kind == Ast.SymbolKind.Var //or
               //symbolInfo.$kind == Ast.SymbolKind.Typ
            {
               if symbolInfo.$accessMode == "pub" {
                  self.writeln( "_classInfo%d.%s = {" ( classTypeId, fieldName ),
                                baseIndent + stepIndent );
                  self.writeln(
                     "  name='%s', staticFlag = %s, "
                     ( fieldName,  typeInfo.get_staticFlag() ) ..
                     "accessMode = '%s', typeId = %d }"
                     ( symbolInfo.$accessMode, typeInfo.get_typeId() ),
                     baseIndent + stepIndent );
                  pickupTypeId( typeInfo );
               }
            }
         }
         self.writeln( "end", baseIndent );
      }
   }
   


   self.writeln( "local _varName2InfoMap = {}", baseIndent );
   self.writeln( "moduleObj._varName2InfoMap = _varName2InfoMap", baseIndent );

   forsort varInfo, varName in self.pubVarName2InfoMap {
      self.writeln( string.format( "_varName2InfoMap.%s = {", varName ),
                    baseIndent );
      self.writeln(
         "  name='%s', accessMode = '%s', typeId = %d }"
         ( varName, varInfo.accessMode, varInfo.typeInfo.$typeId ),
         baseIndent );
      pickupTypeId( varInfo.$typeInfo, true );
   }

   forsort funcInfo, funcName in self.pubFuncName2InfoMap {
      pickupTypeId( funcInfo.$typeInfo, true );
   }

   

   self.writeln( "local _typeInfoList = {}", baseIndent );
   self.writeln( "moduleObj._typeInfoList = _typeInfoList", baseIndent );
   let listIndex = 1;

   let wroteTypeIdSet:Map<int,bool> = {};
   fn outputTypeInfo( typeInfo: Ast.TypeInfo ) {
      let typeId = typeInfo.get_typeId();
      if wroteTypeIdSet[ typeId ] {
         return;
      }
      wroteTypeIdSet[ typeId ] = true;
      if typeId2TypeInfo[ typeId ] and not Ast.isBuiltin( typeId )
      {               
         self.write( "_typeInfoList[%d] = " (listIndex) );
         listIndex = listIndex + 1;
         typeInfo.serialize( self );
      }
   }
   
   forsort typeInfo, typeId in typeId2TypeInfo {
      outputTypeInfo( typeInfo );
   }

   self.writeln( "----- meta -----", baseIndent );

   if self.stream ~= self.metaStream {
      self.writeln( "return moduleObj", baseIndent );
   }

   self.outMetaFlag = false;
}

pub override fn convFilter.processRoot( 
   node: Ast.RootNode, parent: Ast.Node, baseIndent:int )
{
   self.writeln( "--%s" ( self.streamName ), baseIndent );
   self.writeln( "local moduleObj = {}", baseIndent );

   self.writeln( ```
local function _lune_nilacc( val, fieldName, access, ... )
   if not val then
      return nil
   end
   if fieldName then
      local field = val[ fieldName ]
      if not field then
         return nil
      end
      if access == "item" then
         local typeId = type( field )
         if typeId == "table" then
            return field[ ... ]
         elseif typeId == "string" then
            return string.byte( field, ... )
         end
      elseif access == "call" then
         return field( ... )
      elseif access == "callmtd" then
         return field( val, ... )
      end
      return field
   end
   if access == "item" then
      local typeId = type( val )
      if typeId == "table" then
         return val[ ... ]
      elseif typeId == "string" then
         return string.byte( val, ... )
      end
   elseif access == "call" then
      return val( ... )
   elseif access == "list" then
      local list, arg = ...
      if not list then
         return nil
      end
      return val( list, arg )
   end
   error( string.format( "illegal access -- %s", access ) )
end
function _lune_unwrap( val )
  if val == nil then
     _luneScript.error( 'unwrap val is nil' )
  end
  return val
end
function _lune_unwrapDefault( val, defval )
  if val == nil then
     return defval
  end
  return val
end
```, baseIndent );
   

   let children:Ast.Node[] = node.get_children();

   foreach child in children {
      filter( child, self, node, baseIndent );
      self.writeln( "", baseIndent );
   }

   self.outputMeta( node, baseIndent );

   self.writeln( "return moduleObj", baseIndent );
};

pub override fn convFilter.processSubfile( 
   node: Ast.SubfileNode, parent: Ast.Node, baseIndent:int )
{
}


pub override fn convFilter.processBlock( 
   node: Ast.BlockNode, parent: Ast.Node, baseIndent:int )
{
   let word = "";
   if node.get_blockKind() == "if" or node.get_blockKind() == "elseif" {
      word = "then";
   }
   elseif node.get_blockKind() == "else" {
      word = "";
   }
   elseif node.get_blockKind() == "while" {
      word = "do";
   }
   elseif node.get_blockKind() == "repeat" {
      word = "";
   }
   elseif node.get_blockKind() == "for" {
      word = "do";
   }
   elseif node.get_blockKind() == "apply" {
      word = "do";
   }
   elseif node.get_blockKind() == "foreach" {
      word = "do";
   }
   elseif node.get_blockKind() == "macro" {
      word = "";
   }
   elseif node.get_blockKind() == "func" {
      word = "";
   }
   elseif node.get_blockKind() == "default" {
      word = "";
   }
   elseif node.get_blockKind() == "{" {
      word = "do";
   }
   elseif node.get_blockKind() == "macro" {
      word = "";
   }
   elseif node.get_blockKind() == "let!" {
      word = "";
   }
   elseif node.get_blockKind() == "if!" {
      word = "";
   }
   self.writeln( word, baseIndent + stepIndent );
   let stmtList = node.get_stmtList();
   foreach statement in stmtList {
      filter( statement, self, node, baseIndent + stepIndent );
      self.writeln( "", baseIndent + stepIndent );
   }

   self.setIndent( baseIndent ) ;
   if node.get_blockKind() == "{" {
      self.writeln( "end", baseIndent );
   }
};

pub override fn convFilter.processStmtExp( 
   node: Ast.StmtExpNode, parent: Ast.Node, baseIndent:int )
{
   filter( node.get_exp(),  self, node, baseIndent );
};

pub override fn convFilter.processDeclClass( 
   node: Ast.DeclClassNode, parent: Ast.Node, baseIndent:int )
{
   let nodeInfo = node;
   let classNameToken = nodeInfo.get_name();
   let className = classNameToken.txt;
   let classTypeInfo = node.get_expType();
   let classTypeId = classTypeInfo.$typeId;

   if nodeInfo.get_accessMode() == "pub" {
      self.classId2TypeInfo[ classTypeId ] = classTypeInfo;
   }
   self.classId2MemberList[ classTypeId ] = nodeInfo.get_memberList();

   if! node.$moduleName {
      self.writeln(
         string.format( "local %s = require( %s )", className, _exp.txt ), baseIndent );
      return;
   }
   self.writeln( string.format( "local %s = {}", className ), baseIndent );
   
   let baseInfo = node.get_expType().get_baseTypeInfo();
   if baseInfo.get_typeId() ~= Ast.rootTypeId {
      self.writeln(
         "setmetatable( %s, { __index = %s } )"
         ( className, (unwrap baseInfo).getTxt() ), baseIndent );
   }
   
   if nodeInfo.get_accessMode() == "pub" {
      self.writeln( string.format( "moduleObj.%s = %s", className, className ),
                    baseIndent );
   }
   let hasConstrFlag = false;
   let memberList: Ast.DeclMemberNode[] = [];
   let fieldList: Ast.Node[] = nodeInfo.get_fieldList();
   let outerMethodSet: Map<str,bool> = nodeInfo.get_outerMethodSet();
   let methodNameSet: Map<str,bool> = {};
   foreach field in fieldList {
      let ignoreFlag = false;
      if field.$kind == Ast.nodeKind.DeclConstr {
         hasConstrFlag = true;
         methodNameSet[ "__init" ] = true;
      }
      if field.$kind == Ast.nodeKind.DeclMember {
         let declMemberNode = field@@Ast.DeclMemberNode;
         if not declMemberNode.$staticFlag {
            memberList.insert( declMemberNode );
         }
      }
      if field.$kind == Ast.nodeKind.DeclMethod {
         let methodNode = field@@Ast.DeclMethodNode;
         let declInfo = methodNode.get_declInfo();
         let methodNameToken = unwrap declInfo.get_name();
         if outerMethodSet[ methodNameToken.txt ] {
            ignoreFlag = true;
         }
         methodNameSet[ methodNameToken.txt ] = true;
      }

      if ( not ignoreFlag ) {
         filter( field, self, node, baseIndent );
      }
   }
   
   if not hasConstrFlag {
      methodNameSet[ "__init" ] = true;
      let argTxt = "";
      foreach member, index in memberList {
         if index > 1 {
            argTxt = argTxt .. ", ";
         }
         argTxt = argTxt .. member.$name.txt;
      }

      self.writeln( ```
function %s.new( %s )
  local obj = {}
  setmetatable( obj, { __index = %s } )
  if obj.__init then
    obj:__init( %s )
  end        
  return obj 
 end         
function %s:__init( %s ) 
            ```
      ( className, argTxt, className, argTxt, className, argTxt ),
     baseIndent );
      foreach member in memberList {
         let memberName = member.$name.txt;
         self.writeln( string.format( "self.%s = %s", memberName, memberName ),
                       baseIndent + stepIndent);         
      }
      self.writeln( 'end', baseIndent );
   }

   // accessor
   let scope = nodeInfo.get_scope();
   foreach memberNode in nodeInfo.$memberList {
      let memberNameToken = memberNode.get_name();
      let memberName = memberNameToken.txt;
      let getterName = "get_" .. memberName;
      // let typeInfo = scope.getTypeInfo( getterName, scope, false );
      // let autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
      let autoFlag = not methodNameSet[ getterName ];
      let prefix = memberNode.$staticFlag and className or "self";
      if memberNode.get_getterMode() ~= "none" and autoFlag
      {       
         self.writeln( ```
function %s:%s()
  return %s.%s
end``` ( className, getterName, prefix, memberName ), baseIndent );
         methodNameSet[ getterName ] = true;
      }
      let setterName = "set_" .. memberName;
      //typeInfo = scope.getTypeInfo( setterName, scope, false );
      //autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
      autoFlag = not methodNameSet[ setterName ];
      if memberNode.get_setterMode() ~= "none" and autoFlag
      {       
         self.writeln( ```
function %s:%s( %s )
  %s.%s = %s
end``` ( className, setterName, memberName, prefix, memberName, memberName ),
            baseIndent );
         methodNameSet[ setterName ] = true;
      }
   }

   // advertise
   foreach advertiseInfo in node.$advertiseList {
      let memberName = advertiseInfo.$member.$name.txt;
      let memberType = advertiseInfo.$member.$expType;
      foreach child in memberType.$children {
         if child.$kind == Ast.TypeInfoKindMethod and
            child.$accessMode ~= "pri" and
            not child.$staticFlag
         {
            let childName = advertiseInfo.$prefix .. child.getTxt();
            if not methodNameSet[ childName ] {
               self.writeln( ```
function %s:%s( ... )
   return self.%s:%s( ... )
end
``` (className, childName, memberName, childName), baseIndent );
            }
         }
      }
   }

   


   // init block
   self.writeln( "do", baseIndent + stepIndent );
   foreach initStmt in nodeInfo.$initStmtList {
      filter( initStmt, self, node, baseIndent + stepIndent );
      self.writeln( "", baseIndent + stepIndent );
   }
   self.writeln( "end", baseIndent );
};

pub override fn convFilter.processDeclMember( 
   node: Ast.DeclMemberNode, parent: Ast.Node, baseIndent:int )
{
   // dump( baseIndent, node, node.info.name.txt )
   // node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};



pub override fn convFilter.processExpMacroExp( 
   node: Ast.ExpMacroExpNode, parent: Ast.Node, baseIndent:int ) 
{
   let stmtList = node.get_stmtList();
   if  stmtList {
      foreach stmt in stmtList {
         filter( stmt, self, node, baseIndent );
         self.writeln( "", baseIndent );
      }
   }
};

pub override fn convFilter.processDeclMacro( 
   node: Ast.DeclMacroNode, parent: Ast.Node, baseIndent:int ) 
{
   if self.inMacro {
      let nodeInfo = node.get_declInfo();
      let name = nodeInfo.get_name();
      
      self.write( "local function %s(" ( name.txt ) );

      // let argTxt = "";
      // foreach arg, index in nodeInfo.get_argList() {
      //    if index > 1 {
      //       self.write( ", " );
      //       argTxt = argTxt .. ", ";
      //    }   
      //    filter( arg, self, node, baseIndent );
      //    if arg.get_kind() == Ast.nodeKind.DeclArg {
      //       argTxt = argTxt .. (arg@@Ast.DeclArgNode).$name.txt;
      //    }
      //    else {
      //       error( "not support ... in macro %s" ( node.get_declInfo().$name.txt ) );
      //    }
      // }

      // self.writeln( ")", baseIndent );

      self.writeln( "__macroArgs )", baseIndent );
      foreach arg, index in nodeInfo.get_argList() {
         let argName = arg.$name.txt;
         self.writeln( "local %s = __macroArgs.%s"
                       (argName, argName ), baseIndent );
      }

      self.writeln( "local macroVar = {}", baseIndent );
      self.writeln( "macroVar._names = {}", baseIndent );

      self.macroDepth = self.macroDepth + 1;

      if! nodeInfo.get_ast() {
         filter( _exp, self, node, baseIndent );
      }
      
      self.macroDepth = self.macroDepth - 1;
      
      self.writeln( "", baseIndent );
      self.writeln( "return macroVar", baseIndent );
      self.writeln( "end", baseIndent );
      self.writeln( "return %s" ( name.txt ), baseIndent );
   }
};

pub override fn convFilter.processExpMacroStat( 
   node: Ast.ExpMacroStatNode, parent: Ast.Node, baseIndent:int ) 
{
   foreach token, index in node.get_expStrList() {
      if index ~= 1 {
         self.write( '..' );
      }
      
      filter( token, self, node, baseIndent );
   }
};


pub override fn convFilter.processExpNew( 
   node: Ast.ExpNewNode, parent: Ast.Node, baseIndent:int )
{
   filter( node.get_symbol(),  self, node, baseIndent );
   self.write( ".new(" );
   if! node.get_argList() {
      filter( _exp,  self, node, baseIndent );
   }
   self.write( ")" );
};

pub override fn convFilter.processDeclConstr( 
   node: Ast.DeclConstrNode, parent: Ast.Node, baseIndent:int )
{
   let declInfo = node.get_declInfo();
   let classNameToken = unwrap declInfo.get_className();
   let className = classNameToken.txt;
   self.write( string.format( "function %s.new( ", className ) );

   let argTxt = "";
   let argList: Ast.Node[] = declInfo.get_argList();
   foreach arg, index in argList {
      if index > 1 {
         self.write( ", " );
         argTxt = argTxt .. ", ";
      }
      filter( arg, self, node, baseIndent );

      if arg.get_kind() == Ast.nodeKind.DeclArg {
         argTxt = argTxt .. (arg@@Ast.DeclArgNode).$name.txt;
      }
      else {
         let name = unwrap node.get_declInfo().$name;
         Util.err( "not support ... in macro -- %s" (name.txt) );
      }
   }
   self.writeln( " )", baseIndent + stepIndent );
   self.writeln( "local obj = {}", baseIndent + stepIndent );
   self.writeln( string.format( "setmetatable( obj, { __index = %s } )", className ),
                 baseIndent + stepIndent );
   self.writeln( string.format( "if obj.__init then obj:__init( %s ); end",
                                argTxt ), baseIndent );
   self.writeln( "return obj", baseIndent );
   self.writeln( "end", baseIndent );


   // foreach refType, index in declInfo.retTypeList {
   //    if index > 1 {
   //   self.write( ", " )
   //    }
   //filter( //    refType,  self, node, baseIndent )
   // }
   self.write( string.format( "function %s:__init(%s) ", className, argTxt ) );
   if! declInfo.get_body() {
      filter( _exp,  self, node, baseIndent );
   }
   self.writeln( "end", baseIndent );
};


pub override fn convFilter.processExpCallSuper( 
   node: Ast.ExpCallSuperNode, parent: Ast.Node, baseIndent:int )
{
   let typeInfo:Ast.TypeInfo = node.get_superType();
   self.write( "%s.__init( self, " ( typeInfo.getTxt() ) );

   if node.get_expList() {
      filter( node.get_expList(), self, node, baseIndent );
   }
   self.writeln( ")", baseIndent );
};


pub override fn convFilter.processDeclMethod( 
   node: Ast.DeclMethodNode, parent: Ast.Node, baseIndent:int )
{
   let declInfo = node.get_declInfo();
   let delimit = ":";
   if declInfo.get_staticFlag() {
      delimit = ".";
   }
   let methodNodeToken = unwrap declInfo.get_name();
   let methodName = methodNodeToken.txt;
   let classNameToken = unwrap declInfo.get_className();
   self.write( "function %s%s%s( "
               ( classNameToken.txt, delimit, methodName ) );

   let argList: Ast.Node[] = declInfo.get_argList();
   foreach arg, index in argList {
      if index > 1 {
         self.write( ", " );
      }
      filter( arg, self, node, baseIndent );
   }
   self.writeln( " )", baseIndent );
   // foreach refType, index in declInfo.retTypeList {
   //    if index > 1 {
   //   self.write( ", " )
   //    }
   //filter( //    refType,  self, node, baseIndent )
   // }
   if! declInfo.get_body() {
      filter( _exp, self, node, baseIndent );
   }
   self.writeln( "end", baseIndent );
};


pub override fn convFilter.processUnwrapSet(
   node: Ast.UnwrapSetNode, parent: Ast.Node, baseIndent:int )
{
   let dstExpList = node.$dstExpList;
   filter( dstExpList, self, node, baseIndent );
   self.write( " = " );
   filter( node.$srcExpList, self, node, baseIndent );
   self.writeln( "", baseIndent );

   self.write( "if " );
   foreach expNode, index in dstExpList.$expList {
      if index > 1 {
	 self.write( " or " );
      }   
      self.write( "nil == " );
      filter( expNode, self, node, baseIndent );
   }
   self.writeln( " then", baseIndent + stepIndent );

   foreach expNode, index in dstExpList.$expList {
      self.write( "local _exp%d = " (index));
      filter( expNode, self, node, baseIndent + stepIndent );
      self.writeln( "", baseIndent + stepIndent );
   }

   if node.$unwrapBlock {
      filter( unwrap node.$unwrapBlock, self, node, baseIndent + stepIndent );
   }
   self.writeln( "end", baseIndent );
}

pub override fn convFilter.processIfUnwrap(
   node: Ast.IfUnwrapNode, parent: Ast.Node, baseIndent:int )
{
   self.writeln( "do", baseIndent + stepIndent );
   self.write( "local _exp = " );
   filter( node.$exp, self, node, baseIndent + stepIndent );
   self.writeln( "", baseIndent + stepIndent );

   self.writeln( "if _exp ~= nil then", baseIndent + stepIndent );
   filter( node.$block, self, node, baseIndent + stepIndent * 2 );

   if node.$nilBlock {
      self.writeln( "else", baseIndent + stepIndent );

      filter( unwrap node.$nilBlock, self, node, baseIndent + stepIndent * 2 );
   }
   self.writeln( "end", baseIndent );
   self.writeln( "end", baseIndent );
}

pub override fn convFilter.processDeclVar( 
   node: Ast.DeclVarNode, parent: Ast.Node, baseIndent:int )
{
   if node.$syncBlock {
      self.writeln( "do", baseIndent + stepIndent );
      foreach varInfo in node.$syncVarList {
         self.writeln( "local _sync_%s" (varInfo.$name.txt),
                       baseIndent + stepIndent );
      }
      self.writeln( "do", baseIndent + stepIndent * 2 );
   }

   if node.$mode ~= "unwrap" and node.get_accessMode() ~= "global" {
      self.write( "local " );
   }

   let varList = node.get_varList();
   foreach var, index in varList  {
      if index > 1 {
         self.write( ", " );
      }
      self.write( var.$name.txt );
   }

   if! node.get_expList() {
      self.write( " = " );
      filter( _exp, self, node, baseIndent );
   }

   self.writeln( "", baseIndent );

   if! node.$unwrapBlock {
      self.writeln( "", baseIndent + stepIndent * 2 );
      self.write( "if " );
      foreach var, index in varList {
         if index > 1 {
	    self.write( " or " );
         }   
	 self.write( " nil == " .. var.$name.txt );
      }
      self.writeln( " then", baseIndent + stepIndent * 3 );

      foreach var, index in varList  {
         self.writeln( "local _%s = %s" (var.$name.txt, var.$name.txt ),
                       baseIndent + stepIndent * 3 );
      }

      filter( _exp, self, node, baseIndent + stepIndent * 2 );

      sync! thenBlock = node.$thenBlock {}
      then {
         self.writeln( "else", baseIndent + stepIndent * 3 );
	 filter( thenBlock, self, node, baseIndent + stepIndent * 3);
      };
      
      self.writeln( "end", baseIndent + stepIndent * 1 );
   }

   if! node.$syncBlock {
      filter( _exp, self, node, baseIndent + stepIndent * 1);

      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s = %s" (varInfo.$name.txt, varInfo.$name.txt),
                       baseIndent + stepIndent );
      }
      self.writeln( "end", baseIndent + stepIndent );
      
      foreach varInfo in node.$syncVarList {
         self.writeln( "%s = _sync_%s" (varInfo.$name.txt, varInfo.$name.txt),
                       baseIndent + stepIndent );
      }
      self.writeln( "end", baseIndent );
   }
   

   if node.get_accessMode() == "pub" {
      self.writeln( "", baseIndent );
      foreach var, index in varList {
         let name: str = var.$name.txt;
         self.writeln( "moduleObj.%s = %s" ( name, name ),
                       baseIndent );
         self.pubVarName2InfoMap[ name ] = new PubVerInfo(
            node.get_staticFlag(),
            node.get_accessMode(), node.get_typeInfoList()[ index ] );
      }
   }

   if self.macroDepth > 0 {
      self.writeln( "", baseIndent );
      foreach var, index in varList {
         let varName = var.$name.txt;
         self.writeln( "table.insert( macroVar._names, '%s' )" ( varName ),
                       baseIndent );
	 self.writeln( "macroVar.%s = %s" ( varName, varName ), baseIndent );
      }
   }
};

pub override fn convFilter.processDeclArg( 
   node: Ast.DeclArgNode, parent: Ast.Node, baseIndent:int )
{
   self.write( string.format( "%s", node.get_name().txt ) );

   // filter( // node.info.argType,  self, node, baseIndent )
};

pub override fn convFilter.processDeclArgDDD( 
   node: Ast.DeclArgDDDNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "..." );
};

pub override fn convFilter.processExpDDD( 
   node: Ast.ExpDDDNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "..." );
};

pub override fn convFilter.processDeclFunc( 
   node: Ast.DeclFuncNode, parent: Ast.Node, baseIndent:int )
{
   let declInfo = node.get_declInfo();
   let nameToken = declInfo.get_name();
   let name = "";
   if! nameToken {
      name = _exp.txt;
   }
   let letTxt = "";
   if declInfo.get_accessMode() ~= "global" and #name ~= 0 {
      letTxt = "local ";
   }
   self.write( string.format( "%sfunction %s( ", letTxt, name ) );

   let argList = declInfo.get_argList();
   foreach arg, index in argList {
      if index > 1 {
         self.write( ", " );
      }
      filter( arg, self, node, baseIndent );
   }
   self.writeln( " )", baseIndent );
   // foreach refType, index in declInfo.get_retTypeList() {
   //    if index > 1 {
   //   self.write( ", " )
   //    }
   //filter( //    refType,  self, node, baseIndent )
   // }
   if! declInfo.get_body() { 
      filter( _exp,  self, node, baseIndent );
   }
   self.writeln( "end", baseIndent );

   //if declInfo.get_accessMode() == "pub" {
   let expType: Ast.TypeInfo = node.get_expType();
   if expType.get_accessMode() == "pub" {
      self.write( "moduleObj.%s = %s" ( name, name ) );

      self.pubFuncName2InfoMap[ name ] = new PubFuncInfo(
         declInfo.get_accessMode(), node.get_expType() );
   }
};

pub override fn convFilter.processRefType( 
   node: Ast.RefTypeNode, parent: Ast.Node, baseIndent:int )
{
   self.write( (node.get_refFlag() and "&" or "") ..
               (node.get_mutFlag() and "mut " or "") );
   filter( node.get_name(),  self, node, baseIndent );
   if node.get_array() == "array" {
      self.write( "[@]" );
   }
   elseif node.get_array() == "list" {
      self.write( "[]" );
   }
};

pub override fn convFilter.processIf( 
   node: Ast.IfNode, parent: Ast.Node, baseIndent:int )
{
   let valList = node.get_stmtList();
   foreach val, index in valList {
      if index == 1 {
         self.write( "if " );
         filter( val.$exp,  self, node, baseIndent );
      }
      elseif val.$kind == "elseif" {
         self.write( "elseif " );
         filter( val.$exp,  self, node, baseIndent );
      }
      else {
         self.write( "else" );
      }
      self.write( " " );
      filter( val.$block, self, node, baseIndent );
   }
   self.write( "end" );
};

pub override fn convFilter.processSwitch( 
   node: Ast.SwitchNode, parent: Ast.Node, baseIndent:int )
{
   self.writeln( "do", baseIndent + 2 );
   self.write( "local _switchExp = " );
   filter( node.get_exp(),  self, node, baseIndent + 2 );
   self.writeln( "", baseIndent + 2 );

   foreach caseInfo, index in node.get_caseList() {
      if index == 1 {
         self.write( "if " );
      }
      else {
         self.write( "elseif " );
      }
      let expList = caseInfo.get_expList();
      foreach expNode, index in expList.get_expList() {
         if index ~= 1 {
            self.write( " or " );
         }

         self.write( "_switchExp == " );
         filter( expNode, self, node, baseIndent + 2 );
      }   
      self.write( " then" );
      filter( caseInfo.$block, self, node, baseIndent + 2 );
   }
   if! node.get_default() {
      self.write( "else " );
      filter( _exp, self, node, baseIndent + 2 );
   }
   self.writeln( "end", baseIndent );
   
   self.writeln( "end", baseIndent );
};

pub override fn convFilter.processWhile( 
   node: Ast.WhileNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "while " );

   filter( node.get_exp(), self, node, baseIndent );
   self.write( " " );
   filter( node.get_block(), self, node, baseIndent );
   self.write( "end" );
};

pub override fn convFilter.processRepeat( 
   node: Ast.RepeatNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "repeat " );
   filter( node.get_block(),  self, node, baseIndent );
   self.write( "until " );
   filter( node.get_exp(),  self, node, baseIndent );
};

pub override fn convFilter.processFor( 
   node: Ast.ForNode, parent: Ast.Node, baseIndent:int )
{
   self.write( string.format( "for %s = ", node.get_val().txt ) );
   filter( node.get_init(),  self, node, baseIndent );
   self.write( ", " );
   filter( node.get_to(),  self, node, baseIndent );
   if! node.get_delta() {
      self.write( ", " );
      filter( _exp,  self, node, baseIndent );
   }
   self.write( " " );
   filter( node.get_block(),  self, node, baseIndent );
   self.write( "end" );
};

pub override fn convFilter.processApply( 
   node: Ast.ApplyNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "for " );
   let varList = node.get_varList();
   foreach var, index in varList {
      if index > 1 {
         self.write( ", " );
      }
      self.write( var.txt );
   }
   self.write( " in " );
   filter( node.$exp,  self, node, baseIndent );
   self.write( " " );
   filter( node.$block,  self, node, baseIndent );
   self.write( "end" );
};

pub override fn convFilter.processForeach( 
   node: Ast.ForeachNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "for " );
   if! node.$key {
      self.write( _exp.txt );
   }
   else {
      self.write( "__index" );
   }
   self.write( ", " );
   self.write( node.$val.txt );

   self.write( " in pairs( " );
   filter( node.$exp,  self, node, baseIndent );
   self.write( " ) " );
   filter( node.$block,  self, node, baseIndent );
   self.write( "end" );
};

pub override fn convFilter.processForsort( 
   node: Ast.ForsortNode, parent: Ast.Node, baseIndent:int )
{
   self.writeln( "do", baseIndent + stepIndent );
   self.writeln( "local __sorted = {}", baseIndent + stepIndent );
   self.write( "local __map = " );
   filter( node.$exp,  self, node, baseIndent + stepIndent );
   self.writeln( "", baseIndent + stepIndent );
   self.writeln( "for __key in pairs( __map ) do", baseIndent + stepIndent * 2 );
   self.writeln( "table.insert( __sorted, __key )", baseIndent + stepIndent );
   self.writeln( "end", baseIndent + stepIndent );

   self.writeln( "table.sort( __sorted )", baseIndent + stepIndent );


   self.write( "for __index, " );
   let key = "__key";
   if! node.$key {
      key = _exp.txt;
   }
   self.write( key );
   self.writeln( " in ipairs( __sorted ) do", baseIndent + stepIndent * 2 );
   self.writeln( string.format( "%s = __map[ %s ]", node.$val.txt, key ),
                 baseIndent + stepIndent * 2 );
   filter( node.$block, self, node, baseIndent + stepIndent * 2 );
   self.writeln( "end", baseIndent + stepIndent );
   self.writeln( "end", baseIndent );
   self.writeln( "end", baseIndent );
};


pub override fn convFilter.processExpUnwrap(
   node: Ast.ExpUnwrapNode, parent: Ast.Node, baseIndent:int )
{
   if! node.$default {
      self.write( '_lune_unwrapDefault( ' );
      filter( node.$exp, self, node, baseIndent );
      self.write( ', ' );
      filter( _exp, self, node, baseIndent );
      self.write( ')');
   }
   else {
      self.write( '_lune_unwrap( ' );
      filter( node.$exp, self, node, baseIndent );
      self.write( ')');
   }
}


pub override fn convFilter.processExpCall( 
   node: Ast.ExpCallNode, parent: Ast.Node, baseIndent:int )
{
   let wroteFuncFlag = false;
   if node.$func.$kind == Ast.nodeKind.RefField {
      let refField = node.$func@@Ast.RefFieldNode;
      if node.$nilAccess {
         wroteFuncFlag = true;
         if refField.$prefix.$expType.$kind == Ast.TypeInfoKindList {
            self.write( "_lune_nilacc( table.%s, nil, 'list', " (refField.$field.txt ) );
            filter( refField.$prefix, self, refField, baseIndent );
         }
         else {
            self.write( "_lune_nilacc( " );
            filter( refField.$prefix, self, refField, baseIndent );
            self.write( ", '%s', 'callmtd' " (refField.$field.txt ) );
         }
      }
      else {
         if refField.$prefix.$expType.$kind == Ast.TypeInfoKindList {
            wroteFuncFlag = true;
            self.write( "table.%s( " (refField.$field.txt ) );
            filter( refField.$prefix, self, refField, baseIndent );
         }
      }
   }

   if not wroteFuncFlag {
      if node.$nilAccess {
         self.write( "_lune_nilacc( " );
         filter( node.$func, self, node, baseIndent );
         self.write( ", nil, 'call'" );
         wroteFuncFlag = true;
      }
      else {
         filter( node.$func, self, node, baseIndent );
         self.write( "( " );
      }
   }

   
   if! node.$argList {
      if wroteFuncFlag {
         if #_exp.$expList > 0 {
            self.write( ", " );
         }
      }
      filter( _exp,  self, node, baseIndent );
   }
   self.write( " )" );
};


pub override fn convFilter.processExpList( 
   node: Ast.ExpListNode, parent: Ast.Node, baseIndent:int )
{
   let expList = node.get_expList();
   //let expList = node.$expList;
   foreach exp, index in expList {
      if index > 1 {
         self.write( ", " );
      }
      filter( exp, self, node, baseIndent );
   }
};


pub override fn convFilter.processExpOp1( 
   node: Ast.ExpOp1Node, parent: Ast.Node, baseIndent:int )
{
   let op = node.$op.txt;
   // if op == ",,," or op == ",,,," {
   //     filter( node.$exp,  self, node, baseIndent );
   // }
   if op == ",,," {
      filter( node.$exp,  self, node, baseIndent );
   }
   elseif op == ",,,," {
      if node.$macroMode == "expand" {
         filter( node.$exp,  self, node, baseIndent );
      }
      else {
         self.write( "_luneSym2Str( " );
         filter( node.$exp,  self, node, baseIndent );
         self.write( " )" );
      }
   }
   elseif op == ",," {
      self.write( "_luneGetLocal( " );
      filter( node.$exp,  self, node, baseIndent );
      self.write( " )" );
   }
   else {
      if op == "not" {
         op = op .. " ";
      }   
      self.write( op );
      filter( node.$exp,  self, node, baseIndent );
   }
};

pub override fn convFilter.processExpCast( 
   node: Ast.ExpCastNode, parent: Ast.Node, baseIndent:int )
{
   if node.$expType == Ast.builtinTypeInt {
      self.write( "math.floor(" );
      filter( node.$exp,  self, node, baseIndent );
      self.write( ")" );
   }
   else {
      filter( node.$exp,  self, node, baseIndent );
   }
};


pub override fn convFilter.processExpParen( 
   node: Ast.ExpParenNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "(" );
   filter( node.$exp,  self, node, baseIndent );
   self.write( " )" );
};

pub override fn convFilter.processExpOp2( 
   node: Ast.ExpOp2Node, parent: Ast.Node, baseIndent:int )
{
   let intCast = false;
   if node.$expType == Ast.builtinTypeInt and node.$op.txt == "/" {
      intCast = true;
      self.write( "math.floor(" );
   }
   
   filter( node.$exp1,  self, node, baseIndent );

   self.write( " " .. node.$op.txt .. " " );

   filter( node.$exp2,  self, node, baseIndent );

   if intCast {
      self.write( ")" );
   }
};

pub override fn convFilter.processExpRef( 
   node: Ast.ExpRefNode, parent: Ast.Node, baseIndent:int )
{
   self.write( node.$token.txt );
};

pub override fn convFilter.processExpRefItem( 
   node: Ast.ExpRefItemNode, parent: Ast.Node, baseIndent:int )
{
   if node.$nilAccess {
      self.write( "_lune_nilacc( " );
      filter( node.$val, self, node, baseIndent );
      self.write( ", nil, 'item', " );
      filter( node.$index, self, node, baseIndent );
      self.write( ")" );
   }
   else {
      if node.$val.$expType == Ast.builtinTypeString {
         self.write( "string.byte( " );
         filter( node.$val, self, node, baseIndent );
         self.write( ", " );
         filter( node.$index, self, node, baseIndent );
         self.write( " )" );
      }  
      else {
         filter( node.$val, self, node, baseIndent );
         self.write( "[" );
         filter( node.$index, self, node, baseIndent );
         self.write( "]" );
      }
   }
};

pub override fn convFilter.processRefField( 
   node: Ast.RefFieldNode, parent: Ast.Node, baseIndent:int )
{
   let prefix = node.get_prefix();

   if node.$nilAccess {
      self.write( '_lune_nilacc( ' );
      filter( prefix,  self, node, baseIndent );
      self.write( ', "%s" )' (node.$field.txt) );
   }
   else {
      filter( prefix,  self, node, baseIndent );
      
      let delimit = ".";
      if parent.$kind == Ast.nodeKind.ExpCall {
         if node.get_expType().get_kind() == Ast.TypeInfoKindMethod {
            delimit = ":";
         }   
         else {
            delimit = ".";
         }   
      }  
      let fieldToken = node.get_field();
      self.write( delimit .. fieldToken.txt );
   }
};

pub override fn convFilter.processGetField(
   node: Ast.GetFieldNode, parent: Ast.Node, baseIndent:int )
{
   filter( node.get_prefix(),  self, node, baseIndent );
   let delimit = ".";
   if node.get_getterTypeInfo().get_kind() == Ast.TypeInfoKindMethod {
      delimit = ":";
   }   
   else {
      delimit = ".";
   }
   let fieldTxt = node.get_field().txt;
   if node.get_getterTypeInfo() {
      fieldTxt = "get_%s()" ( fieldTxt );
   }
   self.write( delimit .. fieldTxt );
};  


pub override fn convFilter.processReturn( 
   node: Ast.ReturnNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "return " );

   if! node.$expList {
      filter( _exp,  self, node, baseIndent );
   }
};

pub override fn convFilter.processLiteralList( 
   node: Ast.LiteralListNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "{" );

   if! node.$expList {
      filter( _exp, self, node, baseIndent );
   }

   self.write( "}" );
};

pub override fn convFilter.processLiteralMap( 
   node: Ast.LiteralMapNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "{" );
   let pairList = node.$pairList;
   foreach pair, index in pairList {
      if index > 1 {
         self.write( ", " );
      }
      self.write( "[" );
      filter( pair.$key, self, node, baseIndent );
      self.write( "] = " );
      filter( pair.$val, self, node, baseIndent );
   }

   self.write( "}" );
};


pub override fn convFilter.processLiteralArray( 
   node: Ast.LiteralArrayNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "{" );

   if! node.$expList {
      filter( _exp, self, node, baseIndent );
   }

   self.write( "}" );
};


pub override fn convFilter.processLiteralChar( 
   node: Ast.LiteralCharNode, parent: Ast.Node, baseIndent:int )
{
   self.write( string.format( "%g", node.$num ) );
};

pub override fn convFilter.processLiteralInt( 
   node: Ast.LiteralIntNode, parent: Ast.Node, baseIndent:int )
{
   self.write( string.format( "%d", node.$num ) );
};

pub override fn convFilter.processLiteralReal( 
   node: Ast.LiteralRealNode, parent: Ast.Node, baseIndent:int )
{
   self.write( string.format( "%s", node.$num ) );
};

pub override fn convFilter.processLiteralString( 
   node: Ast.LiteralStringNode, parent: Ast.Node, baseIndent:int )
{
   let txt = node.get_token().txt;
   if string.find( txt, '^```' ) {
      txt = '[==[' .. txt.sub( 4, -4 ) .. ']==]';
   }
   let argList = node.get_argList();
   if #argList > 0 {
      self.write( string.format( 'string.format( %s, ', txt ) );
      foreach val, index in argList {
         if index > 1 {
            self.write( ", " );
         }
         filter( val,  self, node, baseIndent );
      }
      self.write( ")" );
   }
   else {
      self.write( txt );
   }
};

pub override fn convFilter.processLiteralBool( 
   node: Ast.LiteralBoolNode, parent: Ast.Node, baseIndent:int )
{
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralNil( 
   node: Ast.LiteralNilNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "nil" );
};

pub override fn convFilter.processBreak( 
   node: Ast.BreakNode, parent: Ast.Node, baseIndent:int )
{
   self.write( "break" );
};

pub override fn convFilter.processLiteralSymbol( 
   node: Ast.LiteralSymbolNode, parent: Ast.Node, baseIndent:int ) 
{
   self.write( '%s' ( node.$token.txt ) );
};


pub class MacroEvalImp extend Ast.MacroEval {
   pri let mode: str;

   pub override fn eval( node: Ast.DeclMacroNode ): form
   {   
      let oStream = new Util.memStream();
      let conv = new convFilter( "macro", oStream, oStream, "exe", true );

      conv.processDeclMacro( node, node, 0 );

      //Util.errorLog( 'hoooo: %s' (oStream.get_txt()) );
      
      let chunk, err = load( oStream.get_txt() );
      if err {
         Util.err( err );
      }
      if! chunk {
         let mod = _exp();
         if not mod {
            Util.err( "macro load error" );
         }   
         return (unwrap mod)@@form;
      }
      Util.err( "failed to load -- " .. node.$declInfo.$name );
   }
}

