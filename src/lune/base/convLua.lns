/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Ast;
import lune.base.Util;

class PubVerInfo {
   pub let staticFlag: bool;
   pub let accessMode: Ast.AccessMode;
   pub let mutable:bool;
   pub let typeInfo: &Ast.TypeInfo;
};

class PubFuncInfo {
   pub let accessMode: Ast.AccessMode;
   pub let typeInfo: &Ast.TypeInfo;
}

pub enum ConvMode {
   /** lns ソースを実行する */
   Exec,
   /** lua への変換を行なう */
   Convert,
   /** lua への変換と、 Meta 情報生成を行なう */
   ConvMeta,
}

class convFilter extend Ast.Filter (oStream) {
   pri let streamName: str;
   pri let mut stream: oStream;
   pri let mut metaStream: oStream;
   pri let mut outMetaFlag: bool;
   pri let mut typeInfo2ModuleName: Map<&Ast.TypeInfo,str>;
   pri let convMode: ConvMode;
   pri let inMacro: bool;
   pri let mut indent: int;
   pri let mut curLineNo: int;
   // クラス TypeId → TypeInfo
   pri let mut classId2TypeInfo: Map<int,&Ast.TypeInfo>;
   // クラス TypeId → Member Node List
   pri let mut classId2MemberList: Map<str,List<&Ast.DeclMemberNode>>;
   // enum TypeId -> EnumTypeInfo
   pri let mut pubEnumId2EnumTypeInfo: Map<int,&Ast.EnumTypeInfo>;
   // public 変数名 → 変数情報
   pri let mut pubVarName2InfoMap: Map<str,PubVerInfo>;
   // public 関数名 → 関数情報
   pri let mut pubFuncName2InfoMap: Map<str,PubFuncInfo>;
   pri let mut needIndent: bool;
   pri let mut macroDepth: int;
   pri let moduleTypeInfo: &Ast.TypeInfo;

   
   pub fn __init( streamName: str, stream: oStream, metaStream: oStream,
                  convMode: ConvMode, inMacro: bool, moduleTypeInfo: &Ast.TypeInfo )
   {
      //Util.errorLog( "__init: %s" (mode) );
      self.macroDepth = 0;
      self.streamName = streamName;
      self.stream = stream;
      self.metaStream = metaStream;
      self.outMetaFlag = false;
      self.typeInfo2ModuleName = {};
      self.convMode = convMode;
      self.inMacro = inMacro;
      self.indent = 0;
      self.curLineNo = 1;
      self.classId2TypeInfo = {};
      self.classId2MemberList = {};
      self.pubVarName2InfoMap = {};
      self.pubFuncName2InfoMap = {};
      self.pubEnumId2EnumTypeInfo = {};
      self.needIndent = false;
      self.moduleTypeInfo = moduleTypeInfo;
   }


   fn getCanonicalName( typeInfo:&Ast.TypeInfo ): str {
      let mut canonicalName = typeInfo.$rawTxt;

      if self.moduleTypeInfo == typeInfo.getModule() {
         return canonicalName;
      }     
      
      let mut workType = typeInfo.$parentInfo;
      while workType ~= Ast.rootTypeInfo {
         canonicalName = "%s.%s" (workType.$rawTxt, canonicalName);
         if self.typeInfo2ModuleName[ workType ] {
            break;
         }
         workType = workType.$parentInfo;
      }
      return canonicalName;
   }

   pub fn close() mut {
   }
   pub fn write( txt: str ) mut {
      let mut stream = self.stream;
      if self.outMetaFlag {
         stream = self.metaStream;
      }  
      
      if self.needIndent {
         stream.write( string.rep( " ", self.indent ) );
         self.needIndent = false;
      }  

      apply cr of string.gmatch( txt, "\n" ) {
         self.curLineNo = self.curLineNo + 1;
      }  
      stream.write( txt );
   }  
}

fn filter( node: &Ast.Node, filter: convFilter,
           parent: &Ast.Node, baseIndent:int )
{
   node.processFilter( filter, parent, baseIndent );
}

let stepIndent = 2;

let mut builtInModuleSet:Map<str,bool> = {};
builtInModuleSet[ "io" ] = true;
builtInModuleSet[ "string" ] = true;
builtInModuleSet[ "table" ] = true;
builtInModuleSet[ "math" ] = true;
builtInModuleSet[ "debug" ] = true;
//builtInModuleSet[ "_luneScript" ] = true;


fn convFilter.setIndent( indent: int ) mut {
   self.indent = indent;
}

fn convFilter.writeln( txt: str, baseIndent: int ) mut {
   self.write( txt );
   self.write( "\n" );
   self.needIndent = true;
   self.indent = baseIndent;
}

pub override fn convFilter.processNone(
   node: Ast.NoneNode, parent: &Ast.Node, baseIndent:int ) mut 
{
   self.writeln( "-- none", baseIndent );
};

pub override fn convFilter.processImport( 
   node: Ast.ImportNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let module = node.get_modulePath();
   let moduleName = string.gsub( module, ".*%.", "" );
   self.typeInfo2ModuleName[ node.$moduleTypeInfo ] = module;
   //if self.convMode == "exe" or self.convMode == "ast" {
   if self.convMode == .Exec {
      self.writeln(
         "local %s = __luneScript:loadModule( '%s' )" ( moduleName, module),
         baseIndent );
   }
   else {
      self.writeln( "local %s = require( '%s' )" ( moduleName, module ),
                    baseIndent );
   }
};


/**
メタ情報を出力する。

メタ情報は次の情報から成る。

- モジュールが依存(import)している外部モジュール情報
  - 外部モジュール識別番号
  - 外部モジュール名
  - このモジュールが公開している型の一部に、外部モジュールの情報を利用しているかどうか
- モジュール内で定義している pub な型情報
- モジュールが利用している外部モジュール内の型情報
  - 外部モジュール識別番号
  - このモジュール内の型識別番号
  - 外部モジュール内の型識別番号

@param node RootNode
@param baseIndent インデント量
*/
fn convFilter.outputMeta( node: Ast.RootNode, baseIndent: int ) mut
{
   if self.convMode == .Convert {
      return;
   }
   // switch self.convMode {
   //    case "lua", "save" {
   //       return;
   //    }
   // }

   self.outMetaFlag = true;

   if self.stream ~= self.metaStream {
      self.writeln( "local _moduleObj = {}", baseIndent );
   }
   
   self.writeln( "----- meta -----", baseIndent );

   let mut importModuleType2Index:Map<&Ast.TypeInfo,int> = {};
   let mut importNameMap:Map<str,&Ast.TypeInfo> = {};
   {
      // foreach importName, typeInfo in self.typeInfo2ModuleName {
      //    importNameMap[ importName ] = typeInfo;
      // }

      foreach moduleInfo, typeInfo in node.$importModule2moduleInfo {
         importNameMap[ moduleInfo.$fullName ] = typeInfo;
      }
      
      let mut index = 0;
      forsort typeInfo, importName in importNameMap {
         index = index + 1;
         importModuleType2Index[ typeInfo ] = index;
      }
   }

   let mut typeId2TypeInfo: Map<int,Ast.TypeInfo> = {};
   let mut typeId2UseFlag: Map<int,bool> = {};


   let mut pickupClassMap: Map<int,Ast.TypeInfo> = {};

   fn checkExportTypeInfo( typeInfo:&Ast.TypeInfo ): bool! {
      let moduleTypeInfo = typeInfo.getModule();
      let typeId = typeInfo.$typeId;
      return typeId2TypeInfo[ typeId ] and not Ast.isBuiltin( typeId ) and
          ( moduleTypeInfo.hasRouteNamespaceFrom( node.$moduleTypeInfo ) or
            typeInfo.$srcTypeInfo ~= typeInfo or
            moduleTypeInfo.equals( Ast.rootTypeInfo ) );
   }
   
   // 公開される型情報を typeId2TypeInfo にピックアップする
   fn pickupTypeId( typeInfo: &Ast.TypeInfo, forceFlag: bool!, pickupChildFlag: bool! ) {
      if typeInfo.get_typeId() == Ast.rootTypeId {
         return;
      }
      if not forceFlag and typeInfo.get_accessMode() ~= .Pub {
         return;
      }

      if typeId2TypeInfo[ typeInfo.get_typeId() ] {
         if pickupChildFlag and not typeInfo.$nilable {
	    foreach itemTypeInfo in typeInfo.get_children() {
               if itemTypeInfo.$accessMode == .Pub and
                   ( itemTypeInfo.get_kind() == Ast.TypeInfoKind.Class or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.IF or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.Func or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.Method )
               {
                  pickupTypeId( itemTypeInfo, true, true );
               }
	    }
         }
         return;
      }

      typeId2TypeInfo[ typeInfo.get_typeId() ] = typeInfo;
      if typeInfo.$nilable {
	 pickupTypeId( typeInfo.get_orgTypeInfo(), true, false );
      }
      else {
         if typeInfo.$kind == Ast.TypeInfoKind.Class or
            typeInfo.$kind == Ast.TypeInfoKind.IF
         {           
            pickupClassMap[ typeInfo.$typeId ] = typeInfo;
         }

         let parentInfo = typeInfo.get_parentInfo();
         pickupTypeId( parentInfo, true, false );
         
         let baseInfo = typeInfo.get_baseTypeInfo();
         if baseInfo.$typeId ~= Ast.rootTypeId {
            pickupTypeId( baseInfo, true, true );
         }
         
	 let mut typeInfoList: &List<&Ast.TypeInfo> = typeInfo.get_itemTypeInfoList();
         if typeInfoList {
	    foreach itemTypeInfo in typeInfoList {
               pickupTypeId( itemTypeInfo, true, false );
	    }
         }
	 typeInfoList = typeInfo.get_argTypeInfoList();
         if typeInfoList {
	    foreach itemTypeInfo in typeInfoList {
               pickupTypeId( itemTypeInfo, true, false );
	    }
         }
	 typeInfoList = typeInfo.get_retTypeInfoList();
         if typeInfoList {
	    foreach itemTypeInfo in typeInfoList {
               pickupTypeId( itemTypeInfo, true, true );
	    }
         }
         if pickupChildFlag {
	    foreach itemTypeInfo in typeInfo.get_children() {
               if itemTypeInfo.$accessMode == .Pub and
                   ( itemTypeInfo.get_kind() == Ast.TypeInfoKind.Class or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.IF or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.Func or
                     itemTypeInfo.get_kind() == Ast.TypeInfoKind.Method )
               {
                  pickupTypeId( itemTypeInfo, true, true );
               }
	    }
         }

         pickupTypeId( typeInfo.get_nilableTypeInfo(), true, false );
      }
   }

   let mut classId2TypeInfo:Map<int,&Ast.TypeInfo> = {};

   let mut validChildrenSet:Map<&Ast.TypeInfo, Map<int,&Ast.TypeInfo>> = {};

   {
      let mut typeInfo = self.moduleTypeInfo;
      while typeInfo ~= Ast.rootTypeInfo {
         validChildrenSet[ typeInfo.$parentInfo ] = { typeInfo.$typeId: typeInfo };
         typeInfo = typeInfo.$parentInfo;
      }
      pickupTypeId( self.moduleTypeInfo, true );
   }
   
   let typeId2ClassMap = node.get_typeId2ClassMap();
   foreach namespaceInfo in typeId2ClassMap {
      if namespaceInfo.typeInfo.get_accessMode() == .Pub and
         not namespaceInfo.typeInfo.$externalFlag
      {
         pickupClassMap[ namespaceInfo.typeInfo.$typeId ] = namespaceInfo.typeInfo;
      }
   }
   classId2TypeInfo = self.classId2TypeInfo;

   self.writeln( "local _typeId2ClassInfoMap = {}", baseIndent );
   self.writeln( "_moduleObj._typeId2ClassInfoMap = _typeId2ClassInfoMap",
                 baseIndent );

   forsort classTypeInfo, classTypeId in classId2TypeInfo {
      if classTypeInfo.$accessMode == .Pub {
         pickupTypeId( classTypeInfo, true,
                       validChildrenSet[ classTypeInfo ] == nil and
                       not classTypeInfo.$externalFlag );    
         pickupClassMap[ classTypeId ] = nil;

         
         self.writeln( "do", baseIndent + stepIndent );
         self.writeln( "local _classInfo%d = {}" (classTypeId), baseIndent + stepIndent );
         self.writeln( "_typeId2ClassInfoMap[ %d ] = _classInfo%d"
                       (classTypeId, classTypeId), baseIndent + stepIndent );

         
         foreach memberNode in unwrap self.classId2MemberList[ classTypeId ] {
            if memberNode.$accessMode ~= .Pri {
               let memberName = memberNode.$name.txt;
               let memberTypeInfo:Ast.TypeInfo = memberNode.get_expType();
               self.writeln( "_classInfo%d.%s = {" ( classTypeId, memberName ),
                             baseIndent + stepIndent );
               self.writeln(
                  "  name='%s', staticFlag = %s, " ( memberName,
                                                     memberNode.$staticFlag ) ..
                  "accessMode = '%s', typeId = %d }"
                  ( memberNode.$accessMode,
                    memberTypeInfo.get_typeId() ),
                  baseIndent + stepIndent );

               pickupTypeId( memberTypeInfo, true );
            }  
         }  
         
         self.writeln( "end", baseIndent );
      }
   }


   let mut pickupedClassMap: Map<int,Ast.TypeInfo> = {};
   while true {
      let mut workClassMap: Map<int,Ast.TypeInfo> = {};
      let mut hasWorkClassFlag = false;
      foreach classTypeInfo, classTypeId in pickupClassMap {
         if not pickupedClassMap[ classTypeId ] {
            pickupedClassMap[ classTypeId ] = classTypeInfo;
            workClassMap[ classTypeId ] = classTypeInfo;
            hasWorkClassFlag = true;
         }  
      }

      if not hasWorkClassFlag {
         break;
      }
      forsort classTypeInfo, classTypeId in workClassMap {
         let scope = unwrap classTypeInfo.$scope;

         if not Ast.isBuiltin( classTypeId ) {
            pickupTypeId( classTypeInfo, true,
                          validChildrenSet[ classTypeInfo ] == nil and
                          not classTypeInfo.$externalFlag );

            if checkExportTypeInfo( classTypeInfo ) {
               let className = classTypeInfo.getTxt();
               self.writeln( "do", baseIndent + stepIndent );
               self.writeln( "local _classInfo%s = {}"
                             (classTypeId), baseIndent + stepIndent );
               self.writeln( "_typeId2ClassInfoMap[ %d ] = _classInfo%d"
                             ( classTypeId, classTypeId), baseIndent + stepIndent );
               
               forsort symbolInfo, fieldName in scope.$symbol2TypeInfoMap {
                  let typeInfo = symbolInfo.$typeInfo;
                  if symbolInfo.$kind == Ast.SymbolKind.Mbr or
                     symbolInfo.$kind == Ast.SymbolKind.Var //or
                  //symbolInfo.$kind == Ast.SymbolKind.Typ
                  {
                     if symbolInfo.$accessMode == .Pub {
                        self.writeln( "_classInfo%d.%s = {" ( classTypeId, fieldName ),
                                      baseIndent + stepIndent );
                        self.writeln(
                           "  name='%s', staticFlag = %s, "
                           ( fieldName,  symbolInfo.$staticFlag ) ..
                           "accessMode = %d, typeId = %d }"
                           ( symbolInfo.$accessMode, typeInfo.get_typeId() ),
                           baseIndent + stepIndent );
                        pickupTypeId( typeInfo );
                     }
                  }
               }

               self.writeln( "end", baseIndent );
            }
         }
      }
   }

   self.writeln( "local _varName2InfoMap = {}", baseIndent );
   self.writeln( "_moduleObj._varName2InfoMap = _varName2InfoMap", baseIndent );

   forsort varInfo, varName in self.pubVarName2InfoMap {
      self.writeln( string.format( "_varName2InfoMap.%s = {", varName ),
                    baseIndent );
      self.writeln(
         "  name='%s', accessMode = %d, typeId = %d, mutable = %s }"
         ( varName, varInfo.accessMode, varInfo.typeInfo.$typeId,
           true ),      
         baseIndent );
      pickupTypeId( varInfo.$typeInfo, true );
   }

   forsort funcInfo, funcName in self.pubFuncName2InfoMap {
      pickupTypeId( funcInfo.$typeInfo, true );
   }

   self.writeln( "local _typeInfoList = {}", baseIndent );
   self.writeln( "_moduleObj._typeInfoList = _typeInfoList", baseIndent );
   
   let mut listIndex = 1;

   let mut wroteTypeIdSet:Map<int,bool> = {};
   fn outputTypeInfo( typeInfo: Ast.TypeInfo ) {
      let typeId = typeInfo.get_typeId();
      if wroteTypeIdSet[ typeId ] {
         return;
      }
      wroteTypeIdSet[ typeId ] = true;
      if checkExportTypeInfo( typeInfo ) {
         self.write( "_typeInfoList[%d] = " (listIndex) );
         listIndex = listIndex + 1;

         let mut validChildren = validChildrenSet[ typeInfo ];
         if not validChildren {
            validChildren = typeId2TypeInfo;
         }
         typeInfo.serialize( self, validChildren );
      }
      else {
         // self.writeln( "--[[ %s, %s" ( moduleTypeInfo.getTxt(),
         //                               node.$moduleTypeInfo.getTxt() ), baseIndent );  
         // typeInfo.serialize( self, nil );
         // self.writeln( "]]", baseIndent );
      }
   }

   foreach typeInfo, typeId in self.pubEnumId2EnumTypeInfo {
      typeId2TypeInfo[ typeId ] = typeInfo;
   }


   self.writeln( "local _dependIdMap = {}", baseIndent );
   self.writeln( "_moduleObj._dependIdMap = _dependIdMap", baseIndent );
   let mut exportNeedModuleTypeInfo:Map<&Ast.TypeInfo,bool> = {};
   forsort typeInfo, typeId in typeId2TypeInfo {
      outputTypeInfo( typeInfo );
      let moduleTypeInfo = typeInfo.getModule();
      exportNeedModuleTypeInfo[ moduleTypeInfo ] = true;
      if! let moduleIndex = importModuleType2Index[ moduleTypeInfo ] {
         let moduleInfo = unwrap node.$importModule2moduleInfo[ moduleTypeInfo ];
         if! let extId = moduleInfo.$localTypeInfo2importIdMap[ typeInfo ] {
            let mut valid = false;
            if typeInfo.$srcTypeInfo ~= typeInfo {
               valid = true;
            }
            else {
               let mut orgTypeInfo:&Ast.TypeInfo = typeInfo;
               if typeInfo.$nilable {
                  orgTypeInfo = typeInfo.$orgTypeInfo;
               }
               switch orgTypeInfo.$kind {
                  case .IF, .Map, .Enum, .List, .Array, .Class, .Module {
                     valid = true;
                  }
                  // default {
                  //    Util.errorLog( "hoge: %s:%d(%s)"
                  //       ( typeInfo.getTxt(), typeInfo.$typeId, typeInfo.$kind.$_txt ) );
                  // }
               }
            }
            if valid {
               self.writeln(
                  "_dependIdMap[ %d ] = { %d, %d }"
                  ( typeInfo.$typeId, moduleIndex, extId ),
                  baseIndent );
            }
         }
      }
   }

   self.writeln( "local _dependModuleMap = {}", baseIndent );
   self.writeln( "_moduleObj._dependModuleMap = _dependModuleMap", baseIndent );

   
   forsort moduleTypeInfo, name in importNameMap {
      self.writeln(
         "_dependModuleMap[ '%s' ] = { id = %d, use = %s }"
         ( name, unwrap importModuleType2Index[ moduleTypeInfo ],
           exportNeedModuleTypeInfo[ moduleTypeInfo ] or false ), baseIndent );
   }
   
   let mut moduleTypeInfo = self.moduleTypeInfo;
   if! node.$provideNode {
      moduleTypeInfo = _exp.$val.$expType;
   }
   self.writeln( "_moduleObj._moduleTypeId = %d" (moduleTypeInfo.$typeId ),
                 baseIndent );
   self.writeln( "_moduleObj._moduleMutable = %s" (moduleTypeInfo.$mutable ),
                 baseIndent );

   self.writeln( "----- meta -----", baseIndent );

   if self.stream ~= self.metaStream {
      self.writeln( "return _moduleObj", baseIndent );
   }

   self.outMetaFlag = false;
}

pub override fn convFilter.processRoot( 
   node: Ast.RootNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.writeln( "--%s" ( self.streamName ), baseIndent );
   self.writeln( "local _moduleObj = {}", baseIndent );

   if node.$luneHelperInfo.$useNilAccess or node.$luneHelperInfo.$useUnwrapExp {
      self.writeln( ```
if not _ENV._lune then
   _lune = {}
end```, baseIndent );
      if node.$luneHelperInfo.$useNilAccess {
         self.writeln( ```
function _lune.nilacc( val, fieldName, access, ... )
  if not val then
    return nil
  end
  if fieldName then
    local field = val[ fieldName ]
    if not field then
      return nil
    end
    if access == "item" then
      local typeId = type( field )
      if typeId == "table" then
        return field[ ... ]
      elseif typeId == "string" then
        return string.byte( field, ... )
      end
    elseif access == "call" then
      return field( ... )
    elseif access == "callmtd" then
      return field( val, ... )
    end
    return field
  end
  if access == "item" then
    local typeId = type( val )
    if typeId == "table" then
      return val[ ... ]
    elseif typeId == "string" then
      return string.byte( val, ... )
    end
  elseif access == "call" then
    return val( ... )
  elseif access == "list" then
    local list, arg = ...
    if not list then
      return nil
    end
    return val( list, arg )
  end
  error( string.format( "illegal access -- %s", access ) )
end
```, baseIndent );
      }
      if node.$luneHelperInfo.$useUnwrapExp {
         self.writeln(```
function _lune.unwrap( val )
  if val == nil then
    __luneScript:error( 'unwrap val is nil' )
  end
  return val
end 
function _lune.unwrapDefault( val, defval )
  if val == nil then
    return defval
  end
  return val
end
```, baseIndent );
      }
   }
   

   let children:List<&Ast.Node> = node.get_children();

   foreach child in children {
      filter( child, self, node, baseIndent );
      self.writeln( "", baseIndent );
   }

   self.outputMeta( node, baseIndent );

   if! node.$provideNode {
      self.write( "return " );
      filter( _exp.$val, self, node, baseIndent );
      self.writeln( "", baseIndent );
   }
   else { 
      self.writeln( "return _moduleObj", baseIndent );
   }
};

pub override fn convFilter.processSubfile( 
   node: Ast.SubfileNode, parent: &Ast.Node, baseIndent:int ) mut
{
}


pub override fn convFilter.processBlock( 
   node: Ast.BlockNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let mut word = "";
   switch node.get_blockKind() {
      case .If, .Elseif {
         word = "then";
      }
      case .Else {
         word = "";
      }
      case .While {
         word = "do";
      }  
      case .Repeat {
      word = "";
      }  
      case .For {
         word = "do";
      }
      case .Apply {
         word = "do";
      }
      case .Foreach {
         word = "do";
      }  
      case .Macro {
         word = "";
      }  
      case .Func {
         word = "";
      }  
      case .Default {
         word = "";
      }  
      case .Block {
         word = "do";
      }  
      case .Macro {
         word = "";
      }  
      case .LetUnwrap {
         word = "";
      }  
      case .IfUnwrap {
         word = "";
      }
   }
   self.writeln( word, baseIndent + stepIndent );
   let stmtList = node.get_stmtList();
   foreach statement in stmtList {
      filter( statement, self, node, baseIndent + stepIndent );
      self.writeln( "", baseIndent + stepIndent );
   }

   self.setIndent( baseIndent );
   if node.get_blockKind() == .Block {
      self.writeln( "end", baseIndent );
   }
};

pub override fn convFilter.processStmtExp( 
   node: Ast.StmtExpNode, parent: &Ast.Node, baseIndent:int ) mut
{
   filter( node.get_exp(),  self, node, baseIndent );
};

pub override fn convFilter.processDeclEnum(
   node: Ast.DeclEnumNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let access = node.$accessMode == .Global and "" or "local ";
   self.writeln( "%s%s = {}" (access, node.$name.txt), baseIndent );
   if node.$accessMode == .Pub {
      self.writeln( "_moduleObj.%s = %s" ( node.$name.txt, node.$name.txt ),
                    baseIndent );
   }
   
   let typeInfo = node.$expType@@Ast.EnumTypeInfo;

   if typeInfo.$accessMode ~= .Pri {
      self.pubEnumId2EnumTypeInfo[ typeInfo.$typeId ] = typeInfo;
   }

   self.writeln( "%s._val2NameMap = {}" (node.$name.txt), baseIndent );
   self.writeln( ```function %s:_getTxt( val )
  local name = self._val2NameMap[ val ]
  if name then
    return string.format( "%s.%%s", name )
  end
  return string.format( "illegal val -- %%s", val )
end 
function %s:_from( val )
  if self._val2NameMap[ val ] then
    return val
  end
  return nil
end 
    ``` (node.$name.txt, self.getCanonicalName( typeInfo ), node.$name.txt ), baseIndent );
   foreach valName in node.$valueNameList {
      let valInfo = unwrap typeInfo.getEnumValInfo( valName.txt );
      let mut valTxt = "%s" (valInfo.$val);
      if typeInfo.$valTypeInfo.equals( Ast.builtinTypeString ) {
         valTxt = "'%s'" (valInfo.$val);
      }
      self.writeln(
         "%s.%s = %s" (node.$name.txt, valName.txt, valTxt ), baseIndent );

      self.writeln( "%s._val2NameMap[%s] = '%s'"
         (node.$name.txt, valTxt, valName.txt ), baseIndent );
   }
}


fn convFilter.getDestrClass( classTypeInfo:&Ast.TypeInfo ) : Ast.TypeInfo!
{
   let mut typeInfo = classTypeInfo;
   while not typeInfo.equals( Ast.rootTypeInfo ) {
      let scope = unwrap typeInfo.$scope;
      if! scope.getTypeInfoChild( "__free" ) {
         return typeInfo;
      }
      typeInfo = typeInfo.$baseTypeInfo;
   }
   return nil;
}

pub override fn convFilter.processDeclClass( 
   node: Ast.DeclClassNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let nodeInfo = node;
   let classNameToken = nodeInfo.get_name();
   let className = classNameToken.txt;
   let classTypeInfo = node.get_expType();
   let classTypeId = classTypeInfo.$typeId;

   if nodeInfo.get_accessMode() == .Pub {
      self.classId2TypeInfo[ classTypeId ] = classTypeInfo;
   }
   self.classId2MemberList[ classTypeId ] = nodeInfo.get_memberList();

   if! node.$moduleName {
      self.writeln(
         string.format( "local %s = require( %s )", className, _exp.txt ), baseIndent );
      if node.$accessMode ~= .Pri {
         self.writeln( "_moduleObj.%s = %s" (className, className ), baseIndent );
      }
      return;
   }
   self.writeln( string.format( "local %s = {}", className ), baseIndent );
   
   let baseInfo = node.get_expType().get_baseTypeInfo();
   if baseInfo.get_typeId() ~= Ast.rootTypeId {
      self.writeln(
         "setmetatable( %s, { __index = %s } )"
         ( className, (unwrap baseInfo).getTxt() ), baseIndent );
   }
   
   if nodeInfo.get_accessMode() == .Pub {
      self.writeln( string.format( "_moduleObj.%s = %s", className, className ),
                    baseIndent );
   }
   let mut hasConstrFlag = false;
   let mut hasDestrFlag = false;
   let mut memberList: List<&Ast.DeclMemberNode> = [];
   let fieldList: List<&Ast.Node> = nodeInfo.get_fieldList();
   let outerMethodSet: Map<str,bool> = nodeInfo.get_outerMethodSet();
   let mut methodNameSet: Map<str,bool> = {};
   foreach field in fieldList {
      let mut ignoreFlag = false;
      if field.$kind == Ast.nodeKind.DeclConstr {
         hasConstrFlag = true;
         methodNameSet[ "__init" ] = true;
      }
      if field.$kind == Ast.nodeKind.DeclDestr {
         hasDestrFlag = true;
         methodNameSet[ "__free" ] = true;
      }
      if field.$kind == Ast.nodeKind.DeclMember {
         let declMemberNode = field@@Ast.DeclMemberNode;
         if not declMemberNode.$staticFlag {
            memberList.insert( declMemberNode );
         }
      }
      if field.$kind == Ast.nodeKind.DeclMethod {
         let methodNode = field@@Ast.DeclMethodNode;
         let declInfo = methodNode.get_declInfo();
         let methodNameToken = unwrap declInfo.get_name();
         if outerMethodSet[ methodNameToken.txt ] {
            ignoreFlag = true;
         }
         methodNameSet[ methodNameToken.txt ] = true;
      }

      if ( not ignoreFlag ) {
         filter( field, self, node, baseIndent );
      }
   }

   let mut destTxt = "";
   if! self.getDestrClass( node.get_expType() ) {
      destTxt = ", __gc = %s.__free" (_exp.getTxt());
   }
   
   self.writeln(```
function %s.setmeta( obj )
  setmetatable( obj, { __index = %s %s } )
end```
      ( className, className, destTxt ), baseIndent );
   
   if not hasConstrFlag {
      methodNameSet[ "__init" ] = true;
      let mut argTxt = "";
      foreach member, index in memberList {
         if index > 1 {
            argTxt = argTxt .. ", ";
         }
         argTxt = argTxt .. member.$name.txt;
      }


      self.writeln( ```
function %s.new( %s )
  local obj = {}
  %s.setmeta( obj )
  if obj.__init then
    obj:__init( %s )
  end        
  return obj 
end         
function %s:__init( %s ) 
```
            ( className, argTxt, className,
              argTxt, className, argTxt ),
           baseIndent );
      foreach member in memberList {
         let memberName = member.$name.txt;
         self.writeln( string.format( "self.%s = %s", memberName, memberName ),
                       baseIndent + stepIndent);         
      }
      self.writeln( 'end', baseIndent );
   }

   // accessor
   let scope = nodeInfo.get_scope();
   foreach memberNode in nodeInfo.$memberList {
      let memberNameToken = memberNode.get_name();
      let memberName = memberNameToken.txt;
      let getterName = "get_" .. memberName;
      // let typeInfo = scope.getTypeInfo( getterName, scope, false );
      // let autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
      let mut autoFlag = not methodNameSet[ getterName ];
      let prefix = memberNode.$staticFlag and className or "self";
      if memberNode.get_getterMode() ~= .None and autoFlag
      {       
         self.writeln( ```
function %s:%s()       
  return %s.%s         
end``` ( className, getterName, prefix, memberName ), baseIndent );
         methodNameSet[ getterName ] = true;
      }                
      let setterName = "set_" .. memberName;
      //typeInfo = scope.getTypeInfo( setterName, scope, false );
      //autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
      autoFlag = not methodNameSet[ setterName ];
      if memberNode.get_setterMode() ~= .None and autoFlag
      {                
         self.writeln( ```
function %s:%s( %s )   
  %s.%s = %s              
end``` ( className, setterName, memberName, prefix, memberName, memberName ),
            baseIndent ); 
         methodNameSet[ setterName ] = true;
      }                   
   }                      

   // advertise
   foreach advertiseInfo in node.$advertiseList {
      let memberName = advertiseInfo.$member.$name.txt;
      let mut memberType = advertiseInfo.$member.$expType;
      foreach child in memberType.$children {
         if child.$kind == Ast.TypeInfoKind.Method and
            child.$accessMode ~= .Pri and
            not child.$staticFlag
         {     
            let childName = advertiseInfo.$prefix .. child.getTxt();
            if not methodNameSet[ childName ] {
               self.writeln( ```
function %s:%s( ... )
  return self.%s:%s( ... )
end       
``` (className, childName, memberName, childName), baseIndent );
            }     
         }  
      }
   }  

   // init block
   self.writeln( "do", baseIndent + stepIndent );
   foreach initStmt in nodeInfo.$initStmtList {
      filter( initStmt, self, node, baseIndent + stepIndent );
      self.writeln( "", baseIndent + stepIndent );
   } 
   self.writeln( "end", baseIndent );
};    

pub override fn convFilter.processDeclMember( 
   node: Ast.DeclMemberNode, parent: &Ast.Node, baseIndent:int ) mut
{
   // dump( baseIndent, node, node.info.name.txt )
   // node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};

pub override fn convFilter.processExpMacroExp( 
   node: Ast.ExpMacroExpNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let stmtList = node.get_stmtList();
   if  stmtList {
      foreach stmt in stmtList {
         filter( stmt, self, node, baseIndent );
         self.writeln( "", baseIndent );
      }    
   } 
};

pub override fn convFilter.processDeclMacro( 
   node: Ast.DeclMacroNode, parent: &Ast.Node, baseIndent:int ) mut
{
   if self.inMacro {
      let nodeInfo = node.get_declInfo();
      let name = nodeInfo.get_name();

      self.write( "local function %s(" ( name.txt ) );

      // let argTxt = "";
      // foreach arg, index in nodeInfo.get_argList() {
      //    if index > 1 {
      //       self.write( ", " );
      //       argTxt = argTxt .. ", ";
      //    }   
      //    filter( arg, self, node, baseIndent );
      //    if arg.get_kind() == Ast.nodeKind.DeclArg {
      //       argTxt = argTxt .. (arg@@Ast.DeclArgNode).$name.txt;
      //    }
      //    else {
      //       error( "not support ... in macro %s" ( node.get_declInfo().$name.txt ) );
      //    }
      // }

      // self.writeln( ")", baseIndent );

      self.writeln( "__macroArgs )", baseIndent );
      foreach arg, index in nodeInfo.get_argList() {
         let argName = arg.$name.txt;
         self.writeln( "local %s = __macroArgs.%s"
                       (argName, argName ), baseIndent );
      } 

      self.writeln( "local macroVar = {}", baseIndent );
      self.writeln( "macroVar._names = {}", baseIndent );

      self.macroDepth = self.macroDepth + 1;

      if! nodeInfo.get_ast() {
         filter( _exp, self, node, baseIndent );
      }
      
      self.macroDepth = self.macroDepth - 1;
      
      self.writeln( "", baseIndent );
      self.writeln( "return macroVar", baseIndent );
      self.writeln( "end", baseIndent );
      self.writeln( "return %s" ( name.txt ), baseIndent );
   }      
};        

pub override fn convFilter.processExpMacroStat( 
   node: Ast.ExpMacroStatNode, parent: &Ast.Node, baseIndent:int ) mut
{
   foreach token, index in node.get_expStrList() {
      if index ~= 1 {
         self.write( '..' );
      }    
      
      filter( token, self, node, baseIndent );
   }  
};    


pub override fn convFilter.processExpNew( 
   node: Ast.ExpNewNode, parent: &Ast.Node, baseIndent:int ) mut
{
   filter( node.get_symbol(),  self, node, baseIndent );
   self.write( ".new(" );
   if! node.get_argList() {
      filter( _exp,  self, node, baseIndent );
   } 
   self.write( ")" );
};

pub override fn convFilter.processDeclConstr( 
   node: Ast.DeclConstrNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let declInfo = node.get_declInfo();
   let classNameToken = unwrap declInfo.get_className();
   let className = classNameToken.txt;
   self.write( string.format( "function %s.new( ", className ) );

   let mut argTxt = "";
   let argList = declInfo.get_argList();
   foreach arg, index in argList {
      if index > 1 {
         self.write( ", " );
         argTxt = argTxt .. ", ";
      } 
      filter( arg, self, node, baseIndent );

      if arg.get_kind() == Ast.nodeKind.DeclArg {
         argTxt = argTxt .. (arg@@Ast.DeclArgNode).$name.txt;
      }
      else {
         let name = unwrap node.get_declInfo().$name;
         Util.err( "not support ... in macro -- %s" (name.txt) );
      }
   }  
   self.writeln( " )", baseIndent + stepIndent );
   self.writeln( "local obj = {}", baseIndent + stepIndent );
   self.writeln( "%s.setmeta( obj )" ( className ),
                 baseIndent + stepIndent );
   self.writeln( string.format( "if obj.__init then obj:__init( %s ); end",
                                argTxt ), baseIndent );
   self.writeln( "return obj", baseIndent );
   self.writeln( "end", baseIndent );


   // foreach refType, index in declInfo.retTypeList {
   //    if index > 1 {
   //   self.write( ", " )
   //    }
   //filter( //    refType,  self, node, baseIndent )
   // }
   self.write( string.format( "function %s:__init(%s) ", className, argTxt ) );
   if! declInfo.$body {
      filter( _exp,  self, node, baseIndent );
   }
   self.writeln( "end", baseIndent );
};

pub override fn convFilter.processDeclDestr( 
   node: Ast.DeclDestrNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.writeln( "function %s.__free( self )" ( node.$declInfo.$className$.txt ),
                 baseIndent + stepIndent );

   filter( unwrap node.$declInfo.$body, self, node, baseIndent + stepIndent );

   let classTypeInfo = node.$expType.$parentInfo;
   if! self.getDestrClass( classTypeInfo.$baseTypeInfo ) {
      self.writeln( "%s.__free( self )" (_exp.getTxt() ), baseIndent );
   }

   
   self.writeln( "end", baseIndent );
}


pub override fn convFilter.processExpCallSuper( 
   node: Ast.ExpCallSuperNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let typeInfo:Ast.TypeInfo = node.get_superType();
   self.write( "%s.__init( self, " ( typeInfo.getTxt() ) );

   if! node.$expList {
      filter( _exp, self, node, baseIndent );
   }
   self.writeln( ")", baseIndent );
};  


pub override fn convFilter.processDeclMethod( 
   node: Ast.DeclMethodNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let declInfo = node.get_declInfo();
   let mut delimit = ":";
   if declInfo.get_staticFlag() {
      delimit = ".";
   }  
   let methodNodeToken = unwrap declInfo.get_name();
   let methodName = methodNodeToken.txt;
   let classNameToken = unwrap declInfo.get_className();
   self.write( "function %s%s%s( "
               ( classNameToken.txt, delimit, methodName ) );

   let argList = declInfo.get_argList();
   foreach arg, index in argList {
      if index > 1 {
         self.write( ", " );
      } 
      filter( arg, self, node, baseIndent );
   }
   self.write( " )" );
   if! declInfo.$body {
      filter( _exp, self, node, baseIndent );
   }
   else {
      self.writeln("", baseIndent );
   }
   self.writeln( "end", baseIndent );
};    


pub override fn convFilter.processUnwrapSet(
   node: Ast.UnwrapSetNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let dstExpList = node.$dstExpList;
   filter( dstExpList, self, node, baseIndent );
   self.write( " = " );
   filter( node.$srcExpList, self, node, baseIndent );
   self.writeln( "", baseIndent );

   self.write( "if " );
   foreach expNode, index in dstExpList.$expList {
      if index > 1 {
         self.write( " or " );
      }   
      self.write( "nil == " );
      filter( expNode, self, node, baseIndent );
   }  
   self.writeln( " then", baseIndent + stepIndent );

   foreach expNode, index in dstExpList.$expList {
      self.write( "local _exp%d = " (index));
      filter( expNode, self, node, baseIndent + stepIndent );
      self.writeln( "", baseIndent + stepIndent );
   } 

   if node.$unwrapBlock {
      filter( unwrap node.$unwrapBlock, self, node, baseIndent + stepIndent );
   }
   self.writeln( "end", baseIndent );
}   

pub override fn convFilter.processIfUnwrap(
   node: Ast.IfUnwrapNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.writeln( "do", baseIndent + stepIndent );
   self.write( "local " );
   foreach varName, index in node.$varNameList {
      self.write( varName );
      if index ~= #node.$varNameList {
         self.write( ", " );
      }
   }
   self.write( " = " );

   foreach expNode, index in node.$expNodeList {
      filter( expNode, self, node, baseIndent + stepIndent );
      if index ~= #node.$expNodeList {
         self.write( ", " );
      }
   }
   self.writeln( "", baseIndent + stepIndent );

   self.write( "if " );
   foreach varName, index in node.$varNameList {
      self.write( "%s ~= nil" (varName) );
      if index ~= #node.$varNameList {
         self.write( " and " );
      }
   }
   self.writeln( " then", baseIndent + stepIndent );
   
   filter( node.$block, self, node, baseIndent + stepIndent * 2 );

   if node.$nilBlock {
      self.writeln( "else", baseIndent + stepIndent );

      filter( unwrap node.$nilBlock, self, node, baseIndent + stepIndent * 2 );
   }  
   self.writeln( "end", baseIndent );
   self.writeln( "end", baseIndent );
}       

pub override fn convFilter.processDeclVar( 
   node: Ast.DeclVarNode, parent: &Ast.Node, baseIndent:int ) mut
{
   if node.$syncBlock {
      self.writeln( "do", baseIndent + stepIndent );
      foreach varInfo in node.$syncVarList {
         self.writeln( "local _sync_%s" (varInfo.$name.txt),
                       baseIndent + stepIndent );
      }   
      self.writeln( "do", baseIndent + stepIndent * 2 );
   }

   if node.$mode ~= .Unwrap and node.get_accessMode() ~= .Global {
      self.write( "local " );
   }

   let varList = node.get_varList();
   foreach var, index in varList  {
      if index > 1 {
         self.write( ", " );
      } 
      self.write( var.$name.txt );
   } 

   if! node.get_expList() {
      self.write( " = " );
      filter( _exp, self, node, baseIndent );
   }

   self.writeln( "", baseIndent );

   if! node.$unwrapBlock {
      self.writeln( "", baseIndent + stepIndent * 2 );
      self.write( "if " );
      foreach var, index in varList {
         if index > 1 {
            self.write( " or " );
         }   
         self.write( " nil == " .. var.$name.txt );
      }
      self.writeln( " then", baseIndent + stepIndent * 3 );

      foreach var, index in varList  {
         self.writeln( "local _%s = %s" (var.$name.txt, var.$name.txt ),
                       baseIndent + stepIndent * 3 );
      }

      filter( _exp, self, node, baseIndent + stepIndent * 2 );

      if! let thenBlock = node.$thenBlock {     
         self.writeln( "else", baseIndent + stepIndent * 3 );
	 filter( thenBlock, self, node, baseIndent + stepIndent * 3);
      };
      
      self.writeln( "end", baseIndent + stepIndent * 1 );
   }   

   if! node.$syncBlock {
      filter( _exp, self, node, baseIndent + stepIndent * 1);

      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s = %s" (varInfo.$name.txt, varInfo.$name.txt),
                       baseIndent + stepIndent );
      }
      self.writeln( "end", baseIndent + stepIndent );
      
      foreach varInfo in node.$syncVarList {
         self.writeln( "%s = _sync_%s" (varInfo.$name.txt, varInfo.$name.txt),
                       baseIndent + stepIndent );
      }
      self.writeln( "end", baseIndent );
   }    
   

   if node.get_accessMode() == .Pub {
      self.writeln( "", baseIndent );
      foreach var, index in varList {
         let name: str = var.$name.txt;
         self.writeln( "_moduleObj.%s = %s" ( name, name ),
                       baseIndent );     
         self.pubVarName2InfoMap[ name ] = new PubVerInfo(
            node.$staticFlag, node.$accessMode,
            node.$symbolInfoList[ index ].$mutable, node.$typeInfoList[ index ] );
      }
   }  

   if self.macroDepth > 0 {
      self.writeln( "", baseIndent );
      foreach var, index in varList {
         let varName = var.$name.txt;
         self.writeln( "table.insert( macroVar._names, '%s' )" ( varName ),
                       baseIndent );     
         self.writeln( "macroVar.%s = %s" ( varName, varName ), baseIndent );
      }
   }  
};    

pub override fn convFilter.processDeclArg( 
   node: Ast.DeclArgNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( string.format( "%s", node.get_name().txt ) );

   // filter( // node.info.argType,  self, node, baseIndent )
}; 

pub override fn convFilter.processDeclArgDDD( 
   node: Ast.DeclArgDDDNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "..." );
};

pub override fn convFilter.processExpDDD( 
   node: Ast.ExpDDDNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "..." );
};

pub override fn convFilter.processDeclFunc( 
   node: Ast.DeclFuncNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let declInfo = node.get_declInfo();
   let nameToken = declInfo.get_name();
   let mut name = "";
   if! nameToken {
      name = _exp.txt;
   }  
   let mut letTxt = "";
   if declInfo.get_accessMode() ~= .Global and #name ~= 0 {
      letTxt = "local ";
   }  
   self.write( string.format( "%sfunction %s( ", letTxt, name ) );

   let argList = declInfo.get_argList();
   foreach arg, index in argList {
      if index > 1 {
         self.write( ", " );
      } 
      filter( arg, self, node, baseIndent );
   }
   self.write( " )" );
   // foreach refType, index in declInfo.get_retTypeList() {
   //    if index > 1 {
   //   self.write( ", " )
   //    }
   //filter( //    refType,  self, node, baseIndent )
   // }
   if! declInfo.$body { 
      filter( _exp,  self, node, baseIndent );
   }
   else {
      self.writeln( "", baseIndent );
   }
   self.writeln( "end", baseIndent );

   //if declInfo.get_accessMode() == .Pub {
   let expType: Ast.TypeInfo = node.get_expType();
   if expType.get_accessMode() == .Pub {
      self.write( "_moduleObj.%s = %s" ( name, name ) );

      self.pubFuncName2InfoMap[ name ] = new PubFuncInfo(
         declInfo.get_accessMode(), node.get_expType() );
   }   
};     

pub override fn convFilter.processRefType( 
   node: Ast.RefTypeNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( (node.get_refFlag() and "&" or "") ..
               (node.get_mutFlag() and "mut " or "") );
   filter( node.get_name(),  self, node, baseIndent );
   if node.get_array() == "array" {
      self.write( "[@]" );
   }
   elseif node.get_array() == "list" {
      self.write( "[]" );
   }
}; 

pub override fn convFilter.processIf( 
   node: Ast.IfNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let valList = node.get_stmtList();
   foreach val, index in valList {
      if index == 1 {
         self.write( "if " );
         filter( val.$exp,  self, node, baseIndent );
      }    
      elseif val.$kind == "elseif" {
         self.write( "elseif " );
         filter( val.$exp,  self, node, baseIndent );
      }   
      else {
         self.write( "else" );
      }  
      self.write( " " );
      filter( val.$block, self, node, baseIndent );
   }
   self.write( "end" );
};   

pub override fn convFilter.processSwitch( 
   node: Ast.SwitchNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.writeln( "do", baseIndent + 2 );
   self.write( "local _switchExp = " );
   filter( node.get_exp(),  self, node, baseIndent + 2 );
   self.writeln( "", baseIndent + 2 );

   foreach caseInfo, index in node.get_caseList() {
      if index == 1 {
         self.write( "if " );
      } 
      else {
         self.write( "elseif " );
      }
      let expList = caseInfo.get_expList();
      foreach expNode, index in expList.get_expList() {
         if index ~= 1 {
            self.write( " or " );
         }  

         self.write( "_switchExp == " );
         filter( expNode, self, node, baseIndent + 2 );
      }   
      self.write( " then" );
      filter( caseInfo.$block, self, node, baseIndent + 2 );
   }       
   if! node.get_default() {
      self.write( "else " );
      filter( _exp, self, node, baseIndent + 2 );
   }        
   self.writeln( "end", baseIndent );
   
   self.writeln( "end", baseIndent );
};  

pub override fn convFilter.processWhile( 
   node: Ast.WhileNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "while " );

   filter( node.get_exp(), self, node, baseIndent );
   self.write( " " );
   filter( node.get_block(), self, node, baseIndent );
   self.write( "end" );
};   

pub override fn convFilter.processRepeat( 
   node: Ast.RepeatNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "repeat " );
   filter( node.get_block(),  self, node, baseIndent );
   self.write( "until " );
   filter( node.get_exp(),  self, node, baseIndent );
};

pub override fn convFilter.processFor( 
   node: Ast.ForNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( string.format( "for %s = ", node.get_val().txt ) );
   filter( node.get_init(),  self, node, baseIndent );
   self.write( ", " );
   filter( node.get_to(),  self, node, baseIndent );
   if! node.get_delta() {
      self.write( ", " );
      filter( _exp,  self, node, baseIndent );
   }
   self.write( " " );
   filter( node.get_block(),  self, node, baseIndent );
   self.write( "end" );
};   

pub override fn convFilter.processApply( 
   node: Ast.ApplyNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "for " );
   let varList = node.get_varList();
   foreach var, index in varList {
      if index > 1 {
         self.write( ", " );
      }   
      self.write( var.txt );
   }
   self.write( " in " );
   filter( node.$exp,  self, node, baseIndent );
   self.write( " " );
   filter( node.$block,  self, node, baseIndent );
   self.write( "end" );
};    

pub override fn convFilter.processForeach( 
   node: Ast.ForeachNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "for " );
   if! node.$key {
      self.write( _exp.txt );
   }
   else {
      self.write( "__index" );
   }
   self.write( ", " );
   self.write( node.$val.txt );

   self.write( " in pairs( " );
   filter( node.$exp,  self, node, baseIndent );
   self.write( " ) " );
   filter( node.$block,  self, node, baseIndent );
   self.write( "end" );
};    

pub override fn convFilter.processForsort( 
   node: Ast.ForsortNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.writeln( "do", baseIndent + stepIndent );
   self.writeln( "local __sorted = {}", baseIndent + stepIndent );
   self.write( "local __map = " );
   filter( node.$exp,  self, node, baseIndent + stepIndent );
   self.writeln( "", baseIndent + stepIndent );
   self.writeln( "for __key in pairs( __map ) do", baseIndent + stepIndent * 2 );
   self.writeln( "table.insert( __sorted, __key )", baseIndent + stepIndent );
   self.writeln( "end", baseIndent + stepIndent );

   self.writeln( "table.sort( __sorted )", baseIndent + stepIndent );


   self.write( "for __index, " );
   let mut key = "__key";
   if! node.$key {
      key = _exp.txt;
   }
   self.write( key );
   self.writeln( " in ipairs( __sorted ) do", baseIndent + stepIndent * 2 );
   self.writeln( string.format( "%s = __map[ %s ]", node.$val.txt, key ),
                 baseIndent + stepIndent * 2 );
   filter( node.$block, self, node, baseIndent + stepIndent * 2 );
   self.writeln( "end", baseIndent + stepIndent );
   self.writeln( "end", baseIndent );
   self.writeln( "end", baseIndent );
};        


pub override fn convFilter.processExpUnwrap(
   node: Ast.ExpUnwrapNode, parent: &Ast.Node, baseIndent:int ) mut
{
   if! node.$default {
      self.write( '_lune.unwrapDefault( ' );
      filter( node.$exp, self, node, baseIndent );
      self.write( ', ' );
      filter( _exp, self, node, baseIndent );
      self.write( ')');
   }
   else {
      self.write( '_lune.unwrap( ' );
      filter( node.$exp, self, node, baseIndent );
      self.write( ')');
   } 
}    


pub override fn convFilter.processExpCall( 
   node: Ast.ExpCallNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let mut wroteFuncFlag = false;
   let mut setArgFlag = false;

   macro _fieldCall( fieldClass:sym ) {
      let fieldNode = node.$func@@Ast. ,,fieldClass;
      let prefixNode = fieldNode.$prefix;
      let prefixType = prefixNode.$expType;
      if node.$nilAccess {
         wroteFuncFlag = true;
         setArgFlag = true;
         if prefixType.$kind == Ast.TypeInfoKind.List {
            self.write( "_lune.nilacc( table.%s, nil, 'list', " (fieldNode.$field.txt ) );
            filter( prefixNode, self, fieldNode, baseIndent );
         }
         else {
            self.write( "_lune.nilacc( " );
            filter( prefixNode, self, fieldNode, baseIndent );
            self.write( ", '%s', 'callmtd' " (fieldNode.$field.txt ) );
         } 
      }
      else {
         if prefixType.$kind == Ast.TypeInfoKind.List {
            setArgFlag = true;
            wroteFuncFlag = true;
            self.write( "table.%s( " (fieldNode.$field.txt ) );
            filter( prefixNode, self, fieldNode, baseIndent );
         }
         elseif prefixType.$kind == Ast.TypeInfoKind.Enum {
            wroteFuncFlag = true;
            let fieldExpType = fieldNode.$expType;
            let canonicalName = self.getCanonicalName( prefixType );
            let mut methodName = fieldNode.$field.txt;
            if methodName == "get__txt" {
               methodName = "_getTxt";
            }  
            self.write( "%s:%s( " (canonicalName, methodName ) );
            if fieldExpType.$staticFlag {
               setArgFlag = false;
            }
            else {
               filter( prefixNode, self, fieldNode, baseIndent );
               setArgFlag = true;
            }
         }  
      }     
      
   }
   
   if node.$func.$kind == Ast.nodeKind.RefField {
      _fieldCall( RefFieldNode );
   }
   

   if not wroteFuncFlag {
      if node.$nilAccess {
         self.write( "_lune.nilacc( " );
         filter( node.$func, self, node, baseIndent );
         self.write( ", nil, 'call'" );
         wroteFuncFlag = true;
      }
      else {
         filter( node.$func, self, node, baseIndent );
         self.write( "( " );
      }
   }  

   
   if! node.$argList {
      if wroteFuncFlag and setArgFlag {
         if #_exp.$expList > 0 {
            self.write( ", " );
         }    
      } 
      filter( _exp,  self, node, baseIndent );
   }
   self.write( " )" );
};   


pub override fn convFilter.processExpList( 
   node: Ast.ExpListNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let expList = node.get_expList();
   //let expList = node.$expList;
   foreach exp, index in expList {
      if index > 1 {
         self.write( ", " );
      }    
      filter( exp, self, node, baseIndent );
   } 
};


pub override fn convFilter.processExpOp1( 
   node: Ast.ExpOp1Node, parent: &Ast.Node, baseIndent:int ) mut
{
   let mut op = node.$op.txt;
   // if op == ",,," or op == ",,,," {
   //     filter( node.$exp,  self, node, baseIndent );
   // }
   if op == ",,," {
      filter( node.$exp,  self, node, baseIndent );
   }  
   elseif op == ",,,," {
      if node.$macroMode == .Expand {
         filter( node.$exp,  self, node, baseIndent );
      }     
      else {
         self.write( "_luneSym2Str( " );
         filter( node.$exp,  self, node, baseIndent );
         self.write( " )" );
      }   
   }
   elseif op == ",," {
      self.write( "_luneGetLocal( " );
      filter( node.$exp,  self, node, baseIndent );
      self.write( " )" );
   }
   else {
      if op == "not" {
         op = op .. " ";
      }   
      self.write( op );
      filter( node.$exp,  self, node, baseIndent );
   } 
};   

pub override fn convFilter.processExpCast( 
   node: Ast.ExpCastNode, parent: &Ast.Node, baseIndent:int ) mut
{
   if node.$expType.equals( Ast.builtinTypeInt ) {
      self.write( "math.floor(" );
      filter( node.$exp,  self, node, baseIndent );
      self.write( ")" );
   }
   else {
      filter( node.$exp,  self, node, baseIndent );
   }
};


pub override fn convFilter.processExpParen( 
   node: Ast.ExpParenNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "(" );
   filter( node.$exp,  self, node, baseIndent );
   self.write( " )" );
};

pub override fn convFilter.processExpOp2( 
   node: Ast.ExpOp2Node, parent: &Ast.Node, baseIndent:int ) mut
{
   let mut intCast = false;
   if node.$expType.equals( Ast.builtinTypeInt ) and node.$op.txt == "/" {
      intCast = true;
      self.write( "math.floor(" );
   } 
   
   filter( node.$exp1,  self, node, baseIndent );

   self.write( " " .. node.$op.txt .. " " );

   filter( node.$exp2,  self, node, baseIndent );

   if intCast {
      self.write( ")" );
   }
};  

pub override fn convFilter.processExpRef( 
   node: Ast.ExpRefNode, parent: &Ast.Node, baseIndent:int ) mut
{
   if node.$symbolInfo.$accessMode == .Pub and
      node.$symbolInfo.$kind == Ast.SymbolKind.Var
   {  
      self.write( "_moduleObj." );
   } 
   self.write( node.$token.txt );
};

pub override fn convFilter.processExpRefItem( 
   node: Ast.ExpRefItemNode, parent: &Ast.Node, baseIndent:int ) mut
{
   if node.$nilAccess {
      self.write( "_lune.nilacc( " );
      filter( node.$val, self, node, baseIndent );
      self.write( ", nil, 'item', " );
      if! node.$index {
         filter( _exp, self, node, baseIndent );
      }
      else {
         self.write( "'%s'" ( unwrap node.$symbol ) );
      }
      self.write( ")" );
   }
   else {
      if node.$val.$expType.equals( Ast.builtinTypeString ) {
         self.write( "string.byte( " );
         filter( node.$val, self, node, baseIndent );
         self.write( ", " );
         if! node.$index {
            filter( _exp, self, node, baseIndent );
         }
         else {
            error( "index is nil" );
         }
         self.write( " )" );
      }
      else {
         filter( node.$val, self, node, baseIndent );
         self.write( "[" );
         if! node.$index {
            filter( _exp, self, node, baseIndent );
         }
         else {
            self.write( "'%s'" ( unwrap node.$symbol ) );
         }
         self.write( "]" );
      } 
   }    
};      

pub override fn convFilter.processRefField( 
   node: Ast.RefFieldNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let prefix = node.get_prefix();

   if node.$nilAccess {
      self.write( '_lune.nilacc( ' );
      filter( prefix,  self, node, baseIndent );
      self.write( ', "%s" )' (node.$field.txt) );
   } 
   else {
      filter( prefix,  self, node, baseIndent );
      
      let mut delimit = ".";
      if parent.$kind == Ast.nodeKind.ExpCall {
         if node.get_expType().get_kind() == Ast.TypeInfoKind.Method {
            delimit = ":";
         }
         else {
            delimit = ".";
         }   
      }  
      let fieldToken = node.get_field();
      self.write( delimit .. fieldToken.txt );
   }   
};     

pub override fn convFilter.processExpOmitEnum( 
   node: &Ast.ExpOmitEnumNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let! mut moduleName = self.typeInfo2ModuleName[ node.$expType.getModule() ] {
      moduleName = "";
   }
   then {
      // Util.errorLog( "hoge: %s %s"
      //                (node.$expType.getModule().getTxt(),
      //                  self.moduleTypeInfo.getTxt() ) );
      
      moduleName = moduleName.gsub( ".*%.", "" );
      moduleName = moduleName .. ".";
   };
   self.write( "%s%s.%s" (moduleName, node.$expType.getTxt(), node.$valToken.txt ) );
};

pub override fn convFilter.processGetField(
   node: Ast.GetFieldNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let prefixNode = node.get_prefix();
   let prefixType = prefixNode.$expType;
   let mut fieldTxt = node.get_field().txt;
   if fieldTxt == "_txt" and prefixType.$kind == Ast.TypeInfoKind.Enum {
      let canonicalName = self.getCanonicalName( prefixType );
      self.write( "%s:_getTxt( " (canonicalName ) );
      filter( prefixNode, self, node, baseIndent );
      self.writeln( ")", baseIndent );
   }
   else {
      filter( prefixNode,  self, node, baseIndent );
      let mut delimit = ".";
      if node.get_getterTypeInfo().get_kind() == Ast.TypeInfoKind.Method {
         delimit = ":";
      }   
      else {
         delimit = ".";
      }   
      if node.get_getterTypeInfo() {
         fieldTxt = "get_%s()" ( fieldTxt );
      }   
      self.write( delimit .. fieldTxt );
   }
};  


pub override fn convFilter.processReturn( 
   node: Ast.ReturnNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "return " );

   if! node.$expList {
      filter( _exp,  self, node, baseIndent );
   }
}; 

pub override fn convFilter.processProvide(
   node: Ast.ProvideNode, parent:Ast.Node, baseIndent:int ) mut
{
}


pub override fn convFilter.processLiteralList( 
   node: Ast.LiteralListNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "{" );

   if! node.$expList {
      filter( _exp, self, node, baseIndent );
   }

   self.write( "}" );
};  

pub override fn convFilter.processLiteralMap( 
   node: Ast.LiteralMapNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "{" );
   let pairList = node.$pairList;
   foreach pair, index in pairList {
      if index > 1 {
         self.write( ", " );
      }   
      self.write( "[" );
      filter( pair.$key, self, node, baseIndent );
      self.write( "] = " );
      filter( pair.$val, self, node, baseIndent );
   }

   self.write( "}" );
};  


pub override fn convFilter.processLiteralArray( 
   node: Ast.LiteralArrayNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "{" );

   if! node.$expList {
      filter( _exp, self, node, baseIndent );
   }

   self.write( "}" );
};  


pub override fn convFilter.processLiteralChar( 
   node: Ast.LiteralCharNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( string.format( "%g", node.$num ) );
};

pub override fn convFilter.processLiteralInt( 
   node: Ast.LiteralIntNode, parent: &Ast.Node, baseIndent:int ) mut
{
   //self.write( string.format( "%d", node.$num ) );
   self.write( node.$token.txt );

};

pub override fn convFilter.processLiteralReal( 
   node: Ast.LiteralRealNode, parent: &Ast.Node, baseIndent:int ) mut
{
   //self.write( string.format( "%s", node.$num ) );
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralString( 
   node: Ast.LiteralStringNode, parent: &Ast.Node, baseIndent:int ) mut
{
   let mut txt = node.get_token().txt;
   if string.find( txt, '^```' ) {
      txt = '[==[' .. txt.sub( 4, -4 ) .. ']==]';
   }  
   let argList = node.get_argList();
   if #argList > 0 {
      self.write( string.format( 'string.format( %s, ', txt ) );
      foreach val, index in argList {
         if index > 1 {
            self.write( ", " );
         }      
         filter( val,  self, node, baseIndent );
      }   
      self.write( ")" );
   }
   else {
      self.write( txt );
   }
};  

pub override fn convFilter.processLiteralBool( 
   node: Ast.LiteralBoolNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralNil( 
   node: Ast.LiteralNilNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "nil" );
};

pub override fn convFilter.processBreak( 
   node: Ast.BreakNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( "break" );
};

pub override fn convFilter.processLiteralSymbol( 
   node: Ast.LiteralSymbolNode, parent: &Ast.Node, baseIndent:int ) mut
{
   self.write( '%s' ( node.$token.txt ) );
};


pub fn createFilter(
   streamName: str, stream: oStream, metaStream: oStream,
   convMode: ConvMode, inMacro: bool, moduleTypeInfo: &Ast.TypeInfo ) : Ast.Filter
{
   return new convFilter( streamName, stream, metaStream,
                          convMode, inMacro, moduleTypeInfo );
}


pub class MacroEvalImp extend Ast.MacroEval {
   pri let mode: str;

   pub override fn eval( node: Ast.DeclMacroNode ): form
   {   
      let mut oStream = new Util.memStream();
      let mut conv = new convFilter(
         "macro", oStream, oStream, .Exec, true, Ast.rootTypeInfo );

      conv.processDeclMacro( node, node, 0 );

      //Util.errorLog( 'hoooo: %s' (oStream.get_txt()) );
      
      let chunk, err = load( oStream.get_txt() );
      if err {
         Util.err( err );
      }
      if! chunk {
         let mod = _exp();
         if not mod {
            Util.err( "macro load error" );
         }   
         return (unwrap mod)@@form;
      }
      Util.err( "failed to load -- " .. node.$declInfo.$name );
   }  
}     
