/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

fn TransUnit.MultiTo1( mut exp:Nodes.Node ) mut : Nodes.Node {
   if #exp.$expTypeList > 1 {
      exp = Nodes.ExpMultiTo1Node.create(
         self.nodeManager, exp.$pos, self.inTestBlock,
         exp.$macroArgFlag, [ exp.$expType ], exp );
   } else {
      if! let dddType = exp.$expType@@@Ast.DDDTypeInfo {
         exp = Nodes.ExpMultiTo1Node.create(
            self.nodeManager, exp.$pos, self.inTestBlock, exp.$macroArgFlag,
            [ dddType.$typeInfo.$nilableTypeInfo ], exp );
      }
   }
   return exp;
}

/**
一つの値を持つ R-Value の expression を期待する。

多値の expression の場合、 ExpMultiTo1 ノードでラッピングする。
*/
fn TransUnit.analyzeExpOneRVal(
   allowNoneType:bool, skipOp2Flag: bool, canCondRet:bool!, opLevel: int!,        
   expectType:&Ast.TypeInfo! ) mut : Nodes.Node
{
   let mut exp = self.analyzeExp(
      allowNoneType, skipOp2Flag, false,
      unwrap canCondRet default false, opLevel, expectType );
   exp = self.MultiTo1( exp );

   when! expectType {
      switch expectType.$kind {
         case .IF, .Class {
            let expOrgType = exp.$expType.$nonnilableType.$srcTypeInfo;
            let exceptOrgType = expectType.$nonnilableType.$srcTypeInfo;
            if expOrgType.isInheritFrom( self.processInfo, exceptOrgType ##) {
               exp = Nodes.ExpCastNode.create(
                  self.nodeManager, exp.$pos, self.inTestBlock,
                  self.macroCtrl.isInAnalyzeArgMode(), [ expectType ],
                  exp, expectType, nil, "", .Implicit );   
            }
         }
      }
   }
   
   return exp;
}

/**
ExpNode のリスト expList を、 expTypeList 


*/
fn TransUnit.createExpList(
   pos:&Parser.Position,
   expTypeList:List<&Ast.TypeInfo>, expList:&List<&Nodes.Node>,
   followOn:bool, abbrNode:&Nodes.AbbrNode! ) mut: Nodes.ExpListNode
{
   let mut workList:List<&Nodes.Node> = [];
   let mut mRetExp:Nodes.MRetExp! = nil;
   if #expList > 0 {
      foreach exp, index in expList {
         if expTypeList[ index ] ~= Ast.builtinTypeMultiExp and
            Nodes.hasMultiValNode( exp )
         {
            // 複数の結果を持つ場合
            if index ~= #expList {
               // 最終ノード以外
               let firstType;
               if! let dddType = exp.$expType@@@Ast.DDDTypeInfo {
                  firstType = dddType.$typeInfo.$nilableTypeInfo;
               }
               else {
                  firstType = exp.$expType;
               }
               workList.insert(
                  Nodes.ExpMultiTo1Node.create(
                     self.nodeManager, exp.$pos, self.inTestBlock,
                     exp.$macroArgFlag, [ firstType ], exp ) );
            }
            else {
               //workList.insert( exp );
               // 最終ノードが複数の値を持つ場合は、その複数の型を追加する。
               mRetExp = new Nodes.MRetExp( exp, index );
               foreach expType, listIndex in exp.$expTypeList {
                  if listIndex ~= 1 {
                     expTypeList.insert( expType );
                  }
               }
               // 多値返却の場合、 ExpAccessMRet を追加する。
               foreach retType, retIndex in exp.$expTypeList {
                  if retIndex == 1 {
                     workList.insert( 
                        Nodes.ExpMRetNode.create(
                           self.nodeManager, exp.$pos, self.inTestBlock,
                           exp.$macroArgFlag, [ retType ], exp ) );
                  } else {
                     workList.insert( 
                        Nodes.ExpAccessMRetNode.create(
                           self.nodeManager, exp.$pos, self.inTestBlock,
                           exp.$macroArgFlag, [ retType ], exp, retIndex ) );
                  }
               }
            }
         }
         else {
            workList.insert( exp );
         }
      }
   }

   when! abbrNode {
      workList.insert( abbrNode );
   }

   return Nodes.ExpListNode.create(
      self.nodeManager, pos, self.inTestBlock, self.macroCtrl.isInAnalyzeArgMode(),
      expTypeList, workList, mRetExp, followOn );
}

/**
式のリスト exp, exp, exp ... を解析する。

@param allowNoneType true の場合、exp の評価結果が TypeInfoNone となるようなケースを許可する
@param skipOp2Flag true の場合、2項演算の解析は行なわない。
@param expNode 式のリストの先頭に加える式。 nil の場合は、リストに追加しない。
@param expectTypeList。 各式に期待する型。
  期待する型がない場合は、リストの要素に TypeInfoNone を指定する。
@param contExpect true の場合、 解析する式が、 expectTypeList の要素数を越えた時に、
    expectTypeList の最終要素の型を使用する。

*/
fn TransUnit.analyzeExpList(
   allowNoneType:bool, skipOp2Flag: bool, canLeftExp:bool, canCondRet:bool,
   expNode: &Nodes.Node!,
   expectTypeList: &List<&Ast.TypeInfo>!, contExpect:bool! ) mut: Nodes.ExpListNode
{
   let mut expList:List<&Nodes.Node> = [];
   let mut pos:&Parser.Position! = nil;
   let mut expTypeList:List<&Ast.TypeInfo> = [];
   when! expNode {
      pos = expNode.$pos;
      expList.insert( expNode );
      expTypeList.insert( expNode.$expType );
   }

   let mut index = 1;
   let mut abbrNode:&Nodes.AbbrNode! = nil;
   let mut followOn = false;
   repeat {
      // 期待値の確定
      let mut expectType:&Ast.TypeInfo! = nil;
      let mut allowNoneTypeOne = allowNoneType;
      when! expectTypeList {
         if #expectTypeList > 0 {
            let mut checkIndex = index;
            if index > #expectTypeList and contExpect {
               checkIndex = #expectTypeList;
            }
            if checkIndex <= #expectTypeList and
               expectTypeList[ checkIndex ] ~= Ast.builtinTypeNone
            {
               let worktype = expectTypeList[ checkIndex ];
               expectType = worktype;
               if worktype == Ast.builtinTypeExp {
                  allowNoneTypeOne = true;
               }
            }
         }
      }

      let mut exp;
      
      if self.macroCtrl.$analyzeInfo.$mode == .AnalyzeArg {
         // マクロ用の引数解析
         switch expectType {
            case Ast.builtinTypeExp, Ast.builtinTypeMultiExp {
               self.macroCtrl.switchMacroMode();
               exp = self.analyzeExp(
                  allowNoneTypeOne, skipOp2Flag, canLeftExp, canCondRet, 0, expectType );
               self.macroCtrl.restoreMacroMode();
            }
            case Ast.builtinTypeBlockArg {
               //self.macroCtrl.switchMacroMode();
               exp = self.analyzeBlock( .Macro, .Ignore ##);
               //self.macroCtrl.restoreMacroMode();
            }
            default {
               exp = self.analyzeExp(
                  allowNoneTypeOne, skipOp2Flag, canLeftExp, canCondRet, 0, expectType );
            }
         }
      }
      else {
         exp = self.analyzeExp(
            allowNoneTypeOne, skipOp2Flag, canLeftExp, canCondRet, 0, expectType );
      }

      
      if not allowNoneTypeOne and
         expectType ~= Ast.builtinTypeBlockArg and
         not exp.canBeRight( self.processInfo )
      {
         self.addErrMess(
            exp.$effectivePos,
            "This arg can't be r-value. -- %s" ( Nodes.getNodeKindName( exp.$kind) ) );
      }
      if not pos {
         pos = exp.$pos;
      }
      switch expectType {
         case Ast.builtinTypeExp, Ast.builtinTypeMultiExp, Ast.builtinTypeBlockArg {
            exp = Nodes.ExpMacroArgExpNode.create(
               self.nodeManager, exp.$pos, self.inTestBlock,
               self.macroCtrl.isInAnalyzeArgMode(), exp.$expTypeList,
               Macro.nodeToCodeTxt( exp, self.moduleType ), exp );
            expTypeList.insert( unwrap expectType );
         }
         default {
            expTypeList.insert( exp.$expType );
         }
      }
      expList.insert( exp );
      let mut token = self.getToken( true );

      if token.txt == "**" {
         //if #exp.$expTypeList <= 1 {
         if not Nodes.hasMultiValNode( exp ) {
            self.addErrMess(
               exp.$pos,
               "This arg(%d) doesn't have multiple value. It must not use '**'" (index) );
         }
         followOn = true;
         
         token = self.getToken( true );
      }
      
      if token.txt == "##" {
         if exp.$expType.$kind == .DDD {
            self.addErrMess( token.pos, "'##' can't use with '...'" );
         }
         abbrNode = Nodes.AbbrNode.create(
            self.nodeManager, token.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeAbbr ] );
         self.getToken(##);
         break;
      }

      index = index + 1;
      if self.macroCtrl.$analyzeInfo.equalsArgTypeList( expectTypeList ) {
         self.macroCtrl.$analyzeInfo.nextArg();
      }
   } token.txt ~= ",";

   let mut expListNode = self.createExpList(
      unwrap pos default self.createPosition( 0, 0 ),
      expTypeList, expList, followOn, abbrNode );

   if not allowNoneType {
      foreach expType, expIndex in expTypeList {
         if expType == Ast.builtinTypeNone {
            self.addErrMess( unwrap pos default self.createPosition( 0, 0 ),
                             "The type of exp(%d) is None!!" (expIndex) );
         }
      }
   }

   self.pushback();

   return expListNode;
}

fn TransUnit.checkSymbolHavingValue(
   pos:&Parser.Position, symbolInfoList:&List<&Ast.SymbolInfo> ) mut
{
   foreach symbolInfo in symbolInfoList {
      if symbolInfo.$kind == .Var {
         if not symbolInfo.$hasValueFlag {
            self.addErrMess(
               pos, "this variable have no value. -- %s" (symbolInfo.$name) );
         }
      }
   }
}


fn TransUnit.analyzeExpRefItem(
   token: &Parser.Token, exp: &Nodes.Node, mut nilAccess:bool ) mut : Nodes.Node
{
   self.checkSymbolHavingValue( exp.$pos, exp.getSymbolInfo() );
      
   let mut expType = exp.$expType;

   expType = expType.$extedType;
   if nilAccess {
      if not exp.$expType.$nilable {
         self.addWarnMess( token.pos, "This is not nilable. -- %s" (expType.getTxt(##)) );
         nilAccess = false;
      }
      else {
         expType = expType.$nonnilableType;
      }
   } elseif exp.$expType.$nilable {
      self.addErrMess( token.pos,
                       "could not access with []. Use '$[]'-- %s"
                       (exp.$expType.getTxt(##)) );
   }

   let mut expectItemType:&Ast.TypeInfo! = nil;
   // 参照したアイテムの型情報
   let mut typeInfo = Ast.builtinTypeStem_;
   // 指定すべき index の型
   let mut indexTypeInfo = Ast.builtinTypeInt;
   if expType.$kind == .Map {
      let itemTypeList = expType.get_itemTypeInfoList();
      typeInfo = itemTypeList[2];
      indexTypeInfo = itemTypeList[1];
      expectItemType = itemTypeList[1];
      if not typeInfo.equals( self.processInfo, Ast.builtinTypeStem_ ##) and
         not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
   }
   elseif expType.$kind == .Array or expType.$kind == .List
   {
      typeInfo = expType.get_itemTypeInfoList()[1];
   }
   elseif expType.equals( self.processInfo, Ast.builtinTypeString ##) {
      typeInfo = Ast.builtinTypeInt;
   }
   elseif expType.equals( self.processInfo, Ast.builtinTypeStem ##) {
      indexTypeInfo = Ast.builtinTypeStem;
      typeInfo = Ast.builtinTypeStem_;
   }
   else {
      self.addErrMess(
         exp.$pos,
         "could not access with []. -- %s" (exp.$expType.getTxt(##)) );
   }

   if nilAccess {
      self.helperInfo.useNilAccess = true;
      if not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
   }

   if Ast.TypeInfo.isMut( typeInfo ) {
      if expType.$mutMode == .IMutRe {
         typeInfo = self.createModifier( typeInfo, .IMutRe );
      }
      // let list:&List<Val> の list[1] を &Val として扱う場合は、ここを有効にする。
      // ただ、 list[1] を &Val とするならば、 &List<&Val> とすべき。
      // &List<Val> ならば list[1] は Val であるべき。
      // elseif not Ast.TypeInfo.isMut( expType ) {
      //    typeInfo = self.createModifier( typeInfo, .IMut );
      // }
   }

   if Ast.isExtType( exp.$expType.$nonnilableType ) {
      typeInfo = self.createExtType( exp.$pos, typeInfo );

      if not self.macroCtrl.$analyzeInfo.isAnalyzingBlockArg() and
         not self.$curNsInfo.canAccessLuaval()
      {
         self.addErrMess(
            token.$pos,
            "can't access Luaval without __luago. -- %s" (exp.$expType.getTxt(##)) );
      }
   }

   let indexExp = self.analyzeExpOneRVal( false, false, false, nil, expectItemType );
   if not indexExp.canBeRight( self.processInfo ) {
      self.addErrMess( indexExp.$pos, "This node can't use index" );
   }
   if not indexTypeInfo.canEvalWith(
      self.processInfo, indexExp.$expType, .SetOp, {} ) {
      self.addErrMess( indexExp.$pos,
                       "unmatch index type -- %s, %s"
                       ( indexTypeInfo.getTxt(##), indexExp.$expType.getTxt(##) ) );
   }
   
   self.checkNextToken( "]" );

   if expType.$kind == .Array or expType.$kind == .List {
      if! let indexLit = indexExp.getLiteral() {
         match indexLit {
            case .Int( val ) {
               if val <= 0 {
                  self.addWarnMess( indexExp.$pos, "index <= -1 (%d)" (val) );
               }
            }
         }
      }
   }

   return Nodes.ExpRefItemNode.create(
      self.nodeManager, token.pos,  self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ typeInfo ], exp, nilAccess, nil, indexExp );
}


/**
expListNode の値を dstTypeList へ代入する際に、
暗黙キャストされるかどうかをチェックし、
暗黙キャストされる場合、そのノードを ExpCastNode に変換した
ノードリストを返す。

@param alt2typeMap generics 情報
@param dstTypeList 代入先型リスト
@param expListNode 代入元ノードリスト
@param callback 暗黙キャストをするかどうかの判定コールバック

*/
fn TransUnit.checkImplicitCast(
   alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo>, validCastToGen:bool,
   dstTypeList:&List<&Ast.TypeInfo>, expListNode:&Nodes.ExpListNode,
   callback:checkImplicitCastCallback ) mut : Nodes.ExpListNode!
{
   let expNodeList = expListNode.$expList;
   let mut newExpNodeList:List<&Nodes.Node> = [];
   let mut expTypeList:List<&Ast.TypeInfo> = [];


   // 暗黙キャストを行なった場合 true にセットする
   let mut hasModNode = false;
   

   // 代入元の値から、代入先の型に暗黙キャストしているかどうか確認し、
   // 暗黙キャストしている場合は ExpCastNode を生成する。
   fn process( index:int, dstType:&Ast.TypeInfo, expNode:&Nodes.Node,
               mut workNode:&Nodes.Node ) __trans : &Nodes.Node, bool
   {
      //if dstType.$kind == .Box and expNode.$expType.$kind ~= .Box {
      if! let repNode = callback( dstType, expNode ) {
         if not hasModNode {
            hasModNode = true;
         }
         workNode = repNode;
      }
      else {
         if expNode.$expType ~= Ast.builtinTypeNil and
            dstType ~= Ast.builtinTypeEmpty and
            not dstType.$srcTypeInfo.equals( self.processInfo,
                                             expNode.$expType.$srcTypeInfo ## ) and       
            not dstType.$nonnilableType.$srcTypeInfo.equals(
               self.processInfo, expNode.$expType.$srcTypeInfo ## )
         {
            if expNode.$kind ~= Nodes.NodeKind.$Abbr {
               if not hasModNode {
                  hasModNode = true;
               }
               if dstType.$kind == .DDD {
                  let mut argList:List<&Nodes.Node> = [];
                  let mut argTypeList:List<&Ast.TypeInfo> = [];
                  for workIndex = index, #expNodeList {
                     let appNode = expNodeList[ workIndex ];
                     argList.insert( appNode );
                     if workIndex == #expNodeList {
                        foreach expType in appNode.$expTypeList {
                           argTypeList.insert( expType );
                        }
                     }
                     else {
                        argTypeList.insert( appNode.$expType );
                     }
                  }

                  let mRetExp:Nodes.MRetExp!;
                  if! let workMRetExp = expListNode.$mRetExp {
                     mRetExp = new Nodes.MRetExp(
                        workMRetExp.$exp, workMRetExp.$index - index + 1 );

                     if #argList == 0 {
                        return Nodes.ExpSubDDDNode.create(
                           self.nodeManager, expNode.$pos, self.inTestBlock,
                           self.macroCtrl.isInAnalyzeArgMode(),
                           workMRetExp.$exp.$expTypeList,
                           workMRetExp.$exp, index - workMRetExp.$index ), true;
                     }
                  }
                  else {
                     mRetExp = nil;
                  }
                  let newExpListNode = Nodes.ExpListNode.create(
                     self.nodeManager, expNode.$pos, self.inTestBlock,
                     self.macroCtrl.isInAnalyzeArgMode(), argTypeList, argList,
                     mRetExp, expListNode.$followOn );
                  
                  workNode = Nodes.ExpToDDDNode.create(
                     self.nodeManager, expNode.$pos, self.inTestBlock,
                     self.macroCtrl.isInAnalyzeArgMode(),
                     [ dstType ], newExpListNode );
                  return workNode, true;
               }
               else {
                  let castType;
                  if validCastToGen {
                     castType = unwrap alt2typeMap[ dstType ] default dstType;
                  } else {
                     castType = dstType;
                  }
                  workNode = Nodes.ExpCastNode.create(
                     self.nodeManager, expNode.$pos, self.inTestBlock,
                     self.macroCtrl.isInAnalyzeArgMode(),
                     [ expNode.$expType ], expNode, castType, nil, "", .Implicit );   
               }
            }
         }
      }
      return workNode, false;
   }
   
   foreach expNode, index in expNodeList {
      // 代入元の値から、代入先の型に暗黙キャストしているかどうか確認し、
      // 暗黙キャストしている場合は ExpCastNode を生成する。
      let mut workNode = expNode;
      let mut stopFlag = false;
      if #dstTypeList >= index {
         if index == #expNodeList and expNode.$expType.$kind == .DDD {
            // 最終ノードが DDD の場合、
            // 残りの代入先に対して調べる
            for dstIndex = index, #dstTypeList {
               workNode = expNode;
               workNode, stopFlag = process(
                  dstIndex, dstTypeList[ dstIndex ], expNode, workNode );
               newExpNodeList.insert( workNode );
               expTypeList.insert( workNode.$expType );
            }
            break;
         }
         else {
            workNode, stopFlag = process( index, dstTypeList[ index ],
                                          expNode, workNode );
         }
      }

      newExpNodeList.insert( workNode );
      expTypeList.insert( workNode.$expType );
      if stopFlag {
         break;
      }
   }

   if not hasModNode {
      return nil;
   }

   let mut newMRetExp:&Nodes.MRetExp! = nil;
   if! let mRetExp = expListNode.$mRetExp {
      if mRetExp.$index <= #dstTypeList and dstTypeList[ mRetExp.$index ].$kind ~= .DDD
      {
         // 代入元の多値の先頭位置と、代入先の ... の位置が異なる場合、
         // 代入元の多値位置情報を記録する。
         // 位置が同じ場合は、そのまま代入するだけなので記録しない。
         newMRetExp = mRetExp;
      }
   }
   
   return Nodes.ExpListNode.create(
      self.nodeManager, expListNode.$pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      expTypeList, newExpNodeList, newMRetExp, expListNode.$followOn );
}


/**
型の一致性を確認する。

@param message 不一致時に出力するメッセージ
@param pos 不一致時に出力するコードの場所
@param dstTypeList 設定先の型のリスト
@param expListNode 設定する値の型リスト
@param allowDstShort dstTypeList の要素数が expNodeList よりも少ないことを許容する場合 true
@param warnForFollow true の場合、値を省略している時に警告を出力する
@param genericsClassType dstTypeList のメソッドが属するクラス
@param altDetectFlag genericsClassType の createAlt2typeMap() をコールする際の引数。
@param validImplicitCast 暗黙キャストを有効にする場合 true
@return Map<&Ast.TypeInfo,&Ast.TypeInfo>  AlternateTypeInfo → 実型パラメータのマップ
@return 
*/
fn TransUnit.checkMatchType(
   mut message:str, pos: &Parser.Position, dstTypeList: &List<&Ast.TypeInfo>,
   expListNode: &Nodes.ExpListNode!, allowDstShort:bool, warnForFollow:bool,
   workAlt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo>!, validImplicitCast:bool ) mut :
   //genericsClassType:&Ast.TypeInfo!, altDetectFlag:bool ) mut :
Ast.MatchType, Map<&Ast.TypeInfo,&Ast.TypeInfo>, Nodes.ExpListNode!, &List<&Ast.TypeInfo>
{
   let! expNodeList:&List<&Nodes.Node> = expListNode$.$expList {
      expNodeList = [];
   };
   let mut warnForFollowSrcIndex:int! = nil;
   let mut expTypeList:List<&Ast.TypeInfo> = [];

   // expNodeList から、評価後の型リスト expTypeList を取得する。
   // ## で省略を明示した場合、expNodeList の末尾には AbbrNode が入っている。
   // 多値使用警告を正常に判定するため、一旦 AbbrNode を抜く。
   let mut workExpNodeList = expNodeList;
   let mut hasAbbr = false;
   if #expNodeList > 0 {
      if expNodeList[ #expNodeList ].$kind == Nodes.NodeKind.$Abbr {
         hasAbbr = true;
         let mut workList:List<&Nodes.Node> = [];
         foreach node in expNodeList {
            workList.insert( node );
         }
         workList.remove(##);
         workExpNodeList = workList;
      }
   }

   // 実際にコード上で指定されている exp の数。
   // 多値返却があると、workExpNodeList の要素数と実際のコード上の exp の数が異なるので、
   // ExpAccessMRet を除外した数を取得する。
   let mut realExpNum = -1;
   
   foreach expNode, index in workExpNodeList {
      if realExpNum == -1 and expNode.$kind == Nodes.NodeKind.$ExpAccessMRet {
         realExpNum = index - 1;
      }
      if index == #workExpNodeList and expNode@@@Nodes.ExpMacroArgExpNode == nil {
         foreach expType in expNode.$expTypeList {
            expTypeList.insert( expType );
         }
      }
      else {
         expTypeList.insert( expNode.$expType );
      }
   }
   if realExpNum == -1 {
      realExpNum = #workExpNodeList;
   }
   
   if warnForFollow and #expTypeList > realExpNum {
      warnForFollowSrcIndex = realExpNum + 1;
   }
   if hasAbbr {
      expTypeList.insert( Ast.builtinTypeAbbr );
   }

   let mut alt2typeMap;
   when! workAlt2typeMap {
      alt2typeMap = workAlt2typeMap;
   } else {
      alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
   }

   // let mut alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
   // when! genericsClassType {
   //    alt2typeMap = genericsClassType.createAlt2typeMap( altDetectFlag );
   // }

   Ast.CanEvalCtrlTypeInfo.setupNeedAutoBoxing( alt2typeMap, self.processInfo );
   
   let result, mess = Ast.TypeInfo.checkMatchType(
      self.processInfo,
      dstTypeList, expTypeList, allowDstShort, warnForFollowSrcIndex, alt2typeMap );
   //Ast.AlternateTypeInfo.createAlt2typeMap( applyGeneric ) ); 
   switch result {
      case .Error {
         self.addErrMess( pos, "%s: %s" (message, mess ) );
      }
      case .Warn {
         if not self.ctrl_info.checkingDefineAbbr and
            Code.isMessageOf( .nothing_define_abbr, mess )
         {
         }
         else {
            self.addWarnMess( pos, "%s: %s" (message, mess ) );
         }
      }
   }


   when! expListNode {
      let mut autoBoxingCount = 0;
      let mut hasImplictCast = false;
      let mut newExpListNode:Nodes.ExpListNode!;

      if result ~= .Error {
         if validImplicitCast {
            if! let mut workList = self.checkImplicitCast(
               alt2typeMap, false, dstTypeList, expListNode,
               fn ( dstType:&Ast.TypeInfo, expNode:&Nodes.Node ): &Nodes.Node! {
                  if Ast.CanEvalCtrlTypeInfo.canAutoBoxing( dstType, expNode.$expType ) {
                     autoBoxingCount = autoBoxingCount + 1;

                     return Nodes.BoxingNode.create(
                        self.nodeManager, expNode.$pos, self.inTestBlock,
                        self.macroCtrl.isInAnalyzeArgMode(), [ dstType ], expNode );
                  }
                  return nil;
               } )
            {
               newExpListNode = workList;
               hasImplictCast = true;
            }
            else {
               newExpListNode = nil;
            }
         } else {
            //newExpListNode = expListNode;
            newExpListNode = Nodes.ExpListNode.create(
               self.nodeManager, expListNode.$pos, expListNode.$inTestBlock,
               expListNode.$macroArgFlag,
               expListNode.$expTypeList,
               expListNode.$expList, expListNode.$mRetExp, expListNode.$followOn );
            hasImplictCast = false;
         }
      } else {
         newExpListNode = nil;
      }
      

      if autoBoxingCount > 0 {
         if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap,
                                                              autoBoxingCount )
         {
            self.addErrMess( pos, "illegal auto boxing error -- %d" (autoBoxingCount) );
         }
         
         return result, alt2typeMap, newExpListNode, expTypeList;
      }
      elseif Ast.CanEvalCtrlTypeInfo.hasNeedAutoBoxing( alt2typeMap ) {
         self.addErrMess( pos, "not support auto boxing" );
      }

      
      if hasImplictCast {
         return result, alt2typeMap, newExpListNode, expTypeList;
      }
   }
   if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 0 ) {
      self.addErrMess( pos, "can't auto boxing error" );
   }
   
   
   return result, alt2typeMap, nil, expTypeList;
}



/**
関数 funcTypeInfo の引数に expList を指定している時の、引数型チェックを行なう。

@param pos この引数チェックを行なっているソース位置
@param funcTypeInfo 関数型
@param expList 引数情報
@param genericTypeList generics に与えられている型
@param genericsClass funcTypeInfo がメソッドだったときの、
    そのメソッドが定義されているクラス
@return Ast.MatchType マッチ結果
@return Map<&Ast.TypeInfo,&Ast.TypeInfo> AlternateTypeInfo → 実型パラメータのマップ
@return &Nodes.ExpListNode! 暗黙キャストなどを解決した引数 
*/
fn TransUnit.checkMatchValType(
   pos: &Parser.Position, funcTypeInfo:&Ast.TypeInfo, expList:&Nodes.ExpListNode!,
   genericTypeList: &List<&Ast.TypeInfo>, genericsClass:&Ast.TypeInfo! ) mut :
Ast.MatchType, Map<&Ast.TypeInfo,&Ast.TypeInfo>, &Nodes.ExpListNode!
{
   let mut argTypeList = funcTypeInfo.$argTypeInfoList;
   if funcTypeInfo.$kind == .Ext {
      let extTypeList, mess = Ast.convToExtTypeList( self.processInfo, argTypeList );
      when! extTypeList {
         argTypeList = extTypeList;
      } else {
         self.addErrMess( pos, "not support argType on Luaval -- %s" (mess));
      }
   }

   let mut validImplicitCast = true;
   switch funcTypeInfo {
      case self.builtinFunc.list_insert,
           self.builtinFunc.set_add, self.builtinFunc.set_del {
         //argTypeList = genericTypeList;
      }
      case self.builtinFunc.list_sort {
         let alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
         let callback = self.processInfo.createFuncAsync(
            // false, false, nil, Ast.TypeInfoKind.Func,
            false, false, nil, .FormFunc,
            self.processInfo.$dummyParentType,
            self.processInfo.$dummyParentType,
            false, false, true, .Pri, "sort", .Async, nil,
            [ genericTypeList[ 1 ], genericTypeList[ 1 ] ],
            [ Ast.builtinTypeBool ], .IMut );
         argTypeList = [ callback.$nilableTypeInfo ];

         // implicitCast すると、 go の変換が出来ないので implicitCast を抑制
         validImplicitCast = false;
      }
      case self.builtinFunc.list_remove {
      }
      case self.builtinFunc.lns___run {
         self.helperInfo.useRun = true;
      }
   }

   let mut warnForFollow = true;

   when! expList {
      if expList.$followOn {
         warnForFollow = false;
      }
   }

   let mut alt2typeMap;
   when! genericsClass {
      if funcTypeInfo.$rawTxt == "__init" {
         alt2typeMap = genericsClass.createAlt2typeMap( true );
      } else {
         if #funcTypeInfo.$itemTypeInfoList == 0 {
            alt2typeMap = genericsClass.createAlt2typeMap( false );
         }
         else {
            if! let genFuncType = funcTypeInfo@@@Ast.GenericTypeInfo {
               alt2typeMap = genFuncType.createAlt2typeMap( false );
            } else {
               alt2typeMap = genericsClass.createAlt2typeMap( true );
               foreach itemType in genericsClass.$itemTypeInfoList {
                  // 下手に型推論が働かないように、ダミーの型をセットする
                  if itemType.$kind == .Alternate and not alt2typeMap[ itemType ] {
                     alt2typeMap[ itemType ] = Ast.builtinTypeNone;
                  }
               }
            }
         }
      }
   } else {
      if! let genFuncType = funcTypeInfo@@@Ast.GenericTypeInfo {
         alt2typeMap = genFuncType.createAlt2typeMap( false );
      } else {
         alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap(
            #funcTypeInfo.$itemTypeInfoList > 0 );
      }
   }
   let matchResult, _, newExpNodeList = self.checkMatchType(
      funcTypeInfo.getTxt(##), pos,
      argTypeList, expList, false, warnForFollow, alt2typeMap, validImplicitCast );
   // if funcTypeInfo.$kind == .Macro and matchResult ~= .Match {
   //    self.error( "unmatch macro arguments" );
   // }
   
   if expList and newExpNodeList {
      return matchResult, alt2typeMap, newExpNodeList;
   }
   return matchResult, alt2typeMap, expList;
}

fn TransUnit.analyzeListItems(
   firstPos:&Parser.Position, nextToken:&Parser.Token, termTxt:str,
   expectTypeList:List<&Ast.TypeInfo>! ) mut : &Nodes.ExpListNode!, &Ast.TypeInfo
{
   let mut expList:&Nodes.ExpListNode! = nil;
   let mut itemCommonType = Ast.CommonType.Normal( Ast.builtinTypeNone );
   
   if nextToken.txt ~= termTxt {
      self.pushback();
      expList = self.analyzeExpList(
         false, false, false, false, nil, expectTypeList, expectTypeList ~= nil );
      self.checkNextToken( termTxt );
      let nodeList: &List<&Nodes.Node> = (unwrap expList).$expList;
      foreach exp in nodeList {
         itemCommonType = Ast.TypeInfo.getCommonTypeCombo(
            self.processInfo, itemCommonType, Ast.CommonType.Normal( exp.$expType ),
            Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
      }
   }

   let mut itemTypeInfo;
   match itemCommonType {
      case .Normal( info ) {
         itemTypeInfo = info;
      }
      case .Combine( info ) {
         itemTypeInfo = info.get_typeInfo( self.processInfo );
      }
   }

   if itemTypeInfo.$kind == .DDD {
      if #itemTypeInfo.$itemTypeInfoList > 0 {
         itemTypeInfo = itemTypeInfo.$itemTypeInfoList[ 1 ];
      }
      else {
         itemTypeInfo = Ast.builtinTypeStem_;
      }
   }

   if not expectTypeList {
      // expList の itemTypeInfo への暗黙キャストを解決する
      let mut expTypeList:List<&Ast.TypeInfo> = [];
      when! expList {
         foreach expNode, index in expList.$expList {
            if index == #expList.$expList {
               if expNode.$expType.$kind == .DDD {
                  expTypeList.insert( expNode.$expType );
               }
               else {
                  for _ = 1, #expNode.$expTypeList {
                     expTypeList.insert( itemTypeInfo );
                  }
               }
            }
            else {
               expTypeList.insert( itemTypeInfo );
            }
         }
      }
      let _, _, mut workExpList = self.checkMatchType(
         "List constructor", firstPos, expTypeList, expList, false, false, nil, true );
      when! workExpList {
         expList = workExpList;
      }
   }
   return expList, itemTypeInfo;
}


fn TransUnit.analyzeListConst(
   token: &Parser.Token, expectType:&Ast.TypeInfo! ) mut : Nodes.Node
{
   let nextToken = self.getToken(##);

   let mut expectTypeList:List<&Ast.TypeInfo>! = nil;
   if expectType$.$kind == .List {
      if! let itemTypeInfoList = expectType$.$itemTypeInfoList {
         expectTypeList = [ itemTypeInfoList[ 1 ] ];
      }
   }

   let mut expList, itemTypeInfo = self.analyzeListItems(
      token.$pos, nextToken, "]", expectTypeList );
   
   
   let mut typeInfoList = [ Ast.builtinTypeNone ];
   if token.txt == '[' {
      typeInfoList = [ self.processInfo.createList( .Local, self.getCurrentClass(),
                                                      [ itemTypeInfo ], .Mut ) ];
      return Nodes.LiteralListNode.create(
         self.nodeManager, token.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), typeInfoList, expList );
   }
   else {
      typeInfoList = [ self.processInfo.createArray( .Local, self.getCurrentClass(),
                                                       [ itemTypeInfo ], .Mut ) ];
      return Nodes.LiteralArrayNode.create(
         self.nodeManager, token.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), typeInfoList, expList );
   }
}

fn TransUnit.analyzeSetConst(
   token: &Parser.Token, expectType:&Ast.TypeInfo! ) mut : Nodes.Node {

   self.helperInfo.useSet = true;

   
   let nextToken = self.getToken(##);

   let mut expectTypeList:List<&Ast.TypeInfo>! = nil;
   if expectType$.$kind == .Set {
      if! let itemTypeInfoList = expectType$.$itemTypeInfoList {
         expectTypeList = [ itemTypeInfoList[ 1 ] ];
      }
   }

   let mut expList, itemTypeInfo = self.analyzeListItems(
      token.$pos, nextToken, ")", expectTypeList );

   if itemTypeInfo.$nilable {
      when! expList {
         foreach exp in expList.$expList {
            let expType = exp.$expType;
            if expType.$nilable {
               self.addErrMess(
                  exp.$pos,
                  "'Set' object can't store nilable. -- %s" (expType.getTxt(##)));
            }
         }
      }
   }
   
   
   let mut typeInfoList = [ Ast.builtinTypeNone ];
   typeInfoList = [ self.processInfo.createSet( .Local, self.getCurrentClass(),
                                                  [ itemTypeInfo ], .Mut ) ];
   return Nodes.LiteralSetNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), typeInfoList, expList );
}

fn TransUnit.analyzeMapConst(
   token: &Parser.Token, expectType:&Ast.TypeInfo! ) mut : Nodes.LiteralMapNode
{
   let mut nextToken = self.getToken(##);
   let mut map:Map<&Nodes.Node,&Nodes.Node> = {};
   let mut pairList:Nodes.PairItem[] = [];
   let mut keyTypeInfo = Ast.builtinTypeNone;
   let mut valTypeInfo = Ast.builtinTypeNone;


   fn getMapKeyValType(
      pos: &Parser.Position, keyFlag: bool,
      mut typeInfo:&Ast.TypeInfo, mut expType:&Ast.TypeInfo ): &Ast.TypeInfo
   {
      if expType.$nilable {
         if keyFlag {
            self.addErrMess(
               pos, "map key can't set a nilable -- %s" (expType.getTxt(##)) );
         }
         if expType.equals( self.processInfo, Ast.builtinTypeNil ## ) {
            return typeInfo;
         }
         expType = expType.$nonnilableType;
      }
      return Ast.TypeInfo.getCommonType(
         self.processInfo, typeInfo, expType,
         Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
   }

   let mut expectKeyType:&Ast.TypeInfo! = nil;
   let mut expectValType:&Ast.TypeInfo! = nil;
   if expectType$.$kind == .Map {
      if! let itemTypeInfoList = expectType$.$itemTypeInfoList {
         expectKeyType = itemTypeInfoList[ 1 ];
         expectValType = itemTypeInfoList[ 2 ];
      }
   }
   
   while true {
      if nextToken.txt == "}" {
         break;
      }
      self.pushback();

      let key = self.analyzeExpOneRVal( false, false, false, nil, expectKeyType );
      keyTypeInfo = getMapKeyValType( key.$pos, true, keyTypeInfo, key.$expType );

      self.checkNextToken( ":" );

      let val = self.analyzeExpOneRVal( false, false, false, nil, expectValType);
      valTypeInfo = getMapKeyValType( val.$pos, false, valTypeInfo, val.$expType );

      //pairList.insert( { "key": key, "val": val } );
      pairList.insert( new Nodes.PairItem( key, val ) );
      map[ key ] = val;
      nextToken = self.getToken(##);
      if nextToken.txt ~= "," {
         break;
      }
      nextToken = self.getToken(##);
   }

   let typeInfo = self.processInfo.createMap(
      .Local, self.getCurrentClass(), keyTypeInfo, valTypeInfo, .Mut );

   self.checkToken( nextToken, "}" );
   // return self.createNode( nodeKindLiteralMap, token.pos,[ typeInfo ],
   //                      { "map": map, "pairList": pairList } );
   return Nodes.LiteralMapNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], map, pairList );
}



/**
マクロ展開処理。

この関数は、所定のマクロの macro-statment を評価し、
macro-expand を展開したトークンを getToken() で取れるようにセットする。

getToken() で取得したトークンを実際に処理するのは evalMacroCallback で与える。

@param firstToken マクロ展開開始トークン。メッセージ表示用
@param macroTypeInfo マクロの型
@param expList マクロの引数
@param evalMacroCallback マクロ展開したコードを処理するコールバック関数。
*/
fn TransUnit.evalMacroOp(
   firstToken: &Parser.Token, macroTypeInfo: &Ast.TypeInfo,
   expList: &Nodes.ExpListNode!, evalMacroCallback:Macro.EvalMacroCallback ) mut
{
   let mut parser, mess = self.macroCtrl.evalMacroOp(
      self.moduleType, self.parser.getStreamName(),
      firstToken, macroTypeInfo, expList );

   let mut bakParser = self.parser;

   when! parser {
      self.setParser( new Parser.DefaultPushbackParser( parser ) );
   }
   else {
      self.error( unwrap mess );
   }
   
   self.macroCtrl.startExpandMode(
      firstToken.pos, macroTypeInfo, evalMacroCallback );

   // evalMacroCallback();

   // self.macroCtrl.finishMacroMode();

   let nextToken = self.getTokenNoErr(##);

   self.setParser( bakParser );
   
   if nextToken ~= Parser.getEofToken() {
      self.addErrMess( firstToken.pos,
                       "remain macro expand-statement token -- '%s'(%d:%d)"
                       (nextToken.txt, nextToken.pos.lineNo, nextToken.pos.column) );
      if not macroTypeInfo.$externalFlag {
         self.addErrMess( nextToken.pos,
                          "remain macro expand-statement token -- '%s'" (nextToken.txt) );
      }
   }
}


fn TransUnit.evalMacro(
   firstToken: &Parser.Token, macroRefNode: Nodes.Node,
   expList: &Nodes.ExpListNode! ) mut : Nodes.ExpMacroExpNode
{
   let macroTypeInfo = macroRefNode.$expType.$nonnilableType;
   let mut stmtList:List<&Nodes.Node> = [];
   
   self.evalMacroOp( firstToken, macroTypeInfo, expList,
                     fn () __trans {
                        if #macroTypeInfo.$retTypeInfoList == 0 {
                           self.analyzeStatementList( stmtList, true, "}" );
                        }
                        else {
                           stmtList.insert(
                              self.analyzeExp( false, false, false, false ## ) );
                        }
                     } );

   // return self.createNode(
   //     nodeKindExpMacroExp, firstToken.pos, builtinTypeNone, stmtList );

   let mut expTypeList = macroTypeInfo.$retTypeInfoList;
   if #macroTypeInfo.$retTypeInfoList > 0 {
      // マクロに戻り値が指定されている場合
      let macroRetTypeList = macroTypeInfo.$retTypeInfoList;
      if #stmtList == 1 {
         let node = stmtList[ 1 ];
         let retType = macroRetTypeList[ 1 ];
         if retType.equals( self.processInfo, Ast.builtinTypeMultiExp ## ) {
            expTypeList = node.$expTypeList;
         }
         elseif retType.equals( self.processInfo, Ast.builtinTypeExp ## ) {
            if #node.$expTypeList == 1 {
               expTypeList = node.$expTypeList;
            }
            else {
               self.addErrMess( firstToken.pos,
                                "__exp can't return multiple values. use __exps." );
            }
         }
         elseif #node.$expTypeList == 1 {
            if retType.equals( self.processInfo, node.$expType ## ) {
               expTypeList = node.$expTypeList;
            }
            else {
               self.addErrMess(
                  firstToken.pos,   
                  "mismatch type -- %s != %s"
                  (macroRetTypeList[ 1 ].getTxt(##), node.$expType.getTxt(##)) );
            }
         }
         else {
            self.addErrMess( firstToken.pos,
                             "macro can't return multiple values." );
         }
      }
      else {
         self.addErrMess( firstToken.pos, "macro to return value must be one statemnt." );
      }
   }
   else {
      expTypeList = [ Ast.builtinTypeNone ];
   }
   
   return Nodes.ExpMacroExpNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), expTypeList,
      macroRefNode, macroTypeInfo, expList, stmtList );
}

/**
format の書式から %? を検索して、リストを返す。
*/
pub fn findForm( format:str ) __async : List<str> {
   let mut remain = format.replace( "%%", "" );
   //let mut remain = format.gsub( "%%%%", "" );
   let mut opList:List<str> = [];

   while true {
      let mut pos:int!, mut endPos:int! = nil, nil;
      if! let index, endIndex = remain.find( "^%%%-?[%d%.]*%a" ## ) {
         pos, endPos = index, endIndex;
      }  
      else {
         if! let index, endIndex = remain.find( "[^%%]%%%-?[%d%.]*%a" ## ) {
            pos, endPos = index + 1, endIndex;
         }      
      }  

      when! pos, endPos {
         let op = remain.sub( pos, endPos );
         opList.insert( op );
         remain = remain.sub( endPos + 1 ## );
      }
      else {
         break;
      }
   }
   return opList;
}

pub enum FormType {
   Match,
   NeedConv,
   Unmatch,
}
pub fn isMatchStringFormatType(
   opKind:str, mut argType:&Ast.TypeInfo, luaVer:&LuaVer.LuaVerInfo ) __async :
   FormType, &Ast.TypeInfo
{
   if! let enumType = argType.$srcTypeInfo.$aliasSrc@@@Ast.EnumTypeInfo {
      argType = enumType.$valTypeInfo;
   }
   switch opKind[ #opKind ] {
      case ?s {
         if argType.$srcTypeInfo ~= Ast.builtinTypeString {
            if not luaVer.$canFormStem2Str {
               return .NeedConv, Ast.builtinTypeString;
            }
         }
      }
      case ?q {
         if argType.$srcTypeInfo ~= Ast.builtinTypeString {
            // 文字列以外に %q を使うのは不具合の可能性があるので unmatch にする。
            return .Unmatch, Ast.builtinTypeString;
         }
      }
      case ?A, ?a, ?E, ?e, ?f, ?G, ?g {
         if argType.$srcTypeInfo ~= Ast.builtinTypeReal {
            return .Unmatch, Ast.builtinTypeReal;
         }
      }
      default {
         if argType.$srcTypeInfo ~= Ast.builtinTypeInt and
            argType.$srcTypeInfo ~= Ast.builtinTypeChar
         {
            return .Unmatch, Ast.builtinTypeInt;
         }
      }
   }
   return .Match, Ast.builtinTypeNone;
}


fn TransUnit.checkStringFormat(
   pos:&Parser.Position, formatTxt:str, argTypeList:&List<&Ast.TypeInfo> ) mut
{
   let opList = findForm( formatTxt );
   //let mut dstTypeList:List<&Ast.TypeInfo> = [];

   if #opList ~= #argTypeList {
      self.addErrMess( pos,
                       "argument number is mismatch -- %d != %d (%s)"
                       ( #opList, #argTypeList, formatTxt.sub( 1, 20 ) ) );
      return;
   }
   
   foreach op, index in opList {
      let argType = argTypeList[ index ];
      let match, reqType = isMatchStringFormatType( op, argType, self.targetLuaVer );
      if match == .Unmatch {
         let mut mess = "type must be %s -- %s"
             ( reqType.getTxt(##), argType.getTxt(##) );
         self.addErrMess( pos, "argument(%d) %s" (index, mess ) );
      }
   }
}

/**
関数呼び出し Node の前処理。

引数の型チェックを行なう。

"(" を読み済みの状態。次のトークンは引数のトークンになっている状態にする。
この関数を抜けると、 ")" を読み込み済みの状態。


@param position 関数の定義位置
@param funcTypeInfo 関数の型情報
@param genericTypeList Genericsの実型パラメータ
@param genericsClass funcTypeInfo が属するクラス Generics クラス。
         funcTypeInfo がメソッドでなければ headTypeInfo.
*/
fn TransUnit.prepareExpCall(
   position:&Parser.Position, funcTypeInfo:&Ast.TypeInfo,
   genericTypeList:&List<&Ast.TypeInfo>, genericsClass:&Ast.TypeInfo ) mut :
   Map<&Ast.TypeInfo,&Ast.TypeInfo>, &Nodes.ExpListNode!
{

   if funcTypeInfo.$kind == .Macro {
      if self.macroCtrl.isUsing__var( funcTypeInfo ) and
         funcTypeInfo.$parentInfo ~= self.$curNsInfo.$typeInfo
      {
         self.error(
            "The macro (%s) only can use at the same scope declared it, because it's access __ver."
            (funcTypeInfo.getTxt( ## ) ) );
      }
      self.macroCtrl.startAnalyzeArgMode( funcTypeInfo );
   }

   let work = self.getToken(##);
   let mut argList: &Nodes.ExpListNode! = nil;
   if work.txt ~= ")" {
      self.pushback();
      argList = self.analyzeExpList(
         false, false, false, false, nil, funcTypeInfo.$argTypeInfoList ## );
      self.checkNextToken( ")" );

      when! argList {
         foreach argNode in argList.$expList {
            if not argNode.canBeRight( self.processInfo) and
               argNode.$kind ~= Nodes.NodeKind.$Abbr
            {
               self.addErrMess( argNode.$effectivePos, "this node can't be r-value. -- %s"
                                (Nodes.getNodeKindName( argNode.$kind )));
            }
         }
      }
   }

   // 引数の型チェック
   let matchResult, mut alt2typeMap, workArgList = self.checkMatchValType(
      position, funcTypeInfo, argList, genericTypeList, genericsClass );

   if funcTypeInfo.$kind == .Macro and matchResult == .Error {
      // マクロの場合、引数が一致していない時はエラーで止める。
      self.error( "unmatch macro arguments. -- %s" (funcTypeInfo.getTxt(##) ) );
   }


   if funcTypeInfo.$kind == .Macro {
      self.macroCtrl.finishMacroMode();
   }
   

   return alt2typeMap, workArgList;
}

// string.format() の引数チェック
fn TransUnit.checkArgForStringForm(
   firstToken:&Parser.Token, argList:&Nodes.ExpListNode ) mut {
   let mut formArgTypeList:List<&Ast.TypeInfo> = [];
   let mut formatTxt = "";
   if #argList.$expList > 0 {
      let argNode = argList.$expList[ 1 ];
      if argNode.$kind ~= Nodes.NodeKind.$LiteralString {
         // literal 文字列でない場合は無視
         return;
      }
      if! let literal = argNode.getLiteral() {
         match literal {
            case .Str( val ) {
               formatTxt = val;
            }
         }
      }
   }
   if #argList.$expList > 1 {
      if! let toDDDNode = argList.$expList[ 2 ]@@@Nodes.ExpToDDDNode {
         foreach workNode in toDDDNode.$expList.$expList {
            formArgTypeList.insert( workNode.$expType );
         }
      } else {
         self.error( "illegal node -- %s"
                     (Nodes.getNodeKindName( argList.$expList[ 2 ].$kind) ));
      }
   }
   // foreach argType, index in argList.$expTypeList {
   //    if index ~= 1 {
   //       formArgTypeList.insert( argType );
   //    }
   // }
   self.checkStringFormat( firstToken.pos, formatTxt, formArgTypeList );
}

// List.sort() の引数チェック 
fn TransUnit.checkArgForSort(
   firstToken:&Parser.Token,
   genericTypeList:&List<&Ast.TypeInfo>, argList:&Nodes.ExpListNode ) mut
{  
   if #argList.$expTypeList > 0 {
      let callback = argList.$expTypeList[ 1 ];
      if callback == Ast.builtinTypeAbbr {
         return;
      }
      if #callback.$retTypeInfoList ~= 1 {
         self.addErrMess(
            firstToken.$pos,
            "The callback's to return value of sort() must have a value. -- %d"
            (#callback.$retTypeInfoList) );
         return;
      }
      if not Ast.builtinTypeBool.equals(
         self.processInfo, callback.$retTypeInfoList[ 1 ] ##) {
         self.addErrMess(
            firstToken.$pos,
            "The callback's return type of sort() must be bool. -- '%s'"
            ( callback.$retTypeInfoList[ 1 ].getTxt(##) ) );
      }
      if #callback.$argTypeInfoList ~= 2 {
         self.addErrMess(
            firstToken.$pos,
            "The callback's argument must have 2 arguments. -- '%s'"
            (callback.$display_stirng) );
      }
      if #genericTypeList == 1 {
         foreach argType, index in callback.$argTypeInfoList {
            if not genericTypeList[ 1 ].equals(
               self.processInfo, argType ##)
            { 
               self.addErrMess(
                  firstToken.$pos,
                  "The callback's argument(%d) type must be -- '%s'"
                  ( index, genericTypeList[ 1 ].getTxt(##)) );
            }
         }
      }
      else {
         self.addErrMess(
            firstToken.$pos, "The generics of the list is illegal" );
      }
   }
}



fn TransUnit.processFunc(
   firstToken:&Parser.Token, nextToken:&Parser.Token,
   refFieldNode:&Nodes.RefFieldNode!, funcExp: Nodes.Node,
   funcType:&Ast.TypeInfo, alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo>,
   genericTypeList:&List<&Ast.TypeInfo>, genericsClass:&Ast.TypeInfo,
   argList:&Nodes.ExpListNode! ) mut : Nodes.Node
{
   let funcSymbol:&Ast.SymbolInfo!;
   let symbolInfoList = funcExp.getSymbolInfo();
   if #symbolInfoList > 0 {
      let symbol = symbolInfoList[ 1 ];
      if symbol.$kind == .Typ {
         self.addErrMess( funcExp.$pos, "can't call any Type. -- %s" (symbol.$name) );
      }
      funcSymbol = symbol;
   }
   else {
      funcSymbol = nil;
   }

   let mut funcTypeInfo = funcExp.$expType.$srcTypeInfo;
   let nilAccess;

   if nextToken.txt == "$(" {
      if funcTypeInfo.$nilable {
         funcTypeInfo = funcTypeInfo.$nonnilableType;
         nilAccess = true;
      }
      else {
         self.addWarnMess( funcExp.$pos,
                           "This is not nilable. -- %s" (funcTypeInfo.getTxt(##) ) );
         nilAccess = false;
      }
   }
   else {
      nilAccess = false;
   }

   
   switch( funcTypeInfo.$kind ) {
      case .Method, .Func, .Form, .FormFunc {
      }
      default {
         if! let extType = funcTypeInfo@@@Ast.ExtTypeInfo {
            switch( extType.$extedType.$kind ) {
               case .Method, .Func, .Form, .FormFunc {
               }
               default {
                  self.error( "can't call the type -- %s, %s"
                              ( funcTypeInfo.getTxt(##),
                                funcTypeInfo.$kind.$_txt ) );
               }
            }
         }
         else {
            self.error( "can't call the type -- %s, %s"
                        ( funcTypeInfo.getTxt(##),
                          funcTypeInfo.$kind.$_txt ) );
         }
      }
   }

   let prefixMutMode:Ast.MutMode;
   when! refFieldNode {
      prefixMutMode = refFieldNode.$prefix.$expType.$mutMode;
   } else {
      prefixMutMode = .Mut;
   }
   
   let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
   foreach retType in funcTypeInfo.$retTypeInfoList {
      let mut workType = retType;

      if! let applyType = retType.applyGeneric(
         self.processInfo, alt2typeMap, self.moduleType ) {
            workType = applyType;
      }
      else {
         if funcTypeInfo == self.builtinFunc.list_remove {
            // pending: List.remove の戻り値設定を暫定対応
            workType = genericTypeList[ 1 ].$nilableTypeInfo;
         }
         elseif funcTypeInfo.$kind == .Func and
             ( funcTypeInfo.$rawTxt == "_fromMap" or
               funcTypeInfo.$rawTxt == "_fromStem" ) and
            genericsClass.isInheritFrom( self.processInfo,
                                         Ast.builtinTypeMapping, alt2typeMap )    
         {
            workType = genericsClass.$nilableTypeInfo;
         }
         else {
            self.addErrMess(
               firstToken.pos,
               "not support generics yet. -- %s" (retType.getTxt(##)) );
         }
      }

      if retType.$mutMode == .Depend {
         // depend の場合、 prefix の MutMode に依存する。
         if prefixMutMode == .Mut {
            retTypeInfoList.insert( workType.$srcTypeInfo );
         } else {
            retTypeInfoList.insert(
               self.createModifier( workType.$srcTypeInfo, .IMut ) );
         }
      } else {
         retTypeInfoList.insert( workType );
      }
   }
   
   when! refFieldNode {
      if funcTypeInfo.equals( self.processInfo, self.builtinFunc.list_unpack ##) or
         funcTypeInfo.equals( self.processInfo, self.builtinFunc.array_unpack ##)
      {
         // unpack の型を list の要素の DDD 型にする
         let prefixType = refFieldNode.$prefix.$expType;
         if #prefixType.$itemTypeInfoList > 0 {
            let dddType = self.processInfo.createDDD(
               prefixType.$itemTypeInfoList[ 1 ], false, false );
            retTypeInfoList = [];
            retTypeInfoList.insert( dddType );
         }
      }
   }
   
   
   if nilAccess {
      let mut retList:List<&Ast.TypeInfo> = [];
      foreach retType in retTypeInfoList {
         if retType.$nilable {
            retList.insert( retType );
         }
         else {
            retList.insert( retType.$nilableTypeInfo );
         }
      }
      retTypeInfoList = retList;
      self.helperInfo.useNilAccess = true;
   }

   let mut errorFuncFlag = false;
   if #retTypeInfoList > 0 {
      let retType = retTypeInfoList[1];
      if retType == Ast.builtinTypeNeverRet {
         errorFuncFlag = true;
      }
   }

   when! argList {
      switch funcTypeInfo {
         case self.builtinFunc.string_format {
            self.checkArgForStringForm( firstToken, argList );
         }
         case self.builtinFunc.list_sort, self.builtinFunc.array_sort {
            self.checkArgForSort( firstToken, genericTypeList, argList );
         }
      }
   }

   if funcTypeInfo.equals( self.processInfo, self.builtinFunc.lns__kind ##) {
      if! let expList = argList$.$expList {
         if #expList > 0 {
            return Nodes.LuneKindNode.create(
               self.nodeManager, firstToken.pos, self.inTestBlock,
               self.macroCtrl.isInAnalyzeArgMode(),
               [ Ast.builtinTypeInt ], expList[ 1 ] );
         }
      }
      return Nodes.LuneKindNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeInt ],
         self.createNoneNode( firstToken.pos ) );               
   }

   when! funcSymbol {
      if funcSymbol.$name == "super" {
         return Nodes.ExpCallSuperNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), retTypeInfoList,
            funcSymbol.$typeInfo.$parentInfo, funcSymbol.$typeInfo, argList );
      }
   }
   if funcType.$kind == .Ext {
      let mut work, err = Ast.convToExtTypeList( self.processInfo, retTypeInfoList );
      when! work {
         retTypeInfoList = work;
      } else {
         self.addErrMess( firstToken.pos, err );
      }
   }

   return Nodes.ExpCallNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      retTypeInfoList, funcExp, errorFuncFlag, nilAccess, argList );
}

/**
現在の名前空間から funcTypeInfo をコールする上での nosync 系チェック。
*/
fn TransUnit.checkNoasyncType( pos:&Parser.Position, funcTypeInfo:&Ast.TypeInfo ) mut {
   if self.macroCtrl.$analyzeInfo.isAnalyzingBlockArg() {
      return;
   }
   
   let isExt = funcTypeInfo.$kind == .Ext or
      self.builtinFunc.isLuavalFunc( funcTypeInfo );
   if isExt {
      let curType = self.getCurrentNamespaceTypeInfo();
      if not self.getNSInfo( curType ).canAccessLuaval()
      {
         // async の関数から、 luaval 関数は実行できない。
         self.addErrMess(
            pos,        
            "can't access Luaval function without __luago. -- %s on %s"
            (funcTypeInfo.getTxt(##), curType.getTxt(##)));
      }
   }
   
   if funcTypeInfo.$asyncMode == .Noasync {
      let curType = self.getCurrentNamespaceTypeInfo();
      switch curType.$kind {
         case .Func, .Method {
            switch curType.$asyncMode {
               case .Async, .Transient {
                  if not self.getNSInfo( curType ).canAccessNoasync() {
                     // async の関数から、 noasync 関数は実行できない。
                     self.addErrMess(
                        pos,        
                        "can't access noasync function in async. -- %s on %s"
                        (funcTypeInfo.getTxt(##), curType.getTxt(##)));
                  }
               }
            }
         }
      }
   }
}

fn TransUnit.processCreatePipe(
   firstToken:&Types.Token, funcExp: &Nodes.Node, argList:&Nodes.ExpListNode! )
mut : Nodes.ExpCallNode
{
   let mut itemTypeList:&List<&Ast.TypeInfo> = [];
   when! argList {
      if #argList.$expList > 0 {
         let argNode = argList.$expList[ 1 ];
         let mut findFlag = false;
         argNode.visit(
            fn ( node:&Nodes.Node, parent:&Nodes.Node,
                 relation:str, depth:int ): Nodes.NodeVisitMode
            {
               if not parent@@@Nodes.ExpMacroArgExpNode {
                  return .Child;
               }
               if! let refTypeNode = node@@@Nodes.RefTypeNode {
                  let refType = refTypeNode.$name.$expType;
                  itemTypeList = [ refType ];
                  findFlag = true;
                  if not Ast.isBuiltin( refType.$typeId.id ) and
                     not refType.isInheritFrom(
                        self.processInfo, Ast.builtinTypeAsyncItem, nil )
                  {
                     self.addErrMess(
                        refTypeNode.$pos,
                        "The pipe's type has to inherit __AsyncItem. -- %s"
                        (refType.getTxt(##)) );
                  }
               }
               return .Child;
            }, 0, (@) );
         if not findFlag {
            self.addErrMess( firstToken.pos, "It has to set the type for the pipe." );
         }
      }
   }
   let genPipeType = self.createGeneric(
      firstToken.pos, self.builtinFunc.__pipe_, itemTypeList );
   
   return Nodes.ExpCallNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ genPipeType.$nilableTypeInfo ], funcExp, false, false, argList );
}

/**
関数コール処理。

関数コールの "(" を読み込み済みの状態。

@param firstToken 関数コールの最初のトークン
@param exp 関数

*/
fn TransUnit.analyzeExpCall(
   firstToken:&Parser.Token, funcExp: Nodes.Node, nextToken:&Parser.Token ) mut :
   Nodes.Node, &Parser.Token
{
   self.checkSymbolHavingValue( funcExp.$pos, funcExp.getSymbolInfo() );


   let funcTypeInfo = funcExp.$expType.$nonnilableType;   
   self.checkNoasyncType( funcExp.$effectivePos, funcTypeInfo );
   if funcTypeInfo == Ast.builtinTypeLnsLoad {
      self.macroCtrl.setToUseLnsLoad();
   }
   
   // 引数の型チェック
   let mut genericTypeList = funcTypeInfo.$itemTypeInfoList;
   let mut refFieldNode:&Nodes.RefFieldNode! = nil;
   let mut genericsClass = Ast.headTypeInfo;
   if! let refField = funcExp@@@Nodes.RefFieldNode {
      refFieldNode = refField;
      let classType = refField.$prefix.$expType;
      genericsClass = classType;

      if funcTypeInfo.$kind == .Method {
         genericTypeList = classType.$itemTypeInfoList;
      }
   }

   // let mut alt2typeMap, workArgList = self.checkMatchValType(
   //    exp.$pos, funcTypeInfo, argList, genericTypeList, genericsClass );
   // argList = workArgList;


   let mut alt2typeMap, argList = self.prepareExpCall(
      funcExp.$pos, funcTypeInfo, genericTypeList, genericsClass );

   if funcTypeInfo.equals( self.processInfo, self.builtinFunc.list_insert ##) {
      when! argList {
         if argList.$expType.$nilable {
            self.addErrMess( argList.$pos, "list can't insert nilable" );
         }
      }
   }
   if funcTypeInfo.equals( self.processInfo, self.builtinFunc.set_add ##) {
      when! argList {
         if argList.$expType.$nilable {
            self.addErrMess( argList.$pos, "set can't add nilable" );
         }
      }
   }
   elseif funcTypeInfo.equals( self.processInfo, self.builtinFunc.list_remove ##) {
      if #genericTypeList > 0 {
         if genericTypeList[ 1 ].$nilable {
            self.addWarnMess( funcExp.$pos, "remove() is dangerous for nilable's list." );
         }
      }
   }

   if funcTypeInfo.$rawTxt == "" {
      self.addErrMess( funcExp.$pos, "can't directly call the declared function." );
   }

   let mut exp:Nodes.Node;
   if funcTypeInfo.get_kind() == .Macro {
      if funcTypeInfo == self.builtinFunc.__lns_sync__createPipe {
         exp = self.processCreatePipe( firstToken, funcExp, argList );
      } else {
         exp = self.evalMacro( firstToken, funcExp, argList );
      }
   }
   else {
      // processFunc
      exp = self.processFunc(
         firstToken, nextToken, refFieldNode, funcExp, funcTypeInfo,
         alt2typeMap, genericTypeList, genericsClass, argList );
   }

   return exp, self.getTokenNoErr(##);
}

fn TransUnit.analyzeExpCast(
   firstToken:&Parser.Token, opTxt:str, exp:Nodes.Node ) mut : Nodes.Node
{
   let castTypeNode = self.analyzeRefType( .Local, false, false, false, false );
   let mut castType = castTypeNode.$expType;

   if exp.$expType.$kind == .Ext and castType.$kind ~= .Ext and castType.$kind ~= .Stem {
      if opTxt == "@@" or opTxt == "@@=" {
         // 外部言語型のデータは、強制的に immutable にする。
         castType = self.createModifier( castType, .IMut );
      }
      castType = self.createExtType( castTypeNode.$pos, castType );
   }

   if castType.$kind == .Form and
      exp.$expType.$nonnilableType.$kind == .Stem
   {
      if self.supportLang( .C ) {
         // Stem から form へのキャストは、
         // C のトランスコンパイルではサポートしない
         self.addWarnMess(
            castTypeNode.$pos,
            "not support cast from stem to form for transcompiling to c-lang." );
      }
   }

   let expType = exp.$expType;

   if opTxt == "@@@" or opTxt == "@@=" {
      if #castType.$itemTypeInfoList > 0 {
         self.addErrMess( castTypeNode.$pos,
                          "not support cast for generics class yet -- %s"
                          (castType.getTxt(##)));
      }
      switch castType.$kind {
         case .IF, .Class, .Prim {
         }
         default {
            if opTxt ~= "@@=" {
               self.addErrMess( castTypeNode.$pos,
                                "not support cast -- %s" (castType.getTxt(##)));
            }
         }
      }

      if opTxt == "@@=" {
         let orgExpType = expType.$extedType;
         let orgCastType = castType.$extedType;
         if orgCastType.$kind ~= .IF and orgCastType.$kind ~= .Class {
            self.addErrMess( castTypeNode.$pos,
                             "'@@=' cast must be class or interface. -- %s"
                             (castType.getTxt(##)) );
         }
         if orgExpType.$srcTypeInfo ~= Ast.builtinTypeStem and
            orgExpType.$kind ~= .IF and orgExpType.$kind ~= .Class
         {           
            self.addErrMess( castTypeNode.$pos,
                             "'@@=' cast must be class or interface. -- %s"
                             (castType.getTxt(##)) );
         }  
         if not Ast.isStruct( orgCastType ) {
            self.addErrMess( castTypeNode.$pos,
                             "'@@=' cast type can't use class has method -- %s"
                             (castType.getTxt(##)));
         }
      }
   }
   else {
      if castType ~= Ast.builtinTypeString and
          ( castType.$kind == .IF or castType.$kind == .Class )
      {           
         self.addWarnMess( castTypeNode.$pos,
                           "use '@@@' cast for class or interface. -- %s"
                           (castType.getTxt(##)) );
      }
   }
   
   
   if opTxt ~= "@@@" and expType.$nilable and not castType.$nilable {
      self.addErrMess( firstToken.pos,
                       "can't cast from nilable to not nilable  -- %s->%s"
                       (expType.getTxt(##), castType.getTxt(##)) );
   }
   if not Ast.TypeInfo.isMut( expType ) and Ast.TypeInfo.isMut( castType ) {
      castType = self.createModifier( castType, .IMut );
   }

   if castType.canEvalWith(
      self.processInfo, expType, .SetOp, {} ) {
      if castType.$kind ~= .Ext and
         not ( castType.$kind == .Stem and  Ast.isExtType( expType ) )
      {
         // "str"@@str のように、意味のないキャストはエラー
         self.addWarnMess( castTypeNode.$pos,
                           "This cast isn't need. (%s <- %s)"
                           ( castType.getTxt( self.typeNameCtrl ## ),
                             expType.getTxt( self.typeNameCtrl ## ) ) );
      }
   }
   elseif not expType.canEvalWith(
      self.processInfo, castType, .SetOp, {} ) {
      if not Ast.isNumberType( expType ) or not Ast.isNumberType( castType ) {
         // キャスト先の型からキャスト元の型へ互換性がない場合はエラー
         self.addErrMess( castTypeNode.$pos,
                          "This type can't cast. (%s <- %s)"
                          ( castType.getTxt( self.typeNameCtrl ## ),
                            expType.getTxt( self.typeNameCtrl ## ) ) );            
      }
   }

   // if expType.$kind == .Ext and castType.$kind ~= .Ext and castType.$kind ~= .Stem
   // {
   //    castType = self.createExtType( castTypeNode.$pos, castType );
   // }
   
   if opTxt == "@@@" {
      castType = castType.$nilableTypeInfo;
   }

   return Nodes.ExpCastNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ castType ],
      self.nodeManager.MultiTo1( exp ), castType, castTypeNode, opTxt,
      opTxt ~= "@@@" and Nodes.CastKind.Force or Nodes.CastKind.Normal);
}

fn TransUnit.canReturnFromHere( pos:&Types.Position ) mut : bool {
   let mut available = true;
      
   let funcTypeInfo = self.getCurrentNamespaceTypeInfo();
   if not Ast.TypeInfo.hasParent( funcTypeInfo ) or
      ( funcTypeInfo.$kind ~= .Func and funcTypeInfo.$kind ~= .Method )
   {
      self.addErrMess( pos, "'return' could not use here" );
      available = false;
   }
   let nsInfo = self.getNSInfo( funcTypeInfo );
   if nsInfo.isLockedAsync() {
      self.addErrMess( pos, "can't use 'return' in the __asyncLock." );
      available = false;
   }

   if funcTypeInfo.getTxt(##) == "__init" {
      // フロー解析するのが面倒なので、 __init 内では return を禁止。
      self.addErrMess( pos, "__init method can't return" );
      available = false;
   }

   return available;
}

fn TransUnit.getRetErrTypeInfo(
   pos:&Types.Position, mess:str, target:&Ast.TypeInfo ) mut :
&Ast.TypeInfo!, &Ast.TypeInfo!
{
   let! algeType = target.$srcTypeInfo.$genSrcTypeInfo@@@Ast.AlgeTypeInfo {
      self.addErrMess(
         pos, "%s '%s' is not __Ret." ( mess, target.getTxt(##) ) );
      return nil, nil;
   };
   if algeType ~= self.builtinFunc.__ret_ {
      self.addErrMess(
         pos, "%s '%s' is not __Ret." ( mess, target.getTxt(##) ) );
      return nil, nil;
   }
   if #target.$itemTypeInfoList ~= 2 {
      self.addErrMess(
         pos, "%s '%s' is illegal type." ( mess, target.getTxt(##) ) );
      return nil, nil;
   }
   return target.$itemTypeInfoList[ 1 ], target.$itemTypeInfoList[ 2 ];
}

fn TransUnit.analyzeCondRet(
   firstToken: &Parser.Token, mut exp: Nodes.Node ) mut : Nodes.Node
{
   let mess = "can't use '!' here. --";
   self.canReturnFromHere( firstToken.pos );

   let mut nsInfo = self.$curNsInfo;
   let typeInfo = nsInfo.$typeInfo;
   switch typeInfo.$kind {
      case .Func, .Method {
      }
      default {
         self.addErrMess(
            firstToken.pos, "%s '%s' is not func" (mess, typeInfo.$rawTxt) );
         return exp;
      }
   }
   // 関数の戻り値取得
   let retTypeList = typeInfo.$retTypeInfoList;
   if #retTypeList ~= 1 {
      self.addErrMess(
         firstToken.pos, "%s '%s' has multi return values" (mess, typeInfo.$rawTxt) );
      return exp;
   }
   let retType = retTypeList[1];
   let expType = exp.$expType;
   
   if expType.$nilable {
      if retType.$nilable {
         // 評価結果が nilable で、関数の戻り値が nilable の場合
         // CondRetNode を生成する
         return nsInfo.addCondRet(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), expType.$nonnilableType, exp );
      } else {
         self.addErrMess(
            firstToken.pos, "%s '%s' is not nilable." ( mess, expType.getTxt(##) ) );
         return exp;
      }
   } else {
      // nilable でない場合は __Ret かどうか確認する
      let! expOkType, expErrType =
         self.getRetErrTypeInfo( firstToken.pos, mess, expType )
      {
         return exp;
      };
      let! _, retErrType = self.getRetErrTypeInfo( firstToken.pos, mess, retType ) {
         return exp;
      };

      if retErrType.canEvalWith( self.processInfo, expErrType, .SetOp, {} ) {
         return nsInfo.addCondRet(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), expOkType, exp );
      }
   }
   
   return exp;
}

fn TransUnit.analyzeExpCont(
   firstToken: &Parser.Token, mut exp: Nodes.Node,
   skipFlag: bool, canLeftExp:bool, canCondRet:bool ) mut : Nodes.Node
{
   let mut nextToken = self.getToken( true );
   if nextToken.kind == .Eof {
      return exp;
   }

   if not skipFlag {
      repeat {
         let mut matchFlag = false;
         if nextToken.txt == "[" or nextToken.txt == "$[" {
            matchFlag = true;
            exp = self.analyzeExpRefItem( nextToken, exp, nextToken.txt == "$[" );
            nextToken = self.getToken(##);
         }
         if nextToken.txt == "(" or nextToken.txt == "$(" {
            matchFlag = true;

            exp, nextToken = self.analyzeExpCall( firstToken, exp, nextToken );
         }
      } not matchFlag;

      switch nextToken.txt {
         case "@@", "@@@", "@@=" {
            exp = self.analyzeExpCast( firstToken, nextToken.txt, exp );
            nextToken = self.getToken( ## );
         }
      }

      if nextToken.txt == "!" {
         if not canCondRet {
            self.addErrMess( nextToken.pos, "can't use '!' here." );
         }
         exp = self.analyzeCondRet( nextToken, exp );
         nextToken = self.getToken(##);
      }
   }

   switch nextToken.txt {
      case "." {
         return self.analyzeExpSymbol( firstToken, self.getToken(##), .Field,
                                       exp, skipFlag, canLeftExp, canCondRet );   
      }
      case "$." {
         return self.analyzeExpSymbol( firstToken, self.getToken(##), .FieldNil,
                                       exp, skipFlag, canLeftExp, canCondRet );
      }
      case ".$" {
         return self.analyzeExpSymbol( firstToken, self.getToken(##), .Get,
                                       exp, skipFlag, canLeftExp, canCondRet );
      }
      case "$.$" {
         return self.analyzeExpSymbol( firstToken, self.getToken(##), .GetNil,
                                       exp, skipFlag, canLeftExp, canCondRet );
      }
   }

   self.pushback();
   return exp;

}


fn TransUnit.analyzeAccessClassField(
   mut classTypeInfo: &Ast.TypeInfo, mode:ExpSymbolMode, token:&Parser.Token ) mut :
   &Ast.TypeInfo, &Ast.SymbolInfo!, bool
{
   switch classTypeInfo.get_kind() {
      case .List {
         classTypeInfo = Ast.builtinTypeList;
      }
      case .Array {
         classTypeInfo = Ast.builtinTypeArray;
      }
      case .Set {
         classTypeInfo = Ast.builtinTypeSet;
      }
      case .Map {
         classTypeInfo = Ast.builtinTypeMap;
      }
      case .Box {
         classTypeInfo = Ast.builtinTypeBox;
      }
   }
   let className = classTypeInfo.getTxt(##);
   let! classScope = classTypeInfo.$scope {
      self.error( "not found field: %s, %s"
                  ( className, classTypeInfo ) );
   };
   
   let mut symbolInfo:&Ast.SymbolInfo! = nil;
   let mut fieldTypeInfo:&Ast.TypeInfo! = nil;
   let mut getterFlag = false;
   if mode == .Get or mode == .GetNil {
      let fieldSymbolInfo = classScope.getSymbolInfo(
         "get_%s" (token.txt), self.$scope, false, self.scopeAccess );
      when! fieldSymbolInfo {
         if ( fieldSymbolInfo.get_kind() == .Mtd or fieldSymbolInfo.get_kind() == .Fun )
         {
            let retTypeList = fieldSymbolInfo.$typeInfo.get_retTypeInfoList();
            symbolInfo = fieldSymbolInfo;
            if #retTypeList > 0 {
               if! let applyedType = retTypeList[ 1 ].applyGeneric(
                  self.processInfo,
                  classTypeInfo.createAlt2typeMap(false), self.moduleType )
               {                 
                  fieldTypeInfo = applyedType;
               }
               else {
                  fieldTypeInfo = retTypeList[ 1 ];
               }
            }
            if #fieldSymbolInfo.$typeInfo.$argTypeInfoList > 0 {
               self.addErrMess(
                  token.pos,        
                  "can't use '$' with -- %s" ( fieldSymbolInfo.$typeInfo.getTxt(##) ) );
            }
            
            getterFlag = true;
         }
      }
   }
   if not symbolInfo {
      // fieldSymbolInfo = classScope.getTypeInfo(
      //     token.txt, self.scope, false );
      // fieldTypeInfo = classScope.getTypeInfoField(
      //    token.txt, true, self.scope );
      symbolInfo = classScope.getSymbolInfoField(
         token.txt, true, self.$scope, self.scopeAccess );
      if not symbolInfo {
         symbolInfo = classScope.getSymbolInfoIfField(
            token.txt, self.$scope, self.scopeAccess );
      }
      when! symbolInfo {
         fieldTypeInfo = symbolInfo.$typeInfo;
      }
   }
   if not fieldTypeInfo {
      foreach val, name in classScope.$symbol2SymbolInfoMap {
         Util.errorLog( "debug: %s, %s" ( name, val ) );
      }
      Util.errorLog( "class, scope: -- %s, %s" (classTypeInfo, classScope));
      self.error( "not found field typeInfo: %s.%s -- %s"
                  ( classTypeInfo.getFullName( self.typeNameCtrl, self.$scope, false ),
                    token.txt, classTypeInfo.$kind.$_txt ) );
   }
   let typeInfo = unwrap fieldTypeInfo default Ast.builtinTypeNone;

   when! symbolInfo {
      if self.inAnalyzingState( .InitBlock ) or self.inAnalyzingState( .ClassMethod ) 
      {     
         let mut errorMess:str! = nil;
         if self.nsInfoMap[ symbolInfo.$typeInfo ]$.$nobody {

            // __init ブロックの制御
            errorMess = "It can't call prototype function from static -- %s" (symbolInfo.$name);
         }
         when! errorMess {
            self.addErrMess( token.pos, errorMess );
         }
      }
      elseif self.inAnalyzingState( .Constructor ) {
         let mut errorMess:str! = nil;
         if self.nsInfoMap[ symbolInfo.$typeInfo ]$.$nobody {
            errorMess = "It can't call prototype function from '__init'";
         }
         else {
            if symbolInfo.$typeInfo.$kind == .Method and symbolInfo.$scope == classScope
            {           
               foreach val in classScope.$symbol2SymbolInfoMap {
                  if val.$kind == .Mbr and not val.$staticFlag {
                     if not val.$hasValueFlag and not val.$typeInfo.$nilable {
                        errorMess = "Set member(%s) before to access the method-- %s"
                        ( val.$name, symbolInfo.$name );
                        break;
                     }
                  }
               }
            }
         }
         when! errorMess {
            self.addErrMess( token.pos, errorMess );
         }
      }
   }
   
   return typeInfo, symbolInfo, getterFlag;
}

fn TransUnit.dumpComp(
   writer: Writer.Writer, pattern: str,
   symbolInfo: &Ast.SymbolInfo, getterFlag:bool ): bool
{
   let symbol = symbolInfo.$name;
   if pattern == "" or symbol.find( pattern ## ) {
      if getterFlag {
         writer.startParent( "candidate", false );
         let typeInfo = symbolInfo.$typeInfo;
         writer.write( "type", "%s" ( symbolInfo.$kind.$_txt ) );
         switch ( symbolInfo.$kind ) {
            case .Mtd, .Fun, .Mac {
               writer.write( "displayTxt", "$%s"
                             ( (typeInfo.$rawTxt.gsub( "^get_", "")) ) );
            }  
            case .Mbr {
               writer.write( "displayTxt", "$%s: %s"
                             ( symbolInfo.$name, typeInfo.getTxt(##) ) );
            }
         }
      }
      else {
         writer.startParent( "candidate", false );
         let typeInfo = symbolInfo.$typeInfo;
         writer.write( "type", "%s" ( symbolInfo.$kind.$_txt ) );
         switch ( symbolInfo.$kind ) {
            case .Fun, .Mtd, .Mac {
               writer.write(
                  "displayTxt",
                  typeInfo.get_display_stirng_with(symbolInfo.$name, nil) );
            }  
            case .Mbr, .Var, .Arg {
               let mut name = symbolInfo.$name;
               if! let algeTypeInfo = typeInfo@@@Ast.AlgeTypeInfo {
                  if! let valInfo = algeTypeInfo.getValInfo( name ) {
                     if #valInfo.$typeList > 0 {
                        name = "%s(" (name);
                        foreach itemType, index in valInfo.$typeList {
                           if index > 1 {
                              name = name .. ",";
                           }
                           name = name .. itemType.$display_stirng;
                        }
                        name = name .. ")";
                     }
                  }
               }
               writer.write( "displayTxt", "%s: %s"
                             ( name, typeInfo.$display_stirng ) );
            }  
            case .Typ {
               writer.write( "displayTxt",
                             "%s" ( (typeInfo.$display_stirng.gsub( "@", "" ) )) );
            }  
         }
      }
      writer.endElement();
   }
   return true;
}

fn TransUnit.dumpFieldComp(
   writer: Writer.Writer, isPrefixType: bool,
   prefixTypeInfo: &Ast.TypeInfo, pattern: str, getterPattern: str! )
{
   let typeInfo;
   switch prefixTypeInfo.get_kind() {
      case .List {
         typeInfo = Ast.builtinTypeList;
      }
      case .Array {
         typeInfo = Ast.builtinTypeArray;
      }
      case .Set {
         typeInfo = Ast.builtinTypeSet;
      }
      case .Map {
         typeInfo = Ast.builtinTypeMap;
      }
      case .Box {
         typeInfo = Ast.builtinTypeBox;
      }
      default {
         typeInfo = prefixTypeInfo;
      }
   }
   let! scope = typeInfo.$scope {
      return;
   };

   scope.filterTypeInfoField(
      true, self.$scopeRO, self.scopeAccess,
      fn ( symbolInfo: &Ast.SymbolInfo ) __trans : bool {
         if ( isPrefixType ) {
            if not symbolInfo.$staticFlag and
               not symbolInfo.$typeInfo.$staticFlag and
               symbolInfo.$kind ~= .Typ
            {
               // 型のフィールド補完は 非 static を除外
               return true;
            }
         }
         elseif symbolInfo.$staticFlag {
            // インスタンスのフィールド補完は static を除外
            return true;
         }
         let symbol = symbolInfo.$name;
         if symbol ~= "__init" and symbol ~= "__free" and
            symbol ~= "self"
         {
            when! getterPattern {
               if symbolInfo.$kind == .Mtd or symbolInfo.$kind == .Fun {
                  let retList = symbolInfo.$typeInfo.$retTypeInfoList;
                  if #retList == 1 {
                     return self.dumpComp( writer, getterPattern, symbolInfo, true );
                  }
               }
               return true;
            }
            return self.dumpComp(writer, pattern, symbolInfo, false );
         }
         return true;
      });
}

fn TransUnit.dumpSymbolComp( writer: Writer.Writer, scope: &Ast.Scope, pattern: str ) {
   scope.filterSymbolTypeInfo(
      scope, self.moduleScope, self.scopeAccess,
      fn ( symbolInfo: &Ast.SymbolInfo ) __trans : bool {
         return self.dumpComp(writer, pattern, symbolInfo, false );
      });    
}

form checkCompForm( jsonWriter: Writer.JSON, prefix:str  );

fn TransUnit.checkComp( token:&Parser.Token, callback:checkCompForm ) 
{
   if self.analyzeMode == .Complete and self.isTargetToken ( token ) {
      let mut currentModule = self.parser.getStreamName().gsub( "%.lns", "" );
      currentModule = currentModule.gsub( ".*/", "" );
      let target = self.analyzeModule.gsub( "[^%.]+%.", "" );
      if currentModule == target {
         let mut jsonWriter = new Writer.JSON( io.stdout );
         jsonWriter.startParent( "lunescript", false );
         let prefix = token.txt.gsub( "lune$", "" );
         jsonWriter.write( "prefix", prefix );
         jsonWriter.startParent( "candidateList", true );

         callback( jsonWriter, prefix );

         jsonWriter.endElement();
         jsonWriter.endElement();
         jsonWriter.fin();
         os.exit( 0 );
      }
   }
}


fn TransUnit.checkFieldComp(
   getterFlag:bool, token:&Parser.Token, prefixExp: &Nodes.Node ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   let prefixSymbolInfoList = prefixExp.getSymbolInfo();
   let mut prefixSymbolInfo:&Ast.SymbolInfo! = nil;
   if #prefixSymbolInfoList == 1 {
      prefixSymbolInfo = prefixSymbolInfoList[ 1 ];
   }
   
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         let mut getterPattern:str! = nil;
         if getterFlag {
            getterPattern = "^get_" .. prefix;
         }
         let mut isPrefixType = false;
         if! prefixSymbolInfo {
            isPrefixType = _exp.$kind == .Typ;
         }     
         self.dumpFieldComp(
            jsonWriter, isPrefixType, prefixExp.$expType,
            prefix == "" and "" or "^" .. prefix, getterPattern );
      }
   );
}

fn TransUnit.checkEnumComp(
   token:&Parser.Token, enumTypeInfo: &Ast.EnumTypeInfo ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         let! scope = enumTypeInfo.$scope {
            return;
         };

         let pattern = prefix == "" and "" or "^" .. prefix;
         scope.filterTypeInfoField(
            true, self.$scopeRO, self.scopeAccess,
            fn ( symbolInfo: &Ast.SymbolInfo ) __trans : bool {
               if symbolInfo.$kind == .Mbr {
                  return self.dumpComp( jsonWriter, pattern, symbolInfo, false );
               }
               return true;
            } );
      }
   );
}

fn TransUnit.checkAlgeComp(
   token:&Parser.Token, algeTypeInfo: &Ast.AlgeTypeInfo ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         self.dumpFieldComp(
            jsonWriter, true, algeTypeInfo,
            prefix == "" and "" or "^" .. prefix, nil );
      }
   );
}

fn TransUnit.checkAsyncSymbol( symbolInfo:&Ast.SymbolInfo, pos:&Types.Position ) mut {
   if not self.supportLang( .Go ) or not self.supportLang( .C ) {
      return;
   }
   
   // 現在の名前空間が async で、
   // mutable な大域変数かクロージャ変数にアクセスしている場合エラー。
   let curNs = self.getCurrentNamespaceTypeInfo();
   switch curNs.$kind {
      case .Func, .Method {
      }
      default {
         return;
      }
   }
   
   let nsInfo = self.getNSInfo( curNs );
   let mut warn = false;
   if not nsInfo.canAccessNoasync() and symbolInfo.$name ~= "self" {
      switch symbolInfo.$kind {
         case .Mbr {
            if not Ast.isPrimitive( symbolInfo.$typeInfo ) {
               warn = true;
            }
         }
         case .Arg, .Var {
            if not symbolInfo.$scope.isInnerOf( unwrap curNs.$scope ) {
               warn = true;
            }
         }
      }
   }
   if warn {
      switch curNs.$kind {
         case .Func {
            if not nsInfo.canAccessNoasync() and
               curNs.$asyncMode ~= .Transient
            {
               if not self.canBeAsyncParam( symbolInfo.$typeInfo ) {
                  self.addErrMess(
                     pos,               
                     "can't access the mutable type's symbol(%s) from async (%s)."
                     (symbolInfo.$name, nsInfo.$typeInfo.getTxt(##) ) );
               }
            }
         }
         case .Method {
            if not nsInfo.canAccessNoasync() or
               ( symbolInfo.$staticFlag and symbolInfo.$kind == .Mbr )
            {
               if not self.canBeAsyncParam( symbolInfo.$typeInfo ) {
                  self.addErrMess(
                     pos,               
                     "can't access the mutable type's symbol(%s) from async (%s)."
                     (symbolInfo.$name, nsInfo.$typeInfo.getTxt(##) ) );
               }
            }
         }
      }
   }
}


fn TransUnit.checkAsyncField( symbolInfo:&Ast.SymbolInfo, pos:&Types.Position ) mut {
   // 現在の名前空間が async で、
   // mutable な大域変数かクロージャ変数にアクセスしている場合エラー。
   let curNs = self.getCurrentNamespaceTypeInfo();
   let mut warn = false;
   if curNs.$asyncMode == .Async {
      if not Ast.isPrimitive( symbolInfo.$typeInfo ) {
         warn = true;
      }
   }
   if warn {
      if ( ( symbolInfo.$staticFlag and symbolInfo.$kind == .Mbr ) or
           symbolInfo.$kind == .Var ) and
         not self.builtinFunc.$allSymbolSet.has( symbolInfo.getOrg() ) and
         not self.canBeAsyncParam( symbolInfo.$typeInfo )
      {
         // 以下の builtin ではないシンボルにアクセスし、
         // - static メンバ
         // - 外部モジュールの大域変数
         // さらに、そのシンボルの型が次の場合、エラーとする。
         // - async のパラメータとして渡せない型。 (canBeAsyncParam) 
         self.addErrMess(
            pos,               
            "can't access the mutable symbol(%s) from async (%s)."
            (symbolInfo.$name, curNs.getTxt(##) ) );
      }
   }
}


fn TransUnit.checkSymbolComp( token:&Parser.Token ) 
{
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         self.dumpSymbolComp( jsonWriter, self.$scopeRO,
                              prefix == "" and "" or "^" .. prefix );
      }
   );
}

fn TransUnit.analyzeExpField(
   firstToken: &Parser.Token, fieldToken: &Parser.Token,
   mode: ExpSymbolMode, mut prefixExp: &Nodes.Node ) mut : Nodes.Node
{
   if #prefixExp.$expTypeList > 1 {
      prefixExp = Nodes.ExpMultiTo1Node.create(
         self.nodeManager, prefixExp.$pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(),
         [ prefixExp.$expType ], prefixExp );
   }

   let mut accessNil = false;
   if mode == .FieldNil or mode == .GetNil {
      accessNil = true;
      if not prefixExp.$expType.$nilable {
         self.addWarnMess(
            prefixExp.$pos,
            "This is not nilable. -- %s" (prefixExp.$expType.getTxt(##)) ); 
      }
   }
   if self.macroCtrl.$analyzeInfo.isAnalyzingSymArg() {
      if accessNil {
         self.helperInfo.useNilAccess = true;
      }

      // self.checkFieldComp(
      //    mode == .Get or mode == .GetNil, token, prefixExp );

      
      return Nodes.RefFieldNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeSymbol ],
         fieldToken, nil, accessNil, prefixExp );
         //token, accessNil, unwrap prefixExp );
   }

   let mut typeInfo:&Ast.TypeInfo = Ast.builtinTypeStem_;
   let mut prefixExpType = prefixExp.$expType;
   if accessNil {
      if prefixExpType.$nilable {
         // nil 条件演算で、 prefixExpType が nilable ならば、
         // prefixExpType を非 nilable にセットする
         prefixExpType = prefixExpType.$nonnilableType;

         if prefixExpType.$srcTypeInfo.$kind == .Box {
            self.addErrMess( prefixExp.$pos, "Nilable can't support '$.' access yet" );
         }
      }
      else {
         // prefixExpType が nilable でなければ、
         // nil 判定は不要なので accessNil をクリアする
         accessNil = false;
      }
   }

   let extFlag;
   if Ast.isExtType( prefixExpType ) {
      if not self.macroCtrl.$analyzeInfo.isAnalyzingBlockArg() and
         not self.$curNsInfo.canAccessLuaval()
      {
         self.addErrMess(
            firstToken.$pos,
            "can't access Luaval without __luago. -- %s"
            (prefixExp.$expType.getTxt(##)) );
      }
      
      extFlag = true;
      prefixExpType = prefixExpType.$extedType;
   } else {
      extFlag = false;
   }

   self.checkFieldComp(
      mode == .Get or mode == .GetNil, fieldToken, prefixExp );

   if accessNil {
      self.helperInfo.useNilAccess = true;
      switch prefixExpType.get_kind() {
         case .Set, .Enum, .Alge, .Box {
         // 現状は set, enum, alge の accessNil はサポートしていない。
            self.addErrMess( firstToken.pos,
                             "%s does not support $." (prefixExpType.getTxt( nil ##) ) );
         }
      }
   }

   let prefixSymbolInfoList = prefixExp.getSymbolInfo();
   self.checkSymbolHavingValue( prefixExp.$pos, prefixSymbolInfoList );

   let mut getterTypeInfo:&Ast.TypeInfo! = nil;
   let mut symbolInfo:&Ast.SymbolInfo! = nil;
   switch prefixExpType.$kind {
      case .Class, .Module, .ExtModule, .IF, .List, .Array, .Set, .Box, .Alternate {
         let mut getterFlag = false;
         typeInfo, symbolInfo, getterFlag =
            self.analyzeAccessClassField( prefixExpType, mode, fieldToken );
         if getterFlag {
            if! symbolInfo {
               getterTypeInfo = _exp.$typeInfo;

               self.checkNoasyncType( fieldToken.pos, _exp.$typeInfo );
            }
         }
      }
      case .Enum, .Alge {
         let scope = unwrap prefixExpType.$scope;
         let mut fieldName = fieldToken.txt;
         let symbolInfoList = prefixExp.getSymbolInfo();
         let mut isTypeSymbol = false;
         if #symbolInfoList > 0 {
            if symbolInfoList[1].$kind == .Typ {
               isTypeSymbol = true;
            }  
         }
         if mode == .Get {
            let moduleType = prefixExpType.getModule();
            if not moduleType.equals( self.processInfo, self.moduleType ##) and
               not self.$scope.getModuleInfo( moduleType )
            {
               if not self.importedAliasMap[ prefixExpType ] {
                  // enum の名前を取得するには、そのモジュールのインポートが必要
                  self.addErrMess( fieldToken.pos, "need to import module -- %s"
                                   ( prefixExpType.getModule().getTxt(##) ) );
               }
            }
            fieldName = "get_" .. fieldName;
            if! let funcSymbol = scope.getSymbolInfoChild( fieldName ) {
               symbolInfo = funcSymbol;
               let funcType = funcSymbol.$typeInfo;
               if funcType.$staticFlag ~= isTypeSymbol {
                  self.addErrMess(
                     prefixExp.$pos,
                     "Can't access -- %s, %s" ( fieldName, isTypeSymbol) );
               }
               
               
               let retTypeList = funcType.$retTypeInfoList;
               if #retTypeList == 0 {
                  self.addErrMess(
                     fieldToken.$pos,
                     "The func (%s) doesn't return value." (funcType.getTxt(##)) );
               }
               else {
                  typeInfo = retTypeList[ 1 ];
               }
            }
            else {
               self.addErrMess( fieldToken.$pos, "not found -- %s." ( fieldName ) );
               typeInfo = Ast.builtinTypeNone;
            }

            getterTypeInfo = Ast.headTypeInfo;
         }
         else {
            if! scope.getTypeInfoChild( fieldName ) {
               typeInfo = _exp;
               if typeInfo.$kind == .Enum or typeInfo.$kind == .Alge {
                  if not isTypeSymbol {
                     self.addErrMess( fieldToken.pos,
                                      "can't access field -- %s" (fieldToken.txt));
                  }
               }
            }
            else {
               self.addErrMess( fieldToken.pos,
                                "not found field -- %s" (fieldToken.txt));
               typeInfo = Ast.builtinTypeInt;
            }
         }
      }
      case .Map {
         let work = prefixExpType.$itemTypeInfoList[1];
         if not work.equals( self.processInfo, Ast.builtinTypeString ##) {
            self.addErrMess(
               fieldToken.pos,
               "map key type is not str. (%s)" (work.getTxt(##)) );
         }
         typeInfo = prefixExpType.$itemTypeInfoList[2];
         if not typeInfo.$nilable {
            typeInfo = typeInfo.$nilableTypeInfo;
         }
         if extFlag {
            typeInfo = self.createExtType( fieldToken.pos, typeInfo );
         }
         return Nodes.ExpRefItemNode.create(
            self.nodeManager, fieldToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(),
            [ typeInfo ], prefixExp, accessNil, fieldToken.txt, nil );
      }
      default {
         if prefixExpType.equals( self.processInfo, Ast.builtinTypeStem ##) {
            typeInfo = Ast.builtinTypeStem_;
            if extFlag {
               typeInfo = self.createExtType( fieldToken.pos, typeInfo );
            }
            return Nodes.ExpRefItemNode.create(
               self.nodeManager, fieldToken.pos, self.inTestBlock,
               self.macroCtrl.isInAnalyzeArgMode(),
               [ typeInfo ], prefixExp, accessNil, fieldToken.txt, nil );
         }
         else {
            self.error( "illegal type -- %s, %s"
                        ( prefixExpType.getTxt(##),
                          prefixExpType.get_kind().$_txt ) );
         }
      }
   }

   if not symbolInfo {
      let prefixScope = prefixExpType.$scope;
      if! prefixScope {
         symbolInfo = _exp.getSymbolInfoField(
            fieldToken.txt, true, self.$scope, self.scopeAccess );
      }
   }
   
   when! symbolInfo {
      if #prefixSymbolInfoList == 1 {
         let prefixSymbolInfo = prefixSymbolInfoList[1];
         if prefixSymbolInfo.$kind == .Typ {
            if prefixSymbolInfo.$typeInfo.$kind ~= .Module and
               not symbolInfo.$staticFlag and symbolInfo.$kind ~= .Typ
            {
               // クラスシンボルから、 static でないメンバにアクセスした場合エラー
               self.addErrMess(
                  fieldToken.pos,
                  "Type can't access this symbol. -- %s" (symbolInfo.$name) );
            }
         }
         elseif symbolInfo.$staticFlag and symbolInfo.$typeInfo.$kind ~= .Method {
            // インスタンスから、 static メンバにアクセスした場合エラー
            self.addErrMess(
               fieldToken.pos, "can't access this symbol. -- %s" (fieldToken.txt) );
         }
      };

      if not Ast.TypeInfo.isMut( prefixExpType ) and not symbolInfo.$staticFlag and
         symbolInfo.$kind == .Mtd and symbolInfo.$mutMode == .Mut
      {  
         // オブジェクトが immutable で、
         // mutable な method へのアクセスはエラー
         self.addErrMess(
            fieldToken.pos,
            "can't access mutable method. -- %s.%s"
            (prefixExpType.getTxt(##), fieldToken.txt) );
      }

      if symbolInfo.$typeInfo.$mutMode == .AllMut {
         let curType = self.getCurrentNamespaceTypeInfo();
         switch curType.$kind {
            case .Func, .Method {
               switch curType.$asyncMode {
                  case .Async, .Transient {
                     if curType.$kind ~= .Method or curType.$rawTxt ~= "__init" {
                        // async から allmut 型を格納するシンボルにはアクセスできない。
                        self.addErrMess(
                           fieldToken.pos,
                           "can't access allmut type's field(%s) in async function."
                           (symbolInfo.$name) );
                     }
                  }
               }
            }
         }
      }
   }

   let mut accessSymbolInfo:Ast.AccessSymbolInfo! = nil;
   //let mut canBeLeft:bool! = nil;
   let mut symbolMutMode = typeInfo.$mutMode;
   when! symbolInfo {
      let mut workSymInfo = new Ast.AccessSymbolInfo(
         self.processInfo, symbolInfo, .Prefix( prefixExpType ), not accessNil );
      if not getterTypeInfo {
         typeInfo = workSymInfo.$typeInfo;
      }
      accessSymbolInfo = workSymInfo;
      switch mode {
         case .Field, .FieldNil {
            symbolMutMode = symbolInfo.$mutMode;
         }
      }
   }

   if accessNil {
      if not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
      self.helperInfo.useNilAccess = true;
   }

   if not Ast.TypeInfo.isMut( prefixExpType ) {
      if self.ctrl_info.legacyMutableControl {
         if symbolMutMode == .Mut {           
            typeInfo = self.createModifier( typeInfo, .IMut );
         }
      } else {
         if typeInfo.$mutMode == .Mut and typeInfo.$mutMode ~= .AllMut {
            typeInfo = self.createModifier( typeInfo, .IMut );
         }
      }
   }

   if typeInfo.equals( self.processInfo, self.builtinFunc.list_unpack ##) or
      typeInfo.equals( self.processInfo, self.builtinFunc.array_unpack ##)
   {
      self.helperInfo.useUnpack = true;
   }
   if typeInfo.equals( self.processInfo, self.builtinFunc.str_replace ## ) {
      self.helperInfo.useStrReplace = true;
   }

   if! let expRef = prefixExp@@@Nodes.ExpRefNode {
      let prefixSym = expRef.$symbolInfo;
      let prefixType = prefixSym.$typeInfo;
      if prefixSym.$kind == .Typ and prefixType.$kind == .Class and
         #prefixType.$itemTypeInfoList > 0 and
         not Ast.isGenericType( prefixType ) and
         not self.$scope.isInnerOf( unwrap prefixType.$scope )
      {
         let mut accessErr = false;
         if typeInfo.$kind == .Func {
            // static method 呼び出しで、
            // 引数から全ての型パラメータを推論できるものに関しては、
            // エラーしないので、引数のチェックを行なう。
            let mut altSet:Set<&Ast.TypeInfo> = (@);
            let mut hasAlt = false;
            foreach argType in typeInfo.$argTypeInfoList {
               let orgType = argType.$nonnilableType.$srcTypeInfo;
               if orgType.$kind == .Alternate {
                  altSet.add( orgType );
                  hasAlt = true;
               }
            }
            // if not hasAlt {
            //    foreach retType in typeInfo.$retTypeInfoList {
            //       let orgType = retType.$nonnilableType.$srcTypeInfo;
            //       if orgType.$kind == .Alternate {
            //          hasAlt = true;
            //       }
            //    }
            // }
            // if hasAlt {
               foreach itemType in prefixType.$itemTypeInfoList {
                  if not altSet.has( itemType.$nonnilableType.$srcTypeInfo ) {
                     accessErr = true;
                     break;
                  }
               }
            // }
         } else {
            accessErr = true;
         }
         if accessErr {
            // 型パラメータを指定しないで generics クラスへのアクセスはエラー。
            self.addErrMess(
               prefixExp.$pos,
               "can't access this class(%s) without '<>'." (prefixType.getTxt(##)) );
         }
      }
   }
   
   
   if extFlag {
      typeInfo = self.createExtType( firstToken.pos, typeInfo );
   }

   

   if! getterTypeInfo {
      return Nodes.GetFieldNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ],
         fieldToken, accessSymbolInfo, accessNil, prefixExp, _exp );
         //token, canBeLeft, accessNil, prefixExp, _exp );
   }
   else {
      when! accessSymbolInfo {
         self.checkAsyncField( accessSymbolInfo, fieldToken.pos );
      }

      if typeInfo.$kind == .Func {
         let nextToken = self.getToken(##);
         if nextToken.txt == "<" {
            let itemNodeList:List<&Nodes.Node> = [];
            let genericList = self.analyzeTypeParamArg( .Pri, false, itemNodeList, nil );

            if #typeInfo.$itemTypeInfoList == #genericList {
               typeInfo = self.createGeneric( nextToken.pos, typeInfo, genericList );
            } else {
               self.addErrMess(
                  nextToken.pos,
                  "generic type count is unmatch. -- %d, %s"
                  (#genericList, typeInfo.getTxt(##) ) );
            }
         } else {
            self.pushback();
         }
      }
      
      return Nodes.RefFieldNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ],
         fieldToken, accessSymbolInfo, accessNil, prefixExp );
   }
}

fn TransUnit.analyzeNewAlge(
   firstToken:&Parser.Token, expectType:&Ast.TypeInfo,
   algeTypeInfo:&Ast.AlgeTypeInfo, prefix:&Nodes.Node! ) mut : Nodes.NewAlgeValNode
{
   if not self.helperInfo.useAlge {
      self.helperInfo.useAlge = true;
   }
   
   let symbolToken = self.getSymbolToken( .MustNot_ );

   self.checkAlgeComp( symbolToken, algeTypeInfo );   

   if! let valInfo = algeTypeInfo.getValInfo( symbolToken.txt ) {
      // alge の引数の Generics 対応
      let argExpectTypeList:List<&Ast.TypeInfo> = [];
      if #valInfo.$typeList > 0 {
         if Ast.isGenericType( expectType ) {
            let mut alt2TypeMap = expectType.createAlt2typeMap( false );
            foreach typeInfo in valInfo.$typeList {
               argExpectTypeList.insert( Ast.applyGenericDefault(
                  self.processInfo, typeInfo, alt2TypeMap, self.moduleType ) );
            }
         } else {
            foreach typeInfo in valInfo.$typeList {
               argExpectTypeList.insert( typeInfo );
            }
         }
      }
      
      let mut argList:&List<&Nodes.Node> = [];
      let argListNode:&Nodes.ExpListNode!;
      if #argExpectTypeList > 0 {
         self.checkNextToken( "(" );
         argListNode = self.analyzeExpList(
            false, false, false, false, nil, argExpectTypeList, nil );
         argList = (unwrap argListNode).$expList;
         self.checkNextToken( ")" );
      }
      else {
         argListNode = nil;
      }


      let genericList:List<&Ast.TypeInfo> = [];
      //let mut alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
      if! let _, alt2typeMap, newExpNodeList = self.checkMatchType(
         "call", symbolToken.pos, argExpectTypeList,
         argListNode, false, true, expectType.createAlt2typeMap( true ), true )
      {
         argList = newExpNodeList.$expList;

         if #algeTypeInfo.$itemTypeInfoList > 0 {
            foreach itemType in algeTypeInfo.$itemTypeInfoList {
               if! let genType = alt2typeMap[ itemType ] {
                  genericList.insert( genType );
               } else {
                  genericList.insert( itemType );
               }
            }
         }
      }

      if algeTypeInfo.$externalFlag and
         not self.$scope.getModuleInfo( algeTypeInfo.getModule().$srcTypeInfo )
      {  
         let fullname = algeTypeInfo.getFullName( self.typeNameCtrl, self.$scope, true );
         self.addErrMess( firstToken.pos, "This module not import -- %s"
                          ( fullname ) );
      }

      let newAlgeTypeInfo:&Ast.TypeInfo;
      if #genericList > 0 {
         newAlgeTypeInfo = self.createGeneric(
            firstToken.pos, algeTypeInfo, genericList );
      } else {
         newAlgeTypeInfo = algeTypeInfo;
      }

      return Nodes.NewAlgeValNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ newAlgeTypeInfo ],
         symbolToken, prefix, .Alge( algeTypeInfo ), valInfo, argList );
   }
   else {
      let dummySymbol =
         algeTypeInfo.$parentInfo.$scope$.getSymbolInfoChild$( algeTypeInfo.$rawTxt );
      self.addErrMess( symbolToken.pos, "not found Alge -- %s" (symbolToken.txt) );
      return Nodes.NewAlgeValNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ algeTypeInfo ],
         symbolToken, prefix, .Alge( algeTypeInfo ),
         new Ast.AlgeValInfo("", [], algeTypeInfo, unwrap dummySymbol ), [] );
   }
}

local fn TransUnit.analyzeExpSymbol(
   firstToken: &Parser.Token, symbolToken: &Parser.Token, mode: ExpSymbolMode,
   prefixExp: &Nodes.Node!, mut skipFlag: bool,
   canLeftExp:bool, canCondRet:bool ) mut : Nodes.Node
{
   let mut exp:Nodes.Node;
   
   if mode == .Field or mode == .Get or
      mode == .FieldNil or mode == .GetNil
   {
      when! prefixExp {
         exp = self.analyzeExpField( firstToken, symbolToken, mode, prefixExp );

         let expType = exp.$expType;
         if prefixExp.$expType.isModule() {
            if! let algeType = expType.$genSrcTypeInfo@@@Ast.AlgeTypeInfo {
               let nextToken = self.getToken(##);
               if nextToken.txt == "." {
                  return self.analyzeNewAlge( firstToken, expType, algeType, exp );
               }  
               self.pushback();
            }
         }
      }
      else {
         Util.err( "prefixExp is nil" );
      }
   }
   elseif mode == .Symbol {
      if self.macroCtrl.$analyzeInfo.isAnalyzingSymArg() {
         exp = Nodes.LiteralSymbolNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeSymbol ], symbolToken );
      }
      else {
         self.checkSymbolComp( symbolToken );

         let! symbolInfo = self.$scope.getSymbolTypeInfo(
            symbolToken.txt, self.$scope, self.moduleScope, self.scopeAccess )
         {
            if self.macroCtrl.$isDeclaringMacro and
               symbolToken.txt == "__var" and self.analyzePhase == .Runner
            {
               self.error( "declare '_lune_control use_macro_special_var'." );
            } else {
               if self.analyzeMode ~= .Diag and Log.getLevel() >= .Debug {
                  let mut work:&Ast.Scope = self.$scope;
                  while true {
                     Util.println( work, self.moduleScope );
                     if work == work.$parent {
                        break;
                     }
                     work = work.$parent;
                  }

                  self.$scope.filterSymbolTypeInfo(
                     self.$scope, self.moduleScope, self.scopeAccess,
                     fn ( workSymbolInfo:&Ast.SymbolInfo ): bool {
                        Util.println( "sym", workSymbolInfo.$name );
                        return true;
                     } );
               }
               self.error( "not found type -- " .. symbolToken.txt );
            }
         };

         if self.macroCtrl.$isDeclaringMacro and symbolToken.txt == "__var" {
            self.macroCtrl.setUsing__var();
         }
         

         self.accessSymbol( symbolInfo, canLeftExp );

         self.checkAsyncSymbol( symbolInfo, firstToken.pos );
         
         let typeInfo = symbolInfo.$typeInfo;
         // if symbolInfo.$kind == .Typ and
         //    typeInfo.$kind == .Alternate and
         //    self.analyzingStaticMethodArgsScope ~= nil and
         //    symbolInfo.$scope ~= self.analyzingStaticMethodArgsScope
         // {
         //    // static メソッド内では、
         //    // そのメソッドで定義した型パラメータ以外を使用できない。
         //    self.addErrMess(
         //       firstToken.pos,    
         //       "The static method can't use the type parameter. -- %s"
         //       (typeInfo.getTxt(##)));
         // }

         switch symbolInfo.$kind {
            case .Typ {  
               if! let algeType = typeInfo.$genSrcTypeInfo@@@Ast.AlgeTypeInfo {
                  let nextToken = self.getToken(##);
                  if nextToken.txt == "." {
                     return self.analyzeNewAlge( firstToken, typeInfo, algeType, nil );
                  }  
                  self.pushback();
               }
            }
            case .Var {
               self.tentativeSymbol.addAccessSym( symbolInfo );
               if not symbolInfo.$hasValueFlag {
                  let nsTypeInfo = self.getCurrentNamespaceTypeInfo();
                  if not symbolInfo.$scope.isInnerOf( unwrap nsTypeInfo.$scope ) {
                     self.tentativeSymbol.addAccessSymPos(
                        new AccessSymPos( symbolInfo, firstToken.pos ) );
                  }
               }
            }           
         }
         
         if typeInfo.equals( self.processInfo, Ast.builtinTypeSymbol ##) {
            skipFlag = true;
         }
         if typeInfo.equals( self.processInfo, self.builtinFunc.lns__load ##) {
            self.helperInfo.useLoad = true;
         }

         switch symbolToken.txt {
            case "__func__" {
               let funcTypeInfo = self.getCurrentNamespaceTypeInfo();
               self.has__func__Symbol.add( funcTypeInfo );
            }
            case "_G", "_ENV" {
               let mut valid = false;
               foreach pragma in self.helperInfo.pragmaSet {
                  match pragma {
                     case .limit_conv_code( codeSet ) {
                        if codeSet.len() == 1 and codeSet.has( LuneControl.Code.Lua ) {
                           valid = true;
                           break;
                        }
                     }
                  }
               }
               if not valid {
                  self.addErrMess(
                     firstToken.pos,
                     "'_G' and '_ENV' only can access with transcompiling to lua." );
               }
            }
            case "_" {
               if not canLeftExp {
                  self.addErrMess( firstToken.pos, "It can't access the symbol '_'." );
               }
            }
         }

         exp = Nodes.ExpRefNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], 
            new Ast.AccessSymbolInfo( self.processInfo, symbolInfo, .None, true ) );

         if typeInfo.$kind == .Func {
            let nextToken = self.getToken(##);
            if nextToken.txt == "<" {
               let itemNodeList:List<&Nodes.Node> = [];
               let genericList = self.analyzeTypeParamArg( .Pri, false, itemNodeList, nil );

               if #typeInfo.$itemTypeInfoList == #genericList {
                  let newTypeInfo = self.createGeneric(
                     firstToken.pos, typeInfo, genericList );
                  
                  exp = Nodes.RefTypeNode.create(
                     self.nodeManager, firstToken.pos, self.inTestBlock,
                     self.macroCtrl.isInAnalyzeArgMode(), [ newTypeInfo ],
                     exp, itemNodeList, {}, typeInfo.$mutMode, "no" );
               } else {
                  self.addErrMess(
                     nextToken.pos,
                     "generic type count is unmatch. -- %d, %s"
                     (#genericList, typeInfo.getTxt(##) ) );
               }
               
            } else {
               self.pushback();
            }
         }
         
      }
   }
   elseif mode == .Fn {
      exp = self.analyzeDeclFunc(
         .Func, false, false, false, .Local, false, nil, symbolToken, nil );
   }
   else {
      self.error( "illegal mode -- %s" ( mode ) );
   }

   if self.analyzeMode == .Inquire and self.isTargetToken ( symbolToken ) {
      let mut accessMode = Ast.AccessMode.None;
      foreach symbolInfo in exp.getSymbolInfo() {
         accessMode = symbolInfo.$accessMode;
      }
      self.dumpSymbolType( accessMode, symbolToken.txt, exp.$expType );
   }
   
   return self.analyzeExpCont( firstToken, exp, skipFlag, canLeftExp, canCondRet );
}

/**
代入演算。

@param exp 左辺
@param opeToken 演算子のトークン
@param expTypeList 右辺に期待される型のリスト。
*      左辺の変数の数だけ要素がある。
*/
fn TransUnit.analyzeExpOpSet(
   exp: Nodes.Node, opeToken: &Parser.Token,
   expectTypeList:&List<&Ast.TypeInfo> ) mut : Nodes.Node
{
   exp.setLValue();

   if not exp.canBeLeft() {
      self.addErrMess( exp.$pos,
                       "this node can not be l-value. -- %s"
                       (Nodes.getNodeKindName( exp.$kind ) ) );
   }

   fn process( lValNode:&Nodes.Node ) : &Nodes.ExpRefItemNode! {
      let! refItemNode = lValNode@@@Nodes.ExpRefItemNode {
         return nil;
      };
      switch refItemNode.$val.$expType.$kind {
         case .List, .Map {
            return refItemNode;
         }
      }
      return nil;
   }
   
   let mut listRefItemNode:&Nodes.ExpRefItemNode! = nil;
   if! let symNodeList = exp@@@Nodes.ExpListNode {
      foreach symNode in symNodeList.$expList {
         if! let refItemNode = process( symNode ) {
            listRefItemNode = refItemNode;
            if #symNodeList.$expList > 1 {
               // golang へ変換する場合、
               // リストの要素に設定するには 1 ずつ処理しなければならない。
               self.addErrMess(
                  refItemNode.$pos,       
                  "When left-value includes 'list[i]', left-value must be single." );
            }
            break;
         }
      }
   } else {
      listRefItemNode = process( exp );
   }
   
   let mut expList = self.analyzeExpList( false, false, false, false, nil, expectTypeList## );
   foreach expType, index in expList.$expTypeList {
      if expType.$asyncMode == .Transient {
         // Transient は変数への代入禁止
         self.addErrMess(
            expList.$pos,
            "can't set the __trans type -- index:%d, %s" (index, expType.getTxt(##)) );
      }
   }

   if not expList.canBeRight( self.processInfo ) {
      self.addErrMess( expList.$effectivePos,
                       "this node can not be r-value. -- %s"
                       (Nodes.getNodeKindName( expList.$kind ) ) );
   }

   let _, _, mut workList, expTypeList =
      self.checkMatchType( "= operator", opeToken.pos, exp.$expTypeList,
                           expList, true, false, nil, true );
   when! workList {
      expList = workList;
   }

   let mut initSymSet:Set<&Ast.SymbolInfo> = (@);
   let mut symbolList:List<&Ast.SymbolInfo> = [];

   
   foreach symbolInfo, index in exp.getSymbolInfo() {
      symbolList.insert( symbolInfo );
      if not symbolInfo.$mutable and symbolInfo.$hasValueFlag
      {
         if self.validMutControl {
            self.addErrMess( opeToken.$pos,
                             "this is not mutable variable. -- %s"
                             ( symbolInfo.$name ) );
         }
      }
      self.tentativeSymbol.modSym( symbolInfo );
      if index <= #expTypeList and not symbolInfo.$hasValueFlag {
         switch symbolInfo.$kind {
            case .Var {
               if symbolInfo.$typeInfo == Ast.builtinTypeEmpty {
                  // 未初期化変数に型が指定されていないので型推論を行なう
                  
                  let mut expType = expTypeList[ index ];
                  switch expType.$kind {
                     case .DDD {
                        if #expType.$itemTypeInfoList > 0 {
                           expType = expType.$itemTypeInfoList[ 1 ].$nilableTypeInfo;
                        }
                     }
                     case .List, .Array, .Set, .Map {
                        let workPos;
                        if index <= #expList.$expList {
                           workPos = expList.$expList[ index ].$pos;
                        }
                        else {
                           workPos = opeToken.$pos;
                        }
                        self.checkLiteralEmptyCollection(
                           workPos, symbolInfo.$name, expType );
                     }
                  }
                  symbolInfo.set_typeInfo( expType );
               }
               if not self.tentativeSymbol.regist( symbolInfo, exp.$pos ) {
                  self.addErrMess( opeToken.pos,
                                   "can't access in this scope. -- %s"
                                   ( symbolInfo.$name ) );
               }
               initSymSet.add( symbolInfo );
            }
            case .Mbr {
               initSymSet.add( symbolInfo );
            }
         }
      }
      //symbolInfo.set_hasValueFlag( true );
      if symbolInfo.$kind ~= .Var or
         self.$scope.getNamespaceTypeInfo() == symbolInfo.$scope.getNamespaceTypeInfo()
      {
         symbolInfo.updateValue( exp.$pos );
      }
   }

   when! listRefItemNode {
      let index:Nodes.IndexVal;
      if! let indexNode = listRefItemNode.$index {
         index = .NodeIdx( indexNode );
      } else {
         index = .SymIdx( unwrap listRefItemNode.$symbol );
      }
      if listRefItemNode.$val.$expType.$kind == .Map {
         if expList.$expType ~= Ast.builtinTypeNil and expList.$expType.$nilable {
            self.addWarnMess(
               expList.$pos,
               "you shouldn't use nilable value to set a map item(%s). use nil or no-nilable"(listRefItemNode.$val.$expType.getTxt(##)) );
         }
      }
      return Nodes.ExpSetItemNode.create(
         self.nodeManager, exp.$pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         listRefItemNode.$val, index, expList );
   }

   return Nodes.ExpSetValNode.create(
      self.nodeManager, exp.$pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], exp, expList, symbolList, initSymSet );
}


fn TransUnit.analyzeExpOpEquals(
   pos:&Parser.Position, opToken:&Parser.Token,
   mut exp1: Nodes.Node, mut exp2: Nodes.Node ) mut : Nodes.Node, Nodes.Node
{
   let exp1Type = exp1.$expType;
   let exp2Type = exp2.$expType;
   
   if ( not exp1Type.canEvalWith(
      self.processInfo, exp2Type, .SetOp, {} ) and
        not exp2Type.canEvalWith(
           self.processInfo, exp1Type, .SetOp, {} ) )
   {
      self.addErrMess(
         opToken.pos,
         "not compatible type '%s' or '%s'"
         ( exp1Type.getTxt(self.typeNameCtrl## ),
           exp2Type.getTxt(self.typeNameCtrl## ) ) );
      return exp1, exp2;
   }
   if! exp1@@@Nodes.NewAlgeValNode {
      if #_exp.$paramList > 0 {
         self.addErrMess( exp1.$pos, "can't compare alge." );
         return exp1, exp2;
      }
   }
   if! exp2@@@Nodes.NewAlgeValNode {
      if #_exp.$paramList > 0 {
         self.addErrMess( exp2.$pos, "can't compare alge." );
         return exp1, exp2;
      }
   }
   if exp1Type.equals( self.processInfo, Ast.builtinTypeBool ##) and
      exp2Type.equals( self.processInfo, Ast.builtinTypeBool ##) and
       ( exp1.$kind == Nodes.NodeKind.$LiteralBool or
         exp2.$kind == Nodes.NodeKind.$LiteralBool )
   {
      self.addWarnMess( exp1.$pos, "this operation is deprecated." );
      return exp1, exp2;
   }

   fn getType( typeInfo:&Ast.TypeInfo ) : &Ast.TypeInfo {
      let workType = typeInfo.$nonnilableType.$srcTypeInfo;
      if workType.$kind == .Alternate and workType.hasBase() {
         return workType.$baseTypeInfo;         
      }
      return workType;
   }
   
   let nonNilType1 = getType( exp1Type );
   let nonNilType2 = getType( exp2Type );
   
   if nonNilType1 ~= nonNilType2 {
      if nonNilType1.$kind == .Class or nonNilType1.$kind == .IF {
         // exp1 が class/if の場合
         if nonNilType2.$kind == .Class or nonNilType2.$kind == .IF {
            if nonNilType1.isInheritFrom( self.processInfo, nonNilType2 ## ) {
               // exp1 が exp2 を派生している場合、exp1 を exp2 に upcast する。
               exp1 = Nodes.ExpCastNode.create(
                  self.nodeManager, exp1.$pos, self.inTestBlock,
                  self.macroCtrl.isInAnalyzeArgMode(), [ exp2Type.$nonnilableType ],
                  exp1, exp2Type, nil, "", .Implicit );   
            } else {
               exp2 = Nodes.ExpCastNode.create(
                  self.nodeManager, exp2.$pos, self.inTestBlock,
                  self.macroCtrl.isInAnalyzeArgMode(), [ exp1Type.$nonnilableType ],
                  exp2, exp1Type, nil, "", .Implicit );   
            }
         } else {
            // exp1 が class/if で exp2 が違う場合、 exp1 を stem に cast する。
            exp1 = Nodes.ExpCastNode.create(
               self.nodeManager, exp1.$pos, self.inTestBlock,
               self.macroCtrl.isInAnalyzeArgMode(), [ exp1Type ],
               exp1, Ast.builtinTypeStem, nil, "", .Implicit );   
         }
      } else {
         if nonNilType2.$kind == .Class or nonNilType2.$kind == .IF {
            // exp2 が class/if で exp1 が違う場合、 exp2 を stem に cast する。
            exp2 = Nodes.ExpCastNode.create(
               self.nodeManager, exp2.$pos, self.inTestBlock,
               self.macroCtrl.isInAnalyzeArgMode(), [ exp2Type ],
               exp2, Ast.builtinTypeStem, nil, "", .Implicit );
         }
      }
   }
      

   return exp1, exp2;
}



fn TransUnit.analyzeExpOp2(
   firstToken: &Parser.Token, mut exp: Nodes.Node, prevOpLevel: int! ) mut : Nodes.Node
{
   while true {
      let opToken = self.getTokenNoErr(##);
      let opTxt = opToken.txt;

      if opToken.txt == "@@" or opToken.txt == "@@@" or opToken.txt ==  "@@=" {
         exp = self.analyzeExpCast( firstToken, opTxt, exp );
      }
      elseif opToken.kind == Parser.TokenKind.Ope {
         if Parser.isOp2( opTxt ) {
            if opTxt ~= "=" and not exp.canBeRight( self.processInfo ) {
               self.addErrMess(
                  exp.$pos, "This can't evaluate for '%s' -- %s"
                  ( opTxt, Nodes.getNodeKindName( exp.$kind ) ) );
            }
            let! opLevel = op2levelMap[ opTxt ] {
               self.error( "unknown op -- %s %s" (opTxt, prevOpLevel ) );
            };
            if! prevOpLevel {
               if opLevel <= _exp {
                  self.pushback();
                  return exp;
               }
            }

            let mut expectTypeList:List<&Ast.TypeInfo> = [];
            foreach exp1Type in exp.$expTypeList {
               let mut prefixExpType = exp1Type;
               if prefixExpType.$nilable {
                  prefixExpType = prefixExpType.$nonnilableType;
               }

               let mut expectType = Ast.builtinTypeNone;
               if! prefixExpType.$srcTypeInfo@@@Ast.GenericTypeInfo {
                  expectType = _exp;
               } else {
                  if! prefixExpType.$srcTypeInfo.$aliasSrc@@@Ast.EnumTypeInfo {
                     expectType = _exp;
                  }
                  if! prefixExpType.$srcTypeInfo@@@Ast.AlgeTypeInfo {
                     expectType = _exp;
                  }
               }
               expectTypeList.insert( expectType );
            }
            if #expectTypeList == 0 {
               self.addErrMess(
                  exp.$pos,
                  "This exp have no value -- %s" (Nodes.getNodeKindName( exp.$kind )) );
               expectTypeList.insert( Ast.builtinTypeNone );
            }
            
            

            if opTxt == "=" {
               return self.analyzeExpOpSet( exp, opToken, expectTypeList );
            }

            exp = self.MultiTo1( exp );
            
            let mut exp2:Nodes.Node = self.analyzeExp(
               false, false, false, false, opLevel, expectTypeList[ 1 ] );
            exp2 = self.MultiTo1( exp2 );
            
            if not exp2.canBeRight( self.processInfo ) {
               self.addErrMess(
                  exp2.$pos, "This can't evaluate for '%s' -- %s"
                  ( opTxt, Nodes.getNodeKindName( exp2.$kind ) ) );
            }
            
            let mut retType = Ast.builtinTypeNone;

            if not exp2.canBeRight( self.processInfo ) {
               self.addErrMess( exp2.$effectivePos,
                                "this node can not be r-value. -- %s"
                                (Nodes.getNodeKindName( exp2.$kind ) ) );
            }
            
            let mut exp1Type = exp.$expType;
            let exp2Type = exp2.$expType;

            if exp1Type.$kind == .DDD {
               if! let dddType = exp1Type@@@Ast.DDDTypeInfo {
                  exp = Nodes.ExpMultiTo1Node.create(
                     self.nodeManager, exp.$pos, self.inTestBlock,
                     self.macroCtrl.isInAnalyzeArgMode(),
                     [ dddType.$typeInfo.$nilableTypeInfo ], exp );
               }
            }
            if exp2Type.$kind == .DDD {
               if! let dddType = exp2Type@@@Ast.DDDTypeInfo {
                  exp2 = Nodes.ExpMultiTo1Node.create(
                     self.nodeManager, exp2.$pos, self.inTestBlock,
                     self.macroCtrl.isInAnalyzeArgMode(),
                     [ dddType.$typeInfo.$nilableTypeInfo ], exp2 );
               }
            }
            
            switch opTxt {
               case "or" {
                  let is3op;
                  if! let opExpType = exp1Type@@@Ast.AndExpTypeInfo {
                     // exp1Type が AndExpTypeInfo なら and or の 3 項演算なので、
                     // 演算処理を変更する。
                     exp1Type = opExpType.$exp2;
                     is3op = true;
                  }
                  else {
                     is3op = false;
                  }

                  if not exp1Type.equals( self.processInfo, Ast.builtinTypeBool ##) and
                     not exp1Type.equals( self.processInfo, Ast.builtinTypeStem ##) and
                     not exp1Type.$nilable
                  {
                     if (exp@@@Nodes.ExpOp2Node)$.$op$.txt == "and" {
                        // 本来はこの判定は不要で warning を出すべき。
                        // 現在 ( flag and 1 or 0 ) という式を書いた場合、
                        // flag and 1 の評価結果を暫定的に int としている。
                        // これは and or を使った 3 項演算子で、
                        // 無理矢理に型情報を保持させているための暫定動作。
                        // 本来 flag and 1 の型は stem 等になるはず。
                        // しかし、 stem にすると全体の演算結果の型も stem になってしまい
                        // 意図した型にならない。
                        // このため、ここで warning を出するは誤認識の可能性が高いので
                        // warning は出さない。
                     }
                     else {
                        self.addWarnMess(
                           exp.$pos,
                           "this value never be 'false' -- %s"
                           (exp1Type.getTxt(##)) );
                     }
                  }
                  
                  if exp1Type.equals( self.processInfo, exp2Type ##) {
                     retType = exp1Type;
                  }
                  elseif exp1Type.canEvalWith(
                     self.processInfo, exp2Type, .SetOp, {}) {
                     // 暗黙キャストの関係にある場合
                     retType = exp1Type;
                  }
                  elseif exp2Type.canEvalWith(
                     self.processInfo, exp1Type, .SetOp, {}) {
                     // 暗黙キャストの関係にある場合
                     retType = exp2Type;
                  }
                  elseif exp2Type.equals( self.processInfo, Ast.builtinTypeNil ##) {
                     // 片方が nil の場合
                     if is3op or exp1Type.equals( self.processInfo,
                                                  Ast.builtinTypeBool ## ) {                        
                        retType = exp1Type.$nilableTypeInfo;
                     }
                     else {
                        retType = exp1Type;
                     }
                  }
                  elseif exp1Type.equals( self.processInfo, Ast.builtinTypeNil ##) {
                     // 片方が nil の場合
                     retType = exp2Type;
                  }
                  else {
                     // 型に互換性がない場合
                     if exp1Type.$nilable and exp2Type.$nilable {
                        // exp1: nilable, exp2: nilable
                        retType = Ast.builtinTypeStem_;
                     }
                     elseif exp2Type.$nilable {
                        // exp1: not nilable, exp2: nilable
                        retType = Ast.builtinTypeStem_;
                     }
                     elseif exp1Type.$nilable {
                        // exp1: nilable, exp2: not nilable
                        retType = Ast.builtinTypeStem;
                     }
                     else {
                        // exp1: not nilable, exp2: not nilable
                        retType = Ast.builtinTypeStem;
                     }
                  }
                  if retType.$nilable and not exp2Type.$nilable {
                     // exp2 が nilable でなければ、必ず結果は not nilable になる
                     retType = retType.$nonnilableType;
                  }
               }
               case "and" {
                  let workToken = self.getToken(##);
                  self.pushback();

                  if not exp1Type.equals( self.processInfo, Ast.builtinTypeBool ##) and
                     not exp1Type.equals( self.processInfo, Ast.builtinTypeStem ##) and
                     not exp1Type.$nilable
                  {  
                     self.addWarnMess( exp.$pos, "this value never be 'false'" );
                  }
                  elseif exp2.$kind == Nodes.NodeKind.$LiteralBool {
                     if! let literal = exp2.getLiteral() {
                        if not Nodes.getLiteralObj( literal ) {
                           self.addErrMess(
                              exp2.$pos, "this value never be 'true'" );
                        }
                     }
                  }
                  
                  // if workToken.txt == "or" {
                  //    // A and B or C の場合、 A and B の演算結果は B の型とし、
                  //    // B or C の演算結果に処理を廻す。
                  //    retType = exp2Type;
                  // }
                  // else {
                  if exp1Type.$nilable {
                     if exp2Type.$nilable {
                        retType = exp2Type;
                     } else {
                        retType = exp2Type.$nilableTypeInfo;
                     }
                  }
                  elseif exp1Type.equals( self.processInfo, Ast.builtinTypeBool ##) or
                     exp2Type.equals( self.processInfo, Ast.builtinTypeBool ##)
                  {
                     if exp1Type.canEvalWith( self.processInfo, exp2Type, .SetOp, {} ) {  
                        retType = exp1Type;
                     } elseif exp2Type.canEvalWith(
                        self.processInfo, exp1Type, .SetOp, {} )
                     {  
                        retType = exp2Type;
                     } else {
                        if exp2Type.$nilable {
                           retType = Ast.builtinTypeStem_;
                        } else {
                           retType = Ast.builtinTypeStem;
                        }  
                     }  
                  } elseif exp1Type.equals( self.processInfo, Ast.builtinTypeStem ## ) {
                     retType = Ast.builtinTypeStem;
                  } else {
                     retType = exp2Type;
                  }
                  // }  
                  retType = new Ast.AndExpTypeInfo(
                     self.processInfo,  exp1Type, exp2Type, retType );
               }
               case "<", ">", "<=", ">=" {
                  if Ast.builtinTypeString.canEvalWith(
                     self.processInfo, exp1Type, .SetOp, {} ) and
                     Ast.builtinTypeString.canEvalWith(
                        self.processInfo, exp2Type, .SetOp, {} ) or
                      ( Ast.builtinTypeInt.canEvalWith(
                         self.processInfo, exp1Type, .Comp, {} ) or
                        Ast.builtinTypeReal.canEvalWith(
                           self.processInfo, exp1Type, .Comp, {} ) ) and
                      ( Ast.builtinTypeInt.canEvalWith(
                         self.processInfo, exp2Type, .Comp, {} ) or 
                        Ast.builtinTypeReal.canEvalWith(
                           self.processInfo, exp2Type, .Comp, {} ) )   
                  {
                     ;
                  }
                  else {
                     self.addErrMess(
                        opToken.pos,
                        "no numeric type '%s' or '%s'"
                        ( exp1Type.getTxt(self.typeNameCtrl## ),
                          exp2Type.getTxt(self.typeNameCtrl## ) ) );   
                  }
                  retType = Ast.builtinTypeBool;
               }
               case "~=", "==" {
                  exp, exp2 = self.analyzeExpOpEquals(
                     firstToken.pos, opToken, exp, exp2 );
                  retType = Ast.builtinTypeBool;
               }
               case "^", "|", "~", "&", "|<<", "|>>" {
                  if self.targetLuaVer.$hasBitOp == .Cant {
                     self.addErrMess( opToken.pos,
                                      "this lua version can't use bit operand." );
                  }
                  
                  if not Ast.builtinTypeInt.canEvalWith(
                     self.processInfo, exp1Type, .Logical, {} ) or
                     not Ast.builtinTypeInt.canEvalWith(
                        self.processInfo, exp2Type, .Logical, {} )
                  {
                     self.addErrMess(
                        opToken.pos,
                        "no int type '%s' or '%s'"
                        ( exp1Type.getTxt(##), exp2Type.getTxt(##) ) );
                  }
                  retType = Ast.builtinTypeInt;
               }
               case ".." {
                  if not exp1Type.equals( self.processInfo, Ast.builtinTypeString ##) or
                     not exp2Type.equals( self.processInfo, Ast.builtinTypeString ##)
                  {
                     self.addErrMess(
                        opToken.pos,
                        "no string type '%s' or '%s'"
                        ( exp1Type.getTxt(##), exp2Type.getTxt(##) ) );
                  }
                  retType = Ast.builtinTypeString;
               }
               case "+", "-", "*", "/", "%" {
                  if ( not Ast.builtinTypeInt.canEvalWith(
                     self.processInfo, exp1Type, .Math, {} ) and
                       not Ast.builtinTypeReal.canEvalWith(
                          self.processInfo, exp1Type, .Math, {} ) ) or
                      ( not Ast.builtinTypeInt.canEvalWith(
                         self.processInfo, exp2Type, .Math, {} ) and
                        not Ast.builtinTypeReal.canEvalWith(
                           self.processInfo, exp2Type, .Math, {} ) )   
                  {
                     self.addErrMess(
                        opToken.pos,
                        "no numeric type '%s' or '%s'"
                        ( exp1Type.getTxt(##), exp2Type.getTxt(##) ) );
                  }

                  if exp1Type.equals( self.processInfo, Ast.builtinTypeReal ##) or
                     exp2Type.equals( self.processInfo, Ast.builtinTypeReal ##)
                  {
                     retType = Ast.builtinTypeReal;
                     if exp1Type.equals( self.processInfo, Ast.builtinTypeInt ##) {
                        exp = Nodes.ExpCastNode.create(
                           self.nodeManager, exp.$pos, self.inTestBlock,
                           self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeReal ],
                           exp, Ast.builtinTypeReal, nil, "", .Implicit );   
                     } elseif exp2Type.equals( self.processInfo, Ast.builtinTypeInt ##) {
                        exp2 = Nodes.ExpCastNode.create(
                           self.nodeManager, exp2.$pos, self.inTestBlock,
                           self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeReal ],
                           exp2, Ast.builtinTypeReal, nil, "", .Implicit );   
                     }
                  }
                  else {
                     retType = Ast.builtinTypeInt;
                  }
               }
               default {
                  self.error( "unknown op " .. opTxt );
               }
            }


            exp = Nodes.ExpOp2Node.create(
               self.nodeManager, firstToken.pos, self.inTestBlock,
               self.macroCtrl.isInAnalyzeArgMode(), [ retType ], opToken, 
               self.nodeManager.MultiTo1( exp ), self.nodeManager.MultiTo1( exp2 ) );
         }
         else {
            self.error( "illegal op" );
         }
      }
      else {
         self.pushback();
         return exp;
      }
   }
}

fn TransUnit.analyzeExpMacroStat( firstToken: &Parser.Token ) mut : Nodes.ExpMacroStatNode {
   let mut expStrList: List<&Nodes.Node> = [];

   //self.checkNextToken( "{" );

   let mut braceCount = 0;
   let mut prevToken = firstToken;

   let mut errMessList:List<&Macro.ErrorMess> = [];
   
   while true {
      let token = self.getToken(##);

      if token.txt == ",," or token.txt == ",,," or token.txt == ",,,," {
         let exp = self.analyzeExp(
            false, true, false, false, unwrap op1levelMap[ token.txt ] ## );

         let literalStr = self.macroCtrl.expandSymbol(
            self, self.inTestBlock, token, exp, self.nodeManager, errMessList );
         foreach errMess in errMessList {
            self.addErrMess( errMess.pos, errMess.mess );
         }
         
         expStrList.insert( literalStr );
      }
      else {
         if token.txt == "{" {
            braceCount = braceCount + 1;
         }
         elseif token.txt == "}" {
            if braceCount == 0 {
               break;
            }
            braceCount = braceCount - 1;
         }

         let mut format = "' %s'";
         let mut consecutive;
         if prevToken == firstToken or token.consecutive {
            format = "'%s'";
            consecutive = true;
         }
         else {
            consecutive = false;
         }
         let newToken = new Parser.Token(
            token.kind, string.format( format, token.txt ), token.pos, consecutive ## );
         let literalStr = Nodes.LiteralStringNode.create(
            self.nodeManager, token.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(),
            [ Ast.builtinTypeString ], newToken, nil, nil );
         expStrList.insert( literalStr );
      }
      prevToken = token;
   }

   return Nodes.ExpMacroStatNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeStat ], expStrList );
}


fn TransUnit.analyzeSuper( firstToken:&Parser.Token ) mut : Nodes.Node {

   self.checkNextToken( "(" );

   let nextToken = self.getToken(##);
   let mut expList:Nodes.ExpListNode! = nil;
   if nextToken.txt ~= ")" {
      self.pushback();
      expList = self.analyzeExpList( false, false, false, false ## );
      self.checkNextToken( ")" );
   }

   self.checkNextToken( ";" );


   let classType = self.getCurrentClass();
   
   let currentFunc = self.getCurrentNamespaceTypeInfo();
   if currentFunc.$kind == .Method {
      let superType = classType.get_baseTypeInfo();
      if superType.equals( self.processInfo, Ast.headTypeInfo ##) {
         self.addErrMess( firstToken.pos, "This class doesn't have super-class." );
      }     
      else {
         if currentFunc.$rawTxt == "__init" {
            let! superScope = superType.$scope {
               self.error( "not found super scope" );
            };    
            let! superCtorType = superScope.getTypeInfoChild( "__init" ) {
               self.error( "not found super '__init'" );
            }; 
            self.checkMatchValType(
               firstToken.$pos, superCtorType, expList, [], classType );
            return Nodes.ExpCallSuperCtorNode.create(
               self.nodeManager, firstToken.pos, self.inTestBlock,
               self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
               superType, superCtorType, expList );
         }
         else {
            if! let superFunc = (unwrap superType.$scope).getTypeInfoField(
               currentFunc.$rawTxt, true, self.$scope, self.scopeAccess )
            {
               if superFunc.$abstractFlag {
                  self.addErrMess( firstToken.pos, "super is abstract." );
               }
               self.checkMatchValType(
                  firstToken.$pos, superFunc, expList, [], classType );
               let exp = Nodes.ExpCallSuperNode.create(
                  self.nodeManager, firstToken.pos, self.inTestBlock,
                  self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
                  superType, superFunc, expList );
               return Nodes.StmtExpNode.create(
                  self.nodeManager, exp.$pos, self.inTestBlock,
                  self.macroCtrl.isInAnalyzeArgMode(), exp.$expTypeList, exp );
            }
            self.addErrMess( firstToken.pos, "this is not override method." );
            return self.createNoneNode( firstToken.pos );
         }
      }
   }

   self.addErrMess( firstToken.pos, "super can't call here." );
   return self.createNoneNode( firstToken.pos );
}

fn TransUnit.analyzeUnwrap( firstToken: &Parser.Token ) mut : Nodes.Node {
   let nextToken, continueFlag = self.getContinueToken();

   if not continueFlag or nextToken.txt ~= "!" {
      self.pushback();
      self.pushbackToken( firstToken );
      let exp = self.analyzeExp( false, false, false, false ## );
      self.checkNextToken( ";" );
      if not exp.$expType.$nilable {
         self.addErrMess( exp.$pos, "this value is not nilable." );
      }
      return Nodes.StmtExpNode.create(
         self.nodeManager, nextToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], exp );
   }

   self.pushback();
   return self.analyzeDeclVar( .Unwrap, .Local, firstToken );
}

fn TransUnit.analyzeExpUnwrap( firstToken: &Parser.Token ) mut : Nodes.Node {
   //   let expNode = self.analyzeExp( false, opTopLevel ## );
   let expNode = self.analyzeExpOneRVal( false, true ## );
   let nextToken = self.getToken(##);
   let mut insNode: Nodes.Node! = nil;
   if nextToken.txt == "default" {
      insNode = self.analyzeExpOneRVal( false, false ## );
   }
   else {
      self.pushback();
   }

   let mut unwrapType = Ast.builtinTypeStem_;

   let expType = expNode.$expType;
   if not expType.$nilable {
      unwrapType = expType;
      self.addErrMess( expNode.$pos,
                       "this exp is not nilable -- %s" (expType.getTxt(##)) );
   }
   elseif expType.$kind == .DDD {
      if #expType.$itemTypeInfoList > 0 {
         unwrapType = expType.$itemTypeInfoList[ 1 ].$nonnilableType;
      }
      else {
         unwrapType = Ast.builtinTypeStem;
      }
   }
   else {
      unwrapType = expType.$nonnilableType;
   }

   when! insNode {
      let insType = insNode.$expType;

      if insType.$nilable {
         self.addErrMess( insNode.$pos,
                          "default can't use nilable -- %s" (insType.getTxt(##)) );
      }
      
      let mut alt2type = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
      if not unwrapType.canEvalWith(
         self.processInfo, insType, .SetOp, alt2type )
      {
         if not insType.canEvalWith(
            self.processInfo, unwrapType, .SetOp, alt2type ) {
            unwrapType = Ast.builtinTypeStem;
            // self.addErrMess(
            //    insNode.$pos,
            //    "unmatch type: %s <- %s"
            //    ( unwrapType.getTxt(true##), insType.getTxt(true ## ) ) );
         }
         else {
            unwrapType = insType;
         }
      }
      //unwrapType = insType;
   }

   self.helperInfo.useUnwrapExp = true;

   if Ast.isExtType( expType.$nonnilableType ) {
      match self.processInfo.createLuaval( unwrapType, false ) {
         case .OK( work, _ ) {
            unwrapType = work;
         }
         case .Err( err ) {
            self.addErrMess( firstToken.pos, err );
         }
      }
   }

   return Nodes.ExpUnwrapNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ unwrapType ], expNode, insNode );
}

/**
リテラル文字列処理

@param token リテラル文字列トークン
@return LiteralStringNode
*/
fn TransUnit.analyzeStrConst(
   firstToken:&Parser.Token, token:&Parser.Token ) mut : Nodes.Node
{
   let exp;
   
   let mut nextToken = self.getToken( true );
   if nextToken.kind ~= .Eof {
      let param:&Nodes.ExpListNode!;
      let dddParam:&Nodes.ExpListNode!;
      if nextToken.txt == "(" {
         let mut argNodeList:&Nodes.ExpListNode =
            self.analyzeExpList( false, false, false, false## );
         param = argNodeList;

         let _, _, mut workExpList = self.checkMatchType(
            "str constructor", firstToken.pos, [ Ast.builtinTypeDDD ],
            argNodeList, false, false, nil, true );
         when! workExpList {
            dddParam = workExpList;
         }
         else {
            dddParam = nil;
         }

         self.checkNextToken( ")" );
         nextToken = self.getToken( true );

         when! param {
            self.checkStringFormat( token.pos, token.txt, param.$expTypeList );
         }
      }
      else {
         param = nil;
         dddParam = nil;
      }

      let mut workExp:Nodes.Node = Nodes.LiteralStringNode.create(
         self.nodeManager, firstToken.pos,  self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(),
         [ Ast.builtinTypeString ], token, param, dddParam );
      if nextToken.txt == "[" or nextToken.txt == "$[" {
         exp = self.analyzeExpRefItem( nextToken, workExp, nextToken.txt == "$[" );
      }
      else {
         exp = workExp;
         if nextToken.kind ~= .Eof {
            self.pushback();
         }
      }
   }
   else {
      exp = Nodes.LiteralStringNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(),
         [ Ast.builtinTypeString ], token, nil, nil );
   }
   return exp;
}

fn TransUnit.analyzeExp(
   allowNoneType: bool, skipOp2Flag: bool, canLeftExp:bool, canCondRet:bool, 
   prevOpLevel: int!, expectType:&Ast.TypeInfo! ) mut : Nodes.Node
{
   let firstToken = self.getToken(##);
   
   fn processsExpectExp( token:&Parser.Token, orgExpectType:&Ast.TypeInfo ): Nodes.Node {
      if! let enumTypeInfo = orgExpectType.$srcTypeInfo.$aliasSrc@@@Ast.EnumTypeInfo {
         let nextToken = self.getToken(##);
         self.checkEnumComp( nextToken, enumTypeInfo );
         
         if! let valInfo = enumTypeInfo.getEnumValInfo( nextToken.txt ) {

            let mut aliasType:&Ast.AliasTypeInfo! = nil;
            let mut expType:&Ast.TypeInfo = enumTypeInfo;

            aliasType = self.importedAliasMap[ enumTypeInfo ];
            when! aliasType {
               expType = aliasType;
            }
            if not self.moduleType.equals(
               self.processInfo, orgExpectType.getModule() ## )
            {
               if not self.importModuleSet.has( orgExpectType.getModule() ) {
                  // enum を宣言しているモジュールを import していない場合
                  if not aliasType {
                     let fullname = orgExpectType.getFullName(
                        self.typeNameCtrl, self.$scope, true );
                     self.addErrMess(
                        token.pos,              
                        "need to import module -- %s (%s)"
                        ( fullname, enumTypeInfo.getTxt(##) ) );
                  }
               }
            }  
            let mut exp:Nodes.Node = Nodes.ExpOmitEnumNode.create(
               self.nodeManager, token.pos, self.inTestBlock,
               self.macroCtrl.isInAnalyzeArgMode(), [ expType ],
               nextToken, valInfo, aliasType, enumTypeInfo );
            return self.analyzeExpCont( firstToken, exp, false, canLeftExp, canCondRet );
         }

         self.error( "illegal enum val -- %s.%s"
                     (orgExpectType.getTxt(##), nextToken.txt) );
      }
      if! let algeTyepInfo = orgExpectType.$srcTypeInfo.$genSrcTypeInfo@@@Ast.AlgeTypeInfo {
         return self.analyzeNewAlge(
            firstToken, orgExpectType.$srcTypeInfo, algeTyepInfo, nil );
      }

      self.error( "illegal type for '.' -- %s" (orgExpectType.getTxt(##) ) );
   }

   fn processsNewExp( token:&Parser.Token ): Nodes.Node {
      let mut exp:Nodes.Node = self.analyzeRefType( .Local, false, false, true, false );

      let mut classTypeInfo = exp.$expType;
      switch classTypeInfo.$kind {
         case .Class, .IF {
            if classTypeInfo.equals( self.processInfo, Ast.builtinTypeString## ) {
               self.error( "'new' can't use this type -- %s" (classTypeInfo.getTxt(##)));
            }
         }
         default {
            self.error( "'new' can't use this type -- %s" (classTypeInfo.getTxt(##)));
         }
      }
      
      if classTypeInfo.$externalFlag {
         switch classTypeInfo.$accessMode {
            case .Pri, .Local {
               self.addErrMess( token.pos, "Can't access -- %s"
                                (classTypeInfo.$accessMode.$_txt ) );
            }
         }
      }
      if classTypeInfo.$abstractFlag {
         self.addErrMess( token.pos, "abstract class can't new" );
      }
      
      let classScope = classTypeInfo.get_scope();
      let! initTypeInfo = (unwrap classScope).getTypeInfoChild( "__init" ) {
         self.error( "not found __init" );
      };

      self.checkNoasyncType( token.pos, initTypeInfo );
      
      self.checkNextToken( "(" );
      let nextToken = self.getToken(##);
      let mut argList: Nodes.ExpListNode! = nil;
      
      if nextToken.txt ~= ")" {
         self.pushback();
         argList = self.analyzeExpList(
            false, false, false, false, nil, initTypeInfo.$argTypeInfoList ## );
         self.checkNextToken( ")" );
      }

      if initTypeInfo.$accessMode == .Pub or
          ( initTypeInfo.$accessMode == .Pro and
            self.$scope.getClassTypeInfo().isInheritFrom(
               self.processInfo, classTypeInfo, nil ) ) or
          ( self.$scope.getClassTypeInfo() == classTypeInfo.$genSrcTypeInfo ) or
          ( initTypeInfo.$accessMode == .Local and
            initTypeInfo.getModule() == self.moduleType )
      {
         // 次の条件でアクセス可能
         // - pub
         // - pro でサブクラス内
         // - pri で同じクラス内
         // - local で同じモジュール内
      }
      else {
         self.addErrMess(
            token.pos,
            "can't access to __init of %s" (classTypeInfo.getTxt(##)));
      }

      let _, alt2type, newArgList = self.checkMatchValType(
         exp.$pos, initTypeInfo, argList,
         classTypeInfo.$itemTypeInfoList, classTypeInfo );

      if #classTypeInfo.$itemTypeInfoList > 0 {
         if classTypeInfo.$itemTypeInfoList[1].$kind == .Alternate {
            let mut genTypeList:List<&Ast.TypeInfo> = [];
            let mut detect = true;
            foreach altType in classTypeInfo.$itemTypeInfoList {
               if! alt2type[ altType ] {
                  genTypeList.insert( _exp );
               }
               else {
                  self.addErrMess( token.pos, "Can't new generic class. -- %s"
                                   (classTypeInfo.getTxt(##) ));
                  detect = false;
                  break;
               }
            }

            if detect {
               classTypeInfo = self.createGeneric(
                  firstToken.pos, classTypeInfo, genTypeList );
            }
         }
      }
      
      exp = Nodes.ExpNewNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ classTypeInfo ],
         exp, initTypeInfo, newArgList );
      exp = self.analyzeExpCont( firstToken, exp, false, canLeftExp, canCondRet );

      return exp;
   }

   fn processOp1( token:&Parser.Token ): Nodes.Node, bool {
      // 単項演算
      if token.txt == "`{" {
         return self.analyzeExpMacroStat( token ), false;
      }  

      let mut exp = self.analyzeExpOneRVal(
         false, true, false, unwrap op1levelMap[ token.txt] ##);
      let mut typeInfo = Ast.builtinTypeNone;
      let mut macroExpFlag = false;
      let expType = exp.$expType;

      if expType.$kind == .DDD {
         self.addErrMess( exp.$pos, "... can't evaluate for '%s'." (token.txt) );
      }

      switch ( token.txt ) {
         case "-" {
            if not expType.equals( self.processInfo, Ast.builtinTypeInt ##) and
               not expType.equals( self.processInfo, Ast.builtinTypeReal ##)
            {
               self.addErrMess(
                  token.pos,
                  'unmatch type for "-" -- %s' ( expType.getTxt(##) ) );
            }
            typeInfo = expType;
         }
         case "#" {
            if expType.$extedType.$kind ~= .List and
               expType.$extedType.$kind ~= .Array and
               not Ast.builtinTypeString.canEvalWith(
                  self.processInfo, expType, .SetOp, {} )
            {  
               self.addErrMess(
                  token.pos,
                  'unmatch type for "#" -- %s' ( expType.getTxt(##) ) );
            }
            if expType.$kind == .Ext {
               if not self.macroCtrl.$analyzeInfo.isAnalyzingBlockArg() and
                  not self.$curNsInfo.canAccessLuaval()
               {
                  self.addErrMess(
                     token.pos,
                     "can't access the Luaval with '#' without __luago. -- %s"
                     ( expType.getTxt(##) ) );
               }
            }
            
            typeInfo = Ast.builtinTypeInt;
         }  
         case "not" {
            typeInfo = Ast.builtinTypeBool;
            
            if not expType.$nilable and
               not expType.equals( self.processInfo, Ast.builtinTypeBool ##) and
               not expType.equals( self.processInfo, Ast.builtinTypeStem ##) and
               expType.$kind ~= .DDD
            {
               self.addErrMess( token.pos, "this 'not' operand never be false" );
            }
         }
         case ",," {
            macroExpFlag = true;
            typeInfo = expType;
         }  
         case ",,," {
            macroExpFlag = true;
            if not expType.equals( self.processInfo, Ast.builtinTypeString ##) {
               self.error( "unmatch ,,, type, need string type" );
            }  
            typeInfo = Ast.builtinTypeSymbol;
         }
         case ",,,," {
            macroExpFlag = true;
            if not expType.equals( self.processInfo, Ast.builtinTypeSymbol ##) {
               self.error( "unmatch ,,, type, need symbol type" );
            }  
            typeInfo = Ast.builtinTypeString;
         }  
         case "`{" {
            typeInfo = Ast.builtinTypeNone;
         }  
         case "~" {
            if not expType.equals( self.processInfo, Ast.builtinTypeInt ##) {
               self.addErrMess(
                  token.pos,
                  'unmatch type for "~" -- %s' ( expType.getTxt(##) ) );
            }  
            typeInfo = Ast.builtinTypeInt;
         }
         default {
            self.error( "unknown op1" );
         }
      }  

      if macroExpFlag {
         let nextToken = self.getToken( true );
         if nextToken.txt ~= "~~" {
            self.pushback();
         }  
      }  

      exp = Nodes.ExpOp1Node.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], token,
         self.macroCtrl.$analyzeInfo.$mode, self.nodeManager.MultiTo1( exp ) );   
      return self.analyzeExpOp2( firstToken, exp, prevOpLevel ), true;
   }

   
   let mut token = firstToken;
   let mut exp:Nodes.Node = self.createNoneNode( firstToken.pos );

   if token.txt == "##" {
      if allowNoneType {
         self.addErrMess( token.pos, "illeal syntax -- ##" );
      }
      return Nodes.AbbrNode.create(
         self.nodeManager, token.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeAbbr ] );
   }
   
   if token.kind == Parser.TokenKind.Dlmt {
      if token.txt == "." {
         when! expectType {
            let mut orgExpectType = expectType;
            if orgExpectType.$nilable {
               orgExpectType = orgExpectType.$nonnilableType;
            }
            exp = processsExpectExp( token, orgExpectType );
         } else {
            self.error( "illegal '.'" );
         }
      }
      elseif token.txt == '[' or token.txt == '[@' {
         exp = self.analyzeListConst( token, expectType );
      }
      elseif token.txt == '(@' {
         exp = self.analyzeSetConst( token, expectType );
      }  
      elseif token.txt == '{' {
         exp = self.analyzeMapConst( token, expectType );
      }  
      elseif token.txt == "(" {
         exp = self.analyzeExp( false, false, false, false ## );
         self.checkNextToken( ")" );
         if not exp.canBeRight( self.processInfo ) {
            self.addErrMess( exp.$effectivePos,
                             "can't be r-value in paren. -- %s"
                             (Nodes.getNodeKindName( exp.$kind) ) );
         }
         exp = Nodes.ExpParenNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), [ exp.$expType ], exp );
         exp = self.analyzeExpCont( firstToken, exp, false, canLeftExp, canCondRet );
      }
   }  

   if token.txt == "new" {
      exp = processsNewExp( token );
   }  

   if token.kind == Parser.TokenKind.Ope and Parser.isOp1( token.txt ) {
      let mut workExp, fin = processOp1( token );
      if fin {
         return workExp;
      }
      exp = workExp;
   }

   if token.kind == Parser.TokenKind.Int {
      exp = Nodes.LiteralIntNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeInt ],
         token, (unwrap tonumber( token.txt ## ) default 0)@@int );
   }  
   elseif token.kind == Parser.TokenKind.Real {
      exp = Nodes.LiteralRealNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeReal ],
         token, (unwrap tonumber( token.txt ## ) default 0.0));
   }  
   elseif token.kind == Parser.TokenKind.Char {
      let num;
      if #token.txt == 1 {
         num = token.txt[ 1 ];
      }  
      else {
         num = unwrap quotedChar2Code[ token.txt.sub( 2, 2 ) ];
      }  
      exp = Nodes.LiteralCharNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeChar ], token, num );
   }  
   elseif token.kind == Parser.TokenKind.Str {
      exp = self.analyzeStrConst( firstToken, token );
   }
   elseif token.kind == Parser.TokenKind.Symb and token.txt == "__line__" {
      let mut pos = self.getLineNo( token );
      exp = Nodes.LiteralIntNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeInt ],
         new Parser.Token( .Int, "%d" (pos.lineNo),
                           token.pos, false, nil ), token.pos.lineNo );
   }
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "fn" {
      // anonymous 関数 (lambda)
      exp = self.analyzeExpSymbol( firstToken, token, .Fn, nil, false, false, false );
   }  
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "unwrap" {
      exp = self.analyzeExpUnwrap( token );
   }
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "__request" {
      exp = self.analyzeRequest( token );

   }
   elseif token.kind == Parser.TokenKind.Symb {
      exp = self.analyzeExpSymbol(
         firstToken, token, .Symbol, nil, false, canLeftExp, canCondRet );
      let symbolInfoList = exp.getSymbolInfo();
      if #symbolInfoList == 1 {
         let symbolInfo = symbolInfoList[ 1 ];
         if symbolInfo.$kind == .Typ {
            exp = self.analyzeRefTypeWithSymbol(
               .Local, false, nil, exp, false, false );
            let workToken = self.getToken(##);
            if workToken.txt == "." {
               exp = self.analyzeExpSymbol(
                  firstToken, self.getToken(##), .Field,
                  exp, false, canLeftExp, canCondRet );
            }
            else {
               self.pushback();
            }
         }
      }
   }  
   elseif token.kind == Parser.TokenKind.Type {
      let! symbolTypeInfo = Ast.getSym2builtInTypeMap()[ token.txt ] {
         self.error( "unknown type -- %s" ( token.txt ) );
      }; 
      exp = Nodes.ExpRefNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ symbolTypeInfo.$typeInfo ], 
         new Ast.AccessSymbolInfo( self.processInfo, symbolTypeInfo, .None, false ) );

      exp = Nodes.RefTypeNode.create(
         self.nodeManager, firstToken.$pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         exp, [], {}, .Mut, "no" );
   }
   elseif token.kind == Parser.TokenKind.Kywd and
       ( token.txt == "true" or token.txt == "false" )
   {  
      exp = Nodes.LiteralBoolNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeBool ], token );
   }  
   elseif token.kind == Parser.TokenKind.Kywd and
       ( token.txt == "nil" or token.txt == "null" )
   {  
      exp = Nodes.LiteralNilNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNil ] );
   }

   if exp.$kind == Nodes.NodeKind.$None {
      self.error( "illegal exp" );
   }

   if skipOp2Flag {
      return exp;
   }

   return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}
