/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

fn TransUnit.analyzeExpList( skipOp2Flag: bool, expNode: Ast.Node! ) mut: Ast.ExpListNode {
   let expList:Ast.Node[] = [];
   let mut pos:Parser.Position! = nil;
   let expTypeList:Ast.TypeInfo[] = [];
   if! expNode {
      pos = _exp.$pos;
      expList.insert( _exp );
      expTypeList.insert( _exp.$expType );
   }

   repeat {
      let exp = self.analyzeExp( skipOp2Flag, 0 );
      if not pos {
         pos = exp.$pos;
      }
      expList.insert( exp );
      expTypeList.insert( exp.$expType );
      let token = self.getToken();
   } token.txt ~= ",";

   // 最終ノードが複数の値を持つ場合は、その型を追加する
   foreach expType, index in expList[ #expList ].$expTypeList {
      if index ~= 1 {
         expTypeList.insert( expType );
      }
   }

   self.pushback();

   return new Ast.ExpListNode( unwrap pos default new Parser.Position( 0, 0 ),
                               expTypeList, expList );
}

fn TransUnit.analyzeListConst( token: Parser.Token ) mut : Ast.Node {
   let nextToken = self.getToken();
   let mut expList:Ast.ExpListNode! = nil;
   let mut itemTypeInfo = Ast.builtinTypeNone;
   if nextToken.txt ~= "]" {
      self.pushback();
      expList = self.analyzeExpList( false );
      self.checkNextToken( "]" );
      let nodeList: Ast.Node[] = (unwrap expList).$expList;
      foreach exp in nodeList {
         let expType = exp.$expType;
         if itemTypeInfo.equals( Ast.builtinTypeNone ) {
            itemTypeInfo = expType;
         }
         elseif not itemTypeInfo.isSettableFrom( expType ) {
            if expType.equals( Ast.builtinTypeNil ) {
               itemTypeInfo = unwrap itemTypeInfo.$nilableTypeInfo;
            }
            elseif expType.$nilable {
               itemTypeInfo = Ast.builtinTypeStem_;
            }
            else {
               itemTypeInfo = Ast.builtinTypeStem;
            }
         }
      }
   }
   let mut kind = Ast.nodeKindLiteralArray;
   let mut typeInfoList = [ Ast.builtinTypeNone ];
   if token.txt == '[' {
      kind = Ast.nodeKindLiteralList;
      typeInfoList = [ Ast.NormalTypeInfo.createList( "local", self.getCurrentClass(),
                                                      [ itemTypeInfo ] ) ];
      return new Ast.LiteralListNode( token.pos, typeInfoList, expList );
   }
   else {
      typeInfoList = [ Ast.NormalTypeInfo.createArray( "local", self.getCurrentClass(),
                                                       [ itemTypeInfo ] ) ];
      return new Ast.LiteralArrayNode( token.pos, typeInfoList, expList );
   }
   //return self.createNode( kind, token.pos, typeInfo, expList );
}

fn TransUnit.analyzeMapConst( token: Parser.Token ) mut : Ast.LiteralMapNode {
   let mut nextToken:Parser.Token = self.getToken();
   let map:Map<Ast.Node,Ast.Node> = {};
   let pairList:Ast.PairItem[] = [];
   let mut keyTypeInfo = Ast.builtinTypeNone;
   let mut valTypeInfo = Ast.builtinTypeNone;


   fn getMapKeyValType(
      pos: Parser.Position, keyFlag: bool,
      mut typeInfo:Ast.TypeInfo, mut expType:Ast.TypeInfo ): Ast.TypeInfo
   {
      if expType.$nilable {
         if keyFlag {
            self.addErrMess(
               pos, "map key can't set a nilable -- %s" (expType.getTxt()) );
         }
         if expType.equals( Ast.builtinTypeNil ) {
            return typeInfo;
         }
         expType = unwrap expType.$orgTypeInfo;
      }
      if not typeInfo.isSettableFrom( expType ) {
         if not typeInfo.equals( Ast.builtinTypeNone ) {
            typeInfo = Ast.builtinTypeStem;
         }
         else {
            typeInfo = expType;
         }
      }
      return typeInfo;
   }

   while true {
      if nextToken.txt == "}" {
         break;
      }
      self.pushback();

      let key = self.analyzeExp( false );
      keyTypeInfo = getMapKeyValType( key.$pos, true, keyTypeInfo, key.$expType );

      self.checkNextToken( ":" );

      let val = self.analyzeExp( false );
      valTypeInfo = getMapKeyValType( val.$pos, false, valTypeInfo, val.$expType );

      //pairList.insert( { "key": key, "val": val } );
      pairList.insert( new Ast.PairItem( key, val ) );
      map[ key ] = val;
      nextToken = self.getToken();
      if nextToken.txt ~= "," {
         break;
      }
      nextToken = self.getToken();
   }

   let typeInfo = Ast.NormalTypeInfo.createMap(
      "local", self.getCurrentClass(), keyTypeInfo, valTypeInfo );

   self.checkToken( nextToken, "}" );
   // return self.createNode( nodeKindLiteralMap, token.pos,[ typeInfo ],
   //                      { "map": map, "pairList": pairList } );
   return new Ast.LiteralMapNode( token.pos,[ typeInfo ], map, pairList );
}

fn TransUnit.analyzeExpRefItem(
   token: Parser.Token, exp: Ast.Node, mut nilAccess:bool ) mut : Ast.Node {
   let indexExp = self.analyzeExp( false );
   self.checkNextToken( "]" );

   let mut expType = exp.$expType;

   if nilAccess {
      if not expType.$nilable {
         nilAccess = false;
      }
      else {
         expType = unwrap expType.$orgTypeInfo;
      }
   }

   let mut typeInfo = Ast.builtinTypeStem_;
   if expType.$kind == Ast.TypeInfoKind.Map {
      typeInfo = expType.get_itemTypeInfoList()[2];
      if not typeInfo.equals( Ast.builtinTypeStem_ ) and not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
   }
   elseif expType.$kind == Ast.TypeInfoKind.Array or
      expType.$kind == Ast.TypeInfoKind.List
   {
      typeInfo = expType.get_itemTypeInfoList()[1];
   }
   elseif expType.equals( Ast.builtinTypeString ) {
      typeInfo = Ast.builtinTypeInt;
   }
   elseif expType.equals( Ast.builtinTypeStem ) {
      typeInfo = Ast.builtinTypeStem;
   }
   else {
      self.addErrMess( exp.$pos,
                       "could not access with []. -- %s" (expType.getTxt()) );
   }

   if not typeInfo {
      self.error( "illegal type" );
   }

   if nilAccess {
      self.useNilAccess = true;
   }
   return new Ast.ExpRefItemNode( token.pos, [ typeInfo ], exp, nilAccess, indexExp );
}


fn TransUnit.checkMatchType(
   mut message:str, pos: Parser.Position,
   dstTypeList: Ast.TypeInfo[], expNodeList:Ast.Node[] )
{
   if #expNodeList > 0 {
      foreach expNode, index in expNodeList {
         if #dstTypeList < index {
            self.addErrMess( pos,
                             "%s: over exp. expect:%d, actual:%d"
                             ( message,
                               #dstTypeList, #expNodeList) );
            break;
         }
         let argType = dstTypeList[ index ];
         let mut expType = expNode.$expType;
         if #dstTypeList == index {
            if not argType.equals( Ast.builtinTypeDDD ) {
               if not argType.isSettableFrom( expType ) {
                  self.addErrMess(
                     expNode.$pos,
                     "%s: exp(%d) type mismatch %s <- %s"
                     ( message, index,
                       argType.getTxt(), expType.getTxt()));
               }
               if #dstTypeList < #expNodeList {
                  self.addErrMess(
                     expNode.$pos,
                     "%s: over exp. expect: %d: actual: %d"
                     ( message,
                       #dstTypeList, #expNodeList ) );
               }
            }
            break;
         }
         elseif #expNodeList == index {
            // 最終実引数処理
            if expType.equals( Ast.builtinTypeDDD ) {
               for argIndex = index, #dstTypeList {
                  let workArgType = dstTypeList[ argIndex ];
                  if not workArgType.isSettableFrom( Ast.builtinTypeStem_ ) {
                     self.addErrMess(
                        expNode.$pos,
                        "%s: exp(%d) type mismatch %s <- %s"
                        ( message, argIndex,
                          workArgType.getTxt(), expType.getTxt()));
                  }
               }
            }
            else {
               let lastExpTypeList = expNode.$expTypeList;
               let mut expIndex = 1;
               for argIndex = index, #dstTypeList {
                  if expIndex <= #lastExpTypeList {
                     expType = lastExpTypeList[ expIndex ];
                  }
                  else {
                     expType = Ast.builtinTypeNil;
                  }
                  let argTypeInfo = dstTypeList[ argIndex ];
                  if not argTypeInfo.isSettableFrom( expType ) {
                     self.addErrMess(
                        expNode.$pos,
                        "%s: exp(%d) type mismatch %s <- %s"
                        ( message, argIndex,
                          argTypeInfo.getTxt(), expType.getTxt() ) );
                  }
                  expIndex = expIndex + 1;
               }
            }
            break;
         }
         if not argType.isSettableFrom( expType ) {
            self.addErrMess(
               expNode.$pos,
               "%s: exp(%d) type mismatch %s <- %s"
               ( message, index,
                 argType.getTxt(), expType.getTxt()));
         }
      }
   }
   else {
      foreach argType, index in dstTypeList {
         if not argType.isSettableFrom( Ast.builtinTypeNil ) {
            self.addErrMess(
               pos, "%s: exp(%d) type mismatch %s <- nil"
               ( message, index, argType.getTxt()));
         }
      }
   }
}



fn TransUnit.checkMatchValType(
   pos: Parser.Position, funcTypeInfo:Ast.TypeInfo, expList:Ast.ExpListNode!,
   genericTypeList: Ast.TypeInfo[] )
{
   let mut argTypeList = funcTypeInfo.$argTypeInfoList;
   switch funcTypeInfo {
      case typeInfoListInsert {
         argTypeList = genericTypeList;
      }
      case typeInfoListRemove {
      }
   }

   let mut expNodeList:Ast.Node[] = [];

   if! expList {
      expNodeList = _exp.$expList;
   }
   self.checkMatchType( funcTypeInfo.getTxt(), pos, argTypeList, expNodeList );
}

class MacroPaser extend Parser.Parser {
   let tokenList: Parser.Token[];
   let mut pos: int;
   let name: str;

   pub fn __init( tokenList: Parser.Token[], name: str ) {
      self.pos = 1;
      self.tokenList = tokenList;
      self.name = name;
   }

   pub override fn getToken() mut : Parser.Token! {
      if #self.tokenList < self.pos {
         return nil;
      }
      let token = self.tokenList[ self.pos ];
      self.pos = self.pos + 1;

      // Util.errorLog( "getToken: %s" (token.txt) );

      return token;
   }
   pub override fn getStreamName(): str {
      return self.name;
   }
}


fn TransUnit.evalMacro(
   firstToken: Parser.Token,
   macroTypeInfo: Ast.TypeInfo, expList: Ast.ExpListNode! ) mut : Ast.ExpMacroExpNode
{

   if! expList {
      if _exp.get_expList() {
         foreach exp in _exp.get_expList() {
            let kind = exp.$kind;
            if kind ~= Ast.nodeKindLiteralNil and
               kind ~= Ast.nodeKindLiteralChar and
               kind ~= Ast.nodeKindLiteralInt and
               kind ~= Ast.nodeKindLiteralReal and
               kind ~= Ast.nodeKindLiteralArray and
               kind ~= Ast.nodeKindLiteralList and
               kind ~= Ast.nodeKindLiteralMap and
               kind ~= Ast.nodeKindLiteralString and
               kind ~= Ast.nodeKindLiteralBool and
               kind ~= Ast.nodeKindLiteralSymbol and
               kind ~= Ast.nodeKindRefField and
               kind ~= Ast.nodeKindExpMacroStat
            {
               self.error( "Macro arguments must be literal value." );
            }
         }
      }
   }

   let macroInfo = unwrap self.typeId2MacroInfo[ macroTypeInfo.get_typeId() ];

   let argValMap:Map<int,stem> = {};
   let macroArgValMap:Map<str,stem> = {};
   let macroArgNodeList = macroInfo.declInfo.$argList;
   if! expList {
      foreach argNode, index in _exp.get_expList() {
         //let val, typeInfo = getLiteralValue( argNode );
         let valList, typeInfoList = argNode.getLiteral();
         let typeInfo = typeInfoList[1];

         // if type( val ) == "table" {
         //     foreach txt in val@str[] {
         //         if type( txt ) == "table" {
         //             foreach txt2 in txt@str[] {
         //                 Util.errorLog( "hoge: %s" ( txt2 ) );
         //             }
         //         }
         //         else {
         //             Util.errorLog( "hoge: %s" ( txt ) );
         //         }
         //     }
         // }
         // else {
         //         Util.errorLog( "hoge: %s" ( val ) );
         // }
         let! val = valList[1] {}
         then {
            argValMap[ index ] = val;
            let declArgNode = macroArgNodeList[ index ];
            
            macroArgValMap[ declArgNode.$name.txt ] = val;
         };
      }
   }

   let func = macroInfo.func;
   //let macroVars:Map<str,stem!> = func( table.unpack( argVal ) )@@Map<str,stem!>;
   let macroVars:Map<str,stem!> = func( macroArgValMap )@@Map<str,stem!>;

   foreach name in (unwrap macroVars._names)@@str[] {
      let valInfo = unwrap macroInfo.symbol2MacroValInfoMap[ name ];
      let typeInfo = valInfo and valInfo.typeInfo or Ast.builtinTypeStem_;
      let mut val = macroVars[ name ];
      if typeInfo.equals( Ast.builtinTypeSymbol ) {
         val = [ val ];
      }
      self.symbol2ValueMapForMacro[ name ] = new Ast.MacroValInfo( val, typeInfo );
   }

   //let scope = self.pushScope();


   let argList = macroInfo.declInfo.$argList;
   if argList {
      foreach arg, index in argList {
         if arg.get_kind() == Ast.nodeKindDeclArg {
            let argInfo = arg@@Ast.DeclArgNode;
            let argType = argInfo.$argType;
            let argName = argInfo.$name.txt;
            //scope.add( argName, argType.expType );
            self.symbol2ValueMapForMacro[ argName ] =
               new Ast.MacroValInfo( argValMap[ index ], argType.$expType );
         }
         else {
            self.error( "not support ... in macro" );
         }
      }
   }

   // foreach macroValInfo, symbol in self.symbol2ValueMapForMacro {
   //     Util.errorLog( "HOGE: %s %s" (symbol, macroValInfo) );
   // }


   let parser = new MacroPaser( macroInfo.$declInfo.$tokenList,
                                "macro %s" (macroTypeInfo.getTxt()) );
   let bakParser = self.parser;
   self.parser = parser;


   self.macroMode = "expand";


   let stmtList:Ast.Node[] = [];
   self.analyzeStatementList( stmtList, "}" );


   //    self.popScope();

   self.macroMode = "none";
   self.parser = bakParser;


   // return self.createNode(
   //     nodeKindExpMacroExp, firstToken.pos, builtinTypeNone, stmtList );
   return new Ast.ExpMacroExpNode( firstToken.pos, [ Ast.builtinTypeNone ], stmtList );

}

fn TransUnit.analyzeExpCont(
   firstToken: Parser.Token, mut exp: Ast.Node, skipFlag: bool ) mut : Ast.Node {
      let mut nextToken = self.getToken();

      if not skipFlag {
         repeat {
            let mut matchFlag = false;
            if nextToken.txt == "[" or nextToken.txt == "$[" {
               matchFlag = true;
               exp = self.analyzeExpRefItem( nextToken, exp, nextToken.txt == "$[" );
               nextToken = self.getToken();
            }
            if nextToken.txt == "(" or nextToken.txt == "$(" {
               let mut macroFlag = false;
               let mut funcTypeInfo = exp.$expType;
               let mut nilAccess = nextToken.txt == "$(";

               if nilAccess {
                  if funcTypeInfo.$nilable {
                     funcTypeInfo = funcTypeInfo.$orgTypeInfo;
                  }
                  else {
                     nilAccess = false;
                  }
               }

               if funcTypeInfo.get_kind() == Ast.TypeInfoKind.Macro {
                  macroFlag = true;
                  self.symbol2ValueMapForMacro = {};
                  self.macroMode = "analyze";
               }

               matchFlag = true;
               let work = self.getToken();
               let mut expList: Ast.ExpListNode! = nil;
               if work.txt ~= ")" {
                  self.pushback();
                  expList = self.analyzeExpList( false );
                  self.checkNextToken( ")" );
               }

               // 引数の型チェック
               let mut genericTypeList = funcTypeInfo.$itemTypeInfoList;
               if funcTypeInfo.$kind == Ast.TypeInfoKind.Method and
                  exp.$kind == Ast.nodeKindRefField
               {
                  let refField = exp@@Ast.RefFieldNode;
                  let classType = refField.$prefix.$expType;
                  genericTypeList = classType.$itemTypeInfoList;
               }

               self.checkMatchValType(
                  exp.$pos, funcTypeInfo, expList, genericTypeList );

               if funcTypeInfo.equals( typeInfoListInsert ) {
                  if! expList {
                     if _exp.$expType.$nilable {
                        self.addErrMess( _exp.$pos, "list can't insert nilable" );
                     }
                  }
               }

               if macroFlag {
                  self.macroMode = "none";
                  exp = self.evalMacro( firstToken, funcTypeInfo, expList );
               }
               else {
                  switch( funcTypeInfo.$kind ) {
                     case Ast.TypeInfoKind.Method, Ast.TypeInfoKind.Func {
                     }
                     default {
                        self.error( "can't call the type -- %s, %s"
                                    ( funcTypeInfo.getTxt(),
                                      funcTypeInfo.$kind.$_txt ) );
                     }
                  }
                  let mut retTypeInfoList:Ast.TypeInfo[] =
                     funcTypeInfo.get_retTypeInfoList();
                  if nilAccess {
                     retTypeInfoList = [];
                     foreach retType in funcTypeInfo.get_retTypeInfoList() {
                        if retType.$nilable {
                           retTypeInfoList.insert( retType );
                        }
                        else {
                           retTypeInfoList.insert( retType.$nilableTypeInfo );
                        }
                     }
                     self.useNilAccess = true;
                  }
                  exp = new Ast.ExpCallNode(
                     firstToken.pos, retTypeInfoList, exp, nilAccess, expList );
               }

               nextToken = self.getToken();
            }
         } not matchFlag;
      }

      switch nextToken.txt {
         case "." {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(), "field", exp, skipFlag );
         }
         case "$." {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(), "field_nil", exp, skipFlag );
         }
         case ".$" {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(), "get", exp, skipFlag );
         }
         case "$.$" {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(), "get_nil", exp, skipFlag );
         }
      }

      self.pushback();
      return exp;

   }


fn TransUnit.analyzeAccessClassField(
   mut classTypeInfo: Ast.TypeInfo, mode:str, token:Parser.Token ) :
   Ast.TypeInfo!, Ast.SymbolInfo!
{
   if classTypeInfo.get_kind() == Ast.TypeInfoKind.List {
      classTypeInfo = Ast.builtinTypeList;
   }
   let className = classTypeInfo.getTxt();
   let! classScope = classTypeInfo.$scope {
      self.error( "not found field: %s, %s, %s"
                  ( classScope, className, classTypeInfo ) );
   };
   
   let mut getterTypeInfo:Ast.SymbolInfo! = nil;
   let mut fieldTypeInfo:Ast.TypeInfo! = nil;
   if mode == "get" or mode == "get_nil" {
      let fieldSymbolInfo = classScope.getSymbolInfo(
         "get_%s" (token.txt), self.scope, false );
      if! fieldSymbolInfo {
         if ( _exp.get_kind() == Ast.SymbolKind.Mtd )
         {
            let retTypeList = _exp.$typeInfo.get_retTypeInfoList();
            getterTypeInfo = _exp;
            fieldTypeInfo = retTypeList[ 1 ];
         }
      }
   }
   if not getterTypeInfo {
      // fieldSymbolInfo = classScope.getTypeInfo(
      //     token.txt, self.scope, false );
      fieldTypeInfo = classScope.getTypeInfoField(
         token.txt, true, self.scope );
   }
   if not fieldTypeInfo {
      foreach val, name in classScope.$symbol2TypeInfoMap {
         Util.log( "debug: %s, %s" ( name, val ) );
      }
      self.error( "not found field typeInfo: %s.%s"
                  ( className, token.txt ) );
   }
   return fieldTypeInfo, getterTypeInfo;
}

fn TransUnit.dumpComp(
   writer: Writer.Writer, pattern: str,
   symbolInfo: Ast.SymbolInfo, getterFlag:bool ): bool
{
   let symbol = symbolInfo.$name;
   if pattern == "" or symbol.find( pattern ) {
      if getterFlag {
         writer.startParent( "candidate", false );
         let typeInfo = symbolInfo.$typeInfo;
         writer.write( "type", "%s" ( symbolInfo.$kind.$_txt ) );
         switch ( symbolInfo.$kind ) {
            case Ast.SymbolKind.Mtd {
               writer.write( "displayTxt", "$%s"
                             ( typeInfo.$rawTxt.gsub( "^get_", "") ) );
            }  
            case Ast.SymbolKind.Mbr {
               writer.write( "displayTxt", "$%s: %s"
                             ( symbolInfo.$name, typeInfo.getTxt() ) );
            }  
         }
      }
      else {
         writer.startParent( "candidate", false );
         let typeInfo = symbolInfo.$typeInfo;
         writer.write( "type", "%s" ( symbolInfo.$kind.$_txt ) );
         switch ( symbolInfo.$kind ) {
            case Ast.SymbolKind.Fun, Ast.SymbolKind.Mtd {
               writer.write( "displayTxt", "%s" ( typeInfo.$display_stirng ) );
            }  
            case Ast.SymbolKind.Mbr, Ast.SymbolKind.Var {
               writer.write( "displayTxt", "%s: %s"
                             ( symbolInfo.$name, typeInfo.$display_stirng ) );
            }  
            case Ast.SymbolKind.Typ {
               writer.write( "displayTxt", "%s"
                             ( typeInfo.$display_stirng ) );
            }  
         }
      }
      writer.endElement();
   }
   return true;
}

fn TransUnit.dumpFieldComp(
   writer: Writer.Writer, prefixSymbolInfo: Ast.SymbolInfo!,
   prefixTypeInfo: Ast.TypeInfo, pattern: str, getterPattern: str! )
{
   let typeInfo = prefixTypeInfo;
   let! scope = typeInfo.$scope {
      return;
   };

   let mut isPrefixType = false;
   if! prefixSymbolInfo {
      isPrefixType = _exp.$kind == Ast.SymbolKind.Typ;
   }
   
   scope.filterTypeInfoField(
      true, self.scope,
      fn ( symbolInfo: Ast.SymbolInfo ) : bool {
         if ( isPrefixType ) {
            if not symbolInfo.$staticFlag and
               not symbolInfo.$typeInfo.$staticFlag and
               symbolInfo.$kind ~= Ast.SymbolKind.Typ
            {
               // 型のフィールド補完は 非 static を除外
               return true;
            }
         }
         elseif symbolInfo.$staticFlag {
            // インスタンスのフィールド補完は static を除外
            return true;
         }
         let symbol = symbolInfo.$name;
         if symbol ~= "__init" and symbol ~= "self"
         {
            if! getterPattern {
               if symbolInfo.$kind == Ast.SymbolKind.Mtd {
                  let typeInfo = symbolInfo.$typeInfo;
                  let retList = typeInfo.$retTypeInfoList;
                  if #retList == 1 {
                     return self.dumpComp( writer, _exp, symbolInfo, true );
                  }
               }
               return true;
            }
            return self.dumpComp(writer, pattern, symbolInfo, false );
         }
         return true;
      });
}

fn TransUnit.dumpSymbolComp( writer: Writer.Writer, scope: Ast.Scope, pattern: str ) {
   scope.filterSymbolTypeInfo(
      scope, self.moduleScope,
      fn ( symbolInfo: Ast.SymbolInfo ) : bool {
         return self.dumpComp(writer, pattern, symbolInfo, false );
      });    
}

fn TransUnit.checkComp( token:Parser.Token, callback:form )
{
   if self.analyzeMode == "comp" and
      self.analyzePos.lineNo == token.pos.lineNo and
      self.analyzePos.column >= token.pos.column and
      self.analyzePos.column <= token.pos.column + #token.txt 
   {
      let mut currentModule = self.parser.getStreamName().gsub( "%.lns", "" );
      currentModule = currentModule.gsub( ".*/", "" );
      let target = self.analyzeModule.gsub( "[^%.]+%.", "" );
      if currentModule == target {
         let jsonWriter = new Writer.JSON( io.stdout );
         jsonWriter.startParent( "lunescript", false );
         let prefix = token.txt.gsub( "lune$", "" );
         jsonWriter.write( "prefix", prefix );
         jsonWriter.startParent( "candidateList", true );

         callback( jsonWriter, prefix );

         jsonWriter.endElement();
         jsonWriter.endElement();
         jsonWriter.fin();
         os.exit( 0 );
      }
   }
}


fn TransUnit.checkFieldComp(
   getterFlag:bool, token:Parser.Token, prefixExp: Ast.Node )
{
   if self.analyzeMode ~= "comp" {
      return;
   }
   let prefixSymbolInfoList = prefixExp.getSymbolInfo();
   let mut prefixSymbolInfo:Ast.SymbolInfo! = nil;
   if #prefixSymbolInfoList == 1 {
      prefixSymbolInfo = prefixSymbolInfoList[ 1 ];
   }
   
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         let mut getterPattern:str! = nil;
         if getterFlag {
            getterPattern = "^get_" .. prefix;
         }
         self.dumpFieldComp(
            jsonWriter, prefixSymbolInfo, prefixExp.$expType,
            prefix == "" and "" or "^" .. prefix, getterPattern );
      }
   );
}

fn TransUnit.checkSymbolComp( token:Parser.Token )
{
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         self.dumpSymbolComp( jsonWriter, self.scope,
                              prefix == "" and "" or "^" .. prefix );
      }
   );
}


fn TransUnit.analyzeExpSymbol(
   firstToken: Parser.Token, token: Parser.Token,
   mode: str, prefixExp: Ast.Node!, mut skipFlag: bool ) mut : Ast.Node
{
   let mut exp:Ast.Node! = nil;
   
   if mode == "field" or mode == "get" or
      mode == "field_nil" or mode == "get_nil"
   {
      sync! prefixExp = prefixExp { self.error( "prefix is nil" ); }
      then {
         let mut accessNil = false;
         if mode == "field_nil" or mode == "get_nil" {
            accessNil = true;
         }
         if self.macroMode == "analyze" {
            if accessNil {
               self.useNilAccess = true;
            }
            exp = new Ast.RefFieldNode(
               firstToken.pos, [ Ast.builtinTypeSymbol ],
               token, nil, accessNil, unwrap prefixExp );
         }
         else {
            let mut typeInfo:Ast.TypeInfo! = Ast.builtinTypeStem_;
            let mut prefixExpType = prefixExp.$expType;

            self.checkFieldComp(
               mode == "get" or mode == "get_nil", token, prefixExp );
            
            if accessNil {
               if prefixExpType.$nilable {
                  // nil 条件演算で、 prefixExpType が nilable ならば、
                  // prefixExpType を非 nilable にセットする
                  prefixExpType = unwrap prefixExpType.$orgTypeInfo;
               }
               else {
                  // prefixExpType が nilable でなければ、
                  // nil 判定は不要なので accessNil をクリアする
                  accessNil = false;
               }
            }

            let mut getterTypeInfo:Ast.TypeInfo! = nil;
            let mut symbolInfo:Ast.SymbolInfo! = nil;
            if prefixExpType.get_kind() == Ast.TypeInfoKind.Class or
               prefixExpType.get_kind() == Ast.TypeInfoKind.Module or
               prefixExpType.get_kind() == Ast.TypeInfoKind.IF or
               prefixExpType.get_kind() == Ast.TypeInfoKind.List
            {
               typeInfo, symbolInfo = self.analyzeAccessClassField(
                  prefixExpType, mode, token );
               if! symbolInfo {
                  getterTypeInfo = _exp.$typeInfo;
               }
            }
            elseif prefixExpType.get_kind() == Ast.TypeInfoKind.Map {
               let work = prefixExpType.$itemTypeInfoList[1];
               if not work.equals( Ast.builtinTypeString ) {
                  self.addErrMess(
                     token.pos,
                     "map key type is not str. (%s)" (work.getTxt()) );
               }
               typeInfo = prefixExpType.$itemTypeInfoList[2];
               if! typeInfo {
                  if not _exp.$nilable {
                     //if _exp.$nilable {
                     typeInfo = _exp.$nilableTypeInfo;
                  }
               }
            }
            elseif prefixExpType.get_kind() == Ast.TypeInfoKind.Enum {
               let scope = unwrap prefixExpType.$scope;
               let mut fieldName = token.txt;
               if mode == "get" {
                  fieldName = "get_" .. fieldName;
                  getterTypeInfo = Ast.rootTypeInfo;
               }
               
               typeInfo = scope.getTypeInfoChild( fieldName );
               if not typeInfo {
                  self.addErrMess( token.pos,
                                   "not found enum field -- %s" (token.txt));
                  typeInfo = Ast.builtinTypeInt;
               }
            }
            elseif prefixExpType.equals( Ast.builtinTypeStem ) {
            }
            else {
               self.error( "illegal type -- %s, %d"
                           ( prefixExpType.getTxt(),
                             prefixExpType.get_kind() ) );
            }


            if not symbolInfo {
               let prefixScope = prefixExpType.$scope;
               if! prefixScope {
                  symbolInfo = _exp.getSymbolInfoField( token.txt, true, self.scope );
               }
            }
            let prefixSymbolInfoList = prefixExp.getSymbolInfo();
            let mut prefixSymbolInfo:Ast.AccessSymbolInfo! = nil;
            if #prefixSymbolInfoList == 1 {
               prefixSymbolInfo = prefixSymbolInfoList[1];
            }
            
            if! symbolInfo {
               sync! prefixSymbolInfo = prefixSymbolInfo {}
               then {
                  if prefixSymbolInfo.$kind == Ast.SymbolKind.Typ {
                     if _exp.$typeInfo.$kind ~= Ast.TypeInfoKind.Func and
                        _exp.$typeInfo.$kind ~= Ast.TypeInfoKind.Method and
                        _exp.$kind ~= Ast.SymbolKind.Typ and
                        not _exp.$staticFlag
                     {  
                        self.addErrMess(
                           token.pos,              
                           "Type can't access this symbol. -- %s" (token.txt) );
                     }  
                  }  
                  elseif _exp.$staticFlag {
                     self.addErrMess(
                        token.pos, "can't access this symbol. -- %s" (token.txt) );
                  }
               };
            }

            if accessNil {
               if! typeInfo {
                  if not _exp.$nilable {
                     typeInfo = _exp.$nilableTypeInfo;
                  }
               }
               self.useNilAccess = true;
            }

            let mut accessSymbolInfo:Ast.AccessSymbolInfo! = nil;
            if! symbolInfo {
               accessSymbolInfo = new Ast.AccessSymbolInfo( _exp, prefixExpType );
            };

            
            if! getterTypeInfo {
               exp = new Ast.GetFieldNode(
                  firstToken.pos, [ unwrap typeInfo ],
                  token, accessSymbolInfo, accessNil, prefixExp, _exp );
            }
            else {
               exp = new Ast.RefFieldNode(
                  firstToken.pos, [ unwrap typeInfo ],
                  token, accessSymbolInfo, accessNil, prefixExp );
            }
         }
      };
   }
   elseif mode == "symbol" {
      if self.macroMode == "analyze" {
         exp = new Ast.LiteralSymbolNode(
            firstToken.pos, [ Ast.builtinTypeSymbol ], token );
      }
      else {
         self.checkSymbolComp( token );
         
         let! symbolInfo = self.scope.getSymbolTypeInfo(
            token.txt, self.scope, self.moduleScope )
         {
            self.error( "not found type -- " .. token.txt );
         };
         let typeInfo = symbolInfo.$typeInfo;
         if typeInfo.equals( Ast.builtinTypeSymbol ) {
            skipFlag = true;
         }
         exp = new Ast.ExpRefNode(
            firstToken.pos, [ typeInfo ], token,
            new Ast.AccessSymbolInfo( symbolInfo, nil ) );
      }
   }
   elseif mode == "fn" {
      exp = self.analyzeDeclFunc(
         false, false, false, "local", false, nil, token, nil );
   }
   else {
      self.error( "illegal mode -- %s" ( mode ) );
   }

   return self.analyzeExpCont( firstToken, unwrap exp, skipFlag );
}

fn TransUnit.analyzeExpOpSet(
   exp: Ast.Node, opeToken: Parser.Token, exp2NodeList:Ast.Node[] ) mut
{
   if not exp.canBeLeft() {
      self.addErrMess( exp.$pos,
                       "this node can not be l-value. -- %s"
                       (Ast.getNodeKindName( exp.$kind ) ) );
   }
   self.checkMatchType(
      "= operator", opeToken.pos, exp.$expTypeList, exp2NodeList );

   foreach symbolInfo in exp.getSymbolInfo() {
      if not symbolInfo.$mutable and symbolInfo.$hasValueFlag
      {     
         self.addErrMess( opeToken.$pos,
                          "this is not mutable variable. -- %s"
                          ( symbolInfo.$name ) );
      }
      symbolInfo.set_hasValueFlag( true );
   }
}

fn TransUnit.analyzeExpOp2(
   firstToken: Parser.Token, mut exp: Ast.Node, prevOpLevel: int! ) mut : Ast.Node
{
   while true {
      let nextToken = self.getToken();
      let opTxt = nextToken.txt;

      if opTxt == "@@" {
         let castType = self.analyzeRefType( "local", false );
         
         if exp.$expType.$nilable and not castType.$expType.$nilable {
            self.addErrMess( firstToken.pos,
                             "can't cast from nilable to not nilable  -- %s->%s"
                             (exp.$expType.getTxt(), castType.$expType.getTxt()) );
         }
         exp = new Ast.ExpCastNode( firstToken.pos, castType.$expTypeList, exp );
      }
      elseif nextToken.kind == Parser.TokenKind.Ope {
         if Parser.isOp2( opTxt ) {
            let! opLevel = op2levelMap[ opTxt ] {
               self.error( "unknown op -- %s %s" (opTxt, prevOpLevel ) );
            };
            if! prevOpLevel {
               if opLevel <= _exp {
                  self.pushback();
                  return exp;
               }
            }

            let mut exp2 = self.analyzeExp( false, opLevel );
            let mut exp2NodeList = [ exp2 ];
            if opTxt == "=" {
               let workToken = self.getToken();
               if workToken.txt == "," {
                  let expListNode = self.analyzeExpList( false, exp2 );
                  exp2 = expListNode;
                  exp2NodeList = expListNode.$expList;
               }
               else {
                  self.pushback();
               }
            }
            let info = { "op": nextToken, "exp1": exp, "exp2": exp2 };

            if not exp.$expType or not exp2.$expType {
               self.error( "illegal exp or exp2 %s, %s, %s , %s,%d:%d"
                           ( exp.$expType, exp2.$expType,
                             nextToken.txt, self.parser.getStreamName(),
                             nextToken.pos.lineNo, nextToken.pos.column) );
            }

            let mut retType = Ast.builtinTypeNone;

            if not exp2.canBeRight() {
               self.addErrMess( exp2.$pos,
                                "this node can not be r-value. -- %s"
                                (Ast.getNodeKindName( exp2.$kind ) ) );
            }
            
            let exp1Type = exp.$expType;
            let exp2Type = exp2.$expType;
            if not exp1Type {
               self.error( "expType is nil %s:%d:%d"
                           ( self.parser.getStreamName(),
                             firstToken.pos.lineNo, firstToken.pos.column ) );
            }

            switch opTxt {
               case "or" {
                  if exp1Type.equals( exp2Type ) {
                     retType = exp1Type;
                  }
                  elseif exp1Type.$kind == exp2Type.$kind {
                     // 暫定
                     retType = exp1Type;
                  }
                  elseif exp2Type.equals( Ast.builtinTypeNil ) {
                     retType = exp1Type;
                  }
                  elseif exp1Type.equals( Ast.builtinTypeNil ) {
                     retType = exp2Type;
                  }
                  else {
                     retType = Ast.builtinTypeStem_;
                  }
               }
               case "and" {
                  // 暫定。 本来は exp2Type の nilable になる
                  retType = exp2Type;
               }
               case "<", ">", "<=", ">=" {
                  if ( not Ast.builtinTypeInt.isSettableFrom( exp1Type ) and
                       not Ast.builtinTypeReal.isSettableFrom( exp1Type ) ) or
                      ( not Ast.builtinTypeInt.isSettableFrom( exp2Type ) and
                        not Ast.builtinTypeReal.isSettableFrom( exp2Type) )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no numeric type %s or %s"
                        ( exp1Type.getTxt(), exp2Type.getTxt() ) );
                  }
                  retType = Ast.builtinTypeBool;
               }
               case "~=", "==" {
                  if ( not exp1Type.isSettableFrom( exp2Type ) and
                       not exp2Type.isSettableFrom( exp1Type ) )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "not compatible type %s or %s" ( exp1Type.getTxt(),
                                                         exp2Type.getTxt() ) );
                  }
                  retType = Ast.builtinTypeBool;
               }
               case "^", "|", "~", "&", "<<", ">>" {
                  if not Ast.builtinTypeInt.isSettableFrom( exp1Type ) or
                     not Ast.builtinTypeInt.isSettableFrom( exp2Type )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no int type %s or %s" ( exp1Type.getTxt(),
                                                 exp2Type.getTxt() ) );
                  }
                  retType = Ast.builtinTypeInt;
               }
               case ".." {
                  if not exp1Type.equals( Ast.builtinTypeString ) or
                     not exp1Type.equals( Ast.builtinTypeString )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no string type %s or %s" ( exp1Type.getTxt(),
                                                    exp2Type.getTxt() ) );
                  }
                  retType = Ast.builtinTypeString;
               }
               case "+", "-", "*", "/", "//", "%" {
                  if ( not Ast.builtinTypeInt.isSettableFrom( exp1Type ) and
                       not Ast.builtinTypeReal.isSettableFrom( exp1Type ) ) or
                      ( not Ast.builtinTypeInt.isSettableFrom( exp2Type ) and
                        not Ast.builtinTypeReal.isSettableFrom( exp2Type) )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no numeric type %s or %s" ( exp1Type.getTxt(),
                                                     exp2Type.getTxt() ) );
                  }

                  if Ast.builtinTypeReal.isSettableFrom( exp1Type ) or
                     Ast.builtinTypeReal.isSettableFrom( exp2Type )
                  {
                     retType = Ast.builtinTypeReal;
                  }
                  else {
                     retType = Ast.builtinTypeInt;
                  }
               }
               case "=" {
                  self.analyzeExpOpSet( exp, nextToken, exp2NodeList );
               }
               default {
                  self.error( "unknown op " .. opTxt );
               }
            }

            exp = new Ast.ExpOp2Node(
               firstToken.pos, [ retType ], nextToken, exp, exp2 );
         }
         else {
            self.error( "illegal op" );
         }
      }
      else {
         self.pushback();
         return exp;
      }
   }
   return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}

fn TransUnit.analyzeExpMacroStat( firstToken: Parser.Token ) mut : Ast.ExpMacroStatNode {
   let expStrList: Ast.Node[] = [];

   self.checkNextToken( "{" );

   let mut braceCount = 0;
   let mut prevToken = firstToken;
   while true {
      let token = self.getToken();

      if token.txt == ",," or token.txt == ",,," or token.txt == ",,,," {
         let exp = self.analyzeExp( true, unwrap op1levelMap[ token.txt ] );

         let nextToken = self.getToken();
         if nextToken.txt ~= "~~" {
            self.pushback();
         }


         let mut format = token.txt == ",,," and "'%s '" or '"\'%s\'"';

         if token.txt == ",," and exp.$kind == Ast.nodeKindExpRef
         {
            let refToken = (exp@@Ast.ExpRefNode).get_token();
            let macroInfo = self.symbol2ValueMapForMacro[ refToken.txt ];
            if macroInfo {
               if (unwrap macroInfo).typeInfo.equals( Ast.builtinTypeSymbol ) {
                  format = "'%s '";
               }
            }
            else {
               if exp.$expType.equals( Ast.builtinTypeInt ) or
                  exp.$expType.equals( Ast.builtinTypeReal )
               {
                  format = "'%s' ";
               }
            }
         }
         let newToken = new Parser.Token( Parser.TokenKind.Str, format, token.pos );
         let literalStr = new Ast.LiteralStringNode(
            token.pos, [ Ast.builtinTypeString ], newToken, [ exp ] );
         expStrList.insert(  literalStr );
      }
      else {
         if token.txt == "{" {
            braceCount = braceCount + 1;
         }
         elseif token.txt == "}" {
            if braceCount == 0 {
               break;
            }
            braceCount = braceCount - 1;
         }

         let mut format = "' %s '";
         if prevToken == firstToken or
            (prevToken.pos.lineNo == token.pos.lineNo and
              prevToken.pos.column + #prevToken.txt == token.pos.column)
         {
            format = "'%s'";
         }
         let newToken = new Parser.Token(
            token.kind, string.format( format, token.txt ), token.pos );
         let literalStr = new Ast.LiteralStringNode(
            token.pos, [ Ast.builtinTypeString ], newToken, [] );
         expStrList.insert( literalStr );
      }
      prevToken = token;
   }

   return new Ast.ExpMacroStatNode(
      firstToken.pos, [ Ast.builtinTypeStat ], expStrList );
}


fn TransUnit.analyzeSuper( firstToken:Parser.Token ) mut : Ast.Node {

   self.checkNextToken( "(" );

   let expList = self.analyzeExpList( false );

   self.checkNextToken( ")" );
   self.checkNextToken( ";" );

   let classType = self.getCurrentClass();
   let superType = classType.get_baseTypeInfo();

   return new Ast.ExpCallSuperNode(
      firstToken.pos, [ Ast.builtinTypeNone ], superType, expList );
}

fn TransUnit.analyzeUnwrap( firstToken: Parser.Token ) mut : Ast.Node {
   let nextToken, continueFlag = self.getContinueToken();

   if not continueFlag or nextToken.txt ~= "!" {
      self.pushback();
      self.pushbackToken( firstToken );
      let exp = self.analyzeExp( false );
      self.checkNextToken( ";" );
      return new Ast.StmtExpNode( nextToken.pos, [ Ast.builtinTypeNone ], exp );
   }

   self.pushback();
   return self.analyzeDeclVar( "unwrap", "local", firstToken );
}

fn TransUnit.analyzeExpUnwrap( firstToken: Parser.Token ) mut : Ast.Node {
   let expNode = self.analyzeExp( true );
   let nextToken = self.getToken();
   let mut insNode: Ast.Node! = nil;
   if nextToken.txt == "default" {
      insNode = self.analyzeExp( false );
   }
   else {
      self.pushback();
   }

   let mut unwrapType:Ast.TypeInfo = Ast.builtinTypeStem_;

   let expType = expNode.$expType;
   if not expType.$nilable {
      unwrapType = expType;
   }
   else {
      unwrapType = unwrap expType.$orgTypeInfo;
      if! insNode {
         let insType = _exp.$expType;
         unwrapType = insType;

         if not unwrapType.isSettableFrom( insType ) {
            self.addErrMess(
               _exp.$pos,
               "unmatch type: %s <- %s" ( unwrapType.getTxt(), insType.getTxt() ) );
         }
      }
   }

   self.useUnwrapExp = true;

   return new Ast.ExpUnwrapNode( firstToken.pos, [ unwrapType ], expNode, insNode );
}


fn TransUnit.analyzeExp( skipOp2Flag: bool, prevOpLevel: int! ) mut: Ast.Node {
   let firstToken = self.getToken();
   let mut token = firstToken;
   let mut exp:Ast.Node = new Ast.NoneNode( firstToken.pos, [ Ast.builtinTypeNone ] );

   if token.kind == Parser.TokenKind.Dlmt {
      if token.txt == "..." {
         return new Ast.ExpDDDNode( firstToken.pos, [ Ast.builtinTypeNone ], token );
      }

      if token.txt == '[' or token.txt == '[@' {
         exp = self.analyzeListConst( token );
      }
      if token.txt == '{' {
         exp = self.analyzeMapConst( token );
      }
      if token.txt == "(" {
         exp = self.analyzeExp( false );
         self.checkNextToken( ")" );
         exp = new Ast.ExpParenNode( firstToken.pos, exp.$expTypeList, exp );
         exp = self.analyzeExpCont( firstToken, exp, false );
      }
   }

   if token.txt == "new" {
      exp = self.analyzeRefType( "local", false );

      self.checkNextToken( "(" );
      let nextToken = self.getToken();
      let mut argList: Ast.ExpListNode! = nil;
      if nextToken.txt ~= ")" {
         self.pushback();
         argList = self.analyzeExpList( false );
         self.checkNextToken( ")" );
      }

      // 引数チェック
      let classTypeInfo = exp.$expType;
      //let classScope = self.typeId2Scope[ classTypeInfo.get_typeId() ];
      let classScope = classTypeInfo.get_scope();
      let! initTypeInfo = (unwrap classScope).getTypeInfoChild( "__init" ) {
         self.error( "not found __init" );
      };

      if initTypeInfo.$accessMode == "pub" or
          ( initTypeInfo.$accessMode == "pro" and
            self.scope.getClassTypeInfo().isInheritFrom( classTypeInfo ) ) or
          ( self.scope.getClassTypeInfo() == classTypeInfo )
      {
         // pub、 pro でサブクラス、 pri で同じクラスの場合はアクセス可能
      }
      else {
         self.addErrMess(
            token.pos,
            "can't access to __init of %s" (classTypeInfo.getTxt()));
      }

      self.checkMatchValType( exp.$pos, initTypeInfo, argList,
                              exp.$expType.$itemTypeInfoList );

      exp = new Ast.ExpNewNode( firstToken.pos, exp.$expTypeList, exp, argList );
      exp = self.analyzeExpCont( firstToken, exp, false );
   }

   if token.kind == Parser.TokenKind.Ope and Parser.isOp1( token.txt ) {
      // 単項演算
      if token.txt == "`" {
         exp = self.analyzeExpMacroStat( token );
      }
      else {
         exp = self.analyzeExp( true, unwrap op1levelMap[ token.txt] );
         let mut typeInfo = Ast.builtinTypeNone;
         let mut macroExpFlag = false;

         switch ( token.txt ) {
            case "-" {
               if not exp.$expType.equals( Ast.builtinTypeInt ) and
                  not exp.$expType.equals( Ast.builtinTypeReal )
               {
                  self.addErrMess(
                     token.pos,
                     'unmatch type for "-" -- %s' ( exp.$expType.getTxt() ) );
               }
               typeInfo = exp.$expType;
            }
            case "#" {
               if exp.$expType.$kind ~= Ast.TypeInfoKind.List and
                  exp.$expType.$kind ~= Ast.TypeInfoKind.Array and
                  exp.$expType.$kind ~= Ast.TypeInfoKind.Map and
                  not Ast.builtinTypeString.isSettableFrom( exp.$expType )
               {
                  self.addErrMess(
                     token.pos,
                     'unmatch type for "#" -- %s' ( exp.$expType.getTxt() ) );
               }
               typeInfo = Ast.builtinTypeInt;
            }
            case "not" {
               typeInfo = Ast.builtinTypeBool;
            }
            case ",," {
               macroExpFlag = true;
            }
            case ",,," {
               macroExpFlag = true;
               if not exp.$expType.equals( Ast.builtinTypeString ) {
                  self.error( "unmatch ,,, type, need string type" );
               }
               typeInfo = Ast.builtinTypeSymbol;
            }
            case ",,,," {
               macroExpFlag = true;
               if not exp.$expType.equals( Ast.builtinTypeSymbol ) {
                  self.error( "unmatch ,,, type, need symbol type" );
               }
               typeInfo = Ast.builtinTypeString;
            }
            case "`" {
               typeInfo = Ast.builtinTypeNone;
            }
            case "not" {
               typeInfo = Ast.builtinTypeBool;
            }
            default {
               self.error( "unknown op1" );
            }
         }

         if macroExpFlag {
            let nextToken = self.getToken();
            if nextToken.txt ~= "~~" {
               self.pushback();
            }
         }

         exp = new Ast.ExpOp1Node(
            firstToken.pos, [ typeInfo ], token, self.macroMode, exp );
         return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
      }
   }

   if token.kind == Parser.TokenKind.Int {
      exp = new Ast.LiteralIntNode( firstToken.pos, [ Ast.builtinTypeInt ],
                                    token, tonumber( token.txt )@@int );
   }
   elseif token.kind == Parser.TokenKind.Real {
      exp = new Ast.LiteralRealNode( firstToken.pos, [ Ast.builtinTypeReal ],
                                     token, tonumber( token.txt ) );
   }
   elseif token.kind == Parser.TokenKind.Char {
      let mut num = 0;
      if #(token.txt) == 1 {
         num = token.txt.byte( 1 );
      }
      else {
         num = unwrap quotedChar2Code[ token.txt.sub( 2, 2 ) ];
      }
      exp = new Ast.LiteralCharNode( firstToken.pos, [ Ast.builtinTypeChar ], token, num );
   }
   elseif token.kind == Parser.TokenKind.Str {
      let mut nextToken = self.getToken();
      let formatArgList:Ast.Node[] = [];
      if nextToken.txt == "(" {
         repeat {
            let arg = self.analyzeExp( false );
            formatArgList.insert( arg );
            nextToken = self.getToken();
         } nextToken.txt ~= ",";
         self.checkToken( nextToken, ")" );
         nextToken = self.getToken();
      }
      exp = new Ast.LiteralStringNode(
         firstToken.pos, [ Ast.builtinTypeString ], token, formatArgList );
      token = nextToken;
      if token.txt == "[" or token.txt == "$[" {
         exp = self.analyzeExpRefItem( token, exp, token.txt == "$[" );
      }
      else {
         self.pushback();
      }
   }
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "fn" {
      exp = self.analyzeExpSymbol( firstToken, token, "fn", nil, false );
   }
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "unwrap" {
      exp = self.analyzeExpUnwrap( token );
   }
   elseif token.kind == Parser.TokenKind.Symb {
      exp = self.analyzeExpSymbol(
         firstToken, token, "symbol", nil, false );
   }
   elseif token.kind == Parser.TokenKind.Type {
      let! symbolTypeInfo = Ast.sym2builtInTypeMap[ token.txt ] {
         self.error( "unknown type -- %s" ( token.txt ) );
      };
      exp = new Ast.ExpRefNode(
         firstToken.pos, [ Ast.builtinTypeNone ], token,
         new Ast.AccessSymbolInfo( symbolTypeInfo, nil ) );
   }
   elseif token.kind == Parser.TokenKind.Kywd and
       ( token.txt == "true" or token.txt == "false" ) {
          exp = new Ast.LiteralBoolNode( firstToken.pos, [ Ast.builtinTypeBool ], token );
       }
   elseif token.kind == Parser.TokenKind.Kywd and
       ( token.txt == "nil" or token.txt == "null" )
   {
      exp = new Ast.LiteralNilNode( firstToken.pos, [ Ast.builtinTypeNil ] );
   }

   if not exp {
      self.error( "illegal exp" );
   }

   if skipOp2Flag {
      return exp;
   }

   return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}
