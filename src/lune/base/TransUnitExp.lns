/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

fn TransUnit.analyzeExpList(
   skipOp2Flag: bool, expNode: Ast.Node!,
   expectTypeList: List<&Ast.TypeInfo>!, contExpect:bool! ) mut: Ast.ExpListNode
{
   let mut expList:List<&Ast.Node> = [];
   let mut pos:Parser.Position! = nil;
   let mut expTypeList:List<&Ast.TypeInfo> = [];
   if! expNode {
      pos = _exp.$pos;
      expList.insert( _exp );
      expTypeList.insert( _exp.$expType );
   }

   let mut index = 1;
   repeat {
      let mut expectType:&Ast.TypeInfo! = nil;
      if! expectTypeList {
         if #_exp > 0 {
            let mut checkIndex = index;
            if index > #_exp and contExpect {
               checkIndex = #_exp;
            }
            if checkIndex <= #_exp and _exp[ checkIndex ] ~= Ast.builtinTypeNone {
               expectType = _exp[ checkIndex ];
            }
         }
      }
      let exp = self.analyzeExp( skipOp2Flag, 0, expectType );
      if not pos {
         pos = exp.$pos;
      }
      expList.insert( exp );
      expTypeList.insert( exp.$expType );
      let token = self.getToken();
      index = index + 1;
   } token.txt ~= ",";

   // 最終ノードが複数の値を持つ場合は、その型を追加する
   foreach expType, listIndex in expList[ #expList ].$expTypeList {
      if listIndex ~= 1 {
         expTypeList.insert( expType );
      }
   }

   self.pushback();

   return Ast.ExpListNode.create(
      self.nodeManager, unwrap pos default new Parser.Position( 0, 0 ),
      expTypeList, expList );
}

fn TransUnit.analyzeListConst( token: &Parser.Token ) mut : Ast.Node {
   let nextToken = self.getToken();
   let mut expList:Ast.ExpListNode! = nil;
   let mut itemTypeInfo = Ast.builtinTypeNone;
   if nextToken.txt ~= "]" {
      self.pushback();
      expList = self.analyzeExpList( false );
      self.checkNextToken( "]" );
      let nodeList: List<&Ast.Node> = (unwrap expList).$expList;
      foreach exp in nodeList {
         let expType = exp.$expType;
         if itemTypeInfo.equals( Ast.builtinTypeNone ) {
            itemTypeInfo = expType;
         }
         elseif not itemTypeInfo.canEvalWith( expType, "=" ) {
            if expType.equals( Ast.builtinTypeNil ) {
               itemTypeInfo = unwrap itemTypeInfo.$nilableTypeInfo;
            }
            elseif expType.$nilable {
               itemTypeInfo = Ast.builtinTypeStem_;
            }
            else {
               itemTypeInfo = Ast.builtinTypeStem;
            }
         }
      }
   }
   let mut kind = Ast.nodeKindLiteralArray;
   let mut typeInfoList = [ Ast.builtinTypeNone ];
   if token.txt == '[' {
      kind = Ast.nodeKindLiteralList;
      typeInfoList = [ Ast.NormalTypeInfo.createList( .Local, self.getCurrentClass(),
                                                      [ itemTypeInfo ] ) ];
      return Ast.LiteralListNode.create(
         self.nodeManager, token.pos, typeInfoList, expList );
   }
   else {
      typeInfoList = [ Ast.NormalTypeInfo.createArray( .Local, self.getCurrentClass(),
                                                       [ itemTypeInfo ] ) ];
      return Ast.LiteralArrayNode.create(
         self.nodeManager, token.pos, typeInfoList, expList );
   }
   //return self.createNode( kind, token.pos, typeInfo, expList );
}

fn TransUnit.analyzeMapConst( token: &Parser.Token ) mut : Ast.LiteralMapNode {
   let mut nextToken = self.getToken();
   let mut map:Map<&Ast.Node,&Ast.Node> = {};
   let mut pairList:Ast.PairItem[] = [];
   let mut keyTypeInfo = Ast.builtinTypeNone;
   let mut valTypeInfo = Ast.builtinTypeNone;


   fn getMapKeyValType(
      pos: &Parser.Position, keyFlag: bool,
      mut typeInfo:&Ast.TypeInfo, mut expType:&Ast.TypeInfo ): &Ast.TypeInfo
   {
      if expType.$nilable {
         if keyFlag {
            self.addErrMess(
               pos, "map key can't set a nilable -- %s" (expType.getTxt()) );
         }
         if expType.equals( Ast.builtinTypeNil ) {
            return typeInfo;
         }
         expType = unwrap expType.$orgTypeInfo;
      }
      if not typeInfo.canEvalWith( expType, "=" ) {
         if not typeInfo.equals( Ast.builtinTypeNone ) {
            typeInfo = Ast.builtinTypeStem;
         }
         else {
            typeInfo = expType;
         }
      }
      return typeInfo;
   }

   while true {
      if nextToken.txt == "}" {
         break;
      }
      self.pushback();

      let key = self.analyzeExp( false );
      keyTypeInfo = getMapKeyValType( key.$pos, true, keyTypeInfo, key.$expType );

      self.checkNextToken( ":" );

      let val = self.analyzeExp( false );
      valTypeInfo = getMapKeyValType( val.$pos, false, valTypeInfo, val.$expType );

      //pairList.insert( { "key": key, "val": val } );
      pairList.insert( new Ast.PairItem( key, val ) );
      map[ key ] = val;
      nextToken = self.getToken();
      if nextToken.txt ~= "," {
         break;
      }
      nextToken = self.getToken();
   }

   let typeInfo = Ast.NormalTypeInfo.createMap(
      .Local, self.getCurrentClass(), keyTypeInfo, valTypeInfo );

   self.checkToken( nextToken, "}" );
   // return self.createNode( nodeKindLiteralMap, token.pos,[ typeInfo ],
   //                      { "map": map, "pairList": pairList } );
   return Ast.LiteralMapNode.create(
      self.nodeManager, token.pos,[ typeInfo ], map, pairList );
}

fn TransUnit.analyzeExpRefItem(
   token: &Parser.Token, exp: &Ast.Node, mut nilAccess:bool ) mut : Ast.Node {

   let mut expType = exp.$expType;

   if nilAccess {
      if not expType.$nilable {
         nilAccess = false;
      }
      else {
         expType = unwrap expType.$orgTypeInfo;
      }
   }

   let mut expectItemType:&Ast.TypeInfo! = nil;
   let mut typeInfo = Ast.builtinTypeStem_;
   if expType.$kind == .Map {
      let itemTypeList = expType.get_itemTypeInfoList();
      typeInfo = itemTypeList[2];
      expectItemType = itemTypeList[1];
      if not typeInfo.equals( Ast.builtinTypeStem_ ) and not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
   }
   elseif expType.$kind == .Array or
      expType.$kind == .List
   {
      typeInfo = expType.get_itemTypeInfoList()[1];
   }
   elseif expType.equals( Ast.builtinTypeString ) {
      typeInfo = Ast.builtinTypeInt;
   }
   elseif expType.equals( Ast.builtinTypeStem ) {
      typeInfo = Ast.builtinTypeStem;
   }
   else {
      self.addErrMess( exp.$pos,
                       "could not access with []. -- %s" (expType.getTxt()) );
   }

   if nilAccess {
      self.useNilAccess = true;
   }

   if typeInfo.$mutable and not expType.$mutable {
      typeInfo = self.createModifier( typeInfo, false );
   }

   let indexExp = self.analyzeExp( false, nil, expectItemType );
   self.checkNextToken( "]" );
   
   
   return Ast.ExpRefItemNode.create(
      self.nodeManager, token.pos, [ typeInfo ], exp, nilAccess, nil, indexExp );
}


fn TransUnit.checkMatchType(
   mut message:str, pos: &Parser.Position, dstTypeList: &List<&Ast.TypeInfo>,
   expNodeList: &List<&Ast.Node>, allowDstShort:bool ) mut
{
   let mut expTypeList:List<&Ast.TypeInfo> = [];
   foreach expNode, index in expNodeList {
      if index == #expNodeList {
         foreach expType in expNode.$expTypeList {
            expTypeList.insert( expType );
         }
      }
      else {
         expTypeList.insert( expNode.$expType );
      }
   }
   let match, mess = Ast.TypeInfo.checkMatchType( dstTypeList,
                                                  expTypeList, allowDstShort );
   if not match {
      self.addErrMess( pos, "%s: %s" (message, mess ) );
   }
}



fn TransUnit.checkMatchValType(
   pos: &Parser.Position, funcTypeInfo:&Ast.TypeInfo, expList:&Ast.ExpListNode!,
   genericTypeList: &List<&Ast.TypeInfo> ) mut
{
   let mut argTypeList = funcTypeInfo.$argTypeInfoList;
   switch funcTypeInfo {
      case typeInfoListInsert {
         argTypeList = genericTypeList;
      }
      case typeInfoListRemove {
      }
   }

   let mut expNodeList:List<&Ast.Node> = [];

   if! expList {
      foreach node in _exp.$expList {
         expNodeList.insert( node );
      }
   }
   self.checkMatchType( funcTypeInfo.getTxt(), pos, argTypeList, expNodeList, false );
}

class MacroPaser extend Parser.Parser {
   let tokenList: &List<&Parser.Token>;
   let mut pos: int;
   let name: str;

   pub fn __init( tokenList: &List<&Parser.Token>, name: str ) {
      self.pos = 1;
      self.tokenList = tokenList;
      self.name = name;
   }

   pub override fn getToken() mut : &Parser.Token! {
      if #self.tokenList < self.pos {
         return nil;
      }
      let token = self.tokenList[ self.pos ];
      self.pos = self.pos + 1;

      // Util.errorLog( "getToken: %s" (token.txt) );

      return token;
   }
   pub override fn getStreamName(): str {
      return self.name;
   }
}


fn TransUnit.evalMacro(
   firstToken: &Parser.Token,
   macroTypeInfo: &Ast.TypeInfo, expList: &Ast.ExpListNode! ) mut : Ast.ExpMacroExpNode
{

   if! expList {
      if _exp.get_expList() {
         foreach exp in _exp.get_expList() {
            let kind = exp.$kind;
            if kind ~= Ast.nodeKindLiteralNil and
               kind ~= Ast.nodeKindLiteralChar and
               kind ~= Ast.nodeKindLiteralInt and
               kind ~= Ast.nodeKindLiteralReal and
               kind ~= Ast.nodeKindLiteralArray and
               kind ~= Ast.nodeKindLiteralList and
               kind ~= Ast.nodeKindLiteralMap and
               kind ~= Ast.nodeKindLiteralString and
               kind ~= Ast.nodeKindLiteralBool and
               kind ~= Ast.nodeKindLiteralSymbol and
               kind ~= Ast.nodeKindRefField and
               kind ~= Ast.nodeKindExpMacroStat
            {
               self.error( "Macro arguments must be literal value." );
            }
         }
      }
   }

   let macroInfo = unwrap self.typeId2MacroInfo[ macroTypeInfo.get_typeId() ];

   let mut argValMap:Map<int,stem> = {};
   let mut macroArgValMap:Map<str,stem> = {};
   let macroArgNodeList = macroInfo.declInfo.$argList;
   if! expList {
      foreach argNode, index in _exp.get_expList() {
         //let val, typeInfo = getLiteralValue( argNode );
         let valList, typeInfoList = argNode.getLiteral();
         let typeInfo = typeInfoList[1];

         // if type( val ) == "table" {
         //     foreach txt in val@str[] {
         //         if type( txt ) == "table" {
         //             foreach txt2 in txt@str[] {
         //                 Util.errorLog( "hoge: %s" ( txt2 ) );
         //             }
         //         }
         //         else {
         //             Util.errorLog( "hoge: %s" ( txt ) );
         //         }
         //     }
         // }
         // else {
         //         Util.errorLog( "hoge: %s" ( val ) );
         // }
         let! val = valList[1] {}
         then {
            argValMap[ index ] = val;
            let declArgNode = macroArgNodeList[ index ];
            
            macroArgValMap[ declArgNode.$name.txt ] = val;
         };
      }
   }

   let func = macroInfo.func;
   //let macroVars:Map<str,stem!> = func( table.unpack( argVal ) )@@Map<str,stem!>;
   let macroVars:Map<str,stem!> = func( macroArgValMap )@@Map<str,stem!>;

   foreach name in (unwrap macroVars._names)@@str[] {
      let valInfo = unwrap macroInfo.symbol2MacroValInfoMap[ name ];
      let typeInfo = valInfo.typeInfo or Ast.builtinTypeStem_;
      let mut val = macroVars[ name ];
      if typeInfo.equals( Ast.builtinTypeSymbol ) {
         val = [ val ];
      }
      self.symbol2ValueMapForMacro[ name ] = new Ast.MacroValInfo( val, typeInfo );
   }

   //let scope = self.pushScope();


   let argList = macroInfo.declInfo.$argList;
   if argList {
      foreach arg, index in argList {
         if arg.get_kind() == Ast.nodeKindDeclArg {
            let argInfo = arg;
            let argType = argInfo.$argType;
            let argName = argInfo.$name.txt;
            //scope.add( argName, argType.expType );
            self.symbol2ValueMapForMacro[ argName ] =
               new Ast.MacroValInfo( argValMap[ index ], argType.$expType );
         }
         else {
            self.error( "not support ... in macro" );
         }
      }
   }

   // foreach macroValInfo, symbol in self.symbol2ValueMapForMacro {
   //     Util.errorLog( "HOGE: %s %s" (symbol, macroValInfo) );
   // }


   let mut parser = new MacroPaser( macroInfo.$declInfo.$tokenList,
                                "macro %s" (macroTypeInfo.getTxt()) );
   let mut bakParser = self.parser;
   self.parser = parser;


   self.macroMode = .Expand;


   let mut stmtList:List<&Ast.Node> = [];
   self.analyzeStatementList( stmtList, "}" );


   //    self.popScope();

   self.macroMode = .None;
   self.parser = bakParser;


   // return self.createNode(
   //     nodeKindExpMacroExp, firstToken.pos, builtinTypeNone, stmtList );
   return Ast.ExpMacroExpNode.create(
      self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], stmtList );

}

fn TransUnit.analyzeExpCont(
   firstToken: &Parser.Token, mut exp: Ast.Node, skipFlag: bool ) mut : Ast.Node {
      let mut nextToken = self.getToken();

      if not skipFlag {
         repeat {
            let mut matchFlag = false;
            if nextToken.txt == "[" or nextToken.txt == "$[" {
               matchFlag = true;
               exp = self.analyzeExpRefItem( nextToken, exp, nextToken.txt == "$[" );
               nextToken = self.getToken();
            }
            if nextToken.txt == "(" or nextToken.txt == "$(" {
               let mut macroFlag = false;
               let mut funcTypeInfo = exp.$expType;
               let mut nilAccess = nextToken.txt == "$(";

               if nilAccess {
                  if funcTypeInfo.$nilable {
                     funcTypeInfo = funcTypeInfo.$orgTypeInfo;
                  }
                  else {
                     nilAccess = false;
                  }
               }

               if funcTypeInfo.get_kind() == .Macro {
                  macroFlag = true;
                  self.symbol2ValueMapForMacro = {};
                  self.macroMode = .Analyze;
               }

               matchFlag = true;
               let work = self.getToken();
               let mut expList: Ast.ExpListNode! = nil;
               if work.txt ~= ")" {
                  self.pushback();
                  expList = self.analyzeExpList(
                     false, nil, funcTypeInfo.$argTypeInfoList );
                  self.checkNextToken( ")" );
               }

               // 引数の型チェック
               let mut genericTypeList = funcTypeInfo.$itemTypeInfoList;
               if funcTypeInfo.$kind == .Method and
                  exp.$kind == Ast.nodeKindRefField
               {
                  let refField = exp@@Ast.RefFieldNode;
                  let classType = refField.$prefix.$expType;
                  genericTypeList = classType.$itemTypeInfoList;
               }

               self.checkMatchValType(
                  exp.$pos, funcTypeInfo, expList, genericTypeList );

               if funcTypeInfo.equals( typeInfoListInsert ) {
                  if! expList {
                     if _exp.$expType.$nilable {
                        self.addErrMess( _exp.$pos, "list can't insert nilable" );
                     }
                  }
               }

               if macroFlag {
                  self.macroMode = .None;
                  exp = self.evalMacro( firstToken, funcTypeInfo, expList );
               }
               else {
                  switch( funcTypeInfo.$kind ) {
                     case .Method, .Func {
                     }
                     default {
                        self.error( "can't call the type -- %s, %s"
                                    ( funcTypeInfo.getTxt(),
                                      funcTypeInfo.$kind.$_txt ) );
                     }
                  }
                  let mut retTypeInfoList:&List<&Ast.TypeInfo> =
                      funcTypeInfo.get_retTypeInfoList();
                  if nilAccess {
                     let mut retList:List<&Ast.TypeInfo> = [];
                     foreach retType in funcTypeInfo.get_retTypeInfoList() {
                        if retType.$nilable {
                           retList.insert( retType );
                        }
                        else {
                           retList.insert( retType.$nilableTypeInfo );
                        }
                     }
                     retTypeInfoList = retList;
                     self.useNilAccess = true;
                  }
                  exp = Ast.ExpCallNode.create(
                     self.nodeManager, firstToken.pos,
                     retTypeInfoList, exp, nilAccess, expList );
               }

               nextToken = self.getToken();
            }
         } not matchFlag;
      }

      switch nextToken.txt {
         case "." {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(), .Field, exp, skipFlag );
         }
         case "$." {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(), .FieldNil, exp, skipFlag );
         }
         case ".$" {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(), .Get, exp, skipFlag );
         }
         case "$.$" {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(), .GetNil, exp, skipFlag );
         }
      }

      self.pushback();
      return exp;

   }


fn TransUnit.analyzeAccessClassField(
   mut classTypeInfo: &Ast.TypeInfo, mode:ExpSymbolMode, token:&Parser.Token ) mut :
   &Ast.TypeInfo, &Ast.SymbolInfo!, bool
{
   if classTypeInfo.get_kind() == .List {
      classTypeInfo = Ast.builtinTypeList;
   }
   let className = classTypeInfo.getTxt();
   let! classScope = classTypeInfo.$scope {
      self.error( "not found field: %s, %s, %s"
                  ( classScope, className, classTypeInfo ) );
   };
   
   let mut symbolInfo:Ast.SymbolInfo! = nil;
   let mut fieldTypeInfo:Ast.TypeInfo! = nil;
   let mut getterFlag = false;
   if mode == .Get or mode == .GetNil {
      let fieldSymbolInfo = classScope.getSymbolInfo(
         "get_%s" (token.txt), self.scope, false );
      if! fieldSymbolInfo {
         if ( _exp.get_kind() == .Mtd )
         {
            let retTypeList = _exp.$typeInfo.get_retTypeInfoList();
            symbolInfo = _exp;
            if #retTypeList > 0 {
               fieldTypeInfo = retTypeList[ 1 ];
            }
            getterFlag = true;
         }
      }
   }
   if not symbolInfo {
      // fieldSymbolInfo = classScope.getTypeInfo(
      //     token.txt, self.scope, false );
      // fieldTypeInfo = classScope.getTypeInfoField(
      //    token.txt, true, self.scope );
      symbolInfo = classScope.getSymbolInfoField(
         token.txt, true, self.scope );
      if! symbolInfo {
         fieldTypeInfo = _exp.$typeInfo;
      }
   }
   if not fieldTypeInfo {
      foreach val, name in classScope.$symbol2TypeInfoMap {
         Util.log( "debug: %s, %s" ( name, val ) );
      }
      self.error( "not found field typeInfo: %s.%s"
                  ( className, token.txt ) );
   }
   let typeInfo = unwrap fieldTypeInfo default Ast.builtinTypeNone;
   return typeInfo, symbolInfo, getterFlag;
}

fn TransUnit.dumpComp(
   writer: Writer.Writer, pattern: str,
   symbolInfo: Ast.SymbolInfo, getterFlag:bool ): bool
{
   let symbol = symbolInfo.$name;
   if pattern == "" or symbol.find( pattern ) {
      if getterFlag {
         writer.startParent( "candidate", false );
         let typeInfo = symbolInfo.$typeInfo;
         writer.write( "type", "%s" ( symbolInfo.$kind.$_txt ) );
         switch ( symbolInfo.$kind ) {
            case .Mtd {
               writer.write( "displayTxt", "$%s"
                             ( typeInfo.$rawTxt.gsub( "^get_", "") ) );
            }  
            case .Mbr {
               writer.write( "displayTxt", "$%s: %s"
                             ( symbolInfo.$name, typeInfo.getTxt() ) );
            }  
         }
      }
      else {
         writer.startParent( "candidate", false );
         let typeInfo = symbolInfo.$typeInfo;
         writer.write( "type", "%s" ( symbolInfo.$kind.$_txt ) );
         switch ( symbolInfo.$kind ) {
            case .Fun, .Mtd {
               writer.write( "displayTxt", "%s" ( typeInfo.$display_stirng ) );
            }  
            case .Mbr, .Var {
               writer.write( "displayTxt", "%s: %s"
                             ( symbolInfo.$name, typeInfo.$display_stirng ) );
            }  
            case .Typ {
               writer.write( "displayTxt", "%s"
                             ( typeInfo.$display_stirng ) );
            }  
         }
      }
      writer.endElement();
   }
   return true;
}

fn TransUnit.dumpFieldComp(
   writer: Writer.Writer, isPrefixType: bool,
   prefixTypeInfo: &Ast.TypeInfo, pattern: str, getterPattern: str! )
{
   let typeInfo = prefixTypeInfo;
   let! scope = typeInfo.$scope {
      return;
   };

   scope.filterTypeInfoField(
      true, self.scope,
      fn ( symbolInfo: Ast.SymbolInfo ) : bool {
         if ( isPrefixType ) {
            if not symbolInfo.$staticFlag and
               not symbolInfo.$typeInfo.$staticFlag and
               symbolInfo.$kind ~= .Typ
            {
               // 型のフィールド補完は 非 static を除外
               return true;
            }
         }
         elseif symbolInfo.$staticFlag {
            // インスタンスのフィールド補完は static を除外
            return true;
         }
         let symbol = symbolInfo.$name;
         if symbol ~= "__init" and symbol ~= "__free" and
            symbol ~= "self"
         {
            if! getterPattern {
               if symbolInfo.$kind == .Mtd {
                  let typeInfo = symbolInfo.$typeInfo;
                  let retList = typeInfo.$retTypeInfoList;
                  if #retList == 1 {
                     return self.dumpComp( writer, _exp, symbolInfo, true );
                  }
               }
               return true;
            }
            return self.dumpComp(writer, pattern, symbolInfo, false );
         }
         return true;
      });
}

fn TransUnit.dumpSymbolComp( writer: Writer.Writer, scope: &Ast.Scope, pattern: str ) {
   scope.filterSymbolTypeInfo(
      scope, self.moduleScope,
      fn ( symbolInfo: Ast.SymbolInfo ) : bool {
         return self.dumpComp(writer, pattern, symbolInfo, false );
      });    
}

fn TransUnit.checkComp( token:&Parser.Token, callback:form ) 
{
   if self.analyzeMode == .Complete and
      self.analyzePos.lineNo == token.pos.lineNo and
      self.analyzePos.column >= token.pos.column and
      self.analyzePos.column <= token.pos.column + #token.txt 
   {
      let mut currentModule = self.parser.getStreamName().gsub( "%.lns", "" );
      currentModule = currentModule.gsub( ".*/", "" );
      let target = self.analyzeModule.gsub( "[^%.]+%.", "" );
      if currentModule == target {
         let mut jsonWriter = new Writer.JSON( io.stdout );
         jsonWriter.startParent( "lunescript", false );
         let prefix = token.txt.gsub( "lune$", "" );
         jsonWriter.write( "prefix", prefix );
         jsonWriter.startParent( "candidateList", true );

         callback( jsonWriter, prefix );

         jsonWriter.endElement();
         jsonWriter.endElement();
         jsonWriter.fin();
         os.exit( 0 );
      }
   }
}


fn TransUnit.checkFieldComp(
   getterFlag:bool, token:&Parser.Token, prefixExp: &Ast.Node ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   let prefixSymbolInfoList = prefixExp.getSymbolInfo();
   let mut prefixSymbolInfo:Ast.SymbolInfo! = nil;
   if #prefixSymbolInfoList == 1 {
      prefixSymbolInfo = prefixSymbolInfoList[ 1 ];
   }
   
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         let mut getterPattern:str! = nil;
         if getterFlag {
            getterPattern = "^get_" .. prefix;
         }
         let mut isPrefixType = false;
         if! prefixSymbolInfo {
            isPrefixType = _exp.$kind == .Typ;
         }     
         self.dumpFieldComp(
            jsonWriter, isPrefixType, prefixExp.$expType,
            prefix == "" and "" or "^" .. prefix, getterPattern );
      }
   );
}

fn TransUnit.checkEnumComp(
   token:&Parser.Token, enumTypeInfo: &Ast.EnumTypeInfo ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         self.dumpFieldComp(
            jsonWriter, true, enumTypeInfo,
            prefix == "" and "" or "^" .. prefix, nil );
      }
   );
}


fn TransUnit.checkSymbolComp( token:&Parser.Token ) 
{
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         self.dumpSymbolComp( jsonWriter, self.scope,
                              prefix == "" and "" or "^" .. prefix );
      }
   );
}

fn TransUnit.analyzeExpField(
   firstToken: &Parser.Token, token: &Parser.Token,
   mode: ExpSymbolMode, prefixExp: &Ast.Node ) mut : Ast.Node
{
   let mut accessNil = false;
   if mode == .FieldNil or mode == .GetNil {
      accessNil = true;
   }
   if self.macroMode == .Analyze {
      if accessNil {
         self.useNilAccess = true;
      }
      return Ast.RefFieldNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeSymbol ],
         token, nil, accessNil, unwrap prefixExp );
         //token, accessNil, unwrap prefixExp );
   }

   let mut typeInfo:&Ast.TypeInfo = Ast.builtinTypeStem_;
   let mut prefixExpType = prefixExp.$expType;

   self.checkFieldComp(
      mode == .Get or mode == .GetNil, token, prefixExp );
   
   if accessNil {
      if prefixExpType.$nilable {
         // nil 条件演算で、 prefixExpType が nilable ならば、
         // prefixExpType を非 nilable にセットする
         prefixExpType = unwrap prefixExpType.$orgTypeInfo;
      }
      else {
         // prefixExpType が nilable でなければ、
         // nil 判定は不要なので accessNil をクリアする
         accessNil = false;
      }
   }
   if accessNil {
      self.useNilAccess = true;
   }

   let mut getterTypeInfo:Ast.TypeInfo! = nil;
   let mut symbolInfo:Ast.SymbolInfo! = nil;
   if prefixExpType.get_kind() == .Class or
      prefixExpType.get_kind() == .Module or
      prefixExpType.get_kind() == .IF or
      prefixExpType.get_kind() == .List
   {
      let mut getterFlag = false;
      typeInfo, symbolInfo, getterFlag =
         self.analyzeAccessClassField( prefixExpType, mode, token );
      if getterFlag {
         if! symbolInfo {
            getterTypeInfo = _exp.$typeInfo;
         }
      }
   }
   elseif prefixExpType.get_kind() == .Enum {
      let scope = unwrap prefixExpType.$scope;
      let mut fieldName = token.txt;
      if mode == .Get {
         let moduleType = prefixExpType.getModule();
         if not moduleType.equals( self.moduleType ) and
            not self.importModule2ModuleInfoCurrent[ moduleType ] {
            // enum の名前を取得するには、そのモジュールのインポートが必要
            self.addErrMess( token.pos, "need to import module -- %s"
                             ( prefixExpType.getModule().getTxt() ) );
         }
         fieldName = "get_" .. fieldName;
         getterTypeInfo = Ast.headTypeInfo;
         typeInfo = Ast.builtinTypeString;
      }
      else {
         if! scope.getTypeInfoChild( fieldName ) {
            typeInfo = _exp;
         }  
         else {
            self.addErrMess( token.pos,
                             "not found enum field -- %s" (token.txt));
            typeInfo = Ast.builtinTypeInt;
         }
      }
   }
   elseif prefixExpType.get_kind() == .Map {
      let work = prefixExpType.$itemTypeInfoList[1];
      if not work.equals( Ast.builtinTypeString ) {
         self.addErrMess(
            token.pos,
            "map key type is not str. (%s)" (work.getTxt()) );
      }
      typeInfo = prefixExpType.$itemTypeInfoList[2];
      if not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
      return Ast.ExpRefItemNode.create(
         self.nodeManager, token.pos,
         [ typeInfo ], prefixExp, accessNil, token.txt, nil );
   }
   elseif prefixExpType.equals( Ast.builtinTypeStem ) {
      return Ast.ExpRefItemNode.create(
         self.nodeManager, token.pos,
         [ Ast.builtinTypeStem_ ], prefixExp, accessNil, token.txt, nil );
   }
   else {
      self.error( "illegal type -- %s, %d"
                  ( prefixExpType.getTxt(),
                    prefixExpType.get_kind() ) );
   }

   if not symbolInfo {
      let prefixScope = prefixExpType.$scope;
      if! prefixScope {
         symbolInfo = _exp.getSymbolInfoField( token.txt, true, self.scope );
      }
   }
   let prefixSymbolInfoList = prefixExp.getSymbolInfo();
   
   if! symbolInfo {
      if #prefixSymbolInfoList == 1 {
         let prefixSymbolInfo = prefixSymbolInfoList[1];
         if prefixSymbolInfo.$kind == .Typ {
            if not _exp.$staticFlag and _exp.$kind ~= .Typ
            {
               // クラスシンボルから、 static でないメンバにアクセスした場合エラー
               self.addErrMess(
                  token.pos, "Type can't access this symbol. -- %s" (_exp.$name) );    
            }
         }
         elseif _exp.$staticFlag and _exp.$typeInfo.$kind ~= .Method {
            // インスタンスから、 static メンバにアクセスした場合エラー
            self.addErrMess(
               token.pos, "can't access this symbol. -- %s" (token.txt) );
         }
      };

      if not prefixExpType.$mutable and not _exp.$staticFlag and
         _exp.$kind == .Mtd and _exp.$mutable 
      {  
         // オブジェクトが immutable で、
         // mutable な method へのアクセスはエラー
         self.addErrMess(
            token.pos, "can't access mutable method. -- %s" (token.txt) );
      }  
   }

   if accessNil {
      if not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
      self.useNilAccess = true;
   }

   let mut accessSymbolInfo:Ast.AccessSymbolInfo! = nil;
   //let mut canBeLeft:bool! = nil;
   if! symbolInfo {
      //canBeLeft = _exp.canBeLeft();
      accessSymbolInfo = new Ast.AccessSymbolInfo( _exp, prefixExpType, not accessNil );
   };
   if not prefixExpType.$mutable and typeInfo.$mutable
   {           
      typeInfo = self.createModifier( typeInfo, false );
   }
   
   if! getterTypeInfo {
      return Ast.GetFieldNode.create(
         self.nodeManager, firstToken.pos, [ typeInfo ],
         token, accessSymbolInfo, accessNil, prefixExp, _exp );
         //token, canBeLeft, accessNil, prefixExp, _exp );
   }
   else {
      return Ast.RefFieldNode.create(
         self.nodeManager, firstToken.pos, [ typeInfo ],
         token, accessSymbolInfo, accessNil, prefixExp );
         //token, canBeLeft, accessNil, prefixExp );
   }
}

fn TransUnit.analyzeExpSymbol(
   firstToken: &Parser.Token, token: &Parser.Token,
   mode: ExpSymbolMode, prefixExp: &Ast.Node!, mut skipFlag: bool ) mut : Ast.Node
{
   let mut exp:Ast.Node! = nil;
   
   if mode == .Field or mode == .Get or
      mode == .FieldNil or mode == .GetNil
   {
      exp = self.analyzeExpField( firstToken, token, mode, unwrap prefixExp );
   }
   elseif mode == .Symbol {
      if self.macroMode == .Analyze {
         exp = Ast.LiteralSymbolNode.create(
            self.nodeManager, firstToken.pos, [ Ast.builtinTypeSymbol ], token );
      }
      else {
         self.checkSymbolComp( token );

         let! symbolInfo = self.scope.getSymbolTypeInfo(
            token.txt, self.scope, self.moduleScope )
         {  
            self.error( "not found type -- " .. token.txt );
         }; 
         let typeInfo = symbolInfo.$typeInfo;
         if typeInfo.equals( Ast.builtinTypeSymbol ) {
            skipFlag = true;
         }
         if token.txt == "__func__" {
            self.has__func__Symbol = true;
         }
         
         exp = Ast.ExpRefNode.create(
            self.nodeManager, firstToken.pos, [ typeInfo ], token,
            new Ast.AccessSymbolInfo( symbolInfo, nil, true ) );
      }
   }
   elseif mode == .Fn {
      exp = self.analyzeDeclFunc(
         .Func, false, false, .Local, false, nil, token, nil );
   }
   else {
      self.error( "illegal mode -- %s" ( mode ) );
   }

   return self.analyzeExpCont( firstToken, unwrap exp, skipFlag );
}

fn TransUnit.analyzeExpOpSet(
   exp: &Ast.Node, opeToken: &Parser.Token, exp2NodeList:List<&Ast.Node> ) mut
{
   if not exp.canBeLeft() {
      self.addErrMess( exp.$pos,
                       "this node can not be l-value. -- %s"
                       (Ast.getNodeKindName( exp.$kind ) ) );
   }
   self.checkMatchType(
      "= operator", opeToken.pos, exp.$expTypeList, exp2NodeList, true );

   foreach symbolInfo in exp.getSymbolInfo() {
      if not symbolInfo.$mutable and symbolInfo.$hasValueFlag
      {
         if self.validMutControl {
            self.addErrMess( opeToken.$pos,
                             "this is not mutable variable. -- %s"
                             ( symbolInfo.$name ) );
         }
      }
      symbolInfo.set_hasValueFlag( true );
   }
}

fn TransUnit.analyzeExpOp2(
   firstToken: &Parser.Token, mut exp: Ast.Node, prevOpLevel: int! ) mut : Ast.Node
{
   while true {
      let nextToken = self.getToken();
      let opTxt = nextToken.txt;

      if opTxt == "@@" {
         let castTypeNode = self.analyzeRefType( .Local, false );
         let mut castType = castTypeNode.$expType;

         let expType = exp.$expType;
         
         if expType.$nilable and not castType.$nilable {
            self.addErrMess( firstToken.pos,
                             "can't cast from nilable to not nilable  -- %s->%s"
                             (expType.getTxt(), castType.getTxt()) );
         }
         elseif not expType.$mutable and castType.$mutable {
            castType = self.createModifier( castType, false );
         }

         if castType.canEvalWith( expType, "=" ) {
            // "str"@@str のように、意味のないキャストはエラー
            self.addWarnMess( castTypeNode.$pos,
                              "This cast doesn't need. (%s <- %s)"
                              ( castType.getTxt(), expType.getTxt() ) );
         }
         elseif not expType.canEvalWith( castType, "=" ) {
            if not Ast.isNumberType( expType ) and not Ast.isNumberType( castType ) {
               // キャスト先の型からキャスト元の型へ互換性がない場合はエラー
               self.addErrMess( castTypeNode.$pos,
                                "This type can't cast. (%s <- %s)"
                                ( castType.getTxt(), expType.getTxt() ) );
            }
         }
         
         exp = Ast.ExpCastNode.create(
            self.nodeManager, firstToken.pos, [ castType ], exp );
      }
      elseif nextToken.kind == Parser.TokenKind.Ope {
         if Parser.isOp2( opTxt ) {
            let! opLevel = op2levelMap[ opTxt ] {
               self.error( "unknown op -- %s %s" (opTxt, prevOpLevel ) );
            };
            if! prevOpLevel {
               if opLevel <= _exp {
                  self.pushback();
                  return exp;
               }
            }

            let mut enumTypeInfo:&Ast.EnumTypeInfo! = nil;
            {
               let mut prefixExpType = exp.$expType;
               if prefixExpType.$nilable {
                  prefixExpType = prefixExpType.$orgTypeInfo;
               }  
               if prefixExpType.$kind == .Enum {
                  enumTypeInfo = prefixExpType.$srcTypeInfo@@Ast.EnumTypeInfo;
               }
            }
            
            let mut exp2:&Ast.Node = self.analyzeExp( false, opLevel, enumTypeInfo );
            let mut exp2NodeList = [ exp2 ];
            if opTxt == "=" {
               let workToken = self.getToken();
               if workToken.txt == "," {
                  let mut expListNode = self.analyzeExpList( false, exp2 );
                  exp2 = expListNode;
                  exp2NodeList = expListNode.$expList;
               }
               else {
                  self.pushback();
               }
            }
            let info = { "op": nextToken, "exp1": exp, "exp2": exp2 };

            let mut retType = Ast.builtinTypeNone;

            if not exp2.canBeRight() {
               self.addErrMess( exp2.$pos,
                                "this node can not be r-value. -- %s"
                                (Ast.getNodeKindName( exp2.$kind ) ) );
            }
            
            let exp1Type = exp.$expType;
            let exp2Type = exp2.$expType;

            switch opTxt {
               case "or" {
                  if exp1Type.equals( exp2Type ) {
                     retType = exp1Type;
                  }
                  elseif exp1Type.canEvalWith( exp2Type, "=") {
                     retType = exp1Type;
                  }
                  elseif exp2Type.canEvalWith( exp1Type, "=") {
                     retType = exp2Type;
                  }
                  elseif exp2Type.equals( Ast.builtinTypeNil ) {
                     retType = exp1Type;
                  }
                  elseif exp1Type.equals( Ast.builtinTypeNil ) {
                     retType = exp2Type;
                  }
                  else {
                     if exp1Type.$nilable or exp2Type.$nilable {
                        retType = Ast.builtinTypeStem_;
                     }
                     else {
                        retType = Ast.builtinTypeStem;
                     }
                  }
               }
               case "and" {
                  let workToken = self.getToken();
                  self.pushback();

                  if not exp1Type.equals( Ast.builtinTypeBool ) and
                     not exp1Type.equals( Ast.builtinTypeStem ) and
                     not exp1Type.$nilable
                  {  
                     self.addWarnMess( exp.$pos, "this value never be 'false'" );
                  }
                  elseif exp2.$kind == Ast.nodeKindLiteralBool {
                     let valList = exp2.getLiteral();
                     if not valList[1] {
                        self.addErrMess( exp2.$pos, "this value never be 'true'" );
                     }
                  }
                  
                  if workToken.txt == "or" {
                     // A and B or C の場合、 A and B の演算結果は B の型とし、
                     // B or C の演算結果に処理を廻す。
                     retType = exp2Type;
                  }
                  else {
                     if exp1Type.$nilable {
                        if exp2Type.$nilable {
                           retType = exp2Type;
                        }  
                        else {
                           retType = exp2Type.$nilableTypeInfo;
                        }
                     }
                     elseif exp1Type.equals( Ast.builtinTypeBool ) or
                        exp2Type.equals( Ast.builtinTypeBool )
                     {
                        if exp1Type.canEvalWith( exp2Type, "=" ) {
                           retType = exp1Type;
                        }
                        elseif exp2Type.canEvalWith( exp1Type, "=" ) {
                           retType = exp2Type;
                        }  
                        else {
                           if exp2Type.$nilable {
                              retType = Ast.builtinTypeStem_;
                           }  
                           else {
                              retType = Ast.builtinTypeStem;
                           }  
                        }  
                     }
                     else {
                        retType = exp2Type;
                     }
                  }
               }
               case "<", ">", "<=", ">=" {
                  if ( not Ast.builtinTypeInt.canEvalWith( exp1Type, opTxt ) and
                       not Ast.builtinTypeReal.canEvalWith( exp1Type, opTxt ) ) or
                      ( not Ast.builtinTypeInt.canEvalWith( exp2Type, opTxt ) and
                        not Ast.builtinTypeReal.canEvalWith( exp2Type, opTxt ) )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no numeric type %s or %s"
                        ( exp1Type.getTxt(), exp2Type.getTxt() ) );
                  }
                  retType = Ast.builtinTypeBool;
               }
               case "~=", "==" {
                  if ( not exp1Type.canEvalWith( exp2Type, opTxt ) and
                       not exp2Type.canEvalWith( exp1Type, opTxt ) )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "not compatible type %s or %s" ( exp1Type.getTxt(),
                                                         exp2Type.getTxt() ) );
                  }
                  retType = Ast.builtinTypeBool;
               }
               case "^", "|", "~", "&", "|<<", "|>>" {
                  if not Ast.builtinTypeInt.canEvalWith( exp1Type, opTxt ) or
                     not Ast.builtinTypeInt.canEvalWith( exp2Type, opTxt )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no int type %s or %s" ( exp1Type.getTxt(),
                                                 exp2Type.getTxt() ) );
                  }
                  retType = Ast.builtinTypeInt;
               }
               case ".." {
                  if not exp1Type.equals( Ast.builtinTypeString ) or
                     not exp1Type.equals( Ast.builtinTypeString )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no string type %s or %s" ( exp1Type.getTxt(),
                                                    exp2Type.getTxt() ) );
                  }
                  retType = Ast.builtinTypeString;
               }
               case "+", "-", "*", "/", "%" {
                  if ( not Ast.builtinTypeInt.canEvalWith( exp1Type, opTxt ) and
                       not Ast.builtinTypeReal.canEvalWith( exp1Type, opTxt ) ) or
                      ( not Ast.builtinTypeInt.canEvalWith( exp2Type, opTxt ) and
                        not Ast.builtinTypeReal.canEvalWith( exp2Type, opTxt) )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no numeric type %s or %s" ( exp1Type.getTxt(),
                                                     exp2Type.getTxt() ) );
                  }

                  if exp1Type.equals( Ast.builtinTypeReal ) or
                     exp2Type.equals( Ast.builtinTypeReal )
                  {
                     retType = Ast.builtinTypeReal;
                  }
                  else {
                     retType = Ast.builtinTypeInt;
                  }
               }
               case "=" {
                  self.analyzeExpOpSet( exp, nextToken, exp2NodeList );
               }
               default {
                  self.error( "unknown op " .. opTxt );
               }
            }

            exp = Ast.ExpOp2Node.create(
               self.nodeManager, firstToken.pos, [ retType ], nextToken, exp, exp2 );
         }
         else {
            self.error( "illegal op" );
         }
      }
      else {
         self.pushback();
         return exp;
      }
   }
   return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}

fn TransUnit.analyzeExpMacroStat( firstToken: &Parser.Token ) mut : Ast.ExpMacroStatNode {
   let mut expStrList: List<&Ast.Node> = [];

   self.checkNextToken( "{" );

   let mut braceCount = 0;
   let mut prevToken = firstToken;
   while true {
      let token = self.getToken();

      if token.txt == ",," or token.txt == ",,," or token.txt == ",,,," {
         let exp = self.analyzeExp( true, unwrap op1levelMap[ token.txt ] );

         let nextToken = self.getToken();
         if nextToken.txt ~= "~~" {
            self.pushback();
         }


         let mut format = token.txt == ",,," and "'%s '" or '"\'%s\'"';

         if token.txt == ",," and exp.$kind == Ast.nodeKindExpRef
         {
            let refToken = (exp@@Ast.ExpRefNode).get_token();
            let macroInfo = self.symbol2ValueMapForMacro[ refToken.txt ];
            if macroInfo {
               if (unwrap macroInfo).typeInfo.equals( Ast.builtinTypeSymbol ) {
                  format = "'%s '";
               }
            }
            else {
               if exp.$expType.equals( Ast.builtinTypeInt ) or
                  exp.$expType.equals( Ast.builtinTypeReal )
               {
                  format = "'%s' ";
               }
            }
         }
         let newToken = new Parser.Token( Parser.TokenKind.Str, format, token.pos );
         let literalStr = Ast.LiteralStringNode.create(
            self.nodeManager, token.pos, [ Ast.builtinTypeString ], newToken, [ exp ] );
         expStrList.insert(  literalStr );
      }
      else {
         if token.txt == "{" {
            braceCount = braceCount + 1;
         }
         elseif token.txt == "}" {
            if braceCount == 0 {
               break;
            }
            braceCount = braceCount - 1;
         }

         let mut format = "' %s '";
         if prevToken == firstToken or
            (prevToken.pos.lineNo == token.pos.lineNo and
              prevToken.pos.column + #prevToken.txt == token.pos.column)
         {
            format = "'%s'";
         }
         let newToken = new Parser.Token(
            token.kind, string.format( format, token.txt ), token.pos );
         let literalStr = Ast.LiteralStringNode.create(
            self.nodeManager, token.pos, [ Ast.builtinTypeString ], newToken, [] );
         expStrList.insert( literalStr );
      }
      prevToken = token;
   }

   return Ast.ExpMacroStatNode.create(
      self.nodeManager, firstToken.pos, [ Ast.builtinTypeStat ], expStrList );
}


fn TransUnit.analyzeSuper( firstToken:&Parser.Token ) mut : Ast.Node {

   self.checkNextToken( "(" );

   let nextToken = self.getToken();
   let mut expList:Ast.ExpListNode! = nil;
   if nextToken.txt ~= ")" {
      self.pushback();
      expList = self.analyzeExpList( false );
      self.checkNextToken( ")" );
   }

   self.checkNextToken( ";" );

   let classType = self.getCurrentClass();
   let superType = classType.get_baseTypeInfo();
   if superType.equals( Ast.headTypeInfo ) {
      self.addErrMess( firstToken.pos, "This class doesn't have super-class." );
   }
   else {
      let! superScope = superType.$scope {
         self.error( "not found super scope" );
      };
      let! superCtorType = superScope.getTypeInfoChild( "__init" ) {
         self.error( "not found super '__init'" );
      };        
      self.checkMatchValType( firstToken.$pos, superCtorType, expList, [] );
   }

   return Ast.ExpCallSuperNode.create(
      self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], superType, expList );
}

fn TransUnit.analyzeUnwrap( firstToken: &Parser.Token ) mut : Ast.Node {
   let nextToken, continueFlag = self.getContinueToken();

   if not continueFlag or nextToken.txt ~= "!" {
      self.pushback();
      self.pushbackToken( firstToken );
      let exp = self.analyzeExp( false );
      self.checkNextToken( ";" );
      if not exp.$expType.$nilable {
         self.addErrMess( exp.$pos, "this value is not nilable." );
      }
      return Ast.StmtExpNode.create(
         self.nodeManager, nextToken.pos, [ Ast.builtinTypeNone ], exp );
   }

   self.pushback();
   return self.analyzeDeclVar( .Unwrap, .Local, firstToken );
}

fn TransUnit.analyzeExpUnwrap( firstToken: &Parser.Token ) mut : Ast.Node {
   let expNode = self.analyzeExp( true );
   let nextToken = self.getToken();
   let mut insNode: Ast.Node! = nil;
   if nextToken.txt == "default" {
      insNode = self.analyzeExp( false );
   }
   else {
      self.pushback();
   }

   let mut unwrapType = Ast.builtinTypeStem_;

   let expType = expNode.$expType;
   if not expType.$nilable {
      unwrapType = expType;
   }
   else {
      unwrapType = unwrap expType.$orgTypeInfo;
      if! insNode {
         let insType = _exp.$expType;
         unwrapType = insType;

         if not unwrapType.canEvalWith( insType, "=" ) {
            self.addErrMess(
               _exp.$pos,
               "unmatch type: %s <- %s" ( unwrapType.getTxt(), insType.getTxt() ) );
         }
      }
   }

   self.useUnwrapExp = true;

   return Ast.ExpUnwrapNode.create(
      self.nodeManager, firstToken.pos, [ unwrapType ], expNode, insNode );
}


fn TransUnit.analyzeExp(
   skipOp2Flag: bool, prevOpLevel: int!, expectType:&Ast.TypeInfo! ) mut : Ast.Node
{
   let firstToken = self.getToken();
   let mut token = firstToken;
   let mut exp:Ast.Node = self.createNoneNode( firstToken.pos );

   if token.kind == Parser.TokenKind.Dlmt {
      if token.txt == "." {
         if! expectType {
            let mut orgExpectType = _exp;
            if orgExpectType.$nilable {
               orgExpectType = orgExpectType.$orgTypeInfo;
            }
            if orgExpectType.$kind == .Enum {
               let enumTyepInfo = orgExpectType.$srcTypeInfo@@Ast.EnumTypeInfo;
               let nextToken = self.getToken();
               self.checkEnumComp( nextToken, enumTyepInfo );
               
               if enumTyepInfo.getEnumValInfo( nextToken.txt ) {
                  if orgExpectType.$externalFlag and
                     not self.importModule2ModuleInfoCurrent[
                        orgExpectType.getModule().$srcTypeInfo ]
                  {
                     let fullname = orgExpectType.getFullName(
                        self.importModule2ModuleInfo, true );
                     self.addErrMess( token.pos, "This module not import -- %s"
                                      ( fullname ) );
                  }
                  exp = Ast.ExpOmitEnumNode.create(
                     self.nodeManager, token.pos, [ enumTyepInfo ],
                     nextToken, enumTyepInfo );
                  exp = self.analyzeExpCont( firstToken, exp, false );
               }
               else {
                  self.error( "illegal enum val -- %s.%s"
                              (orgExpectType.getTxt(), nextToken.txt) );
               }
            }
            else {
               self.error( "illegal type for '.' -- %s" (orgExpectType.getTxt() ) );
            }
         }
         else {
            self.error( "illegal '.'" );
         }
      }
      elseif token.txt == "..." {
         return Ast.ExpDDDNode.create(
            self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], token );
      }
      elseif token.txt == '[' or token.txt == '[@' {
         exp = self.analyzeListConst( token );
      }
      elseif token.txt == '{' {
         exp = self.analyzeMapConst( token );
      }
      elseif token.txt == "(" {
         exp = self.analyzeExp( false );
         self.checkNextToken( ")" );
         exp = Ast.ExpParenNode.create(
            self.nodeManager, firstToken.pos, exp.$expTypeList, exp );
         exp = self.analyzeExpCont( firstToken, exp, false );
      }
   }

   if token.txt == "new" {
      exp = self.analyzeRefType( .Local, false );

      let classTypeInfo = exp.$expType;
      if classTypeInfo.$externalFlag {
         switch classTypeInfo.$accessMode {
            case .Pri, .Local {
               self.addErrMess( token.pos, "Can't access -- %s"
                                (classTypeInfo.$accessMode.$_txt ) ); 
            }
         }
      }
      if classTypeInfo.$abstructFlag {
         self.addErrMess( token.pos, "abstruct class can't new" );
      }
      
      let classScope = classTypeInfo.get_scope();
      let! initTypeInfo = (unwrap classScope).getTypeInfoChild( "__init" ) {
         self.error( "not found __init" );
      };
      
      self.checkNextToken( "(" );
      let nextToken = self.getToken();
      let mut argList: Ast.ExpListNode! = nil;
      
      if nextToken.txt ~= ")" {
         self.pushback();
         argList = self.analyzeExpList( false, nil, initTypeInfo.$argTypeInfoList );
         self.checkNextToken( ")" );
      }

      // 引数チェック
      //let classScope = self.typeId2Scope[ classTypeInfo.get_typeId() ];

      if initTypeInfo.$accessMode == .Pub or
          ( initTypeInfo.$accessMode == .Pro and
            self.scope.getClassTypeInfo().isInheritFrom( classTypeInfo ) ) or
          ( self.scope.getClassTypeInfo() == classTypeInfo )
      {
         // pub、 pro でサブクラス、 pri で同じクラスの場合はアクセス可能
      }
      else {
         self.addErrMess(
            token.pos,
            "can't access to __init of %s" (classTypeInfo.getTxt()));
      }

      self.checkMatchValType( exp.$pos, initTypeInfo, argList,
                              exp.$expType.$itemTypeInfoList );
      
      exp = Ast.ExpNewNode.create(
         self.nodeManager, firstToken.pos, exp.$expTypeList, exp, argList );
      exp = self.analyzeExpCont( firstToken, exp, false );
   }

   if token.kind == Parser.TokenKind.Ope and Parser.isOp1( token.txt ) {
      // 単項演算
      if token.txt == "`" {
         exp = self.analyzeExpMacroStat( token );
      }
      else {
         exp = self.analyzeExp( true, unwrap op1levelMap[ token.txt] );
         let mut typeInfo = Ast.builtinTypeNone;
         let mut macroExpFlag = false;
         let expType = exp.$expType;

         switch ( token.txt ) {
            case "-" {
               if not expType.equals( Ast.builtinTypeInt ) and
                  not expType.equals( Ast.builtinTypeReal )
               {
                  self.addErrMess(
                     token.pos,
                     'unmatch type for "-" -- %s' ( expType.getTxt() ) );
               }
               typeInfo = expType;
            }
            case "#" {
               if expType.$kind ~= .List and
                  expType.$kind ~= .Array and
                  expType.$kind ~= .Map and
                  not Ast.builtinTypeString.canEvalWith( expType, "=" )
               {
                  self.addErrMess(
                     token.pos,
                     'unmatch type for "#" -- %s' ( expType.getTxt() ) );
               }
               typeInfo = Ast.builtinTypeInt;
            }
            case "not" {
               typeInfo = Ast.builtinTypeBool;
               
               if not expType.$nilable and
                  not expType.equals( Ast.builtinTypeBool ) and
                  not expType.equals( Ast.builtinTypeStem ) and
                  not expType.equals( Ast.builtinTypeDDD )
               {
                  self.addErrMess( token.pos, "this 'not' operand never be false" );
               }
            }
            case ",," {
               macroExpFlag = true;
            }
            case ",,," {
               macroExpFlag = true;
               if not expType.equals( Ast.builtinTypeString ) {
                  self.error( "unmatch ,,, type, need string type" );
               }
               typeInfo = Ast.builtinTypeSymbol;
            }
            case ",,,," {
               macroExpFlag = true;
               if not expType.equals( Ast.builtinTypeSymbol ) {
                  self.error( "unmatch ,,, type, need symbol type" );
               }
               typeInfo = Ast.builtinTypeString;
            }
            case "`" {
               typeInfo = Ast.builtinTypeNone;
            }
            case "~" {
               if not expType.equals( Ast.builtinTypeInt ) {
                  self.addErrMess(
                     token.pos,
                     'unmatch type for "~" -- %s' ( expType.getTxt() ) );
               }
               typeInfo = Ast.builtinTypeInt;
            }
            default {
               self.error( "unknown op1" );
            }
         }

         if macroExpFlag {
            let nextToken = self.getToken();
            if nextToken.txt ~= "~~" {
               self.pushback();
            }
         }

         exp = Ast.ExpOp1Node.create(
            self.nodeManager, firstToken.pos, [ typeInfo ], token, self.macroMode, exp );
         return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
      }
   }

   if token.kind == Parser.TokenKind.Int {
      exp = Ast.LiteralIntNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeInt ],
         token, tonumber( token.txt )@@int );
   }
   elseif token.kind == Parser.TokenKind.Real {
      exp = Ast.LiteralRealNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeReal ],
         token, tonumber( token.txt ) );
   }
   elseif token.kind == Parser.TokenKind.Char {
      let mut num = 0;
      if #(token.txt) == 1 {
         num = token.txt.byte( 1 );
      }
      else {
         num = unwrap quotedChar2Code[ token.txt.sub( 2, 2 ) ];
      }
      exp = Ast.LiteralCharNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeChar ], token, num );
   }
   elseif token.kind == Parser.TokenKind.Str {
      let mut nextToken = self.getToken();
      let mut formatArgList:List<&Ast.Node> = [];
      if nextToken.txt == "(" {
         repeat {
            let arg = self.analyzeExp( false );
            formatArgList.insert( arg );
            nextToken = self.getToken();
         } nextToken.txt ~= ",";
         self.checkToken( nextToken, ")" );
         nextToken = self.getToken();
      }
      exp = Ast.LiteralStringNode.create(
         self.nodeManager, firstToken.pos,
         [ Ast.builtinTypeString ], token, formatArgList );
      token = nextToken;
      if token.txt == "[" or token.txt == "$[" {
         exp = self.analyzeExpRefItem( token, exp, token.txt == "$[" );
      }
      else {
         self.pushback();
      }
   }
   elseif token.kind == Parser.TokenKind.Symb and token.txt == "__line__" {
      exp = Ast.LiteralIntNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeInt ],
         new Parser.Token( .Int, "%d" (token.pos.lineNo),
                           token.pos, nil ), token.pos.lineNo );
   }
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "fn" {
      exp = self.analyzeExpSymbol( firstToken, token, .Fn, nil, false );
   }
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "unwrap" {
      exp = self.analyzeExpUnwrap( token );
   }
   elseif token.kind == Parser.TokenKind.Symb {
      exp = self.analyzeExpSymbol(
         firstToken, token, .Symbol, nil, false );
   }
   elseif token.kind == Parser.TokenKind.Type {
      let! symbolTypeInfo = Ast.sym2builtInTypeMap[ token.txt ] {
         self.error( "unknown type -- %s" ( token.txt ) );
      };
      exp = Ast.ExpRefNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], token,
         new Ast.AccessSymbolInfo( symbolTypeInfo, nil, false ) );
   }
   elseif token.kind == Parser.TokenKind.Kywd and
       ( token.txt == "true" or token.txt == "false" )
   {  
      exp = Ast.LiteralBoolNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeBool ], token );
   }
   elseif token.kind == Parser.TokenKind.Kywd and
       ( token.txt == "nil" or token.txt == "null" )
   {
      exp = Ast.LiteralNilNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeNil ] );
   }

   if exp.$kind == Ast.nodeKindNone {
      self.error( "illegal exp" );
   }

   if skipOp2Flag {
      return exp;
   }

   return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}
