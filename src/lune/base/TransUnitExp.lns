/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;


/**
式のリスト exp, exp, exp ... を解析する。

@param allowNoneType true の場合、exp の評価結果が TypeInfoNone となるようなケースを許可する
@param skipOp2Flag true の場合、2項演算の解析は行なわない。
@param expNode 式のリストの先頭に加える式。 nil の場合は、リストに追加しない。
@param expectTypeList。 各式に期待する型。
  期待する型がない場合は、リストの要素に TypeInfoNone を指定する。
@param contExpect true の場合、 解析する式が、 expectTypeList の要素数を越えた時に、
    expectTypeList の最終要素の型を使用する。

*/
fn TransUnit.analyzeExpList(
   allowNoneType:bool, skipOp2Flag: bool, expNode: &Nodes.Node!,
   expectTypeList: &List<&Ast.TypeInfo>!, contExpect:bool! ) mut: Nodes.ExpListNode
{
   let mut expList:List<&Nodes.Node> = [];
   let mut pos:&Parser.Position! = nil;
   let mut expTypeList:List<&Ast.TypeInfo> = [];
   when! expNode {
      pos = expNode.$pos;
      expList.insert( expNode );
      expTypeList.insert( expNode.$expType );
   }

   let mut index = 1;
   let mut abbrNode:&Nodes.AbbrNode! = nil;
   let mut followOn = false;
   repeat {
      let mut expectType:&Ast.TypeInfo! = nil;
      when! expectTypeList {
         if #expectTypeList > 0 {
            let mut checkIndex = index;
            if index > #expectTypeList and contExpect {
               checkIndex = #expectTypeList;
            }
            if checkIndex <= #expectTypeList and
               expectTypeList[ checkIndex ] ~= Ast.builtinTypeNone
            {           
               expectType = expectTypeList[ checkIndex ];
            }
         }
      }
      let exp = self.analyzeExp( allowNoneType, skipOp2Flag, 0, expectType );
      if not allowNoneType and not exp.canBeRight() {
         self.addErrMess(
            exp.$pos,
            "This arg can't be r-value. -- %s" ( Nodes.getNodeKindName( exp.$kind) ) );
      }
      if not pos {
         pos = exp.$pos;
      }
      expList.insert( exp );
      expTypeList.insert( exp.$expType );
      let mut token = self.getToken(##);

      if token.txt == "**" {
         if #exp.$expTypeList <= 1 {
            self.addErrMess(
               exp.$pos,
               "This arg(%d) doesn't have multiple value. It must not use '**'" (index) );
         }
         
         token = self.getToken(##);
         followOn = true;
      }
      
      if token.txt == "##" {
         if exp.$expType.$kind == .DDD {
            self.addErrMess( token.pos, "'##' can't use with '...'" );
         }
         abbrNode = Nodes.AbbrNode.create(
            self.nodeManager, token.pos, [ Ast.builtinTypeAbbr ] );
                                         
         self.getToken(##);
         break;
      }

      index = index + 1;
      
      
   } token.txt ~= ",";

   // 最終ノードが複数の値を持つ場合は、その型を追加する
   foreach expType, listIndex in expList[ #expList ].$expTypeList {
      if listIndex ~= 1 {
         expTypeList.insert( expType );
      }
   }

   if not allowNoneType {
      foreach expType, expIndex in expTypeList {
         if expType == Ast.builtinTypeNone {
            self.addErrMess( unwrap pos default new Parser.Position( 0, 0 ),
                             "The type of exp(%d) is None!!" (expIndex) );
         }
      }
   }

   when! abbrNode {
      expList.insert( abbrNode );
   }

   self.pushback();

   return Nodes.ExpListNode.create(
      self.nodeManager, unwrap pos default new Parser.Position( 0, 0 ),
      expTypeList, expList, followOn );
}

fn TransUnit.analyzeListConst( token: &Parser.Token ) mut : Nodes.Node {
   let nextToken = self.getToken(##);
   let mut expList:Nodes.ExpListNode! = nil;
   let mut itemTypeInfo = Ast.builtinTypeNone;

   if nextToken.txt ~= "]" {
      self.pushback();
      expList = self.analyzeExpList( false, false ## );
      self.checkNextToken( "]" );
      let nodeList: List<&Nodes.Node> = (unwrap expList).$expList;
      foreach exp in nodeList {
         itemTypeInfo = Ast.TypeInfo.getCommonType(
            itemTypeInfo, exp.$expType,
            Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
      }
   }
   if itemTypeInfo.$kind == .DDD {
      if #itemTypeInfo.$itemTypeInfoList > 0 {
         itemTypeInfo = itemTypeInfo.$itemTypeInfoList[ 1 ];
      }
      else {
         itemTypeInfo = Ast.builtinTypeStem_;
      }
   }
   let mut typeInfoList = [ Ast.builtinTypeNone ];
   if token.txt == '[' {
      typeInfoList = [ Ast.NormalTypeInfo.createList( .Local, self.getCurrentClass(),
                                                      [ itemTypeInfo ], .Mut ) ];
      return Nodes.LiteralListNode.create(
         self.nodeManager, token.pos, typeInfoList, expList );
   }
   else {
      typeInfoList = [ Ast.NormalTypeInfo.createArray( .Local, self.getCurrentClass(),
                                                       [ itemTypeInfo ], .Mut ) ];
      return Nodes.LiteralArrayNode.create(
         self.nodeManager, token.pos, typeInfoList, expList );
   }
}

fn TransUnit.analyzeSetConst( token: &Parser.Token ) mut : Nodes.Node {

   self.helperInfo.useSet = true;

   
   let nextToken = self.getToken(##);
   let mut expList:Nodes.ExpListNode! = nil;
   let mut itemTypeInfo = Ast.builtinTypeNone;
   if nextToken.txt ~= ")" {
      self.pushback();
      expList = self.analyzeExpList( false, false ## );
      self.checkNextToken( ")" );
      let nodeList: List<&Nodes.Node> = (unwrap expList).$expList;
      foreach exp in nodeList {
         let expType = exp.$expType;
         if expType.$nilable {
            self.addErrMess(
               exp.$pos,
               "'Set' object can't store nilable. -- %s" (expType.getTxt(##)));
         }
         else {
            itemTypeInfo = Ast.TypeInfo.getCommonType(
               itemTypeInfo, exp.$expType,
               Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
         }
      }
   }
   let mut typeInfoList = [ Ast.builtinTypeNone ];
   typeInfoList = [ Ast.NormalTypeInfo.createSet( .Local, self.getCurrentClass(),
                                                  [ itemTypeInfo ], .Mut ) ];
   return Nodes.LiteralSetNode.create(
      self.nodeManager, token.pos, typeInfoList, expList );
}

fn TransUnit.analyzeMapConst( token: &Parser.Token ) mut : Nodes.LiteralMapNode {
   let mut nextToken = self.getToken(##);
   let mut map:Map<&Nodes.Node,&Nodes.Node> = {};
   let mut pairList:Nodes.PairItem[] = [];
   let mut keyTypeInfo = Ast.builtinTypeNone;
   let mut valTypeInfo = Ast.builtinTypeNone;


   fn getMapKeyValType(
      pos: &Parser.Position, keyFlag: bool,
      mut typeInfo:&Ast.TypeInfo, mut expType:&Ast.TypeInfo ): &Ast.TypeInfo
   {
      if expType.$nilable {
         if keyFlag {
            self.addErrMess(
               pos, "map key can't set a nilable -- %s" (expType.getTxt(##)) );
         }
         if expType.equals( Ast.builtinTypeNil ## ) {
            return typeInfo;
         }
         expType = expType.$nonnilableType;
      }
      return Ast.TypeInfo.getCommonType(
         typeInfo, expType,
         Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
   }

   while true {
      if nextToken.txt == "}" {
         break;
      }
      self.pushback();

      let key = self.analyzeExp( false, false ## );
      keyTypeInfo = getMapKeyValType( key.$pos, true, keyTypeInfo, key.$expType );

      self.checkNextToken( ":" );

      let val = self.analyzeExp( false, false ## );
      valTypeInfo = getMapKeyValType( val.$pos, false, valTypeInfo, val.$expType );

      //pairList.insert( { "key": key, "val": val } );
      pairList.insert( new Nodes.PairItem( key, val ) );
      map[ key ] = val;
      nextToken = self.getToken(##);
      if nextToken.txt ~= "," {
         break;
      }
      nextToken = self.getToken(##);
   }

   let typeInfo = Ast.NormalTypeInfo.createMap(
      .Local, self.getCurrentClass(), keyTypeInfo, valTypeInfo, .Mut );

   self.checkToken( nextToken, "}" );
   // return self.createNode( nodeKindLiteralMap, token.pos,[ typeInfo ],
   //                      { "map": map, "pairList": pairList } );
   return Nodes.LiteralMapNode.create(
      self.nodeManager, token.pos,[ typeInfo ], map, pairList );
}

fn TransUnit.checkSymbolHavingValue(
   pos:&Parser.Position, symbolInfoList:&List<&Ast.SymbolInfo> ) mut
{
   foreach symbolInfo in symbolInfoList {
      if symbolInfo.$kind == .Var {
         if not symbolInfo.$hasValueFlag {
            self.addErrMess(
               pos, "this variable have no value. -- %s" (symbolInfo.$name) );
         }
      }
   }
}


fn TransUnit.analyzeExpRefItem(
   token: &Parser.Token, exp: &Nodes.Node, mut nilAccess:bool ) mut : Nodes.Node
{
   self.checkSymbolHavingValue( exp.$pos, exp.getSymbolInfo() );
      
   let mut expType = exp.$expType;

   if nilAccess {
      if not expType.$nilable {
         nilAccess = false;
      }
      else {
         expType = expType.$nonnilableType;
      }
   }

   let mut expectItemType:&Ast.TypeInfo! = nil;
   let mut typeInfo = Ast.builtinTypeStem_;
   // 指定すべき index の型
   let mut indexTypeInfo = Ast.builtinTypeInt;
   if expType.$kind == .Map {
      let itemTypeList = expType.get_itemTypeInfoList();
      if expType.$kind == .Map {
         typeInfo = itemTypeList[2];
         indexTypeInfo = itemTypeList[1];
      }
      else {
         typeInfo = self.createModifier(
            Ast.builtinTypeBool.$nilableTypeInfo, .IMut );
         indexTypeInfo = itemTypeList[1];
      }
      expectItemType = itemTypeList[1];
      if not typeInfo.equals( Ast.builtinTypeStem_ ##) and not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
   }
   elseif expType.$kind == .Array or expType.$kind == .List
   {
      typeInfo = expType.get_itemTypeInfoList()[1];
   }
   elseif expType.equals( Ast.builtinTypeString ##) {
      typeInfo = Ast.builtinTypeInt;
   }
   elseif expType.equals( Ast.builtinTypeStem ##) {
      indexTypeInfo = Ast.builtinTypeStem;
      typeInfo = Ast.builtinTypeStem_;
   }
   else {
      self.addErrMess( exp.$pos,
                       "could not access with []. -- %s" (expType.getTxt(##)) );
   }

   if nilAccess {
      self.helperInfo.useNilAccess = true;
      if not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
   }

   if Ast.TypeInfo.isMut( typeInfo ) and not Ast.TypeInfo.isMut( expType ) {
      typeInfo = self.createModifier( typeInfo, .IMut );
   }

   let indexExp = self.analyzeExp( false, false, nil, expectItemType );
   if not indexExp.canBeRight() {
      self.addErrMess( indexExp.$pos, "This node can't use index" );
   }
   if not indexTypeInfo.canEvalWith( indexExp.$expType, "=", {} ) {
      self.addErrMess( indexExp.$pos,
                       "unmatch index type -- %s, %s"
                       ( indexTypeInfo.getTxt(##), indexExp.$expType.getTxt(##) ) );
   }
   
   self.checkNextToken( "]" );
   
   
   return Nodes.ExpRefItemNode.create(
      self.nodeManager, token.pos, [ typeInfo ], exp, nilAccess, nil, indexExp );
}


/**
型の一致性を確認する。

@param message 不一致時に出力するメッセージ
@param pos 不一致時に出力するコードの場所
@param dstTypeList 設定先の型のリスト
@param expNodeList 設定する値の型リスト
@param allowDstShort dstTypeList の要素数が expNodeList よりも少ないことを許容する場合 true
@param warnForFollow true の場合、値を省略している時に警告を出力する
@param 
*/
fn TransUnit.checkMatchType(
   mut message:str, pos: &Parser.Position, dstTypeList: &List<&Ast.TypeInfo>,
   expNodeList: &List<&Nodes.Node>, allowDstShort:bool, warnForFollow:bool,
   genericsClassType:&Ast.TypeInfo! ) mut :
   Map<&Ast.TypeInfo,&Ast.TypeInfo>, List<&Nodes.Node>!, &List<&Ast.TypeInfo>
{
   let mut warnForFollowSrcIndex:int! = nil;
   let mut expTypeList:List<&Ast.TypeInfo> = [];

   // expNodeList から、評価後の型リスト expTypeList を取得する。
   // ## で省略を明示した場合、expNodeList の末尾には AbbrNode が入っている。
   // 多値使用警告を正常に判定するため、一旦 AbbrNode を抜く。
   let mut workExpNodeList = expNodeList;
   let mut hasAbbr = false;
   if #expNodeList > 0 {
      if expNodeList[ #expNodeList ].$kind == Nodes.NodeKind.$Abbr {
         hasAbbr = true;
         let mut workList:List<&Nodes.Node> = [];
         foreach node, index in expNodeList {
            workList.insert( node );
         }
         workList.remove(##);
         workExpNodeList = workList;
      }
   }
   
   foreach expNode, index in workExpNodeList {
      if index == #workExpNodeList {
         foreach expType in expNode.$expTypeList {
            expTypeList.insert( expType );
         }
      }
      else {
         expTypeList.insert( expNode.$expType );
      }
   }
   
   if warnForFollow and #expTypeList > #workExpNodeList {
      warnForFollowSrcIndex = #workExpNodeList + 1;
   }
   if hasAbbr {
      expTypeList.insert( Ast.builtinTypeAbbr );
   }

   let mut alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
   when! genericsClassType {
      alt2typeMap = genericsClassType.createAlt2typeMap( true );
   }

   Ast.CanEvalCtrlTypeInfo.setupNeedAutoBoxing( alt2typeMap );
   
   let result, mess = Ast.TypeInfo.checkMatchType(
      dstTypeList, expTypeList, allowDstShort, warnForFollowSrcIndex, alt2typeMap );
   //Ast.AlternateTypeInfo.createAlt2typeMap( applyGeneric ) ); 
   switch result {
      case .Error {
         self.addErrMess( pos, "%s: %s" (message, mess ) );
      }
      case .Warn {
         if not self.ctrl_info.checkingDefineAbbr and
            Code.isMessageOf( .nothing_define_abbr, mess )
         {
         }
         else {
            self.addWarnMess( pos, "%s: %s" (message, mess ) );
         }
      }
   }


   if #expNodeList ~= 0 {
      let mut autoBoxingCount = 0;
      let mut newExpNodeList:List<&Nodes.Node> = [];
      
      foreach expNode, index in expNodeList {
         newExpNodeList.insert( expNode );
         if #dstTypeList >= index {
            let dstType = dstTypeList[ index ];
            //if dstType.$kind == .Box and expNode.$expType.$kind ~= .Box {
            if Ast.CanEvalCtrlTypeInfo.canAutoBoxing( dstType, expNode.$expType ) {
               autoBoxingCount = autoBoxingCount + 1;
               newExpNodeList[ index ] = Nodes.BoxingNode.create(
                  self.nodeManager, expNode.$pos, [ dstType ], expNode );
            }
         }
      }

      if autoBoxingCount > 0 {
         if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap,
                                                              autoBoxingCount )
         {
            self.addErrMess( pos, "illegal auto boxing error -- %d" (autoBoxingCount) );
         }
         
         return alt2typeMap, newExpNodeList, expTypeList;
      }
   }
   if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 0 ) {
      self.addErrMess( pos, "can't auto boxing error" );
   }
   
   
   return alt2typeMap, nil, expTypeList;
}



/**
関数 funcTypeInfo の引数に expList を指定している時の、引数型チェックを行なう。

@param pos この引数チェックを行なっているソース位置
@param funcTypeInfo 関数型
@param expList 引数情報
@param genericTypeList generics に与えられている型
@param genericsClass funcTypeInfo がメソッドだったときの、
    そのメソッドが定義されているクラス
@return AlternateTypeInfo → 実型パラメータのマップ
@return 
*/
fn TransUnit.checkMatchValType(
   pos: &Parser.Position, funcTypeInfo:&Ast.TypeInfo, expList:&Nodes.ExpListNode!,
   genericTypeList: &List<&Ast.TypeInfo>, genericsClass:&Ast.TypeInfo! ) mut :
   Map<&Ast.TypeInfo,&Ast.TypeInfo>, &Nodes.ExpListNode!
{
   let mut argTypeList = funcTypeInfo.$argTypeInfoList;
   switch funcTypeInfo {
      case builtinFunc.list_insert, builtinFunc.set_add, builtinFunc.set_del {
         argTypeList = genericTypeList;
      }
      case builtinFunc.list_sort {
         let alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
         let callback = Ast.NormalTypeInfo.createFunc(
            false, false, nil, Ast.TypeInfoKind.Func,
            Ast.headTypeInfo, false, false, true, .Pri, "sort", nil,
            [ genericTypeList[ 1 ], genericTypeList[ 1 ] ],
            [ Ast.builtinTypeBool ], false );
         argTypeList = [ callback.$nilableTypeInfo ];
      }
      case builtinFunc.list_remove {
      }
   }

   let mut expNodeList:List<&Nodes.Node> = [];
   let mut warnForFollow = true;

   when! expList {
      foreach node in expList.$expList {
         expNodeList.insert( node );
      }
      if expList.$followOn {
         warnForFollow = false;
      }
   }

   let mut alt2typeMap, newExpNodeList = self.checkMatchType(
      funcTypeInfo.getTxt(##), pos,
      argTypeList, expNodeList, false, warnForFollow, genericsClass );
   
   when! expList, newExpNodeList {
      return alt2typeMap, self.createExpListNode( expList.$pos, expList.$followOn,
                                                  newExpNodeList );
   }
   return alt2typeMap, expList;
}

class MacroPaser extend Parser.Parser {
   let tokenList: &List<&Parser.Token>;
   let mut pos: int;
   let name: str;

   pub fn __init( tokenList: &List<&Parser.Token>, name: str ) {
      super();
      self.pos = 1;
      self.tokenList = tokenList;
      self.name = name;
   }

   pub override fn getToken() mut : &Parser.Token! {
      if #self.tokenList < self.pos {
         return nil;
      }
      let token = self.tokenList[ self.pos ];
      self.pos = self.pos + 1;

      // Util.errorLog( "getToken: %s" (token.txt) );

      return token;
   }
   pub override fn getStreamName(): str {
      return self.name;
   }
}

fn TransUnit.evalMacroOp(
   firstToken: &Parser.Token, macroTypeInfo: &Ast.TypeInfo,
   expList: &Nodes.ExpListNode!, evalMacroCallback:EvalMacroCallback ) mut
{
   fn getLiteralMacroVal( obj:Nodes.Literal ) : stem! {
      match obj {
         case .Nil {
            return nil;
         }
         case .Int( val ) {
            return val;
         }
         case .Real( val ) {
            return val;
         }
         case .Str( val ) {
            return val;
         }
         case .Bool( val ) {
            return val;
         }
         case .Symbol( val ) {
            return [ val ];
         }
         case .Field( val ) {
            return val;
         }
         case .LIST( list ) {
            let mut newList:List<stem!> = [];
            foreach item, index in list {
               newList[ index ] = getLiteralMacroVal( item );
            }
            return newList;
         }
         case .ARRAY( list ) {
            let mut newList:List<stem!> = [];
            foreach item, index in list {
               newList[ index ] = getLiteralMacroVal( item );
            }
            return newList;
         }
         case .SET( list ) {
            let mut newSet:Set<stem> = (@);
            foreach item in list {
               if! getLiteralMacroVal( item ) {
                  newSet.add( _exp );
               }
            }
            return newSet;
         }
         case .MAP( map ) {
            let mut newMap:Map<&stem,&stem> = {};
            foreach val, key in map {
               let keyObj = getLiteralMacroVal( key );
               let valObj = getLiteralMacroVal( val );
               when! keyObj, valObj {
                  newMap[ keyObj ] = valObj;
               }
            }
            return newMap;
         }
      }
      Util.err( "unknown literal obj -- " .. obj.$_txt );
   }
   
   
   self.useModuleMacroSet.add( macroTypeInfo.getModule() );

   when! expList {
      foreach exp in expList.get_expList() {
         let kind = exp.$kind;
         switch kind {
            case Nodes.NodeKind.$LiteralNil,
                 Nodes.NodeKind.$LiteralChar,
                 Nodes.NodeKind.$LiteralInt,
                 Nodes.NodeKind.$LiteralReal,
                 Nodes.NodeKind.$LiteralArray,
                 Nodes.NodeKind.$LiteralList,
                 Nodes.NodeKind.$LiteralMap,
                 Nodes.NodeKind.$LiteralString,
                 Nodes.NodeKind.$LiteralBool,
                 Nodes.NodeKind.$LiteralSymbol,
                 Nodes.NodeKind.$RefField,
                 Nodes.NodeKind.$ExpMacroStat,
                 Nodes.NodeKind.$ExpOmitEnum
            {
            }
            default {
               self.error( "Macro arguments must be literal value." );
            }
         }
      }
   }

   let macroInfo = unwrap self.typeId2MacroInfo[ macroTypeInfo.get_typeId() ];

   let mut argValMap:Map<int,stem> = {};
   let mut macroArgValMap:Map<str,stem> = {};
   let macroArgNodeList = macroInfo.getArgList();
   let mut macroArgName2ArgNode:Map<str,&Nodes.Node> = {};
   when! expList {
      foreach argNode, index in expList.get_expList() {
         let literal = argNode.getLiteral();
         when! literal {
            if! let val = getLiteralMacroVal( literal ) {
               argValMap[ index ] = val;
               let declArgNode = macroArgNodeList[ index ];
            
               macroArgValMap[ declArgNode.$name ] = val;
               macroArgName2ArgNode[ declArgNode.$name ] = argNode;
            }
         }
      }
   }

   let func = macroInfo.func;
   //let macroVars:Map<str,stem!> = func( argVal.unpack() )@@Map<str,stem!>;
   let mut macroVars:&Map<str,stem> = {};
   if! let macroRet = func( macroArgValMap ) {
      macroVars = macroRet@@Map<str,stem>;
   }
   foreach name in (unwrap macroVars.__names)@@List<str> {
      let valInfo = unwrap macroInfo.symbol2MacroValInfoMap[ name ];
      let typeInfo = valInfo.typeInfo or Ast.builtinTypeStem_;
      let mut val = macroVars[ name ];
      if typeInfo.equals( Ast.builtinTypeSymbol ##) {
         val = [ val ];
      }
      self.symbol2ValueMapForMacro[ name ] =
         new Nodes.MacroValInfo( val, typeInfo, macroArgName2ArgNode[ name ] );
   }

   //let scope = self.pushScope();


   foreach arg, index in macroInfo.getArgList() {
      if arg.$typeInfo.$kind ~= .DDD {
         let argType = arg.$typeInfo;
         let argName = arg.$name;
         //scope.add( argName, argType.expType );
         self.symbol2ValueMapForMacro[ argName ] =
            new Nodes.MacroValInfo( argValMap[ index ], argType,
                                    macroArgName2ArgNode[ argName ] );
      }
      else {
         self.error( "not support ... in macro" );
      }
   }

   // foreach macroValInfo, symbol in self.symbol2ValueMapForMacro {
   //     Util.errorLog( "HOGE: %s %s" (symbol, macroValInfo) );
   // }


   let mut parser = new MacroPaser(
      macroInfo.getTokenList(),
      "%s:%d(macro %s)" (self.parser.getStreamName(),
                          firstToken.pos.lineNo, macroTypeInfo.getTxt(##)) );
   let mut bakParser = self.parser;
   self.parser = parser;


   self.macroMode = .Expand;
   self.macroCallLineNo = firstToken.pos.lineNo;

   evalMacroCallback();


   //    self.popScope();

   self.macroMode = .None;
   self.parser = bakParser;
}


fn TransUnit.evalMacro(
   firstToken: &Parser.Token,
   macroTypeInfo: &Ast.TypeInfo, expList: &Nodes.ExpListNode! ) mut : Nodes.ExpMacroExpNode
{
   let mut stmtList:List<&Nodes.Node> = [];
   
   self.evalMacroOp( firstToken, macroTypeInfo, expList,
                     fn () {
                        self.analyzeStatementList( stmtList, "}" );
                     } );

   // return self.createNode(
   //     nodeKindExpMacroExp, firstToken.pos, builtinTypeNone, stmtList );
   return Nodes.ExpMacroExpNode.create(
      self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], stmtList );
}

/**
format の書式から %? を検索して、リストを返す。
*/
pub fn findForm( format:str ): List<str> {
   let mut remain = format;
   let mut opList:List<str> = [];

   while true {
      let mut pos:int!, mut endPos:int! = nil, nil;
      if! let index, endIndex = remain.find( "^%%[%d]*%a" ## ) {
         pos, endPos = index, endIndex;
      }  
      else {
         if! let index, endIndex = remain.find( "[^%%]%%[%d]*%a" ## ) {
            pos, endPos = index + 1, endIndex;
         }      
      }  

      when! pos, endPos {
         let op = remain.sub( pos, endPos );
         opList.insert( op );
         remain = remain.sub( endPos + 1 ## );
      }
      else {
         break;
      }
   }
   return opList;
}

pub enum FormType {
   Match,
   NeedConv,
   Unmatch,
}
pub fn isMatchStringFormatType(
   opKind:str, mut argType:&Ast.TypeInfo, luaVer:&LuaVer.LuaVerInfo ):
   FormType, &Ast.TypeInfo
{
   if! let enumType = argType.$srcTypeInfo@@@Ast.EnumTypeInfo {
      argType = enumType.$valTypeInfo;
   }
   switch opKind[ #opKind ] {
      case ?s {
         if not argType.equals( Ast.builtinTypeString ##) {
            if not luaVer.$canFormStem2Str {
               return .NeedConv, Ast.builtinTypeString;
            }
         }
      }
      case ?q {
         if not argType.equals( Ast.builtinTypeString ##) {
            // 文字列以外に %q を使うのは不具合の可能性があるので unmatch にする。
            return .Unmatch, Ast.builtinTypeString;
         }
      }
      case ?A, ?a, ?E, ?e, ?f, ?G, ?g {
         if not argType.equals( Ast.builtinTypeReal ##) {
            return .Unmatch, Ast.builtinTypeReal;
         }
      }
      default {
         if not argType.equals( Ast.builtinTypeInt ##) and
            not argType.equals( Ast.builtinTypeChar ##)
         {
            return .Unmatch, Ast.builtinTypeInt;
         }
      }
   }
   return .Match, Ast.builtinTypeNone;
}


fn TransUnit.checkStringFormat(
   pos:&Parser.Position, formatTxt:str, argTypeList:&List<&Ast.TypeInfo> ) mut
{
   let opList = findForm( formatTxt );
   let mut dstTypeList:List<&Ast.TypeInfo> = [];

   if #opList ~= #argTypeList {
      self.addErrMess( pos,
                       "argument number is mismatch -- %d != %d"
                       ( #opList, #argTypeList ) );   
      return;
   }
   
   foreach op, index in opList {
      let argType = argTypeList[ index ];
      let match, reqType = isMatchStringFormatType( op, argType, self.targetLuaVer );
      if match == .Unmatch {
         let mut mess = "type must be %s -- %s"
             ( reqType.getTxt(##), argType.getTxt(##) );
         self.addErrMess( pos, "argument(%d) %s" (index, mess ) );
      }
   }
}

/**
関数呼び出し Node の前処理。

"(" を読み済みの状態。次のトークンは引数のトークンになっている状態にする。
この関数を抜けると、 ")" を読み込み済みの状態。

@param position 関数の定義位置
@param funcTypeInfo 関数の型情報
@param genericTypeList Genericsの実型パラメータ
@param genericsClass funcTypeInfo が属するクラス Generics クラス。
         funcTypeInfo がメソッドでなければ headTypeInfo.
*/
fn TransUnit.prepareExpCall(
   position:&Parser.Position, funcTypeInfo:&Ast.TypeInfo,
   genericTypeList:&List<&Ast.TypeInfo>, genericsClass:&Ast.TypeInfo ) mut :
   Map<&Ast.TypeInfo,&Ast.TypeInfo>, &Nodes.ExpListNode!
{
   let mut macroFlag = false;

   if funcTypeInfo.get_kind() == .Macro {
      macroFlag = true;
      self.symbol2ValueMapForMacro = {};
      self.macroMode = .Analyze;
   }

   let work = self.getToken(##);
   let mut argList: &Nodes.ExpListNode! = nil;
   if work.txt ~= ")" {
      self.pushback();
      argList = self.analyzeExpList(
         false, false, nil, funcTypeInfo.$argTypeInfoList ## );
      self.checkNextToken( ")" );

      when! argList {
         foreach argNode in argList.$expList {
            if not argNode.canBeRight() and argNode.$kind ~= Nodes.NodeKind.$Abbr {
               self.addErrMess( argNode.$pos, "this node can't be r-value. -- %s"
                                (Nodes.getNodeKindName( argNode.$kind )));
            }
         }
      }
   }

   // 引数の型チェック
   let mut alt2typeMap, workArgList = self.checkMatchValType(
      position, funcTypeInfo, argList, genericTypeList, genericsClass );

   return alt2typeMap, workArgList;
}

fn TransUnit.analyzeExpCall(
   firstToken:&Parser.Token, mut exp: Nodes.Node, nextToken:&Parser.Token ) mut :
   Nodes.Node, &Parser.Token
{
   self.checkSymbolHavingValue( exp.$pos, exp.getSymbolInfo() );
   
   // string.format() の引数チェック
   fn checkArgForStringForm( argList:&Nodes.ExpListNode ) {
      let mut formArgTypeList:List<&Ast.TypeInfo> = [];
      let mut formatTxt = "";
      if #argList.$expList > 0 {
         let argNode = argList.$expList[ 1 ];
         if argNode.$kind ~= Nodes.NodeKind.$LiteralString {
            // literal 文字列でない場合は無視
            return;
         }
         if! let literal = argNode.getLiteral() {
            match literal {
               case .Str( val ) {
                  formatTxt = val;
               }
            }
         }
      }
      foreach argType, index in argList.$expTypeList {
         if index ~= 1 {
            formArgTypeList.insert( argType );
         }
      }
      self.checkStringFormat( firstToken.pos, formatTxt, formArgTypeList );
   }

   // List.sort() の引数チェック 
   fn checkArgForSort(
      genericTypeList:&List<&Ast.TypeInfo>, argList:&Nodes.ExpListNode )
   {  
      if #argList.$expTypeList > 0 {
         let callback = argList.$expTypeList[ 1 ];
         if callback == Ast.builtinTypeAbbr {
            return;
         }
         if #callback.$retTypeInfoList ~= 1 {
            self.addErrMess(
               firstToken.$pos,
               "The callback's to return value of sort() must have a value. -- %d"
               (#callback.$retTypeInfoList) );
            return;
         }
         if not Ast.builtinTypeBool.equals( callback.$retTypeInfoList[ 1 ] ##) {
            self.addErrMess(
               firstToken.$pos,
               "The callback's return type of sort() must be bool. -- '%s'"
               ( callback.$retTypeInfoList[ 1 ].getTxt(##) ) );
         }
         if #callback.$argTypeInfoList ~= 2 {
            self.addErrMess(
               firstToken.$pos,
               "The callback's argument must have 2 arguments. -- '%s'"
               (callback.$display_stirng) );
         }
         if #genericTypeList == 1 {
            foreach argType, index in callback.$argTypeInfoList {
               if not genericTypeList[ 1 ].equals( argType ##) {
                  self.addErrMess(
                     firstToken.$pos,
                     "The callback's argument(%d) type must be -- '%s'"
                     ( index, genericTypeList[ 1 ].getTxt(##)) );
               }
            }
         }
         else {
            self.addErrMess(
               firstToken.$pos, "The generics of the list is illegal" );
         }
      }
   }
   
   // let mut macroFlag = false;
   let mut funcTypeInfo = exp.$expType;
   let nilAccess;

   if nextToken.txt == "$(" and funcTypeInfo.$nilable {
      funcTypeInfo = funcTypeInfo.$nonnilableType;
      nilAccess = true;
   }
   else {
      nilAccess = false;
   }

   // if funcTypeInfo.get_kind() == .Macro {
   //    macroFlag = true;
   //    self.symbol2ValueMapForMacro = {};
   //    self.macroMode = .Analyze;
   // }

   // let work = self.getToken(##);
   // let mut argList: &Nodes.ExpListNode! = nil;
   // if work.txt ~= ")" {
   //    self.pushback();
   //    argList = self.analyzeExpList(
   //       false, false, nil, funcTypeInfo.$argTypeInfoList ## );
   //    self.checkNextToken( ")" );

   //    when! argList {
   //       foreach argNode in argList.$expList {
   //          if not argNode.canBeRight() and argNode.$kind ~= Nodes.NodeKind.$Abbr {
   //             self.addErrMess( argNode.$pos, "this node can't be r-value. -- %s"
   //                              (Nodes.getNodeKindName( argNode.$kind )));
   //          }
   //       }
   //    }
   // }

   // 引数の型チェック
   let mut genericTypeList = funcTypeInfo.$itemTypeInfoList;
   let mut refFieldNode:&Nodes.RefFieldNode! = nil;
   let mut genericsClass = Ast.headTypeInfo;
   if! let refField = exp@@@Nodes.RefFieldNode {
      refFieldNode = refField;
      let classType = refField.$prefix.$expType;
      genericsClass = classType;

      if funcTypeInfo.$kind == .Method {
         genericTypeList = classType.$itemTypeInfoList;
      }
   }

   // let mut alt2typeMap, workArgList = self.checkMatchValType(
   //    exp.$pos, funcTypeInfo, argList, genericTypeList, genericsClass );
   // argList = workArgList;


   let mut alt2typeMap, argList = self.prepareExpCall(
      exp.$pos, funcTypeInfo, genericTypeList, genericsClass );

   if funcTypeInfo.equals( builtinFunc.list_insert ##) {
      when! argList {
         if argList.$expType.$nilable {
            self.addErrMess( argList.$pos, "list can't insert nilable" );
         }
      }
   }
   if funcTypeInfo.equals( builtinFunc.set_add ##) {
      when! argList {
         if argList.$expType.$nilable {
            self.addErrMess( argList.$pos, "set can't add nilable" );
         }
      }
   }
   elseif funcTypeInfo.equals( builtinFunc.list_remove ##) {
      if #genericTypeList > 0 {
         if genericTypeList[ 1 ].$nilable {
            self.addWarnMess( exp.$pos, "remove() is dangerous for nilable's list." );
         }
      }
   }

   if funcTypeInfo.get_kind() == .Macro {
      self.macroMode = .None;
      exp = self.evalMacro( firstToken, funcTypeInfo, argList );
   }
   else {
      switch( funcTypeInfo.$kind ) {
         case .Method, .Func, .Form {
         }
         default {
            self.error( "can't call the type -- %s, %s"
                        ( funcTypeInfo.getTxt(##),
                          funcTypeInfo.$kind.$_txt ) );
         }
      }
      let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
      foreach retType, index in funcTypeInfo.$retTypeInfoList {
         retTypeInfoList.insert( retType );
         if! let applyType = retType.applyGeneric( alt2typeMap, self.moduleType ) {
            retTypeInfoList[ index ] = applyType;
         }
         else {
            if funcTypeInfo == builtinFunc.list_remove {
               // pending: List.remove の戻り値設定を暫定対応
               retTypeInfoList[ index ] = genericTypeList[ 1 ].$nilableTypeInfo;
            }
            elseif funcTypeInfo.$kind == .Func and
                ( funcTypeInfo.$rawTxt == "_fromMap" or
                  funcTypeInfo.$rawTxt == "_fromStem" ) and
               genericsClass.isInheritFrom( Ast.builtinTypeMapping, alt2typeMap )
            {
               retTypeInfoList[ index ] = genericsClass.$nilableTypeInfo;
            }
            else {
               self.addErrMess(
                  firstToken.pos,
                  "not support generics yet. -- %s" (retType.getTxt(##)) );
            }
         }
      }
      
      when! refFieldNode {
         if funcTypeInfo.equals( builtinFunc.list_unpack ##) or
            funcTypeInfo.equals( builtinFunc.array_unpack ##)
         {
            // unpack の型を list の要素の DDD 型にする
            let prefixType = refFieldNode.$prefix.$expType;
            if #prefixType.$itemTypeInfoList > 0 {
               let dddType = Ast.NormalTypeInfo.createDDD(
                  prefixType.$itemTypeInfoList[ 1 ], false );
               retTypeInfoList = [ dddType ];
            }
         }
      }
         
      
      if nilAccess {
         let mut retList:List<&Ast.TypeInfo> = [];
         foreach retType in retTypeInfoList {
            if retType.$nilable {
               retList.insert( retType );
            }
            else {
               retList.insert( retType.$nilableTypeInfo );
            }
         }
         retTypeInfoList = retList;
         self.helperInfo.useNilAccess = true;
      }

      let mut errorFuncFlag = false;
      if #retTypeInfoList > 0 {
         let retType = retTypeInfoList[1];
         if retType == Ast.builtinTypeNeverRet {
            errorFuncFlag = true;
         }
      }

      when! argList {
         switch funcTypeInfo {
            case builtinFunc.string_format {
               checkArgForStringForm( argList );
            }
            case builtinFunc.list_sort, builtinFunc.array_sort {
               checkArgForSort( genericTypeList, argList );
            }
         }
      }

      if funcTypeInfo.equals( builtinFunc.lune__kind ##) {
         if! let expList = argList$.$expList {
            if #expList > 0 {
               exp = Nodes.LuneKindNode.create(
                  self.nodeManager, firstToken.pos, [ Ast.builtinTypeInt ],
                  expList[ 1 ] );
            }
         }
      }
      else {
         exp = Nodes.ExpCallNode.create(
            self.nodeManager, firstToken.pos,
            retTypeInfoList, exp, errorFuncFlag, nilAccess, argList );
      }
   }

   return exp, self.getToken(##);
}

fn TransUnit.analyzeExpCast(
   firstToken:&Parser.Token, opTxt:str, exp:Nodes.Node ) mut : Nodes.Node
{
   let castTypeNode = self.analyzeRefType( .Local, false );
   let mut castType = castTypeNode.$expType;

   let expType = exp.$expType;

   if opTxt == "@@@" or opTxt == "@@=" {
      if #castType.$itemTypeInfoList > 0 {
         self.addErrMess( castTypeNode.$pos,
                          "not support cast for generics class yet -- %s"
                          (castType.getTxt(##)));
      }
      switch castType.$kind {
         case .IF, .Class, .Prim {
         }
         default {
            self.addErrMess( castTypeNode.$pos,
                             "not support cast -- %s" (castType.getTxt(##)));
         }
      }

      if opTxt == "@@=" {
         if castType.$kind ~= .IF and castType.$kind ~= .Class {
            self.addErrMess( castTypeNode.$pos,
                             "'@@=' cast must be class or interface. -- %s"
                             (castType.getTxt(##)) );
         }
         if expType.$srcTypeInfo ~= Ast.builtinTypeStem and
            expType.$kind ~= .IF and expType.$kind ~= .Class
         {           
            self.addErrMess( castTypeNode.$pos,
                             "'@@=' cast must be class or interface. -- %s"
                             (castType.getTxt(##)) );
         }  
         if not Ast.isStruct( castType ) {
            self.addErrMess( castTypeNode.$pos,
                             "'@@=' cast type can't use class has method -- %s"
                             (castType.getTxt(##)));
         }
      }
   }
   else {
      if castType ~= Ast.builtinTypeString and
          ( castType.$kind == .IF or castType.$kind == .Class )
      {           
         self.addWarnMess( castTypeNode.$pos,
                           "use '@@@' cast for class or interface. -- %s"
                           (castType.getTxt(##)) );
      }
   }
   
   
   if opTxt ~= "@@@" and expType.$nilable and not castType.$nilable {
      self.addErrMess( firstToken.pos,
                       "can't cast from nilable to not nilable  -- %s->%s"
                       (expType.getTxt(##), castType.getTxt(##)) );
   }
   if not Ast.TypeInfo.isMut( expType ) and Ast.TypeInfo.isMut( castType ) {
      castType = self.createModifier( castType, .IMut );
   }

   if castType.canEvalWith( expType, "=", {} ) {
      // "str"@@str のように、意味のないキャストはエラー
      self.addWarnMess( castTypeNode.$pos,
                        "This cast isn't need. (%s <- %s)"
                        ( castType.getTxt( true ## ),
                          expType.getTxt( true ## ) ) );          
   }
   elseif not expType.canEvalWith( castType, "=", {} ) {
      if not Ast.isNumberType( expType ) or not Ast.isNumberType( castType ) {
         // キャスト先の型からキャスト元の型へ互換性がない場合はエラー
         self.addErrMess( castTypeNode.$pos,
                          "This type can't cast. (%s <- %s)"
                          ( castType.getTxt( true ## ),
                            expType.getTxt( true ## ) ) );            
      }
   }

   if opTxt == "@@@" {
      castType = castType.$nilableTypeInfo;
   }

   return Nodes.ExpCastNode.create(
      self.nodeManager, firstToken.pos, [ castType ], exp, opTxt ~= "@@@" );
}


fn TransUnit.analyzeExpCont(
   firstToken: &Parser.Token, mut exp: Nodes.Node, skipFlag: bool ) mut : Nodes.Node {
      let mut nextToken = self.getToken(##);

      if not skipFlag {
         repeat {
            let mut matchFlag = false;
            if nextToken.txt == "[" or nextToken.txt == "$[" {
               matchFlag = true;
               exp = self.analyzeExpRefItem( nextToken, exp, nextToken.txt == "$[" );
               nextToken = self.getToken(##);
            }
            if nextToken.txt == "(" or nextToken.txt == "$(" {
               matchFlag = true;

               exp, nextToken = self.analyzeExpCall( firstToken, exp, nextToken );
            }
         } not matchFlag;

         switch nextToken.txt {
            case "@@", "@@@", "@@=" {
               exp = self.analyzeExpCast( firstToken, nextToken.txt, exp );
               nextToken = self.getToken( ## );
            }
         }
      }

      switch nextToken.txt {
         case "." {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(##), .Field, exp, skipFlag );
         }
         case "$." {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(##), .FieldNil, exp, skipFlag );
         }
         case ".$" {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(##), .Get, exp, skipFlag );
         }
         case "$.$" {
            return self.analyzeExpSymbol(
               firstToken, self.getToken(##), .GetNil, exp, skipFlag );
         }
      }

      self.pushback();
      return exp;

   }


fn TransUnit.analyzeAccessClassField(
   mut classTypeInfo: &Ast.TypeInfo, mode:ExpSymbolMode, token:&Parser.Token ) mut :
   &Ast.TypeInfo, &Ast.SymbolInfo!, bool
{
   switch classTypeInfo.get_kind() {
      case .List {
         classTypeInfo = Ast.builtinTypeList;
      }
      case .Array {
         classTypeInfo = Ast.builtinTypeArray;
      }
      case .Set {
         classTypeInfo = Ast.builtinTypeSet;
      }
   }
   let className = classTypeInfo.getTxt(##);
   let! classScope = classTypeInfo.$scope {
      self.error( "not found field: %s, %s"
                  ( className, classTypeInfo ) );
   };
   
   let mut symbolInfo:&Ast.SymbolInfo! = nil;
   let mut fieldTypeInfo:&Ast.TypeInfo! = nil;
   let mut getterFlag = false;
   if mode == .Get or mode == .GetNil {
      let fieldSymbolInfo = classScope.getSymbolInfo(
         "get_%s" (token.txt), self.scope, false );
      when! fieldSymbolInfo {
         if ( fieldSymbolInfo.get_kind() == .Mtd or fieldSymbolInfo.get_kind() == .Fun )
         {
            let retTypeList = fieldSymbolInfo.$typeInfo.get_retTypeInfoList();
            symbolInfo = fieldSymbolInfo;
            if #retTypeList > 0 {
               fieldTypeInfo = retTypeList[ 1 ];
               when! fieldTypeInfo {
                  if! fieldTypeInfo.applyGeneric(
                     classTypeInfo.createAlt2typeMap(false), self.moduleType )
                  {                 
                     fieldTypeInfo = _exp;
                  }
               }
            }
            getterFlag = true;
         }
      }
   }
   if not symbolInfo {
      // fieldSymbolInfo = classScope.getTypeInfo(
      //     token.txt, self.scope, false );
      // fieldTypeInfo = classScope.getTypeInfoField(
      //    token.txt, true, self.scope );
      symbolInfo = classScope.getSymbolInfoField( token.txt, true, self.scope );
      if not symbolInfo {
         symbolInfo = classScope.getSymbolInfoIfField( token.txt, self.scope );
      }
      when! symbolInfo {
         fieldTypeInfo = symbolInfo.$typeInfo;
      }
   }
   if not fieldTypeInfo {
      foreach val, name in classScope.$symbol2SymbolInfoMap {
         Util.log( "debug: %s, %s" ( name, val ) );
      }
      self.error( "not found field typeInfo: %s.%s" ( className, token.txt ) );
   }
   let typeInfo = unwrap fieldTypeInfo default Ast.builtinTypeNone;

   when! symbolInfo {
      if self.inAnalyzingState( .InitBlock ) or
         self.inAnalyzingState( .ClassMethod ) 
      {     
         let mut errorMess:str! = nil;
         if self.protoFuncMap[ symbolInfo.$typeInfo ] {
            errorMess = "It can't call prototype function from static -- %s" (symbolInfo.$name);
         }
         // elseif symbolInfo.$scope == classTypeInfo.$scope and symbolInfo.$kind == .Mtd {
         //    errorMess = "It can't call the method from __init.-- %s" (symbolInfo.$name);
         // }
         when! errorMess {
            self.addErrMess( token.pos, errorMess );
         }
      }
      elseif self.inAnalyzingState( .Constructor ) {
         let mut errorMess:str! = nil;
         if self.protoFuncMap[ symbolInfo.$typeInfo ] {
            errorMess = "It can't call prototype function from '__init'";
         }
         else {
            if symbolInfo.$typeInfo.$kind == .Method and symbolInfo.$scope == classScope
            {           
               foreach val, name in classScope.$symbol2SymbolInfoMap {
                  if val.$kind == .Mbr and not val.$staticFlag {
                     if not val.$hasValueFlag and not val.$typeInfo.$nilable {
                        errorMess = "Set member(%s) before to access the method-- %s"
                        ( val.$name, symbolInfo.$name );
                        break;
                     }
                  }
               }
            }
         }
         when! errorMess {
            self.addErrMess( token.pos, errorMess );
         }
      }
   }
   
   return typeInfo, symbolInfo, getterFlag;
}

fn TransUnit.dumpComp(
   writer: Writer.Writer, pattern: str,
   symbolInfo: &Ast.SymbolInfo, getterFlag:bool ): bool
{
   let symbol = symbolInfo.$name;
   if pattern == "" or symbol.find( pattern ## ) {
      if getterFlag {
         writer.startParent( "candidate", false );
         let typeInfo = symbolInfo.$typeInfo;
         writer.write( "type", "%s" ( symbolInfo.$kind.$_txt ) );
         switch ( symbolInfo.$kind ) {
            case .Mtd, .Fun {
               writer.write( "displayTxt", "$%s"
                             ( (typeInfo.$rawTxt.gsub( "^get_", "")) ) );
            }  
            case .Mbr {
               writer.write( "displayTxt", "$%s: %s"
                             ( symbolInfo.$name, typeInfo.getTxt(##) ) );
            }
         }
      }
      else {
         writer.startParent( "candidate", false );
         let typeInfo = symbolInfo.$typeInfo;
         writer.write( "type", "%s" ( symbolInfo.$kind.$_txt ) );
         switch ( symbolInfo.$kind ) {
            case .Fun, .Mtd {
               writer.write( "displayTxt", "%s" ( typeInfo.$display_stirng ) );
            }  
            case .Mbr, .Var {
               let mut name = symbolInfo.$name;
               if! let algeTypeInfo = typeInfo@@@Ast.AlgeTypeInfo {
                  if! let valInfo = algeTypeInfo.getValInfo( name ) {
                     if #valInfo.$typeList > 0 {
                        name = "%s(" (name);
                        foreach itemType, index in valInfo.$typeList {
                           if index > 1 {
                              name = name .. ",";
                           }
                           name = name .. itemType.$display_stirng;
                        }
                        name = name .. ")";
                     }
                  }
               }
               writer.write( "displayTxt", "%s: %s"
                             ( name, typeInfo.$display_stirng ) );
            }  
            case .Typ {
               writer.write( "displayTxt",
                             "%s" ( (typeInfo.$display_stirng.gsub( "@", "" ) )) );
            }  
         }
      }
      writer.endElement();
   }
   return true;
}

fn TransUnit.dumpFieldComp(
   writer: Writer.Writer, isPrefixType: bool,
   prefixTypeInfo: &Ast.TypeInfo, pattern: str, getterPattern: str! )
{
   let typeInfo = prefixTypeInfo;
   let! scope = typeInfo.$scope {
      return;
   };

   scope.filterTypeInfoField(
      true, self.scope,
      fn ( symbolInfo: &Ast.SymbolInfo ) : bool {
         if ( isPrefixType ) {
            if not symbolInfo.$staticFlag and
               not symbolInfo.$typeInfo.$staticFlag and
               symbolInfo.$kind ~= .Typ
            {
               // 型のフィールド補完は 非 static を除外
               return true;
            }
         }
         elseif symbolInfo.$staticFlag {
            // インスタンスのフィールド補完は static を除外
            return true;
         }
         let symbol = symbolInfo.$name;
         if symbol ~= "__init" and symbol ~= "__free" and
            symbol ~= "self"
         {
            when! getterPattern {
               if symbolInfo.$kind == .Mtd or symbolInfo.$kind == .Fun {
                  let typeInfo = symbolInfo.$typeInfo;
                  let retList = typeInfo.$retTypeInfoList;
                  if #retList == 1 {
                     return self.dumpComp( writer, getterPattern, symbolInfo, true );
                  }
               }
               return true;
            }
            return self.dumpComp(writer, pattern, symbolInfo, false );
         }
         return true;
      });
}

fn TransUnit.dumpSymbolComp( writer: Writer.Writer, scope: &Ast.Scope, pattern: str ) {
   scope.filterSymbolTypeInfo(
      scope, self.moduleScope,
      fn ( symbolInfo: &Ast.SymbolInfo ) : bool {
         return self.dumpComp(writer, pattern, symbolInfo, false );
      });    
}

form checkCompForm( jsonWriter: Writer.JSON, prefix:str  );

fn TransUnit.checkComp( token:&Parser.Token, callback:checkCompForm ) 
{
   if self.analyzeMode == .Complete and
      self.analyzePos.lineNo == token.pos.lineNo and
      self.analyzePos.column >= token.pos.column and
      self.analyzePos.column <= token.pos.column + #token.txt 
   {
      let mut currentModule = self.parser.getStreamName().gsub( "%.lns", "" );
      currentModule = currentModule.gsub( ".*/", "" );
      let target = self.analyzeModule.gsub( "[^%.]+%.", "" );
      if currentModule == target {
         let mut jsonWriter = new Writer.JSON( io.stdout );
         jsonWriter.startParent( "lunescript", false );
         let prefix = token.txt.gsub( "lune$", "" );
         jsonWriter.write( "prefix", prefix );
         jsonWriter.startParent( "candidateList", true );

         callback( jsonWriter, prefix );

         jsonWriter.endElement();
         jsonWriter.endElement();
         jsonWriter.fin();
         os.exit( 0 );
      }
   }
}


fn TransUnit.checkFieldComp(
   getterFlag:bool, token:&Parser.Token, prefixExp: &Nodes.Node ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   let prefixSymbolInfoList = prefixExp.getSymbolInfo();
   let mut prefixSymbolInfo:&Ast.SymbolInfo! = nil;
   if #prefixSymbolInfoList == 1 {
      prefixSymbolInfo = prefixSymbolInfoList[ 1 ];
   }
   
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         let mut getterPattern:str! = nil;
         if getterFlag {
            getterPattern = "^get_" .. prefix;
         }
         let mut isPrefixType = false;
         if! prefixSymbolInfo {
            isPrefixType = _exp.$kind == .Typ;
         }     
         self.dumpFieldComp(
            jsonWriter, isPrefixType, prefixExp.$expType,
            prefix == "" and "" or "^" .. prefix, getterPattern );
      }
   );
}

fn TransUnit.checkEnumComp(
   token:&Parser.Token, enumTypeInfo: &Ast.EnumTypeInfo ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         let! scope = enumTypeInfo.$scope {
            return;
         };

         let pattern = prefix == "" and "" or "^" .. prefix;
         scope.filterTypeInfoField(
            true, self.scope,
            fn ( symbolInfo: &Ast.SymbolInfo ) : bool {
               if symbolInfo.$kind == .Mbr {
                  return self.dumpComp( jsonWriter, pattern, symbolInfo, false );
               }
               return true;
            } );
      }
   );
}

fn TransUnit.checkAlgeComp(
   token:&Parser.Token, algeTypeInfo: &Ast.AlgeTypeInfo ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         self.dumpFieldComp(
            jsonWriter, true, algeTypeInfo,
            prefix == "" and "" or "^" .. prefix, nil );
      }
   );
}


fn TransUnit.checkSymbolComp( token:&Parser.Token ) 
{
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         self.dumpSymbolComp( jsonWriter, self.scope,
                              prefix == "" and "" or "^" .. prefix );
      }
   );
}

fn TransUnit.analyzeExpField(
   firstToken: &Parser.Token, token: &Parser.Token,
   mode: ExpSymbolMode, prefixExp: &Nodes.Node ) mut : Nodes.Node
{
   let mut accessNil = false;
   if mode == .FieldNil or mode == .GetNil {
      accessNil = true;
   }
   if self.macroMode == .Analyze {
      if accessNil {
         self.helperInfo.useNilAccess = true;
      }
      return Nodes.RefFieldNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeSymbol ],
         token, nil, accessNil, prefixExp );
         //token, accessNil, unwrap prefixExp );
   }

   let mut typeInfo:&Ast.TypeInfo = Ast.builtinTypeStem_;
   let mut prefixExpType = prefixExp.$expType;

   self.checkFieldComp(
      mode == .Get or mode == .GetNil, token, prefixExp );
   
   if accessNil {
      if prefixExpType.$nilable {
         // nil 条件演算で、 prefixExpType が nilable ならば、
         // prefixExpType を非 nilable にセットする
         prefixExpType = prefixExpType.$nonnilableType;

         if prefixExpType.$srcTypeInfo.$kind == .Box {
            self.addErrMess( prefixExp.$pos, "Nilable can't support '$.' access yet" );
         }
      }
      else {
         // prefixExpType が nilable でなければ、
         // nil 判定は不要なので accessNil をクリアする
         accessNil = false;
      }
   }
   if accessNil {
      self.helperInfo.useNilAccess = true;
      switch prefixExpType.get_kind() {
         case .Set, .Enum, .Alge {
         // 現状は set, enum, alge の accessNil はサポートしていない。
            self.addErrMess( firstToken.pos,
                             "%s does not support $." (prefixExpType.getTxt(false##) ) );
         }
      }
   }

   let prefixSymbolInfoList = prefixExp.getSymbolInfo();
   self.checkSymbolHavingValue( prefixExp.$pos, prefixSymbolInfoList );

   let mut getterTypeInfo:&Ast.TypeInfo! = nil;
   let mut symbolInfo:&Ast.SymbolInfo! = nil;
   if prefixExpType.get_kind() == .Class or
      prefixExpType.get_kind() == .Module or
      prefixExpType.get_kind() == .IF or
      prefixExpType.get_kind() == .List or 
      prefixExpType.get_kind() == .Array or
      prefixExpType.get_kind() == .Set or
      prefixExpType.get_kind() == .Box or
      prefixExpType.get_kind() == .Alternate
   {
      let mut getterFlag = false;
      typeInfo, symbolInfo, getterFlag =
         self.analyzeAccessClassField( prefixExpType, mode, token );
      if getterFlag {
         if! symbolInfo {
            getterTypeInfo = _exp.$typeInfo;
         }
      }
   }
   elseif prefixExpType.get_kind() == .Enum or prefixExpType.get_kind() == .Alge {
      let scope = unwrap prefixExpType.$scope;
      let mut fieldName = token.txt;
      let symbolInfoList = prefixExp.getSymbolInfo();
      let mut isTypeSymbol = false;
      if #symbolInfoList > 0 {
         if symbolInfoList[1].$kind == .Typ {
            isTypeSymbol = true;
         }  
      }
      if mode == .Get {
         let moduleType = prefixExpType.getModule();
         if not moduleType.equals( self.moduleType ##) and
            not self.importModule2ModuleInfoCurrent[ moduleType ] {
            // enum の名前を取得するには、そのモジュールのインポートが必要
            self.addErrMess( token.pos, "need to import module -- %s"
                             ( prefixExpType.getModule().getTxt(##) ) );
         }
         fieldName = "get_" .. fieldName;
         if! let funcType = scope.getTypeInfoChild( fieldName ) {

            if funcType.$staticFlag ~= isTypeSymbol {
               self.addErrMess(
                  prefixExp.$pos, "Can't access -- %s, %s" ( fieldName, isTypeSymbol) );
            }
            
            
            let retTypeList = funcType.$retTypeInfoList;
            if #retTypeList == 0 {
               self.addErrMess(
                  token.$pos,
                  "The func (%s) doesn't return value." (funcType.getTxt(##)) );
            }
            else {
               typeInfo = retTypeList[ 1 ];
            }
         }
         else {
            self.addErrMess( token.$pos, "not found -- %s." ( fieldName ) );
            typeInfo = Ast.builtinTypeNone;
         }

         getterTypeInfo = Ast.headTypeInfo;
      }
      else {
         if! scope.getTypeInfoChild( fieldName ) {
            typeInfo = _exp;
            if typeInfo.$kind == .Enum or typeInfo.$kind == .Alge {
               if not isTypeSymbol {
                  self.addErrMess( token.pos, "can't access field -- %s" (token.txt));
               }
            }
         }
         else {
            self.addErrMess( token.pos,
                             "not found field -- %s" (token.txt));
            typeInfo = Ast.builtinTypeInt;
         }
      }
   }
   elseif prefixExpType.get_kind() == .Map {
      let work = prefixExpType.$itemTypeInfoList[1];
      if not work.equals( Ast.builtinTypeString ##) {
         self.addErrMess(
            token.pos,
            "map key type is not str. (%s)" (work.getTxt(##)) );
      }
      typeInfo = prefixExpType.$itemTypeInfoList[2];
      if not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
      return Nodes.ExpRefItemNode.create(
         self.nodeManager, token.pos,
         [ typeInfo ], prefixExp, accessNil, token.txt, nil );
   }
   elseif prefixExpType.equals( Ast.builtinTypeStem ##) {
      return Nodes.ExpRefItemNode.create(
         self.nodeManager, token.pos,
         [ Ast.builtinTypeStem_ ], prefixExp, accessNil, token.txt, nil );
   }
   else {
      self.error( "illegal type -- %s, %s"
                  ( prefixExpType.getTxt(##),
                    prefixExpType.get_kind().$_txt ) );
   }

   if not symbolInfo {
      let prefixScope = prefixExpType.$scope;
      if! prefixScope {
         symbolInfo = _exp.getSymbolInfoField( token.txt, true, self.scope );
      }
   }
   
   when! symbolInfo {
      if #prefixSymbolInfoList == 1 {
         let prefixSymbolInfo = prefixSymbolInfoList[1];
         if prefixSymbolInfo.$kind == .Typ {
            if not symbolInfo.$staticFlag and symbolInfo.$kind ~= .Typ
            {
               // クラスシンボルから、 static でないメンバにアクセスした場合エラー
               self.addErrMess(
                  token.pos, "Type can't access this symbol. -- %s" (symbolInfo.$name) );
            }
         }
         elseif symbolInfo.$staticFlag and symbolInfo.$typeInfo.$kind ~= .Method {
            // インスタンスから、 static メンバにアクセスした場合エラー
            self.addErrMess(
               token.pos, "can't access this symbol. -- %s" (token.txt) );
         }
      };

      if not Ast.TypeInfo.isMut( prefixExpType ) and not symbolInfo.$staticFlag and
         symbolInfo.$kind == .Mtd and symbolInfo.$mutable
      {  
         // オブジェクトが immutable で、
         // mutable な method へのアクセスはエラー
         self.addErrMess(
            token.pos, "can't access mutable method. -- %s" (token.txt) );
      }  
   }

   if accessNil {
      if not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
      self.helperInfo.useNilAccess = true;
   }

   let mut accessSymbolInfo:Ast.AccessSymbolInfo! = nil;
   //let mut canBeLeft:bool! = nil;
   let mut symbolMutMode = typeInfo.$mutMode;
   when! symbolInfo {
      //canBeLeft = _exp.canBeLeft();
      accessSymbolInfo = new Ast.AccessSymbolInfo(
         symbolInfo, prefixExpType, not accessNil );
      switch mode {
         case .Field, .FieldNil {
            symbolMutMode = symbolInfo.$mutMode;
         }
      }
   }

   if not Ast.TypeInfo.isMut( prefixExpType ) and symbolMutMode == .Mut {           
      typeInfo = self.createModifier( typeInfo, .IMut );
   }

   if typeInfo.equals( builtinFunc.list_unpack ##) or
      typeInfo.equals( builtinFunc.array_unpack ##)
   {
      self.helperInfo.useUnpack = true;
   }

   
   if! getterTypeInfo {
      return Nodes.GetFieldNode.create(
         self.nodeManager, firstToken.pos, [ typeInfo ],
         token, accessSymbolInfo, accessNil, prefixExp, _exp );
         //token, canBeLeft, accessNil, prefixExp, _exp );
   }
   else {
      return Nodes.RefFieldNode.create(
         self.nodeManager, firstToken.pos, [ typeInfo ],
         token, accessSymbolInfo, accessNil, prefixExp );
         //token, canBeLeft, accessNil, prefixExp );
   }
}

fn TransUnit.analyzeNewAlge(
   firstToken:&Parser.Token,
   algeTypeInfo:&Ast.AlgeTypeInfo, prefix:&Nodes.Node! ) mut : Nodes.NewAlgeValNode
{
   let symbolToken = self.getSymbolToken( .MustNot_ );

   self.checkAlgeComp( symbolToken, algeTypeInfo );   

   if! let valInfo = algeTypeInfo.getValInfo( symbolToken.txt ) {
      let mut argList:List<&Nodes.Node> = [];
      if #valInfo.$typeList > 0 {
         self.checkNextToken( "(" );
         foreach typeInfo, index in valInfo.$typeList {
            let argExp = self.analyzeExp( false, false, nil, typeInfo );
            argList.insert( argExp );
            if index ~= #valInfo.$typeList {
               self.checkNextToken( "," );
            }
         }
         self.checkNextToken( ")" );
      }

      if! let alt2typeMap, mut newExpNodeList = self.checkMatchType(
         "call", symbolToken.pos, valInfo.$typeList, argList, false, true, nil )
      {
         argList = newExpNodeList;
      }

      if algeTypeInfo.$externalFlag and
         not self.importModule2ModuleInfoCurrent[ algeTypeInfo.getModule().$srcTypeInfo ]
      {  
         let fullname = algeTypeInfo.getFullName(
            self.importModule2ModuleInfo, true );
         self.addErrMess( firstToken.pos, "This module not import -- %s"
                          ( fullname ) );
      }

      
      return Nodes.NewAlgeValNode.create(
         self.nodeManager, firstToken.pos, [ algeTypeInfo ],
         symbolToken, prefix, algeTypeInfo, valInfo, argList );
   }
   else {
      self.addErrMess( symbolToken.pos, "not found Alge -- %s" (symbolToken.txt) );
      return Nodes.NewAlgeValNode.create(
         self.nodeManager, firstToken.pos, [ algeTypeInfo ],
         symbolToken, prefix, algeTypeInfo, new Ast.AlgeValInfo("", []), [] );
   }
}

fn TransUnit.analyzeExpSymbol(
   firstToken: &Parser.Token, token: &Parser.Token,
   mode: ExpSymbolMode, prefixExp: &Nodes.Node!, mut skipFlag: bool ) mut : Nodes.Node
{
   let mut exp:Nodes.Node;
   
   if mode == .Field or mode == .Get or
      mode == .FieldNil or mode == .GetNil
   {
      when! prefixExp {
         exp = self.analyzeExpField( firstToken, token, mode, prefixExp );

         let expType = exp.$expType;
         if prefixExp.$expType.isModule() {
            if! let algeType = expType@@@Ast.AlgeTypeInfo {
               let nextToken = self.getToken(##);
               if nextToken.txt == "." {
                  return self.analyzeNewAlge( firstToken, algeType, exp );
               }  
               self.pushback();
            }
         }
      }
      else {
         Util.err( "prefixExp is nil" );
      }
   }
   elseif mode == .Symbol {
      if self.macroMode == .Analyze {
         exp = Nodes.LiteralSymbolNode.create(
            self.nodeManager, firstToken.pos, [ Ast.builtinTypeSymbol ], token );
      }
      else {
         self.checkSymbolComp( token );

         let! symbolInfo = self.scope.getSymbolTypeInfo(
            token.txt, self.scope, self.moduleScope )
         {
            let mut work = self.scope;
            while true {
               print( work, self.globalScope, Ast.rootScope );
               if work == work.$parent {
                  break;
               }
               work = work.$parent;
            }

            self.scope.filterSymbolTypeInfo(
               self.scope, self.moduleScope,
               fn ( workSymbolInfo:&Ast.SymbolInfo ): bool {
                  print( "sym", workSymbolInfo.$name );
                  return true;
               } );
            
            self.error( "not found type -- " .. token.txt );
         }; 
         let typeInfo = symbolInfo.$typeInfo;

         switch symbolInfo.$kind {
            case .Typ {  
               if! let algeType = typeInfo@@@Ast.AlgeTypeInfo {
                  let nextToken = self.getToken(##);
                  if nextToken.txt == "." {
                     return self.analyzeNewAlge( firstToken, algeType, nil );
                  }  
                  self.pushback();
               }
            }
            case .Var {
               if not symbolInfo.$hasValueFlag {
                  let nsTypeInfo = self.getCurrentNamespaceTypeInfo();
                  if not symbolInfo.$scope.isInnerOf( unwrap nsTypeInfo.$scope ) {
                     self.addErrMess(
                        firstToken.pos,         
                        "This can't access variable have no value -- %s"
                        (symbolInfo.$name) );
                  }
               }
            }           
         }
         
         if typeInfo.equals( Ast.builtinTypeSymbol ##) {
            skipFlag = true;
         }
         if typeInfo.equals( builtinFunc.lune__load ##) {
            self.helperInfo.useLoad = true;
         }
         
         if token.txt == "__func__" {
            let funcTypeInfo = self.getCurrentNamespaceTypeInfo();
            self.has__func__Symbol.add( funcTypeInfo );
         }
         
         exp = Nodes.ExpRefNode.create(
            self.nodeManager, firstToken.pos, [ typeInfo ], token,
            new Ast.AccessSymbolInfo( symbolInfo, nil, true ) );
      }
   }
   elseif mode == .Fn {
      exp = self.analyzeDeclFunc(
         .Func, false, false, .Local, false, nil, token, nil );
   }
   else {
      self.error( "illegal mode -- %s" ( mode ) );
   }

   return self.analyzeExpCont( firstToken, exp, skipFlag );
}

fn TransUnit.analyzeExpOpSet(
   exp: &Nodes.Node, opeToken: &Parser.Token, exp2NodeList:&List<&Nodes.Node> ) mut :
   &Nodes.ExpListNode!
{
   if not exp.canBeLeft() {
      self.addErrMess( exp.$pos,
                       "this node can not be l-value. -- %s"
                       (Nodes.getNodeKindName( exp.$kind ) ) );
   }
   let mut newExpListNode:&Nodes.ExpListNode! = nil;

   let alt2typeMap, newExpNodeList, expTypeList = self.checkMatchType(
      "= operator", opeToken.pos, exp.$expTypeList, exp2NodeList, true, false, nil );

   when! newExpNodeList {
      newExpListNode = self.createExpListNode(
         exp2NodeList[1].$pos, false, newExpNodeList );
   }

   foreach symbolInfo, index in exp.getSymbolInfo() {
      if not symbolInfo.$mutable and symbolInfo.$hasValueFlag
      {
         if self.validMutControl {
            self.addErrMess( opeToken.$pos,
                             "this is not mutable variable. -- %s"
                             ( symbolInfo.$name ) );
         }
      }

      if index <= #expTypeList and
         not symbolInfo.$hasValueFlag and symbolInfo.$kind == .Var
      {
         if symbolInfo.$typeInfo == Ast.builtinTypeEmpty {
            let mut expType = expTypeList[ index ];
            if expType.$kind == .DDD {
               if #expType.$itemTypeInfoList > 0 {
                  expType = expType.$itemTypeInfoList[ 1 ].$nilableTypeInfo;
               }
            }
            symbolInfo.set_typeInfo( expType );
         }
         if not self.tentativeSymbol.regist( symbolInfo ) {
            self.addErrMess( opeToken.$pos,
                             "can't access in this scope. -- %s"
                             ( symbolInfo.$name ) );
         }
      }
      symbolInfo.set_hasValueFlag( true );
   }
   return newExpListNode;
}


fn TransUnit.analyzeExpOp2(
   firstToken: &Parser.Token, mut exp: Nodes.Node, prevOpLevel: int! ) mut : Nodes.Node
{
   while true {
      let nextToken = self.getToken(##);
      let opTxt = nextToken.txt;

      if nextToken.txt == "@@" or nextToken.txt == "@@@" or nextToken.txt ==  "@@=" {
         exp = self.analyzeExpCast( firstToken, opTxt, exp );
      }
      elseif nextToken.kind == Parser.TokenKind.Ope {
         if Parser.isOp2( opTxt ) {
            if opTxt ~= "=" and not exp.canBeRight() {
               self.addErrMess(
                  exp.$pos, "This can't evaluate for '%s' -- %s"
                  ( opTxt, Nodes.getNodeKindName( exp.$kind ) ) );
            }
            let! opLevel = op2levelMap[ opTxt ] {
               self.error( "unknown op -- %s %s" (opTxt, prevOpLevel ) );
            };
            if! prevOpLevel {
               if opLevel <= _exp {
                  self.pushback();
                  return exp;
               }
            }

            let mut expectTypeInfo:&Ast.TypeInfo! = nil;
            {
               let mut prefixExpType = exp.$expType;
               if prefixExpType.$nilable {
                  prefixExpType = prefixExpType.$nonnilableType;
               }
               
               if! prefixExpType.$srcTypeInfo@@@Ast.EnumTypeInfo {
                  expectTypeInfo = _exp;
               }
               if! prefixExpType.$srcTypeInfo@@@Ast.AlgeTypeInfo {
                  expectTypeInfo = _exp;
               }
            }
            
            let mut exp2:&Nodes.Node =
               self.analyzeExp( false, false, opLevel, expectTypeInfo );
            let mut exp2NodeList:&List<&Nodes.Node> = [ exp2 ];

            if not exp2.canBeRight() {
               self.addErrMess(
                  exp2.$pos, "This can't evaluate for '%s' -- %s"
                  ( opTxt, Nodes.getNodeKindName( exp2.$kind ) ) );
            }
            

            if opTxt == "=" {
               // if! let expRefNode = exp@@@Nodes.ExpRefNode {
               //    let symbolInfo = expRefNode.$symbolInfo;
               //    if symbolInfo.$namespaceTypeInfo ~= self.scope.getNamespaceTypeInfo() {
               //       symbolInfo.set_isSetFromClosuer( true );
               //    }
               // }
               
               let workToken = self.getToken(##);
               if workToken.txt == "," {
                  let mut expListNode = self.analyzeExpList( false, false, exp2 ## );
                  exp2 = expListNode;
                  exp2NodeList = expListNode.$expList;
               }
               else {
                  self.pushback();
               }
            }
            let info = { "op": nextToken, "exp1": exp, "exp2": exp2 };

            let mut retType = Ast.builtinTypeNone;

            if not exp2.canBeRight() {
               self.addErrMess( exp2.$pos,
                                "this node can not be r-value. -- %s"
                                (Nodes.getNodeKindName( exp2.$kind ) ) );
            }
            
            let exp1Type = exp.$expType;
            let exp2Type = exp2.$expType;

            if opTxt ~= "=" {
               if exp1Type.$kind == .DDD {
                  self.addErrMess( exp.$pos, "... can't evaluate for %s" (opTxt) );
               }
               elseif exp2Type.$kind == .DDD {
                  self.addErrMess( exp2.$pos, "... can't evaluate for %s" (opTxt) );
               }
            }
            
            switch opTxt {
               case "or" {
                  if exp1Type.equals( exp2Type ##) {
                     retType = exp1Type;
                  }
                  elseif exp1Type.canEvalWith( exp2Type, "=", {}) {
                     retType = exp1Type;
                  }
                  elseif exp2Type.canEvalWith( exp1Type, "=", {}) {
                     retType = exp2Type;
                  }
                  elseif exp2Type.equals( Ast.builtinTypeNil ##) {
                     retType = exp1Type;
                  }
                  elseif exp1Type.equals( Ast.builtinTypeNil ##) {
                     retType = exp2Type;
                  }
                  else {
                     if exp1Type.$nilable or exp2Type.$nilable {
                        retType = Ast.builtinTypeStem_;
                     }
                     else {
                        retType = Ast.builtinTypeStem;
                     }
                  }
               }
               case "and" {
                  let workToken = self.getToken(##);
                  self.pushback();

                  if not exp1Type.equals( Ast.builtinTypeBool ##) and
                     not exp1Type.equals( Ast.builtinTypeStem ##) and
                     not exp1Type.$nilable
                  {  
                     self.addWarnMess( exp.$pos, "this value never be 'false'" );
                  }
                  elseif exp2.$kind == Nodes.NodeKind.$LiteralBool {
                     if! let literal = exp2.getLiteral() {
                        if not Nodes.getLiteralObj( literal ) {
                           self.addErrMess(
                              exp2.$pos, "this value never be 'true'" );
                        }
                     }
                  }
                  
                  if workToken.txt == "or" {
                     // A and B or C の場合、 A and B の演算結果は B の型とし、
                     // B or C の演算結果に処理を廻す。
                     retType = exp2Type;
                  }
                  else {
                     if exp1Type.$nilable {
                        if exp2Type.$nilable {
                           retType = exp2Type;
                        }  
                        else {
                           retType = exp2Type.$nilableTypeInfo;
                        }
                     }
                     elseif exp1Type.equals( Ast.builtinTypeBool ##) or
                        exp2Type.equals( Ast.builtinTypeBool ##)
                     {
                        if exp1Type.canEvalWith( exp2Type, "=", {} ) {
                           retType = exp1Type;
                        }
                        elseif exp2Type.canEvalWith( exp1Type, "=", {} ) {
                           retType = exp2Type;
                        }  
                        else {
                           if exp2Type.$nilable {
                              retType = Ast.builtinTypeStem_;
                           }  
                           else {
                              retType = Ast.builtinTypeStem;
                           }  
                        }  
                     }
                     else {
                        retType = exp2Type;
                     }
                  }
               }
               case "<", ">", "<=", ">=" {
                  if Ast.builtinTypeString.canEvalWith( exp1Type, "=", {} ) and
                     Ast.builtinTypeString.canEvalWith( exp2Type, "=", {} ) or
                      ( Ast.builtinTypeInt.canEvalWith( exp1Type, opTxt, {} ) or
                        Ast.builtinTypeReal.canEvalWith( exp1Type, opTxt, {} ) ) and
                     ( Ast.builtinTypeInt.canEvalWith( exp2Type, opTxt, {} ) or
                        Ast.builtinTypeReal.canEvalWith( exp2Type, opTxt, {} ) )
                  {
                     ;
                  }
                  else {
                     self.addErrMess(
                        nextToken.pos,
                        "no numeric type '%s' or '%s'"
                        ( exp1Type.getTxt(true## ),
                          exp2Type.getTxt(true## ) ) );   
                  }
                  retType = Ast.builtinTypeBool;
               }
               case "~=", "==" {
                  if ( not exp1Type.canEvalWith( exp2Type, opTxt, {} ) and
                       not exp2Type.canEvalWith( exp1Type, opTxt, {} ) )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "not compatible type '%s' or '%s'"
                        ( exp1Type.getTxt(true## ),
                          exp2Type.getTxt(true## ) ) );
                  }
                  if! exp@@@Nodes.NewAlgeValNode {
                     if #_exp.$paramList > 0 {
                        self.addErrMess( exp.$pos, "can't compare alge." );
                     }
                  }
                  if! exp2@@@Nodes.NewAlgeValNode {
                     if #_exp.$paramList > 0 {
                        self.addErrMess( exp2.$pos, "can't compare alge." );
                     }
                  }
                  if exp1Type.equals( Ast.builtinTypeBool ##) and
                     exp2Type.equals( Ast.builtinTypeBool ##) and
                     ( exp.$kind == Nodes.NodeKind.$LiteralBool or
                       exp2.$kind == Nodes.NodeKind.$LiteralBool )
                  {
                     self.addWarnMess( exp.$pos, "this operation is deprecated." );
                  }
                  
                  retType = Ast.builtinTypeBool;
               }
               case "^", "|", "~", "&", "|<<", "|>>" {
                  if self.targetLuaVer.$hasBitOp == .Cant {
                     self.addErrMess( nextToken.pos,
                                      "this lua version can't use bit operand." );
                  }
                  
                  if not Ast.builtinTypeInt.canEvalWith( exp1Type, opTxt, {} ) or
                     not Ast.builtinTypeInt.canEvalWith( exp2Type, opTxt, {} )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no int type '%s' or '%s'"
                        ( exp1Type.getTxt(##), exp2Type.getTxt(##) ) );
                  }
                  retType = Ast.builtinTypeInt;
               }
               case ".." {
                  if not exp1Type.equals( Ast.builtinTypeString ##) or
                     not exp1Type.equals( Ast.builtinTypeString ##)
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no string type '%s' or '%s'"
                        ( exp1Type.getTxt(##), exp2Type.getTxt(##) ) );
                  }
                  retType = Ast.builtinTypeString;
               }
               case "+", "-", "*", "/", "%" {
                  if ( not Ast.builtinTypeInt.canEvalWith( exp1Type, opTxt, {} ) and
                       not Ast.builtinTypeReal.canEvalWith( exp1Type, opTxt, {} ) ) or
                      ( not Ast.builtinTypeInt.canEvalWith( exp2Type, opTxt, {} ) and
                        not Ast.builtinTypeReal.canEvalWith( exp2Type, opTxt, {} ) )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no numeric type '%s' or '%s'"
                        ( exp1Type.getTxt(##), exp2Type.getTxt(##) ) );
                  }

                  if exp1Type.equals( Ast.builtinTypeReal ##) or
                     exp2Type.equals( Ast.builtinTypeReal ##)
                  {
                     retType = Ast.builtinTypeReal;
                  }
                  else {
                     retType = Ast.builtinTypeInt;
                  }
               }
               case "=" {
                  if! self.analyzeExpOpSet( exp, nextToken, exp2NodeList ) {
                     exp2 = _exp;
                  }
               }
               default {
                  self.error( "unknown op " .. opTxt );
               }
            }

            exp = Nodes.ExpOp2Node.create(
               self.nodeManager, firstToken.pos, [ retType ], nextToken, exp, exp2 );
         }
         else {
            self.error( "illegal op" );
         }
      }
      else {
         self.pushback();
         return exp;
      }
   }
}

fn TransUnit.analyzeExpMacroStat( firstToken: &Parser.Token ) mut : Nodes.ExpMacroStatNode {
   let mut expStrList: List<&Nodes.Node> = [];

   self.checkNextToken( "{" );

   let mut braceCount = 0;
   let mut prevToken = firstToken;
   while true {
      let token = self.getToken(##);

      if token.txt == ",," or token.txt == ",,," or token.txt == ",,,," {
         let mut exp = self.analyzeExp( false, true, unwrap op1levelMap[ token.txt ] ## );

         let nextToken = self.getToken(##);
         if nextToken.txt ~= "~~" {
            self.pushback();
         }


         let mut format = token.txt == ",,," and "' %s '" or '"\'%s\'"';

         if token.txt == ",," {
            if! let refNode = exp@@@Nodes.ExpRefNode {
               let refToken = refNode.get_token();
               let macroInfo = self.symbol2ValueMapForMacro[ refToken.txt ];
               when! macroInfo {
                  let valType = macroInfo.typeInfo;
                  if valType.equals( Ast.builtinTypeSymbol ##) or
                     valType.equals( Ast.builtinTypeStat ##)
                  {
                     format = "' %s '";
                  }
                  elseif valType.$kind == .List and
                     valType.$itemTypeInfoList[1].equals( Ast.builtinTypeStat ##)
                  {
                     format = "' %s '";
                     exp = Nodes.ExpMacroStatListNode.create(
                        self.nodeManager, token.pos, [ Ast.builtinTypeString ], exp );
                  }
                  elseif Ast.builtinTypeString.equals( valType ##) {
                     //
                  }
                  else {
                     self.addErrMess(
                        refToken.pos,           
                        "not support ,, -- %s" (valType.getTxt(##)) );
                  }
               }  
               else {
                  if exp.$expType.equals( Ast.builtinTypeInt ##) or
                     exp.$expType.equals( Ast.builtinTypeReal ##)
                  {
                     format = "'%s' ";
                  }
                  elseif exp.$expType.equals( Ast.builtinTypeStat ##) {
                     format = "' %s '";
                  }
               }
            }
         }
         let newToken = new Parser.Token(
            Parser.TokenKind.Str, format, token.pos, token.consecutive ## );
         let literalStr = Nodes.LiteralStringNode.create(
            self.nodeManager, token.pos, [ Ast.builtinTypeString ], newToken, [ exp ] );
         expStrList.insert( literalStr );
      }
      else {
         if token.txt == "{" {
            braceCount = braceCount + 1;
         }
         elseif token.txt == "}" {
            if braceCount == 0 {
               break;
            }
            braceCount = braceCount - 1;
         }

         let mut format = "' %s'";
         let mut consecutive;
         if prevToken == firstToken or token.consecutive {
            format = "'%s'";
            consecutive = true;
         }
         else {
            consecutive = false;
         }
         let newToken = new Parser.Token(
            token.kind, string.format( format, token.txt ), token.pos, consecutive ## );
         let literalStr = Nodes.LiteralStringNode.create(
            self.nodeManager, token.pos, [ Ast.builtinTypeString ], newToken, [] );
         expStrList.insert( literalStr );
      }
      prevToken = token;
   }

   return Nodes.ExpMacroStatNode.create(
      self.nodeManager, firstToken.pos, [ Ast.builtinTypeStat ], expStrList );
}


fn TransUnit.analyzeSuper( firstToken:&Parser.Token ) mut : Nodes.Node {

   self.checkNextToken( "(" );

   let nextToken = self.getToken(##);
   let mut expList:Nodes.ExpListNode! = nil;
   if nextToken.txt ~= ")" {
      self.pushback();
      expList = self.analyzeExpList( false, false ## );
      self.checkNextToken( ")" );
   }

   self.checkNextToken( ";" );


   let classType = self.getCurrentClass();
   
   let currentFunc = self.getCurrentNamespaceTypeInfo();
   if currentFunc.$kind == .Method {
      let superType = classType.get_baseTypeInfo();
      if superType.equals( Ast.headTypeInfo ##) {
         self.addErrMess( firstToken.pos, "This class doesn't have super-class." );
      }     
      else {
         if currentFunc.$rawTxt == "__init" {
            let! superScope = superType.$scope {
               self.error( "not found super scope" );
            };    
            let! superCtorType = superScope.getTypeInfoChild( "__init" ) {
               self.error( "not found super '__init'" );
            }; 
            self.checkMatchValType(
               firstToken.$pos, superCtorType, expList, [], classType );
            return Nodes.ExpCallSuperNode.create(
               self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ],
               superType, superCtorType, expList );
         }
         else {
            if! let superFunc = (unwrap superType.$scope).getTypeInfoField(
               currentFunc.$rawTxt, true, self.scope )
            {
               if superFunc.$abstractFlag {
                  self.addErrMess( firstToken.pos, "super is abstract." );
               }
               self.checkMatchValType(
                  firstToken.$pos, superFunc, expList, [], classType );
               return Nodes.ExpCallSuperNode.create(
                  self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ],
                  superType, superFunc, expList );
            }
            self.addErrMess( firstToken.pos, "this is not override method." );
            return self.createNoneNode( firstToken.pos );
         }
      }
   }

   self.addErrMess( firstToken.pos, "super can't call here." );
   return self.createNoneNode( firstToken.pos );
}

fn TransUnit.analyzeUnwrap( firstToken: &Parser.Token ) mut : Nodes.Node {
   let nextToken, continueFlag = self.getContinueToken();

   if not continueFlag or nextToken.txt ~= "!" {
      self.pushback();
      self.pushbackToken( firstToken );
      let exp = self.analyzeExp( false, false ## );
      self.checkNextToken( ";" );
      if not exp.$expType.$nilable {
         self.addErrMess( exp.$pos, "this value is not nilable." );
      }
      return Nodes.StmtExpNode.create(
         self.nodeManager, nextToken.pos, [ Ast.builtinTypeNone ], exp );
   }

   self.pushback();
   return self.analyzeDeclVar( .Unwrap, .Local, firstToken );
}

fn TransUnit.analyzeExpUnwrap( firstToken: &Parser.Token ) mut : Nodes.Node {
   //   let expNode = self.analyzeExp( false, opTopLevel ## );
   let expNode = self.analyzeExp( false, true ## );
   let nextToken = self.getToken(##);
   let mut insNode: Nodes.Node! = nil;
   if nextToken.txt == "default" {
      insNode = self.analyzeExp( false, false ## );
   }
   else {
      self.pushback();
   }

   let mut unwrapType = Ast.builtinTypeStem_;

   let expType = expNode.$expType;
   if not expType.$nilable {
      unwrapType = expType;
      self.addErrMess( expNode.$pos,
                       "this exp is not nilable -- %s" (expType.getTxt(##)) );
   }
   elseif expType.$kind == .DDD {
      if #expType.$itemTypeInfoList > 0 {
         unwrapType = expType.$itemTypeInfoList[ 1 ];
      }
      else {
         unwrapType = Ast.builtinTypeStem;
      }
   }
   else {
      unwrapType = expType.$nonnilableType;
   }

   when! insNode {
      let insType = insNode.$expType;

      if insType.$nilable {
         self.addErrMess( insNode.$pos,
                          "default can't use nilable -- %s" (insType.getTxt(##)) );
      }
      
      let mut alt2type = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
      if not unwrapType.canEvalWith( insType, "=", alt2type )
      {
         if not insType.canEvalWith( unwrapType, "=", alt2type ) {
            unwrapType = Ast.builtinTypeStem;
            // self.addErrMess(
            //    insNode.$pos,
            //    "unmatch type: %s <- %s"
            //    ( unwrapType.getTxt(true##), insType.getTxt(true ## ) ) );
         }
         else {
            unwrapType = insType;
         }
      }
      //unwrapType = insType;
   }

   self.helperInfo.useUnwrapExp = true;

   return Nodes.ExpUnwrapNode.create(
      self.nodeManager, firstToken.pos, [ unwrapType ], expNode, insNode );
}


fn TransUnit.analyzeExp(
   allowNoneType: bool, skipOp2Flag: bool,
   prevOpLevel: int!, expectType:&Ast.TypeInfo! ) mut : Nodes.Node
{
   let firstToken = self.getToken(##);
   
   fn processsExpectExp( token:&Parser.Token, orgExpectType:&Ast.TypeInfo ): Nodes.Node {
      if! let enumTyepInfo = orgExpectType.$srcTypeInfo@@@Ast.EnumTypeInfo {
         let nextToken = self.getToken(##);
         self.checkEnumComp( nextToken, enumTyepInfo );
         
         if! let valInfo = enumTyepInfo.getEnumValInfo( nextToken.txt ) {
            if orgExpectType.$externalFlag and
               not self.importModule2ModuleInfoCurrent[
                  orgExpectType.getModule().$srcTypeInfo ]
            {  
               let fullname = orgExpectType.getFullName(
                  self.importModule2ModuleInfo, true );
               self.addErrMess( token.pos, "This module not import -- %s"
                                ( fullname ) );
            }  
            let mut exp:Nodes.Node = Nodes.ExpOmitEnumNode.create(
               self.nodeManager, token.pos, [ enumTyepInfo ],
               nextToken, valInfo, enumTyepInfo );
            return self.analyzeExpCont( firstToken, exp, false );
         }

         self.error( "illegal enum val -- %s.%s"
                     (orgExpectType.getTxt(##), nextToken.txt) );
      }
      if! let algeTyepInfo = orgExpectType.$srcTypeInfo@@@Ast.AlgeTypeInfo {
         return self.analyzeNewAlge( firstToken, algeTyepInfo, nil );
      }

      self.error( "illegal type for '.' -- %s" (orgExpectType.getTxt(##) ) );
   }

   fn processsNewExp( token:&Parser.Token ): Nodes.Node {
      let mut exp:Nodes.Node = self.analyzeRefType( .Local, false );

      let mut classTypeInfo = exp.$expType;
      switch classTypeInfo.$kind {
         case .Class, .IF {
            if classTypeInfo.equals( Ast.builtinTypeString## ) {
               self.error( "'new' can't use this type -- %s" (classTypeInfo.getTxt(##)));
            }
         }
         default {
            self.error( "'new' can't use this type -- %s" (classTypeInfo.getTxt(##)));
         }
      }
      
      if classTypeInfo.$externalFlag {
         switch classTypeInfo.$accessMode {
            case .Pri, .Local {
               self.addErrMess( token.pos, "Can't access -- %s"
                                (classTypeInfo.$accessMode.$_txt ) );
            }
         }
      }
      if classTypeInfo.$abstractFlag {
         self.addErrMess( token.pos, "abstract class can't new" );
      }
      
      let classScope = classTypeInfo.get_scope();
      let! initTypeInfo = (unwrap classScope).getTypeInfoChild( "__init" ) {
         self.error( "not found __init" );
      }; 
      
      self.checkNextToken( "(" );
      let nextToken = self.getToken(##);
      let mut argList: Nodes.ExpListNode! = nil;
      
      if nextToken.txt ~= ")" {
         self.pushback();
         argList = self.analyzeExpList(
            false, false, nil, initTypeInfo.$argTypeInfoList ## );
         self.checkNextToken( ")" );
      }

      if initTypeInfo.$accessMode == .Pub or
          ( initTypeInfo.$accessMode == .Pro and
            self.scope.getClassTypeInfo().isInheritFrom( classTypeInfo, nil ) ) or
          ( self.scope.getClassTypeInfo() == classTypeInfo )
      {
         // pub、 pro でサブクラス、 pri で同じクラスの場合はアクセス可能
      }
      else {
         self.addErrMess(
            token.pos,
            "can't access to __init of %s" (classTypeInfo.getTxt(##)));
      }

      let alt2type = self.checkMatchValType(
         exp.$pos, initTypeInfo, argList,
         classTypeInfo.$itemTypeInfoList, classTypeInfo );

      if #classTypeInfo.$itemTypeInfoList > 0 {
         if classTypeInfo.$itemTypeInfoList[1].$kind == .Alternate {
            let mut genTypeList:List<&Ast.TypeInfo> = [];
            let mut detect = true;
            foreach altType in classTypeInfo.$itemTypeInfoList {
               if! alt2type[ altType ] {
                  genTypeList.insert( _exp );
               }
               else {
                  self.addErrMess( token.pos, "Can't new generic class. -- %s"
                                   (classTypeInfo.getTxt(##) ));
                  detect = false;
                  break;
               }
            }

            if detect {
               classTypeInfo = Ast.NormalTypeInfo.createGeneric(
                  classTypeInfo, genTypeList, self.moduleType );
            }
         }
      }
      
      exp = Nodes.ExpNewNode.create(
         self.nodeManager, firstToken.pos, [ classTypeInfo ], exp, argList );
      exp = self.analyzeExpCont( firstToken, exp, false );

      return exp;
   }

   fn processOp1( token:&Parser.Token ): Nodes.Node, bool {
      // 単項演算
      if token.txt == "`" {
         return self.analyzeExpMacroStat( token ), false;
      }  

      let mut exp = self.analyzeExp( false, true, unwrap op1levelMap[ token.txt] ##);
      let mut typeInfo = Ast.builtinTypeNone;
      let mut macroExpFlag = false;
      let expType = exp.$expType;

      if expType.$kind == .DDD {
         self.addErrMess( exp.$pos, "... can't evaluate for '%s'." (token.txt) );
      }

      switch ( token.txt ) {
         case "-" {
            if not expType.equals( Ast.builtinTypeInt ##) and
               not expType.equals( Ast.builtinTypeReal ##)
            {
               self.addErrMess(
                  token.pos,
                  'unmatch type for "-" -- %s' ( expType.getTxt(##) ) );
            }
            typeInfo = expType;
         }
         case "#" {
            if expType.$kind ~= .List and
               expType.$kind ~= .Array and
               not Ast.builtinTypeString.canEvalWith( expType, "=", {} )
            {  
               self.addErrMess(
                  token.pos,
                  'unmatch type for "#" -- %s' ( expType.getTxt(##) ) );
            }  
            typeInfo = Ast.builtinTypeInt;
         }  
         case "not" {
            typeInfo = Ast.builtinTypeBool;
            
            if not expType.$nilable and
               not expType.equals( Ast.builtinTypeBool ##) and
               not expType.equals( Ast.builtinTypeStem ##) and
               expType.$kind ~= .DDD
            {  
               self.addErrMess( token.pos, "this 'not' operand never be false" );
            }  
         }  
         case ",," {
            macroExpFlag = true;
         }  
         case ",,," {
            macroExpFlag = true;
            if not expType.equals( Ast.builtinTypeString ##) {
               self.error( "unmatch ,,, type, need string type" );
            }  
            typeInfo = Ast.builtinTypeSymbol;
         }  
         case ",,,," {
            macroExpFlag = true;
            if not expType.equals( Ast.builtinTypeSymbol ##) {
               self.error( "unmatch ,,, type, need symbol type" );
            }  
            typeInfo = Ast.builtinTypeString;
         }  
         case "`" {
            typeInfo = Ast.builtinTypeNone;
         }  
         case "~" {
            if not expType.equals( Ast.builtinTypeInt ##) {
               self.addErrMess(
                  token.pos,
                  'unmatch type for "~" -- %s' ( expType.getTxt(##) ) );
            }  
            typeInfo = Ast.builtinTypeInt;
         }  
         default {
            self.error( "unknown op1" );
         }  
      }  

      if macroExpFlag {
         let nextToken = self.getToken(##);
         if nextToken.txt ~= "~~" {
            self.pushback();
         }  
      }  

      exp = Nodes.ExpOp1Node.create(
         self.nodeManager, firstToken.pos, [ typeInfo ], token, self.macroMode, exp );
      return self.analyzeExpOp2( firstToken, exp, prevOpLevel ), true;
   }

   
   let mut token = firstToken;
   let mut exp:Nodes.Node = self.createNoneNode( firstToken.pos );

   if token.txt == "##" {
      if allowNoneType {
         self.addErrMess( token.pos, "illeal syntax -- ##" );
      }
      return Nodes.AbbrNode.create(
         self.nodeManager, token.pos, [ Ast.builtinTypeAbbr ] );
   }
   
   if token.kind == Parser.TokenKind.Dlmt {
      if token.txt == "." {
         when! expectType {
            let mut orgExpectType = expectType;
            if orgExpectType.$nilable {
               orgExpectType = orgExpectType.$nonnilableType;
            }
            exp = processsExpectExp( token, orgExpectType );
         }
         else {
            self.error( "illegal '.'" );
         }
      }
      elseif token.txt == "..." {
         return Nodes.ExpDDDNode.create(
            self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], token );
      }
      elseif token.txt == '[' or token.txt == '[@' {
         exp = self.analyzeListConst( token );
      }
      elseif token.txt == '(@' {
         exp = self.analyzeSetConst( token );
      }  
      elseif token.txt == '{' {
         exp = self.analyzeMapConst( token );
      }  
      elseif token.txt == "(" {
         exp = self.analyzeExp( false, false ## );
         self.checkNextToken( ")" );
         exp = Nodes.ExpParenNode.create(
            self.nodeManager, firstToken.pos, [ exp.$expType ], exp );
         exp = self.analyzeExpCont( firstToken, exp, false );
      }
   }  

   if token.txt == "new" {
      exp = processsNewExp( token );
   }  

   if token.kind == Parser.TokenKind.Ope and Parser.isOp1( token.txt ) {
      let mut workExp, fin = processOp1( token );
      if fin {
         return workExp;
      }
      exp = workExp;
   }

   if token.kind == Parser.TokenKind.Int {
      exp = Nodes.LiteralIntNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeInt ],
         token, (unwrap tonumber( token.txt ## ) default 0)@@int );
   }  
   elseif token.kind == Parser.TokenKind.Real {
      exp = Nodes.LiteralRealNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeReal ],
         token, (unwrap tonumber( token.txt ## ) default 0.0));
   }  
   elseif token.kind == Parser.TokenKind.Char {
      let mut num = 0;
      if #(token.txt) == 1 {
         num = token.txt.byte( 1 ## );
      }  
      else {
         num = unwrap quotedChar2Code[ token.txt.sub( 2, 2 ) ];
      }  
      exp = Nodes.LiteralCharNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeChar ], token, num );
   }  
   elseif token.kind == Parser.TokenKind.Str {
      let mut nextToken = self.getToken(##);
      let mut formatArgList:&List<&Nodes.Node> = [];
      if nextToken.txt == "(" {
         let argNodeList = self.analyzeExpList( false, false, nil ## );
         self.checkNextToken( ")" );
         nextToken = self.getToken(##);

         formatArgList = argNodeList.$expList;

         self.checkStringFormat( token.pos, token.txt, argNodeList.$expTypeList );
      }  

      exp = Nodes.LiteralStringNode.create(
         self.nodeManager, firstToken.pos,
         [ Ast.builtinTypeString ], token, formatArgList );
      token = nextToken;
      if token.txt == "[" or token.txt == "$[" {
         exp = self.analyzeExpRefItem( token, exp, token.txt == "$[" );
      }  
      else {
         self.pushback();
      }  
   }  
   elseif token.kind == Parser.TokenKind.Symb and token.txt == "__line__" {
      let mut lineNo = token.pos.lineNo;
      if self.macroMode == .Expand {
         lineNo = self.macroCallLineNo;
      }
      exp = Nodes.LiteralIntNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeInt ],
         new Parser.Token( .Int, "%d" (lineNo),
                           token.pos, false, nil ), token.pos.lineNo );
   }  
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "fn" {
      exp = self.analyzeExpSymbol( firstToken, token, .Fn, nil, false );
   }  
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "unwrap" {
      exp = self.analyzeExpUnwrap( token );
   }  
   elseif token.kind == Parser.TokenKind.Symb {
      exp = self.analyzeExpSymbol(
         firstToken, token, .Symbol, nil, false );
      let symbolInfoList = exp.getSymbolInfo();
      if #symbolInfoList == 1 {
         let symbolInfo = symbolInfoList[ 1 ];
         if symbolInfo.$kind == .Typ {
            exp = self.analyzeRefTypeWithSymbol( .Local, false, false, false, exp );
            let workToken = self.getToken(##);
            if workToken.txt == "." {
               exp = self.analyzeExpSymbol(
                  firstToken, self.getToken(##), .Field, exp, false );
            }
            else {
               self.pushback();
            }
         }
         else {
            self.scope.accessSymbol( self.moduleScope, symbolInfo );
         }
      }
   }  
   elseif token.kind == Parser.TokenKind.Type {
      let! symbolTypeInfo = Ast.sym2builtInTypeMap[ token.txt ] {
         self.error( "unknown type -- %s" ( token.txt ) );
      }; 
      exp = Nodes.ExpRefNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], token,
         new Ast.AccessSymbolInfo( symbolTypeInfo, nil, false ) );
   }  
   elseif token.kind == Parser.TokenKind.Kywd and
       ( token.txt == "true" or token.txt == "false" )
   {  
      exp = Nodes.LiteralBoolNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeBool ], token );
   }  
   elseif token.kind == Parser.TokenKind.Kywd and
       ( token.txt == "nil" or token.txt == "null" )
   {  
      exp = Nodes.LiteralNilNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeNil ] );
   }

   if exp.$kind == Nodes.NodeKind.$None {
      self.error( "illegal exp" );
   }

   if skipOp2Flag {
      return exp;
   }

   return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}
