/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

submodule owner lune.base.TransUnit;

fn TransUnit.analyzeExpList( skipOp2Flag: bool ): Ast.ExpListNode {
   let expList:Ast.Node[] = [];
   let pos:Parser.Position! = nil;

   let expTypeList:Ast.TypeInfo[] = [];
   repeat {
      let exp = self.analyzeExp( skipOp2Flag, 0 );
      if not pos {
         pos = exp.$pos;
      } 
      expList.insert( exp );
      expTypeList.insert( exp.$expType );
      let token = self.getToken();
   } token.txt ~= ",";

   self.pushback();

   return new Ast.ExpListNode( unwrap pos default new Parser.Position( 0, 0 ),
                               expTypeList, expList );
}

fn TransUnit.analyzeListConst( token: Parser.Token ): Ast.Node {
   let nextToken = self.getToken();
   let expList:Ast.ExpListNode! = nil;
   let itemTypeInfo = Ast.builtinTypeNone;
   if nextToken.txt ~= "]" {
      self.pushback();
      expList = self.analyzeExpList();
      self.checkNextToken( "]" );
      let nodeList: Ast.Node[] = (unwrap expList).$expList;
      foreach exp in nodeList {
         let expType = exp.$expType;
         if itemTypeInfo == Ast.builtinTypeNone {
            itemTypeInfo = expType;
         }  
         elseif not itemTypeInfo.isSettableFrom( expType ) {
            if expType == Ast.builtinTypeNil {
               itemTypeInfo = unwrap itemTypeInfo.$nilableTypeInfo;
            }   
            elseif expType.$nilable {
               itemTypeInfo = Ast.builtinTypeStem_;
            }   
            else {
               itemTypeInfo = Ast.builtinTypeStem;
            }   
         }  
      } 
   }
   let kind = Ast.nodeKindLiteralArray;
   let typeInfoList = [ Ast.builtinTypeNone ];
   if token.txt == '[' {
      kind = Ast.nodeKindLiteralList;
      typeInfoList = [ Ast.NormalTypeInfo.createList( "local", self.getCurrentClass(),
                                                      [ itemTypeInfo ] ) ];
      return new Ast.LiteralListNode( token.pos, typeInfoList, expList );
   }
   else {
      typeInfoList = [ Ast.NormalTypeInfo.createArray( "local", self.getCurrentClass(),
                                                       [ itemTypeInfo ] ) ];                         
      return new Ast.LiteralArrayNode( token.pos, typeInfoList, expList );
   }
   //return self.createNode( kind, token.pos, typeInfo, expList );
}

fn TransUnit.analyzeMapConst( token: Parser.Token ): Ast.LiteralMapNode {
   let nextToken:Parser.Token = self.getToken();
   let map:Map<Ast.Node,Ast.Node> = {};
   let pairList:Ast.PairItem[] = [];
   let keyTypeInfo = Ast.builtinTypeNone;
   let valTypeInfo = Ast.builtinTypeNone;


   fn getMapKeyValType(
      pos: Parser.Position,
      keyFlag: bool, typeInfo:Ast.TypeInfo, expType:Ast.TypeInfo ): Ast.TypeInfo
   {   
      if expType.$nilable {
         if keyFlag {
            self.addErrMess(
               pos, "map key can't set a nilable -- %s" (expType.getTxt()) );
         }   
         if expType == Ast.builtinTypeNil {
            return typeInfo;
         }  
         expType = unwrap expType.$orgTypeInfo;
      } 
      if not typeInfo.isSettableFrom( expType ) {
         if typeInfo ~= Ast.builtinTypeNone {
            typeInfo = Ast.builtinTypeStem;
         }  
         else {
            typeInfo = expType;
         }  
      } 
      return typeInfo;
   }
   
   while true {
      if nextToken.txt == "}" {
         break;
      } 
      self.pushback();

      let key = self.analyzeExp();
      keyTypeInfo = getMapKeyValType( key.$pos, true, keyTypeInfo, key.$expType );

      self.checkNextToken( ":" );

      let val = self.analyzeExp();
      valTypeInfo = getMapKeyValType( val.$pos, false, valTypeInfo, val.$expType );

      //pairList.insert( { "key": key, "val": val } );
      pairList.insert( new Ast.PairItem( key, val ) );
      map[ key ] = val;
      nextToken = self.getToken();
      if nextToken.txt ~= "," {
         break;
      } 
      nextToken = self.getToken();
   }

   let typeInfo = Ast.NormalTypeInfo.createMap(
      "local", self.getCurrentClass(), keyTypeInfo, valTypeInfo );

   self.checkToken( nextToken, "}" );
   // return self.createNode( nodeKindLiteralMap, token.pos,[ typeInfo ],
   //                      { "map": map, "pairList": pairList } );
   return new Ast.LiteralMapNode( token.pos,[ typeInfo ], map, pairList );
}

fn TransUnit.analyzeExpRefItem( token: Parser.Token, exp: Ast.Node ): Ast.Node {
   let indexExp = self.analyzeExp();
   self.checkNextToken( "]" );

   let typeInfo = Ast.builtinTypeStem_;
   let expType = exp.$expType;
   if expType {
      if expType.$kind == Ast.TypeInfoKindMap {
         typeInfo = expType.get_itemTypeInfoList()[2];
         if typeInfo ~= Ast.builtinTypeStem_ and not typeInfo.$nilable {
            typeInfo = typeInfo.$nilableTypeInfo;
         }  
      } 
      elseif expType.$kind == Ast.TypeInfoKindArray or
         expType.$kind == Ast.TypeInfoKindList
      { 
         typeInfo = expType.get_itemTypeInfoList()[1];
      } 
      elseif expType == Ast.builtinTypeString {
         typeInfo = Ast.builtinTypeInt;
      } 
      else {
         self.addErrMess( exp.$pos, "could not access with []." );
      } 
   }
   if not typeInfo {
      Util.errorLog( "illegal type" );
   }

   return new Ast.ExpRefItemNode( token.pos, [ typeInfo ], exp, indexExp );
}


fn TransUnit.checkMatchValType(
   pos: Parser.Position, funcTypeInfo:Ast.TypeInfo, expList:Ast.ExpListNode!,
   genericTypeList: Ast.TypeInfo[] )
{
   let argTypeList = funcTypeInfo.$argTypeInfoList;
   switch funcTypeInfo {
      case typeInfoListInsert {
         argTypeList = genericTypeList;
      } 
      case typeInfoListRemove {
      } 
   }
   
   if! expList {
      let expNodeList = _exp.$expList;
      foreach expNode, index in expNodeList {
         if #argTypeList < index {
            self.addErrMess( pos,
                             "%s: over argument. expect:%d, actual:%d"
                             ( funcTypeInfo.getTxt(),
                               #argTypeList, #expNodeList) );
            break;
         }  
         let argType = argTypeList[ index ];
         let expType = expNode.$expType;
         if #argTypeList == index {
            if argType ~= Ast.builtinTypeDDD {
               if not argType.isSettableFrom( expType ) {
                  self.addErrMess(
                     expNode.$pos,                           
                     "%s: argument(%d) type mismatch %s <- %s"
                     ( funcTypeInfo.getTxt(), index,
                       argType.getTxt(), expType.getTxt()));      
               }    
            }   
            break;
         }  
         elseif #expNodeList == index {
            // 最終実引数処理
            if expType == Ast.builtinTypeDDD {
               for argIndex = index, #argTypeList {
                  let workArgType = argTypeList[ argIndex ];
                  if not workArgType.isSettableFrom( Ast.builtinTypeStem_ ) {
                     self.addErrMess(
                        expNode.$pos,                           
                        "%s: argument(%d) type mismatch %s <- %s"
                        ( funcTypeInfo.getTxt(), argIndex,
                          workArgType.getTxt(), expType.getTxt()));
                  }     
               }    
            }   
            else {
               for argIndex = index, #argTypeList {
                  let argTypeInfo = argTypeList[ argIndex ];
                  if not argTypeInfo.isSettableFrom( expType ) {
                     self.addErrMess(
                        expNode.$pos,
                        "%s: argument(%d) type mismatch %s <- %s"
                        ( funcTypeInfo.getTxt(), argIndex,
                          argTypeInfo.getTxt(), expType.getTxt() ) );
                  }     
                  expType = Ast.builtinTypeNil;
               }    
            }   
            break;
         }  
         if not argType.isSettableFrom( expType ) {
            self.addErrMess(
               expNode.$pos,                           
               "%s: argument(%d) type mismatch %s <- %s"
               ( funcTypeInfo.getTxt(), index,
                 argType.getTxt(), expType.getTxt()));
         }  
      } 
   }
   else {
      if #argTypeList ~= 0 {
         // 現状引数省略は無視
         // self.addErrMess( nextToken.pos,
         //                  "argument is shortness" );
      } 
   }
}

class MacroPaser extend Parser.Parser {
   let tokenList: Parser.Token[];
   let pos: int;
   let name: str;

   pub fn __init( tokenList: Parser.Token[], name: str ) {
      self.pos = 1;
      self.tokenList = tokenList;
      self.name = name;
   }

   pub override fn getToken() : Parser.Token! {
      if #self.tokenList < self.pos {
         return nil;
      } 
      let token = self.tokenList[ self.pos ];
      self.pos = self.pos + 1;

      // Util.errorLog( "getToken: %s" (token.txt) );
      
      return token;
   }
   pub override fn getStreamName(): str {
      return self.name;
   }
}


fn TransUnit.evalMacro(
   firstToken: Parser.Token,
   macroTypeInfo: Ast.TypeInfo, expList: Ast.ExpListNode! ) : Ast.ExpMacroExpNode
{

   if! expList {
      if _exp.get_expList() {
         foreach exp in _exp.get_expList() {
            let kind = exp.$kind;    
            if kind ~= Ast.nodeKindLiteralNil and
               kind ~= Ast.nodeKindLiteralChar and
               kind ~= Ast.nodeKindLiteralInt and
               kind ~= Ast.nodeKindLiteralReal and
               kind ~= Ast.nodeKindLiteralArray and
               kind ~= Ast.nodeKindLiteralList and
               kind ~= Ast.nodeKindLiteralMap and
               kind ~= Ast.nodeKindLiteralString and
               kind ~= Ast.nodeKindLiteralBool and
               kind ~= Ast.nodeKindLiteralSymbol and
               kind ~= Ast.nodeKindRefField and
               kind ~= Ast.nodeKindExpMacroStat 
            {                       
               self.error( "Macro arguments must be literal value." );
            }                       
         }  
      } 
   }                       

   let macroInfo = unwrap self.typeId2MacroInfo[ macroTypeInfo.get_typeId() ];

   let argVal:stem![] = []; 
   if! expList {            
      foreach argNode in _exp.get_expList() {
         //let val, typeInfo = getLiteralValue( argNode );
         let valList, typeInfoList = argNode.getLiteral();
         let val = valList[1];
         let typeInfo = typeInfoList[1];

         
         // if type( val ) == "table" {
         //     foreach txt in val@str[] {
         //         if type( txt ) == "table" {
         //             foreach txt2 in txt@str[] {
         //                 Util.errorLog( "hoge: %s" ( txt2 ) );
         //             }
         //         }
         //         else {
         //             Util.errorLog( "hoge: %s" ( txt ) );
         //         }
         //     }
         // }
         // else {
         //         Util.errorLog( "hoge: %s" ( val ) );
         // }
         argVal.insert( val );
      }                       
   }                       

   let func = macroInfo.func;
   let macroVars:Map<str,stem!> = func( table.unpack( argVal ) )@Map<str,stem!>;

   foreach name in macroVars._names@str[] {
      let valInfo = unwrap macroInfo.symbol2MacroValInfoMap[ name ];
      let typeInfo = valInfo and valInfo.typeInfo or Ast.builtinTypeStem_;
      let val = macroVars[ name ];
      if typeInfo == Ast.builtinTypeSymbol {
         val = [ val ];
      } 
      self.symbol2ValueMapForMacro[ name ] = new Ast.MacroValInfo( val, typeInfo );
   }
   
   //let scope = self.pushScope();


   let argList = macroInfo.declInfo.get_argList();
   if argList {            
      foreach arg, index in argList {
         if arg.get_kind() == Ast.nodeKindDeclArg {
            let argInfo = arg@Ast.DeclArgNode; 
            let argType = argInfo.$argType;
            let argName = argInfo.$name.txt;
            //scope.add( argName, argType.expType );
            self.symbol2ValueMapForMacro[ argName ] =
               new Ast.MacroValInfo( argVal[ index ], argType.$expType );
         }  
         else {
            self.error( "not support ... in macro" );
         }  
      }                       
   }

   // foreach macroValInfo, symbol in self.symbol2ValueMapForMacro {
   //     Util.errorLog( "HOGE: %s %s" (symbol, macroValInfo) );
   // }
   

   let parser = new MacroPaser( macroInfo.$declInfo.$tokenList,
                                "macro %s" (macroTypeInfo.getTxt()) );
   let bakParser = self.parser;
   self.parser = parser;   
   

   self.macroMode = "expand";

   
   let stmtList:Ast.Node[] = [];
   self.analyzeStatementList( stmtList, "}" );


   //    self.popScope();        

   self.macroMode = "none";
   self.parser = bakParser;

   
   // return self.createNode( 
   //     nodeKindExpMacroExp, firstToken.pos, builtinTypeNone, stmtList );
   return new Ast.ExpMacroExpNode( firstToken.pos, [ Ast.builtinTypeNone ], stmtList );
   
}                       

fn TransUnit.analyzeExpCont(
   firstToken: Parser.Token, exp: Ast.Node, skipFlag: bool ): Ast.Node {
      let nextToken = self.getToken();

      if not skipFlag {
         repeat {
            let matchFlag = false;
            if nextToken.txt == "[" {
               matchFlag = true;
               exp = self.analyzeExpRefItem( nextToken, exp );
               nextToken = self.getToken();
            }   
            if nextToken.txt == "(" {
               let macroFlag = false;
               let funcTypeInfo = exp.$expType;
               if funcTypeInfo.get_kind() == Ast.TypeInfoKindMacro {
                  macroFlag = true;
                  self.symbol2ValueMapForMacro = {};
                  self.macroMode = "analyze";
               }    
               
               matchFlag = true;
               let work = self.getToken();
               let expList: Ast.ExpListNode! = nil;
               if work.txt ~= ")" {
                  self.pushback();
                  expList = self.analyzeExpList();
                  self.checkNextToken( ")" );
               }    

               // 引数の型チェック
               let genericTypeList = funcTypeInfo.$itemTypeInfoList;
               if funcTypeInfo.$kind == Ast.TypeInfoKindMethod and
                  exp.$kind == Ast.nodeKindRefField
               {              
                  let refField = exp@Ast.RefFieldNode;
                  let classType = refField.$prefix.$expType;
                  genericTypeList = classType.$itemTypeInfoList;
               }    
               
               self.checkMatchValType(
                  exp.$pos, funcTypeInfo, expList, genericTypeList );
               
               if macroFlag {
                  self.macroMode = "none";
                  exp = self.evalMacro( firstToken, funcTypeInfo, expList );
               }    
               else {
                  switch( exp.$expType.$kind ) {
                     case Ast.TypeInfoKindMethod, Ast.TypeInfoKindFunc {
                     }      
                     default {
                        self.error( "can't call the type -- %s"
                                    (exp.$expType.getTxt() ) );
                     }      
                  }     
                  exp = new Ast.ExpCallNode(
                     firstToken.pos,
                     funcTypeInfo.get_retTypeInfoList(), exp, expList );
               }    

               nextToken = self.getToken();
            }   
         } not matchFlag;
      } 

      if nextToken.txt == "." {
         return self.analyzeExpSymbol(
            firstToken, self.getToken(), "field", exp, skipFlag );
      } 
      elseif nextToken.txt == ".$" {
         return self.analyzeExpSymbol(
            firstToken, self.getToken(), "get", exp, skipFlag );
      } 

      self.pushback();
      return exp;

   } 


fn TransUnit.analyzeExpSymbol(
   firstToken: Parser.Token, token: Parser.Token,
   mode: str, prefixExp: Ast.Node!, skipFlag: bool ): Ast.Node {
      let exp:Ast.Node! = nil;

      if mode == "field" or mode == "get" {
         sync! prefixExp = prefixExp { self.error( "prefix is nil" ); }
         then {
            if self.macroMode == "analyze" {
               exp = new Ast.RefFieldNode(
                  firstToken.pos, [ Ast.builtinTypeSymbol ], token, unwrap prefixExp );
            }   
            else {
               let typeInfo:Ast.TypeInfo! = Ast.builtinTypeStem_;
               let prefixExpType = prefixExp.$expType;
               if not prefixExpType {
                  self.error( "unknown prefix type: " ..
                              Ast.getNodeKindName( prefixExp.$kind ) );
               }    
               let getterTypeInfo:Ast.TypeInfo! = nil;
               if prefixExpType.get_kind() == Ast.TypeInfoKindClass or
                  prefixExpType.get_kind() == Ast.TypeInfoKindList
               {    
                  if prefixExpType.get_kind() == Ast.TypeInfoKindList {
                     prefixExpType = Ast.builtinTypeList;
                  }     
                  let className = prefixExpType.getTxt();
                  let! classScope = prefixExpType.$scope {
                     self.error( "not found field: %s, %s, %s"
                                 ( classScope, className, prefixExpType ) );
                  };    
                  typeInfo = nil;
                  if mode == "get" {
                     typeInfo = classScope.getTypeInfo(
                        "get_%s" (token.txt), self.scope, false );
                     if! typeInfo {                       
                        if ( _exp.get_kind() == Ast.TypeInfoKindMethod )
                        {                                
                           let retTypeList = _exp.get_retTypeInfoList();
                           getterTypeInfo = _exp;
                           typeInfo = retTypeList[ 1 ];
                        }       
                     }      
                  }     
                  if not getterTypeInfo {
                     // typeInfo = classScope.getTypeInfo(
                     //     token.txt, self.scope, false );
                     typeInfo = classScope.getTypeInfoField(           
                        token.txt, true, self.scope );
                  }     
                  if not typeInfo {
                     foreach val, name in classScope.$symbol2TypeInfoMap {
                        Util.errorLog( "debug: %s, %s" ( name, val ) );
                     }      
                     self.error( string.format(
                        "not found field typeInfo: %s.%s",
                        className, token.txt) );
                  }     
               }    
               elseif prefixExpType.get_kind() == Ast.TypeInfoKindMap {
                  let work = prefixExpType.$itemTypeInfoList[1];
                  if work ~= Ast.builtinTypeString {
                     self.addErrMess(
                        token.pos,
                        "map key type is not str. (%s)" (work.getTxt()) );
                  }     
                  typeInfo = prefixExpType.$itemTypeInfoList[2];
                  if! typeInfo {
                     if _exp.$nilable {
                        typeInfo = _exp.$nilableTypeInfo;
                     }      
                  }     
               }    
               elseif prefixExpType == Ast.builtinTypeStem {
               }    
               else {
                  self.error( "illegal type -- %s, %d"
                              ( prefixExpType.getTxt(),
                                prefixExpType.get_kind() ) );
               }    

               // exp = self.createNode(
               //     nodeKindRefField, firstToken.pos, [ typeInfo ], info );
               if! getterTypeInfo {
                  exp = new Ast.GetFieldNode(
                     firstToken.pos, [ unwrap typeInfo ],
                     token, prefixExp, _exp );
               }    
               else {
                  exp = new Ast.RefFieldNode(
                     firstToken.pos, [ unwrap typeInfo ], token, prefixExp );
               }    
            }   
         }; 
      } 
      elseif mode == "symbol" {
         if self.macroMode == "analyze" {
            exp = new Ast.LiteralSymbolNode(
               firstToken.pos, [ Ast.builtinTypeSymbol ], token );
         }  
         else {
            let! symbolInfo = self.scope.getSymbolTypeInfo(
               token.txt, self.scope, self.moduleScope )
            {           
               self.error( "not found type -- " .. token.txt );
            };
            let typeInfo = symbolInfo.$typeInfo;
            // if token.txt == "self" {
            //    typeInfo = self.getCurrentClass();
            // }   
            if typeInfo == Ast.builtinTypeSymbol {
               skipFlag = true;
            }   
            exp = new Ast.ExpRefNode( firstToken.pos, [ typeInfo ], token, symbolInfo );
         }  
      } 
      elseif mode == "fn" {
         exp = self.analyzeDeclFunc( false, "local", false, nil, token, nil );
      } 
      else {
         self.error( "illegal mode", mode );
      } 

      return self.analyzeExpCont( firstToken, unwrap exp, skipFlag );
   }

fn TransUnit.analyzeExpOp2(
   firstToken: Parser.Token, exp: Ast.Node, prevOpLevel: int ): Ast.Node
{
   while true {
      let nextToken = self.getToken();
      let opTxt = nextToken.txt;

      if opTxt == "@" {
         let castType = self.analyzeRefType( "local" );
         if exp.$expType.$nilable and not castType.$expType.$nilable {
            self.addErrMess( firstToken.pos,
                             "can't cast from nilable to not nilable  -- %s->%s"
                             (exp.$expType.getTxt(), castType.$expType.getTxt()) );
         }  
         exp = new Ast.ExpCastNode( firstToken.pos, castType.$expTypeList, exp );
      } 
      elseif nextToken.kind == Parser.kind.Ope {
         if Parser.isOp2( opTxt ) {
            let! opLevel = op2levelMap[ opTxt ] {
               error( string.format( "unknown op -- %s %s",
                                     opTxt, prevOpLevel ) );
            };  
            if prevOpLevel and opLevel <= prevOpLevel {
               self.pushback();
               return exp;
            }   

            let exp2 = self.analyzeExp( false, opLevel );
            let info = { "op": nextToken, "exp1": exp, "exp2": exp2 };

            if not exp.$expType or not exp2.$expType {
               self.error( "illegal exp or exp2 %s, %s, %s , %s,%d:%d"
                           ( exp.$expType, exp2.$expType,
                             nextToken.txt, self.parser.getStreamName(),
                             nextToken.pos.lineNo, nextToken.pos.column) );
            }   

            let retType = Ast.builtinTypeNone;

            let exp1Type = exp.$expType;
            let exp2Type = exp2.$expType;
            if not exp1Type {
               self.error( "expType is nil %s:%d:%d"
                           ( self.parser.getStreamName(),
                             firstToken.pos.lineNo, firstToken.pos.column ) );
            }   

            switch opTxt {
               case "or" {
                  if exp1Type.equals( exp2Type ) {
                     retType = exp1Type;
                  }     
                  elseif exp1Type.$kind == exp2Type.$kind {
                     // 暫定
                     retType = exp1Type;
                  }     
                  elseif exp2Type == Ast.builtinTypeNil {
                     retType = exp1Type;
                  }     
                  elseif exp1Type == Ast.builtinTypeNil {
                     retType = exp2Type;
                  }     
                  else {
                     retType = Ast.builtinTypeStem_;
                  }     
               }    
               case "and" {
                  // 暫定。 本来は exp2Type の nilable になる
                  retType = exp2Type;
               }    
               case "<", ">", "<=", ">=" {
                  if ( exp1Type ~= Ast.builtinTypeInt and
                       exp1Type ~= Ast.builtinTypeReal ) or
                      ( exp2Type ~= Ast.builtinTypeInt and
                        exp2Type ~= Ast.builtinTypeReal )
                  {     
                     self.addErrMess(
                        nextToken.pos,
                        "no int type %s or %s" ( exp1Type.getTxt(),
                                                 exp2Type.getTxt() ) );
                  }     
                  retType = Ast.builtinTypeBool;
               }    
               case "~=", "==" {
                  if ( not exp1Type.isSettableFrom( exp2Type ) and
                       not exp2Type.isSettableFrom( exp1Type ) )
                  {     
                     self.addErrMess(
                        nextToken.pos,
                        "not compatible type %s or %s" ( exp1Type.getTxt(),
                                                         exp2Type.getTxt() ) );
                  }     
                  retType = Ast.builtinTypeBool;
               }    
               case "^", "|", "~", "&", "<<", ">>" {
                  if exp1Type ~= Ast.builtinTypeInt or
                     exp2Type ~= Ast.builtinTypeInt
                  {                       
                     self.addErrMess(
                        nextToken.pos,
                        "no int type %s or %s" ( exp1Type.getTxt(),
                                                 exp2Type.getTxt() ) );
                  }     
                  retType = Ast.builtinTypeInt;
               }    
               case ".." {
                  if exp1Type ~= Ast.builtinTypeString or
                     exp1Type ~= Ast.builtinTypeString
                  {     
                     self.addErrMess(
                        nextToken.pos,
                        "no string type %s or %s" ( exp1Type.getTxt(),
                                                    exp2Type.getTxt() ) );
                  }     
                  retType = Ast.builtinTypeString;
               }    
               case "+", "-", "*", "/", "//", "%" {
                  if ( exp1Type ~= Ast.builtinTypeReal and
                       exp1Type ~= Ast.builtinTypeInt ) or
                      ( exp2Type ~= Ast.builtinTypeReal and
                        exp2Type ~= Ast.builtinTypeInt )
                  {                       
                     self.addErrMess(
                        nextToken.pos,
                        "no numeric type %s or %s" ( exp1Type.getTxt(),
                                                     exp2Type.getTxt() ) );
                  }     
                  
                  if exp1Type == Ast.builtinTypeReal or
                     exp2Type == Ast.builtinTypeReal
                  {     
                     retType = Ast.builtinTypeReal;
                  }     
                  else {
                     retType = Ast.builtinTypeInt;
                  }     
               }    
               case "=" {
                  if not exp1Type.isSettableFrom( exp2Type ) {   
                     self.addErrMess(
                        nextToken.pos,
                        "unmatch type %s and %s" ( exp1Type.getTxt(),
                                                   exp2Type.getTxt() ) );
                  }     
               }    
               default {
                  self.error( "unknown op " .. opTxt );
               }    
            }   

            exp = new Ast.ExpOp2Node(
               firstToken.pos, [ retType ], nextToken, exp, exp2 );
         }  
         else {
            self.error( "illegal op" );
         }  
      } 
      else {
         self.pushback();
         return exp;
      } 
   }
   return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}

fn TransUnit.analyzeExpMacroStat( firstToken: Parser.Token ): Ast.ExpMacroStatNode {
   let expStrList: Ast.Node[] = [];

   self.checkNextToken( "{" );

   let braceCount = 0;
   while true {
      let token = self.getToken();

      if token.txt == ",," or token.txt == ",,," or token.txt == ",,,," {
         let exp = self.analyzeExp( true, unwrap op1levelMap[ token.txt ] );

         let nextToken = self.getToken();
         if nextToken.txt ~= "$" {
            self.pushback();
         }  

         
         let format = token.txt == ",,," and "'%s '" or '"\'%s\'"';

         if token.txt == ",," and exp.$kind == Ast.nodeKindExpRef
         {           
            let refToken = (exp@Ast.ExpRefNode).get_token();
            let macroInfo = self.symbol2ValueMapForMacro[ refToken.txt ];
            if macroInfo {
               if (unwrap macroInfo).typeInfo == Ast.builtinTypeSymbol {
                  format = "'%s '";
               }    
            }   
         }  
         let newToken = new Parser.Token( Parser.kind.Str, format, token.pos );
         let literalStr = new Ast.LiteralStringNode(
            token.pos, [ Ast.builtinTypeString ], newToken, [ exp ] );
         expStrList.insert(  literalStr );
      } 
      else {
         if token.txt == "{" {
            braceCount = braceCount + 1;
         }   
         elseif token.txt == "}" {
            if braceCount == 0 {
               break;
            }   
            braceCount = braceCount - 1;
         }  

         let newToken = new Parser.Token(
            token.kind, string.format( "'%s '", token.txt ), token.pos );
         let literalStr = new Ast.LiteralStringNode(
            token.pos, [ Ast.builtinTypeString ], newToken, [] );
         expStrList.insert( literalStr );
      } 
   }

   return new Ast.ExpMacroStatNode(
      firstToken.pos, [ Ast.builtinTypeStat ], expStrList );
}


fn TransUnit.analyzeSuper( firstToken:Parser.Token ) : Ast.Node {

   self.checkNextToken( "(" );

   let expList = self.analyzeExpList();
   
   self.checkNextToken( ")" );
   self.checkNextToken( ";" );

   let classType = self.getCurrentClass();
   let superType = classType.get_baseTypeInfo();
   
   return new Ast.ExpCallSuperNode(
      firstToken.pos, [ Ast.builtinTypeNone ], superType, expList ); 
}

fn TransUnit.analyzeUnwrap( firstToken: Parser.Token ): Ast.Node {
   let nextToken, continueFlag = self.getContinueToken();

   if not continueFlag or nextToken.txt ~= "!" {
      self.pushback();
      self.pushbackToken( firstToken );
      let exp = self.analyzeExp();
      self.checkNextToken( ";" );
      return new Ast.StmtExpNode( nextToken.pos, [ Ast.builtinTypeNone ], exp );
   }

   self.pushback();
   return self.analyzeDeclVar( "unwrap", "local", false, firstToken );
}

fn TransUnit.analyzeExpUnwrap( firstToken: Parser.Token ): Ast.Node {
   let expNode = self.analyzeExp();
   let nextToken = self.getToken();
   let insNode: Ast.Node! = nil;
   if nextToken.txt == "default" {
      insNode = self.analyzeExp();
   }
   else {
      self.pushback();
   }

   let unwrapType:Ast.TypeInfo = Ast.builtinTypeStem_;

   let expType = expNode.$expType;
   if not expType.$nilable {
      unwrapType = expType;
   }
   else {
      unwrapType = unwrap expType.$orgTypeInfo;
      if! insNode {
         let insType = _exp.$expType;
         unwrapType = insType;

         if not unwrapType.isSettableFrom( insType ) {
            self.addErrMess(
               _exp.$pos,   
               "unmatch type: %s <- %s" ( unwrapType.getTxt(), insType.getTxt() ) ); 
         }  
      } 
   }

   return new Ast.ExpUnwrapNode( firstToken.pos, [ unwrapType ], expNode, insNode );
}


fn TransUnit.analyzeExp( skipOp2Flag: bool, prevOpLevel: int ): Ast.Node {
   let firstToken = self.getToken();
   let token = firstToken;
   let exp:Ast.Node = new Ast.NoneNode( firstToken.pos, [ Ast.builtinTypeNone ] );

   if token.kind == Parser.kind.Dlmt {
      if token.txt == "..." {
         return new Ast.ExpDDDNode( firstToken.pos, [ Ast.builtinTypeNone ], token );
      } 

      if token.txt == '[' or token.txt == '[@' {
         exp = self.analyzeListConst( token );
      } 
      if token.txt == '{' {
         exp = self.analyzeMapConst( token );
      } 
      if token.txt == "(" {
         exp = self.analyzeExp();
         self.checkNextToken( ")" );
         exp = new Ast.ExpParenNode( firstToken.pos, exp.$expTypeList, exp );
         exp = self.analyzeExpCont( firstToken, exp, false );
      } 
   }

   if token.txt == "new" {
      exp = self.analyzeRefType( "local" );

      self.checkNextToken( "(" );
      let nextToken = self.getToken();
      let argList: Ast.ExpListNode! = nil;
      if nextToken.txt ~= ")" {
         self.pushback();
         argList = self.analyzeExpList();
         self.checkNextToken( ")" );
      } 

      // 引数チェック
      let classTypeInfo = exp.$expType;
      //let classScope = self.typeId2Scope[ classTypeInfo.get_typeId() ];
      let classScope = classTypeInfo.get_scope();
      let! initTypeInfo = (unwrap classScope).getTypeInfoChild( "__init" ) {
         self.error( "not found __init" );
      };

      if initTypeInfo.$accessMode == "pub" or
          ( initTypeInfo.$accessMode == "pro" and
            self.scope.getClassTypeInfo().isInheritFrom( classTypeInfo ) ) or
          ( self.scope.getClassTypeInfo() == classTypeInfo )
      { 
         // pub、 pro でサブクラス、 pri で同じクラスの場合はアクセス可能
      } 
      else {
         self.addErrMess(
            token.pos,
            "can't access to __init of %s" (classTypeInfo.getTxt()));
      } 
      
      self.checkMatchValType( exp.$pos, initTypeInfo, argList,
                              exp.$expType.$itemTypeInfoList );
      
      exp = new Ast.ExpNewNode( firstToken.pos, exp.$expTypeList, exp, argList );
      exp = self.analyzeExpCont( firstToken, exp, false );
   }

   if token.kind == Parser.kind.Ope and Parser.isOp1( token.txt ) {
      // 単項演算
      if token.txt == "`" {
         exp = self.analyzeExpMacroStat( token );
      } 
      else {
         exp = self.analyzeExp( true, unwrap op1levelMap[ token.txt] );
         let typeInfo = Ast.builtinTypeNone;
         let macroExpFlag = false;

         switch ( token.txt ) {
            case "-" {
               if exp.$expType ~= Ast.builtinTypeInt and
                  exp.$expType ~= Ast.builtinTypeReal
               {                   
                  self.addErrMess(
                     token.pos,
                     'unmatch type for "-" -- %s' ( exp.$expType.getTxt() ) );
               }    
               typeInfo = exp.$expType;
            }   
            case "#" {
               if exp.$expType.$kind ~= Ast.TypeInfoKindList and
                  exp.$expType.$kind ~= Ast.TypeInfoKindArray and
                  exp.$expType.$kind ~= Ast.TypeInfoKindMap and
                  exp.$expType ~= Ast.builtinTypeString
               {    
                  self.addErrMess(
                     token.pos,
                     'unmatch type for "#" -- %s' ( exp.$expType.getTxt() ) );
               }    
               typeInfo = Ast.builtinTypeInt;
            }   
            case "not" {
               typeInfo = Ast.builtinTypeBool;
            }   
            case ",," {
               macroExpFlag = true;
            }   
            case ",,," {
               macroExpFlag = true;
               if exp.$expType ~= Ast.builtinTypeString {
                  self.error( "unmatch ,,, type, need string type" );
               }    
               typeInfo = Ast.builtinTypeSymbol;
            }   
            case ",,,," {
               macroExpFlag = true;
               if exp.$expType ~= Ast.builtinTypeSymbol {
                  self.error( "unmatch ,,, type, need symbol type" );
               }    
               typeInfo = Ast.builtinTypeString;
            }   
            case "`" {
               typeInfo = Ast.builtinTypeNone;
            }   
            case "not" {
               typeInfo = Ast.builtinTypeBool;
            }   
            default {
               self.error( "unknown op1" );
            }   
         }  

         if macroExpFlag {
            let nextToken = self.getToken();
            if nextToken.txt ~= "$" {
               self.pushback();
            }   
         }  
         
         exp = new Ast.ExpOp1Node(
            firstToken.pos, [ typeInfo ], token, self.macroMode, exp );
         return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
      } 
   }


   if token.kind == Parser.kind.Int {
      exp = new Ast.LiteralIntNode( firstToken.pos, [ Ast.builtinTypeInt ],
                                    token, tonumber( token.txt )@int );
   }
   elseif token.kind == Parser.kind.Real {
      exp = new Ast.LiteralRealNode( firstToken.pos, [ Ast.builtinTypeReal ],
                                     token, tonumber( token.txt ) );
   }
   elseif token.kind == Parser.kind.Char {
      let num = 0;
      if #(token.txt) == 1 {
         num = token.txt.byte( 1 );
      } 
      else {
         num = unwrap quotedChar2Code[ token.txt.sub( 2, 2 ) ];
      } 
      exp = new Ast.LiteralCharNode( firstToken.pos, [ Ast.builtinTypeChar ], token, num );
   }
   elseif token.kind == Parser.kind.Str {
      let nextToken = self.getToken();
      let formatArgList:Ast.Node[] = [];
      if nextToken.txt == "(" {
         repeat {
            let arg = self.analyzeExp();
            formatArgList.insert( arg );
            nextToken = self.getToken();
         } nextToken.txt ~= ",";
         self.checkToken( nextToken, ")" );
         nextToken = self.getToken();
      } 
      exp = new Ast.LiteralStringNode(
         firstToken.pos, [ Ast.builtinTypeString ], token, formatArgList );
      token = nextToken;
      if token.txt == "[" {
         exp = self.analyzeExpRefItem( token, exp );
      } 
      else {
         self.pushback();
      } 
   }
   elseif token.kind == Parser.kind.Kywd and token.txt == "fn" {
      exp = self.analyzeExpSymbol( firstToken, token, "fn", nil, false );
   }
   elseif token.kind == Parser.kind.Kywd and token.txt == "unwrap" {
      exp = self.analyzeExpUnwrap( token );
   }
   elseif token.kind == Parser.kind.Symb {
      exp = self.analyzeExpSymbol(
         firstToken, token, "symbol", nil, false );
   }
   elseif token.kind == Parser.kind.Type {
      let! symbolTypeInfo = Ast.sym2builtInTypeMap[ token.txt ] {
         self.error( "unknown type -- %s" ( token.txt ) );
      };
      exp = new Ast.ExpRefNode(
         firstToken.pos, [ Ast.builtinTypeNone ], token, symbolTypeInfo );
   }
   elseif token.kind == Parser.kind.Kywd and
       ( token.txt == "true" or token.txt == "false" ) {
          exp = new Ast.LiteralBoolNode( firstToken.pos, [ Ast.builtinTypeBool ], token );
       } 
   elseif token.kind == Parser.kind.Kywd and
       ( token.txt == "nil" or token.txt == "null" )
   {
      exp = new Ast.LiteralNilNode( firstToken.pos, [ Ast.builtinTypeNil ] );
   }

   if not exp {
      self.error( "illegal exp" );
   }

   if skipOp2Flag {
      return exp;
   }

   return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}
