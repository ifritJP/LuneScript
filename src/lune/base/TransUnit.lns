/*
MIT License

Copyright (c) 2018, 2019 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

_lune_control default_async_all;
_lune_control default_strict_generics;


subfile use lune.base.TransUnitDecl;
subfile use lune.base.TransUnitExp;
subfile use lune.base.TransUnitStatementList;
subfile use lune.base.TransUnitTest;
subfile use lune.base.TransUnitCtrl;

import lune.base.Types;
import lune.base.Meta;
import lune.base.Parser as Tokenizer;
import lune.base.Util;
import lune.base.Ast;
import lune.base.Nodes;
import lune.base.Writer;
import lune.base.frontInterface;
import lune.base.LuaVer;
import lune.base.Option;
import lune.base.Code;
import lune.base.Log;
import lune.base.LuneControl;
import lune.base.Macro;
import lune.base.TransUnitIF;
import lune.base.Builtin;
import lune.base.Import;
import lune.base.AstInfo;
import lune.base.Async;


_lune_control ignore_symbol_;
_lune_control default_strict_generics;

macro _cloneMap( dst:__exp, src:__exp ) {
   {}
    {
       foreach val, key in ,,src {
          ,,dst[ key ] = val;
       }
    }
}
      


alias DeclClassMode = TransUnitIF.DeclClassMode;

enum DeclFuncMode {
   Func,
   Class,
   Module,
   Glue,
}

enum ExpSymbolMode {
   Symbol,
   Fn,
   Field,
   FieldNil,
   Get,
   GetNil,
}

pub enum AnalyzeMode {
   Compile,
   Diag,
   Complete,
   Inquire,
}

enum DefaultAsyncMode {
   /** noasync */
   NoAsync,
   /** 関数が async */
   AsyncFunc,
   /** 全て async */
   AsyncAll,
}

class AccessSymPos {
   pri let symbol:&Ast.SymbolInfo {pub};
   pri let pos:&Tokenizer.Position {pub};
}

class RefAccessSymPos {
   pri let symbol:&Ast.SymbolInfo {pub};
   pri let pos:&Tokenizer.Position! {pub};
}

fn clearThePosForModToRef(
   scope:&Ast.Scope, moduleScope:&Ast.Scope ) : &List<RefAccessSymPos>
{
   let mut list:List<RefAccessSymPos> = [];
   scope.filterSymbolTypeInfo(
      scope, moduleScope, .Normal,
      fn ( symInfo:&Ast.SymbolInfo ) __trans : bool {
         if symInfo.$kind == .Var {
            list.insert( new RefAccessSymPos( symInfo, symInfo.$posForModToRef ) );
            symInfo.set_posForModToRef(nil);
         }
         return true;
      });
   return list;
}

/**
初期値を持たない変数について、次処理を行なう。

- 変数の型を確定させる
- 変数の初期値未確定パス検知

ブロック毎にこのインスタンスを生成し、ブロック終了時にシンボルの型を確定する。
*/
class TentativeSymbol {
   /** ブロックで初期値をセットしたシンボルの集合。 */
   pri let mut symbolSet:Set<&Ast.SymbolInfo>;
   /**
初期値をセットした変数の集合。
symbolSet は、 merge でクリアされるが、 initSymSet は保持される。
 */
   pri let mut initSymSet:Set<&Ast.SymbolInfo> {pub&};
   /**
以前のブロックで初期値をセットしたシンボルの集合。
 
例えば、 if {} else {} などの条件分岐するブロックで、
if のブロックを解析中の情報は symbolSet で管理し、
if のブロックを解析終了時に symbolSet を oldSymbolSet にセットする。
そして else のブロックを解析し symbolSet で管理する。
両方が終った所で oldSymbolSet と symbolSet で共通するシンボルの値が確定する。
    */  
   pri let mut oldSymbolSet:Set<&Ast.SymbolInfo>!;

   

   /** 親ブロックを管理する TentativeSymbol */
   pri let mut parent:TentativeSymbol!;
   pri let mut scope:&Ast.Scope {pub};
   pri let mut skipFlag:bool;
   pri let loopFlag:bool;
   pri let mut accessSymList:List<&AccessSymPos> {pub&};

   /** ブロックで値をセットしたシンボルの集合。 */
   pri let mut modSymbolSet:Set<&Ast.SymbolInfo>;
   /** アクセスしたシンボルのセット */
   pri let mut accessSymSet:Set<&Ast.SymbolInfo>;

   /** このブロック処理直前のアクセス可能なローカル変数の posForModToRef を保持。 */
   pri let sym2posForModToRef:&List<RefAccessSymPos>;

   pub fn __init( parent:TentativeSymbol!, scope:&Ast.Scope, moduleScope:&Ast.Scope,
                  loopFlag:bool, refAccessSymPosList:&List<RefAccessSymPos>! )
   { 
      self.symbolSet = (@);
      self.oldSymbolSet = nil;
      self.parent = parent;
      self.scope = scope;
      self.skipFlag = false;
      self.loopFlag = loopFlag;
      self.accessSymList = [];
      self.initSymSet = (@);

      self.accessSymSet = (@);
      self.modSymbolSet = (@);


      let list;
      when! refAccessSymPosList {
         list = refAccessSymPosList;
      } else {
         if loopFlag {
            list = clearThePosForModToRef( scope, moduleScope );
         } else {
            list = [];
         }
      }
      self.sym2posForModToRef = list;
   }

   pub fn modSym( accessSym:&Ast.SymbolInfo ) mut {
      self.modSymbolSet.add( accessSym.getOrg() );
   }
   pub fn addAccessSym( accessSym:&Ast.SymbolInfo ) mut {
      self.accessSymSet.add( accessSym.getOrg() );
   }
   
   /**
このブロック内でアクセスしている未初期化シンボルを登録する。

未初期化シンボルへのアクセスがないかを検出するために利用する。
   */
   pub fn addAccessSymPos( accessSym:&AccessSymPos ) mut {
      self.accessSymList.insert( accessSym );
   }
   /**
   このブロック内でアクセスしているシンボルの登録をクリアする。
   */
   pub fn clearAccessSym() mut {
      if #self.accessSymList ~= 0 {
         self.accessSymList = [];
      }
   }

   /**
指定のシンボルに値をセット済みかどうかチェックする。
セット済みの場合、セット済み集合から除外する。

@return セット済みの場合 true
   */
   pub fn checkAndExclude( mut symbolInfo:&Ast.SymbolInfo ) mut : bool {
      symbolInfo = symbolInfo.getOrg();
      if self.symbolSet.has( symbolInfo ) {
         self.symbolSet.del( symbolInfo );
         return true;
      }
      return false;
   }

   /**
値をセットしたシンボルを登録する。   
   */
   pub fn regist( symbolInfo:&Ast.SymbolInfo, pos:&Tokenizer.Position ) mut : bool {
      self.symbolSet.add( symbolInfo.getOrg() );
      self.initSymSet.add( symbolInfo.getOrg() );
      symbolInfo.set_hasValueFlag( true );

      if self.$scope.isInnerOf( symbolInfo.$scope ) {
         if not symbolInfo.$mutable {
            let mut work = self;
            while true {
               if! work.parent {
                  if work.scope == symbolInfo.$scope {
                     break;
                  }
                  if work.loopFlag {
                     // loop 内で immutable な変数へのセットはサポートしない
                     return false;
                  }
                  work = _exp;
               }
               else {
                  break;
               }
            }
         }
      }

      return true;
   }

   /**
break でそのブロック自体を抜ける場合、
そこまで解析した情報は無意味になる。
よって解析情報を捨てることを通知する。
   */
   pub fn skip() mut {
      foreach symbolInfo in self.symbolSet {
         symbolInfo.clearValue();
      }
      self.skipFlag = true;
   }

   /**
   oldSymbolSet と symbolSet に共通するシンボルを確定し、
   確定した情報を symbolSet にセットする。

@return bool self.symbolSet が有効な場合 true
     */   
   fn merge( finishFlag:bool ) mut : bool {
      if self.skipFlag {
         self.skipFlag = false;
         if! let other = self.oldSymbolSet {
            self.symbolSet = other.clone();
         }
         if finishFlag {
            foreach symbolInfo in self.symbolSet {
               symbolInfo.updateValue( symbolInfo.$posForLatestMod );
            }
         }
         return self.oldSymbolSet ~= nil;
      }
      if! let other = self.oldSymbolSet {
         let mut mergedSet = self.symbolSet.clone().and( other );
         if finishFlag {
            foreach symbolInfo in self.symbolSet.clone().or( other ).sub( mergedSet ) {
               symbolInfo.clearValue();
            }
         }
         else {
            foreach symbolInfo in self.symbolSet.clone().or( other ) {
               symbolInfo.clearValue();
            }
         }
         self.symbolSet = mergedSet;
      }
      else {
         if not finishFlag {
            foreach symbolInfo in self.symbolSet {
               symbolInfo.clearValue();
            }
         }
      }
      return true;
   }

   pub fn syncPos() mut {
      if self.loopFlag {
         // loop を抜けた後の変数アクセス判定を行なうために、
         // アクセスとセット両方している変数は、
         // セット位置とアクセス位置を一緒にする。
         // foreach symbol in self.accessSymSet {
         //    if self.modSymbolSet.has( symbol ) and
         //       self.sym2posForModToRef[ symbol ] ~= symbol.$posForModToRef
         foreach info in self.sym2posForModToRef {
            let symbol = info.$symbol;
            if symbol.$posForModToRef {
               symbol.set_posForModToRef( symbol.$posForLatestMod );
            } else {
               symbol.set_posForModToRef( info.$pos );
            }
         }
      }
   }
   
   /*
ブロックの解析処理を終了する。
 
if {} else {} の if のブロック終了時は、 else のブロックが残っているので、
complete は false を指定する。
   */
   pub fn finish( complete:bool ) mut : TentativeSymbol! {
      self.syncPos();
      self.merge( true );
      if! let mut parent = self.parent {
         if complete {
            foreach symbolInfo in self.symbolSet {
               if symbolInfo.$hasValueFlag {
                  if parent.scope.isInnerOf( symbolInfo.$scope ) {
                     parent.symbolSet.add( symbolInfo );
                  }
               }
            }
         }
         else {
            foreach symbolInfo in self.symbolSet {
               symbolInfo.clearValue();
            }
         }

         macro _syncToParent( set:sym ) {
            foreach symbolInfo in self.,,set {
               if symbolInfo.$scope ~= self.$scope {
                  parent.,,set.add( symbolInfo );
               }
            }
         }

         _syncToParent( initSymSet );
         _syncToParent( accessSymSet );
         _syncToParent( modSymbolSet );
         return parent;
      }

      return nil;
   }

   pub fn newSet( scope:&Ast.Scope ) mut {
      if self.merge( false ) {
         self.oldSymbolSet = self.symbolSet;
      }
      self.symbolSet = (@);
      self.scope = scope;
   }
}

enum AnalyzingState {
   Other,
   /** コンストラクタ */
   Constructor,
   /** class の __init ブロック */
   InitBlock,
   /** class の static method */
   ClassMethod,
   /** その他の 関数, メソッド */
   Func,
}

/**
expNode から dstType に代入する際に、
暗黙型キャストが必要かどうかをチェックする。

必要な場合は、 変換を行なう ExpCastNode を返す。

*/
form checkImplicitCastCallback( dstType:&Ast.TypeInfo, expNode:&Nodes.Node ): &Nodes.Node!;

class ClosureFun {
   /** 関数シンボル */
   let symbol:&Ast.SymbolInfo;
   /** 関数シンボルにアクセスしているスコープ */
   let mut fromScope:Ast.Scope;

   /**
   アクセスしている関数シンボルがクロージャかどうか判定し、
   クロージャなら、このシンボルもクロージャとして登録する。

   @return クロージャだったら true
   */
   pub fn check() mut : bool {
      if! self.symbol.$typeInfo.$scope$.$closureSymList {
         if #_exp > 0 {
            self.fromScope.setClosure( self.symbol );
            return true;
         }
      }
      return false;
   }

   /**
指定の ClosureFun のリストの関数シンボルアクセスがクロージャかどうかの判定処理を行なう。
   */
   pub static fn checkList( list:List<ClosureFun> ) {
      let mut workList = list;
      let mut remainList:List<ClosureFun> = [];
      while true {
         let mut update = false;
         foreach closureFun in workList {
            if closureFun.check() {
               update = true;
            }
            else {
               remainList.insert( closureFun );
            }
         }
         if not update {
            break;
         }
         workList = remainList;
         remainList = [];
      }
   }
   
}


/**
analyzeExpSymbol で解析した参照シンボルと、
その時点の posForLatestMod 情報を保持する。

analyzeExpSymbol() 実行時点では、
そのシンボルへの書き込みアクセスか参照アクセスかが確定しないため、
一旦このクラスで保持しておいて、
確定後に情報を更新するために利用する。

なお、代入の左辺以外で利用される analyzeExpSymbol() は全て参照なので、
参照として確定している場合は、このクラスは利用せずに直接情報を反映する。
*/
class AccessSymbolSet {
   let mut accessSym2Pos:Map<&Ast.SymbolInfo,&Tokenizer.Position> {pub&};
   pub fn __init() {
      self.accessSym2Pos = {};
   }
   pub fn add( symbol:&Ast.SymbolInfo ) mut {
      if! symbol.$posForLatestMod {
         self.accessSym2Pos[ symbol ] = _exp;
      } else {
         self.accessSym2Pos[ symbol ] = nil;
      }
   }
   pub fn applyPos( excludeSymList:&Set<&Ast.SymbolInfo>! ) mut {
      let! set = excludeSymList {
         set = (@);
      };
      foreach pos, symbol in self.accessSym2Pos {
         if not set.has( symbol.getOrg() ) {
            symbol.set_posForModToRef( pos );
         }
      }
   }

   pub fn clone() : AccessSymbolSet {
      let mut obj = new AccessSymbolSet();
      foreach val, key in self.accessSym2Pos {
         obj.accessSym2Pos[ key ] = val;
      }
      return obj;
   }
}

class AccessSymbolSetQueue {
   let mut queue:List<AccessSymbolSet>;
   pub fn __init() {
      self.queue = [];
   }
   pub fn push() mut {
      self.queue.insert( new AccessSymbolSet() );
   }
   pub fn pop( symbolList:&Set<&Ast.SymbolInfo>! ) mut {
      self.queue[ #self.queue ].applyPos( symbolList );
      self.queue.remove(##);
   }
   pub fn add( symbol:&Ast.SymbolInfo ) mut {
      self.queue[ #self.queue ].add( symbol );
   }
   pub fn getMap() : &Map<&Ast.SymbolInfo,&Tokenizer.Position> {
      return self.queue[ #self.queue ].$accessSym2Pos;
   }

   local fn setupFrom(src:&AccessSymbolSetQueue) mut {
      foreach symbol in src.queue {
         self.queue.insert( symbol.clone() );
      }
   }
}

final class FuncBlockInfo extend (__AsyncItem) {
   let declFuncInfo:Nodes.DeclFuncInfo {pub};
   let nsInfo:TransUnitIF.NSInfo {pub};
   let funcType:&Ast.TypeInfo{pub};
   let typeDataAccessor:Ast.TypeDataAccessor{pub};
   let mut funcScope:Ast.Scope {pub,local};
   let tokenList:&List<&Tokenizer.Token> {pub};
   let declPos:&Tokenizer.Position {pub};
   let orgPos:&Tokenizer.Position! {pub};
}

interface FuncBlockCtlIF {
   pub fn getNext() mut :&FuncBlockInfo!;
}

class ListFuncBlockCtl extend (FuncBlockCtlIF) {
   let list:&List<&FuncBlockInfo>;
   let mut pos:int;

   pub fn __init( list:&List<&FuncBlockInfo> ) {
      self.list = list;
      self.pos = 0;
   }
   
   pub fn getNext() mut : &FuncBlockInfo! {
      if self.pos >= #self.list {
         return nil;
      }
      self.pos = self.pos + 1;
      return self.list[ self.pos ];
   }
}

class PipeFuncBlockCtl extend (FuncBlockCtlIF) {
   let pipe:__pipe<&FuncBlockInfo>;

   pub fn __init( pipe:__pipe<&FuncBlockInfo> ) {
      self.pipe = pipe;
   }
   
   pub fn getNext() mut : &FuncBlockInfo! {
      return self.pipe.get();
   }
}


class FuncBlockResult {
   let funcBlockInfo:&FuncBlockInfo {pub};
   let body:Nodes.BlockNode {pub};
   let has_func_sym:bool {pub};
   let stmtNum:int {pub};
}

enum AnalyzePhase {
   /** Meta ファイル用の外部公開の情報を解析する */
   Meta,
   /** Runner で分割解析する */
   Runner,
   /** 全体を解析する */
   Main,
}

pub abstract class TransUnit extend TransUnitIF.TransUnitBase (Tokenizer.PushbackTokenizer) {

   /** 解析モード */
   local let analyzeMode: AnalyzeMode;
   /** 解析対象位置 */
   pri let analyzePos: &Tokenizer.Position;
   /** 解析対象モジュール */
   pri let analyzeModule: str;
   /**
トランスコンパイル先の lua バージョン
   */
   pro let targetLuaVer:&LuaVer.LuaVerInfo;

   pro let moduleId:&frontInterface.ModuleId;

   /** マクロを展開する際にマクロを評価する MacroEval のオブジェクト */
   pri let macroEval: &Nodes.MacroEval;

   local let builtinFunc:&Builtin.BuiltinFuncType;

   local let frontAccessor:frontInterface.FrontAccessor;
   
   //===== 解析開始時に設定 ===
   
   /** true の場合は mut 制御が有効 */
   pro let mut validMutControl: bool;

   /** モジュール名 */
   local let mut moduleName: str;
   local let mut moduleType: &Ast.TypeInfo;

   /** true の場合、 _ で始まるシンボル名チェックをしない */
   pro let mut ignoreToCheckSymbol_:bool;
   /** async 宣言のデフォルト */
   local let mut defaultAsyncMode: DefaultAsyncMode;

   // pro let mut stdinFile:&Types.StdinFile!;

   pro let mut baseDir:str!;


   //===== Meta 解析時に設定
   local let mut analyzePhase:AnalyzePhase;
   //local let funcBlockInfoList:List<FuncBlockInfo>;

   

   // ===== 複数持ち 
   pro let modifier:TransUnitIF.Modifier;

   pro let topScope: Ast.Scope;
   /** macro-statement の最上位スコープ */
   pri let mut macroScope: Ast.Scope!;

   /** */
   pri let mut tentativeSymbol:TentativeSymbol;
   /** パーサー */
   pro let mut tokenizer: Tokenizer.DefaultPushbackTokenizer;
   pro fn setTokenizer( tokenizer:Tokenizer.DefaultPushbackTokenizer ) mut {
      self.tokenizer = tokenizer;
   }
   pro let mut scopeAccess:Ast.ScopeAccess;

   /** 引数解析中の static method の Scope */
   let mut analyzingStaticMethodArgsScope:&Ast.Scope!;

   local let mut inTestBlock:bool;

   /** Meta 解析後に、各関数ブロックを解析する際の*/  
   pro let mut funcBlockInfoLinkNo:&Tokenizer.Position!;

   /** モジュールの最上位スコープ */
   pro let mut moduleScope: &Ast.Scope;

   /** __func__ シンボルを持つ関数 TypeInfo の set */
   pro let has__func__Symbol: Set<&Ast.TypeInfo>;
   
   // ==== 複数持ちしてマージ
   /** NodeKind -> Node[]  */
   pro let nodeManager: Nodes.NodeManager;

   /** クロージャ候補の関数情報リスト */
   local let closureFunList:List<ClosureFun>;

   /** コメントリスト */
   local let commentCtrl: Tokenizer.CommentCtrl;


   /** クラスの型情報 -> そのクラスを宣言しているノード */
   pri let typeInfo2ClassNode: Map<&Ast.TypeInfo,Nodes.DeclClassNode>;

   //===== clone して複数持ち
   /** 解析状態 */
   pri let analyzingStateQueue:List<AnalyzingState>;

   // /** subfile 名のリスト */
   // pro let subfileList: List<str>;
   /** マクロ制御 */
   pro let mut macroCtrl:Macro.MacroCtrl;
   /** advertise 宣言されているメンバの型の Set */
   let advertisedTypeSet:Set<&Ast.TypeInfo>;

   let accessSymbolSetQueue:AccessSymbolSetQueue;

   // クラス TypeInfo -> defaultAsyncMode
   let class2defaultAsyncMode: Map<&Ast.TypeInfo,DefaultAsyncMode>;

   //===== clone して後でマージ

   pro let helperInfo:frontInterface.LuneHelperInfo;

   /** 解析警告メッセージ */
   pro let warnMessList: List<&TransUnitIF.ErrMess> { pub };
   
   //===== 実行前に設定。
   /** このモジュール内から直接 import しているモジュールのセット */
   pro let mut importModuleSet: Set<&Ast.TypeInfo>;
   // local let mut importCtrl:Import.Import!;
   /**
インポートしているモジュール内で定義している alias 情報。

alias で置き換えている元の Type → alias の型
   */
   pro let mut importedAliasMap: Map<&Ast.TypeInfo,&Ast.AliasTypeInfo> {pub&};
   //pro let importModuleInfo: frontInterface.ImportModuleInfo;
   


   local fn setup( src:&TransUnit ) mut
   {
      _cloneMap( self.typeId2ClassMap, src.typeId2ClassMap );
      foreach val in src.errMessList {
         self.errMessList.insert( val );
      }


      self.globalScope = new Ast.ScopeWithRef(
         self.processInfo, self.globalScope, src.globalScope, .Other ## );

      _cloneMap( self.typeId2ClassMap, src.typeId2ClassMap );

      foreach nsInfo, typeInfo in src.nsInfoMap {
         self.nsInfoMap[ typeInfo ] = nsInfo.duplicate();
      }

      // === self
      
      self.defaultAsyncMode = src.defaultAsyncMode;
      self.validMutControl = src.validMutControl;
      self.moduleName = src.moduleName;
      self.moduleType = src.moduleType;
      self.ignoreToCheckSymbol_ = src.ignoreToCheckSymbol_;
      self.baseDir = src.baseDir;
      self.analyzePhase = src.analyzePhase;

      self.typeNameCtrl = new Ast.TypeNameCtrl( self.moduleType );
      
      self.macroCtrl = src.macroCtrl.clone( self.frontAccessor );
      self.advertisedTypeSet.or(src.advertisedTypeSet );
      self.accessSymbolSetQueue.setupFrom( src.accessSymbolSetQueue );
      self.helperInfo.pragmaSet.or( src.helperInfo.pragmaSet );
      foreach mess in src.warnMessList {
         self.warnMessList.insert( mess );
      }
      self.importModuleSet.or( src.importModuleSet );
      _cloneMap( self.importedAliasMap, src.importedAliasMap );
   }

   local fn mergeFrom(
      src:&TransUnit, funcBlockResultMap:&Map<&FuncBlockInfo,FuncBlockResult> ) mut
   {
      self.nodeManager.addFrom( src.nodeManager );

      // /** クロージャ候補の関数情報リスト */
      foreach val in src.closureFunList {
         self.closureFunList.insert( val );
      }

      // /** コメントリスト */
      // local let commentCtrl: Tokenizer.CommentCtrl;

      self.macroCtrl.mergeFrom( src.macroCtrl );

      _cloneMap( self.typeInfo2ClassNode, src.typeInfo2ClassNode );

      self.helperInfo.mergeFrom( src.helperInfo );

      fn cloneMessList( dstList:List<&TransUnitIF.ErrMess>,
                        srcList:&List<&TransUnitIF.ErrMess> )
      {
         let set:Set<str> = (@);
         foreach info in dstList {
            set.add( info.mess );
         }
         foreach info in srcList {
            if not set.has( info.mess ) {
               dstList.insert( info );
            }
         }
      }

      cloneMessList( self.warnMessList, src.warnMessList );
      cloneMessList( self.errMessList, src.errMessList );

      foreach nsInfo, typeInfo in src.nsInfoMap {
         let! mut dstInfo = self.nsInfoMap[ typeInfo ] {
            dstInfo = self.newNSInfoWithTypeData(
               nsInfo.$typeInfo,
               nsInfo.$typeDataAccessor, nsInfo.$pos );
            self.nsInfoMap[ typeInfo ] = dstInfo;
         };
         let mut dstChildren = dstInfo.$typeDataAccessor.$typeData.$children;
         let mut srcChildren = nsInfo.$typeDataAccessor.$typeData.$children;
         if #dstChildren == 0 {
            foreach child in srcChildren {
               dstChildren.insert( child );
            }
         } elseif #dstChildren < #srcChildren {
            for index = #dstChildren, #srcChildren {
               dstChildren.insert( srcChildren[ index ] );
            }
         }
      }
      
   }

   

   local static fn getSuperParam( ctrl_info: &Types.TransCtrlInfo ) : 
      &Types.TransCtrlInfo, Ast.ProcessInfo
   {
      let mut processInfo = Ast.createProcessInfo(
         ctrl_info.validCheckingMutable,
         ctrl_info.validLuaval, ctrl_info.validAstDetailError );
      return ctrl_info, processInfo;
   }
   
   pro fn __init( frontAccessor:frontInterface.FrontAccessor,
                  moduleId:&frontInterface.ModuleId,
                  importModuleInfo:&frontInterface.ImportModuleInfo,
                  macroEval: &Nodes.MacroEval, enableMultiPhase:bool,
                  analyzeModule:str!, mode:AnalyzeMode!,
                  pos:&Tokenizer.Position!, targetLuaVer:&LuaVer.LuaVerInfo,
                  ctrl_info: &Types.TransCtrlInfo,
                  builtinFunc:&Builtin.BuiltinFuncType) 
   {
      super( TransUnit.getSuperParam( ctrl_info )** );

      self.frontAccessor = frontAccessor;

      self.funcBlockInfoLinkNo = nil;
      // self.funcBlockInfoList = [];
      let phase:AnalyzePhase;
      if ctrl_info.validMultiPhaseTransUnit and
         enableMultiPhase and ( mode == nil or mode == .Compile )
      {
         phase = .Meta;
      } else {
         phase = .Main;
      }
      self.analyzePhase = phase;
      self.inTestBlock = false;
      self.baseDir = nil;
      // self.stdinFile = nil;
      self.builtinFunc = builtinFunc;
      self.analyzingStaticMethodArgsScope = nil;
      self.class2defaultAsyncMode = {};
      let defaultAsyncMode:DefaultAsyncMode;
      if ctrl_info.defaultAsync {
         defaultAsyncMode = .AsyncAll;
      } else {
         defaultAsyncMode = .NoAsync;
      }
      self.defaultAsyncMode = defaultAsyncMode;
      self.importedAliasMap = {};
      self.importModuleSet = (@);
      self.accessSymbolSetQueue = new AccessSymbolSetQueue();
      self.advertisedTypeSet = (@);
      self.closureFunList = [];
      self.scopeAccess = .Normal;
      self.macroEval = macroEval;
      self.macroCtrl = new Macro.MacroCtrl(
         macroEval, ctrl_info.validMacroAsync, frontAccessor );
      self.analyzingStateQueue = [];
      //self.ctrl_info = ctrl_info;
      self.ignoreToCheckSymbol_ = false;
      self.moduleId = moduleId;
      self.helperInfo = new frontInterface.LuneHelperInfo();
      self.targetLuaVer = targetLuaVer;
      //self.importModuleInfo = importModuleInfo.clone();
      self.has__func__Symbol = (@);
      self.nodeManager = new Nodes.NodeManager();
      self.macroScope = nil;
      self.validMutControl = true;
      self.modifier = new TransUnitIF.Modifier(
         self.validMutControl, self.processInfo );
      self.moduleName = "";
      self.moduleType = Ast.headTypeInfo;
      self.tokenizer = new Tokenizer.DefaultPushbackTokenizer( new Tokenizer.DummyTokenizer() );
      // self.subfileList = [];
      self.topScope = self.$scope;
      self.moduleScope = self.$scope;

      self.tentativeSymbol = new TentativeSymbol(
         nil, self.globalScope, self.moduleScope, false, nil );

      self.typeInfo2ClassNode = {};
      self.commentCtrl = new Tokenizer.CommentCtrl();
      self.warnMessList = [];
      self.analyzeMode = unwrap mode default AnalyzeMode.Compile;
      self.analyzePos = unwrap pos default self.createPosition( 0, 0 );
      self.analyzeModule = unwrap analyzeModule default "";

      // self.importCtrl = nil;
   }

   pub override fn getLatestPos() __async : &Tokenizer.Position {
      return self.tokenizer.getLastPos();
   }

   pri fn pushAnalyzingState( state:AnalyzingState ) mut {
      self.analyzingStateQueue.insert( state );
   }

   pri fn popAnalyzingState() mut {
      if #self.analyzingStateQueue == 0 {
         self.error( "underflow analyzingStateQueue" ); // バグ
      }
      self.analyzingStateQueue.remove(##);
   }

   pri fn inAnalyzingState( state:AnalyzingState ): bool {
      if #self.analyzingStateQueue > 0 {
         return self.analyzingStateQueue[ #self.analyzingStateQueue ] == state;
      }
      return false;
   }

   pri fn addWarnMess( pos: &Tokenizer.Position, mess: str ) __async mut {
      self.warnMessList.insert( new TransUnitIF.ErrMess(
         "%s: warning: %s" ( pos.getDisplayTxt(), mess ), pos ) );
   }

   pri fn addWarnErrMess( pos:&Tokenizer.Position, err:bool, mess: str ) __async mut {
      if err {
         self.addErrMess( pos, mess );
      }
      else {
         self.addWarnMess( pos, mess );
      }
   }
   
   /** scope を名前空間に属させるためのダミーの関数を定義 */
   fn createDummyNS( scope:Ast.Scope, pos:&Tokenizer.Position, asyncMode:Ast.Async ) mut {
      let mut dummyType = self.processInfo.createDummyNameSpace(
         scope, Ast.headTypeInfo, asyncMode );
      self.newNSInfo( dummyType, pos );
   }

   

   pri fn prepareTentativeSymbol(
      scope:&Ast.Scope, loopFlag:bool, list:&List<RefAccessSymPos>! ) mut
   {
      self.tentativeSymbol = new TentativeSymbol(
         self.tentativeSymbol, scope, self.moduleScope, loopFlag, list );
   }

   pri fn checkAccesSym() mut {
      foreach accessSym in self.tentativeSymbol.$accessSymList {
         let symbolInfo = accessSym.$symbol;
         if not symbolInfo.$hasValueFlag {
            self.addErrMess(
               accessSym.$pos,
               "This can't access variable have no value -- %s" (symbolInfo.$name) );
         }
      }

      self.tentativeSymbol.clearAccessSym();
   }
   
   pri fn finishTentativeSymbol( complete:bool ) mut {
      self.checkAccesSym();
      let mut tentativeSymbol = self.tentativeSymbol;
      self.tentativeSymbol = unwrap tentativeSymbol.finish( complete );

      {
         let mut errSymMap:Map<str,&Ast.SymbolInfo> = {};
         foreach symbolInfo in tentativeSymbol.$initSymSet {
            if tentativeSymbol.$scope.$parent == symbolInfo.$scope {
               if not symbolInfo.$hasValueFlag {
                  errSymMap[ symbolInfo.$name ] = symbolInfo;
               }
            }
         }
         forsort symbolInfo in errSymMap {
            self.addErrMess(
               self.tokenizer.getLastPos(),
               "There is the case no initialized value for '%s'"
               (symbolInfo.$name) );
         }
      }

      if tentativeSymbol.$scope.$validCheckingUnaccess {
         forsort symbolInfo in tentativeSymbol.$scope.$symbol2SymbolInfoMap {
            if ( not symbolInfo.$posForModToRef or
                 symbolInfo.$posForModToRef ~= symbolInfo.$posForLatestMod ) and
                ( symbolInfo.$kind == .Var or symbolInfo.$kind == .Fun ) and
               not Ast.isPubToExternal( symbolInfo.$accessMode ) and
               not symbolInfo.$name.find( "^_"## )
            {
               if! let pos = symbolInfo.$posForLatestMod or symbolInfo.$pos {
                  self.addWarnMess( pos, "'%s' var isn't accessed" (symbolInfo.$name) );
               }
            }
         }
      }
   }

   pri fn mergeTentativeSymbol( scope:&Ast.Scope ) mut {
      self.checkAccesSym();
      self.tentativeSymbol.newSet( scope );
   }


   pri fn getCurrentClass() mut : &Ast.TypeInfo {
      let typeInfo = Ast.headTypeInfo;
      let mut scope:&Ast.Scope = self.$scope;
      repeat {
         if! scope.$ownerTypeInfo {
            if _exp.$kind == .Class or _exp.$kind == .Module or _exp.$kind == .IF {
               return _exp;
            }
         }
         scope = scope.$parent;
      } scope.isRoot();
      return typeInfo;
   }


   pri fn pushExtModule(
      externalFlag: bool, name:str, accessMode:Ast.AccessMode, pos:&Tokenizer.Position,
      lazy:bool, lang:Types.Lang, requirePath:str ) mut : TransUnitIF.NSInfo
   {

      let modName = name;
      if! self.$scope.getTypeInfoChild( modName ) {
         self.addErrMess( pos, "multiple define -- %s" (name) );
      }

      let mut parentNsInfo = self.$curNsInfo;
      let mut parentInfo = parentNsInfo.$typeInfo;
      let mut parentScope = self.$scope;
      let mut scope = self.pushScope( .Module ## );
      let mut typeInfo = self.processInfo.createExtModule(
         scope, parentInfo, parentNsInfo.$typeDataAccessor, externalFlag,
         accessMode, name, lang, requirePath );

      parentScope.addExtModule( self.processInfo, name, pos, typeInfo, lazy, lang );

      if not self.typeId2ClassMap[ typeInfo.$typeId ] {
         let namespace = new Nodes.NamespaceInfo( modName, self.$scope, typeInfo );
         self.typeId2ClassMap[ typeInfo.$typeId ] = namespace;
      }

      let mut nsInfo = self.newNSInfo( typeInfo, pos );
      self.set_curNsInfo( nsInfo );
      return nsInfo;
   }


   pub fn pushbackStr( asyncParse:bool!, name: str, statement: str, pos:&Types.Position ) __async mut;
   pri fn analyzeDecl( accessMode: Ast.AccessMode, staticFlag:
                       bool, firstToken: &Tokenizer.Token,
                       token: &Tokenizer.Token ) mut: Nodes.Node!, bool;
   pri fn analyzeDeclVar(
      mode:Nodes.DeclVarMode,
      accessMode: Ast.AccessMode, firstToken: &Tokenizer.Token ) mut: Nodes.Node;
   pri fn analyzeDeclFunc(
      declFuncMode: DeclFuncMode, asyncLocked:bool, abstractFlag: bool,
      overrideFlag: bool, accessMode: Ast.AccessMode, staticFlag: bool,
      mut classTypeInfo: &Ast.TypeInfo!,
      firstToken: &Tokenizer.Token, name: &Tokenizer.Token! ) mut : Nodes.Node;
   pri fn analyzeDeclClass(
      finalFlag:bool, abstractFlag:bool, classAccessMode: Ast.AccessMode,
      classToken: &Tokenizer.Token, mode:DeclClassMode ) mut : Nodes.DeclClassNode!;
   pri fn analyzeExpSub(
      allowNoneType:bool, skipOp2Flag: bool, canLeftExp:bool, canCondRet:bool,
      opLevel: int!, expectType:&Ast.TypeInfo! ) mut : Nodes.Node;
   pri fn analyzeExp(
      allowNoneType:bool, skipOp2Flag: bool, canLeftExp:bool, canCondRet:bool,
      opLevel: int!, expectType:&Ast.TypeInfo! ) mut : Nodes.Node;
   pri fn analyzeExpOneRVal(
      allowNoneType:bool, skipOp2Flag: bool, canCondRet:bool!, opLevel: int!,        
      expectType:&Ast.TypeInfo! ) mut : Nodes.Node;
   pri fn analyzeStatement( termTxt: str! ) mut : Nodes.Node!;
   local fn analyzeExpSymbol(
      firstToken: &Tokenizer.Token, token: &Tokenizer.Token, mode: ExpSymbolMode,
      prefixExp: &Nodes.Node!, skipFlag: bool,
      canLeftExp:bool, canCondRet:bool ) mut : Nodes.Node;
   pri fn analyzeExpList(
      allowNoneType:bool, skipOp2Flag: bool, canLeftExp:bool, canCondRet:bool,
      expNode: &Nodes.Node!,
      expectTypeList: &List<&Ast.TypeInfo>!, contExpect: bool! ) mut : Nodes.ExpListNode;
   pri fn analyzeIfUnwrap( firstToken: &Tokenizer.Token ) mut : Nodes.IfUnwrapNode;
   pub fn getTokenNoErr(skipFlag:bool!) __async mut : &Tokenizer.Token;
   fn analyzeRefType(
      accessMode: Ast.AccessMode, allowDDD:bool, parentPub:bool,
      allowOmitTypeParamFlag:bool, allowToSetAlt:bool ) mut: Nodes.RefTypeNode;
   pri fn analyzeRefTypeWithSymbol(
      accessMode: Ast.AccessMode, allowDDD:bool, mutMode:Ast.MutMode!,
      symbolNode:&Nodes.Node, parentPub:bool, allowToSetAlt:bool ) mut: Nodes.RefTypeNode;
   fn analyzeFuncBlock(
      analyzingState:AnalyzingState, firstToken: &Tokenizer.Token,
      classTypeInfo:&Ast.TypeInfo!, funcTypeInfo:&Ast.TypeInfo,
      funcName:str, funcBodyScope:Ast.Scope,
      retTypeInfoList:&List<&Ast.TypeInfo> ) mut : Nodes.BlockNode;

   pri fn checkAlgeComp( token:&Tokenizer.Token, algeTypeInfo: &Ast.AlgeTypeInfo );


   fn evalMacroOp(
      firstToken: &Tokenizer.Token, macroTypeInfo: &Ast.TypeInfo,
      expList: &Nodes.ExpListNode!, evalMacroCallback:Macro.EvalMacroCallback ) mut;
   fn prepareExpCall(
      termTxt:str, position:&Tokenizer.Position, funcTypeInfo:&Ast.TypeInfo,
      genericTypeList:&List<&Ast.TypeInfo>, genericsClass:&Ast.TypeInfo ) mut:
      Map<&Ast.TypeInfo,&Ast.TypeInfo>, &Nodes.ExpListNode!;

   fn isTargetTokenPos( txt:str, pos:&Tokenizer.Position ) : bool {
      if self.analyzePos.lineNo == pos.lineNo and
         self.analyzePos.column >= pos.column and
         self.analyzePos.column <= pos.column + #txt
      {
         return true;
      }
      return false;
   }

   fn isTargetToken( token:&Tokenizer.Token ) : bool {
      return self.isTargetTokenPos( token.txt, token.pos );
   }

   fn dumpSymbolType( accessMode:Ast.AccessMode, name:str, typeInfo:&Ast.TypeInfo ) {
      let mut writer = new Writer.JSON( io.stdout );
      writer.startParent( "lunescript", false );
      writer.startParent( "inquire", false );
      writer.write( "access", Ast.accessMode2txt( accessMode ) );
      writer.write( "name", name );
      writer.write( "type", typeInfo.getTxt( self.typeNameCtrl## ) );
      writer.write( "typeKind", typeInfo.$kind.$_txt );
      writer.write( "static", "%s" (typeInfo.$staticFlag) );
      writer.write( "display", typeInfo.$get_display_stirng_with( typeInfo.$rawTxt, nil ) );
      writer.endElement();
      writer.endElement();
      writer.fin();
      os.exit( 0 );
   }

   pro fn errorShadowingOp(
      pos:&Tokenizer.Position, symbolInfo:&Ast.SymbolInfo!, errFlag:bool ) mut
   {
      when! symbolInfo {
         let symPos = symbolInfo.$pos;
         when! symPos {
            let mess = "This symbol is shadowed from %d:%d -- %s"
                (pos.lineNo, pos.column, symbolInfo.$name );
            self.addWarnErrMess( symPos, errFlag, mess );
         }
         let mess = "shadowing symbol of %s -- %s"
            (symPos and "%s:%s" (symPos$.lineNo, symPos$.column) or "external",
              symbolInfo.$name );
         self.addWarnErrMess( pos, errFlag, mess );
      }
   }
   
   
   fn errorShadowing( pos:&Tokenizer.Position, symbolInfo:&Ast.SymbolInfo! ) mut {
      self.errorShadowingOp( pos, symbolInfo,not self.ctrl_info.warningShadowing );
   }
   
   pri fn checkShadowing( pos:&Tokenizer.Position, name:str, scope:&Ast.Scope ) mut {
      if name == "_" {
         return;
      }
      let! symbolInfo = self.$scope.getSymbolTypeInfo(
         name, scope, self.moduleScope, self.scopeAccess )
      {
         return;
      };

      self.errorShadowing( pos, symbolInfo );
   }

   
   pro fn addLocalVar(
      pos:&Tokenizer.Position, argFlag:bool, canBeLeft:bool, name:str,
      typeInfo: &Ast.TypeInfo, mutable:Ast.MutMode, allowShadow:bool! ) mut:
      &Ast.SymbolInfo
   {
      if not allowShadow {
         self.checkShadowing( pos, name, self.$scope );
      }

      if self.analyzeMode == .Inquire and self.isTargetTokenPos( name, pos ) {
         self.dumpSymbolType( .Local, name, typeInfo );
      }
      
      return unwrap self.$scope.addLocalVar(
         self.processInfo, argFlag, canBeLeft, name, pos, typeInfo, mutable );
   }


   fn checkImplicitCast(
      alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo>, validCastToGen:bool,
      dstTypeList:&List<&Ast.TypeInfo>, expListNode:&Nodes.ExpListNode,
      callback:checkImplicitCastCallback ) mut : Nodes.ExpListNode!;

   fn getLineNo( token:&Tokenizer.Token ) : &Tokenizer.Position {
      let mut pos = token.pos;
      if! let work = self.funcBlockInfoLinkNo {
         pos = work;
      }
      if self.macroCtrl.$analyzeInfo.$mode ~= .None {
         pos = unwrap self.macroCtrl.$macroCallLineNo;
      }
      return pos;
   }
}

fn TransUnit.canBeAsyncParam(
   fromScope:&Ast.Scope, typeInfo:&Ast.TypeInfo ) : bool, str {
   switch typeInfo.$nilableTypeInfo.$srcTypeInfo.$genSrcTypeInfo {
      case self.builtinFunc.__pipe_,
           self.builtinFunc.__lns_sync_flag_
      {
         return true, "";
      }
   }
   return Ast.TypeInfo.canBeAsyncParam( fromScope, typeInfo )**;
}


/** 最高優先度 */
let mut opTopLevel = 0;

fn setupOpLevel() : &Map<str,int>, &Map<str,int> {
   let op2levelMapWork:Map<str,int> = {};
   let op1levelMapWork:Map<str,int> = {};
   
   let mut opLevelBase = 0;
   fn regOpLevel( opnum: int, opList: str[@] ) __trans {
      opLevelBase = opLevelBase + 1;
      if opnum == 1 {
         foreach op in opList {
            op1levelMapWork[ op ] = opLevelBase;
         }
      }
      else {
         foreach op in opList {
            op2levelMapWork[ op ] = opLevelBase;
         }
      }
   }
   regOpLevel( 2, [@ "=" ] );
   regOpLevel( 2, [@ "or" ] );
   regOpLevel( 2, [@ "and" ] );
   regOpLevel( 2, [@ "<", ">", "<=", ">=", "~=", "==" ] );
   regOpLevel( 2, [@ "|" ] );
   regOpLevel( 2, [@ "~" ] );
   regOpLevel( 2, [@ "&" ] );
   regOpLevel( 2, [@ "|<<", "|>>" ] );
   regOpLevel( 2, [@ ".." ] );
   regOpLevel( 2, [@ "+", "-" ] );
   regOpLevel( 2, [@ "*", "/", "//", "%" ] );
   regOpLevel( 1, [@ "`{", ",,", ",,,", ",,,," ] );
   regOpLevel( 1, [@ "not", "#", "-", "~" ] );
   regOpLevel( 1, [@ "^" ] );

   opTopLevel = opLevelBase + 1;

   return op2levelMapWork, op1levelMapWork;
}

let op2levelMap, op1levelMap = setupOpLevel();



let quotedChar2Code = {
   'a' : 7,    // \a
   'b' : 8,    // \b
   't' : 9,    // \t
   'n' : 10,   // \t
   'v' : 11,   // \v
   'f' : 12,   // \f
   'r' : 13,   // \r
   '\\' : ?\\, // \\
   '"' : ?\",  // "
   "'" : ?\',  // '
};

fn TransUnit.createModifier(
   typeInfo:&Ast.TypeInfo, mutMode: Ast.MutMode ) __async mut : &Ast.TypeInfo
{
   if not self.validMutControl {
      return typeInfo;
   }
   return self.processInfo.createModifier( typeInfo, mutMode );
}

fn TransUnit.createExtType(
   pos:&Tokenizer.Position, typeInfo:&Ast.TypeInfo ) mut :&Ast.TypeInfo
{
   _match self.processInfo.createLuaval( typeInfo, true ) {
      case .OK( work, _ ) {
         return work;
      }
      case .Err( err ) {
         self.addErrMess( pos, "not support -- %s" ( err ) );
         return typeInfo;
      }
   }
}

pub override fn TransUnit.errorAt( pos:&Tokenizer.Position, mess: str ) __async mut : __ {
   self.addErrMess( pos, mess);

   foreach errmess in TransUnitIF.sortMess( self.errMessList ) {
      Util.errorLog( errmess.$mess );
   }
   foreach warnmess in TransUnitIF.sortMess( self.warnMessList ) {
      Util.errorLog( warnmess.$mess );
   }
   if self.macroCtrl.$analyzeInfo.$mode ~= .None {
      Util.println( "------ near code -----", self.macroCtrl.$analyzeInfo.$mode.$_txt );
      Util.println( self.tokenizer.getNearCode() );
      Util.println( "------" );
   }
   
   Util.err( "has error" ); // エラー
}

fn TransUnit.createNoneNode( pos: &Tokenizer.Position ) mut : Nodes.Node {
   return Nodes.NoneNode.create(
      self.nodeManager, pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ] );
}

pub fn TransUnit.pushbackToken( token: &Tokenizer.Token ) __async mut {
   self.tokenizer.pushbackToken( token );
}


pub fn TransUnit.newPushback( tokenList: List<&Tokenizer.Token> ) __async mut {
   self.tokenizer.newPushback( tokenList );
}

pub fn TransUnit.getStreamName() __async : str {
   return self.tokenizer.getStreamName();
}

pub fn TransUnit.createPosition( lineNo: int, column: int ) __async : &Tokenizer.Position {
   return self.tokenizer.createPosition( lineNo, column );
}

// Test 
fn TransUnit.isValidBlockWithoutTesting(): bool {
   return not self.inTestBlock or self.ctrl_info.testing;
}

pub fn TransUnit.getTokenNoErr(skipFlag:bool!) __async mut : &Tokenizer.Token
{
   let mut token;

   let mut commentList:List<&Tokenizer.Token>! = nil;
   let mut workToken = self.tokenizer.getTokenNoErr(##);
   if workToken.kind == Tokenizer.TokenKind.Cmnt {
      let workCommentList:List<&Tokenizer.Token> = [];
      while workToken.kind == Tokenizer.TokenKind.Cmnt {
         workCommentList.insert( workToken );
         workToken = self.tokenizer.getTokenNoErr(##);
      }
      commentList = workCommentList;
   }
   if workToken.$kind ~= .Eof {
      token = workToken;
      if self.macroCtrl.$analyzeInfo.$mode ~= .None and
         ( not skipFlag or self.isValidBlockWithoutTesting() )
      {
         // テストブロック内のマクロ展開は、テストが有効な時に行なう。
         token = self.macroCtrl.expandMacroVal(
            self.typeNameCtrl, self.$scope, self, token );
      }
      if not self.ctrl_info.compatComment {
         when! commentList {
            self.commentCtrl.addDirect( commentList );
         }
      }
   }
   else {
      token = Tokenizer.getEofToken();
      when! commentList {
         self.commentCtrl.addDirect( commentList );
      }
   }

   if #token.$commentList > 0 {
      self.commentCtrl.add( token );
   }

   return token;
}



pro fn TransUnit.getToken( allowEof:bool! ) mut : &Tokenizer.Token {
   let token = self.getTokenNoErr(##);
   if token == Tokenizer.getEofToken() {
      if allowEof {
         return token;
      }
      self.error( "EOF" ); // 要対応
   };

   return token;
}

pub fn TransUnit.pushback() __async mut {
   self.tokenizer.pushback();
}

pub fn TransUnit.pushbackStr(
   asyncParse:bool!, name: str, statement: str, pos:&Types.Position ) __async mut
{
   let! async = asyncParse {
      if self.ctrl_info.macroAsyncParseStmtLen == 0 {
         async = false;
      } else {
         async = #statement >= self.ctrl_info.macroAsyncParseStmtLen;
      }
   };
   
   self.tokenizer.pushbackStr( async, name, statement, pos );
}

enum SymbolMode {
   /** _ で始まるシンボル */
   Must_,
   /** _ で始まってはいけないシンボル */
   MustNot_,
   /** _ で始まってはいけないシンボル。ただし _ は許可 */
   MustNot_Or_,
}

let specialSymbolSet = (@
   "__init",
   "__free",
   "__",
   "_exp"
);

/** ユーザ定義のシンボルとして許可しないキーワード */
let builtinKeywordSet = (@ "self", "super" );

/**
指定 token をシンボルとして利用可能かチェックする。
*/
fn TransUnit.checkSymbol( token: &Tokenizer.Token, mode:SymbolMode ) mut : &Tokenizer.Token {
   if token.kind ~= Tokenizer.TokenKind.Symb and
      token.kind ~= Tokenizer.TokenKind.Kywd and
      token.kind ~= Tokenizer.TokenKind.Type
   {
      self.addErrMess( token.pos, "illegal symbol -- '%s'" ( token.txt) );
   }
   let frontChar = token.txt[1];
   if mode == .Must_ and frontChar ~= ?_ {
      self.addErrMess(
         token.pos, "macro name must begin with '_' -- '%s'" ( token.txt ) );
   }
   elseif mode ~= .Must_ and frontChar == ?_ {
      if not self.ignoreToCheckSymbol_ {
         if mode == .MustNot_Or_ and token.txt == "_" {
            //
         }
         elseif not specialSymbolSet.has( token.txt ) {
            self.addErrMess(
               token.pos, "symbol must not begin with '_' -- '%s'" ( token.txt ) );
         }
      }
   }
   elseif builtinKeywordSet.has( token.txt ) {
      self.addErrMess(
         token.pos, "this symbol is special keyword -- %s" (token.txt) );
   }
   elseif Tokenizer.isLuaKeyword( token.txt ) or
      Tokenizer.isOp2( token.txt ) or Tokenizer.isOp1( token.txt )
   {
      self.addErrMess(
         token.pos, "this symbol is lua keyword -- %s" (token.txt) );
   }
   return token;
}

local fn TransUnit.getSymbolToken(mode:SymbolMode) mut : &Tokenizer.Token {
   return self.checkSymbol( self.getToken(##), mode );
}


local fn TransUnit.checkToken( token: &Tokenizer.Token, txt: str ) mut : &Tokenizer.Token {
   if token.txt ~= txt {
      self.error( "not found -- '%s'. actually '%s'" ( txt, token.txt ) ); // 要対応
   }
   return token;
}

local fn TransUnit.checkNextToken( txt: str ) mut : &Tokenizer.Token {
   return self.checkToken( self.getToken(##), txt );
}

/**
次のトークンが、スペースの空きがなく、連続したトークンであるか確認する。

@return &Tokenizer.Token 次のトークン
@return bool 連続したトークンだった場合 true
*/
fn TransUnit.getContinueToken() mut : &Tokenizer.Token, bool {
   let token = self.getToken(##);
   return token, token.consecutive;
}


fn TransUnit.getDefaultAsync(
   kind:&Ast.TypeInfoKind,
   classTypeInfo:&Ast.TypeInfo!, asyncMode:Ast.Async! ) : Ast.Async
{
   when! asyncMode {
      return asyncMode;
   }

   fn process( defaultAsyncMode:DefaultAsyncMode ) : Ast.Async {
      _switch defaultAsyncMode {
         case .AsyncAll, .AsyncFunc {
            return .Async;
         }
         case .NoAsync {
            return .Noasync;
         }
      }
   }

   when! classTypeInfo {
      if! self.class2defaultAsyncMode[ classTypeInfo ] {
         return process( _exp );
      }
   }
   
   switch kind {
      case .Method {
         if self.defaultAsyncMode == .AsyncAll {
            return .Async;
         }
      }
      case .Func, .FormFunc {
         return process( self.defaultAsyncMode );
      }
   }
   return .Noasync;
}


/**
CondRetNode が登録されている場合、CondRetListNode を生成して返す。
*/
local fn TransUnit.checkCondRet() mut : &Nodes.CondRetInfo! {
   if #self.$curNsInfo.$condRetNodeList > 0 {
      let info = new Nodes.CondRetInfo( self.$curNsInfo.$condRetNodeList );
      self.$curNsInfo.clearCondRetNodeList();
      return info;
   }
   return nil;
}


/**
termTxt が表われるまで statement を解析し、 stmtList に格納する。

@param stmtList 解析した statement を格納するリスト
@param firstSwitchingTokenizer Tokenizer を切り替えた初回の処理かどうか。
@param termTxt 終端文字列。 nil の場合は EOF まで解析する。
@return Nodes.Node! 最後に解析した statement
@return int 最後に解析した statement の直前の行
*/
local fn TransUnit.analyzeStatementList(
   stmtList: List<&Nodes.Node>,
   mut firstSwitchingTokenizer:bool, termTxt: str! ) mut : Nodes.Node!, int
{
   let mut breakKind = Nodes.BreakKind.None;
   if #stmtList > 0 {
      breakKind = stmtList[ #stmtList ].getBreakKind( .Normal );
   }

   let mut tokenizer2lastLineMap:Map<&Tokenizer.PushbackTokenizer,int> = {};
   fn getLastLineNo() __trans : int {
      if! let lastLineNo = tokenizer2lastLineMap[ self.tokenizer ] {
         return lastLineNo;
      }
      return self.tokenizer.getLastPos().lineNo;
   }
   fn setLastLineNo( lineNo:int ) __trans {
      tokenizer2lastLineMap[ self.tokenizer ] = lineNo;
   }
   
   let mut lastStatement:Nodes.Node! = nil;
   let mut lastLineNo = getLastLineNo();

   // コメントが、直前の文の末尾と同じ行にあるかどうか調べ、
   // 同じ行にある場合は、直前の文のコメントとしてセットする
   fn setTailComment( statement:Nodes.Node! ) __trans: int
   {
      let blank;
      let mut commentList = self.commentCtrl.$commentList;
      if #commentList > 0 {
         when! lastStatement {
            let mut tailComment:&Tokenizer.Token! = nil;
            foreach comment in commentList {
               if comment.pos.lineNo == lastStatement.$pos.lineNo {
                  if not tailComment {
                     lastStatement.set_tailComment( comment );
                     tailComment = comment;
                  }
                  else {
                     // 1行に複数のコメントがあるのはエラー
                     // self.addErrMess(
                     //    comment.pos,
                     //    "there are multi comment per line. -- %s" (comment.txt) );
                  }
               }
               // if! let invalidComment = self.commentCtrl.hasInvalidComment() {
               //    // 1行に複数のコメントがあるのはエラー
               //    // self.addErrMess(
               //    //    invalidComment.pos,
               //    //    "there are multi comment per line. -- %s" (invalidComment.txt) );
               // }
            }
            if tailComment {
               commentList.remove( 1 );
            }
         }
      }
      if #commentList > 0 {
         blank = commentList[ 1 ].pos.lineNo - commentList[ 1 ].getLineCount() - lastLineNo;
      }
      else {
         when! statement {
            blank = statement.$pos.lineNo - lastLineNo;
         }
         else {
            blank = self.tokenizer.getLastPos().lineNo - lastLineNo;
         }
      }
      return blank;
   }

   while true {
      lastLineNo = getLastLineNo();
      let mut statement = self.analyzeStatement( termTxt );
      when! statement {
         if breakKind ~= .None {
            if statement.$kind ~= Nodes.NodeKind.$BlankLine {
               self.addErrMess(
                  statement.$pos,
                  "This statement is not reached -- %s" (breakKind.$_txt) );
            }
         }

         // 空白行と、コメントの処理
         let blank = setTailComment( statement );
         if blank > 1 and not firstSwitchingTokenizer {
            stmtList.insert(
               Nodes.BlankLineNode.create(
                  self.nodeManager, self.createPosition( lastLineNo + 1, 0 ),
                  self.inTestBlock, self.macroCtrl.isInAnalyzeArgMode(),
                  [ Ast.builtinTypeNone ], blank - 1 ) );
         }
         setLastLineNo( self.tokenizer.getLastPos().lineNo );
         if firstSwitchingTokenizer {
            firstSwitchingTokenizer = false;
         }

         stmtList.insert( statement );
         lastStatement = statement;
         if statement.$kind ~= Nodes.NodeKind.$BlankLine {
            breakKind = statement.getBreakKind( .Normal );
         }
         
         statement.addComment( self.commentCtrl.$commentList );
         self.commentCtrl.clear();
      }
      else {
         setTailComment( nil );
         break;   
      }
   }
   return lastStatement, lastLineNo;
}

local fn TransUnit.analyzeStatementListSubfile(
   stmtList: List<&Nodes.Node> ) mut : &Nodes.Node!
{
   let statement = self.analyzeStatement( ##);

   if! statement {
      if _exp.$kind ~= Nodes.NodeKind.$Subfile {
         self.error( "subfile must have 'subfile' declaration at top." ); // 要対応
      }
   }
   else {
      self.error( "subfile must have 'subfile' declaration at top." ); // 要対応
   }

   return (self.analyzeStatementList( stmtList, true ## ));
}

fn TransUnit.supportLang( lang:LuneControl.Code ) : bool {
   foreach pragma in self.helperInfo.pragmaSet {
      match pragma {
         case .limit_conv_code( codeSet ) {
            return codeSet.has( lang );
         }
      }
   }
   return true;
}

pro fn TransUnit.analyzeLuneControlToken(
   firstToken:&Tokenizer.Token, controlToken:&Tokenizer.Token ) mut : LuneControl.Pragma!
{
   return nil;
}

/**
_lune_control の解析


@return Nodes.LuneControlNode! 解析失敗した場合 nil
*/
fn TransUnit.analyzeLuneControl(
   firstToken: &Tokenizer.Token ) mut : Nodes.LuneControlNode!
{
   let mut node:Nodes.LuneControlNode! = nil;
   let nextToken = self.getToken(##);

   let pragma;

   if! let work = self.analyzeLuneControlToken( firstToken, nextToken ) {
      pragma = work;
   } else {
      switch ( nextToken.txt ) {
         // case "disable_mut_control" {
         //    self.validMutControl = false;
         //    self.modifier.set_validMutControl( false );
         //    pragma = LuneControl.Pragma.disable_mut_control;
         // }
         // case "ignore_symbol_" {
         //    self.ignoreToCheckSymbol_ = true;
         //    pragma = LuneControl.Pragma.ignore_symbol_;
         // }
         case "load__lune_module" {
            pragma = LuneControl.Pragma.load__lune_module;
         }
         // case "limit_conv_code" {
         //    let mut codeSet:Set<LuneControl.Code> = (@);
         //    while true {
         //       let token = self.getToken(##);
         //       if token.txt == ";" {
         //          self.pushback();
         //          break;
         //       }
         //       if! let code = LuneControl.Code._from( token.txt ) {
         //          codeSet.add( code );
         //       }
         //       else {
         //          self.addErrMess( token.pos, "illegal code -- '%s'" (token.txt ) );
         //       }
         //    }
         //    pragma = LuneControl.Pragma.limit_conv_code( codeSet );
         // }
         // case "use_async" {
         //    pragma = LuneControl.Pragma.use_async;
         // }
         case "run_async_pipe" {
            if not self.helperInfo.pragmaSet.has( LuneControl.Pragma.use_async ) {
               self.addErrMess( nextToken.pos, "must set '_lune_control use_async'" );
            }
            
            let nowMethod = self.getCurrentNamespaceTypeInfo();
            let nowClass = nowMethod.$parentInfo;
            let mut valid = false;
            if nowMethod.$kind == .Method and Ast.isClass( nowClass ) {
               if! let loopMethod = nowClass.$scope$.getTypeInfoChild$( "loop" ) {
                  if loopMethod.$kind == .Method and #loopMethod.$argTypeInfoList == 0 {
                     valid = true;
                  }
               } 
            }
            if valid {
               pragma = LuneControl.Pragma.run_async_pipe;
            } else {
               self.addErrMess(
                  nextToken.pos, 
                  "this option only use in method of the class have loop method." );
               return nil;
            }
         }
         case "default_strict_generics" {
            pragma = LuneControl.Pragma.default_strict_generics;
         }
         // case "default_async_func" {
         //    pragma = LuneControl.Pragma.default_async_func;
         //    self.defaultAsyncMode = .AsyncFunc;
         // }
         // case "default_async_all" {
         //    pragma = LuneControl.Pragma.default_async_all;
         //    self.defaultAsyncMode = .AsyncAll;
         // }
         // case "use_macro_special_var" {
         //    pragma = LuneControl.Pragma.use_macro_special_var;
         //    self.analyzePhase = .Main;
         // }
         // case "single_phase_ast" {
         //    pragma = LuneControl.Pragma.single_phase_ast;
         //    self.analyzePhase = .Main;
         // }
         default {
            self.addErrMess( nextToken.pos, "unknown option -- %s" (nextToken.txt) );
            self.checkNextToken( ";" );
            return nil;
         }
      }
   }

   node = Nodes.LuneControlNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], pragma );
   self.helperInfo.pragmaSet.add( pragma );

   self.checkNextToken( ";" );
   return node;
}

enum TentativeMode {
   /** 関数定義の本体ブロックなど、独立したブロックの最外ブロックに使用する */
   Ignore,
   /** for 文などのループ処理のブロックで使用する */
   Loop,
   /** 単純なブロック文など、一つのブロックで完結する場合に使用する */
   Simple,
   /** if else などの複数ブロックの、if など先頭のブロックで使用する */
   Start,
   /** if elseif else などの複数ブロックの、elseif などの途中のブロックで使用する */
   Merge,
   /** if else などの複数ブロックの、 else などの最後のブロックで使用する */
   Finish,
}

local fn TransUnit.analyzeBlock(
   blockKind: Nodes.BlockKind,
   tentativeMode:TentativeMode, scope: Ast.Scope!,
   refAccessSymPosList:&List<RefAccessSymPos>! ) mut : Nodes.BlockNode
{
   let mut backScope = self.$scope;
   when! scope {
      self.setScope( scope, .FromScope );
   }
   else {
      self.pushScope( .Other ## );
   }
   let mut blockScope = self.$scope;

   blockScope.addIgnoredVar( self.processInfo );

   //let mut nsInfo = self.$curNsInfo;
   let mut nsInfo = self.$curNsInfo;
   
   switch tentativeMode {
      case .Loop {
         self.prepareTentativeSymbol( self.$scope, true, refAccessSymPosList );
      }
      case .Simple, .Start, .Ignore {
         self.prepareTentativeSymbol( self.$scope, false, nil );
      }
      case .Merge, .Finish {
         self.mergeTentativeSymbol( self.$scope );
      }
   }

   let mut loopFlag = false;
   switch blockKind {
      case .For, .Apply, .While, .Repeat, .Foreach {
         loopFlag = true;
         nsInfo.$loopScopeQueue.insert( self.$scope );
      }
   }

   let mut stmtList:List<&Nodes.Node> = [];
   
   let token = self.checkNextToken( "{" );

   self.analyzeStatementList( stmtList, false, "}" );
   nsInfo.addStmtNum( #stmtList );

   self.checkNextToken( "}" );

   
   if loopFlag {
      nsInfo.$loopScopeQueue.remove(##);
   }
   

   when! scope {
      //self.scope = backScope;
      self.setScope( backScope, .FromScope );
   }
   else {
      self.popScope();
   }

   let mut node = Nodes.BlockNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      blockKind, blockScope, stmtList );

   if node.getBreakKind( .Normal ) ~= .None {
      self.tentativeSymbol.skip();
   }

   if blockKind ~= .Repeat {
      switch tentativeMode {
         case .Simple, .Finish {
            self.finishTentativeSymbol( true );
         }
         case .Ignore, .Loop {
            self.finishTentativeSymbol( false );
         }
      }
   }

   return node;
}

fn TransUnit.skipBlock( recordToken:bool ) mut : List<&Tokenizer.Token> {
   let mut blockDepth = 0;
   let mut tokenList:List<&Tokenizer.Token> = [];
   //tokenList = tokenList.__new( 1000 );
   while true {
      let token = self.getTokenNoErr( not recordToken );
      if recordToken {
         tokenList.insert( token );
      }
      if token.kind == .Eof {
         self.error( "EOF" ); // 要対応
      }
      switch token.txt {
         case "{", "`{" {
            blockDepth = blockDepth + 1;
         }
         case "}" {
            blockDepth = blockDepth - 1;
            if blockDepth <= 0 {
               break;
            }
         }
         default {
         }
      }
   }
   if blockDepth < 0 {
      self.error( "mismatch '}'" ); // 要対応
   }

   return tokenList;
}

local fn TransUnit.skipAndCreateDummyBlock() mut : Nodes.BlockNode {
   let blockToken = self.checkNextToken( "{" );
   self.pushback();
   let blockScope = self.pushScope( .Other ## );
   let stmtList:List<&Nodes.Node> = [];
   self.popScope();

   self.skipBlock( false );
   
   return Nodes.BlockNode.create(
      self.nodeManager, blockToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      .Func, blockScope, stmtList );
}


fn TransUnit.analyzeRequest( reqToken: &Tokenizer.Token ) mut : Nodes.RequestNode
{
   let processor = self.analyzeExp( false, true, false, false, nil, Ast.builtinTypeProcessor );
   if processor.$expType ~= Ast.builtinTypeProcessor {
      self.addErrMess(
         processor.$pos,
         "It must be 'processor'. -- %s" (processor.$expType.getTxt(##)) );
   }
   let exp = self.analyzeExp( false, true, false, false, nil, nil );

   return Nodes.RequestNode.create(
      self.nodeManager, reqToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), exp.$expTypeList,
      processor, exp );
}

fn TransUnit.analyzeAsyncLock(
   asyncToken: &Tokenizer.Token, lockKind:Nodes.LockKind ) mut : Nodes.Node
{
   let mut nsInfo = self.getNSInfo( self.getCurrentNamespaceTypeInfo() );
   _switch lockKind {
      case .AsyncLock {
         if nsInfo.isNoasync() {
            // noasync 中は __asyncLock できない。
            self.addErrMess(
               asyncToken.pos,
               "can't use __asyncLock on __noasync. -- %s" (nsInfo.$typeInfo.getTxt(##)));
         }
      }
      case .LuaLock, .LuaDepend {
         if nsInfo.isNoasync() {
            // noasync 中は __luaDepend, __luaLock できない。
            self.addErrMess(
               asyncToken.pos,
               "can't use __luaDepend or __luaLock on __noasync. -- %s"
               (nsInfo.$typeInfo.getTxt(##)) );
         }
      }
      case .LuaGo {
         if not nsInfo.isNoasync() {
            // async 中は __luago できない。
            self.addErrMess(
               asyncToken.pos,
               "can't use __luago on __async. -- %s" (nsInfo.$typeInfo.getTxt(##)) );
         }
      }
   }

   nsInfo.incLock( lockKind );
   
   let block = self.analyzeBlock( .AsyncLock, .Simple, nil, nil );

   nsInfo.decLock();
   
   return Nodes.AsyncLockNode.create(
      self.nodeManager, asyncToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      lockKind, block );
}

fn TransUnit.analyzeIf(
   token: &Tokenizer.Token ) mut : Nodes.Node
{
   let mut nextToken, continueFlag = self.getContinueToken();
   if continueFlag and nextToken.txt == "!" {
      return self.analyzeIfUnwrap( token );
   }
   self.pushback();

   let mut list:List<Nodes.IfStmtInfo> = [];
   let ifExp = self.analyzeExpOneRVal( false, false, true ## );
   let condRetInfo = self.checkCondRet();
   
   list.insert( new Nodes.IfStmtInfo( .If, condRetInfo, ifExp,
                                      self.analyzeBlock( .If, .Start ## ) ) );

   fn checkCond( condExp:&Nodes.Node ) {
      switch condExp.$expType.$kind {
         case .Nilable, .Stem {
            ;
         }
         case .Prim {
            if not condExp.$expType.equals( self.processInfo, Ast.builtinTypeBool ## ) {
               self.addErrMess(
                  condExp.$pos, "This exp never be false -- %s"
                  ( condExp.$expType.getTxt(##)) );
            }
         }
         default {
            self.addErrMess(
               condExp.$pos, "This exp never be false -- %s"
               ( condExp.$expType.getTxt(##)) );
         }
      }
   }
   checkCond( ifExp );

   nextToken = self.getToken( true );
   if nextToken.txt == "elseif" {
      while nextToken.txt == "elseif" {
         let condExp = self.analyzeExpOneRVal( false, false ## );
         list.insert( new Nodes.IfStmtInfo( .ElseIf, nil, condExp,
                                            self.analyzeBlock( .Elseif, .Merge ## ) ));
         checkCond( condExp );
         nextToken = self.getToken( true );
      }
   }

   if nextToken.txt == "else" {
      list.insert( new Nodes.IfStmtInfo(
         .Else, nil, self.createNoneNode( nextToken.pos ),
         self.analyzeBlock( .Else, .Finish ## ) ));
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   return Nodes.IfNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], list );
}

/**
default 部分の処理を行なう。
*/
fn TransUnit.processCaseDefault(
   firstToken:&Tokenizer.Token, mut caseKind:Nodes.CaseKind,
   nextToken:&Tokenizer.Token, hasCase:bool ) mut :
Nodes.BlockNode!, bool
{
   let keyword = firstToken.txt.gsub( "_", "" );
   let fullKeyword = "_%s" (keyword);
   if firstToken.txt == fullKeyword and caseKind ~= .MustFull {
      self.addErrMess( firstToken.pos,
                       "This '%s' hasn't enough 'case' condition." (keyword));
   }
   
   let mut defaultBlock: Nodes.BlockNode! = nil;
   let mut failSafeDefault = false;
   if nextToken.txt == "default" or nextToken.txt == "_default" {
      if firstToken.txt == fullKeyword {
         self.addErrMess(
            nextToken.pos, "'_%s' can't have default." (keyword));
      }
   
      if nextToken.txt == "_default" {
         failSafeDefault = true;
      }
      elseif caseKind == .Full {
         self.addWarnMess(
            nextToken.pos,
            "This '%s' has full case. This 'default' is no reach." (keyword) );
      }
      defaultBlock = self.analyzeBlock(
         .Default, not hasCase and TentativeMode.Simple or TentativeMode.Finish ## );
   }
   else {
      if hasCase {
         self.finishTentativeSymbol( caseKind ~= .Lack );
      }
      self.pushback();
   }
   self.checkNextToken( "}" );

   if not hasCase {
      self.addWarnMess( firstToken.pos,
                        "'%s' should have 'case' blocks." (keyword));
      if defaultBlock {
         self.addErrMess(
            firstToken.pos,
            "'%s' must have 'case' blocks when have 'default' block." (keyword) );
      }
   }

   return defaultBlock, failSafeDefault;
}

fn TransUnit.analyzeSwitch( firstToken: &Tokenizer.Token ) mut : Nodes.SwitchNode {
   let exp = self.analyzeExpOneRVal( false, false ## );

   self.checkNextToken( "{" );

   let mut caseList: List<Nodes.CaseInfo> = [];

   let mut condObjSet:Set<&stem> = (@);
   let mut condSymIdSet:Set<int> = (@);
   let mut hasNilCond = false;
   
   let mut nextToken = self.getToken(##);
   let mut firstFlag = true;
   while ( nextToken.txt == "case" ) {
      self.checkToken( nextToken, "case" );
      let condexpList = self.analyzeExpList(
         false, false, false, false, nil, [ exp.$expType ], true );
      let condBock = self.analyzeBlock(
         .Switch, firstFlag and TentativeMode.Start or TentativeMode.Merge ## );
      if firstFlag {
         firstFlag = false;
      }

      foreach condExp in condexpList.$expList {
         // 同じ case 条件が無いかチェック
         if condExp.$expType.$nilable {
            if hasNilCond {
               self.addWarnMess( condExp.$pos, "multiple case with nil or nilable" );
            } else {
               hasNilCond = true;
            }
         }
         if! let condLiteral = condExp.getLiteral() {
            let literalObj = Nodes.getLiteralObj( condLiteral );
            when! literalObj {
               if condObjSet.has( literalObj ) {
                  self.addErrMess( condExp.$pos, "multiple case exp -- %s" (literalObj) );
               }
               else {
                  condObjSet.add( literalObj );
               }
            }
         } else {
            if! let expRef = condExp@@@Nodes.ExpRefNode {
               let symInfo = expRef.$symbolInfo;
               if condSymIdSet.has( symInfo.$symbolId ) {
                  self.addErrMess(
                     condExp.$pos, "multiple case exp -- %s" (symInfo.$name));
               }
               else {
                  condSymIdSet.add( symInfo.$symbolId );
               }
            }
         }
         
         // switch の式と case の条件の型の不一致チェック
         if not exp.$expType.canEvalWith(
            self.processInfo, condExp.$expType, .Equal, {} )
         {
            self.addErrMess(
               condExp.$pos,
               "case exp unmatch type -- %s <- %s"
               (exp.$expType.getTxt(##), condExp.$expType.getTxt(##)) );
         }
      }

      
      caseList.insert( new Nodes.CaseInfo( condexpList, condBock ) );
      nextToken = self.getToken(##);
   }

   let mut caseKind:Nodes.CaseKind;
   if! let enumType = exp.$expType.$srcTypeInfo.$aliasSrc@@@Ast.EnumTypeInfo {
      // enum 値の switch の場合、全ての case をチェックしているかどうかを調べる
      let mut miss = false;
      foreach enumVal in enumType.$name2EnumValInfo {
         if not condObjSet.has( Ast.getEnumLiteralVal( enumVal.$val ) ) {
            miss = true;
            break;
         }
      }
      if not miss {
         if firstToken.txt == "_switch" {
            caseKind = .MustFull;
         }
         else {
            caseKind = .Full;
         }
      }
      else {
         caseKind = .Lack;
      }
   }
   else {
      caseKind = .Lack;
      if firstToken.txt == "_switch" {
         self.addErrMess( exp.$pos, "The condition of '_switch' must be enum." );
      }
   }

   let defaultBlock, failSafeDefault = self.processCaseDefault(
      firstToken, caseKind, nextToken, #caseList ~= 0 );
   let mut nsInfo = self.$curNsInfo;
   
   return Nodes.SwitchNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      nsInfo.getNextStmtId( .Switch ), exp, caseList,
      defaultBlock, caseKind, failSafeDefault, firstToken.txt == "_switch" );
}


fn TransUnit.analyzeMatch( firstToken: &Tokenizer.Token ) mut : Nodes.MatchNode {
   let exp = self.analyzeExpOneRVal( false, false ## );

   let! algeTypeInfo = exp.$expType.$srcTypeInfo.$genSrcTypeInfo@@@Ast.AlgeTypeInfo {
      self.error( "match must have alge value -- %s" (exp.$expType.getTxt(##)) ); // 要対応
   };

   if not self.moduleType.equals(
      self.processInfo, algeTypeInfo.getModule() ## )
   {
      if not self.importModuleSet.has( algeTypeInfo.getModule() ) and
         algeTypeInfo.getModule() ~= Ast.headTypeInfo
      {
         // alge を宣言しているモジュールを import していない場合
         let fullname = algeTypeInfo.getFullName(
            self.typeNameCtrl, self.$scope, true );
         self.addErrMess(
            firstToken.pos,              
            "need to import module -- %s (%s)"
            ( fullname, algeTypeInfo.getTxt(##) ) );
      }
   }

   let alt2typeMap;
   if! let genTypeInfo = exp.$expType.$srcTypeInfo@@@Ast.GenericTypeInfo {
      alt2typeMap = genTypeInfo.createAlt2typeMap( false );
   } else {
      alt2typeMap = algeTypeInfo.createAlt2typeMap( false );
   }
   
   
   self.checkNextToken( "{" );

   let mut caseList: List<&Nodes.MatchCase> = [];
   let mut algeValNameSet: Set<str> = (@);

   let mut nextToken = self.getToken(##);
   let mut firstFlag = true;
   while ( nextToken.txt == "case" ) {
      self.checkNextToken( "." );
      let valNameToken = self.getToken(##);

      self.checkAlgeComp( valNameToken, algeTypeInfo );

      let! valInfo = algeTypeInfo.getValInfo( valNameToken.txt ) {
         self.error( "not found val -- %s" (valNameToken.txt) ); // 要対応
      };
      if algeValNameSet.has( valNameToken.txt ) {
         self.addErrMess( valNameToken.pos, "multiple val -- %s" (valNameToken.txt) );
      }
      algeValNameSet.add( valNameToken.txt );
      
      let mut valParamNameList:List<&Ast.SymbolInfo> = [];
      nextToken = self.getToken(##);
      let mut blockScope = self.pushScope( .Other ## );
      if nextToken.txt == "(" {
         foreach paramType in valInfo.$typeList {
            let paramName = self.getSymbolToken( .MustNot_Or_ );
            self.checkShadowing( paramName.pos, paramName.txt, self.$scope );

            let! mut workType = alt2typeMap[ paramType.$srcTypeInfo.$nonnilableType ] {
               workType = paramType;
            };
            if Ast.TypeInfo.isMut( paramType ) and
               not Ast.TypeInfo.isMut( exp.$expType )
            {
               workType = self.createModifier( workType, .IMut );
            }
            valParamNameList.insert(
               self.addLocalVar(
                  paramName.pos, false, false, paramName.txt, workType, .IMut ## ));
            nextToken = self.getToken(##);
            if nextToken.txt ~= "," {
               break;
            }
         }
         self.checkToken( nextToken, ")" );
      }
      else {
         self.pushback();
      }
      if #valParamNameList ~= #valInfo.$typeList {
         self.addErrMess( valNameToken.pos,
                          "unmatch param -- %d != %d"
                          (#valParamNameList, #valInfo.$typeList ) );
      }
      let mode = firstFlag and TentativeMode.Start or TentativeMode.Merge;
         
      let block = self.analyzeBlock( .Match, mode, blockScope, nil );
      if firstFlag {
         firstFlag = false;
      }
      self.popScope();
      let valRefNode = Nodes.ExpRefNode.create(
         self.nodeManager, valNameToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ valInfo.$algeTpye ],
         valInfo.$symbolInfo );
      let matchCase = new Nodes.MatchCase( valInfo, valRefNode, valParamNameList, block );

      caseList.insert( matchCase );
      nextToken = self.getToken(##);
   }

   let mut caseKind:Nodes.CaseKind;
   if algeValNameSet.len() == algeTypeInfo.$valInfoNum {
      if firstToken.txt == "_match" { 
         caseKind = .MustFull;
      } else {
         caseKind = .Full;
      }
   } else {
      caseKind = .Lack;
   }

   let defaultBlock, failSafeDefault = self.processCaseDefault(
      firstToken, caseKind, nextToken, #caseList ~= 0 );

   let mut nsInfo = self.$curNsInfo;
   
   return Nodes.MatchNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      nsInfo.getNextStmtId( .Match ), exp, .Alge( algeTypeInfo ),
      caseList, defaultBlock, caseKind, failSafeDefault, firstToken.txt == "_match" );
}



fn TransUnit.analyzeWhile( token: &Tokenizer.Token ) mut : Nodes.WhileNode {

   let refAccessSymPosList = clearThePosForModToRef( self.$scope, self.moduleScope );
   
   let cond = self.analyzeExpOneRVal( false, false## );
   let mut infinit = false;
   if cond.$expType == Ast.builtinTypeBool {
      if! let literal = cond.getLiteral() {
         match literal {
            case .Bool( val ) {
               infinit = val;
            }
         }
      }
   } elseif not cond.$expType.$nilable {
      infinit = true;
   }
   
   return Nodes.WhileNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], cond, infinit,
      self.analyzeBlock( .While, .Loop, nil, refAccessSymPosList ) );
}

fn TransUnit.analyzeRepeat( token: &Tokenizer.Token ) mut : Nodes.RepeatNode {
   let mut scope = self.pushScope( .Other## );
   let mut node = Nodes.RepeatNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      self.analyzeBlock( .Repeat, .Loop, scope, nil ),
      self.analyzeExpOneRVal( false, false ## ) );

   // repeat は、ブロックの後に条件があって、
   // その条件でブロック内のシンボルにアクセスできるので、
   // finishTentativeSymbol はここで行なう。
   self.finishTentativeSymbol( false );
      
   self.popScope();

   self.checkNextToken( ";" );
   return node;
}

fn TransUnit.analyzeFor( firstToken: &Tokenizer.Token ) mut : Nodes.ForNode {

   let mut scope = self.pushScope( .Other## );

   let val = self.getToken(##);
   if val.kind ~= Tokenizer.TokenKind.Symb {
      self.error( "not symbol" ); // 要対応
   }
   self.checkNextToken( "=" );
   let mut exp1 = self.analyzeExpOneRVal( false, false## );
   if not Ast.isNumberType( exp1.$expType ) {
      self.addErrMess( exp1.$pos,
                       "exp1 is not number -- %s" (exp1.$expType.getTxt(##)) );
   }
   self.checkNextToken( "," );
   let exp2 = self.analyzeExpOneRVal( false, false## );
   if not Ast.isNumberType( exp2.$expType ) {
      self.addErrMess( exp2.$pos,
                       "exp2 is not number -- %s" (exp2.$expType.getTxt(##)) );
   }
   let token = self.getToken(##);
   let mut exp3:Nodes.Node! = nil;
   if token.txt == "," {
      exp3 = self.analyzeExpOneRVal( false, false## );
      if! exp3 {
         if not Ast.isNumberType( _exp.$expType ) {
            self.addErrMess( _exp.$pos,
                             "exp is not number -- %s" (_exp.$expType.getTxt(##)) );
         }
      }

   }
   else {
      self.pushback();
   }

   if exp1.$expType == Ast.builtinTypeInt and
      exp2.$expType == Ast.builtinTypeReal or
      exp3$.$expType == Ast.builtinTypeReal
   {
      // いずれかが real の場合、 exp1 を real にキャストする
      exp1 = Nodes.ExpCastNode.create(
         self.nodeManager, exp1.$pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeReal ],
         exp1, Ast.builtinTypeReal, nil, "@@", .Force );
   }


   let mut nsInfo = self.$curNsInfo;
   let symbolInfo = nsInfo.registerSym( self.addLocalVar(
      val.pos, false, true, val.txt, exp1.$expType, .IMut## ) );

   let mut node = Nodes.ForNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      nsInfo.getNextStmtId( .For ), self.analyzeBlock( .For, .Loop, scope, nil ),
      symbolInfo, exp1, exp2, exp3 );
   self.popScope();

   return node;
}

fn TransUnit.analyzeApply( token: &Tokenizer.Token ) mut : Nodes.ApplyNode {
   let mut scope = self.pushScope( .Other## );
   let mut varList:List<&Tokenizer.Token> = [];
   let mut nextToken:&Tokenizer.Token = Tokenizer.getEofToken();
   repeat {
      let var = self.getSymbolToken( .MustNot_Or_ );
      if var.kind ~= Tokenizer.TokenKind.Symb {
         self.error( "illegal symbol" ); // 要対応
      }
      varList.insert( var );
      nextToken = self.getToken(##);
   } nextToken.txt ~= ",";
   self.checkToken( nextToken, "of" );

   let expListNode = self.analyzeExpList( false, false, false, false ## );

   let mut itFunc = Ast.builtinTypeNone;
   
   let expTypeList = expListNode.$expTypeList;
   if #expTypeList < 3 {
      self.addErrMess( expListNode.$pos, "apply must have 3 values -- %s" (#expTypeList) );
   }
   else {
      itFunc = expTypeList[ 1 ].$extedType;
   }

   let mut itemTypeList:List<&Ast.TypeInfo> = [];
   let mut defaultItemType = Ast.builtinTypeStem_;

   let mut readyFlag = false;
   if! let callNode = Nodes.getUnwraped( expListNode.$expList[ 1 ] )@@@Nodes.ExpCallNode {
      let callFuncType = callNode.$func.$expType;
      if callFuncType.equals( self.processInfo, self.builtinFunc.str_gmatch ## ) or
         callFuncType.equals( self.processInfo, self.builtinFunc.string_gmatch ## )
      {
         itemTypeList.insert( Ast.builtinTypeString );
         defaultItemType = Ast.builtinTypeString.$nilableTypeInfo;
         readyFlag = true;
      }
   }

   if not readyFlag {
      switch itFunc.$kind {
         case .Func, .FormFunc, .Form {
         }
         default {
            self.addErrMess(
               expListNode.$pos,
               "The 1st value must be iterator function. -- %s" (itFunc.getTxt(##)) );
         }
      }
      
      if #itFunc.$argTypeInfoList ~= 2 {
         self.addErrMess(
            expListNode.$pos,
            "iterator function must has two arguments. -- %s" (itFunc.getTxt(##)) );
      }
      else {
         let arg2Type = itFunc.$argTypeInfoList[ 2 ];
         if not arg2Type.$nilable {
            self.addErrMess(
               expListNode.$pos,
               "the 2nd argument of iterator function must be nilable. -- %s"
               (itFunc.getTxt(##)) );
         }
      }
      
      if #itFunc.$retTypeInfoList == 0 {
         self.addErrMess( expListNode.$pos, "iterator function must return value." );
      }
      else {
         let iteRetType = itFunc.$retTypeInfoList[ 1 ];
         if not iteRetType.$nilable {
            self.addErrMess(
               expListNode.$pos,
               "iterator function must return nilable type at 1st." );
         }
      }
      
      foreach itemType, index in itFunc.$retTypeInfoList {
         let mut workType = itemType;
         if index == 1 {
            if itemType.$nilable {
               workType = workType.$nonnilableType;
            }
         }
         itemTypeList.insert( workType );
      }
   }


   let mut nsInfo = self.$curNsInfo;
   let mut varSymList:List<&Ast.SymbolInfo> = [];
   foreach var, index in varList {
      let mut itemType = defaultItemType;
      if index <= #itemTypeList {
         itemType = itemTypeList[ index ];
      }
      varSymList.insert( nsInfo.registerSym(
         self.addLocalVar( var.pos, false, true, var.txt, itemType, .IMut## ) ) );
   }
   

   let block = self.analyzeBlock( .Apply, .Loop, scope, nil );
   self.popScope();

   return Nodes.ApplyNode.create(
      self.nodeManager, token.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      nsInfo.getNextStmtId( .Apply ), varSymList, expListNode, block );
}

fn TransUnit.convToExtTypeList(
   pos:&Tokenizer.Position,
   typeInfo:&Ast.TypeInfo, list:&List<&Ast.TypeInfo> ) mut : &List<&Ast.TypeInfo>
{
   if typeInfo.$nonnilableType.$kind ~= .Ext {
      return list;
   }
   let newList, mess = Ast.convToExtTypeList( self.processInfo, list );
   when! newList {
      return newList;
   }
   self.addErrMess( pos, mess );
   return list;
}


fn TransUnit.analyzeForeach( token: &Tokenizer.Token, sortFlag: bool ) mut : Nodes.Node {
   let mut scope = self.pushScope( .Other## );
   let mut mainSymToken:&Tokenizer.Token = Tokenizer.getEofToken();
   let mut subSymToken:&Tokenizer.Token! = nil;
   let mut mainSym:&Ast.SymbolInfo;
   let mut subSym:&Ast.SymbolInfo! = nil;
   let mut nextToken:&Tokenizer.Token = Tokenizer.getEofToken();
   for index = 1, 2 {
      let symbol = self.getToken(##);
      if symbol.kind ~= Tokenizer.TokenKind.Symb {
         self.error( "illegal symbol" ); // 要対応
      }
      if index == 1 {
         mainSymToken = symbol;
      }
      else {
         subSymToken = symbol;
      }
      nextToken = self.getToken(##);
      if nextToken.txt ~= "," {
         break;
      }
   }
   self.checkToken( nextToken, "in" );


   
   let exp = self.analyzeExpOneRVal( false, false## );
   if exp.$expType.$kind == .Ext {
      let nsInfo = self.$curNsInfo;
      if not self.macroCtrl.$analyzeInfo.isAnalyzingBlockArg() and
         not nsInfo.canAccessLuaval()
      {
         // __noasync 以外で Luaval にはアクセスできない。
         self.addErrMess(
            exp.$pos,
            "can't access the luaval without __luago. -- %s in %s"
            (exp.$expType.getTxt(##), nsInfo.$typeInfo.getTxt(##)) );
      }
   }

   fn checkSortType( sortKeyType:&Ast.TypeInfo ) {
      if sortFlag {
         switch sortKeyType.$srcTypeInfo.$extedType {
            case Ast.builtinTypeString,
                 Ast.builtinTypeInt,
                 Ast.builtinTypeReal,
                 // stem はソートできる保証はないが、
                 // ここでエラーにすると LiteralMapNode.setupLiteralTokenList に
                 // 影響があるので、 ここではエラーとしない。
                 Ast.builtinTypeStem
            {
            }
            default {
               self.addErrMess(
                  exp.$pos,
                  "This type can't use forsort -- %s" ( sortKeyType.getTxt(##) ) );
            }
         }
      }
   }
   

   let mut nsInfo = self.$curNsInfo;
  
   let expType = exp.$expType.$extedType;
   let itemTypeInfoList = self.convToExtTypeList(
      token.pos, exp.$expType, expType.$itemTypeInfoList );
   switch expType.$kind {
      case .Map {
         mainSym = nsInfo.registerSym( self.addLocalVar( 
            mainSymToken.pos, false, true,
            mainSymToken.txt, itemTypeInfoList[ 2 ], .IMut## ) );
         if! subSymToken {
            subSym = nsInfo.registerSym( self.addLocalVar(
               _exp.$pos, false, true, _exp.txt, itemTypeInfoList[ 1 ], .IMut## ) );
         }
         checkSortType( itemTypeInfoList[ 1 ] );
      }
      case .Set {
         when! subSymToken {
            self.addErrMess( subSymToken.pos, "Set can't use index" );
         }
         mainSym = nsInfo.registerSym( self.addLocalVar(
            mainSymToken.pos, false, true,
            mainSymToken.txt, itemTypeInfoList[ 1 ], .IMut## ) );
         checkSortType( itemTypeInfoList[ 1 ] );
      }
      case .List, .Array {
         if sortFlag {
            self.addErrMess( exp.$pos, "'%s' doesn't support forsort."
                             (expType.$kind.$_txt) );
         }
         mainSym = nsInfo.registerSym( self.addLocalVar(
            mainSymToken.pos, false, true,
            mainSymToken.txt, itemTypeInfoList[ 1 ], .IMut## ) );
         if! subSymToken {
            subSym = nsInfo.registerSym( self.addLocalVar(
               _exp.pos, false, false, _exp.txt, Ast.builtinTypeInt, .IMut## ) );
         }
      }
      default {
         self.errorAt(
            exp.$pos, "unknown kind type of exp for foreach -- %s" (expType.getTxt(##)) );
      }
   }

   let mut seqSym:str! = nil;
   if! let refNode = exp@@@Nodes.ExpRefNode {
      // foreach の sequential データを保持する変数は imut にする。
      let seqSymbol = refNode.$symbolInfo;
      if seqSymbol.$mutable or Ast.TypeInfo.isMut( seqSymbol.$typeInfo ) {
         scope.addOverrideImut( self.processInfo, seqSymbol );
         seqSym = seqSymbol.$name;
      }
   }
   
   let block = self.analyzeBlock( .Foreach, .Loop, scope, nil );

   when! seqSym {
      scope.remove( seqSym );
   }

   self.popScope();

   if sortFlag {
      return Nodes.ForsortNode.create(
         self.nodeManager, token.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         nsInfo.getNextStmtId( .Forsort ), mainSym, subSym, exp, block, sortFlag );
   }
   else {
      return Nodes.ForeachNode.create(
         self.nodeManager, token.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         nsInfo.getNextStmtId( .Foreach ), mainSym, subSym, exp, block );
   }
}

fn TransUnit.analyzeScope( firstToken: &Tokenizer.Token ) mut : Nodes.ScopeNode {

   let mut nextToken = self.getToken(##);
   let scopeKind:Nodes.ScopeKind;
   switch nextToken.txt {
      case "root" {
         scopeKind = .Root;
      }
      default {
         self.error( "illegal scope kind. -- %s" (nextToken.txt) ); // 要対応
      }
   }

   let mut symList:List<&Ast.SymbolInfo> = [];
   nextToken = self.getToken( ## );
   if nextToken.txt == "(" {
      nextToken = self.getToken( ## );
      while nextToken.txt ~= ")" {
         let symbolNode = self.analyzeExpSymbol(
            nextToken, nextToken, .Symbol, nil, true, false, false );
         let workSymList = symbolNode.getSymbolInfo();
         if #workSymList > 0 {
            //let symbol = workSymList[ 1 ];
            symList.insert( workSymList[ 1 ] );
         }
         nextToken = self.getToken( ## );
         switch nextToken.txt {
            case ")" {
            }
            case "," {
               nextToken = self.getToken( ## );
            }
            default {
               self.error( // 要対応
                  "illegal token: expects ')' or ',' but -- %s" (nextToken.txt) );
            }
         }
      }
   }
   else {
      self.pushback();
   }

   let asyncMode = self.getDefaultAsync( .Func, nil, nil );
   
   // スコープを切り替え
   let mut bakScope = self.$scope;
   //self.scope = self.topScope;
   self.setScope( self.topScope, .FromScope );
   let mut localScope = self.pushScope( .Other ## );

   // 名前空間に属させるためのダミーの関数を定義
   self.createDummyNS( localScope, nextToken.pos, asyncMode );

   // 継承するシンボル情報をスコープに設定設定
   foreach symInfo in symList {
      self.$scope.addAlias(
         self.processInfo, symInfo.$name, nextToken.pos, false, symInfo.$accessMode,
         symInfo.$typeInfo.$parentInfo, symInfo );
   }
   

   let mut block = self.analyzeBlock( .Block, TentativeMode.Simple ## );
   let mut node = Nodes.ScopeNode.create( 
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], scopeKind, self.$scope, symList, block );

   // スコープを戻す
   //self.scope = bakScope;
   self.setScope( bakScope, .FromScope );
   
   return node;
}

