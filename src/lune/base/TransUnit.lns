/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile use lune.base.TransUnitDecl;
subfile use lune.base.TransUnitExp;
subfile use lune.base.TransUnitStatementList;

luneControl disable_mut_control;

import lune.base.Parser;
import lune.base.Util;
import lune.base.Ast;
import lune.base.Writer;

pub class TransUnit {

   /** true の場合は mut 制御が有効 */
   pri let validMutControl: bool;

   /** モジュール名 */
   pri let moduleName: str;

   /** モジュールの最上位スコープ */
   pri let moduleScope: Ast.Scope;

   /** 解析中の scope */
   pri let scope: Ast.Scope;
   /** クラスの TypeId -> NamespaceInfo */
   pri let typeId2ClassMap: Map<int,Ast.NamespaceInfo>;

   /** クラスの型情報 -> そのクラスを宣言しているノード */
   pri let typeInfo2ClassNode: Map<Ast.TypeInfo,Ast.DeclClassNode>;
   /** パーサー */
   pri let parser: Parser.Parser;
   /** push バックしたトークンリスト */
   pri let pushbackList: Parser.Token![];
   /** 現在のトークン */
   pri let currentToken: Parser.Token!;
   /** 解析済みトークンリスト */
   pri let usedTokenList: Parser.Token![];
   /** 解析エラーメッセージ */
   pri let errMessList: str[] { pub };
   /** マクロを展開する際にマクロを評価する MacroEval のオブジェクト */
   pri let macroEval: Ast.MacroEval;
   /** マクロの TypeId -> マクロ情報 */
   pri let typeId2MacroInfo: Map<int,Ast.MacroInfo>;
   /** マクロのモード */
   pri let macroMode: str;
   /** macro-expand 内で利用できるシンボルと値の紐付けマップ */
   pri let symbol2ValueMapForMacro: Map<str,Ast.MacroValInfo>;
   /** macro-statement の最上位スコープ */
   pri let macroScope: Ast.Scope!;

   /** subfile 名のリスト */
   pri let subfileList: str[];

   /** 解析モード */
   pri let analyzeMode: str;
   /** 解析対象位置 */
   pri let analyzePos: Parser.Position;
   /** 解析対象モジュール */
   pri let analyzeModule: str;

   /** provide ノード */
   pri let provideNode: Ast.ProvideNode!;

   fn __init( macroEval: Ast.MacroEval,
              analyzeModule:str!, mode:str!, pos:Parser.Position! )
   {  
      self.macroScope = nil;
      self.validMutControl = true;
      self.moduleName = "";
      self.parser = new Parser.DummyParser();
      self.subfileList = [];
      self.pushbackList = [];
      self.usedTokenList = [];
      self.scope = Ast.rootScope;
      self.typeId2ClassMap = {};
      self.typeInfo2ClassNode = {};
      self.currentToken = nil;
      self.errMessList = [];
      self.macroEval = macroEval;
      self.typeId2MacroInfo = {};
      self.macroMode = "none";
      self.symbol2ValueMapForMacro = {};
      self.analyzeMode = unwrap mode default "";
      self.analyzePos = unwrap pos default new Parser.Position( 0, 0 );
      self.analyzeModule = unwrap analyzeModule default "";
      self.provideNode = nil;
   }

   pri fn addErrMess( pos: Parser.Position, mess: str ) {
      self.errMessList.insert(
         "%s:%d:%d: error: %s" ( self.parser.getStreamName(),
                                 pos.lineNo, pos.column, mess ) );
   }


   pri fn pushScope( classFlag: bool, inheritList: Ast.Scope[]! ): Ast.Scope {
      self.scope = new Ast.Scope( self.scope, classFlag,
                                  unwrap inheritList default []);
      return self.scope;
   }

   pri fn popScope() {
      self.scope = self.scope.get_parent();
   }

   pri fn getCurrentClass() : Ast.TypeInfo {
      let typeInfo = Ast.rootTypeInfo;
      let scope = self.scope;
      repeat {
         if! scope.$ownerTypeInfo {
            if _exp.$kind == Ast.TypeInfoKindClass or
               _exp.$kind == Ast.TypeInfoKindIF {          
               return _exp;
            }   
         }  
         scope = scope.$parent;
      } scope == Ast.rootScope;
      return typeInfo;
   }
   

   pri fn getCurrentNamespaceTypeInfo() : Ast.TypeInfo {
      let typeInfo = Ast.rootTypeInfo;
      let scope = self.scope;
      repeat {
         if! scope.$ownerTypeInfo {
            return _exp;
         }  
         scope = scope.$parent;
      } scope == Ast.rootScope;
      return typeInfo;
   }

   pri fn pushClass(
      classFlag:bool, abstructFlag: bool,
      baseInfo: Ast.TypeInfo!, interfaceList: Ast.TypeInfo[]!,
      externalFlag: bool, name:str,
      accessMode:str, defNamespace: Ast.NamespaceInfo! ): Ast.TypeInfo
   {
      let typeInfo = Ast.rootTypeInfo;
      if! self.scope.getTypeInfoChild( name ) {
         typeInfo = _exp;
         self.scope = unwrap typeInfo.$scope;
      } 
      else {
         let parentInfo = self.getCurrentNamespaceTypeInfo();
         let inheritList:Ast.Scope[] = [];
         if! baseInfo {
            inheritList = [ unwrap _exp.get_scope() ];
         }
         
         let scope = self.pushScope( true, inheritList );
         typeInfo = Ast.NormalTypeInfo.createClass(
            classFlag, abstructFlag, scope, baseInfo, interfaceList,
            parentInfo, externalFlag, accessMode, name );

         let parentScope = scope.get_parent();
         parentScope.addClass( name, typeInfo );
      } 
      let! namespace = defNamespace {
         namespace = new Ast.NamespaceInfo( name, self.scope, typeInfo );
      };
      self.typeId2ClassMap[ typeInfo.get_typeId() ] = namespace;
      //self.typeId2Scope[ typeInfo.get_typeId() ] = self.scope;
      return typeInfo;
   }

   pri fn popClass() {
      self.popScope();
   }

   pri fn pushbackStr( name: str, statement: str );
   pri fn analyzeDecl( accessMode: str, staticFlag:
                       bool, firstToken: Parser.Token,
                       token: Parser.Token ): Ast.Node!;
   pri fn analyzeDeclVar(
      mode:str, accessMode: str, firstToken: Parser.Token ): Ast.Node;
   pri fn analyzeDeclFunc(
      abstructFlag: bool, overrideFlag: bool, accessMode: str, staticFlag: bool,
      classNameToken: Parser.Token!,
      firstToken: Parser.Token, name: Parser.Token! ) : Ast.Node;
   pri fn analyzeDeclClass(
      abstructFlag:bool, classAccessMode: str,
      classToken: Parser.Token, mode:str ): Ast.Node;
   pri fn analyzeExp( skipOp2Flag: bool, opLevel: int! ): Ast.Node;
   pri fn analyzeStatement( termTxt: str! ): Ast.Node!;
   pri fn analyzeExpSymbol( firstToken: Parser.Token, token: Parser.Token,
                            mode: str, prefixExp: Ast.Node!, skipFlag: bool ): Ast.Node;
   pri fn analyzeExpList( skipOp2Flag: bool, expNode: Ast.Node! ): Ast.ExpListNode;


}


let opLevelBase = 0;
let op2levelMap:Map<str,int> = {};
let op1levelMap:Map<str,int> = {};
fn regOpLevel( opnum: int, opList: str[@] ) {
   opLevelBase = opLevelBase + 1;
   if opnum == 1 {
      foreach op in opList {
         op1levelMap[ op ] = opLevelBase;
      } 
   }
   else {
      foreach op in opList {
         op2levelMap[ op ] = opLevelBase;
      } 
   }
}
regOpLevel( 2, [@ "=" ] );
regOpLevel( 2, [@ "or" ] );
regOpLevel( 2, [@ "and" ] );
regOpLevel( 2, [@ "<", ">", "<=", ">=", "~=", "==" ] );
regOpLevel( 2, [@ "|" ] );
regOpLevel( 2, [@ "~" ] );
regOpLevel( 2, [@ "&" ] );
regOpLevel( 2, [@ "<<", ">>" ] );
regOpLevel( 2, [@ ".." ] );
regOpLevel( 2, [@ "+", "-" ] );
regOpLevel( 2, [@ "*", "/", "//", "%" ] );
regOpLevel( 1, [@ "`", ",,", ",,,", ",,,," ] );
regOpLevel( 1, [@ "not", "#", "-", "~" ] );
regOpLevel( 1, [@ "^" ] );


let quotedChar2Code:Map<int,int> = {};
quotedChar2Code[ 'a' ] = 7;    // \a
quotedChar2Code[ 'b' ] = 8;    // \b
quotedChar2Code[ 't' ] = 9;    // \t
quotedChar2Code[ 'n' ] = 10;   // \t
quotedChar2Code[ 'v' ] = 11;   // \v
quotedChar2Code[ 'f' ] = 12;   // \f
quotedChar2Code[ 'r' ] = 13;   // \r
quotedChar2Code[ '\\' ] = ?\\; // \\
quotedChar2Code[ '"' ] = ?\";  // "
quotedChar2Code[ "'" ] = ?\';  // '

class _TypeInfo {
   pub let abstructFlag: bool;
   pub let baseId: int;
   pub let ifList: int[];
   pub let itemTypeId: int[];
   pub let argTypeId: int[];
   pub let retTypeId: int[];
   pub let parentId: int;
   pub let typeId: int;
   pub let txt: str;
   pub let kind: int;
   pub let staticFlag: bool;
   pub let nilable: bool;
   pub let orgTypeId: int;
   pub let children: int[];
   pub let accessMode: str;
}


class _ModuleInfo {
   //pub let _className2InfoMap: Map<str,Map<str,stem>>;
   pub let _typeId2ClassInfoMap: Map<int,Map<str,stem>>;
   pub let _typeInfoList: _TypeInfo[];
   pub let _varName2InfoMap: Map<str,Map<str,stem>>;
   pub let _funcName2InfoMap: Map<str,stem>;
   pub let _moduleTypeId: int;
}

pub let typeInfoListInsert = Ast.typeInfoRoot;
pub let typeInfoListRemove = Ast.typeInfoRoot;


fn TransUnit.registBuiltInScope() {
   let builtInInfo = [
      { 
         "": {
            "type": { "arg": [ "stem!" ], "ret": ["str"] },
            "error": { "arg": [ "str" ], "ret": [] },
            "print": { "arg": [ "..." ], "ret": [] },
            "tonumber": { "arg": [ "str", "int!" ], "ret": ["real"] },
            "load": { "arg": [ "str" ], "ret": ["form!", "str"] },
            "require": { "arg": [ "str" ], "ret": ["stem!"] },
            "_fcall": { "arg": [ "form", "..." ], "ret": [""] },
         }, 
      },
      {
         "iStream": {
            "__attrib": { "type": [ "interface" ] },
            "read": { "type": [ "method" ], "arg": [ "stem!" ], "ret": [ "str!" ] },
            "close": { "type": [ "method" ], "arg": [], "ret": [] },
         },
      },
      {
         "oStream": {
            "__attrib": { "type": [ "interface" ] },
            "write": { "type": [ "method" ], "arg": [ "str" ], "ret": [ ] },
            "close": { "type": [ "method" ], "arg": [], "ret": [] },
         },
      },
      { 
         "luaStream": {
            "__attrib": { "inplements": [ "iStream", "oStream" ] },
            "read": { "type": [ "method" ], "arg": [ "stem!" ], "ret": [ "str!" ] },
            "write": { "type": [ "method" ], "arg": [ "str" ], "ret": [ ] },
            "close": { "type": [ "method" ], "arg": [], "ret": [] },
         }, 
      },
      { 
         "io": {
            "stdin": { "type": [ "member" ], "typeInfo": [ "iStream" ] },
            "stdout": { "type": [ "member" ], "typeInfo": [ "oStream" ] },
            "stderr": { "type": [ "member" ], "typeInfo": [ "oStream" ] },
            "open": { "arg": [ "str", "str!" ], "ret": ["luaStream!"] },
            "popen": { "arg": [ "str" ], "ret": ["luaStream!"] },
         },
      },
      { 
         
         "os": {
            "clock": { "arg": [], "ret": ["int"] },
            "exit": { "arg": [ "int!" ], "ret": [] },
         },
      },
      { 
         "string": {
            "find": { "arg": [ "str", "str", "int!", "bool!" ], "ret": ["int", "int"] },
            "byte": { "arg": [ "str", "int" ], "ret": ["int"] },
            "format": { "arg": [ "str", "..." ], "ret": ["str"] },
            "rep": { "arg": [ "str", "int" ], "ret": ["str"] },
            "gmatch": { "arg": [ "str", "str" ], "ret": ["stem!"] },
            "gsub": { "arg": [ "str", "str", "str" ], "ret": ["str"] },
            "sub": { "arg": [ "str", "int", "int!" ], "ret": ["str"] },
         },
      },
      { 
         "str": {
            "find": { "type": [ "method" ], "arg": [ "str", "int!", "bool!" ], "ret": ["int", "int"] },
            "byte": { "type": [ "method" ], "arg": [ "int" ], "ret": ["int"] },
            "format": { "type": [ "method" ], "arg": [ "..." ], "ret": ["str"] },
            "rep": { "type": [ "method" ], "arg": [ "int" ], "ret": ["str"] },
            "gmatch": { "type": [ "method" ], "arg": [ "str" ], "ret": ["stem!"] },
            "gsub": { "type": [ "method" ], "arg": [ "str", "str" ], "ret": ["str"] },
            "sub": { "type": [ "method" ], "arg": [ "int", "int!" ], "ret": ["str"] },
         },  
      },
      { 
         "table": {
            "unpack": { "arg": [ "stem" ], "ret": ["..."] },
         },  
      },
      { 
         "List": {
            "insert": { "type": [ "method" ], "arg": [ "stem" ], "ret": [""] },
            "remove": { "type": [ "method" ], "arg": [ "int!" ], "ret": [""] },
         },  
      },
      { 
         "debug": {
            "getinfo": { "arg": ["int"], "ret": ["stem"] },
         },  
      },
      { 
         "_luneScript": {
            "loadModule": { "arg": [ "str" ], "ret": ["stem", "stem"] },
            "searchModule": { "arg": [ "str" ], "ret": ["str!"] },
         }, 
      } 
   ]@@Map<str,Map<str,Map<str,str[]>>>[];


   fn getTypeInfo( typeName:str ) : Ast.TypeInfo {
      if typeName.find( "!$" ) {
         let orgTypeName = typeName.gsub( "!$", "" );
         let typeInfo = unwrap Ast.rootScope.getTypeInfo(
            orgTypeName, Ast.rootScope, false );
         return typeInfo.$nilableTypeInfo;
      } 
      return unwrap Ast.rootScope.getTypeInfo(
         typeName, Ast.rootScope, false );
   }

   let builtinModuleName2Scope:Map<str,Ast.Scope> = {};
   
   foreach builtinClassInfo in builtInInfo {
      foreach name2FieldInfo, name in builtinClassInfo {
         let parentInfo = Ast.typeInfoRoot;
         if name ~= "" {
            let classFlag = true;
            if name2FieldInfo$.__attrib$.type$[1] == "interface" {
               classFlag = false;
            }
            let interfaceList:Ast.TypeInfo[] = [];
            if! name2FieldInfo$.__attrib$.inplements {
               foreach ifname in _exp {
                  let ifType = getTypeInfo( ifname );
                  interfaceList.insert( ifType );
               }              
            }
            parentInfo = self.pushClass(
               classFlag, false, nil, interfaceList, true, name, "pub" );
            Ast.builtInTypeIdSet[ parentInfo.get_typeId() ] = parentInfo;
            Ast.builtInTypeIdSet[ parentInfo.$nilableTypeInfo.$typeId ] =
               parentInfo.$nilableTypeInfo;
         }   
         if not parentInfo {
            Util.err( "parentInfo is nil" );
         }  
         if not builtinModuleName2Scope[ name ]
         {  
            if name ~= "" and getTypeInfo( name ) {
               builtinModuleName2Scope[ name ] = self.scope;
            }

            forsort info, fieldName in name2FieldInfo {
               if fieldName ~= "__attrib" {

                  if info.type$[1] == "member" {
                     self.scope.addMember(
                        fieldName,
                        getTypeInfo( unwrap info.typeInfo$[1] ), "pub", true, false );
                  }
                  else {
                     let argTypeList: Ast.TypeInfo[] = [];
                     foreach argType in unwrap info[ "arg" ] {
                        argTypeList.insert( getTypeInfo( argType ) );
                     }  

                     let retTypeList: Ast.TypeInfo[] = [];
                     foreach retType in unwrap info[ "ret" ] {
                        let retTypeInfo = getTypeInfo( retType );
                        retTypeList.insert( retTypeInfo );
                     }    

                     
                     let methodFlag = info.type$[1] == "method";

                     self.pushScope( false );
                     
                     let typeInfo = Ast.NormalTypeInfo.createFunc(
                        false, true, self.scope,
                        methodFlag and Ast.TypeInfoKindMethod or Ast.TypeInfoKindFunc,
                        parentInfo, false, true, not methodFlag, "pub",
                        fieldName, argTypeList, retTypeList );

                     self.popScope();
                     
                     Ast.builtInTypeIdSet[ typeInfo.get_typeId() ] = typeInfo;
                     if typeInfo.$nilableTypeInfo ~= Ast.rootTypeInfo {
                        Ast.builtInTypeIdSet[ typeInfo.$nilableTypeInfo.$typeId ] = typeInfo.$nilableTypeInfo;
                     }
                     self.scope.add(
                        methodFlag and Ast.SymbolKind.Mtd or Ast.SymbolKind.Mbr,
                        not methodFlag, not methodFlag,
                        fieldName, typeInfo, "pub", not methodFlag, false );
                     if methodFlag {
                        switch ( name ) {
                           case "List" {
                              switch ( fieldName ) {
                                 case "insert" {      
                                    typeInfoListInsert = typeInfo;
                                 }        
                                 case "remove" {
                                    typeInfoListRemove = typeInfo;
                                 }        
                              }       
                           }       
                        }       
                     }
                  }
               }
            }   
         }  
         if name ~= "" {
            self.popClass();
         }  
      } 
   }
}


fn TransUnit.error( mess: str ) {
   let pos = new Parser.Position( 0, 0 );
   let txt = "";
   if! self.currentToken {
      pos = _exp.pos;
      txt = _exp.txt;
   }
   else {
      if #self.usedTokenList > 0 {
         if! self.usedTokenList[ #self.usedTokenList ] {
            pos = _exp.pos;
            txt = _exp.txt;
         }
      }
   }
   Util.err( "%s:%d:%d: error:(%s) %s"
             ( self.parser.getStreamName(),
               pos.lineNo, pos.column, txt, mess ) );
}

fn TransUnit.createNoneNode( pos: Parser.Position ): Ast.Node {
   //return self.createNode( nodeKindNone, pos, [ builtinTypeNone ], {} );
   return new Ast.NoneNode( pos, [ Ast.builtinTypeNone ] );
}

fn TransUnit.pushbackToken( token: Parser.Token! ) {
   self.pushbackList.insert( token );
   self.currentToken = self.usedTokenList[ #self.usedTokenList ];
}

fn expandVal( tokenList:Parser.Token[], val: stem!, pos: Parser.Position ): str {
   if! val {
      switch type( _exp ) {
         case "boolean" {
            let token = "%s" (_exp);
            let kind = Parser.kind.Kywd;
            tokenList.insert( new Parser.Token( kind, token, pos ) );
         }   
         case "number" {
            let num = "%g" (_exp);
            let kind = Parser.kind.Int;
            if string.find( num, ".", 1, true ) {
               kind = Parser.kind.Real;
            }   
            tokenList.insert( new Parser.Token( kind, num, pos ) );
         }   
         case "string" {
            tokenList.insert(
               new Parser.Token(
                  Parser.kind.Str, '[[%s]]' (_exp ), pos ) );
            // val 中に \n 等の制御コードが入ると正常に処理されない。
            // val 内の制御コードを \xXX に変換する必要がある。
         }   
         case "table" {
            tokenList.insert(
               new Parser.Token( Parser.kind.Dlmt, "{" (_exp), pos ) );
            foreach item, key in _exp@@stem![] {
               expandVal( tokenList, item, pos );
               tokenList.insert(
                  new Parser.Token( Parser.kind.Dlmt, "," (_exp), pos ) );
            }   
            tokenList.insert(
               new Parser.Token( Parser.kind.Dlmt, "}" (_exp), pos ) );
         }   
      } 
   }
}

fn TransUnit.newPushback( tokenList: Parser.Token[] ) {
   for index = #tokenList, 1, -1  {
      self.pushbackList.insert( tokenList[ index ] );
   }
   self.currentToken = self.usedTokenList[ #self.usedTokenList ];
}

fn TransUnit.getTokenNoErr(): Parser.Token! {
   if #self.pushbackList > 0 {
      self.usedTokenList.insert( self.currentToken );
      self.currentToken = self.pushbackList[ #self.pushbackList ];
      self.pushbackList.remove();
      return self.currentToken;
   }

   let commentList:Parser.Token[] = [];
   let token:Parser.Token! = nil;
   while true {
      token = self.parser.getToken();
      if! token {
         if _exp.kind ~= Parser.kind.Cmnt {
            break;
         }   
         commentList.insert( _exp );
      } 
      else {
         break;
      } 
   }

   if! token {
      if self.macroMode == "expand" {
         let tokenTxt = _exp.txt;
         if tokenTxt == ',,' or tokenTxt == ',,,,' {
            let nextToken = unwrap self.getTokenNoErr();

            let! macroVal = self.symbol2ValueMapForMacro[ nextToken.txt ] {
               self.error( "unknown macro val %s" (nextToken.txt) );
            };
            
            if tokenTxt == ',,' {
               //Util.errorLog( "nextToken: %s" ( nextToken.txt ) );
               if macroVal.typeInfo == Ast.builtinTypeSymbol {
                  let txtList = (unwrap macroVal.val)@@str[];
                  for index = #txtList, 1, -1 {
                     nextToken = new Parser.Token(
                        nextToken.kind, txtList[ index ], nextToken.pos );
                     self.pushbackToken( nextToken );
                  }    
               }   
               elseif macroVal.typeInfo == Ast.builtinTypeStat {
                  self.pushbackStr( "macroVal %s" (nextToken.txt),
                                    (unwrap macroVal.val)@@str );                       
               }   
               elseif macroVal.typeInfo.get_kind() == Ast.TypeInfoKindArray or
                  macroVal.typeInfo.get_kind() == Ast.TypeInfoKindList
               {   
                  let strList = (unwrap macroVal.val)@@str[];
                  if strList {
                     for index = #strList, 1, -1 {
                        self.pushbackStr(
                           "macroVal %s[%d]" (nextToken.txt, index),
                           strList[ index ] );
                     }     
                  }    
                  else {
                     self.error( "macro val is nil %s" (nextToken.txt) );
                  }    
               }
               else {
                  let tokenList: Parser.Token[] = [];
                  expandVal( tokenList, macroVal.val, nextToken.pos );
                  
                  self.newPushback( tokenList );
               } 
            } 
            elseif tokenTxt == ',,,,' {
               if macroVal.typeInfo == Ast.builtinTypeSymbol {
                  let txtList = (unwrap macroVal.val)@@str[];
                  let newToken = "";
                  foreach txt in txtList {
                     newToken = "%s%s" (newToken, txt);
                  } 
                  nextToken = new Parser.Token(
                     Parser.kind.Str, "'%s'" (newToken), nextToken.pos );
                  self.pushbackToken( nextToken );
               } 
               elseif macroVal.typeInfo == Ast.builtinTypeStat {
                  nextToken = new Parser.Token(
                     Parser.kind.Str, "'%s'" (unwrap macroVal.val), nextToken.pos );
                  self.pushbackToken( nextToken );
               } 
               else {
                  self.error( "not support this symbol -- %s%s"
                              (tokenTxt, nextToken.txt) );
               } 
            } 
            nextToken = unwrap self.getTokenNoErr();

            token = nextToken;
         } 
      } 
   }
   if! token {
      _exp.set_commentList( commentList );
   }

   self.usedTokenList.insert( self.currentToken );
   self.currentToken = token;

   return token;
}



fn TransUnit.getToken(): Parser.Token {
   let! token = self.getTokenNoErr() {
      return Parser.getEofToken();
   };

   // if self.macroMode == "expand"  {
   //     Util.errorLog( "getToken %s" (token.txt) );
   // }
   
   self.currentToken = token;
   return token;
}

fn TransUnit.pushback() {
   self.pushbackList.insert( self.currentToken );
   self.currentToken = self.usedTokenList[ #self.usedTokenList ];
   self.usedTokenList.remove();
}

fn TransUnit.pushbackStr( name: str, statement: str ) {
   let memStream = new Parser.TxtStream( statement );
   let parser = new Parser.StreamParser( memStream, name, false );

   let list:Parser.Token![] = [];
   while true {
      let token = parser.getToken();
      if not token {
         break;
      } 
      list.insert( token ); 
   }
   for index = #list, 1, -1  {
      self.pushbackToken( list[ index ] );
   }
}

fn TransUnit.checkSymbol( token: Parser.Token ): Parser.Token {
   if token.kind ~= Parser.kind.Symb and
      token.kind ~= Parser.kind.Kywd and
      token.kind ~= Parser.kind.Type
   {
      self.error( "illegal symbol" );
   }
   return token;
}

fn TransUnit.getSymbolToken(): Parser.Token {
   return self.checkSymbol( self.getToken() );
}


fn TransUnit.checkToken( token: Parser.Token, txt: str ): Parser.Token {
   if not token or token.txt ~= txt {
      self.error( string.format( "not found -- %s", txt ) );
   }
   return token;
}

fn TransUnit.checkNextToken( txt: str ): Parser.Token {
   return self.checkToken( self.getToken(), txt );
}

/**
次のトークンが、スペースの空きがなく、連続したトークンであるか確認する。

@return 1 次のトークン
@return 2 連続したトークンだった場合 true
*/
fn TransUnit.getContinueToken(): Parser.Token, bool {
   let! prevToken = self.currentToken {
      return self.getToken(), false;
   };
   let token = self.getToken();

   if prevToken.pos.lineNo ~= token.pos.lineNo or
      prevToken.pos.column + #prevToken.txt ~= token.pos.column
   {
      return token, false;
   }

   return token, true;
}


fn TransUnit.analyzeStatementList( stmtList: Ast.Node[], termTxt: str! ) : Ast.Node! {
   let lastStatement:Ast.Node! = nil;
   while true {
      let statement = self.analyzeStatement( termTxt );
      if! statement {
         stmtList.insert( _exp );
         lastStatement = statement;
      } 
      else {
         break;
      } 
   }
   return lastStatement;
}

fn TransUnit.analyzeStatementListSubfile( stmtList: Ast.Node[] ) : Ast.Node! {
   let statement = self.analyzeStatement();

   if! statement {
      if _exp.$kind ~= Ast.nodeKindSubfile {
         self.error( "subfile must have 'subfile' declaration at top." );
      } 
   }
   else {
      self.error( "subfile must have 'subfile' declaration at top." );
   }

   return self.analyzeStatementList( stmtList );
}

fn TransUnit.analyzeLuneControl( firstToken: Parser.Token ) {
   let nextToken = self.getToken();
   switch ( nextToken.txt ) {
      case "disable_mut_control" {
         self.validMutControl = false;
      } 
      default {
         self.addErrMess(
            nextToken.pos, "unknown option -- %s" (nextToken.txt) );
      } 
   }
   self.checkNextToken( ";" );
}

fn TransUnit.analyzeBlock( blockKind: str, scope: Ast.Scope! ): Ast.BlockNode {
   let token = self.checkNextToken( "{" );

   if not scope {
      self.pushScope( false );
   }

   let stmtList:Ast.Node[] = [];
   self.analyzeStatementList( stmtList, "}" );

   self.checkNextToken( "}" );

   if not scope {
      self.popScope();
   }

   // let node = self.createNode( nodeKindBlock, token.pos, [ builtinTypeNone ],
   //                          { "kind": blockKind, "stmtList": stmtList } );
   let node = new Ast.BlockNode(
      token.pos, [ Ast.builtinTypeNone ], blockKind, stmtList );

   return node;
}

fn TransUnit.analyzeImport( token: Parser.Token ): Ast.Node {
   if self.moduleScope ~= self.scope {
      self.error( "'import' must call at top scope." );
   }

   // スコープをルートに変更
   self.scope = Ast.rootScope;

   let moduleToken = self.getToken();
   let modulePath = moduleToken.txt;
   let nextToken:Parser.Token = moduleToken;

   let nameList = [ moduleToken.txt ];

   while true {
      nextToken = self.getToken();
      if nextToken.txt == "." {
         nextToken = self.getToken();
         moduleToken = nextToken;
         modulePath = "%s.%s" ( modulePath, moduleToken.txt );
         nameList.insert( moduleToken.txt );
      } 
      else {
         break;
      } 
   }


   // 型情報の登録
   let typeId2TypeInfo: Map<int,Ast.TypeInfo> = {};
   typeId2TypeInfo[ Ast.rootTypeId ] = Ast.typeInfoRoot;

   foreach moduleName in nameList {
      self.pushClass( true, false, nil, nil, true, moduleName, "pub" );
   }
   foreach moduleName in nameList {
      self.popClass();
   }


   let _obj, _obj2 = _luneScript.loadModule( modulePath );
   let moduleInfo = _obj2@@_ModuleInfo;
   //self.moduleName2Info[ modulePath ] = moduleInfo;

   foreach symbolInfo in Ast.sym2builtInTypeMap {
      typeId2TypeInfo[ symbolInfo.$typeInfo.get_typeId() ] = symbolInfo.$typeInfo;
   }
   foreach builtinTypeInfo in Ast.builtInTypeIdSet {
      typeId2TypeInfo[ builtinTypeInfo.$typeId ] = builtinTypeInfo;
   }

   let typeId2Scope: Map<int,Ast.Scope> = {};
   typeId2Scope[ Ast.rootTypeId ] = self.scope;

   let newId2OldIdMap: Map<int,int> = {};

   fn registTypeInfo( atomInfo: _TypeInfo ): Ast.TypeInfo {
      let newTypeInfo: Ast.TypeInfo! = nil;
      if atomInfo.parentId ~= Ast.rootTypeId or
         not Ast.builtInTypeIdSet[ atomInfo.typeId ] or
         atomInfo.kind == Ast.TypeInfoKindList or
         atomInfo.kind == Ast.TypeInfoKindArray or
         atomInfo.kind == Ast.TypeInfoKindMap 
      {
         if atomInfo.nilable {
            let orgTypeInfo = unwrap typeId2TypeInfo[ atomInfo.orgTypeId ];
            newTypeInfo = orgTypeInfo.get_nilableTypeInfo();
            typeId2TypeInfo[ atomInfo.typeId ] = unwrap newTypeInfo;
         }  
         else {
            let parentInfo = Ast.typeInfoRoot;
            if atomInfo.parentId ~= Ast.rootTypeId {
               let! workTypeInfo = typeId2TypeInfo[ atomInfo.parentId ] {
                  Util.err( "not found parentInfo %s %s"
                              ( atomInfo.parentId, atomInfo.txt ) );
               };   
               parentInfo = workTypeInfo;
            }   
            
            let itemTypeInfo:Ast.TypeInfo[] = [];
            foreach typeId in atomInfo.itemTypeId {
               itemTypeInfo.insert( unwrap typeId2TypeInfo[ typeId ] );
            }   
            let argTypeInfo:Ast.TypeInfo[] = [];
            foreach typeId in atomInfo.argTypeId {
               if not typeId2TypeInfo[ typeId ] {
                  Util.log( "not found -- %s.%s, %d, %d"
                                 ( parentInfo.getTxt(), atomInfo.txt,
                                   typeId, #atomInfo.argTypeId ) );  
               }    
               argTypeInfo.insert( unwrap typeId2TypeInfo[ typeId ] );
            }   
            let retTypeInfo:Ast.TypeInfo[] = [];
            foreach typeId in atomInfo.retTypeId {
               retTypeInfo.insert( unwrap typeId2TypeInfo[ typeId ] );
            }   
            
            let baseInfo = unwrap typeId2TypeInfo[ atomInfo.baseId ];
            let interfaceList:Ast.TypeInfo[] = [];
            foreach ifTypeId in atomInfo.ifList {
               interfaceList.insert( unwrap typeId2TypeInfo[ ifTypeId ] );
            }

            let! parentScope = typeId2Scope[ atomInfo.parentId ] {
               self.error( "not found parentScope %s %s"
                           ( atomInfo.parentId, atomInfo.txt ) );
            };  

            if atomInfo.txt ~= "" {
               newTypeInfo = parentScope.getTypeInfoChild( atomInfo.txt );
            }   
            if newTypeInfo and ( atomInfo.kind == Ast.TypeInfoKindClass or
                                 atomInfo.kind == Ast.TypeInfoKindIF )
            {                                
               sync! newTypeInfo = newTypeInfo {
               }    
               then {
                  typeId2Scope[ atomInfo.typeId ] = newTypeInfo.$scope;
                  if not newTypeInfo.$scope {
                     Util.err( "not found scope %s %s %s %s %s"
                                 ( parentScope, atomInfo.parentId,
                                   atomInfo.typeId,
                                   atomInfo.txt, newTypeInfo.getTxt() ) );
                  }     
                  typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;
               };   
            }
            else {
               if atomInfo.kind == Ast.TypeInfoKindClass or
                  atomInfo.kind == Ast.TypeInfoKindIF
               {             
                  let baseScope = unwrap typeId2Scope[ atomInfo.baseId ];

                  let scope = new Ast.Scope(
                     parentScope, true, baseScope and [ baseScope ] or [] );

                  let workTypeInfo = Ast.NormalTypeInfo.createClass(
                     atomInfo.kind == Ast.TypeInfoKindClass, atomInfo.abstructFlag,
                     scope, baseInfo, interfaceList,
                     parentInfo, true, "pub", atomInfo.txt );
                  newTypeInfo = workTypeInfo;
                  typeId2Scope[ atomInfo.typeId ] = scope;


                  typeId2TypeInfo[ atomInfo.typeId ] = workTypeInfo;

                  parentScope.addClass( atomInfo.txt, workTypeInfo );
               }    
               else {
                  let scope:Ast.Scope! = nil;

                  if atomInfo.kind == Ast.TypeInfoKindFunc or
                     atomInfo.kind == Ast.TypeInfoKindMethod
                  {     
                     scope = new Ast.Scope( parentScope, false, [] );
                  }     

                  
                  let workTypeInfo = Ast.NormalTypeInfo.create(
                     atomInfo.abstructFlag, scope, baseInfo, interfaceList, parentInfo,
                     atomInfo.staticFlag, atomInfo.kind,              
                     atomInfo.txt, itemTypeInfo, argTypeInfo, retTypeInfo );
                  newTypeInfo = workTypeInfo;

                  typeId2TypeInfo[ atomInfo.typeId ] = workTypeInfo;

                  if atomInfo.kind == Ast.TypeInfoKindFunc or
                     atomInfo.kind == Ast.TypeInfoKindMethod
                  {
                     let symbolKind = Ast.SymbolKind.Fun;
                     if atomInfo.kind == Ast.TypeInfoKindMethod {
                        symbolKind = Ast.SymbolKind.Mtd;
                     }
                     (unwrap typeId2Scope[ atomInfo.parentId ]).add(
                        symbolKind, false, atomInfo.kind == Ast.TypeInfoKindFunc,
                        atomInfo.txt, workTypeInfo, atomInfo.accessMode,
                        atomInfo.staticFlag, false );
                     typeId2Scope[ atomInfo.typeId ] = scope;
                  }     
               }    
            }   
         }  
      } 
      else {
         newTypeInfo = Ast.rootScope.getTypeInfo(
            atomInfo.txt, Ast.rootScope, false );
         typeId2TypeInfo[ atomInfo.typeId ] = unwrap newTypeInfo;
      } 
      return unwrap newTypeInfo;
   }

   // 初めに child 以外で TypeInfo を登録
   foreach atomInfo in moduleInfo._typeInfoList {
      registTypeInfo( atomInfo );
   }

   // 次に child を登録
   foreach atomInfo in moduleInfo._typeInfoList {
      if atomInfo.children and #atomInfo.children > 0 {
         let scope = unwrap typeId2Scope[ atomInfo.typeId ];
         foreach childId in atomInfo.children {
            let typeInfo = unwrap typeId2TypeInfo[ childId ];
            // scope.addClass(
            //    typeInfo.getTxt(), typeInfo, typeInfo.$accessMode,
            //    typeInfo.$staticFlag, typeInfo.$mutable );
            let symbolKind = Ast.SymbolKind.Typ;
            switch typeInfo.$kind {
               case Ast.TypeInfoKindFunc {
                  symbolKind = Ast.SymbolKind.Fun;
               }
               case Ast.TypeInfoKindMethod {
                  symbolKind = Ast.SymbolKind.Mtd;
               }
               case Ast.TypeInfoKindClass {
                  symbolKind = Ast.SymbolKind.Typ;
               }
            }
            scope.add( symbolKind, false, typeInfo.$kind == Ast.TypeInfoKindFunc,
                       typeInfo.getTxt(), typeInfo, typeInfo.$accessMode,
                       typeInfo.$staticFlag, typeInfo.$mutable );
         }
      }
   }

   // インポート後の TypeId と インポート前の TypeId の紐付け
   foreach typeInfo, typeId in typeId2TypeInfo {
      newId2OldIdMap[ typeInfo.get_typeId() ] = typeId;
   }

   // メンバーの登録
   fn registMember( classTypeId: int ) {
      let classTypeInfo = unwrap typeId2TypeInfo[ classTypeId ];
      self.pushClass( true, classTypeInfo.$abstructFlag,
                      nil, nil, true, classTypeInfo.getTxt(), "pub" );
      if! moduleInfo._typeId2ClassInfoMap[ classTypeId ] {
         let classInfo = _exp;
         foreach fieldInfo, fieldName in classInfo@@Map<str,Map<str,stem>> {
            let typeId = fieldInfo.typeId;
            let fieldTypeInfo = unwrap typeId2TypeInfo[ typeId ];
            self.scope.addMember(
               fieldName, fieldTypeInfo,
               (unwrap fieldInfo.accessMode)@@str,
               (unwrap fieldInfo.staticFlag default false)@@bool,
               (unwrap fieldInfo.mutable default false)@@bool );
         }   
         foreach child in classTypeInfo.get_children() {
            if child.get_kind() == Ast.TypeInfoKindClass or
               child.get_kind() == Ast.TypeInfoKindIF
            {           
               let oldId = newId2OldIdMap[ child.get_typeId() ];
               if oldId {
                  registMember( unwrap oldId );
               }    
            }   
         }  
      }
      else {
         self.error( "not found class -- %d, %s"
                     (classTypeId, classTypeInfo.getTxt()) );
      } 
      self.popClass();
   }
   foreach atomInfo in moduleInfo._typeInfoList {
      if atomInfo.parentId == Ast.rootTypeId and
         ( atomInfo.kind == Ast.TypeInfoKindClass or
           atomInfo.kind == Ast.TypeInfoKindIF )
      {       
         registMember( atomInfo.typeId );
      } 
   }
   

   foreach moduleName in nameList {
      self.pushClass( true, false, nil, nil, true, moduleName, "pub" );
   }


   // 変数登録
   foreach varInfo, varName in moduleInfo._varName2InfoMap {
      self.scope.addLocalVar(
         false, true, varName, unwrap typeId2TypeInfo[ varInfo.typeId ],
         (unwrap varInfo.mutable default false)@@bool );
   }

   foreach moduleName in nameList {
      self.popClass();
   }

   //dumpScope( self.rootScope, "" );


   // スコープを元に戻す
   self.scope = self.moduleScope;

   self.scope.add( Ast.SymbolKind.Var, false, false, moduleToken.txt,
                   unwrap typeId2TypeInfo[ moduleInfo._moduleTypeId ],
                   "local", true, false );

   self.checkToken( nextToken, ";" );


   if self.moduleScope ~= self.scope {
      self.error( "illegal top scope." );
   }

   
   return new Ast.ImportNode( token.pos, [ Ast.builtinTypeNone ], modulePath );
}


fn TransUnit.analyzeSubfile( token: Parser.Token ): Ast.SubfileNode {
   if self.scope ~= self.moduleScope {
      self.error( "'module' must be top scope." );
   }
   

   let mode = self.getToken();

   let moduleName = "";
   while true {
      let nextToken = self.getToken();
      if nextToken.txt == ";" {
         break;
      }   
      if moduleName == "" {
         moduleName = nextToken.txt;
      }   
      else {
         moduleName = "%s%s" (moduleName, nextToken.txt);
      } 
   }
   if moduleName == "" {
      self.addErrMess( token.pos, "illegal subfile" );
   }
   else {
      if mode.txt == "use" {
         if _luneScript.searchModule( moduleName ) {
            self.subfileList.insert( moduleName );
         }   
         else {
            self.addErrMess(
               token.pos, "not found subfile -- %s" ( moduleName ) );
         }   
      } 
      elseif mode.txt == "owner" {
         if self.moduleName ~= moduleName {
            self.addErrMess(
               token.pos,
               "illegal owner module -- %s, %s"
               ( moduleName, self.moduleName ) );
         }  
      } 
      else {
         self.addErrMess( mode.pos, "illegal module mode -- %s" ( mode.txt ) );
      } 
   }
   return new Ast.SubfileNode( token.pos, [ Ast.builtinTypeNone ] );
}

fn TransUnit.analyzeIfUnwrap( firstToken: Parser.Token ): Ast.Node {
   let exp = self.analyzeExp( false );

   if self.scope.getSymbolTypeInfo( "_exp", self.scope, self.moduleScope ) {
      self.addErrMess( firstToken.pos, "shadowing _exp" );
   }

   let scope = self.pushScope( false );

   let expType = exp.$expType;
   if not expType.$nilable {
      self.addErrMess( exp.$pos, "this is not nilable" );
      scope.addLocalVar( false, true, "_exp", expType, false );
   }
   else {
      scope.addLocalVar( false, true, "_exp", expType.$orgTypeInfo, false );
   }
   
   let block = self.analyzeBlock( "if!", scope );

   self.popScope();

   let elseBlock:Ast.BlockNode! = nil;
   let nextToken = self.getToken();
   if nextToken.txt == "else" {
      elseBlock = self.analyzeBlock( "if!" );
   }
   else {
      self.pushback();
   }

   return new Ast.IfUnwrapNode(
      firstToken.pos, [ Ast.builtinTypeNone ], exp, block, elseBlock );
}


fn TransUnit.analyzeIf( token: Parser.Token ): Ast.Node {
   let nextToken, continueFlag = self.getContinueToken();
   if continueFlag and nextToken.txt == "!" {
      return self.analyzeIfUnwrap( token );
   }
   self.pushback();
   
   let list:Ast.IfStmtInfo[] = [];
   list.insert( new Ast.IfStmtInfo( "if", self.analyzeExp( false ),
                                    self.analyzeBlock( "if" ) ) );

   nextToken = self.getToken();
   if nextToken.txt == "elseif" {
      while nextToken.txt == "elseif" {
         list.insert( new Ast.IfStmtInfo( "elseif", self.analyzeExp( false ),
                                          self.analyzeBlock( "elseif" ) ));
         nextToken = self.getToken();
      } 
   }

   if nextToken.txt == "else" {
      list.insert(
         new Ast.IfStmtInfo( "else", new Ast.NoneNode( nextToken.pos,
                                                       [ Ast.builtinTypeNone ] ),
                             self.analyzeBlock( "else" ) ));
   }
   else {
      self.pushback();
   }

   return new Ast.IfNode( token.pos, [ Ast.builtinTypeNone ], list );
}


fn TransUnit.analyzeSwitch( firstToken: Parser.Token ): Ast.SwitchNode {
   let exp = self.analyzeExp( false );

   self.checkNextToken( "{" );

   let caseList: Ast.CaseInfo[] = [];

   let nextToken = self.getToken();
   while ( nextToken.txt == "case" ) {
      self.checkToken( nextToken, "case" );
      let condexpList = self.analyzeExpList( false );
      let condBock = self.analyzeBlock( "switch" );
      caseList.insert( new Ast.CaseInfo( condexpList, condBock ) );
      nextToken = self.getToken();
   }

   let defaultBlock: Ast.BlockNode! = nil;
   if nextToken.txt == "default" {
      defaultBlock = self.analyzeBlock( "default" );
   }
   else {
      self.pushback();
   }
   self.checkNextToken( "}" );

   return new Ast.SwitchNode( firstToken.pos, [ Ast.builtinTypeNone ],
                              exp, caseList, defaultBlock );
}


fn TransUnit.analyzeWhile( token: Parser.Token ): Ast.WhileNode {
   return new Ast.WhileNode( token.pos, [ Ast.builtinTypeNone ],
                             self.analyzeExp( false ), self.analyzeBlock( "while" ) );
}

fn TransUnit.analyzeRepeat( token: Parser.Token ): Ast.RepeatNode {
   let scope = self.pushScope( false );
   let node = new Ast.RepeatNode( token.pos, [ Ast.builtinTypeNone ],
                                  self.analyzeBlock( "repeat", scope ),
                                  self.analyzeExp( false ) );
   self.popScope();
   
   self.checkNextToken( ";" );
   return node;
}

fn TransUnit.analyzeFor( firstToken: Parser.Token ): Ast.ForNode {

   let scope = self.pushScope( false );

   let val = self.getToken();
   if val.kind ~= Parser.kind.Symb {
      self.error( "not symbol" );
   }
   self.checkNextToken( "=" );
   let exp1 = self.analyzeExp( false );
   if exp1.$expType ~= Ast.builtinTypeInt {
      self.addErrMess( exp1.$pos,
                       "exp1 is not int -- %s" (exp1.$expType.getTxt()) );
   }
   self.scope.addLocalVar( false, true, val.txt, exp1.$expType, false );
   self.checkNextToken( "," );
   let exp2 = self.analyzeExp( false );
   if exp2.$expType ~= Ast.builtinTypeInt {
      self.addErrMess( exp2.$pos,
                       "exp2 is not int -- %s" (exp2.$expType.getTxt()) );
   }
   let token = self.getToken();
   let exp3:Ast.Node! = nil;
   if token.txt == "," {
      exp3 = self.analyzeExp( false );
      if! exp3 {
         if _exp.$expType ~= Ast.builtinTypeInt {
            self.addErrMess( _exp.$pos,
                             "exp is not int -- %s" (_exp.$expType.getTxt()) );
         }  
      } 
      
   }
   else {
      self.pushback();
   }

   let node = new Ast.ForNode(
      firstToken.pos, [ Ast.builtinTypeNone ],
      self.analyzeBlock( "for", scope ), val, exp1, exp2, exp3 );
   self.popScope();
   
   return node;
}

fn TransUnit.analyzeApply( token: Parser.Token ): Ast.ApplyNode {
   let scope = self.pushScope( false );
   let varList:Parser.Token[] = [];
   let nextToken:Parser.Token = Parser.getEofToken();
   repeat {
      let var = self.getSymbolToken();
      if var.kind ~= Parser.kind.Symb {
         self.error( "illegal symbol" );
      } 
      varList.insert( var );
      nextToken = self.getToken();
      scope.addLocalVar( false, true, var.txt, Ast.builtinTypeStem, false );
   } nextToken.txt ~= ",";
   self.checkToken( nextToken, "of" );

   let exp = self.analyzeExp( false );
   if exp.$kind ~= Ast.nodeKindExpCall {
      self.error( "not call" );
   }

   let block = self.analyzeBlock( "apply", scope );
   self.popScope();

   return new Ast.ApplyNode( token.pos, [ Ast.builtinTypeNone ], varList, exp, block );
}

fn TransUnit.analyzeForeach( token: Parser.Token, sortFlag: bool ): Ast.Node {
   let scope = self.pushScope( false );
   let valSymbol:Parser.Token = Parser.getEofToken();
   let keySymbol:Parser.Token! = nil;
   let nextToken:Parser.Token = Parser.getEofToken();
   for index = 1, 2 {
      let sym = self.getToken();
      if sym.kind ~= Parser.kind.Symb {
         self.error( "illegal symbol" );
      } 
      if index == 1 {
         valSymbol = sym;
      } 
      else {
         keySymbol = sym;
      } 
      nextToken = self.getToken();
      if nextToken.txt ~= "," {
         break;
      } 
   }
   self.checkToken( nextToken, "in" );

   let exp = self.analyzeExp( false );
   if not exp.$expType {
      self.error( "unknown type of exp -- %d:%d" (token.pos.lineNo, token.pos.column) );
   }
   else {
      let itemTypeInfoList = exp.$expType.get_itemTypeInfoList();
      if exp.$expType.get_kind() == Ast.TypeInfoKindMap {
         self.scope.addLocalVar(
            false, true, valSymbol.txt, itemTypeInfoList[ 2 ], false );
         if! keySymbol {
            self.scope.addLocalVar(
               false, true, _exp.txt, itemTypeInfoList[ 1 ], false );
         }  
      } 
      elseif exp.$expType.get_kind() == Ast.TypeInfoKindList or
         exp.$expType.get_kind() == Ast.TypeInfoKindArray
      { 
         self.scope.addLocalVar(
            false, true, valSymbol.txt, itemTypeInfoList[ 1 ], false );
         if! keySymbol {
            self.scope.addLocalVar( false, false, _exp.txt, Ast.builtinTypeInt, false );
         }
         else {
            self.scope.addLocalVar( false, false, "__index", Ast.builtinTypeInt, false );
         }
      }
      else {
         self.error( "unknown kind type of exp for foreach-- %d:%d"
            (exp.$pos.lineNo, exp.$pos.column) );
      }
   }

   let block = self.analyzeBlock( "foreach", scope );

   self.popScope();

   if sortFlag {
      return new Ast.ForsortNode( token.pos, [ Ast.builtinTypeNone ],
                                  valSymbol, keySymbol, exp, block, sortFlag );
   }
   else {
      return new Ast.ForeachNode( token.pos, [ Ast.builtinTypeNone ],
                                  valSymbol, keySymbol, exp, block );
   }
}

fn TransUnit.analyzeProvide( firstToken: Parser.Token ): Ast.Node {
   let val = self.analyzeExp( true );
   self.checkNextToken( ";" );

   switch val.$kind {
      case Ast.nodeKindExpRef {
         let expRefNode = val@@Ast.ExpRefNode;
      }
   }
   
   let node = new Ast.ProvideNode( firstToken.pos, [ Ast.builtinTypeNone ], val );
   if self.provideNode {
      self.addErrMess( firstToken.pos, "multiple provide" );
   }
   self.provideNode = node;


   if node.$val.$kind == Ast.nodeKindExpRef {
      let expRefNode = node.$val@@Ast.ExpRefNode;

      forsort symbolInfo, symbol in self.moduleScope.$symbol2TypeInfoMap {
         if expRefNode.$symbolInfo == symbolInfo {
            if symbolInfo.$accessMode ~= "pub" {
               self.addErrMess( firstToken.pos,
                                "provide variable must be 'pub'.  -- %s"
                                (symbolInfo.$accessMode));
            }
         }
         elseif symbolInfo.$accessMode == "pub" {
            self.addErrMess(
               firstToken.pos,   
               "variable (%s) can't set 'pub'." ( symbolInfo.$name ) );
         }  
      }  
   }
      
   return node;
}
