/*
MIT License

Copyright (c) 2018, 2019 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile use lune.base.TransUnitDecl;
subfile use lune.base.TransUnitExp;
subfile use lune.base.TransUnitStatementList;

import lune.base.Meta;
import lune.base.Parser;
import lune.base.Util;
import lune.base.Ast;
import lune.base.Nodes;
import lune.base.Writer;
import lune.base.frontInterface;
import lune.base.LuaVer;
import lune.base.Option;
import lune.base.Code;
import lune.base.Log;
import lune.base.LuneControl;
import lune.base.Macro;

_lune_control ignore_symbol_;


enum DeclClassMode {
   Class,
   Interface,
   Module
}

enum DeclFuncMode {
   Func,
   Class,
   Module,
   Glue,
}

enum ExpSymbolMode {
   Symbol,
   Fn,
   Field,
   FieldNil,
   Get,
   GetNil,
}

pub enum AnalyzeMode {
   Compile,
   Diag,
   Complete,
}

class AccessSymPos {
   pri let symbol:&Ast.SymbolInfo {pub};
   pri let pos:&Parser.Position {pub};
}

/**
初期値を持たない変数について、次処理を行なう。

- 変数の型を確定させる
- 変数の初期値未確定パス検知

ブロック毎にこのインスタンスを生成し、ブロック終了時にシンボルの型を確定する。
*/
class TentativeSymbol {
   /** ブロックで値をセットしたシンボルの集合。 */
   pri let mut symbolSet:Set<&Ast.SymbolInfo>;
   /**
以前のブロックで値をセットしたシンボルの集合。
 
例えば、 if {} else {} などの条件分岐するブロックで、
if のブロックを解析中の情報は symbolSet で管理し、
if のブロックを解析終了時に symbolSet を oldSymbolSet にセットする。
そして else のブロックを解析し symbolSet で管理する。
両方が終った所で oldSymbolSet と symbolSet で共通するシンボルの値が確定する。
    */  
   pri let mut oldSymbolSet:Set<&Ast.SymbolInfo>!;

   /** 親ブロックを管理する TentativeSymbol */
   pri let mut parent:TentativeSymbol!;
   pri let mut scope:&Ast.Scope;
   pri let mut skipFlag:bool;
   pri let loopFlag:bool;
   pri let mut accessSymList:List<&AccessSymPos> {pub&};

   pub fn __init( parent:TentativeSymbol!, scope:&Ast.Scope, loopFlag:bool ) {
      self.symbolSet = (@);
      self.oldSymbolSet = nil;
      self.parent = parent;
      self.scope = scope;
      self.skipFlag = false;
      self.loopFlag = loopFlag;
      self.accessSymList = [];
   }

   /**
このブロック内でアクセスしているシンボルを登録する。

未初期化シンボルへのアクセスがないかを検出するために利用する。
   */
   pub fn addAccessSym( accessSym:&AccessSymPos ) mut {
      self.accessSymList.insert( accessSym );
   }
   /**
   このブロック内でアクセスしているシンボルの登録をクリアする。
   */
   pub fn clearAccessSym() mut {
      if #self.accessSymList ~= 0 {
         self.accessSymList = [];
      }
   }

   /**
指定のシンボルに値をセット済みかどうかチェックする。
セット済みの場合、セット済み集合から除外する。

@return セット済みの場合 true
   */
   pub fn checkAndExclude( mut symbolInfo:&Ast.SymbolInfo ) mut : bool {
      symbolInfo = symbolInfo.getOrg();
      if self.symbolSet.has( symbolInfo ) {
         self.symbolSet.del( symbolInfo );
         return true;
      }
      return false;
   }

   /**
値をセットしたシンボルを登録する。   
   */
   pub fn regist( symbolInfo:&Ast.SymbolInfo ) mut : bool {
      self.symbolSet.add( symbolInfo.getOrg() );
      symbolInfo.set_hasValueFlag( true );

      if self.$scope.isInnerOf( symbolInfo.$scope ) {
         if not symbolInfo.$mutable {
            let mut work = self;
            while true {
               if! work.parent {
                  if work.scope == symbolInfo.$scope {
                     break;
                  }
                  if work.loopFlag {
                     // loop 内で immutable な変数へのセットはサポートしない
                     return false;
                  }
                  work = _exp;
               }
               else {
                  break;
               }
            }
         }
      }

      return true;
   }

   /**
return や break などでそのブロック自体を抜ける場合、
そこまで解析した情報は無意味になる。
よって解析情報を捨てることを通知する。
   */
   pub fn skip() mut {
      foreach symbolInfo in self.symbolSet {
         symbolInfo.set_hasValueFlag( false );
      }
      self.skipFlag = true;
   }

   /**
   oldSymbolSet と symbolSet に共通するシンボルを確定し、
   確定した情報を symbolSet にセットする。
     */   
   fn merge( finishFlag:bool ) mut {
      if self.skipFlag {
         self.skipFlag = false;
         if! let other = self.oldSymbolSet {
            self.symbolSet = other.clone();
         }
         if finishFlag {
            foreach symbolInfo in self.symbolSet {
               symbolInfo.set_hasValueFlag( true );
            }
         }
         return;
      }
      if! let other = self.oldSymbolSet {
         let mut mergedSet = self.symbolSet.clone().and( other );
         if finishFlag {
            foreach symbolInfo in self.symbolSet.clone().or( other ).sub( mergedSet ) {
               symbolInfo.set_hasValueFlag( false );
            }
         }
         else {
            foreach symbolInfo in self.symbolSet.clone().or( other ) {
               symbolInfo.set_hasValueFlag( false );
            }
         }
         self.symbolSet = mergedSet;
      }
      else {
         if not finishFlag {
            foreach symbolInfo in self.symbolSet {
               symbolInfo.set_hasValueFlag( false );
            }
         }
      }
   }

   /*
ブロックの解析処理を終了する。

if {} else {} の if のブロック終了時は、 else のブロックが残っているので、
complete は false を指定する。
   */
   pub fn finish( complete:bool ) mut : TentativeSymbol! {
      self.merge( true );
      if! let mut parent = self.parent {
         if complete {
            foreach symbolInfo in self.symbolSet {
               if symbolInfo.$hasValueFlag {
                  if parent.scope.isInnerOf( symbolInfo.$scope ) {
                     parent.symbolSet.add( symbolInfo );
                  }
               }
            }
         }
         else {
            foreach symbolInfo in self.symbolSet {
               symbolInfo.set_hasValueFlag( false );
            }
         }
         return parent;
      }
      return nil;
   }

   pub fn newSet( scope:&Ast.Scope ) mut {
      self.merge( false );
      self.oldSymbolSet = self.symbolSet;
      self.symbolSet = (@);
      self.scope = scope;
   }
}

enum AnalyzingState {
   Other,
   /** コンストラクタ */
   Constructor,
   /** class の __init ブロック */
   InitBlock,
   /** class の static method */
   ClassMethod,
   /** その他の 関数, メソッド */
   Func,
}

form checkImplicitCastCallback( dstType:&Ast.TypeInfo, expNode:&Nodes.Node ): &Nodes.Node!;

class ClosureFun {
   /** 関数シンボル */
   let symbol:&Ast.SymbolInfo;
   /** 関数シンボルにアクセスしているスコープ */
   let mut fromScope:Ast.Scope;

   /**
   アクセスしている関数シンボルがクロージャかどうか判定し、
   クロージャなら、このシンボルもクロージャとして登録する。

   @return クロージャだったら true
   */
   pub fn check() mut : bool {
      if! self.symbol.$typeInfo.$scope$.$closureSymList {
         if #_exp > 0 {
            self.fromScope.setClosure( self.symbol );
            return true;
         }
      }
      return false;
   }

   /**
指定の ClosureFun のリストの関数シンボルアクセスがクロージャかどうかの判定処理を行なう。
   */
   pub static fn checkList( list:List<ClosureFun> ) {
      let mut workList = list;
      let mut remainList:List<ClosureFun> = [];
      while true {
         let mut update = false;
         foreach closureFun in workList {
            if closureFun.check() {
               update = true;
            }
            else {
               remainList.insert( closureFun );
            }
         }
         if not update {
            break;
         }
         workList = remainList;
         remainList = [];
      }
   }
   
}

pub interface TransUnitIF {
   pub fn createModifier( typeInfo:&Ast.TypeInfo, mutMode: Ast.MutMode ) : &Ast.TypeInfo;
}

pub class TransUnit extend (TransUnitIF, Parser.PushbackParser) {

   /** 解析状態 */
   pri let mut analyzingStateQueue:List<AnalyzingState>;

   pri let mut importModuleInfo: frontInterface.ImportModuleInfo;

   /** true の場合は mut 制御が有効 */
   pri let mut validMutControl: bool;

   /** モジュール名 */
   pri let mut moduleName: str;
   pri let mut moduleType: &Ast.TypeInfo;

   pri let mut globalScope: Ast.Scope;
   pri let mut topScope: Ast.Scope;
   /** モジュールの最上位スコープ */
   pri let mut moduleScope: Ast.Scope;
   /** macro-statement の最上位スコープ */
   pri let mut macroScope: Ast.Scope!;

   /** 解析中の scope */
   pri let mut scope: Ast.Scope;
   /** */
   pri let mut tentativeSymbol:TentativeSymbol;
   /** クラスの TypeId -> NamespaceInfo */
   pri let mut typeId2ClassMap: Map<int,&Nodes.NamespaceInfo>;

   /** クラスの型情報 -> そのクラスを宣言しているノード */
   pri let mut typeInfo2ClassNode: Map<&Ast.TypeInfo,Nodes.DeclClassNode>;
   /** パーサー */
   pri let mut parser: Parser.DefaultPushbackParser;
   // /** push バックしたトークンリスト */
   // pri let mut pushbackList: List<&Parser.Token>;
   // /** 現在のトークン */
   // pri let mut currentToken: &Parser.Token;
   /** コメントリスト */
   pri let mut commentCtrl: Parser.CommentCtrl;
   
   // /** 解析済みトークンリスト */
   // pri let mut usedTokenList: List<&Parser.Token>;
   /** 解析エラーメッセージ */
   pri let mut errMessList: str[] { pub };
   /** 解析警告ーメッセージ */
   pri let mut warnMessList: str[] { pub };

   /** インポートしているモジュールの TypeInfo -> シンボル情報 */
   pri let mut importModule2ModuleInfo: Map<&Ast.TypeInfo,&Nodes.ModuleInfo>;
   pri let mut importModuleName2ModuleInfo: Map<str,&Nodes.ModuleInfo>;

   /** subfile 名のリスト */
   pri let mut subfileList: str[];

   /** __func__ シンボルを持つ関数 TypeInfo の set */
   pri let mut has__func__Symbol: Set<&Ast.TypeInfo>;

   /** 解析モード */
   pri let analyzeMode: AnalyzeMode;
   /** 解析対象位置 */
   pri let analyzePos: &Parser.Position;
   /** 解析対象モジュール */
   pri let analyzeModule: str;

   pri let mut helperInfo:Nodes.LuneHelperInfo;

   /** provide ノード */
   pri let mut provideNode: Nodes.ProvideNode!;
   /** NodeKind -> Node[]  */
   pri let mut nodeManager: Nodes.NodeManager;

   /** ループ系制御構文(for 等)の Scope */
   pri let mut loopScopeQueue: List<&Ast.Scope>;

   /**
プロトタイプだけの関数のタイプ Map。
解析終了時に、この  Map に残っているとエラー。

関数の TypeInfo → Position.
   */
   pri let mut protoFuncMap:Map<&Ast.TypeInfo,&Parser.Position>;
   /**
   プロトタイプ宣言しているクラス。
   解析終了時に、この  Map に残っているとエラー。
   */
   pri let mut protoClassMap:Map<&Ast.TypeInfo,&Parser.Position>;

   /**
トランスコンパイル先の lua バージョン
   */
   pri let targetLuaVer:&LuaVer.LuaVerInfo;

   pri let moduleId:frontInterface.ModuleId;

   /** true の場合、 _ で始まるシンボル名チェックをしない */
   pri let mut ignoreToCheckSymbol_:bool;

   pri let ctrl_info: &Option.TransCtrlInfo;

   pri let mut macroCtrl:Macro.MacroCtrl;
   
   pri let mut typeNameCtrl:&Ast.TypeNameCtrl;

   pri let mut scopeAccess:Ast.ScopeAccess;

   /** クロージャ候補の関数情報リスト */
   let mut closureFunList:List<ClosureFun>;

   /** advertise 宣言されているメンバの型の Set */
   let mut advertisedTypeSet:Set<&Ast.TypeInfo>;
   

   pub fn __init( moduleId:&frontInterface.ModuleId,
                  importModuleInfo:frontInterface.ImportModuleInfo,
                  macroEval: Nodes.MacroEval, analyzeModule:str!, mode:AnalyzeMode!,
                  pos:&Parser.Position!, targetLuaVer:&LuaVer.LuaVerInfo,
                  ctrl_info: &Option.TransCtrlInfo )
   {
      self.advertisedTypeSet = (@);
      self.closureFunList = [];
      self.scopeAccess = .Normal;
      self.macroCtrl = new Macro.MacroCtrl( macroEval );
      self.typeNameCtrl = Ast.defaultTypeNameCtrl;
      self.protoClassMap = {};
      self.analyzingStateQueue = [];
      // self.macroCallLineNo = 0;
      //self.useModuleMacroSet = (@);
      self.ctrl_info = ctrl_info;
      self.ignoreToCheckSymbol_ = false;
      self.moduleId = moduleId;
      self.helperInfo = new Nodes.LuneHelperInfo();
      self.targetLuaVer = targetLuaVer;
      self.importModuleInfo = importModuleInfo;
      self.protoFuncMap = {};
      self.loopScopeQueue = [];
      self.has__func__Symbol = (@);
      self.nodeManager = new Nodes.NodeManager();
      self.importModuleName2ModuleInfo = {};
      self.importModule2ModuleInfo = {};
      self.macroScope = nil;
      self.validMutControl = true;
      self.moduleName = "";
      self.moduleType = Ast.headTypeInfo;
      self.parser = new Parser.DefaultPushbackParser( new Parser.DummyParser() );
      self.subfileList = [];
      // self.pushbackList = [];
      // self.usedTokenList = [];

      // self.scope = Ast.rootScope;
      // self.topScope = Ast.rootScope;
      // self.moduleScope = Ast.rootScope;
      self.globalScope = new Ast.Scope( Ast.rootScope, false, nil ## );

      self.scope = new Ast.Scope( self.globalScope, true, nil ## );
      self.topScope = self.scope;
      self.moduleScope = self.scope;

      self.tentativeSymbol = new TentativeSymbol( nil, self.globalScope, false );

      self.typeId2ClassMap = {};
      self.typeInfo2ClassNode = {};
      // self.currentToken = Parser.getEofToken();
      self.commentCtrl = new Parser.CommentCtrl();
      self.errMessList = [];
      self.warnMessList = [];
      self.analyzeMode = unwrap mode default AnalyzeMode.Compile;
      self.analyzePos = unwrap pos default new Parser.Position( 0, 0 );
      self.analyzeModule = unwrap analyzeModule default "";
      self.provideNode = nil;
   }

   pub fn error( mess: str ) mut : __;

   pri fn pushAnalyzingState( state:AnalyzingState ) mut {
      self.analyzingStateQueue.insert( state );
   }

   pri fn popAnalyzingState() mut {
      if #self.analyzingStateQueue == 0 {
         self.error( "underflow analyzingStateQueue" );
      }
      self.analyzingStateQueue.remove(##);
   }

   pri fn inAnalyzingState( state:AnalyzingState ): bool {
      // foreach workstate in self.analyzingStateQueue {
      //    if workstate == state {
      //       return true;
      //    }
      // }
      if #self.analyzingStateQueue > 0 {
         return self.analyzingStateQueue[ #self.analyzingStateQueue ] == state;
      }
      return false;
   }

   pri fn addErrMess( pos: &Parser.Position, mess: str ) mut {
      self.errMessList.insert(
         "%s:%d:%d: error: %s" ( self.parser.getStreamName(),
                                 pos.lineNo, pos.column, mess ) );
   }

   pri fn addWarnMess( pos: &Parser.Position, mess: str ) mut {
      self.warnMessList.insert(
         "%s:%d:%d: warning: %s" ( self.parser.getStreamName(),
                                   pos.lineNo, pos.column, mess ) );
   }

   // pri fn pushScope( classFlag: bool, inheritScope: Ast.Scope!,
   //                   ifScopeList:List<Ast.Scope>! ) mut : Ast.Scope
   pri fn pushScope( classFlag: bool, baseInfo: &Ast.TypeInfo!,
                     interfaceList: &List<&Ast.TypeInfo>! ) mut: Ast.Scope
   {
      // self.scope = new Ast.Scope( self.scope, classFlag, inheritScope, ifScopeList );
      self.scope = Ast.TypeInfo.createScope(
         self.scope, classFlag, baseInfo, interfaceList );
      return self.scope;
   }

   pri fn popScope() mut {
      self.scope = self.scope.get_parent();
   }

   pri fn prepareTentativeSymbol( scope:&Ast.Scope, loopFlag:bool ) mut {
      self.tentativeSymbol = new TentativeSymbol( self.tentativeSymbol, scope, loopFlag );
   }

   pri fn checkAccesSym() mut {
      foreach accessSym in self.tentativeSymbol.$accessSymList {
         let symbolInfo = accessSym.$symbol;
         if not symbolInfo.$hasValueFlag {
            self.addErrMess(
               accessSym.$pos,
               "This can't access variable have no value -- %s" (symbolInfo.$name) );
         }
      }
      self.tentativeSymbol.clearAccessSym();
   }
   
   pri fn finishTentativeSymbol( complete:bool ) mut {
      self.checkAccesSym();
      self.tentativeSymbol = unwrap self.tentativeSymbol.finish( complete );
   }

   pri fn mergeTentativeSymbol( scope:&Ast.Scope ) mut {
      self.checkAccesSym();
      self.tentativeSymbol.newSet( scope );
   }


   pri fn getCurrentClass() : &Ast.TypeInfo {
      let typeInfo = Ast.headTypeInfo;
      let mut scope = self.scope;
      repeat {
         if! scope.$ownerTypeInfo {
            if _exp.$kind == .Class or _exp.$kind == .Module or _exp.$kind == .IF {
               return _exp;
            }
         }
         scope = scope.$parent;
      } scope.isRoot();
      return typeInfo;
   }


   pri fn getCurrentNamespaceTypeInfo() : &Ast.TypeInfo {
      // let typeInfo = Ast.headTypeInfo;
      // let mut scope = self.scope;
      // repeat {
      //    if! scope.$ownerTypeInfo {
      //       return _exp;
      //    }
      //    scope = scope.$parent;
      // } scope.isRoot();
      // return typeInfo;
      return self.scope.getNamespaceTypeInfo();
   }

   pri fn getCurrentNamespaceScope(): Ast.Scope {
      return unwrap self.getCurrentNamespaceTypeInfo().$scope;
   }

   pri fn pushModule( externalFlag: bool, name:str, mutable: bool ) mut : &Ast.TypeInfo
   {
      let mut typeInfo:&Ast.TypeInfo = Ast.headTypeInfo;

      let modName;
      if name.find( "^@" ## ) {
         modName = name;
      }
      else {
         modName = "@%s" (name);
      }
      
      if! self.scope.getTypeInfoChild( modName ) {
         typeInfo = _exp;
         self.scope = unwrap Ast.getScope( typeInfo );
      }
      else {
         let parentInfo = self.getCurrentNamespaceTypeInfo();
         let mut parentScope = self.scope;
         let mut scope = self.pushScope( true ## );
         typeInfo = Ast.NormalTypeInfo.createModule(
            scope, parentInfo, externalFlag, modName, mutable );

         parentScope.addClass( modName, nil, typeInfo );
      }
      if not self.typeId2ClassMap[ typeInfo.get_typeId() ] {
         let namespace = new Nodes.NamespaceInfo( modName, self.scope, typeInfo );
         self.typeId2ClassMap[ typeInfo.get_typeId() ] = namespace;
      }
      return typeInfo;
   }

   pri fn popModule() mut {
      self.popScope();
   }

   /**
既存クラスの Scope を push する。
   */
   pri fn pushClassScope( errPos:&Parser.Position, classTypeInfo:&Ast.TypeInfo ) mut {
      if self.scope ~= classTypeInfo.$scope$.$parent {
         self.addErrMess( errPos, "This class does not exist in this scope. -- %s"
                          (classTypeInfo.getTxt( ## )) );
      }
      self.scope = unwrap Ast.getScope( classTypeInfo );
   }

   /**
指定クラスの Scope を push し、TypeInfo を取得する。

クラスが生成済みの場合は baseInfo, interfaceList, genTypeList に nil を指定する。
   */
   pub fn pushClass(
      errPos:&Parser.Position, classFlag:bool, abstractFlag: bool,
      baseInfo: &Ast.TypeInfo!, interfaceList: &List<&Ast.TypeInfo>!,
      genTypeList: &List<&Ast.AlternateTypeInfo>!, externalFlag: bool, name:str,
      allowMultiple:bool,
      accessMode:Ast.AccessMode, defNamespace: Nodes.NamespaceInfo! ) mut : &Ast.TypeInfo
   {
      let mut typeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
      if! self.scope.getTypeInfo( name, self.scope, true, .Normal ) {
         typeInfo = _exp;
      }
      //if! self.scope.getTypeInfoChild( name ) {

      if typeInfo ~= Ast.headTypeInfo {
         if typeInfo.$scope$.$parent ~= self.scope {
            self.addErrMess(
               errPos,     
               "multiple class(%s)" (typeInfo.getTxt( self.typeNameCtrl ##)));
            // クラスの複数定義は、その後の解析すると、
            self.error( "stop by error" );
         }
      }
      if typeInfo ~= Ast.headTypeInfo
      {
         // 宣言済み

         if typeInfo.$abstractFlag ~= abstractFlag {
            self.addErrMess( errPos,
                             "mismatch class(%s) abstract for prototpye"
                             (typeInfo.getTxt( self.typeNameCtrl ##)));
         }
         if typeInfo.$accessMode ~= accessMode {
            self.addErrMess( errPos,
                             "mismatch class(%s) accessmode(%s) for prototpye accessmode(%s)"
                             ( typeInfo.getTxt( self.typeNameCtrl ##),
                               accessMode.$_txt, typeInfo.$accessMode.$_txt));
         }
         when! baseInfo {
            if typeInfo.$baseTypeInfo ~= baseInfo {
               self.addErrMess(
                  errPos,
                  "mismatch class(%s) base class(%s) for prototpye base class(%s)"
                  ( typeInfo.getTxt( self.typeNameCtrl##),
                    baseInfo.getTxt(##), typeInfo.$baseTypeInfo.getTxt(##)));
            }
         }
         else {
            if typeInfo.hasBase() {
               self.addErrMess(
                  errPos,
                  "mismatch class(%s) base class(None) for prototpye base class(%s)"
                  ( typeInfo.getTxt( self.typeNameCtrl##),
                    typeInfo.$baseTypeInfo.getTxt(##)));
            }
         }

         fn compareList( protoList:&List<&Ast.TypeInfo>,
                         typeList:&List<&Ast.TypeInfo>, message:str )
         {
            if #protoList == #typeList {
               foreach protoType, index in protoList {
                  if protoType ~= typeList[ index ] {
                     self.addErrMess(
                        errPos,
                        "mismatch class(%s) %s(%s) for prototpye %s(%s)"
                        ( typeInfo.getTxt(self.typeNameCtrl##), message,
                          typeList[ index ].getTxt(self.typeNameCtrl##),
                          message, protoType.getTxt(##)));
                  }
               }
            }
            else {
               self.addErrMess(
                  errPos,
                  "mismatch class(%s) %s(%d) for prototpye %s(%d)"
                  ( typeInfo.getTxt(self.typeNameCtrl##), message, #typeList,
                    message, #protoList) );
            }
         }
         
         compareList( typeInfo.$interfaceList,
                      unwrap interfaceList default [], "interface" );
         
         compareList( typeInfo.$itemTypeInfoList,
                      unwrap genTypeList default [], "generics" );

         

         self.scope = unwrap Ast.getScope( typeInfo );
         switch ( typeInfo.$kind ) {
            case .Class {
               if not classFlag {
                  self.addErrMess(
                     errPos,
                     "define interface already -- %s" (name) );
                  Util.printStackTrace();
               }
            }
            case .IF {
               if classFlag {
                  self.addErrMess(
                     errPos,
                     "define class already -- %s" (name) );
                  Util.printStackTrace();
               }
            }
         }
      }
      else {
         let parentInfo = self.getCurrentNamespaceTypeInfo();

         let mut parentScope = self.scope;
         let mut scope = self.pushScope( true, baseInfo, interfaceList );
         let workGenTypeList;
         when! genTypeList {
            workGenTypeList = genTypeList;
         }
         else {
            workGenTypeList = [];
         }
         typeInfo = Ast.NormalTypeInfo.createClass(
            classFlag, abstractFlag, scope, baseInfo, interfaceList,
            workGenTypeList, parentInfo, externalFlag, accessMode, name );
         
         parentScope.addClass( name, errPos, typeInfo );
      }
      when! genTypeList {
         foreach genType in genTypeList {
            self.scope.addAlternate( accessMode, genType.$txt, errPos, genType );
         }
      }

      let! mut namespace = defNamespace {
         namespace = new Nodes.NamespaceInfo( name, self.scope, typeInfo );
      };
      self.typeId2ClassMap[ typeInfo.get_typeId() ] = namespace;
      return typeInfo;
   }

   pri fn popClass() mut {
      self.popScope();
   }

   pub fn pushbackStr( name: str, statement: str ) mut;
   pri fn analyzeDecl( accessMode: Ast.AccessMode, staticFlag:
                       bool, firstToken: &Parser.Token,
                       token: &Parser.Token ) mut: Nodes.Node!;
   pri fn analyzeDeclVar(
      mode:Nodes.DeclVarMode,
      accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut: Nodes.Node;
   pri fn analyzeDeclFunc(
      declFuncMode: DeclFuncMode, abstractFlag: bool,
      overrideFlag: bool, accessMode: Ast.AccessMode, staticFlag: bool,
      mut classTypeInfo: &Ast.TypeInfo!,
      firstToken: &Parser.Token, name: &Parser.Token! ) mut : Nodes.Node;
   pri fn analyzeDeclClass(
      abstractFlag:bool, classAccessMode: Ast.AccessMode,
      classToken: &Parser.Token, mode:DeclClassMode ) mut : Nodes.DeclClassNode;
   pri fn analyzeExp( allowNoneType:bool, skipOp2Flag: bool, opLevel: int!,        
                      expectType:&Ast.TypeInfo! ) mut : Nodes.Node;
   pri fn analyzeExpOne( allowNoneType:bool, skipOp2Flag: bool, opLevel: int!,        
                         expectType:&Ast.TypeInfo! ) mut : Nodes.Node;
   pri fn analyzeStatement( termTxt: str! ) mut : Nodes.Node!;
   pri fn analyzeExpSymbol(
      firstToken: &Parser.Token, token: &Parser.Token,
      mode: ExpSymbolMode, prefixExp: &Nodes.Node!, skipFlag: bool ) mut : Nodes.Node;
   pri fn analyzeExpList(
      allowNoneType:bool, skipOp2Flag: bool, expNode: &Nodes.Node!,
      expectTypeList: &List<&Ast.TypeInfo>!, contExpect: bool! ) mut : Nodes.ExpListNode;
   pri fn analyzeIfUnwrap( firstToken: &Parser.Token ) mut : Nodes.IfUnwrapNode;
   pub fn getTokenNoErr() mut : &Parser.Token;
   pri fn analyzeRefTypeWithSymbol(
      accessMode: Ast.AccessMode, allowDDD:bool, refFlag: bool,
      mutFlag: bool, symbolNode:&Nodes.Node, parentPub:bool ) mut: Nodes.RefTypeNode;

   pri fn checkAlgeComp( token:&Parser.Token, algeTypeInfo: &Ast.AlgeTypeInfo );


   fn evalMacroOp(
      firstToken: &Parser.Token, macroTypeInfo: &Ast.TypeInfo,
      expList: &Nodes.ExpListNode!, evalMacroCallback:Macro.EvalMacroCallback ) mut;
   fn prepareExpCall(
      position:&Parser.Position, funcTypeInfo:&Ast.TypeInfo,
      genericTypeList:&List<&Ast.TypeInfo>, genericsClass:&Ast.TypeInfo ) mut:
      Map<&Ast.TypeInfo,&Ast.TypeInfo>, &Nodes.ExpListNode!;

   fn errorShadowing( pos:&Parser.Position, symbolInfo:&Ast.SymbolInfo! ) mut {
      when! symbolInfo {
         let symPos = symbolInfo.$pos;
         when! symPos {
            self.addErrMess(
               symPos, "This symbol is shadowed from %d:%d -- %s"
               (pos.lineNo, pos.column, symbolInfo.$name ) );
         }
         self.addErrMess(
            pos, "shadowing symbol of %s -- %s"
            (symPos and "%s:%s" (symPos$.lineNo, symPos$.column) or "external",
              symbolInfo.$name ) );     
      }
   }
   
   pri fn checkShadowing( pos:&Parser.Position, name:str, scope:&Ast.Scope ) mut {
      let symbolInfo = self.scope.getSymbolTypeInfo(
         name, scope, self.moduleScope, self.scopeAccess );

      self.errorShadowing( pos, symbolInfo );
   }

   
   pri fn addLocalVar(
      pos:&Parser.Position, argFlag:bool, canBeLeft:bool, name:str,
      typeInfo: &Ast.TypeInfo, mutable:Ast.MutMode, allowShadow:bool! ) mut:
      &Ast.SymbolInfo
   {
      if not allowShadow {
         if self.scope.getSymbolTypeInfo(
            name, self.scope, self.moduleScope, self.scopeAccess ) {
            self.addErrMess( pos, "shadowing variable -- %s" (name) );
         }
      }
      return unwrap self.scope.addLocalVar(
         argFlag, canBeLeft, name, pos, typeInfo, mutable );
   }


   fn checkImplicitCast(
      alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo>,
      dstTypeList:&List<&Ast.TypeInfo>, expListNode:&Nodes.ExpListNode,
      callback:checkImplicitCastCallback ) mut : Nodes.ExpListNode!;
}


let mut op2levelMap:Map<str,int> = {};
let mut op1levelMap:Map<str,int> = {};

/** 最高優先度 */
let mut opTopLevel = 0;

{
   let mut opLevelBase = 0;
   fn regOpLevel( opnum: int, opList: str[@] ) {
      opLevelBase = opLevelBase + 1;
      if opnum == 1 {
         foreach op in opList {
            op1levelMap[ op ] = opLevelBase;
         }
      }
      else {
         foreach op in opList {
            op2levelMap[ op ] = opLevelBase;
         }
      }
   }
   regOpLevel( 2, [@ "=" ] );
   regOpLevel( 2, [@ "or" ] );
   regOpLevel( 2, [@ "and" ] );
   regOpLevel( 2, [@ "<", ">", "<=", ">=", "~=", "==" ] );
   regOpLevel( 2, [@ "|" ] );
   regOpLevel( 2, [@ "~" ] );
   regOpLevel( 2, [@ "&" ] );
   regOpLevel( 2, [@ "|<<", "|>>" ] );
   regOpLevel( 2, [@ ".." ] );
   regOpLevel( 2, [@ "+", "-" ] );
   regOpLevel( 2, [@ "*", "/", "//", "%" ] );
   regOpLevel( 1, [@ "`", ",,", ",,,", ",,,," ] );
   regOpLevel( 1, [@ "not", "#", "-", "~" ] );
   regOpLevel( 1, [@ "^" ] );

   opTopLevel = opLevelBase + 1;
}


let mut quotedChar2Code:Map<str,int> = {};
quotedChar2Code[ 'a' ] = 7;    // \a
quotedChar2Code[ 'b' ] = 8;    // \b
quotedChar2Code[ 't' ] = 9;    // \t
quotedChar2Code[ 'n' ] = 10;   // \t
quotedChar2Code[ 'v' ] = 11;   // \v
quotedChar2Code[ 'f' ] = 12;   // \f
quotedChar2Code[ 'r' ] = 13;   // \r
quotedChar2Code[ '\\' ] = ?\\; // \\
quotedChar2Code[ '"' ] = ?\";  // "
quotedChar2Code[ "'" ] = ?\';  // '

pub fn TransUnit.createModifier(
   typeInfo:&Ast.TypeInfo, mutMode: Ast.MutMode ) : &Ast.TypeInfo
{
   if not self.validMutControl {
      return typeInfo;
   }
   return Ast.NormalTypeInfo.createModifier( typeInfo, mutMode );
}

proto abstract class _TypeInfo extend (Mapping);

class ImportParam {
   pub let pos:&Parser.Position;
   pub let mut transUnit:TransUnitIF;
   pub let mut typeId2Scope:Map<int,Ast.Scope>;
   pub let mut typeId2TypeInfo:Map<int,&Ast.TypeInfo>;
   pub let metaInfo:Meta._MetaInfo;
   pub let scope:Ast.Scope;
   pub let moduleTypeInfo: &Ast.TypeInfo;
   pub let scopeAccess:Ast.ScopeAccess;

   pri let typeId2AtomMap:Map<int,&_TypeInfo>;
}

abstract class _TypeInfo extend (Mapping) {
   pub let skind: Ast.SerializeKind;
   pub let parentId: int;
   pub let typeId: int;
   pub fn __init() {
      self.parentId = Ast.rootTypeId;
      self.typeId = Ast.rootTypeId;
      self.skind = .Normal;
   }

   /**
このインスタンスから TypeInfo を生成する。

@param param 作業情報
@return Ast.TypeInfo! 生成した型情報。 失敗した場合は nil。
@return str! エラー情報。成功した場合は nil。
   */
   pub abstract fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!;
}

pub fn ImportParam.getTypeInfo(typeId:int) mut :&Ast.TypeInfo!, str! {
   if! let typeInfo = self.typeId2TypeInfo[ typeId ] {
      return typeInfo, nil;
   }
   if! let atom = self.typeId2AtomMap[ typeId ] {
      let typeInfo, mess = atom.createTypeInfo( self );
      when! typeInfo {
         self.typeId2TypeInfo[ typeId ] = typeInfo;
      }
      return typeInfo, mess;
   }
   return nil, nil;
}

class _TypeInfoNilable extend _TypeInfo {
   pub let nilable:bool;
   pub let orgTypeId:int;

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      //let orgTypeInfo = unwrap param.typeId2TypeInfo[ self.orgTypeId ];
      let orgTypeInfo = unwrap param.getTypeInfo( self.orgTypeId );
      let newTypeInfo = orgTypeInfo.get_nilableTypeInfo();
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      return newTypeInfo,nil;
   }
}


class _TypeInfoAlias extend _TypeInfo {
   pri let rawTxt:str;
   pri let srcTypeId:int;

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let srcTypeInfo = unwrap param.getTypeInfo( self.srcTypeId );
      let newTypeInfo = Ast.NormalTypeInfo.createAlias(
         self.rawTxt, true, .Pub, param.moduleTypeInfo, srcTypeInfo );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;

      let! mut parentScope = param.typeId2Scope[ self.parentId ] {
         return nil, "not found parentScope %s %s" ( self.parentId, self.rawTxt );
      };
      parentScope.addAliasForType( self.rawTxt, nil, newTypeInfo );


      return newTypeInfo,nil;
   }
}


class _TypeInfoDDD extend _TypeInfo {
   pub let itemTypeId:int;

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      //let itemTypeInfo = unwrap param.typeId2TypeInfo[ self.itemTypeId ];
      let itemTypeInfo = unwrap param.getTypeInfo( self.itemTypeId );
      let newTypeInfo = Ast.NormalTypeInfo.createDDD( itemTypeInfo, true );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      return newTypeInfo,nil;
   }
}


class _TypeInfoAlternate extend _TypeInfo {
   pub let txt:str;
   pub let accessMode:Ast.AccessMode;
   pub let baseId:int;
   pub let ifList:&List<int>;
   pub let belongClassFlag:bool;
   pub let altIndex:int;

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let baseInfo = unwrap param.getTypeInfo( self.baseId );
      let mut interfaceList:List<&Ast.TypeInfo> = [];
      foreach ifTypeId in self.ifList {
         //interfaceList.insert( unwrap param.typeId2TypeInfo[ ifTypeId ] );
         interfaceList.insert( unwrap param.getTypeInfo( ifTypeId ) );
      }
      let newTypeInfo = Ast.NormalTypeInfo.createAlternate(
         self.belongClassFlag, self.altIndex,
         self.txt, self.accessMode, param.moduleTypeInfo, baseInfo, interfaceList );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      return newTypeInfo, nil;
   }
}

class _TypeInfoGeneric extend _TypeInfo {
   pub let genSrcTypeId:int;
   pub let genTypeList:&List<int>;

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let genSrcTypeInfo = unwrap param.getTypeInfo( self.genSrcTypeId );
      let mut genTypeList:List<&Ast.TypeInfo> = [];
      foreach typeId in self.genTypeList {
         genTypeList.insert( unwrap param.getTypeInfo( typeId ) );
      }
      let newTypeInfo = Ast.NormalTypeInfo.createGeneric(
         genSrcTypeInfo, genTypeList, param.moduleTypeInfo );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      return newTypeInfo, nil;
   }
}

class _TypeInfoBox extend _TypeInfo {
   pub let accessMode:Ast.AccessMode;
   pub let boxingType:int;

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let boxingType = unwrap param.getTypeInfo( self.boxingType );
      let newTypeInfo = Ast.NormalTypeInfo.createBox( self.accessMode, boxingType );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      return newTypeInfo, nil;
   }
}


class _TypeInfoModifier extend _TypeInfo {
   pub let srcTypeId:int;
   pub let mutMode:Ast.MutMode;

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      //let! srcTypeInfo = param.typeId2TypeInfo[ self.srcTypeId ] {
      let! srcTypeInfo = param.getTypeInfo( self.srcTypeId ) {
         return nil, "not found srcType -- %d, %d" ( self.parentId, self.srcTypeId );
      };
      let newTypeInfo = param.transUnit.createModifier( srcTypeInfo, self.mutMode );
      param.typeId2TypeInfo[ self.typeId ] = newTypeInfo;
      return newTypeInfo, nil;
   }
}

class _TypeInfoModule extend _TypeInfo {
   pub let txt:str;

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let mut parentInfo:&Ast.TypeInfo = Ast.headTypeInfo;
      if self.parentId ~= Ast.rootTypeId {
         //let! workTypeInfo = param.typeId2TypeInfo[ self.parentId ] {
         let! workTypeInfo = param.getTypeInfo( self.parentId ) {
            Util.err( "not found parentInfo %s %s"
                      ( self.parentId, self.txt ) );
         };
         parentInfo = workTypeInfo;
      }
      let! mut parentScope = param.typeId2Scope[ self.parentId ] {
         return nil, "not found parentScope %s %s" ( self.parentId, self.txt );
      };

      let mut newTypeInfo = parentScope.getTypeInfoChild( self.txt );
      if! newTypeInfo {
         param.typeId2Scope[ self.typeId ] = Ast.getScope( _exp );
         if not _exp.$scope {
            return nil, "not found scope %s %s %s %s %s" ( parentScope, self.parentId,
                                                           self.typeId,
                                                           self.txt, _exp.getTxt(##) );
         }
         param.typeId2TypeInfo[ self.typeId ] = _exp;
      }
      else {
         let mut scope = new Ast.Scope( parentScope, true, nil ## );

         let mut mutable = false;
         if self.typeId == param.metaInfo.__moduleTypeId {
            mutable = param.metaInfo.__moduleMutable;
         }
         let workTypeInfo = Ast.NormalTypeInfo.createModule(
            scope, parentInfo, true, self.txt, mutable );

         newTypeInfo = workTypeInfo;
         param.typeId2Scope[ self.typeId ] = scope;
         param.typeId2TypeInfo[ self.typeId ] = workTypeInfo;
         parentScope.addClass( self.txt, nil, workTypeInfo );
      }
      return newTypeInfo, nil;
   }
}

class _TypeInfoNormal extend _TypeInfo {
   pub let abstractFlag: bool;
   pub let baseId:int;
   pub let txt:str;
   pub let staticFlag:bool;
   pub let accessMode:Ast.AccessMode;
   pub let kind:Ast.TypeInfoKind;
   pub let mutMode: Ast.MutMode;
   pub let ifList: int[];
   pub let itemTypeId: int[];
   pub let argTypeId: int[];
   pub let retTypeId: int[];
   pub let children: int[];

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let mut newTypeInfo:&Ast.TypeInfo! = nil;
      if self.parentId ~= Ast.rootTypeId or
         not Ast.builtInTypeIdSet[ self.typeId ] or
         self.kind == Ast.TypeInfoKind.List or
         self.kind == Ast.TypeInfoKind.Array or
         self.kind == Ast.TypeInfoKind.Map or
         self.kind == Ast.TypeInfoKind.Set
      {
         let mut parentInfo:&Ast.TypeInfo = Ast.headTypeInfo;
         if self.parentId ~= Ast.rootTypeId {
            //let! workTypeInfo = param.typeId2TypeInfo[ self.parentId ] {
            let! workTypeInfo = param.getTypeInfo( self.parentId ) {
               return nil, "not found parentInfo %s %s" ( self.parentId, self.txt );
            };
            parentInfo = workTypeInfo;
         }

         let mut itemTypeInfo:List<&Ast.TypeInfo> = [];
         foreach typeId in self.itemTypeId {
            //itemTypeInfo.insert( unwrap param.typeId2TypeInfo[ typeId ] );
            itemTypeInfo.insert( unwrap param.getTypeInfo( typeId ) );
         }
         let mut argTypeInfo:List<&Ast.TypeInfo> = [];
         foreach typeId, index in self.argTypeId {
            //if! let argType = param.typeId2TypeInfo[ typeId ] {
            let argType, mess = param.getTypeInfo( typeId );
            when! argType {
               argTypeInfo.insert( argType );
            }
            else {
               let errmess = "not found arg (index:%d) -- %s.%s, %d, %d. %s"
                   ( index, parentInfo.getTxt(##), self.txt, typeId,
                     #self.argTypeId, mess );
               return nil, errmess;
            }
         }
         let mut retTypeInfo:List<&Ast.TypeInfo> = [];
         foreach typeId in self.retTypeId {
            //retTypeInfo.insert( unwrap param.typeId2TypeInfo[ typeId ] );
            retTypeInfo.insert( unwrap param.getTypeInfo( typeId ) );
         }

         //let baseInfo = unwrap param.typeId2TypeInfo[ self.baseId ];
         let baseInfo = unwrap param.getTypeInfo( self.baseId );
         let mut interfaceList:List<&Ast.TypeInfo> = [];
         foreach ifTypeId in self.ifList {
            //interfaceList.insert( unwrap param.typeId2TypeInfo[ ifTypeId ] );
            interfaceList.insert( unwrap param.getTypeInfo( ifTypeId ) );
         }

         let! mut parentScope = param.typeId2Scope[ self.parentId ] {
            return nil, "not found parentScope %s %s" ( self.parentId, self.txt );
         };

         if self.txt ~= "" {
            newTypeInfo = parentScope.getTypeInfoChild( self.txt );
         }
         if newTypeInfo and ( self.kind == Ast.TypeInfoKind.Class or
                              self.kind == Ast.TypeInfoKind.IF )
         {
            if! newTypeInfo {
               param.typeId2Scope[ self.typeId ] = Ast.getScope( _exp );
               if not _exp.$scope {
                  Util.err( "not found scope %s %s %s %s %s"
                            ( parentScope, self.parentId,
                              self.typeId,
                              self.txt, _exp.getTxt(##) ) );
               }
               param.typeId2TypeInfo[ self.typeId ] = _exp;
            };
         }
         else {
            if self.kind == Ast.TypeInfoKind.Class or
               self.kind == Ast.TypeInfoKind.IF
            {
               let baseScope = unwrap param.typeId2Scope[ self.baseId ];
               let mut ifScopeList:List<Ast.Scope> = [];
               foreach ifType in interfaceList {
                  ifScopeList.insert( unwrap ifType.$scope );
               }

               let mut scope = new Ast.Scope( parentScope, true, baseScope, ifScopeList );

               let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
               foreach itemType in itemTypeInfo {
                  altTypeList.insert( unwrap (itemType@@@Ast.AlternateTypeInfo) );
               }

               let workTypeInfo = Ast.NormalTypeInfo.createClass(
                  self.kind == Ast.TypeInfoKind.Class, self.abstractFlag,
                  scope, baseInfo, interfaceList, altTypeList,
                  parentInfo, true, .Pub, self.txt );
               parentScope.addClass( self.txt, nil, workTypeInfo );
               
               newTypeInfo = workTypeInfo;

               param.typeId2Scope[ self.typeId ] = scope;
               param.typeId2TypeInfo[ self.typeId ] = workTypeInfo;
            }
            else {
               let mut scope:Ast.Scope! = nil;

               if self.kind == Ast.TypeInfoKind.Func or
                  self.kind == Ast.TypeInfoKind.Method
               {
                  scope = new Ast.Scope( parentScope, false, nil ## );
               }


               let typeInfoKind = self.kind;
               let accessMode = self.accessMode;
               let workTypeInfo = Ast.NormalTypeInfo.create(
                  accessMode,
                  self.abstractFlag, scope, baseInfo,
                  interfaceList, parentInfo, self.staticFlag, typeInfoKind,
                  self.txt, itemTypeInfo, argTypeInfo, retTypeInfo, self.mutMode );
               newTypeInfo = workTypeInfo;

               param.typeId2TypeInfo[ self.typeId ] = workTypeInfo;

               switch self.kind {
                  case .Func, .Method, .Macro, .Form, .FormFunc {
                     let mut symbolKind = Ast.SymbolKind.Fun;
                     switch self.kind {
                        case .Method {
                           symbolKind = Ast.SymbolKind.Mtd;
                        }
                        case .Macro {
                           symbolKind = Ast.SymbolKind.Mac;
                        }
                        case .Form, .FormFunc {
                           symbolKind = Ast.SymbolKind.Typ;
                        }
                     }
                     let mut workParentScope =
                        unwrap param.typeId2Scope[ self.parentId ];
                     workParentScope.add(
                        symbolKind, false, self.kind == .Func,
                        self.txt, nil, workTypeInfo, accessMode,
                        self.staticFlag, .IMut, true );
                     param.typeId2Scope[ self.typeId ] = scope;
                  }
               }
            }
         }
      }
      else {
         newTypeInfo = param.scope.getTypeInfo(
            self.txt, param.scope, false, param.scopeAccess );
         if not newTypeInfo {
            foreach val, key in self._toMap() {
               Util.errorLog( "error: illegal self %s:%s" ( key, val ) );
            }
         }
         param.typeId2TypeInfo[ self.typeId ] = unwrap newTypeInfo;
      }
      return newTypeInfo, nil;
   }
}

class _TypeInfoEnum extend _TypeInfo {
   pub let txt:str;
   pub let accessMode:Ast.AccessMode;
   pub let valTypeId:int;
   pub let enumValList: Map<str,stem>;

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let accessMode = unwrap Ast.AccessMode._from( self.accessMode );
      //let parentInfo = unwrap param.typeId2TypeInfo[ self.parentId ];
      let parentInfo = unwrap param.getTypeInfo( self.parentId );
      let mut name2EnumValInfo:Map<str,Ast.EnumValInfo> = {};
      let mut parentScope = unwrap Ast.getScope( parentInfo );
      let mut scope = new Ast.Scope( parentScope, true, nil ## );

      param.typeId2Scope[ self.typeId ] = scope;
      let valTypeInfo = unwrap param.getTypeInfo( self.valTypeId );
      let mut enumTypeInfo = Ast.NormalTypeInfo.createEnum(
         scope, parentInfo, true, accessMode, self.txt, valTypeInfo );
      let newTypeInfo = enumTypeInfo;
      param.typeId2TypeInfo[ self.typeId ] = enumTypeInfo;

      fn getEnumLiteral( val:stem ) : Ast.EnumLiteral! {
         switch valTypeInfo {
            case Ast.builtinTypeInt {
               return Ast.EnumLiteral.Int( val@@int );
            }
            case Ast.builtinTypeReal {
               return Ast.EnumLiteral.Real( val@@real );
            }
            case Ast.builtinTypeString {
               return Ast.EnumLiteral.Str( val@@str );
            }
         }
         return nil;
      }
      foreach valData, valName in self.enumValList {
         let! val = getEnumLiteral( valData ) {
            return nil, "unknown enum val type -- %s" (valTypeInfo.getTxt(##));
         };
         enumTypeInfo.addEnumValInfo( new Ast.EnumValInfo( valName, val ) );
         scope.addEnumVal( valName, nil, enumTypeInfo );
      }
      parentScope.addEnum( accessMode, self.txt, nil, enumTypeInfo );
      return newTypeInfo, nil;
   }
}

class _TypeInfoAlgeVal extend (Mapping) {
   pub let name:str;
   pub let typeList:&List<int>;
}

class _TypeInfoAlge extend _TypeInfo {
   pub let txt:str;
   pub let accessMode:Ast.AccessMode;
   pub let algeValList: &List<&_TypeInfoAlgeVal>;

   pub override fn createTypeInfo( param:ImportParam ): &Ast.TypeInfo!, str!
   {
      let accessMode = unwrap Ast.AccessMode._from( self.accessMode );
      //let parentInfo = unwrap param.typeId2TypeInfo[ self.parentId ];
      let parentInfo = unwrap param.getTypeInfo( self.parentId );
      let mut name2AlgeValInfo:Map<str,Ast.AlgeValInfo> = {};
      let mut parentScope = unwrap Ast.getScope( parentInfo );
      let mut scope = new Ast.Scope( parentScope, true, nil ## );

      param.typeId2Scope[ self.typeId ] = scope;
      let mut algeTypeInfo = Ast.NormalTypeInfo.createAlge(
         scope, parentInfo, true, accessMode, self.txt );
      let newTypeInfo = algeTypeInfo;
      param.typeId2TypeInfo[ self.typeId ] = algeTypeInfo;
      foreach valInfo in self.algeValList {
         let mut typeInfoList:List<&Ast.TypeInfo> = [];
         foreach orgTypeId in valInfo.typeList {
            //typeInfoList.insert( unwrap param.typeId2TypeInfo[ orgTypeId ] );
            typeInfoList.insert( unwrap param.getTypeInfo( orgTypeId ) );
         }
         let algeVal = new Ast.AlgeValInfo( valInfo.name, typeInfoList );
         scope.addAlgeVal( valInfo.name, nil, algeTypeInfo );
         algeTypeInfo.addValInfo( algeVal );
      }
      parentScope.addAlge( accessMode, self.txt, nil, algeTypeInfo );
      return newTypeInfo, nil;
   }
}


macro _DefBuiltinFuncType( class2symMapList:List<Map<str,Map<str,Map<str,List<str>>>>> )
{
   {
      let mut defMemberList:List<stat> = [];
      let mut initMemberList:List<stat> = [];
      let mut declProcessList:List<stat> = [];
      let mut caseList:List<stat> = [];
      foreach class2symMap in class2symMapList {
         forsort symbolMap, genClassName in class2symMap {
            let className = genClassName.gsub( "<.*", "" );
            let mut subcaseList:List<stat> = [];
            
            forsort symbolInfo, funcName in symbolMap {
               let typeName = "%s_%s" ( className ~= "" and className.lower() or "lns",
                                        funcName );
               let symName = "%s_sym" (typeName);
               defMemberList.insert( `{
                  pub let mut ,,,typeName:&Ast.TypeInfo;
                  pub let mut ,,,symName:&Ast.SymbolInfo;
               } );
               initMemberList.insert( `{
                  self.,,,typeName = Ast.headTypeInfo;
                  self.,,,symName = Ast.dummySymbol;
               });
               subcaseList.insert( `{
                  case ,,funcName ~~{
                     builtinFunc. ,,,typeName = typeInfo;
                     builtinFunc. ,,,symName = symInfo;
                     builtinFunc.register( symInfo );
                  }
               });
            }
            if #subcaseList > 0 {
               declProcessList.insert( `{
                  fn ,,,"process_%s" (className) ~~ () {
                     switch fieldName {
                        ,,subcaseList
                     }
                  }
               });
               caseList.insert( `{
                  case ,,className {
                     ,,,"process_%s" (className) ~~ ();
                  }
               });
            }
         }
      }
   }
   /**
builtin 関数の TypeInfo を保持するクラス。
   */
   pub class BuiltinFuncType {
      ,,defMemberList;

      let mut allSymbol:List<&Ast.SymbolInfo> {pub};
      let mut allClass:List<&Ast.TypeInfo> {pub};

      pub fn __init() {
         ,,initMemberList;

         self.allSymbol = [];
         self.allClass = [];
      }

      pub fn register( symbolInfo:&Ast.SymbolInfo ) mut {
         self.allSymbol.insert( symbolInfo );
      }
      pub fn registerClass( classInfo:&Ast.TypeInfo ) mut {
         self.allClass.insert( classInfo );
      }
   }

   let mut builtinFunc = new BuiltinFuncType();

   pub fn getBuiltinFunc() : &BuiltinFuncType {
      return builtinFunc;
   }

   fn setupBuiltinTypeInfo( name:str, fieldName:str, symInfo:&Ast.SymbolInfo ) {
      let typeInfo = symInfo.$typeInfo;
      
      ,,declProcessList;

      switch name {
         ,,caseList
      }
   }

   fn getBuiltInInfo(): &List<&Map<str,&Map<str,&Map<str,&List<str>>>>> {
      return ,,class2symMapList;
   }
}

_DefBuiltinFuncType( [
   {
      "": {
         "type": { "arg": [ "&stem!" ], "ret": ["str"] },
         "error": { "arg": [ "str" ], "ret": [ "__" ] },
         "print": { "arg": [ "&..." ], "ret": [] },
         "tonumber": { "arg": [ "str", "int!" ], "ret": ["real!"] },
         "tostring": { "arg": [ "&stem" ], "ret": ["str"] },
         "load": { "arg": [ "str", "str!", "str!", "stem!" ], "ret": ["form!", "str!"] },
         "loadfile": { "arg": [ "str" ], "ret": ["form!", "str!"] },
         "require": { "arg": [ "str" ], "ret": ["stem!"] },
         "collectgarbage": { "arg": [ ], "ret": [] },
         "_fcall": { "arg": [ "form", "&..." ], "ret": [""] },
         "_load": { "arg": [ "str", "stem!" ], "ret": ["__loadedfunc!", "str!"] },
         "_kind": { "arg": [ "stem!" ], "ret":[ "int" ] },
      },
   },
   {
      "iStream": {
         "__attrib": { "type": [ "interface" ] },
         "read": { "type": [ "mut" ], "arg": [ "stem!" ], "ret": [ "str!" ] },
         "close": { "type": [ "mut" ], "arg": [], "ret": [] },
      },
   },
   {
      "oStream": {
         "__attrib": { "type": [ "interface" ] },
         "write": { "type": [ "mut" ], "arg": [ "str" ], "ret": [ "stem!", "str!"] },
         "close": { "type": [ "mut" ], "arg": [], "ret": [] },
         "flush": { "type": [ "mut" ], "arg": [], "ret": [] },
      },
   },
   {
      "luaStream": {
         "__attrib": { "inplements": [ "iStream", "oStream" ] },
         "read": { "type": [ "mut" ], "arg": [ "stem!" ], "ret": [ "str!" ] },
         "write": { "type": [ "mut" ], "arg": [ "str" ], "ret": [ "stem!", "str!" ] },
         "close": { "type": [ "mut" ], "arg": [], "ret": [] },
         "flush": { "type": [ "mut" ], "arg": [], "ret": [] },
         "seek": { "type": [ "mut" ], "arg": [ "str", "int"], "ret": [ "int!", "str!" ] },
      },
   },
   {
      "Mapping": {
         "__attrib": { "type": [ "interface" ] },
         "_toMap": { "type": [ "method" ], "arg": [], "ret": [ ] },
      },
   },
   {
      "io": {
         "__attrib": { "type": [ "module" ] },
         "stdin": { "type": [ "var" ], "typeInfo": [ "iStream" ] },
         "stdout": { "type": [ "var" ], "typeInfo": [ "oStream" ] },
         "stderr": { "type": [ "var" ], "typeInfo": [ "oStream" ] },
         "open": { "arg": [ "str", "str!" ], "ret": ["luaStream!"] },
         "popen": { "arg": [ "str" ], "ret": ["luaStream!"] },
      },
   },
   {
      "package": {
         "__attrib": { "type": [ "module" ] },
         "path": { "type": [ "var" ], "typeInfo": [ "str" ] },
         "searchpath": { "arg": [ "str", "str" ], "ret": ["str!"] },
      },
   },
   {

      "os": {
         "__attrib": { "type": [ "module" ] },
         "clock": { "arg": [], "ret": ["real"] },
         "exit": { "arg": [ "int!" ], "ret": [ "__" ] },
         "remove": {"arg": [ "str" ], "ret": [ "bool!", "str!"] },
         "date": {"arg": [ "str!", "stem!" ], "ret": [ "stem!"] },
         "time": {"arg": [ "stem!" ], "ret": [ "stem!"] },
         "difftime": {"arg": [ "stem", "stem" ], "ret": [ "int"] },
         "rename": {"arg": [ "str", "str" ], "ret": [ "stem!", "str!"] },
      },
   },
   {
      "string": {
         "__attrib": { "type": [ "module" ] },
         "find": { "arg": [ "str", "str", "int!", "bool!" ], "ret": ["int!", "int!"] },
         "byte": { "arg": [ "str", "int!", "int!" ], "ret": ["...<int>"] },
         "format": { "arg": [ "str", "..." ], "ret": ["str"] },
         "rep": { "arg": [ "str", "int" ], "ret": ["str"] },
         "gmatch": { "arg": [ "str", "str" ], "ret": ["Luaval<form>", "stem!", "stem!"] },
         "gsub": { "arg": [ "str", "str", "str" ], "ret": ["str", "int"] },
         "sub": { "arg": [ "str", "int", "int!" ], "ret": ["str"] },
         "dump": { "arg": [ "form", "bool!" ], "ret": ["str"] },
         "lower": { "arg": [ "str" ], "ret": ["str"] },
         "upper": { "arg": [ "str" ], "ret": ["str"] },
         "reverse": { "arg": [ "str" ], "ret": ["str"] },
      },
   },
   {
      "str": {
         "__attrib": { "inplements": [ "Mapping" ] },
         "find": { "type": [ "method" ], "arg": [ "str", "int!", "bool!" ], "ret": ["int!", "int!"] },
         "byte": { "type": [ "method" ], "arg": [ "int!","int!" ], "ret": ["...<int>"] },
         "format": { "type": [ "method" ], "arg": [ "&..." ], "ret": ["str"] },
         "rep": { "type": [ "method" ], "arg": [ "int" ], "ret": ["str"] },
         "gmatch": { "type": [ "method" ], "arg": [ "str" ], "ret": ["Luaval<form>", "stem!", "stem!"] },
         "gsub": { "type": [ "method" ], "arg": [ "str", "str" ], "ret": ["str", "int"] },
         "sub": { "type": [ "method" ], "arg": [ "int", "int!" ], "ret": ["str"] },
         "lower": { "type": [ "method" ], "arg": [ ], "ret": ["str"] },
         "upper": { "type": [ "method" ], "arg": [ ], "ret": ["str"] },
         "reverse": { "type": [ "method" ], "arg": [ ], "ret": ["str"] },
      },
   },
   {
      "List<T>": {
         "insert": { "type": [ "mut" ], "arg": [ "T" ], "ret": [""] },
         "remove": { "type": [ "mut" ], "arg": [ "int!" ], "ret": ["T!"] },
         "unpack": { "type": [ "method" ], "arg": [ ], "ret": ["..."] },
         "sort": { "type": [ "mut" ], "arg": [ "form!" ], "ret": [] },
      },
   },
   {
      "Array<T>": {
         "unpack": { "type": [ "method" ], "arg": [ ], "ret": ["..."] },
         "sort": { "type": [ "mut" ], "arg": [ "form!" ], "ret": [] },
      },
   },
   {
      "Set<T>": {
         "add": { "type": [ "mut" ], "arg": [ "T" ], "ret": [] },
         "del": { "type": [ "mut" ], "arg": [ "T" ], "ret": [] },
         "has": { "type": [ "method" ], "arg": [ "T" ], "ret": [ "bool" ] },
         "and": { "type": [ "mut" ], "arg": [ "&Set<T>" ], "ret": [ "Set<T>" ] },
         "or": { "type": [ "mut" ], "arg": [ "&Set<T>" ], "ret": [ "Set<T>" ] },
         "sub": { "type": [ "mut" ], "arg": [ "&Set<T>" ], "ret": [ "Set<T>" ] },
         "clone": { "type": [ "method" ], "arg": [], "ret": [ "Set<T>" ] },
         "len": { "type": [ "method" ], "arg": [], "ret": [ "int" ] },
      },
   },
   {
      "math": {
         "__attrib": { "type": [ "module" ] },
         "random": { "arg": [ "int!", "int!" ], "ret": ["real"] },
         "randomseed": { "arg": [ "int!" ], "ret": [] },
      }
   },
   {
      "debug": {
         "__attrib": { "type": [ "module" ] },
         "getinfo": { "arg": ["int"], "ret": ["Map<str,stem>!"] },
         "getlocal": { "arg": ["int", "int"], "ret": ["str!", "stem!"] },
      },
   },
   {
      "Nilable<_T>": {
         "val": { "type": [ "method" ], "arg": [ ], "ret": [ "_T!" ] },
      }
   }
] );
   
pub fn isStrFormFunc( typeInfo:&Ast.TypeInfo ):bool {
   if typeInfo.equals( builtinFunc.string_format ## ) {
      return true;
   }
   return false;
}


let mut readyBuiltin = false;

fn TransUnit.registBuiltInScope() mut {
   if readyBuiltin {
      return;
   }
   readyBuiltin = true;

   let builtInInfo = getBuiltInInfo();

   fn getTypeInfo( mut typeName:str ) : &Ast.TypeInfo {

      switch typeName {
         case "_T" {
            return Ast.builtinTypeBox.$boxingType;
         }
         case "_T!" {
            return Ast.builtinTypeBox.$boxingType.$nilableTypeInfo;
         }
      }

      fn getTypeInfoFromScope(
         scope:&Ast.Scope, symbol:str, genTypeList:List<&Ast.TypeInfo> ) :
         &Ast.TypeInfo!
      {
         let! typeInfo = scope.getTypeInfo( symbol, scope, false, self.scopeAccess ) {
            return nil;
         };
         let mut validGenType = false;
         foreach genType in genTypeList {
            if genType.$kind ~= .Alternate {
               validGenType = true;
               break;
            }
         }
         if validGenType {
            switch typeInfo.$kind {
               case .Map {
                  if #genTypeList ~= 2 {
                     Util.err( "illegal map param -- %d" (#genTypeList) );
                  }
                  let keyType = genTypeList[ 1 ];
                  let valType = genTypeList[ 2 ];
                  return Ast.NormalTypeInfo.createMap(
                     .Pub, typeInfo.$parentInfo, keyType, valType, typeInfo.$mutMode );
               }
               case .Ext {
                  if #genTypeList ~= 1 {
                     Util.err( "illegal map param -- %d" (#genTypeList) );
                  }
                  return Ast.NormalTypeInfo.createLuaval( genTypeList[ 1 ] );
               }
               case .DDD {
                  if #genTypeList ~= 1 {
                     Util.err( "illegal map param -- %d" (#genTypeList) );
                  }
                  return Ast.NormalTypeInfo.createDDD( genTypeList[ 1 ], true );
               }
               default {
                  Util.err( "not support type -- %s" (typeInfo.getTxt(##)) );
               }
            }
         }

         
         return typeInfo;
      }

      let mut mutable = true;
      if typeName.find( "^&" ## ) {
         mutable = false;
         typeName = typeName.gsub( "^&", "" );
      }
      let mut genTypeList:List<&Ast.TypeInfo> = [];
      let index, endIndex = typeName.find( "[%w%.]+<" ## );
      let mut suffix = "";
      when! index, endIndex {
         let mut genTypeName = typeName.sub( endIndex + 1## );
         while true {
            if! let tailIndex = genTypeName.find( "[,>]" ## ) {
               let genType = getTypeInfo( genTypeName.sub( 1, tailIndex - 1 ) );
               genTypeList.insert( genType );
               genTypeName = genTypeName.sub( tailIndex + 1## );
            }
            else {
               suffix = genTypeName.sub( 1## );
               break;
            }
         }
         typeName = typeName.sub( 1, endIndex - 1 ) .. suffix;
      }


      let mut typeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
      if typeName.find( "!$" ## ) {
         let orgTypeName = typeName.gsub( "!$", "" );
         if! getTypeInfoFromScope( self.scope, orgTypeName, genTypeList ) {
            typeInfo = _exp;
         }
         else {
            Util.err( "not found builtin -- %s" (orgTypeName) );
         }
         typeInfo = typeInfo.$nilableTypeInfo;
      }
      else {
         if! getTypeInfoFromScope( self.scope, typeName, genTypeList ) {
            typeInfo = _exp;
         }
         else {
            Util.err( "not found builtin -- %s" (typeName) );
         }
      }
      if mutable {
         return typeInfo;
      }
      typeInfo = self.createModifier( typeInfo, .IMut );
      return typeInfo;
   }

   fn processField( name:str, fieldName:str, info:&Map<str,&List<str>>,
                    parentInfo:&Ast.TypeInfo )
   {
      if self.targetLuaVer.isSupport( "%s.%s" (name, fieldName) ) {
         if info.type$[1] == "var" {
            let symbol = unwrap self.scope.add(
               .Var, false, true, fieldName, nil,
               getTypeInfo( unwrap info.typeInfo$[1] ), .Pub,
               true, .Mut, true );
            builtinFunc.register( symbol );
         }
         else {
            let mut argTypeList: List<&Ast.TypeInfo> = [];
            foreach argType in unwrap info[ "arg" ] {
               argTypeList.insert( getTypeInfo( argType ) );
            }

            let mut retTypeList: List<&Ast.TypeInfo> = [];
            foreach retType in unwrap info[ "ret" ] {
               let retTypeInfo = getTypeInfo( retType );
               retTypeList.insert( retTypeInfo );
            }

            let funcType = info.type$[1];
            let mutable = funcType == "mut";

            let staticFlag;
            let kind:Ast.TypeInfoKind;
            let symbolKind:Ast.SymbolKind;
            switch funcType {
               case "method", "mut" {
                  staticFlag = false;
                  kind = .Method;
                  symbolKind = .Mtd;
               }
               case "macro" {
                  staticFlag = true;
                  kind = .Macro;
                  symbolKind = .Mac;
               }
               default {
                  staticFlag = true;
                  kind = .Func;
                  symbolKind = .Fun;
               }
            }
            
            self.pushScope( false ## );

            let typeInfo = Ast.NormalTypeInfo.createFunc(
               false, true, self.scope, kind,
               parentInfo, false, true, staticFlag, .Pub,
               fieldName, nil, argTypeList, retTypeList, mutable );

            self.popScope();

            Ast.builtInTypeIdSet[ typeInfo.get_typeId() ] = typeInfo;
            if typeInfo.$nilableTypeInfo ~= Ast.headTypeInfo {
               Ast.builtInTypeIdSet[ typeInfo.$nilableTypeInfo.$typeId ] = typeInfo.$nilableTypeInfo;
            }
            let symInfo = unwrap self.scope.add(
               symbolKind, false, kind == .Func,
               fieldName, nil, typeInfo, .Pub, staticFlag,
               mutable and Ast.MutMode.Mut or Ast.MutMode.IMut, true );

            setupBuiltinTypeInfo( name, fieldName, symInfo );
         }
      }
   }

   self.scope = Ast.rootScope;

   let mut builtinModuleName2Scope:Map<str,Ast.Scope> = {};

   let mapType = Ast.NormalTypeInfo.createMap(
      .Pub, Ast.headTypeInfo, Ast.builtinTypeString, Ast.builtinTypeStem, .Mut );
   self.scope.addVar( .Global, "_ENV", nil, mapType, .IMutRe, true );
   self.scope.addVar( .Global, "_G", nil, mapType, .IMutRe, true );
   self.scope.addVar( .Global, "__mod__", nil, Ast.builtinTypeString, .IMut, true );
   self.scope.addVar( .Global, "__line__", nil, Ast.builtinTypeInt, .IMut, true );
   //self.scope.addVar( .Global, "__func__", nil, Ast.builtinTypeString, false, true );

   fn processCopyAlterList( alterList:List<&Ast.AlternateTypeInfo>,
                            typeList:&List<&Ast.TypeInfo> )
   {
      foreach typeInfo in typeList {
         alterList.insert( unwrap typeInfo@@@Ast.AlternateTypeInfo );
      }
   }
   
   foreach builtinClassInfo in builtInInfo {
      foreach name2FieldInfo, className in builtinClassInfo {
         let mut name = className;
         let mut genTypeList:List<&Ast.AlternateTypeInfo> = [];

         switch className {
            case "List<T>" {
               name = "List";
               processCopyAlterList(
                  genTypeList, Ast.builtinTypeList.$itemTypeInfoList );
            }
            case "Array<T>" {
               name = "Array";
               processCopyAlterList(
                  genTypeList, Ast.builtinTypeArray.$itemTypeInfoList );
            }
            case "Set<T>" {
               name = "Set";
               processCopyAlterList(
                  genTypeList, Ast.builtinTypeSet.$itemTypeInfoList );
            }
            case "Nilable<_T>" {
               name = "Nilable";
               processCopyAlterList(
                  genTypeList, Ast.builtinTypeBox.$itemTypeInfoList );
            }
            default {
               if className.find( "<" ## ) {
                  name = "";
                  apply token of className.gmatch( "[^<>,%s]+" ) {
                     if #name == 0 {
                        name = token;
                     }
                     else {
                        genTypeList.insert(
                           Ast.NormalTypeInfo.createAlternate(
                              true, #genTypeList + 1,
                              token, .Pri, self.moduleType ## ) );
                     }
                  }
               }
            }
         }
         let mut parentInfo:&Ast.TypeInfo = Ast.headTypeInfo;
         if name ~= "" {
            let mut classKind = DeclClassMode.Class;
            if! let types = name2FieldInfo.__attrib$.type {
               if #types > 0 {
                  switch types[ 1 ] {
                     case "interface" {
                        classKind = .Interface;
                     }
                     case "module" {
                        classKind = .Module;
                     }
                  }
               }
            }
            let mut interfaceList:List<&Ast.TypeInfo> = [];
            if! name2FieldInfo.__attrib$.inplements {
               foreach ifname in _exp {
                  let ifType = getTypeInfo( ifname );
                  interfaceList.insert( ifType );
               }
            }
            switch classKind {
               case .Class, .Interface {
                  parentInfo = self.pushClass(
                     self.parser.$currentToken.pos,
                     classKind == .Class, false, nil, interfaceList,
                     genTypeList, true, name, true, .Pub ## );
                  builtinFunc.registerClass( parentInfo );
               }
               case .Module {
                  parentInfo = self.pushModule( true, name, true );

                  let moduleSymbolInfo = self.scope.$parent.add(
                     .Typ , false, false, name, nil,
                     parentInfo, .Local, true, Ast.MutMode.Mut, true );
               }
            }

            Ast.builtInTypeIdSet[ parentInfo.get_typeId() ] = parentInfo;
            Ast.builtInTypeIdSet[ parentInfo.$nilableTypeInfo.$typeId ] =
               parentInfo.$nilableTypeInfo;
         }
         if not builtinModuleName2Scope[ name ]
         {
            if name ~= "" and getTypeInfo( name ) {
               builtinModuleName2Scope[ name ] = self.scope;
            }

            // typeid が一定になるようにソートする
            forsort info, fieldName in name2FieldInfo {
               switch fieldName {
                  case "__attrib" {
                  }
                  default {
                     processField( name, fieldName, info, parentInfo );
                  }
               }
            }
         }
         if name ~= "" {
            self.popClass();
         }
      }
   }


   self.scope = self.topScope;
}

pub fn TransUnit.error( mess: str ) mut : __ {
   self.addErrMess( self.parser.getLastPos(), mess);
   // Util.err( "%s:%d:%d: error:(%s) %s"
   //           ( self.parser.getStreamName(),
   //             pospos.lineNo, pos.column, txt, mess ) );

   foreach mess in self.errMessList {
      Util.errorLog( mess );
   }
   foreach mess in self.warnMessList {
      Util.errorLog( mess );
   }
   if self.macroCtrl.$macroMode ~= .None {
      print( "------ near code -----", self.macroCtrl.$macroMode.$_txt );
      print( self.parser.getNearCode() );
      print( "------" );
   }
   
   Util.err( "has error" );
}

fn TransUnit.createNoneNode( pos: &Parser.Position ) mut : Nodes.Node {
   //return self.createNode( nodeKindNone, pos, [ builtinTypeNone ], {} );
   return Nodes.NoneNode.create(
      self.nodeManager, pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ] );
}

pub fn TransUnit.pushbackToken( token: &Parser.Token ) mut {
   // if token.kind ~= .Eof {
   //    self.pushbackList.insert( token );
   // }
   // if token == self.currentToken {
   //    if #self.usedTokenList > 0 {
   //       self.currentToken = self.usedTokenList[ #self.usedTokenList ];
   //       self.usedTokenList.remove(##);
   //    }
   //    else {
   //       self.currentToken = Parser.getEofToken();
   //    }
   // }
   self.parser.pushbackToken( token );
}


fn TransUnit.newPushback( tokenList: List<&Parser.Token> ) mut {
   // for index = #tokenList, 1, -1  {
   //    self.pushbackList.insert( tokenList[ index ] );
   // }
   // self.currentToken = self.usedTokenList[ #self.usedTokenList ];
   // self.usedTokenList.remove(##);
   self.parser.newPushback( tokenList );
}

pub fn TransUnit.getStreamName(): str {
   return self.parser.getStreamName();
}

fn TransUnit.getTokenNoErr() mut : &Parser.Token
{
   let mut token;
   
   // if #self.pushbackList > 0 {
   //    // pushbackList にトークンがある場合は、 pushbackList から取り出す
   //    if self.currentToken ~= Parser.getEofToken() {
   //       self.usedTokenList.insert( self.currentToken );
   //    }
   //    token = self.pushbackList[ #self.pushbackList ];
   //    self.pushbackList.remove(##);

   //    if self.macroCtrl.$macroMode == .Expand {
   //       token = self.macroCtrl.expandMacroVal(
   //          self.typeNameCtrl, self.scope, self, token );
   //    }
   // }
   // else {
      // pushbackList にトークンがない場合は、パーサーから取得する
      let mut commentList:List<&Parser.Token> = [];
      let mut workToken = self.parser.getTokenNoErr();
      while workToken.kind == Parser.TokenKind.Cmnt {
         commentList.insert( workToken );
         workToken = self.parser.getTokenNoErr();
      }
      if workToken.$kind ~= .Eof {
         token = workToken;
         if self.macroCtrl.$macroMode ~= .None {
            token = self.macroCtrl.expandMacroVal(
               self.typeNameCtrl, self.scope, self, token );
         }
      }
      else {
         token = Parser.getEofToken();
         self.commentCtrl.addDirect( commentList );
      }
   // }

   if #token.$commentList > 0 {
      self.commentCtrl.add( token );
   }

   return token;
}



fn TransUnit.getToken( allowEof:bool! ) mut : &Parser.Token {
   let token = self.getTokenNoErr();
   if token == Parser.getEofToken() {
      if allowEof {
         return Parser.getEofToken();
      }
      self.error( "EOF" );
   };

   // if self.macroMode == "expand"  {
   //     Util.errorLog( "getToken %s" (token.txt) );
   // }

   return token;
}

fn TransUnit.pushback() mut {
   // if self.currentToken ~= Parser.getEofToken() {
   //    self.pushbackList.insert( self.currentToken );
   //    self.currentToken = self.usedTokenList[ #self.usedTokenList ];
   //    self.usedTokenList.remove(##);
   // }
   //self.pushbackToken( self.currentToken );
   self.parser.pushback();
}

fn TransUnit.pushbackStr( name: str, statement: str ) mut {
   // let mut memStream = new Parser.TxtStream( statement );
   // let mut parser = new Parser.StreamParser( memStream, name, false );

   // let mut list:List<&Parser.Token> = [];
   // while true {
   //    if! parser.getToken() {
   //       list.insert( _exp );
   //    }
   //    else {
   //       break;
   //    }
   // }
   // for index = #list, 1, -1  {
   //    self.pushbackToken( list[ index ] );
   // }
   self.parser.pushbackStr( name, statement );
}

enum SymbolMode {
   /** _ で始まるシンボル */
   Must_,
   /** _ で始まってはいけないシンボル */
   MustNot_,
}

let specialSymbolMap = {
   "__init":true,
   "__free":true,
   "__":true,
   "_exp":true,
};

/** ユーザ定義のシンボルとして許可しないキーワード */
let builtinKeywordSet = (@ "self", "super" );

fn TransUnit.checkSymbol( token: &Parser.Token, mode:SymbolMode ) mut : &Parser.Token {
   if token.kind ~= Parser.TokenKind.Symb and
      token.kind ~= Parser.TokenKind.Kywd and
      token.kind ~= Parser.TokenKind.Type
   {
      self.addErrMess( token.pos, "illegal symbol -- '%s'" ( token.txt) );
   }
   let frontChar = token.txt[1];
   if mode == .Must_ and frontChar ~= ?_ {
      self.addErrMess(
         token.pos, "macro name must begin with '_' -- '%s'" ( token.txt ) );
   }
   elseif mode == .MustNot_ and frontChar == ?_ {
      if not self.ignoreToCheckSymbol_ {
         if not specialSymbolMap[ token.txt ] {
            self.addErrMess(
               token.pos, "symbol must not begin with '_' -- '%s'" ( token.txt ) );
         }
      }
   }
   elseif builtinKeywordSet.has( token.txt ) {
      self.addErrMess(
         token.pos, "this symbol is special keyword -- %s" (token.txt) );
   }
   return token;
}

fn TransUnit.getSymbolToken(mode:SymbolMode) mut : &Parser.Token {
   return self.checkSymbol( self.getToken(##), mode );
}


fn TransUnit.checkToken( token: &Parser.Token, txt: str ) mut : &Parser.Token {
   if token.txt ~= txt {
      self.error( "not found -- %s. expects %s" ( txt, token.txt ) );
   }
   return token;
}

fn TransUnit.checkNextToken( txt: str ) mut : &Parser.Token {
   return self.checkToken( self.getToken(##), txt );
}

/**
次のトークンが、スペースの空きがなく、連続したトークンであるか確認する。

@return &Parser.Token 次のトークン
@return bool 連続したトークンだった場合 true
*/
fn TransUnit.getContinueToken() mut : &Parser.Token, bool {
   let token = self.getToken(##);
   return token, token.consecutive;

   // let! prevToken = self.currentToken {
   //    return self.getToken(), false;
   // };
   // let token = self.getToken();

   // if prevToken.pos.lineNo ~= token.pos.lineNo or
   //    prevToken.pos.column + #prevToken.txt ~= token.pos.column
   // {
   //    return token, false;
   // }

   // return token, true;
}


fn TransUnit.analyzeStatementList(
   stmtList: List<&Nodes.Node>, termTxt: str! ) mut : &Nodes.Node!, int
{
   let mut breakKind = Nodes.BreakKind.None;
   if #stmtList > 0 {
      breakKind = stmtList[ #stmtList ].getBreakKind( .Normal );
   }

   let mut lastStatement:&Nodes.Node! = nil;
   let mut lastLineNo = self.parser.getLastPos().lineNo;

   // コメントが、直前の文の末尾と同じ行にあるかどうか調べ、
   // 同じ行にある場合は、直前の文のコメントとしてセットする
   fn setTailComment( statement:Nodes.Node! ): int {
      let blank;
      let mut commentList = self.commentCtrl.$commentList;
      if #commentList > 0 {
         when! lastStatement {
            let mut tailComment:&Parser.Token! = nil;
            foreach comment in commentList {
               if comment.pos.lineNo == lastStatement.$pos.lineNo {
                  if not tailComment {
                     lastStatement.set_tailComment( comment );
                     tailComment = comment;
                  }
                  else {
                     // 1行に複数のコメントがあるのはエラー
                     // self.addErrMess(
                     //    comment.pos,
                     //    "there are multi comment per line. -- %s" (comment.txt) );
                  }
               }
               if! let invalidComment = self.commentCtrl.hasInvalidComment() {
                  // 1行に複数のコメントがあるのはエラー
                  // self.addErrMess(
                  //    invalidComment.pos,
                  //    "there are multi comment per line. -- %s" (invalidComment.txt) );
               }
            }
            if tailComment {
               commentList.remove( 1 );
            }
         }
      }
      if #commentList > 0 {
         blank = commentList[ 1 ].pos.lineNo - lastLineNo;
      }
      else {
         when! statement {
            blank = statement.$pos.lineNo - lastLineNo;
         }
         else {
            blank = self.parser.getLastPos().lineNo - lastLineNo;
         }
      }
      return blank;
   }
   
   while true {
      let mut statement = self.analyzeStatement( termTxt );
      when! statement {
         if breakKind ~= .None {
            self.addErrMess( statement.$pos,
                             "This statement is not reached -- %s" (breakKind.$_txt) );
         }

         // 空白行と、コメントの処理
         let blank = setTailComment( statement );
         if blank > 1 {
            stmtList.insert(
               Nodes.BlankLineNode.create(
                  self.nodeManager, new Parser.Position( lastLineNo + 1, 0 ),
                  self.macroCtrl.isInAnalyzeArgMode(),
                  [ Ast.builtinTypeNone ], blank - 1 ) );
         }
         lastLineNo = self.parser.getLastPos().lineNo;

         stmtList.insert( statement );
         lastStatement = statement;
         breakKind = statement.getBreakKind( .Normal );
         
         statement.addComment( self.commentCtrl.$commentList );
         self.commentCtrl.clear();
      }
      else {
         setTailComment( nil );
         break;   
      }
   }
   return lastStatement, lastLineNo;
}

fn TransUnit.analyzeStatementListSubfile( stmtList: List<&Nodes.Node> ) mut : &Nodes.Node! {
   let statement = self.analyzeStatement(##);

   if! statement {
      if _exp.$kind ~= Nodes.NodeKind.$Subfile {
         self.error( "subfile must have 'subfile' declaration at top." );
      }
   }
   else {
      self.error( "subfile must have 'subfile' declaration at top." );
   }

   return (self.analyzeStatementList( stmtList ## ));
}

fn TransUnit.analyzeLuneControl(
   firstToken: &Parser.Token ) mut : Nodes.LuneControlNode!
{
   let mut node:Nodes.LuneControlNode! = nil;
   let nextToken = self.getToken(##);

   let pragma;
   switch ( nextToken.txt ) {
      case "disable_mut_control" {
         self.validMutControl = false;
         pragma = LuneControl.Pragma.disable_mut_control;
      }
      case "ignore_symbol_" {
         self.ignoreToCheckSymbol_ = true;
         pragma = LuneControl.Pragma.ignore_symbol_;
      }
      case "load__lune_module" {
         pragma = LuneControl.Pragma.load__lune_module;
      }
      case "can_not_conv_code" {
         let mut codeSet:Set<LuneControl.Code> = (@);
         while true {
            let token = self.getToken(##);
            if token.txt == ";" {
               self.pushback();
               break;
            }
            if! let code = LuneControl.Code._from( token.txt ) {
               codeSet.add( code );
            }
            else {
               self.addErrMess( token.pos, "illegal code -- '%s'" (token.txt ) );
            }
         }
         pragma = LuneControl.Pragma.can_not_conv_code( codeSet );
      }
      default {
         self.addErrMess( nextToken.pos, "unknown option -- %s" (nextToken.txt) );
         self.checkNextToken( ";" );
         return nil;
      }
   }

   node = Nodes.LuneControlNode.create(
      self.nodeManager, firstToken.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], pragma );
   self.helperInfo.pragmaSet.add( pragma );

   self.checkNextToken( ";" );
   return node;
}

enum TentativeMode {
   /** 関数定義の本体ブロックなど、独立したブロックの最外ブロックに使用する */
   Ignore,
   /** for 文などのループ処理のブロックで使用する */
   Loop,
   /** 単純なブロック文など、一つのブロックで完結する場合に使用する */
   Simple,
   /** if else などの複数ブロックの、if など先頭のブロックで使用する */
   Start,
   /** if elseif else などの複数ブロックの、elseif などの途中のブロックで使用する */
   Merge,
   /** if else などの複数ブロックの、 else などの最後のブロックで使用する */
   Finish,
}

fn TransUnit.analyzeBlock(
   blockKind: Nodes.BlockKind,
   tentativeMode:TentativeMode, scope: Ast.Scope! ) mut : Nodes.BlockNode
{
   let token = self.checkNextToken( "{" );

   if not scope {
      self.pushScope( false ## );
   }
   let blockScope = self.scope;

   switch tentativeMode {
      case .Simple, .Start, .Ignore, .Loop {
         self.prepareTentativeSymbol( self.scope, tentativeMode == .Loop );
      }
      case .Merge, .Finish {
         self.mergeTentativeSymbol( self.scope );
      }
   }

   let mut loopFlag = false;
   switch blockKind {
      case .For, .Apply, .While, .Repeat, .Foreach {
         loopFlag = true;
         self.loopScopeQueue.insert( self.scope );
      }
   }

   let mut stmtList:List<&Nodes.Node> = [];
   self.analyzeStatementList( stmtList, "}" );

   self.checkNextToken( "}" );

   if loopFlag {
      self.loopScopeQueue.remove(##);
   }

   if not scope {
      self.popScope();
   }

   // let node = self.createNode( nodeKindBlock, token.pos, [ builtinTypeNone ],
   //                          { "kind": blockKind, "stmtList": stmtList } );
   let mut node = Nodes.BlockNode.create(
      self.nodeManager, token.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      blockKind, blockScope, stmtList );

   if node.getBreakKind( .Normal ) ~= .None {
      self.tentativeSymbol.skip();
   }

   switch tentativeMode {
      case .Simple, .Finish {
         self.finishTentativeSymbol( true );
      }
      case .Ignore, .Loop {
         self.finishTentativeSymbol( false );
      }
   }

   return node;
}

fn TransUnit.analyzeTest( firstToken:&Parser.Token ) mut : Nodes.TestBlockNode
{
   let nameToken = self.getSymbolToken( .MustNot_ );

   self.scopeAccess = .Full;

   let block = self.analyzeBlock( .Test, .Ignore## );

   self.scopeAccess = .Normal;
   
   return Nodes.TestBlockNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], nameToken, block );
}


/**
modulePath で指定されたモジュールからメタ情報を読み込み、型情報を反映する。

@param modulePath モジュール名。 例: 'hoge.foo.bar'
@return 読み込んだメタ情報
@return メタ情報内の typeId -> TypeInfo の Map
@return インポート後の typeId -> メタ情報内の typeId の Map
*/
class DependModuleInfo {
   let id:int;
   let metaTypeId2TypeInfoMap:Map<int,&Ast.TypeInfo>;

   pub fn getTypeInfo( metaTypeId:int ):&Ast.TypeInfo {
      return unwrap self.metaTypeId2TypeInfoMap[ metaTypeId ];
   }
}


fn TransUnit.processImport( modulePath:str ) mut :
   &Meta._MetaInfo, &Map<int,&Ast.TypeInfo>, &Nodes.ModuleInfo
{
   Log._log( .Info, `{ return "%s -> %s start"
                       ( self.moduleType.getTxt( self.typeNameCtrl## ), modulePath); } );

   if not self.importModuleInfo.add( modulePath ) {
      self.error( "recursive import: %s -> %s"
                  ( self.importModuleInfo.getFull(), modulePath ) );
   }


   if! let moduleInfo = self.importModuleName2ModuleInfo[ modulePath ] {
      if! let metaInfoStem = frontInterface.loadMeta( self.importModuleInfo, modulePath )
      {
         Log._log( .Info, `{ return "%s already" (modulePath); } );

         let metaInfo = metaInfoStem@@=Meta._MetaInfo;
         let typeId2TypeInfo = moduleInfo.$importId2localTypeInfoMap;
         let moduleTypeInfo = unwrap typeId2TypeInfo[ metaInfo.__moduleTypeId ];
         self.importModuleInfo.remove();
         return metaInfo, typeId2TypeInfo, moduleInfo;
      }
      self.error( "failed to load meta -- " .. modulePath );
   }

   let mut nameList:str[] = [];
   apply txt of string.gmatch( modulePath, '[^%.]+' ) {
      nameList.insert( txt );
   }

   let! metaInfoStem = frontInterface.loadMeta( self.importModuleInfo, modulePath ) {
      self.error( "failed to load meta -- " .. modulePath );
   };
   let metaInfo = metaInfoStem@@=Meta._MetaInfo;
   Log._log( .Info, `{ return "%s processing" (modulePath); } );


   // 依存するモジュールのメタ情報を読み込み
   let mut dependLibId2DependInfo:Map<int,DependModuleInfo> = {};
   forsort dependInfo, dependName in metaInfo.__dependModuleMap {
      if dependInfo.use {
         let workModuleInfo, metaTypeId2TypeInfoMap =
            self.processImport( dependName );
         let typeId = (unwrap dependInfo.typeId)@@int;
         dependLibId2DependInfo[ typeId ] =
            new DependModuleInfo( typeId, metaTypeId2TypeInfoMap );
      }
   }

   // 型情報の登録

   // meta情報内の typeId -> typeInfo
   let mut typeId2TypeInfo: Map<int,&Ast.TypeInfo> = {};
   typeId2TypeInfo[ Ast.rootTypeId ] = Ast.headTypeInfo;
   let mut typeId2Scope: Map<int,Ast.Scope> = {};
   typeId2Scope[ Ast.rootTypeId ] = self.scope;


   // 依存するモジュールの typeInfo と、 meta 情報内の typeId との紐付け
   foreach dependIdInfo, typeId in metaInfo.__dependIdMap {
      let dependInfo = unwrap dependLibId2DependInfo[ dependIdInfo[ 1 ] ];
      let typeInfo = dependInfo.getTypeInfo( dependIdInfo[ 2 ] );
      typeId2TypeInfo[ typeId ] = typeInfo;
      if! Ast.getScope( typeInfo ) {
         typeId2Scope[ typeId ] = _exp;
      }
   }

   let mut moduleTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   foreach moduleName, index in nameList {
      let mut mutable = false;
      if index == #nameList {
         mutable = metaInfo.__moduleMutable;
      }
      moduleTypeInfo = self.pushModule( true, moduleName, mutable );
   }
   foreach moduleName in nameList {
      self.popModule();
   }

   //self.moduleName2Info[ modulePath ] = metaInfo;

   foreach symbolInfo in Ast.sym2builtInTypeMap {
      typeId2TypeInfo[ symbolInfo.$typeInfo.get_typeId() ] = symbolInfo.$typeInfo;
   }
   foreach builtinTypeInfo in Ast.builtInTypeIdSet {
      typeId2TypeInfo[ builtinTypeInfo.$typeId ] = builtinTypeInfo;
   }


   let mut newId2OldIdMap: Map<&Ast.TypeInfo,int> = {};

   let mut _typeInfoList:List<_TypeInfo> = [];
   let mut id2atomMap:Map<int,_TypeInfo> = {};
   let mut _typeInfoNormalList:List<_TypeInfoNormal> = [];
   foreach atomInfo in metaInfo.__typeInfoList {
      if! let skind = atomInfo.skind {
         let mut actInfo:_TypeInfo! = nil;
         let mut mess:str! = nil;
         let kind = unwrap Ast.SerializeKind._from( skind@@int );
         switch kind {
            case .Enum {
               actInfo = _TypeInfoEnum._fromMap( atomInfo );
            }
            case .Alge {
               actInfo = _TypeInfoAlge._fromMap( atomInfo );
               self.helperInfo.useAlge = true;
            }
            case .Module {
               actInfo = _TypeInfoModule._fromMap( atomInfo );
            }
            case .Normal {
               if! _TypeInfoNormal._fromMap( atomInfo ) {
                  _typeInfoNormalList.insert( _exp );
                  actInfo = _exp;
               }
            }
            case .Nilable {
               actInfo = _TypeInfoNilable._fromMap( atomInfo );
            }
            case .Alias {
               actInfo = _TypeInfoAlias._fromMap( atomInfo );
            }
            case .DDD {
               actInfo, mess = _TypeInfoDDD._fromMap( atomInfo );
            }
            case .Alternate {
               actInfo, mess = _TypeInfoAlternate._fromMap( atomInfo );
            }
            case .Generic {
               actInfo, mess = _TypeInfoGeneric._fromMap( atomInfo );
            }
            case .Modifier {
               actInfo = _TypeInfoModifier._fromMap( atomInfo );
            }
            case .Box {
               actInfo = _TypeInfoBox._fromMap( atomInfo );
            }
            default {
               Util.err( "unknown skind -- %d" (skind@@int) );
            }
         }
         when! actInfo {
            _typeInfoList.insert( actInfo );
            id2atomMap[ actInfo.typeId ] = actInfo;
         }
         else {
            foreach val, key in atomInfo {
               Util.errorLog( "table: %s:%s" (key,val) );
            }
            when! mess {
               Util.errorLog( mess );
            }
            Util.err( "_TypeInfo.%s._fromMap error" (kind.$_txt) );
         }
      }
   }


   let mut orgId2MacroTypeInfo:Map<int,&Ast.TypeInfo> = {};

   // 初めに child 以外で TypeInfo を登録
   let mut importParam = new ImportParam(
      self.parser.getLastPos(), self, typeId2Scope, typeId2TypeInfo,
      metaInfo, self.scope, moduleTypeInfo, self.scopeAccess, id2atomMap );
   foreach atomInfo in _typeInfoList {
      let newTypeInfo, errMess = atomInfo.createTypeInfo( importParam );
      if! errMess {
         Util.err( "%s: %s" ( modulePath, _exp ) );
      }
      when! newTypeInfo {
         if newTypeInfo.$kind == .Macro {
            orgId2MacroTypeInfo[ atomInfo.typeId ] = newTypeInfo;
         }
         if newTypeInfo.$kind == .Set {
            self.helperInfo.useSet = true;
         }
         if newTypeInfo.$accessMode == .Global {
            switch newTypeInfo.$kind {
               case .IF, .Class {
                  self.globalScope.addClass( newTypeInfo.$rawTxt, nil, newTypeInfo );
               }
               case .Func {
                  self.globalScope.addFunc(
                     nil, newTypeInfo, .Global, newTypeInfo.$staticFlag,
                     Ast.TypeInfo.isMut( newTypeInfo) );
               }
               case .Enum {
                  self.globalScope.addEnum(
                     .Global, newTypeInfo.$rawTxt, nil, newTypeInfo );
               }
               case .Nilable {
                  ; // nop
               }
               default {
                  Util.err( "%s: not support kind -- %s"
                            (__func__, newTypeInfo.$kind.$_txt) );
               }
            }
         }
      }
   }

   // 次に child を登録
   foreach atomInfo in _typeInfoNormalList {
      if #atomInfo.children > 0 {
         let mut scope = unwrap typeId2Scope[ atomInfo.typeId ];
         foreach childId in atomInfo.children {
            let! typeInfo = typeId2TypeInfo[ childId ] {
               Util.err( "not found childId -- %s, %d, %s(%d)"
                         (modulePath, childId, atomInfo.txt, atomInfo.typeId ) );
            };
            let mut symbolKind = Ast.SymbolKind.Typ;
            let mut addFlag = true;
            switch typeInfo.$kind {
               case .Func {
                  symbolKind = .Fun;
               }
               case .Form, .FormFunc {
                  symbolKind = .Typ;
               }
               case .Method {
                  symbolKind = .Mtd;
               }
               case .Class, .Module
               {
                  symbolKind = .Typ;
               }
               case .Enum {
                  addFlag = false;
               }
            }

            if addFlag {
               scope.add(
                  symbolKind, false,
                  typeInfo.$kind == .Func,
                  typeInfo.getTxt(##), nil, typeInfo, typeInfo.$accessMode,
                  typeInfo.$staticFlag, typeInfo.$mutMode, true );
            }
         }
      }
   }

   // インポート後の TypeId と インポート前の TypeId の紐付け
   foreach typeInfo, typeId in typeId2TypeInfo {
      newId2OldIdMap[ typeInfo ] = typeId;
   }

   // メンバーの登録
   fn registMember( classTypeId: int ) {
      if metaInfo.__dependIdMap[ classTypeId ] {
         return;
      }
      let mut classTypeInfo = unwrap typeId2TypeInfo[ classTypeId ];

      let mut backupScope = self.scope;
      
      switch ( classTypeInfo.$kind ) {
         case .Class {
            // self.pushClass( self.currentToken.pos, true, classTypeInfo.$abstractFlag,
            //                 nil, nil, nil, true, classTypeInfo.getTxt(##), .Pub ## );
            self.pushClassScope( self.parser.getLastPos(), classTypeInfo );
            
            if! metaInfo.__typeId2ClassInfoMap[ classTypeId ] {
               let classInfo = _exp;
               foreach fieldInfo, fieldName in classInfo@@Map<str,Map<str,stem>> {
                  if! let typeId = fieldInfo.typeId {
                     let fieldTypeInfo = unwrap typeId2TypeInfo[ typeId@@int ];
                     let symbolInfo = self.scope.addMember(
                        fieldName, nil, fieldTypeInfo,
                        unwrap Ast.AccessMode._from( (unwrap fieldInfo.accessMode)@@int ),
                        fieldInfo.staticFlag and true or false,
                        unwrap Ast.MutMode._from( (unwrap fieldInfo.mutMode)@@int ) );
                  }
                  else {
                     self.error( "not found fieldInfo.typeId" );
                  }
               }
            }
            else {
               self.error( "not found class -- %s: %d, %s"
                           (modulePath, classTypeId, classTypeInfo.getTxt(##)) );
            }
         }
         case .Module {
            self.pushModule( true, classTypeInfo.getTxt(##),
                             Ast.TypeInfo.isMut( classTypeInfo ) );
         }
      }

      foreach child in classTypeInfo.get_children() {
         if child.get_kind() == .Class or
            child.get_kind() == .Module or
            child.get_kind() == .IF
         {
            let oldId = newId2OldIdMap[ child ];
            if oldId {
               registMember( unwrap oldId );
            }
         }
      }

      if classTypeInfo.$kind == .Class {
         self.popClass();
      }
      elseif classTypeInfo.$kind == .Module {
         self.popModule();
      }
   }
   foreach atomInfo in _typeInfoList {
      if atomInfo.parentId == Ast.rootTypeId and
         ( atomInfo.skind == .Normal or atomInfo.skind == .Module )
      {
         registMember( atomInfo.typeId );
      }
   }


   foreach moduleName, index in nameList {
      let mut mutable = false;
      if index == #nameList {
         mutable = metaInfo.__moduleMutable;
      }
      self.pushModule( true, moduleName, mutable );
   }


   // 変数登録
   foreach varInfo, varName in metaInfo.__varName2InfoMap {
      if! let typeId = varInfo.typeId {
         self.scope.addStaticVar(
            false, true, varName, nil, unwrap typeId2TypeInfo[ typeId@@int ],
            varInfo.mutable and Ast.MutMode.Mut or Ast.MutMode.IMut );
      }
      else {
         self.error( "illegal varInfo.typeId" );
      }
   }

   // マクロ登録
   foreach macroInfoStem, orgTypeId in metaInfo.__macroName2InfoMap {

      self.macroCtrl.importMacro(
         macroInfoStem, unwrap orgId2MacroTypeInfo[ orgTypeId ],
         typeId2TypeInfo );
   }


   foreach moduleName in nameList {
      self.popModule();
   }


   //dumpScope( self.rootScope, "" );

   let moduleInfo = new Nodes.ModuleInfo(
      modulePath, nameList[#nameList], newId2OldIdMap,
      frontInterface.ModuleId.createIdFromTxt( metaInfo.__buildId ) );
   self.importModule2ModuleInfo[ moduleTypeInfo ] = moduleInfo;
   self.importModuleName2ModuleInfo[ modulePath ] = moduleInfo;

   self.importModuleInfo.remove();

   Log._log( .Info, `{ return "%s complete" (modulePath); } );

   return metaInfo, typeId2TypeInfo, moduleInfo;
}

fn TransUnit.analyzeImport( token: &Parser.Token ) mut : Nodes.Node {
   // if self.moduleScope ~= self.scope {
   //    self.error( "'import' must call at top scope." );
   // }

   let mut backupScope = self.scope;
   // スコープをルートに変更
   self.scope = self.topScope;

   let mut moduleToken = self.getToken(##);
   let mut modulePath = moduleToken.txt;
   let mut nextToken:&Parser.Token = moduleToken;

   while true {
      nextToken = self.getToken(##);
      if nextToken.txt == "." {
         nextToken = self.getToken(##);
         moduleToken = nextToken;
         modulePath = "%s.%s" ( modulePath, moduleToken.txt );
      }
      else {
         break;
      }
   }

   Ast.switchIdProvier( .Ext );

   let metaInfo, typeId2TypeInfo, moduleInfo = self.processImport( modulePath );

   Ast.switchIdProvier( .Base );


   // スコープを元に戻す
   //self.scope = self.moduleScope;
   self.scope = backupScope;


   let mut assignName = moduleToken;
   if nextToken.txt == "as" {
      assignName = self.getSymbolToken( .MustNot_ );
      nextToken = self.getToken(##);
   }

   // モジュールの末尾のシンボルでスコープに登録する。
   // 例えば hoge.foo.bar をインポートした場合、 bar をスコープに登録する
   let moduleTypeInfo = unwrap typeId2TypeInfo[ metaInfo.__moduleTypeId ];
   self.scope.addModule( moduleTypeInfo, moduleInfo.assign( assignName.txt ) );

   let moduleSymbolKind = unwrap Ast.SymbolKind._from( metaInfo.__moduleSymbolKind );
   let moduleSymbolInfo, shadowing = self.scope.add(
      moduleSymbolKind, false, false, assignName.txt, assignName.pos,
      moduleTypeInfo, .Local, true,
      metaInfo.__moduleMutable and Ast.MutMode.Mut or Ast.MutMode.IMut, true );
   when! moduleSymbolInfo {
      self.checkToken( nextToken, ";" );


      // if self.moduleScope ~= self.scope {
      //    self.error( "illegal top scope." );
      // }


      return Nodes.ImportNode.create(
         self.nodeManager, token.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         modulePath, assignName.txt, moduleSymbolInfo, moduleTypeInfo );
   }

   self.errorShadowing( token.pos, shadowing );
   return self.createNoneNode( token.pos );
}


fn TransUnit.analyzeSubfile( token: &Parser.Token ) mut : Nodes.SubfileNode {
   if self.scope ~= self.moduleScope {
      self.error( "'module' must be top scope." );
   }


   let mode = self.getToken(##);

   let mut moduleName = "";
   while true {
      let nextToken = self.getToken(##);
      if nextToken.txt == ";" {
         break;
      }
      if moduleName == "" {
         moduleName = nextToken.txt;
      }
      else {
         moduleName = "%s%s" (moduleName, nextToken.txt);
      }
   }
   let mut usePath:str! = nil;
   if moduleName == "" {
      self.addErrMess( token.pos, "illegal subfile" );
   }
   else {
      if mode.txt == "use" {
         usePath = moduleName;
         if frontInterface.searchModule( moduleName ) {
            self.subfileList.insert( moduleName );
         }
         else {
            self.addErrMess(
               token.pos, "not found subfile -- %s" ( moduleName ) );
         }
      }
      elseif mode.txt == "owner" {
         if self.moduleName ~= moduleName {
            self.addErrMess(
               token.pos,
               "illegal owner module -- %s, %s"
               ( moduleName, self.moduleName ) );
         }
      }
      else {
         self.addErrMess( mode.pos, "illegal module mode -- %s" ( mode.txt ) );
      }
   }
   return Nodes.SubfileNode.create(
      self.nodeManager, token.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], usePath );
}

fn TransUnit.analyzeIf( token: &Parser.Token ) mut : Nodes.Node {
   let mut nextToken, continueFlag = self.getContinueToken();
   if continueFlag and nextToken.txt == "!" {
      return self.analyzeIfUnwrap( token );
   }
   self.pushback();

   let mut list:Nodes.IfStmtInfo[] = [];
   let ifExp = self.analyzeExpOne( false, false ## );
   list.insert( new Nodes.IfStmtInfo( .If, ifExp,
                                      self.analyzeBlock( .If, .Start ## ) ) );

   fn checkCond( condExp:&Nodes.Node ) {
      switch condExp.$expType.$kind {
         case .Nilable, .Stem {
            ;
         }
         case .Prim {
            if not condExp.$expType.equals( Ast.builtinTypeBool ## ) {
               self.addErrMess(
                  condExp.$pos, "This exp never be false -- %s"
                  ( condExp.$expType.getTxt(##)) );
            }
         }
         default {
            self.addErrMess(
               condExp.$pos, "This exp never be false -- %s"
               ( condExp.$expType.getTxt(##)) );
         }
      }
   }
   checkCond( ifExp );

   nextToken = self.getToken( true );
   if nextToken.txt == "elseif" {
      while nextToken.txt == "elseif" {
         let condExp = self.analyzeExpOne( false, false ## );
         list.insert( new Nodes.IfStmtInfo( .ElseIf, condExp,
                                            self.analyzeBlock( .Elseif, .Merge ## ) ));
         checkCond( condExp );
         nextToken = self.getToken( true );
      }
   }

   if nextToken.txt == "else" {
      list.insert( new Nodes.IfStmtInfo(
         .Else, self.createNoneNode( nextToken.pos ),
         self.analyzeBlock( .Else, .Finish ## ) ));
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   return Nodes.IfNode.create(
      self.nodeManager, token.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], list );
}


fn TransUnit.analyzeSwitch( firstToken: &Parser.Token ) mut : Nodes.SwitchNode {
   let exp = self.analyzeExpOne( false, false ## );

   self.checkNextToken( "{" );

   let mut caseList: Nodes.CaseInfo[] = [];

   let mut nextToken = self.getToken(##);
   let mut firstFlag = true;
   while ( nextToken.txt == "case" ) {
      self.checkToken( nextToken, "case" );
      let condexpList = self.analyzeExpList( false, false, nil, [ exp.$expType ], true );
      let condBock = self.analyzeBlock(
         .Switch, firstFlag and TentativeMode.Start or TentativeMode.Merge ## );
      if firstFlag {
         firstFlag = false;
      }
      caseList.insert( new Nodes.CaseInfo( condexpList, condBock ) );
      nextToken = self.getToken(##);
   }

   let mut defaultBlock: Nodes.BlockNode! = nil;
   if nextToken.txt == "default" {
      defaultBlock = self.analyzeBlock(
         .Default, firstFlag and TentativeMode.Simple or TentativeMode.Finish ## );
   }
   else {
      if not firstFlag {
         self.finishTentativeSymbol( false );
      }
      self.pushback();
   }
   self.checkNextToken( "}" );

   if #caseList == 0 {
      self.addWarnMess( firstToken.pos, "'switch' should have 'case' blocks." );
      if defaultBlock {
         self.addErrMess( firstToken.pos, "'switch' must have 'case' blocks when have 'default' block." );
      }
   }

   return Nodes.SwitchNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], exp, caseList, defaultBlock );
}


fn TransUnit.analyzeMatch( firstToken: &Parser.Token ) mut : Nodes.MatchNode {
   let exp = self.analyzeExpOne( false, false ## );

   let! algeTypeInfo = exp.$expType.$srcTypeInfo@@@Ast.AlgeTypeInfo {
      self.error( "match must have alge value" );
   };

   self.checkNextToken( "{" );

   let mut caseList: List<&Nodes.MatchCase> = [];

   let mut nextToken = self.getToken(##);
   let mut firstFlag = true;
   while ( nextToken.txt == "case" ) {
      self.checkNextToken( "." );
      let valNameToken = self.getToken(##);

      self.checkAlgeComp( valNameToken, algeTypeInfo );

      let! valInfo = algeTypeInfo.getValInfo( valNameToken.txt ) {
         self.error( "not found val -- %s" (valNameToken.txt) );
      };
      let mut valParamNameList:List<str> = [];
      nextToken = self.getToken(##);
      let mut blockScope = self.pushScope( false ## );
      if nextToken.txt == "(" {
         foreach paramType in valInfo.$typeList {
            let paramName = self.getSymbolToken( .MustNot_ );
            self.checkShadowing( paramName.pos, paramName.txt, self.scope );
            // if self.scope.getTypeInfo(
            //    paramName.txt, self.scope, true, self.scopeAccess )
            // {
            //    self.addErrMess( paramName.pos,
            //                     "shadowing variable -- %s" (paramName.txt) );
            // }

            let mut workType = paramType;
            if Ast.TypeInfo.isMut( paramType ) and
               not Ast.TypeInfo.isMut( exp.$expType )
            {
               workType = self.createModifier( workType, .IMut );
            }
            blockScope.addLocalVar(
               true, false, paramName.txt, paramName.pos, workType, .IMut );
            valParamNameList.insert( paramName.txt );
            nextToken = self.getToken(##);
            if nextToken.txt ~= "," {
               break;
            }
         }
         self.checkToken( nextToken, ")" );
      }
      else {
         self.pushback();
      }
      if #valParamNameList ~= #valInfo.$typeList {
         self.addErrMess( valNameToken.pos,
                          "unmatch param -- %d != %d"
                          (#valParamNameList, #valInfo.$typeList ) );
      }
      let block = self.analyzeBlock(
         .Match, firstFlag and TentativeMode.Start or TentativeMode.Merge, blockScope );
      if firstFlag {
         firstFlag = false;
      }
      self.popScope();
      let matchCase = new Nodes.MatchCase( valInfo, valParamNameList, block );

      caseList.insert( matchCase );
      nextToken = self.getToken(##);
   }
   let mut defaultBlock:&Nodes.Node! = nil;
   if nextToken.txt == "default" {
      defaultBlock = self.analyzeBlock(
         .Block, firstFlag and TentativeMode.Simple or TentativeMode.Finish ## );
      nextToken = self.getToken(##);
   }
   else {
      self.finishTentativeSymbol( false );
   }
   self.checkToken( nextToken, "}" );

   return Nodes.MatchNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], exp, algeTypeInfo, caseList, defaultBlock );
}



fn TransUnit.analyzeWhile( token: &Parser.Token ) mut : Nodes.WhileNode {
   return Nodes.WhileNode.create(
      self.nodeManager, token.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], self.analyzeExpOne( false, false## ),
      self.analyzeBlock( .While, .Loop ## ) );
}

fn TransUnit.analyzeRepeat( token: &Parser.Token ) mut : Nodes.RepeatNode {
   let mut scope = self.pushScope( false## );
   let mut node = Nodes.RepeatNode.create(
      self.nodeManager, token.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      self.analyzeBlock( .Repeat, .Simple, scope ), self.analyzeExpOne( false, false## ) );
   self.popScope();

   self.checkNextToken( ";" );
   return node;
}

fn TransUnit.analyzeFor( firstToken: &Parser.Token ) mut : Nodes.ForNode {

   let mut scope = self.pushScope( false## );

   let val = self.getToken(##);
   if val.kind ~= Parser.TokenKind.Symb {
      self.error( "not symbol" );
   }
   self.checkNextToken( "=" );
   let exp1 = self.analyzeExpOne( false, false## );
   if not Ast.isNumberType( exp1.$expType ) {
      self.addErrMess( exp1.$pos,
                       "exp1 is not number -- %s" (exp1.$expType.getTxt(##)) );
   }
   let symbolInfo = self.addLocalVar(
      exp1.$pos, false, true, val.txt, exp1.$expType, .IMut## );
   self.checkNextToken( "," );
   let exp2 = self.analyzeExpOne( false, false## );
   if not Ast.isNumberType( exp2.$expType ) {
      self.addErrMess( exp2.$pos,
                       "exp2 is not number -- %s" (exp2.$expType.getTxt(##)) );
   }
   let token = self.getToken(##);
   let mut exp3:Nodes.Node! = nil;
   if token.txt == "," {
      exp3 = self.analyzeExpOne( false, false## );
      if! exp3 {
         if not Ast.isNumberType( _exp.$expType ) {
            self.addErrMess( _exp.$pos,
                             "exp is not number -- %s" (_exp.$expType.getTxt(##)) );
         }
      }

   }
   else {
      self.pushback();
   }

   let mut node = Nodes.ForNode.create(
      self.nodeManager, firstToken.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      self.analyzeBlock( .For, .Loop, scope ), symbolInfo, exp1, exp2, exp3 );
   self.popScope();

   return node;
}

fn TransUnit.analyzeApply( token: &Parser.Token ) mut : Nodes.ApplyNode {
   let mut scope = self.pushScope( false## );
   let mut varList:List<&Parser.Token> = [];
   let mut nextToken:&Parser.Token = Parser.getEofToken();
   repeat {
      let var = self.getSymbolToken( .MustNot_ );
      if var.kind ~= Parser.TokenKind.Symb {
         self.error( "illegal symbol" );
      }
      varList.insert( var );
      nextToken = self.getToken(##);
   } nextToken.txt ~= ",";
   self.checkToken( nextToken, "of" );

   let expListNode = self.analyzeExpList( false, false## );

   let mut itFunc = Ast.builtinTypeNone;
   let mut itParam = Ast.builtinTypeNone;
   
   let expTypeList = expListNode.$expTypeList;
   if #expTypeList < 3 {
      self.addErrMess( expListNode.$pos, "apply must have 3 values -- %s" (#expTypeList) );
   }
   else {
      itFunc = expTypeList[ 1 ];
      itParam = expTypeList[ 2 ];
   }

   let mut itemTypeList:List<&Ast.TypeInfo> = [];
   let mut defaultItemType = Ast.builtinTypeStem_;

   let mut readyFlag = false;
   if! let callNode = expListNode.$expList[ 1 ]@@@Nodes.ExpCallNode {
      let callFuncType = callNode.$func.$expType;
      if callFuncType.equals( builtinFunc.str_gmatch ## ) or
         callFuncType.equals( builtinFunc.string_gmatch ## )
      {
         itemTypeList.insert( Ast.builtinTypeString );
         defaultItemType = Ast.builtinTypeString.$nilableTypeInfo;
         readyFlag = true;
      }
   }

   if not readyFlag {
      itFunc = expTypeList[ 1 ];
      switch itFunc.$kind {
         case .Func, .FormFunc, .Form {
         }
         default {
            self.addErrMess(
               expListNode.$pos,
               "The 1st value must be iterator function. -- %s" (itFunc.getTxt(##)) );
         }
      }
      
      if #itFunc.$argTypeInfoList ~= 2 {
         self.addErrMess(
            expListNode.$pos,
            "iterator function must has two arguments. -- %s" (itFunc.getTxt(##)) );
      }
      else {
         let arg2Type = itFunc.$argTypeInfoList[ 2 ];
         if not arg2Type.$nilable {
            self.addErrMess(
               expListNode.$pos,
               "the 2nd argument of iterator function must be nilable. -- %s"
               (itFunc.getTxt(##)) );
         }
      }
      
      if #itFunc.$retTypeInfoList == 0 {
         self.addErrMess( expListNode.$pos, "iterator function must return value." );
      }
      else {
         let iteRetType = itFunc.$retTypeInfoList[ 1 ];
         if not iteRetType.$nilable {
            self.addErrMess(
               expListNode.$pos,
               "iterator function must return nilable type at 1st." );
         }
      }
      
      foreach itemType, index in itFunc.$retTypeInfoList {
         let mut workType = itemType;
         if index == 1 {
            if itemType.$nilable {
               workType = workType.$nonnilableType;
            }
         }
         itemTypeList.insert( workType );
      }
   }

   let mut varSymList:List<&Ast.SymbolInfo> = [];
   foreach var, index in varList {
      let mut itemType = defaultItemType;
      if index <= #itemTypeList {
         itemType = itemTypeList[ index ];
      }
      varSymList.insert(
         self.addLocalVar( var.pos, false, true, var.txt, itemType, .IMut## ) );
   }
   

   let block = self.analyzeBlock( .Apply, .Loop, scope );
   self.popScope();

   return Nodes.ApplyNode.create(
      self.nodeManager, token.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      varSymList, expListNode, block );
}

fn TransUnit.analyzeForeach( token: &Parser.Token, sortFlag: bool ) mut : Nodes.Node {
   let mut scope = self.pushScope( false## );
   let mut mainSymbol:&Parser.Token = Parser.getEofToken();
   let mut valSymbol:&Parser.Token! = nil;
   let mut subSymbol:&Parser.Token! = nil;
   let mut nextToken:&Parser.Token = Parser.getEofToken();
   for index = 1, 2 {
      let symbol = self.getToken(##);
      if symbol.kind ~= Parser.TokenKind.Symb {
         self.error( "illegal symbol" );
      }
      if index == 1 {
         mainSymbol = symbol;
         valSymbol = symbol;
      }
      else {
         subSymbol = symbol;
      }
      nextToken = self.getToken(##);
      if nextToken.txt ~= "," {
         break;
      }
   }
   self.checkToken( nextToken, "in" );

   let exp = self.analyzeExpOne( false, false## );

   let expType;
   if! let extType = exp.$expType.$srcTypeInfo@@@Ast.ExtTypeInfo {
      expType = extType.$extedType;
   }
   else {
      expType = exp.$expType;
   }
   
   let itemTypeInfoList = expType.$itemTypeInfoList;
   switch expType.$kind {
      case .Map {
         self.addLocalVar(
            exp.$pos, false, true, mainSymbol.txt, itemTypeInfoList[ 2 ], .IMut## );
         if! subSymbol {
            self.addLocalVar(
               _exp.$pos, false, true, _exp.txt, itemTypeInfoList[ 1 ], .IMut## );
         }
      }
      case .Set {
         when! subSymbol {
            self.addErrMess( subSymbol.pos, "Set can't use index" );
         }
         valSymbol = nil;
         subSymbol = mainSymbol;
         self.scope.addLocalVar(
            false, true, mainSymbol.txt, mainSymbol.pos, itemTypeInfoList[ 1 ], .IMut );
      }
      case .List, .Array {
         if sortFlag {
            self.addErrMess( exp.$pos, "'%s' doesn't support forsort."
                             (expType.$kind.$_txt) );
         }
         self.scope.addLocalVar(
            false, true, mainSymbol.txt, mainSymbol.pos, itemTypeInfoList[ 1 ], .IMut );
         if! subSymbol {
            self.addLocalVar(
               _exp.pos, false, false, _exp.txt, Ast.builtinTypeInt, .IMut## );
         }
         else {
            self.scope.addLocalVar(
               false, false, "__index", token.pos, Ast.builtinTypeInt, .IMut );
         }
      }
      default {
         self.error(
            "unknown kind type of exp for foreach-- %s(%d:%d)"
            (expType.getTxt(##), exp.$pos.lineNo, exp.$pos.column) );
      }
   }


   let mut seqSym:str! = nil;
   if! let refNode = exp@@@Nodes.ExpRefNode {
      // foreach の sequential データを保持する変数は imut にする。
      let seqSymbol = refNode.$symbolInfo;
      if seqSymbol.$mutable or Ast.TypeInfo.isMut( seqSymbol.$typeInfo ) {
         let typeInfo;
         if Ast.TypeInfo.isMut( seqSymbol.$typeInfo ) {
            typeInfo = self.createModifier( seqSymbol.$typeInfo, .IMut );
         }
         else {
            typeInfo = seqSymbol.$typeInfo;
         }
         scope.addLocalVar(
            seqSymbol.$kind == .Arg, false,
            seqSymbol.$name, exp.$pos, typeInfo, .IMut );
         seqSym = seqSymbol.$name;
      }
   }
   
   let block = self.analyzeBlock( .Foreach, .Loop, scope );

   when! seqSym {
      scope.remove( seqSym );
   }

   self.popScope();

   if sortFlag {
      return Nodes.ForsortNode.create(
         self.nodeManager, token.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         mainSymbol, subSymbol, exp, block, sortFlag );
   }
   else {
      return Nodes.ForeachNode.create(
         self.nodeManager, token.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         valSymbol, subSymbol, exp, block );
   }
}

fn TransUnit.analyzeProvide( firstToken: &Parser.Token ) mut : Nodes.ProvideNode {
   let token = self.getSymbolToken( .MustNot_ );
   let symbolNode = self.analyzeExpSymbol( firstToken, token, .Symbol, nil, true );
   self.checkNextToken( ";" );

   let symbolInfoList = symbolNode.getSymbolInfo();
   if #symbolInfoList ~= 1 {
      self.error( "'provide' must be symbol." );
   }
   let symbolInfo = symbolInfoList[ 1 ];


   let mut node = Nodes.ProvideNode.create(
      self.nodeManager, firstToken.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], symbolInfo );
   if self.provideNode {
      self.addErrMess( firstToken.pos, "multiple provide" );
   }
   self.provideNode = node;


   if symbolInfo.$accessMode ~= .Pub {
      self.addErrMess( firstToken.pos,
                       "provide variable must be 'pub'.  -- %s"
                       (symbolInfo.$accessMode));
   }

   return node;
}
