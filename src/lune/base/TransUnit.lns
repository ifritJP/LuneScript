/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile use lune.base.TransUnitDecl;
subfile use lune.base.TransUnitExp;
subfile use lune.base.TransUnitStatementList;

import lune.base.Parser;
import lune.base.Util;
import lune.base.Ast;
import lune.base.Writer;
import lune.base.frontInterface;

enum DeclClassMode {
   Class,
   Interface,
   Module
}

enum ExpSymbolMode {
   Symbol,
   Fn,
   Field,
   FieldNil,
   Get,
   GetNil,
}

pub class TransUnit {

   /** true の場合は mut 制御が有効 */
   pri let mut validMutControl: bool;

   /** モジュール名 */
   pri let mut moduleName: str;

   /** モジュールの最上位スコープ */
   pri let mut moduleScope: Ast.Scope;

   /** 解析中の scope */
   pri let mut scope: Ast.Scope;
   /** クラスの TypeId -> NamespaceInfo */
   pri let mut typeId2ClassMap: Map<int,Ast.NamespaceInfo>;

   /** クラスの型情報 -> そのクラスを宣言しているノード */
   pri let mut typeInfo2ClassNode: Map<&Ast.TypeInfo,Ast.DeclClassNode>;
   /** パーサー */
   pri let mut parser: Parser.Parser;
   /** push バックしたトークンリスト */
   pri let mut pushbackList: List<&Parser.Token>;
   /** 現在のトークン */
   pri let mut currentToken: &Parser.Token;
   /** 解析済みトークンリスト */
   pri let mut usedTokenList: List<&Parser.Token>;
   /** 解析エラーメッセージ */
   pri let mut errMessList: str[] { pub };
   /** 解析警告ーメッセージ */
   pri let mut warnMessList: str[] { pub };
   /** マクロを展開する際にマクロを評価する MacroEval のオブジェクト */
   pri let macroEval: Ast.MacroEval;
   /** マクロの TypeId -> マクロ情報 */
   pri let mut typeId2MacroInfo: Map<int,Ast.MacroInfo>;
   /** マクロのモード */
   pri let mut macroMode: Ast.MacroMode;
   /** macro-expand 内で利用できるシンボルと値の紐付けマップ */
   pri let mut symbol2ValueMapForMacro: Map<str,Ast.MacroValInfo>;
   /** macro-statement の最上位スコープ */
   pri let mut macroScope: Ast.Scope!;

   /** インポートしているモジュールの TypeInfo -> シンボル情報 */
   pri let mut importModule2ModuleInfo: Map<&Ast.TypeInfo,Ast.ModuleInfo>;
   pri let mut importModuleName2ModuleInfo: Map<str,Ast.ModuleInfo>;

   /** subfile 名のリスト */
   pri let mut subfileList: str[];

   /** 解析モード */
   pri let analyzeMode: str;
   /** 解析対象位置 */
   pri let analyzePos: &Parser.Position;
   /** 解析対象モジュール */
   pri let analyzeModule: str;

   pri let mut useUnwrapExp: bool;
   pri let mut useNilAccess: bool;

   /** provide ノード */
   pri let mut provideNode: Ast.ProvideNode!;

   pub fn __init( macroEval: Ast.MacroEval,
              analyzeModule:str!, mode:str!, pos:&Parser.Position! )
   {
      self.importModuleName2ModuleInfo = {};
      self.importModule2ModuleInfo = {};
      self.macroScope = nil;
      self.validMutControl = true;
      self.moduleName = "";
      self.parser = new Parser.DummyParser();
      self.subfileList = [];
      self.pushbackList = [];
      self.usedTokenList = [];
      self.scope = Ast.rootScope;
      self.moduleScope = Ast.rootScope;
      self.typeId2ClassMap = {};
      self.typeInfo2ClassNode = {};
      self.currentToken = Parser.getEofToken();
      self.errMessList = [];
      self.warnMessList = [];
      self.macroEval = macroEval;
      self.typeId2MacroInfo = {};
      self.macroMode = .None;
      self.symbol2ValueMapForMacro = {};
      self.analyzeMode = unwrap mode default "";
      self.analyzePos = unwrap pos default new Parser.Position( 0, 0 );
      self.analyzeModule = unwrap analyzeModule default "";
      self.provideNode = nil;
      self.useUnwrapExp = false;
      self.useNilAccess = false;
   }

   pri fn addErrMess( pos: &Parser.Position, mess: str ) mut {
      self.errMessList.insert(
         "%s:%d:%d: error: %s" ( self.parser.getStreamName(),
                                 pos.lineNo, pos.column, mess ) );
   }

   pri fn addWarnMess( pos: &Parser.Position, mess: str ) mut {
      self.warnMessList.insert(
         "%s:%d:%d: warning: %s" ( self.parser.getStreamName(),
                                   pos.lineNo, pos.column, mess ) );
   }
   

   pri fn pushScope( classFlag: bool, inheritList: Ast.Scope[]! ) mut : Ast.Scope {
      self.scope = new Ast.Scope( self.scope, classFlag,
                                  unwrap inheritList default []);
      return self.scope;
   }

   pri fn popScope() mut {
      self.scope = self.scope.get_parent();
   }

   pri fn getCurrentClass() : &Ast.TypeInfo {
      let typeInfo = Ast.rootTypeInfo;
      let mut scope = self.scope;
      repeat {
         if! scope.$ownerTypeInfo {
            if _exp.$kind == .Class or
               _exp.$kind == .Module or
               _exp.$kind == .IF {          
               return _exp;
            }   
         }  
         scope = scope.$parent;
      } scope == Ast.rootScope;
      return typeInfo;
   }
   

   pri fn getCurrentNamespaceTypeInfo() : &Ast.TypeInfo {
      let typeInfo = Ast.rootTypeInfo;
      let mut scope = self.scope;
      repeat {
         if! scope.$ownerTypeInfo {
            return _exp;
         }  
         scope = scope.$parent;
      } scope == Ast.rootScope;
      return typeInfo;
   }

   pri fn pushModule( externalFlag: bool, name:str, mutable: bool ) mut : &Ast.TypeInfo
   {
      let mut typeInfo = Ast.rootTypeInfo;
      if! self.scope.getTypeInfoChild( name ) {
         typeInfo = _exp;
         self.scope = unwrap typeInfo.$scope;
      }
      else {
         let parentInfo = self.getCurrentNamespaceTypeInfo();
         let mut parentScope = self.scope;
         let mut scope = self.pushScope( true );
         typeInfo = Ast.NormalTypeInfo.createModule(
            scope, parentInfo, externalFlag, name, mutable );

         parentScope.addClass( name, typeInfo );
      }
      if not self.typeId2ClassMap[ typeInfo.get_typeId() ] {
         let namespace = new Ast.NamespaceInfo( name, self.scope, typeInfo );
         self.typeId2ClassMap[ typeInfo.get_typeId() ] = namespace;
      }
      return typeInfo;
   }

   pri fn popModule() mut {
      self.popScope();
   }
   

   pri fn pushClass(
      classFlag:bool, abstructFlag: bool,
      baseInfo: &Ast.TypeInfo!, interfaceList: List<&Ast.TypeInfo>!,
      externalFlag: bool, name:str,
      accessMode:Ast.AccessMode, defNamespace: Ast.NamespaceInfo! ) mut : &Ast.TypeInfo
   {
      let mut typeInfo = Ast.rootTypeInfo;
      if! self.scope.getTypeInfoChild( name ) {
         typeInfo = _exp;
         self.scope = unwrap typeInfo.$scope;
         switch ( _exp.$kind ) {
            case .Class {
               if not classFlag {
                  self.addErrMess(
                     self.currentToken.pos,
                     "define interface already -- %s" (name) );
                  Util.printStackTrace();
               }
            }
            case .IF {
               if classFlag {
                  self.addErrMess(
                     self.currentToken.pos,
                     "define class already -- %s" (name) );
                  Util.printStackTrace();
               }
            }
         }
      }
      else {
         let parentInfo = self.getCurrentNamespaceTypeInfo();
         let mut inheritList:Ast.Scope[] = [];
         if! baseInfo {
            inheritList = [ unwrap _exp.get_scope() ];
         }
         
         let mut parentScope = self.scope;
         let mut scope = self.pushScope( true, inheritList );
         typeInfo = Ast.NormalTypeInfo.createClass(
            classFlag, abstructFlag, scope, baseInfo, interfaceList,
            parentInfo, externalFlag, accessMode, name );

         parentScope.addClass( name, typeInfo );
      }
      let! mut namespace = defNamespace {
         namespace = new Ast.NamespaceInfo( name, self.scope, typeInfo );
      };
      self.typeId2ClassMap[ typeInfo.get_typeId() ] = namespace;
      return typeInfo;
   }

   pri fn popClass() mut {
      self.popScope();
   }

   pri fn pushbackStr( name: str, statement: str );
   pri fn analyzeDecl( accessMode: Ast.AccessMode, staticFlag:
                       bool, firstToken: &Parser.Token,
                       token: &Parser.Token ): Ast.Node!;
   pri fn analyzeDeclVar(
      mode:Ast.DeclVarMode,
      accessMode: Ast.AccessMode, firstToken: &Parser.Token ): Ast.Node;
   pri fn analyzeDeclFunc(
      moduleFlag: bool, abstructFlag: bool,
      overrideFlag: bool, accessMode: Ast.AccessMode, staticFlag: bool,
      classNameToken: &Parser.Token!,
      firstToken: &Parser.Token, name: &Parser.Token! ) : Ast.Node;
   pri fn analyzeDeclClass(
      abstructFlag:bool, classAccessMode: Ast.AccessMode,
      classToken: &Parser.Token, mode:DeclClassMode ): Ast.Node;
   pri fn analyzeExp( skipOp2Flag: bool, opLevel: int!,
                      expectType:&Ast.TypeInfo! ): Ast.Node;
   pri fn analyzeStatement( termTxt: str! ): Ast.Node!;
   pri fn analyzeExpSymbol(
      firstToken: &Parser.Token, token: &Parser.Token,
      mode: ExpSymbolMode, prefixExp: Ast.Node!, skipFlag: bool ): Ast.Node;
   pri fn analyzeExpList( skipOp2Flag: bool, expNode: Ast.Node!,
                          expectTypeList: List<&Ast.TypeInfo>!, contExpect: bool! ): Ast.ExpListNode;
   pri fn analyzeIfUnwrap( firstToken: &Parser.Token ) mut : Ast.Node;
}


let mut opLevelBase = 0;
let mut op2levelMap:Map<str,int> = {};
let mut op1levelMap:Map<str,int> = {};
fn regOpLevel( opnum: int, opList: str[@] ) {
   opLevelBase = opLevelBase + 1;
   if opnum == 1 {
      foreach op in opList {
         op1levelMap[ op ] = opLevelBase;
      } 
   }
   else {
      foreach op in opList {
         op2levelMap[ op ] = opLevelBase;
      } 
   }
}
regOpLevel( 2, [@ "=" ] );
regOpLevel( 2, [@ "or" ] );
regOpLevel( 2, [@ "and" ] );
regOpLevel( 2, [@ "<", ">", "<=", ">=", "~=", "==" ] );
regOpLevel( 2, [@ "|" ] );
regOpLevel( 2, [@ "~" ] );
regOpLevel( 2, [@ "&" ] );
regOpLevel( 2, [@ "<<", ">>" ] );
regOpLevel( 2, [@ ".." ] );
regOpLevel( 2, [@ "+", "-" ] );
regOpLevel( 2, [@ "*", "/", "//", "%" ] );
regOpLevel( 1, [@ "`", ",,", ",,,", ",,,," ] );
regOpLevel( 1, [@ "not", "#", "-", "~" ] );
regOpLevel( 1, [@ "^" ] );


let mut quotedChar2Code:Map<int,int> = {};
quotedChar2Code[ 'a' ] = 7;    // \a
quotedChar2Code[ 'b' ] = 8;    // \b
quotedChar2Code[ 't' ] = 9;    // \t
quotedChar2Code[ 'n' ] = 10;   // \t
quotedChar2Code[ 'v' ] = 11;   // \v
quotedChar2Code[ 'f' ] = 12;   // \f
quotedChar2Code[ 'r' ] = 13;   // \r
quotedChar2Code[ '\\' ] = ?\\; // \\
quotedChar2Code[ '"' ] = ?\";  // "
quotedChar2Code[ "'" ] = ?\';  // '

class _TypeInfo {
   pub let abstructFlag: bool;
   pub let baseId: int;
   pub let ifList: int[];
   pub let itemTypeId: int[];
   pub let argTypeId: int[];
   pub let retTypeId: int[];
   pub let parentId: int;
   pub let typeId: int;
   pub let txt: str;
   pub let kind: int;
   pub let staticFlag: bool;
   pub let nilable: bool;
   pub let orgTypeId: int;
   pub let children: int[]!;
   pub let accessMode: int;
   pub let valTypeId: int;
   pub let enumValList: Map<str,stem>;
   pub let mutable: bool!;
   pub let srcTypeId: int!;
}


class _MetaInfo {
   //pub let _className2InfoMap: Map<str,Map<str,stem>>;
   pub let _typeId2ClassInfoMap: Map<int,Map<str,stem>>;
   pub let _typeInfoList: _TypeInfo[];
   pub let _varName2InfoMap: Map<str,Map<str,stem>>;
   pub let _funcName2InfoMap: Map<str,stem>;
   pub let _moduleTypeId: int;
   pub let _moduleMutable: bool;
   pub let _dependModuleMap: Map<str,Map<str,stem>>;
   pub let _dependIdMap: Map<int,int[]>;
}

pub let mut typeInfoListInsert = Ast.typeInfoRoot;
pub let mut typeInfoListRemove = Ast.typeInfoRoot;

fn TransUnit.createModifier( typeInfo:&Ast.TypeInfo, mutable: bool ) : &Ast.TypeInfo {
   if not self.validMutControl {
      return typeInfo;
   }
   return Ast.NormalTypeInfo.createModifier( typeInfo, mutable );
}


fn TransUnit.registBuiltInScope() mut {
   let builtInInfo = [
      { 
         "": {
            "type": { "arg": [ "&stem!" ], "ret": ["str"] },
            "error": { "arg": [ "str" ], "ret": [] },
            "print": { "arg": [ "&..." ], "ret": [] },
            "tonumber": { "arg": [ "str", "int!" ], "ret": ["real"] },
            "load": { "arg": [ "str" ], "ret": ["form!", "str"] },
            "loadfile": { "arg": [ "str" ], "ret": ["form!", "str"] },
            "require": { "arg": [ "str" ], "ret": ["stem!"] },
            "collectgarbage": { "arg": [ ], "ret": [] },
            "_fcall": { "arg": [ "form", "&..." ], "ret": [""] },
         }, 
      },
      {
         "iStream": {
            "__attrib": { "type": [ "interface" ] },
            "read": { "type": [ "mut" ], "arg": [ "&stem!" ], "ret": [ "str!" ] },
            "close": { "type": [ "mut" ], "arg": [], "ret": [] },
         },
      },
      {
         "oStream": {
            "__attrib": { "type": [ "interface" ] },
            "write": { "type": [ "mut" ], "arg": [ "str" ], "ret": [ ] },
            "close": { "type": [ "mut" ], "arg": [], "ret": [] },
         },
      },
      { 
         "luaStream": {
            "__attrib": { "inplements": [ "iStream", "oStream" ] },
            "read": { "type": [ "mut" ], "arg": [ "&stem!" ], "ret": [ "str!" ] },
            "write": { "type": [ "mut" ], "arg": [ "str" ], "ret": [ ] },
            "close": { "type": [ "mut" ], "arg": [], "ret": [] },
         }, 
      },
      { 
         "io": {
            "stdin": { "type": [ "member" ], "typeInfo": [ "iStream" ] },
            "stdout": { "type": [ "member" ], "typeInfo": [ "oStream" ] },
            "stderr": { "type": [ "member" ], "typeInfo": [ "oStream" ] },
            "open": { "arg": [ "str", "str!" ], "ret": ["luaStream!"] },
            "popen": { "arg": [ "str" ], "ret": ["luaStream!"] },
         },
      },
      { 
         "package": {
            "path": { "type": [ "member" ], "typeInfo": [ "str" ] },
            "searchpath": { "arg": [ "str", "str" ], "ret": ["str!"] },
         },
      },
      { 
         
         "os": {
            "clock": { "arg": [], "ret": ["int"] },
            "exit": { "arg": [ "int!" ], "ret": [] },
         },
      },
      { 
         "string": {
            "find": { "arg": [ "str", "str", "int!", "bool!" ], "ret": ["int!", "int!"] },
            "byte": { "arg": [ "str", "int" ], "ret": ["int"] },
            "format": { "arg": [ "str", "..." ], "ret": ["str"] },
            "rep": { "arg": [ "str", "int" ], "ret": ["str"] },
            "gmatch": { "arg": [ "str", "str" ], "ret": ["stem!"] },
            "gsub": { "arg": [ "str", "str", "str" ], "ret": ["str"] },
            "sub": { "arg": [ "str", "int", "int!" ], "ret": ["str"] },
         },
      },
      { 
         "str": {
            "find": { "type": [ "method" ], "arg": [ "str", "int!", "bool!" ], "ret": ["int!", "int!"] },
            "byte": { "type": [ "method" ], "arg": [ "int" ], "ret": ["int"] },
            "format": { "type": [ "method" ], "arg": [ "&..." ], "ret": ["str"] },
            "rep": { "type": [ "method" ], "arg": [ "int" ], "ret": ["str"] },
            "gmatch": { "type": [ "method" ], "arg": [ "str" ], "ret": ["stem!"] },
            "gsub": { "type": [ "method" ], "arg": [ "str", "str" ], "ret": ["str"] },
            "sub": { "type": [ "method" ], "arg": [ "int", "int!" ], "ret": ["str"] },
         },  
      },
      { 
         "table": {
            "unpack": { "arg": [ "&stem" ], "ret": ["..."] },
         },  
      },
      { 
         "List": {
            "insert": { "type": [ "mut" ], "arg": [ "&stem" ], "ret": [""] },
            "remove": { "type": [ "mut" ], "arg": [ "int!" ], "ret": [""] },
         },
      },
      {
         "debug": {
            "getinfo": { "arg": ["int"], "ret": ["stem"] },
            "getlocal": { "arg": ["int", "int"], "ret": ["str!", "stem!"] },
         },
      }
   ]@@Map<str,Map<str,Map<str,str[]>>>[];


   fn getTypeInfo( mut typeName:str ) : &Ast.TypeInfo {
      let mut mutable = true;
      if typeName.find( "^&" ) {
         mutable = false;
         typeName = typeName.gsub( "^&", "" );
      }
      let mut typeInfo = Ast.rootTypeInfo;
      if typeName.find( "!$" ) {
         let orgTypeName = typeName.gsub( "!$", "" );
         typeInfo = unwrap Ast.rootScope.getTypeInfo(
            orgTypeName, Ast.rootScope, false );
         typeInfo = typeInfo.$nilableTypeInfo;
      }
      else {
         typeInfo = unwrap Ast.rootScope.getTypeInfo(
            typeName, Ast.rootScope, false );
      }
      if mutable {
         return typeInfo;
      }
      typeInfo = self.createModifier( typeInfo, false );
      return typeInfo;
   }

   let mut builtinModuleName2Scope:Map<str,Ast.Scope> = {};

   self.scope.addVar( .Global, "_VERSION", Ast.builtinTypeString, false, true );
   
   foreach builtinClassInfo in builtInInfo {
      foreach name2FieldInfo, name in builtinClassInfo {
         let mut parentInfo = Ast.typeInfoRoot;
         if name ~= "" {
            let mut classFlag = true;
            if name2FieldInfo$.__attrib$.type$[1] == "interface" {
               classFlag = false;
            }
            let mut interfaceList:List<&Ast.TypeInfo> = [];
            if! name2FieldInfo$.__attrib$.inplements {
               foreach ifname in _exp {
                  let ifType = getTypeInfo( ifname );
                  interfaceList.insert( ifType );
               }              
            }
            parentInfo = self.pushClass(
               classFlag, false, nil, interfaceList, true, name, .Pub );
            Ast.builtInTypeIdSet[ parentInfo.get_typeId() ] = parentInfo;
            Ast.builtInTypeIdSet[ parentInfo.$nilableTypeInfo.$typeId ] =
               parentInfo.$nilableTypeInfo;
         }   
         if not builtinModuleName2Scope[ name ]
         {  
            if name ~= "" and getTypeInfo( name ) {
               builtinModuleName2Scope[ name ] = self.scope;
            }

            forsort info, fieldName in name2FieldInfo {
               if fieldName ~= "__attrib" {

                  if info.type$[1] == "member" {
                     self.scope.addMember(
                        fieldName,
                        getTypeInfo( unwrap info.typeInfo$[1] ), .Pub, true, true );
                  }
                  else {
                     let mut argTypeList: List<&Ast.TypeInfo> = [];
                     foreach argType in unwrap info[ "arg" ] {
                        argTypeList.insert( getTypeInfo( argType ) );
                     }  

                     let mut retTypeList: List<&Ast.TypeInfo> = [];
                     foreach retType in unwrap info[ "ret" ] {
                        let retTypeInfo = getTypeInfo( retType );
                        retTypeList.insert( retTypeInfo );
                     }    

                     let funcType = info.type$[1];
                     let methodFlag = funcType == "method" or funcType == "mut";
                     let mutable = funcType == "mut";

                     self.pushScope( false );
                     
                     let typeInfo = Ast.NormalTypeInfo.createFunc(
                        false, true, self.scope,
                        methodFlag and Ast.TypeInfoKind.Method or Ast.TypeInfoKind.Func,
                        parentInfo, false, true, not methodFlag, .Pub,
                        fieldName, argTypeList, retTypeList, mutable );
                     
                     self.popScope();
                     
                     Ast.builtInTypeIdSet[ typeInfo.get_typeId() ] = typeInfo;
                     if typeInfo.$nilableTypeInfo ~= Ast.rootTypeInfo {
                        Ast.builtInTypeIdSet[ typeInfo.$nilableTypeInfo.$typeId ] = typeInfo.$nilableTypeInfo;
                     }
                     self.scope.add(
                        methodFlag and Ast.SymbolKind.Mtd or Ast.SymbolKind.Fun,
                        not methodFlag, not methodFlag,
                        fieldName, typeInfo, .Pub, not methodFlag, mutable, true );
                     if methodFlag {
                        switch ( name ) {
                           case "List" {
                              switch ( fieldName ) {
                                 case "insert" {      
                                    typeInfoListInsert = typeInfo;
                                 }        
                                 case "remove" {
                                    typeInfoListRemove = typeInfo;
                                 }        
                              }       
                           }       
                        }       
                     }
                  }
               }
            }   
         }  
         if name ~= "" {
            self.popClass();
         }  
      } 
   }
}


fn TransUnit.error( mess: str ) mut {
   let mut pos:&Parser.Position = new Parser.Position( 0, 0 );
   let mut txt = "";
   if self.currentToken ~= Parser.getEofToken() {
      pos = self.currentToken.pos;
      txt = self.currentToken.txt;
   }
   else {
      if #self.usedTokenList > 0 {
         let token = self.usedTokenList[ #self.usedTokenList ];
         pos = token.pos;
         txt = token.txt;
      }
   }
   self.addErrMess(pos, mess);
   // Util.err( "%s:%d:%d: error:(%s) %s"
   //           ( self.parser.getStreamName(),
   //             pospos.lineNo, pos.column, txt, mess ) );

   foreach mess in self.errMessList {
      Util.errorLog( mess );
   }
   foreach mess in self.warnMessList {
      Util.errorLog( mess );
   }
   Util.err( "has error" );
}

fn TransUnit.createNoneNode( pos: &Parser.Position ): Ast.Node {
   //return self.createNode( nodeKindNone, pos, [ builtinTypeNone ], {} );
   return new Ast.NoneNode( pos, [ Ast.builtinTypeNone ] );
}

fn TransUnit.pushbackToken( token: &Parser.Token ) mut {
   if token ~= Parser.getEofToken() {
      self.pushbackList.insert( token );
   }
   self.currentToken = self.usedTokenList[ #self.usedTokenList ];
}

fn expandVal( tokenList:List<&Parser.Token>, val: stem!, pos: &Parser.Position ): str {
   if! val {
      switch type( _exp ) {
         case "boolean" {
            let token = "%s" (_exp);
            let kind = Parser.TokenKind.Kywd;
            tokenList.insert( new Parser.Token( kind, token, pos ) );
         }   
         case "number" {
            let num = "%g" (_exp);
            let mut kind = Parser.TokenKind.Int;
            if string.find( num, ".", 1, true ) {
               kind = Parser.TokenKind.Real;
            }   
            tokenList.insert( new Parser.Token( kind, num, pos ) );
         }   
         case "string" {
            tokenList.insert(
               new Parser.Token(
                  Parser.TokenKind.Str, '[[%s]]' (_exp ), pos ) );
            // val 中に \n 等の制御コードが入ると正常に処理されない。
            // val 内の制御コードを \xXX に変換する必要がある。
         }   
         case "table" {
            tokenList.insert(
               new Parser.Token( Parser.TokenKind.Dlmt, "{" (_exp), pos ) );
            foreach item, key in _exp@@stem![] {
               expandVal( tokenList, item, pos );
               tokenList.insert(
                  new Parser.Token( Parser.TokenKind.Dlmt, "," (_exp), pos ) );
            }   
            tokenList.insert(
               new Parser.Token( Parser.TokenKind.Dlmt, "}" (_exp), pos ) );
         }   
      } 
   }
}

fn TransUnit.newPushback( tokenList: List<&Parser.Token> ) mut {
   for index = #tokenList, 1, -1  {
      self.pushbackList.insert( tokenList[ index ] );
   }
   self.currentToken = self.usedTokenList[ #self.usedTokenList ];
}

fn TransUnit.getTokenNoErr() mut : &Parser.Token {
   if #self.pushbackList > 0 {
      if self.currentToken ~= Parser.getEofToken() {
         self.usedTokenList.insert( self.currentToken );
      }
      self.currentToken = self.pushbackList[ #self.pushbackList ];
      self.pushbackList.remove();
      return self.currentToken;
   }

   let mut commentList:List<&Parser.Token> = [];
   let mut token:&Parser.Token! = nil;
   while true {
      token = self.parser.getToken();
      if! token {
         if _exp.kind ~= Parser.TokenKind.Cmnt {
            break;
         }   
         commentList.insert( _exp );
      } 
      else {
         break;
      } 
   }

   if! token {
      if self.macroMode == .Expand {
         let tokenTxt = _exp.txt;
         if tokenTxt == ',,' or tokenTxt == ',,,,' {
            let mut nextToken = self.getTokenNoErr();

            let! macroVal = self.symbol2ValueMapForMacro[ nextToken.txt ] {
               self.error( "unknown macro val %s" (nextToken.txt) );
            };
            
            if tokenTxt == ',,' {
               //Util.errorLog( "nextToken: %s" ( nextToken.txt ) );
               if macroVal.typeInfo.equals( Ast.builtinTypeSymbol ) {
                  let txtList = (unwrap macroVal.val)@@str[];
                  for index = #txtList, 1, -1 {
                     nextToken = new Parser.Token(
                        nextToken.kind, txtList[ index ], nextToken.pos );
                     self.pushbackToken( nextToken );
                  }    
               }   
               elseif macroVal.typeInfo.equals( Ast.builtinTypeStat ) {
                  self.pushbackStr( "macroVal %s" (nextToken.txt),
                                    (unwrap macroVal.val)@@str );                       
               }   
               elseif macroVal.typeInfo.get_kind() == .Array or
                  macroVal.typeInfo.get_kind() == .List
               {   
                  let strList = (unwrap macroVal.val)@@str[];
                  if strList {
                     for index = #strList, 1, -1 {
                        self.pushbackStr(
                           "macroVal %s[%d]" (nextToken.txt, index),
                           strList[ index ] );
                     }     
                  }    
                  else {
                     self.error( "macro val is nil %s" (nextToken.txt) );
                  }    
               }
               else {
                  let mut tokenList: List<&Parser.Token> = [];
                  expandVal( tokenList, macroVal.val, nextToken.pos );
                  
                  self.newPushback( tokenList );
               } 
            } 
            elseif tokenTxt == ',,,,' {
               if macroVal.typeInfo.equals( Ast.builtinTypeSymbol ) {
                  let txtList = (unwrap macroVal.val)@@str[];
                  let mut newToken = "";
                  foreach txt in txtList {
                     newToken = "%s%s" (newToken, txt);
                  } 
                  nextToken = new Parser.Token(
                     Parser.TokenKind.Str, "'%s'" (newToken), nextToken.pos );
                  self.pushbackToken( nextToken );
               } 
               elseif macroVal.typeInfo.equals( Ast.builtinTypeStat ) {
                  nextToken = new Parser.Token(
                     Parser.TokenKind.Str, "'%s'" (unwrap macroVal.val), nextToken.pos );
                  self.pushbackToken( nextToken );
               } 
               else {
                  self.error( "not support this symbol -- %s%s"
                              (tokenTxt, nextToken.txt) );
               } 
            } 
            nextToken = self.getTokenNoErr();

            token = nextToken;
         }
      }
   }
   // if! token {
   //    _exp.set_commentList( commentList );
   // }

   self.usedTokenList.insert( self.currentToken );
   self.currentToken = unwrap token default Parser.getEofToken();

   return self.currentToken;
}



fn TransUnit.getToken( allowEof:bool! ) mut : &Parser.Token {
   let token = self.getTokenNoErr();
   if token == Parser.getEofToken() {  
      if allowEof {
         return Parser.getEofToken();
      }
      self.error( "EOF" );
   };

   // if self.macroMode == "expand"  {
   //     Util.errorLog( "getToken %s" (token.txt) );
   // }
   
   self.currentToken = token;
   return token;
}

fn TransUnit.pushback() mut {
   if self.currentToken ~= Parser.getEofToken() {
      self.pushbackList.insert( self.currentToken );
   }
   self.currentToken = self.usedTokenList[ #self.usedTokenList ];
   self.usedTokenList.remove();
}

fn TransUnit.pushbackStr( name: str, statement: str ) mut {
   let mut memStream = new Parser.TxtStream( statement );
   let mut parser = new Parser.StreamParser( memStream, name, false );

   let mut list:List<&Parser.Token> = [];
   while true {
      if! parser.getToken() {
         list.insert( _exp );
      }
      else {
         break;
      }
   }
   for index = #list, 1, -1  {
      self.pushbackToken( list[ index ] );
   }
}

fn TransUnit.checkSymbol( token: &Parser.Token ) mut : &Parser.Token {
   if token.kind ~= Parser.TokenKind.Symb and
      token.kind ~= Parser.TokenKind.Kywd and
      token.kind ~= Parser.TokenKind.Type
   {
      self.error( "illegal symbol" );
   }
   return token;
}

fn TransUnit.getSymbolToken() mut : &Parser.Token {
   return self.checkSymbol( self.getToken() );
}


fn TransUnit.checkToken( token: &Parser.Token, txt: str ) mut : &Parser.Token {
   if token.txt ~= txt {
      self.error( "not found -- %s" ( txt ) );
   }
   return token;
}

fn TransUnit.checkNextToken( txt: str ) mut : &Parser.Token {
   return self.checkToken( self.getToken(), txt );
}

/**
次のトークンが、スペースの空きがなく、連続したトークンであるか確認する。

@return 1 次のトークン
@return 2 連続したトークンだった場合 true
*/
fn TransUnit.getContinueToken() mut : &Parser.Token, bool {
   let! prevToken = self.currentToken {
      return self.getToken(), false;
   };
   let token = self.getToken();

   if prevToken.pos.lineNo ~= token.pos.lineNo or
      prevToken.pos.column + #prevToken.txt ~= token.pos.column
   {
      return token, false;
   }

   return token, true;
}


fn TransUnit.analyzeStatementList(
   stmtList: List<&Ast.Node>, termTxt: str! ) : Ast.Node!
{
   let mut lastStatement:Ast.Node! = nil;
   while true {
      let statement = self.analyzeStatement( termTxt );
      if! statement {
         stmtList.insert( _exp );
         lastStatement = statement;
      } 
      else {
         break;
      } 
   }
   return lastStatement;
}

fn TransUnit.analyzeStatementListSubfile( stmtList: List<&Ast.Node> ) mut : Ast.Node! {
   let statement = self.analyzeStatement();

   if! statement {
      if _exp.$kind ~= Ast.nodeKindSubfile {
         self.error( "subfile must have 'subfile' declaration at top." );
      } 
   }
   else {
      self.error( "subfile must have 'subfile' declaration at top." );
   }

   return self.analyzeStatementList( stmtList );
}

fn TransUnit.analyzeLuneControl( firstToken: &Parser.Token ) mut {
   let nextToken = self.getToken();
   switch ( nextToken.txt ) {
      case "disable_mut_control" {
         self.validMutControl = false;
      } 
      default {
         self.addErrMess(
            nextToken.pos, "unknown option -- %s" (nextToken.txt) );
      } 
   }
   self.checkNextToken( ";" );
}

fn TransUnit.analyzeBlock(
   blockKind: Ast.BlockKind, scope: Ast.Scope! ) mut : Ast.BlockNode
{
   let token = self.checkNextToken( "{" );

   if not scope {
      self.pushScope( false );
   }

   let mut stmtList:List<&Ast.Node> = [];
   self.analyzeStatementList( stmtList, "}" );

   self.checkNextToken( "}" );

   if not scope {
      self.popScope();
   }

   // let node = self.createNode( nodeKindBlock, token.pos, [ builtinTypeNone ],
   //                          { "kind": blockKind, "stmtList": stmtList } );
   let mut node = new Ast.BlockNode(
      token.pos, [ Ast.builtinTypeNone ], blockKind, stmtList );

   return node;
}


/**
modulePath で指定されたモジュールからメタ情報を読み込み、型情報を反映する。

@param modulePath モジュール名。 例: 'hoge.foo.bar'
@return 読み込んだメタ情報
@return メタ情報内の typeId -> TypeInfo の Map
@return インポート後の typeId -> メタ情報内の typeId の Map
*/
class DependModuleInfo {
   let id:int;
   let metaTypeId2TypeInfoMap:Map<int,&Ast.TypeInfo>;

   pub fn getTypeInfo( metaTypeId:int ):&Ast.TypeInfo {
      return unwrap self.metaTypeId2TypeInfoMap[ metaTypeId ];
   }
}


fn TransUnit.processImport( modulePath:str ) mut :
   &_MetaInfo, &Map<int,&Ast.TypeInfo>
{
   if! let moduleInfo = self.importModuleName2ModuleInfo[ modulePath ] {
      let metaInfo = frontInterface.loadMeta( modulePath )@@_MetaInfo;
      return metaInfo, moduleInfo.$importId2localTypeInfoMap;
   }
   
   let mut nameList:str[] = [];
   apply txt of string.gmatch( modulePath, '[^%.]+' ) {
      nameList.insert( txt@@str );
   }
   
   let metaInfo = frontInterface.loadMeta( modulePath )@@_MetaInfo;

   // 依存するモジュールのメタ情報を読み込み
   let mut dependLibId2DependInfo:Map<int,DependModuleInfo> = {};
   foreach dependInfo, dependName in metaInfo._dependModuleMap {
      if dependInfo.use {
         let workModuleInfo, metaTypeId2TypeInfoMap = self.processImport( dependName );
         let id = (unwrap dependInfo.id)@@int;
         dependLibId2DependInfo[ id ] =
            new DependModuleInfo( id, metaTypeId2TypeInfoMap );
      }
   }

   // 型情報の登録

   // meta情報内の typeId -> typeInfo
   let mut typeId2TypeInfo: Map<int,&Ast.TypeInfo> = {};
   typeId2TypeInfo[ Ast.rootTypeId ] = Ast.typeInfoRoot;
   let mut typeId2Scope: Map<int,Ast.Scope> = {};
   typeId2Scope[ Ast.rootTypeId ] = self.scope;

   
   // 依存するモジュールの typeInfo と、 meta 情報内の typeId との紐付け
   foreach dependIdInfo, typeId in metaInfo._dependIdMap {
      let dependInfo = unwrap dependLibId2DependInfo[ dependIdInfo[ 1 ] ];
      let typeInfo = dependInfo.getTypeInfo( dependIdInfo[ 2 ] );
      typeId2TypeInfo[ typeId ] = typeInfo;
      if! typeInfo.$scope {
         typeId2Scope[ typeId ] = _exp;
      }
   }

   let mut moduleTypeInfo = Ast.rootTypeInfo;
   foreach moduleName, index in nameList {
      let mut mutable = false;
      if index == #nameList {
         mutable = metaInfo._moduleMutable;
      }
      moduleTypeInfo = self.pushModule( true, moduleName, mutable );
   }
   foreach moduleName in nameList {
      self.popModule();
   }


   //self.moduleName2Info[ modulePath ] = metaInfo;

   foreach symbolInfo in Ast.sym2builtInTypeMap {
      typeId2TypeInfo[ symbolInfo.$typeInfo.get_typeId() ] = symbolInfo.$typeInfo;
   }
   foreach builtinTypeInfo in Ast.builtInTypeIdSet {
      typeId2TypeInfo[ builtinTypeInfo.$typeId ] = builtinTypeInfo;
   }


   let mut newId2OldIdMap: Map<&Ast.TypeInfo,int> = {};

   fn registTypeInfo( atomInfo: _TypeInfo ): &Ast.TypeInfo {
      let mut newTypeInfo: &Ast.TypeInfo! = nil;
      if! atomInfo.srcTypeId {
         let! srcTypeInfo = typeId2TypeInfo[ _exp ] {
            Util.err( "not found srcType -- %s: %d, %d"
                      ( modulePath, atomInfo.parentId, _exp ) );
         };
         newTypeInfo = self.createModifier(
            srcTypeInfo, unwrap atomInfo.mutable default false);
         typeId2TypeInfo[ atomInfo.typeId ] = newTypeInfo;
      }
      else {
         if atomInfo.kind == Ast.TypeInfoKind.Enum {
            let accessMode = unwrap Ast.AccessMode._from( atomInfo.accessMode );
            let parentInfo = unwrap typeId2TypeInfo[ atomInfo.parentId ];
            let mut name2EnumValInfo:Map<str,Ast.EnumValInfo> = {};
            let mut parentScope = unwrap parentInfo.$scope;
            let mut scope = new Ast.Scope( parentScope, true, [] );
            
            typeId2Scope[ atomInfo.typeId ] = scope;
            let enumTypeInfo = Ast.NormalTypeInfo.createEnum(
               scope, unwrap parentInfo, true, accessMode, atomInfo.txt,
               unwrap typeId2TypeInfo[ atomInfo.valTypeId ],
               name2EnumValInfo );
            newTypeInfo = enumTypeInfo;
            typeId2TypeInfo[ atomInfo.typeId ] = enumTypeInfo;
            foreach valData, valName in atomInfo.enumValList {
               name2EnumValInfo[ valName ] = new Ast.EnumValInfo( valName, valData );
               scope.addEnumVal( valName, enumTypeInfo );
            }  
            parentScope.addEnum( accessMode, atomInfo.txt, enumTypeInfo );
         }  
         elseif atomInfo.kind == Ast.TypeInfoKind.Module {
            let mut parentInfo = Ast.typeInfoRoot;
            if atomInfo.parentId ~= Ast.rootTypeId {
               let! workTypeInfo = typeId2TypeInfo[ atomInfo.parentId ] {
                  Util.err( "not found parentInfo %s %s"
                            ( atomInfo.parentId, atomInfo.txt ) );
               };   
               parentInfo = workTypeInfo;
            }   
            let! mut parentScope = typeId2Scope[ atomInfo.parentId ] {
               self.error( "not found parentScope %s %s"
                           ( atomInfo.parentId, atomInfo.txt ) );
            };  

            newTypeInfo = parentScope.getTypeInfoChild( atomInfo.txt );
            if! newTypeInfo {
               typeId2Scope[ atomInfo.typeId ] = _exp.$scope;
               if not _exp.$scope {
                  Util.err( "not found scope %s %s %s %s %s"
                            ( parentScope, atomInfo.parentId,
                              atomInfo.typeId,
                              atomInfo.txt, _exp.getTxt() ) );
               }
               typeId2TypeInfo[ atomInfo.typeId ] = _exp;
            }
            else {
               let mut scope = new Ast.Scope( parentScope, true, [] );

               let mut mutable = false;
               if atomInfo.typeId == metaInfo._moduleTypeId {
                  mutable = metaInfo._moduleMutable;
               }  
               let workTypeInfo = Ast.NormalTypeInfo.createModule(
                  scope, parentInfo, true, atomInfo.txt, mutable );

               newTypeInfo = workTypeInfo;
               typeId2Scope[ atomInfo.typeId ] = scope;
               typeId2TypeInfo[ atomInfo.typeId ] = workTypeInfo;
               parentScope.addClass( atomInfo.txt, workTypeInfo );
            }   
         }  
         elseif atomInfo.parentId ~= Ast.rootTypeId or
            not Ast.builtInTypeIdSet[ atomInfo.typeId ] or
            atomInfo.kind == Ast.TypeInfoKind.List or
            atomInfo.kind == Ast.TypeInfoKind.Array or
            atomInfo.kind == Ast.TypeInfoKind.Map or
            atomInfo.nilable
         {  
            if atomInfo.nilable {
               let orgTypeInfo = unwrap typeId2TypeInfo[ atomInfo.orgTypeId ];
               newTypeInfo = orgTypeInfo.get_nilableTypeInfo();
               typeId2TypeInfo[ atomInfo.typeId ] = unwrap newTypeInfo;
            }  
            else {
               let mut parentInfo = Ast.typeInfoRoot;
               if atomInfo.parentId ~= Ast.rootTypeId {
                  let! workTypeInfo = typeId2TypeInfo[ atomInfo.parentId ] {
                     Util.err( "not found parentInfo %s %s"
                               ( atomInfo.parentId, atomInfo.txt ) );
                  };   
                  parentInfo = workTypeInfo;
               }   
               
               let mut itemTypeInfo:List<&Ast.TypeInfo> = [];
               foreach typeId in atomInfo.itemTypeId {
                  itemTypeInfo.insert( unwrap typeId2TypeInfo[ typeId ] );
               }   
               let mut argTypeInfo:List<&Ast.TypeInfo> = [];
               foreach typeId in atomInfo.argTypeId {
                  if not typeId2TypeInfo[ typeId ] {
                     Util.log( "not found -- %s, %s.%s, %d, %d"
                               ( modulePath, parentInfo.getTxt(), atomInfo.txt,
                                 typeId, #atomInfo.argTypeId ) );  
                  }    
                  argTypeInfo.insert( unwrap typeId2TypeInfo[ typeId ] );
               }   
               let mut retTypeInfo:List<&Ast.TypeInfo> = [];
               foreach typeId in atomInfo.retTypeId {
                  retTypeInfo.insert( unwrap typeId2TypeInfo[ typeId ] );
               }   
               
               let baseInfo = unwrap typeId2TypeInfo[ atomInfo.baseId ];
               let mut interfaceList:List<&Ast.TypeInfo> = [];
               foreach ifTypeId in atomInfo.ifList {
                  interfaceList.insert( unwrap typeId2TypeInfo[ ifTypeId ] );
               }  

               let! mut parentScope = typeId2Scope[ atomInfo.parentId ] {
                  self.error( "not found parentScope %s %s"
                              ( atomInfo.parentId, atomInfo.txt ) );
               };  

               if atomInfo.txt ~= "" {
                  newTypeInfo = parentScope.getTypeInfoChild( atomInfo.txt );
               }   
               if newTypeInfo and ( atomInfo.kind == Ast.TypeInfoKind.Class or
                                    atomInfo.kind == Ast.TypeInfoKind.IF )
               {                                
                  if! newTypeInfo {
                     typeId2Scope[ atomInfo.typeId ] = _exp.$scope;
                     if not _exp.$scope {
                        Util.err( "not found scope %s %s %s %s %s"
                                  ( parentScope, atomInfo.parentId,
                                    atomInfo.typeId,
                                    atomInfo.txt, _exp.getTxt() ) );
                     }     
                     typeId2TypeInfo[ atomInfo.typeId ] = _exp;
                  };   
               }  
               else {
                  if atomInfo.kind == Ast.TypeInfoKind.Class or
                     atomInfo.kind == Ast.TypeInfoKind.IF
                  {             
                     let baseScope = unwrap typeId2Scope[ atomInfo.baseId ];

                     let mut scope = new Ast.Scope(
                        parentScope, true, [ baseScope ] );

                     let workTypeInfo = Ast.NormalTypeInfo.createClass(
                        atomInfo.kind == Ast.TypeInfoKind.Class, atomInfo.abstructFlag,
                        scope, baseInfo, interfaceList,
                        parentInfo, true, .Pub, atomInfo.txt );
                     newTypeInfo = workTypeInfo;
                     typeId2Scope[ atomInfo.typeId ] = scope;


                     typeId2TypeInfo[ atomInfo.typeId ] = workTypeInfo;

                     parentScope.addClass( atomInfo.txt, workTypeInfo );
                  }    
                  else {
                     let mut scope:Ast.Scope! = nil;

                     if atomInfo.kind == Ast.TypeInfoKind.Func or
                        atomInfo.kind == Ast.TypeInfoKind.Method
                     {     
                        scope = new Ast.Scope( parentScope, false, [] );
                     }     


                     let typeInfoKind = unwrap Ast.TypeInfoKind._from( atomInfo.kind );
                     let mut mutable = true;
                     if! atomInfo.mutable {
                        if not _exp {
                           mutable = false;
                        }  
                     }  
                     let workTypeInfo = Ast.NormalTypeInfo.create(
                        atomInfo.abstructFlag, scope, baseInfo,
                        interfaceList, parentInfo, atomInfo.staticFlag, typeInfoKind,
                        atomInfo.txt, itemTypeInfo, argTypeInfo, retTypeInfo, mutable );
                     newTypeInfo = workTypeInfo;

                     typeId2TypeInfo[ atomInfo.typeId ] = workTypeInfo;

                     if atomInfo.kind == Ast.TypeInfoKind.Func or
                        atomInfo.kind == Ast.TypeInfoKind.Method
                     {  
                        let mut symbolKind = Ast.SymbolKind.Fun;
                        if atomInfo.kind == Ast.TypeInfoKind.Method {
                           symbolKind = Ast.SymbolKind.Mtd;
                        }
                        let accessMode =
                           unwrap Ast.AccessMode._from( atomInfo.accessMode );
                        let mut workParentScope =
                           unwrap typeId2Scope[ atomInfo.parentId ];
                        workParentScope.add(
                           symbolKind, false, atomInfo.kind == Ast.TypeInfoKind.Func,
                           atomInfo.txt, workTypeInfo, accessMode,
                           atomInfo.staticFlag, false, true );
                        typeId2Scope[ atomInfo.typeId ] = scope;
                     }  
                  }  
               }   
            }  
         }  
         else {
            newTypeInfo = Ast.rootScope.getTypeInfo(
               atomInfo.txt, Ast.rootScope, false );
            if not newTypeInfo {
               foreach val, key in atomInfo@@Map<str,stem> {
                  Util.errorLog( "error: illegal atomInfo %s:%s" ( key, val ) );
               }  
            }  
            typeId2TypeInfo[ atomInfo.typeId ] = unwrap newTypeInfo;
         }
      }
      return unwrap newTypeInfo;
   }

   // 初めに child 以外で TypeInfo を登録
   foreach atomInfo in metaInfo._typeInfoList {
      registTypeInfo( atomInfo );
   }

   // 次に child を登録
   foreach atomInfo in metaInfo._typeInfoList {
      if! let children = atomInfo.children {
         if #children > 0 {
            let mut scope = unwrap typeId2Scope[ atomInfo.typeId ];
            foreach childId in children {
               let! typeInfo = typeId2TypeInfo[ childId ] {
                  Util.err( "not found childId -- %s, %d, %s(%d)"
                            (modulePath, childId, atomInfo.txt, atomInfo.typeId ) );
               };
               let mut symbolKind = Ast.SymbolKind.Typ;
               let mut addFlag = true;
               switch typeInfo.$kind {
                  case .Func {
                     symbolKind = Ast.SymbolKind.Fun;
                  }  
                  case .Method {
                     symbolKind = Ast.SymbolKind.Mtd;
                  }  
                  case .Class, .Module
                  {              
                     symbolKind = Ast.SymbolKind.Typ;
                  }  
                  case .Enum {
                     addFlag = false;
                  }  
               }  

               if addFlag {
                  scope.add( symbolKind, false,
                             typeInfo.$kind == .Func,
                             typeInfo.getTxt(), typeInfo, typeInfo.$accessMode,
                             typeInfo.$staticFlag, typeInfo.$mutable, true );
               }  
            }  
         }
      }
   }

   // インポート後の TypeId と インポート前の TypeId の紐付け
   foreach typeInfo, typeId in typeId2TypeInfo {
      newId2OldIdMap[ typeInfo ] = typeId;
   }

   // メンバーの登録
   fn registMember( classTypeId: int ) {
      if metaInfo._dependIdMap[ classTypeId ] {
         return;
      }
      let mut classTypeInfo = unwrap typeId2TypeInfo[ classTypeId ];

      switch ( classTypeInfo.$kind ) {
         case .Class {
            self.pushClass( true, classTypeInfo.$abstructFlag,
                            nil, nil, true, classTypeInfo.getTxt(), .Pub );
            if! metaInfo._typeId2ClassInfoMap[ classTypeId ] {
               let classInfo = _exp;
               foreach fieldInfo, fieldName in classInfo@@Map<str,Map<str,stem>> {
                  let typeId = fieldInfo.typeId;
                  let fieldTypeInfo = unwrap typeId2TypeInfo[ typeId ];
                  self.scope.addMember(
                     fieldName, fieldTypeInfo,
                     unwrap Ast.AccessMode._from( (unwrap fieldInfo.accessMode)@@int ),
                     (unwrap fieldInfo.staticFlag default false)@@bool,
                     (unwrap fieldInfo.mutable default false)@@bool );
               }  
            }  
            else {
               self.error( "not found class -- %s: %d, %s"
                           (modulePath, classTypeId, classTypeInfo.getTxt()) );
            }
         }
         case .Module {
            self.pushModule( true, classTypeInfo.getTxt(), classTypeInfo.$mutable );
         }
      }

      foreach child in classTypeInfo.get_children() {
         if child.get_kind() == .Class or
            child.get_kind() == .Module or
            child.get_kind() == .IF
         {           
            let oldId = newId2OldIdMap[ child ];
            if oldId {
               registMember( unwrap oldId );
            }
         }
      }

      if classTypeInfo.$kind == .Class {     
         self.popClass();
      }
      elseif classTypeInfo.$kind == .Module {
         self.popModule();
      }
   }
   foreach atomInfo in metaInfo._typeInfoList {
      if atomInfo.parentId == Ast.rootTypeId and
         ( atomInfo.kind == Ast.TypeInfoKind.Class or
           atomInfo.kind == Ast.TypeInfoKind.Module or
           atomInfo.kind == Ast.TypeInfoKind.IF )
      {
         registMember( atomInfo.typeId );
      } 
   }
   

   foreach moduleName, index in nameList {
      let mut mutable = false;
      if index == #nameList {
         mutable = metaInfo._moduleMutable;
      }
      self.pushModule( true, moduleName, mutable );
   }


   // 変数登録
   foreach varInfo, varName in metaInfo._varName2InfoMap {
      self.scope.addStaticVar(
         false, true, varName, unwrap typeId2TypeInfo[ varInfo.typeId ],
         unwrap varInfo.mutable default false );
   }

   foreach moduleName in nameList {
      self.popModule();
   }

   //dumpScope( self.rootScope, "" );

   let moduleInfo = new Ast.ModuleInfo( modulePath, newId2OldIdMap );
   self.importModule2ModuleInfo[ moduleTypeInfo ] = moduleInfo;
   self.importModuleName2ModuleInfo[ modulePath ] = moduleInfo;

   return metaInfo, typeId2TypeInfo;
}

fn TransUnit.analyzeImport( token: &Parser.Token ) mut : Ast.Node {
   if self.moduleScope ~= self.scope {
      self.error( "'import' must call at top scope." );
   }

   // スコープをルートに変更
   self.scope = Ast.rootScope;

   let mut moduleToken = self.getToken();
   let mut modulePath = moduleToken.txt;
   let mut nextToken:&Parser.Token = moduleToken;

   while true {
      nextToken = self.getToken();
      if nextToken.txt == "." {
         nextToken = self.getToken();
         moduleToken = nextToken;
         modulePath = "%s.%s" ( modulePath, moduleToken.txt );
      } 
      else {
         break;
      } 
   }

   let metaInfo, typeId2TypeInfo = self.processImport( modulePath );

   // スコープを元に戻す
   self.scope = self.moduleScope;

   // モジュールの末尾のシンボルでスコープに登録する。
   // 例えば hoge.foo.bar をインポートした場合、 bar をスコープに登録する
   let moduleTypeInfo = unwrap typeId2TypeInfo[ metaInfo._moduleTypeId ];
   self.scope.add(
      Ast.SymbolKind.Typ, false, false, moduleToken.txt,
      moduleTypeInfo, .Local, true, metaInfo._moduleMutable, true );

   self.checkToken( nextToken, ";" );


   if self.moduleScope ~= self.scope {
      self.error( "illegal top scope." );
   }

   
   return new Ast.ImportNode( token.pos, [ Ast.builtinTypeNone ],
                              modulePath, moduleTypeInfo );
}


fn TransUnit.analyzeSubfile( token: &Parser.Token ) mut : Ast.SubfileNode {
   if self.scope ~= self.moduleScope {
      self.error( "'module' must be top scope." );
   }
   

   let mode = self.getToken();

   let mut moduleName = "";
   while true {
      let nextToken = self.getToken();
      if nextToken.txt == ";" {
         break;
      }   
      if moduleName == "" {
         moduleName = nextToken.txt;
      }   
      else {
         moduleName = "%s%s" (moduleName, nextToken.txt);
      } 
   }
   if moduleName == "" {
      self.addErrMess( token.pos, "illegal subfile" );
   }
   else {
      if mode.txt == "use" {
         if frontInterface.searchModule( moduleName ) {
            self.subfileList.insert( moduleName );
         }   
         else {
            self.addErrMess(
               token.pos, "not found subfile -- %s" ( moduleName ) );
         }   
      } 
      elseif mode.txt == "owner" {
         if self.moduleName ~= moduleName {
            self.addErrMess(
               token.pos,
               "illegal owner module -- %s, %s"
               ( moduleName, self.moduleName ) );
         }  
      } 
      else {
         self.addErrMess( mode.pos, "illegal module mode -- %s" ( mode.txt ) );
      } 
   }
   return new Ast.SubfileNode( token.pos, [ Ast.builtinTypeNone ] );
}

fn TransUnit.analyzeIf( token: &Parser.Token ) mut : Ast.Node {
   let mut nextToken, continueFlag = self.getContinueToken();
   if continueFlag and nextToken.txt == "!" {
      return self.analyzeIfUnwrap( token );
   }
   self.pushback();
   
   let mut list:Ast.IfStmtInfo[] = [];
   list.insert( new Ast.IfStmtInfo( "if", self.analyzeExp( false ),
                                    self.analyzeBlock( .If ) ) );

   nextToken = self.getToken( true );
   if nextToken.txt == "elseif" {
      while nextToken.txt == "elseif" {
         list.insert( new Ast.IfStmtInfo( "elseif", self.analyzeExp( false ),
                                          self.analyzeBlock( .Elseif ) ));
         nextToken = self.getToken( true );
      } 
   }

   if nextToken.txt == "else" {
      list.insert(
         new Ast.IfStmtInfo( "else", new Ast.NoneNode( nextToken.pos,
                                                       [ Ast.builtinTypeNone ] ),
                             self.analyzeBlock( .Else ) ));
   }
   else {
      self.pushback();
   }

   return new Ast.IfNode( token.pos, [ Ast.builtinTypeNone ], list );
}


fn TransUnit.analyzeSwitch( firstToken: &Parser.Token ) mut : Ast.SwitchNode {
   let exp = self.analyzeExp( false );
   
   self.checkNextToken( "{" );

   let mut caseList: Ast.CaseInfo[] = [];
   
   let mut nextToken = self.getToken();
   while ( nextToken.txt == "case" ) {
      self.checkToken( nextToken, "case" );
      let condexpList = self.analyzeExpList( false, nil, [ exp.$expType ], true );
      let condBock = self.analyzeBlock( .Switch );
      caseList.insert( new Ast.CaseInfo( condexpList, condBock ) );
      nextToken = self.getToken();
   }

   let mut defaultBlock: Ast.BlockNode! = nil;
   if nextToken.txt == "default" {
      defaultBlock = self.analyzeBlock( .Default );
   }
   else {
      self.pushback();
   }
   self.checkNextToken( "}" );

   return new Ast.SwitchNode( firstToken.pos, [ Ast.builtinTypeNone ],
                              exp, caseList, defaultBlock );
}


fn TransUnit.analyzeWhile( token: &Parser.Token ) mut : Ast.WhileNode {
   return new Ast.WhileNode( token.pos, [ Ast.builtinTypeNone ],
                             self.analyzeExp( false ), self.analyzeBlock( .While ) );
}

fn TransUnit.analyzeRepeat( token: &Parser.Token ) mut : Ast.RepeatNode {
   let scope = self.pushScope( false );
   let mut node = new Ast.RepeatNode( token.pos, [ Ast.builtinTypeNone ],
                                      self.analyzeBlock( .Repeat, scope ),
                                      self.analyzeExp( false ) );
   self.popScope();
   
   self.checkNextToken( ";" );
   return node;
}

fn TransUnit.analyzeFor( firstToken: &Parser.Token ) mut : Ast.ForNode {

   let scope = self.pushScope( false );

   let val = self.getToken();
   if val.kind ~= Parser.TokenKind.Symb {
      self.error( "not symbol" );
   }
   self.checkNextToken( "=" );
   let exp1 = self.analyzeExp( false );
   if not exp1.$expType.equals( Ast.builtinTypeInt ) {
      self.addErrMess( exp1.$pos,
                       "exp1 is not int -- %s" (exp1.$expType.getTxt()) );
   }
   self.scope.addLocalVar( false, true, val.txt, exp1.$expType, false );
   self.checkNextToken( "," );
   let exp2 = self.analyzeExp( false );
   if not exp2.$expType.equals( Ast.builtinTypeInt ) {
      self.addErrMess( exp2.$pos,
                       "exp2 is not int -- %s" (exp2.$expType.getTxt()) );
   }
   let token = self.getToken();
   let mut exp3:Ast.Node! = nil;
   if token.txt == "," {
      exp3 = self.analyzeExp( false );
      if! exp3 {
         if not _exp.$expType.equals( Ast.builtinTypeInt ) {
            self.addErrMess( _exp.$pos,
                             "exp is not int -- %s" (_exp.$expType.getTxt()) );
         }  
      } 
      
   }
   else {
      self.pushback();
   }

   let mut node = new Ast.ForNode(
      firstToken.pos, [ Ast.builtinTypeNone ],
      self.analyzeBlock( .For, scope ), val, exp1, exp2, exp3 );
   self.popScope();
   
   return node;
}

fn TransUnit.analyzeApply( token: &Parser.Token ) mut : Ast.ApplyNode {
   let mut scope = self.pushScope( false );
   let mut varList:List<&Parser.Token> = [];
   let mut nextToken:&Parser.Token = Parser.getEofToken();
   repeat {
      let var = self.getSymbolToken();
      if var.kind ~= Parser.TokenKind.Symb {
         self.error( "illegal symbol" );
      } 
      varList.insert( var );
      nextToken = self.getToken();
      scope.addLocalVar( false, true, var.txt, Ast.builtinTypeStem, false );
   } nextToken.txt ~= ",";
   self.checkToken( nextToken, "of" );

   let exp = self.analyzeExp( false );
   if exp.$kind ~= Ast.nodeKindExpCall {
      self.error( "not call" );
   }

   let block = self.analyzeBlock( .Apply, scope );
   self.popScope();

   return new Ast.ApplyNode( token.pos, [ Ast.builtinTypeNone ], varList, exp, block );
}

fn TransUnit.analyzeForeach( token: &Parser.Token, sortFlag: bool ) mut : Ast.Node {
   let scope = self.pushScope( false );
   let mut valSymbol:&Parser.Token = Parser.getEofToken();
   let mut keySymbol:&Parser.Token! = nil;
   let mut nextToken:&Parser.Token = Parser.getEofToken();
   for index = 1, 2 {
      let sym = self.getToken();
      if sym.kind ~= Parser.TokenKind.Symb {
         self.error( "illegal symbol" );
      } 
      if index == 1 {
         valSymbol = sym;
      } 
      else {
         keySymbol = sym;
      } 
      nextToken = self.getToken();
      if nextToken.txt ~= "," {
         break;
      } 
   }
   self.checkToken( nextToken, "in" );

   let exp = self.analyzeExp( false );

   let itemTypeInfoList = exp.$expType.get_itemTypeInfoList();
   if exp.$expType.get_kind() == .Map {
      self.scope.addLocalVar(
         false, true, valSymbol.txt, itemTypeInfoList[ 2 ], false );
      if! keySymbol {
         self.scope.addLocalVar(
            false, true, _exp.txt, itemTypeInfoList[ 1 ], false );
      }  
   } 
   elseif exp.$expType.get_kind() == .List or
      exp.$expType.get_kind() == .Array
   { 
      self.scope.addLocalVar(
         false, true, valSymbol.txt, itemTypeInfoList[ 1 ], false );
      if! keySymbol {
         self.scope.addLocalVar( false, false, _exp.txt, Ast.builtinTypeInt, false );
      }
      else {
         self.scope.addLocalVar( false, false, "__index", Ast.builtinTypeInt, false );
      }
   }
   else {
      self.error( "unknown kind type of exp for foreach-- %d:%d"
         (exp.$pos.lineNo, exp.$pos.column) );
   }

   let block = self.analyzeBlock( .Foreach, scope );

   self.popScope();

   if sortFlag {
      return new Ast.ForsortNode( token.pos, [ Ast.builtinTypeNone ],
                                  valSymbol, keySymbol, exp, block, sortFlag );
   }
   else {
      return new Ast.ForeachNode( token.pos, [ Ast.builtinTypeNone ],
                                  valSymbol, keySymbol, exp, block );
   }
}

fn TransUnit.analyzeProvide( firstToken: &Parser.Token ) mut : Ast.Node {
   let val = self.analyzeExp( true );
   self.checkNextToken( ";" );

   switch val.$kind {
      case Ast.nodeKindExpRef {
         let expRefNode = val@@Ast.ExpRefNode;
      }
   }
   
   let mut node = new Ast.ProvideNode( firstToken.pos, [ Ast.builtinTypeNone ], val );
   if self.provideNode {
      self.addErrMess( firstToken.pos, "multiple provide" );
   }
   self.provideNode = node;


   if node.$val.$kind == Ast.nodeKindExpRef {
      let expRefNode = node.$val@@Ast.ExpRefNode;

      forsort symbolInfo, symbol in self.moduleScope.$symbol2TypeInfoMap {
         if expRefNode.$symbolInfo.$symbolId == symbolInfo.$symbolId {
            if symbolInfo.$accessMode ~= .Pub {
               self.addErrMess( firstToken.pos,
                                "provide variable must be 'pub'.  -- %s"
                                (symbolInfo.$accessMode));
            }
         }
         elseif symbolInfo.$accessMode == .Pub {
            self.addErrMess(
               firstToken.pos,   
               "variable (%s) can't set 'pub'." ( symbolInfo.$name ) );
         }
      }
   }

   return node;
}
