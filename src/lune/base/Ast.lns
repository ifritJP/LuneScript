/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Parser;
import lune.base.Util;

pub class IdProvider {
   let mut id:int {pub};

   pub fn increment() mut {
      self.id = self.id + 1;
   }
   
   pub fn getNewId() mut : int {
      let newId = self.id;
      self.id = self.id + 1;
      return newId;
   }
}

let mut idProv = new IdProvider( 1 );
/**
ビルトインでないユーザが定義した型情報の ID 開始番号。

import 等で、別モジュールを解析する際に、モジュール毎の開始番号として使用する。
*/
let userStartId = 1000;

pub let rootTypeId = idProv.getNewId();
//let mut typeIdSeed = rootTypeId + 1;



pub proto class TypeInfo;
pub proto abstract class SymbolInfo;

pub let mut typeInfoKind:Map<str,TypeInfo> = {};
pub let mut sym2builtInTypeMap:Map<str,SymbolInfo> = {};
pub let mut builtInTypeIdSet:Map<int,&TypeInfo> = {};

pub enum SerializeKind {
   Nilable,
   Modifier,
   Module,
   Normal,
   Enum,
}

pub enum TypeInfoKind {
   Root,
   Macro,
   Prim,
   List,
   Array,
   Map,
   Class,
   IF,
   Func,    
   Method,  
   Nilable, 
   Enum,    
   Module,
   Stem,
}

pub fn isBuiltin( typeId: int ) : bool {
   return builtInTypeIdSet[ typeId ] ~= nil;
}


pub proto class Scope;

pub enum SymbolKind {
   Typ,
   Mbr,
   Mtd,
   Fun,
   Var,
   Arg,
}

pub enum AccessMode {
   None,
   Pub,
   Pro,
   Pri,
   Local,
   Global,
}

pub fn isPubToExternal( mode:AccessMode ): bool {
   switch mode {
      case .Pub, .Pro, .Global {
         return true;
      }
   }
   return false;
}

let mut txt2AccessModeMap:Map<str,AccessMode> = {};
txt2AccessModeMap[ "none" ] = .None;
txt2AccessModeMap[ "pub" ] = .Pub;
txt2AccessModeMap[ "pro" ] = .Pro;
txt2AccessModeMap[ "pri" ] = .Pri;
txt2AccessModeMap[ "local" ] = .Local;
txt2AccessModeMap[ "global" ] = .Global;
pub fn txt2AccessMode( accessMode:str ) : AccessMode! {
   return txt2AccessModeMap[ accessMode ];
}


/** シンボル情報 */
pub abstract class SymbolInfo {
   /** 左辺値になれる場合 true */
   pub abstract fn get_canBeLeft(): bool;
   /** 右辺値になれる場合 true */
   pub abstract fn get_canBeRight(): bool;
   /** このシンボルの ID */
   pub abstract fn get_symbolId(): int;
   /** このシンボルが属するスコープ */
   pub abstract fn get_scope(): Scope;
   /** シンボルのアクセス */
   pub abstract fn get_accessMode(): AccessMode;
   /** */
   pub abstract fn get_staticFlag(): bool;
   /** シンボルの名前 */
   pub abstract fn get_name(): str;
   /** シンボルの型 */
   pub abstract fn get_typeInfo(): TypeInfo;
   /** このシンボルが mut かどうか */
   pub abstract fn get_mutable(): bool;
   /** このシンボルの種類 SymbolKind */
   pub abstract fn get_kind(): SymbolKind;
   /** このシンボルがデータを保持しているかどうか */
   pub abstract fn get_hasValueFlag(): bool;
   pub abstract fn set_hasValueFlag( arg:bool );

   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub abstract fn canAccess( fromScope:&Scope ): &SymbolInfo!;

   pub abstract fn getOrg(): &SymbolInfo;
}


pub class NormalSymbolInfo extend SymbolInfo {
   pri static let mut symbolIdSeed:int;

   __init {
      NormalSymbolInfo.symbolIdSeed = 0;
   }

   /** 左辺値になれる場合 true */
   pri let canBeLeft: bool { pub };
   /** 右辺値になれる場合 true */
   pri let canBeRight: bool { pub };
   
   /** このシンボルの ID */
   pri let symbolId: int { pub };
   /** このシンボルが属するスコープ */
   pri let scope: Scope { pub };
   /** シンボルのアクセス */
   pri let accessMode: AccessMode { pub };
   /** */
   pri let staticFlag: bool { pub };
   /** シンボルの名前 */
   pri let name: str { pub };
   /** シンボルの型 */
   pri let typeInfo: &TypeInfo { pub };
   /** このシンボルが mut かどうか */
   pri let mutable: bool { pub };
   /** このシンボルの種類 SymbolKind */
   pri let kind: SymbolKind { pub };
   /** このシンボルがデータを保持しているかどうか */
   pri let hasValueFlag: bool { pub, pub };

   pub override fn getOrg(): &SymbolInfo {
      return self;
   }


   pub fn __init(
      kind:SymbolKind, canBeLeft:bool, canBeRight:bool, scope: Scope,
      accessMode: AccessMode, staticFlag: bool, name: str, 
      typeInfo: &TypeInfo, mutable: bool!, hasValueFlag: bool )
   {
      super();
      NormalSymbolInfo.symbolIdSeed = NormalSymbolInfo.symbolIdSeed + 1;
      self.kind = kind;
      self.canBeLeft = canBeLeft;
      self.canBeRight = canBeRight;
      self.symbolId = NormalSymbolInfo.symbolIdSeed;
      self.scope = scope;
      self.accessMode = accessMode;
      self.staticFlag = staticFlag;
      self.name = name;
      self.typeInfo = typeInfo;
      self.mutable = mutable and true or false;
      self.hasValueFlag = hasValueFlag;
   }
   
   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub override fn canAccess( fromScope:&Scope ): &SymbolInfo!;
}


pub class DataOwnerInfo {
   pub let hasData:bool;
   pub let symbolInfo: &SymbolInfo;
}

pub class Scope {
   // このスコープのオーナーの TypeInfo。
   // 名前空間に関連する class, function の TypeInfo。
   pri let mut ownerTypeInfo: &TypeInfo! { pub, pub };
   // 親のスコープ。 これが self と等しい場合は root。
   pri let mut parent: Scope { pub };
   // このスコープに登録されているシンボル情報。
   // シンボル名 → SymbolInfo のマップ。
   pri let mut symbol2SymbolInfoMap: Map<str,&SymbolInfo> { pub };
   // このスコープがクラスのスコープかどうか。
   pri let classFlag: bool;
   // 継承しているスコープ。
   pri let inherit: &Scope!;
   // 継承しているスコープ。
   pri let ifScopeList: List<&Scope>;
   /** 所有権情報 */
   pri let mut symbolId2DataOwnerInfo: Map<int,DataOwnerInfo>;
      
      
   pub fn __init( parent: Scope!, classFlag: bool,
                  inherit: &Scope!, ifScopeList:List<&Scope>! )
   {  
      self.parent = unwrap parent default self;
      self.symbol2SymbolInfoMap = {};
      self.inherit = inherit;
      self.classFlag = classFlag;
      self.symbolId2DataOwnerInfo = {};
      self.ifScopeList = unwrap ifScopeList default [];
   }

   pub fn isRoot(): bool {
      return self.parent == self;
   }

   pub fn set_ownerTypeInfo( owner: &TypeInfo! ) mut {
      self.ownerTypeInfo = owner;
   }
   
   pub fn getTypeInfoChild( name: str ) : &TypeInfo! {
      if! self.symbol2SymbolInfoMap[ name ] {
         return _exp.$typeInfo;
      } 
      return nil;
   }

   pub fn getSymbolInfoChild( name: str ) : &SymbolInfo! {
      return self.symbol2SymbolInfoMap[ name ];
   }
   
   pub fn setData( symbolInfo:&SymbolInfo ) mut {
      self.symbolId2DataOwnerInfo[ symbolInfo.$symbolId ] =
      new DataOwnerInfo( true, symbolInfo );
   }

   
   pub fn getNSTypeInfo(): TypeInfo;
}

// 最上位のスコープ
pub let mut rootScope = new Scope( nil, false, nil );

/**
このスコープが scope の同じか内部のスコープか調べる。

@return bool: 同じか内部のスコープの場合 true。
*/
pub fn Scope.isInnerOf( scope:&Scope ): bool {
   let mut workScope = self;
   while workScope ~= rootScope {
      if workScope == scope {
         return true;
      }
      workScope = workScope.parent;
   }
   return false;
}



let dummyList:List<&TypeInfo> = [];
let mut rootChildren:List<&TypeInfo> = [];

pub class TypeData {
   pri let mut children:List<&TypeInfo> {pub};
   pub fn addChildren( child:&TypeInfo ) mut {
      self.children.insert( child );
   }
}

class TypeManager {
   pri static let mut info2Data:Map<&TypeInfo,TypeData>;

   __init {
      TypeManager.info2Data = {};
   }
   pub static fn add( typeInfo:&TypeInfo ) {
      TypeManager.info2Data[ typeInfo ] = new TypeData( [] );
   }
   pub static fn getData( typeInfo:&TypeInfo ) : TypeData! {
      return TypeManager.info2Data[ typeInfo ];
   }
}


let mut typeInfo2ScopeMap:Map<&TypeInfo,Scope> = {};

pub fn getScope( typeInfo:&TypeInfo ): Scope! {
   return typeInfo2ScopeMap[ typeInfo ];
}

pub interface ModuleInfoIF {
   pub fn get_assignName():str;
   pub fn get_modulePath():str;
}

pub class TypeInfo {

   // この TypeInfo のスコープ。
   // class, func など名前空間を持つ TypeInfo は有効。
   pri let scope: Scope!;

   pub fn get_scope(): Scope! {
      return typeInfo2ScopeMap[ self ];
   }
   

   pub fn __init( scope: Scope! ) {
      typeInfo2ScopeMap[ self ] = scope;
      self.scope = scope;
      if! scope {
         _exp.set_ownerTypeInfo( self );
      }
      TypeManager.add( self );
   }

   pub fn isModule(): bool {
      return true;
   }

   pub fn getParentId(): int {
      return rootTypeId;
   }

   pub fn get_baseId(): int {
      return rootTypeId;
   }

   pub fn isInheritFrom( other:&TypeInfo ) : bool {
      return false;
   }

   pub fn getTxt( fullName:bool!,
                  importInfo:&Map<&TypeInfo,ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      return "";
   }

   pro static fn canEvalWithBase(
      dist:&TypeInfo, distMut: bool, other:&TypeInfo, opTxt:str ): bool;

   pub fn canEvalWith( other:&TypeInfo, opTxt:str ): bool {
      return false;
   }
   
   pub fn get_abstractFlag(): bool {
      return false;
   }
   
   pub fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      return;
   }

   pub fn get_display_stirng(): str {
      return "";
   }

   pub fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }

   pub fn equals( typeInfo: &TypeInfo ): bool {
      return self == typeInfo.$srcTypeInfo;
   }

   pub fn get_externalFlag(): bool {
      return false;
   }
   
   pub fn get_interfaceList(): &List<&TypeInfo> {
      return dummyList;
   }  
   pub fn get_itemTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }  
   pub fn get_argTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }  
   pub fn get_retTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }  
   pub fn get_parentInfo(): &TypeInfo {
      return self;
   }

   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報か？
   */
   pub fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      while true {
         if other == self {
            return true;
         }
         if other.$parentInfo == other {
            break;
         }
         other = other.$parentInfo;
      }
      return false;
   }
   pub fn getModule(): &TypeInfo {
      if self.isModule() {
         return self;
      }
      return self.$parentInfo.getModule();
   }
   pub fn get_rawTxt(): str {
      return "";
   }  
   pub fn get_typeId(): int {
      return rootTypeId;
   }  
   pub fn get_kind(): TypeInfoKind {
      return .Root;
   } 
   pub fn get_staticFlag(): bool {
      return false;
   } 
   pub fn get_accessMode(): AccessMode {
      return AccessMode.Pri;
   }  
   pub fn get_autoFlag(): bool {
      return false;
   }  
   pub fn get_orgTypeInfo(): &TypeInfo {
      return self;
   }  
   pub fn get_baseTypeInfo(): &TypeInfo {
      return self;
   } 
   pub fn get_nilable(): bool {
      return false;
   }
   pub fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   pub fn get_typeData(): TypeData {
      return unwrap TypeManager.getData( self ); 
   }
   pub fn get_children() : &List<&TypeInfo> {
      return self.$typeData.$children;
   }
   pub fn addChildren( child:TypeInfo ) {
      (unwrap TypeManager.getData( self )).addChildren( child );
   }
   pub fn get_mutable(): bool {
      return true;
   }

   pub fn getParentFullName( importInfo:&Map<&TypeInfo,ModuleInfoIF>!, localFlag:bool! ) : str {
      let mut typeInfo:&TypeInfo = self;
      let mut name = "";
      let! mut infoMap = importInfo {
         infoMap = {};
      };
      while not infoMap[ typeInfo ] {
         typeInfo = typeInfo.$parentInfo;
         if typeInfo == typeInfo.$parentInfo {
            break;
         }
         let mut txt = typeInfo.$rawTxt;
         if localFlag {
            if! let moduleInfo = infoMap[ typeInfo ] {
               txt = moduleInfo.$assignName;
            }  
            else {
               if typeInfo.isModule() {
                  break;
               }
            }
         }
         name = txt .. "." .. name;
      }
      return name;
   }
}

pub form filterForm( symbolInfo:&SymbolInfo ): bool;

pub fn Scope.filterTypeInfoField(
   includeSelfFlag: bool!, fromScope:&Scope, callback:filterForm ):bool
{
   if self.classFlag {
      if includeSelfFlag {
         foreach symbolInfo in self.symbol2SymbolInfoMap {
            if symbolInfo.canAccess( fromScope ) {
               if not callback( symbolInfo ) {
                  return false;
               }        
            }  
         }  
      }
      if! let scope = self.inherit {
         if not scope.filterTypeInfoField( true, fromScope, callback ) {
            return false;
         }
      } 
   }

   return true;
}

pub fn Scope.getSymbolInfoField(
   name: str, includeSelfFlag: bool!, fromScope:&Scope ) : &SymbolInfo!
{
   if self.classFlag {
      if includeSelfFlag {
         if! self.symbol2SymbolInfoMap$[ name ] {
            let! symbolInfo = _exp.canAccess( fromScope ) {
               return nil;
            };
            return symbolInfo;
         }  
      } 
      if! let scope = self.inherit {
         let symbolInfo = scope.getSymbolInfoField( name, true, fromScope );
         if symbolInfo {
            return symbolInfo;
         }   
      } 
   }

   return nil;
}


pub fn Scope.getSymbolInfoIfField( name: str, fromScope:&Scope ) : &SymbolInfo!
{
   if self.classFlag {
      foreach scope in self.ifScopeList {
         if! let symbolInfo = scope.getSymbolInfoField( name, true, fromScope ) {
            return symbolInfo;
         }
      } 
   }

   if! let scope = self.inherit {
      if! let symbolInfo = scope.getSymbolInfoIfField( name, fromScope ) {
         return symbolInfo;
      }
   } 

   return nil;
}

pub fn Scope.filterSymbolInfoIfField( fromScope:&Scope, callback:filterForm ) : bool
{
   foreach scope in self.ifScopeList {
      if not scope.filterTypeInfoField( true, fromScope, callback ) {
         return false;
      }
   }

   if! let scope = self.inherit {
      if not scope.filterSymbolInfoIfField( fromScope, callback ) {
         return false;
      }
   } 
   
   return true;
}



pub fn Scope.getTypeInfoField(
   name: str, includeSelfFlag: bool!, fromScope:&Scope ) : TypeInfo!
{
   let symbolInfo = self.getSymbolInfoField( name, includeSelfFlag, fromScope );
   if! symbolInfo {
      return _exp.$typeInfo;
   }
   return nil;
}


/**
このスコープからシンボル name の型情報を取得する。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
@param onlySameNsFlag true の場合、検索対象を同一名前空間内に限定する。
*/
pub fn Scope.getSymbolInfo(
   name: str, fromScope:&Scope, onlySameNsFlag:bool ) : &SymbolInfo!
{
   if! self.symbol2SymbolInfoMap[ name ] {
      let! symbolInfo = _exp.canAccess( fromScope ) {
         return nil;
      };
      return symbolInfo;
   }
   if not onlySameNsFlag {
      if! let scope = self.inherit {
         let symbolInfo = scope.getSymbolInfoField( name, true, fromScope );
         if symbolInfo {
            return symbolInfo;
         }   
      } 
   }
   if not onlySameNsFlag or not self.ownerTypeInfo {
      if self.parent ~= self {
         return self.parent.getSymbolInfo( name, fromScope, onlySameNsFlag );
      } 
   }
   if onlySameNsFlag {
      return nil;
   }
   if! sym2builtInTypeMap[ name ] {
      return _exp;
   }
   return nil;
}

pub fn Scope.getTypeInfo(
   name: str, fromScope:&Scope, onlySameNsFlag:bool ) : TypeInfo!
{
   let! symbolInfo = self.getSymbolInfo(name, fromScope, onlySameNsFlag ) {
      return nil;
   };
   return symbolInfo.$typeInfo;
}


/**
このスコープからシンボル name の型情報を取得する。
フィールドを除く name。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
*/
pub fn Scope.getSymbolTypeInfo(
   name: str, fromScope:&Scope, moduleScope:&Scope ) : &SymbolInfo!
{
   let mut typeInfo:TypeInfo! = nil;
   let mut validThisScope = false;

   if! self.ownerTypeInfo {
      if _exp.$kind == .Func or _exp.$kind == .Method or
         self == moduleScope or self == rootScope
      { 
         validThisScope = true;
      } 
      elseif ( _exp.$kind == .IF or _exp.$kind == .Class or
               _exp.$kind == .Module ) and name == "self" {
         validThisScope = true;
      }
      elseif _exp.$kind == .Enum {
         validThisScope = true;
      }
   } 
   else {
      validThisScope = true;
   }
   if validThisScope {
      if! self.symbol2SymbolInfoMap[ name ] {
         return _exp.canAccess( fromScope );
      } 
   }
   if self.parent ~= self {
      return self.parent.getSymbolTypeInfo( name, fromScope, moduleScope );
   }
   return sym2builtInTypeMap[ name ];
}


pub fn Scope.filterSymbolTypeInfo(
   fromScope:&Scope, moduleScope:&Scope, callback:filterForm )
{
   if self.classFlag {
      if! self.symbol2SymbolInfoMap[ "self" ] {
         callback( _exp );
      }
   }
   if moduleScope == fromScope or not self.classFlag {
      foreach symbolInfo in self.symbol2SymbolInfoMap {
         if not callback( symbolInfo ) {
            return;
         }  
      }
   }

   if self.parent ~= self {
      self.parent.filterSymbolTypeInfo( fromScope, moduleScope, callback );
   }
}


pub fn Scope.add( kind: SymbolKind, canBeLeft:bool, canBeRight:bool,
                  name:str, typeInfo: &TypeInfo, accessMode:AccessMode,
                  staticFlag:bool, mutable:bool, hasValueFlag:bool ) mut : &SymbolInfo
{
   let mut symbolInfo = new NormalSymbolInfo(
      kind, canBeLeft, canBeRight,
      self, accessMode, staticFlag, name, typeInfo, mutable, hasValueFlag );
   self.symbol2SymbolInfoMap[ name ] = symbolInfo;
   return symbolInfo;
}

pub fn Scope.addLocalVar(
   argFlag:bool, canBeLeft:bool, name:str, typeInfo: &TypeInfo, mutable:bool ) mut
{
   self.add( argFlag and SymbolKind.Arg or SymbolKind.Var,
             canBeLeft, true, name, typeInfo,
             .Local, false, mutable, true );
}

pub fn Scope.addStaticVar(
   argFlag:bool, canBeLeft:bool, name:str, typeInfo: &TypeInfo, mutable:bool ) mut
{
   self.add( argFlag and SymbolKind.Arg or SymbolKind.Var,
             canBeLeft, true, name, typeInfo,
             .Local, true, mutable, true );
}

pub fn Scope.addVar(
   accessMode:AccessMode, name:str,
   typeInfo: &TypeInfo, mutable:bool, hasValueFlag:bool ) mut
{
   self.add( SymbolKind.Var, true, true, name, typeInfo,
             accessMode, false, mutable, hasValueFlag );
}


pub fn Scope.addEnumVal( name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Mbr, false, true,
             name, typeInfo, .Pub, true, true, true );
}

pub fn Scope.addEnum( accessMode:AccessMode, name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Typ, false, false,
             name, typeInfo, accessMode, true, true, true );
}

pub fn Scope.addMember( name:str, typeInfo: &TypeInfo, accessMode:AccessMode,
                        staticFlag:bool, mutable:bool ) mut : &SymbolInfo
{
   return self.add( SymbolKind.Mbr, true, true,
                    name, typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addMethod(
   typeInfo: &TypeInfo, accessMode:AccessMode, staticFlag:bool, mutable:bool ) mut
{
   self.add( SymbolKind.Mtd, true, true, typeInfo.getTxt(),
             typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addFunc(
   typeInfo: &TypeInfo, accessMode:AccessMode, staticFlag:bool, mutable:bool ) mut
{
   self.add( SymbolKind.Fun, true, true, typeInfo.getTxt(),
             typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addClass( name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Typ, false, false, name, typeInfo,
             typeInfo.$accessMode, true, true, true );
} 

fn dumpScopeSub( scope: Scope!, prefix:str, readyIdSet:Map<Scope,bool> ) {
   if! scope {
      if readyIdSet[ _exp ] {
         return;
      } 
      readyIdSet[ _exp ] = true;
      if #prefix > 20 {
         Util.err("illegal");
      }   
      
      forsort symbolInfo, symbol in _exp.$symbol2SymbolInfoMap {
         Util.log( "scope: %s, %s, %s" ( prefix, _exp, symbol ) );
         if! let subScope = symbolInfo.$typeInfo.$scope {
            dumpScopeSub( subScope, prefix .. "  ", readyIdSet );
         }
      } 
   };
}

fn dumpScope( scope: Scope!, prefix:str ) {
   dumpScopeSub( scope, prefix, {} );
}



pub let mut headTypeInfo:TypeInfo = new TypeInfo( rootScope );
//let rootTypeInfo:TypeInfo = new TypeInfo( rootScope );


pub fn Scope.getNSTypeInfo(): &TypeInfo {
   let mut scope = self;
   while true {
      if! let owner = scope.ownerTypeInfo {
         if owner.$kind == .Root {
            return owner;
         }
      }
      if scope.parent == scope {
         break;
      }
      scope = scope.parent;
   }
   return headTypeInfo;
}

pub fn Scope.getClassTypeInfo(): &TypeInfo {
   let mut scope = self;
   while true {
      if! let owner = scope.ownerTypeInfo {
         switch owner.$kind {
            case .Class, .IF, .Module {
               return owner;
            }
         }
      }
      if scope.parent == scope {
         break;
      }
      scope = scope.parent;
   }
   return headTypeInfo;
}


/**
このシンボルが、fromScope のスコープからアクセスできるか調べる。
 */
pub override fn NormalSymbolInfo.canAccess( fromScope:&Scope ): &SymbolInfo!
{
   let typeInfo = self.$typeInfo;
   if self.scope == fromScope {
      return self;
   }
   switch self.$accessMode {
      case .Pub, .Global {
         return self;
      }           
      case .Pro {
         let nsClass = self.scope.getClassTypeInfo();
         let fromClass = fromScope.getClassTypeInfo();
         if fromClass.isInheritFrom( nsClass ) {
            return self;
         }  
         return nil;
      } 
      case .Local {
         return self;
      } 
      case .Pri {
         // let nsClass = self.scope.getClassTypeInfo();
         // let fromClass = fromScope.getClassTypeInfo();
         // if nsClass == fromClass {
         //    return self;
         // }  
         // return nil;
         if fromScope.isInnerOf( self.scope ) {
            return self;
         }
         return nil;
      } 
   }
   Util.err( "illegl accessmode -- %s, %s"
             (self.$accessMode, self.$name) );
}


pub class AccessSymbolInfo extend SymbolInfo {
   pri let symbolInfo: SymbolInfo {pub};
   pri let prefixTypeInfo: TypeInfo! {pub};
   pri let overrideCanBeLeft: bool;

   pub override fn getOrg(): &SymbolInfo {
      return self.symbolInfo.getOrg();
   }

   pub override fn get_mutable(): bool {
      if! self.prefixTypeInfo {
         return _exp.$mutable and self.symbolInfo.$mutable;
      }
      return self.symbolInfo.$mutable;
   };

   pub override fn get_canBeLeft(): bool {
      if not self.overrideCanBeLeft {
         return false;
      }
      if! self.prefixTypeInfo {
         if not _exp.$mutable {
            return false;
         }
      }
      return self.symbolInfo.$canBeLeft;
   }

   advertise symbolInfo;
}



pub proto class Node;
pub proto class DeclClassNode extend Node;

pub class NilableTypeInfo extend TypeInfo {
   pri let orgTypeInfo: &TypeInfo { pub };
   pri let typeId: int { pub };

   pub override fn get_kind(): TypeInfoKind {
      return .Nilable;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_nilable(): bool {
      return true;
   } 
   pub override fn getTxt( fullName:bool!,
                           importInfo:&Map<&TypeInfo,ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      return self.orgTypeInfo.getTxt( fullName, importInfo, localFlag ) .. "!";
   }
   pub override fn get_display_stirng(): str {
      return self.orgTypeInfo.$display_stirng .. "!";
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, nilable = true, orgTypeId = %d }\n' (
            SerializeKind.Nilable, parentId, self.typeId, self.orgTypeInfo.$typeId ) );
   }

   pub override fn equals( typeInfo: &TypeInfo ): bool {
      if not typeInfo.$nilable {
         return false;
      }
      return self.orgTypeInfo.equals( typeInfo );
   }

   advertise orgTypeInfo;
}


pub class ModifierTypeInfo extend TypeInfo {
   pri let srcTypeInfo: &TypeInfo { pub };
   pri let typeId: int { pub };
   pri let mutable: bool { pub };

   pub override fn getTxt(
      fullName:bool!, importInfo:&Map<&TypeInfo,ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      let mut txt = self.srcTypeInfo.getTxt( fullName, importInfo, localFlag );
      if not self.mutable {
         txt = "&" .. txt;
      }
      return txt;
   }
   pub override fn get_display_stirng(): str {
      let mut txt = self.srcTypeInfo.get_display_stirng();
      if self.mutable {
         txt = "mut " .. txt;
      }
      return txt;
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, srcTypeId = %d, mutable = %s }\n' (
            SerializeKind.Modifier, parentId, self.typeId, self.srcTypeInfo.$typeId,
            self.mutable and true or false ) );
   }

   pub override fn canEvalWith( other:&TypeInfo, opTxt:str ): bool {
      return TypeInfo.canEvalWithBase( self.srcTypeInfo, self.mutable, other, opTxt );
   }


   advertise srcTypeInfo;
}


pub class ModuleTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   //
   pri let mutable: bool {pub};

   pub fn __init( scope: Scope, externalFlag: bool,
                  txt: str, mut parentInfo: &TypeInfo!, typeId: int, mutable:bool )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = typeId;
      self.mutable = mutable;

      if! parentInfo {
         _exp.addChildren( self );
      }

      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;
      

      scope.set_ownerTypeInfo( self );
   }

   pub override fn isModule(): bool {
      return true;
   }

   pub override fn get_accessMode(): AccessMode {
      return AccessMode.Pub;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Module;
   } 
   
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   pub override fn getTxt(
      fullName:bool!, importInfo:&Map<&TypeInfo,ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      return self.rawTxt;
   }

   pub override fn get_display_stirng(): str {
      return self.getTxt();
   }

   pub override fn canEvalWith( other:&TypeInfo, opTxt:str ): bool {
      return false;
   }

   pub override fn serialize(
      stream: oStream, validChildrenSet: Map<int,&TypeInfo>! )
   {  
      let txt = "{ skind = %d, parentId = %d, typeId = %d, txt = '%s', kind = %d, "
          ( SerializeKind.Module,
            self.getParentId(), self.typeId, self.rawTxt, TypeInfoKind.Module );
      stream.write( txt .. '\n' );

      stream.write( "children = {" );

      let! set = validChildrenSet {
         set = {};
      };
      if! validChildrenSet {
         foreach child in self.$children {
            if set[ child.$typeId ] and
               ( child.$accessMode == .Pub or child.$accessMode == .Global ) {
               stream.write( "%d, " ( child.$typeId ) );
            }  
         }  
      }
      stream.write( "} }\n" );
   }
}

pub class EnumValInfo {
   pri let name: str {pub};
   pri let val:stem {pub};
}

pub class EnumTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   pri let nilableTypeInfo: &TypeInfo { pub };

   // この enum で格納している値の型
   pri let valTypeInfo: &TypeInfo {pub};
   

   // enum 値名 -> EnumValInfo
   pri let name2EnumValInfo: Map<str,EnumValInfo> { pub };
   
   pub fn __init( scope: Scope, externalFlag: bool, accessMode: AccessMode,
                  txt: str, parentInfo: &TypeInfo!, typeId: int, valTypeInfo:&TypeInfo,
                  name2EnumValInfo: Map<str,EnumValInfo> )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = typeId;
      self.name2EnumValInfo = name2EnumValInfo;
      self.valTypeInfo = valTypeInfo;

      if! parentInfo {
         _exp.addChildren( self );
      }

      self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;

      scope.set_ownerTypeInfo( self );
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Enum;
   } 
   
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   pub override fn getTxt(
      fullName:bool!, importInfo:&Map<&TypeInfo,ModuleInfoIF>!, localFlag:bool! ) : str
   { 
      return self.rawTxt;
   }

   pub override fn get_display_stirng(): str {
      return self.getTxt();
   }
   
   pub override fn canEvalWith( other:&TypeInfo, opTxt:str ): bool {
      return self == other.$srcTypeInfo;
   }

   pub fn getEnumValInfo( name:str ): EnumValInfo! {
      return self.name2EnumValInfo[ name ];
   }

   pub override fn get_mutable(): bool {
      return true;
   };
}


pub class NormalTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // generic のタイプ
   pri let itemTypeInfoList: List<&TypeInfo> { pub };
   // 引数のタイプ
   pri let argTypeInfoList: List<&TypeInfo> { pub };
   // 戻り値のタイプ
   pri let retTypeInfoList: List<&TypeInfo> { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // タイプの種別
   pri let kind: TypeInfoKind { pub };
   // static かどうか
   pri let staticFlag: bool { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   // コンパイラで自動生成された型情報の場合 true。 accessor 等。
   pri let autoFlag: bool { pub };
   /** */
   pri let abstractFlag: bool { pub };

   // unwrap 後の TypeInfo。 無効な場合は headTypeInfo。
   pri let mut orgTypeInfo: &TypeInfo { pub };
   // 基底クラス。 無効な場合は headTypeInfo。
   pri let baseTypeInfo: &TypeInfo { pub };
   // インタフェースのリスト。
   pri let interfaceList: List<&TypeInfo> { pub };

   // この型が nilable を表わす型かどうか。
   pri let mut nilable: bool { pub };
   // この型の nilable 版の TypeInfo。 無効な場合は headTypeInfo。
   pri let mut nilableTypeInfo: &TypeInfo { pub };
   // このメソッドが mutable かどうか。
   pri let mutable: bool {pub};

   fn __init( abstractFlag:bool, scope: Scope!, baseTypeInfo: TypeInfo!,
              interfaceList: List<&TypeInfo>!, orgTypeInfo: TypeInfo!,
              autoFlag: bool, externalFlag: bool, staticFlag: bool,
              accessMode: AccessMode,
              txt: str, parentInfo: &TypeInfo!, typeId: int, kind: TypeInfoKind,
              itemTypeInfoList: List<&TypeInfo>!, argTypeInfoList:List<&TypeInfo>!,
              retTypeInfoList: List<&TypeInfo>!, mutable: bool! )
   {
      super( scope );

      if type(kind) ~= "number" {
         Util.printStackTrace();
      }
      
      self.abstractFlag = abstractFlag;
      self.baseTypeInfo = unwrap baseTypeInfo default headTypeInfo;
      self.interfaceList = unwrap interfaceList default [];
      self.autoFlag = autoFlag;
      self.externalFlag = externalFlag;
      self.staticFlag = staticFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.kind = kind;
      self.itemTypeInfoList = unwrap itemTypeInfoList default [];
      self.argTypeInfoList = unwrap argTypeInfoList default [];
      self.retTypeInfoList = unwrap retTypeInfoList default [];
      self.orgTypeInfo = unwrap orgTypeInfo default headTypeInfo;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.mutable = mutable and true or false;

      // if dummyRootTypeInfo and not parentInfo {
      //     Util.debugLog();
      //     error( "" );
      // }

      self.typeId = typeId;
      if kind == .Root {
         self.nilable = false;
         // dummyRootTypeInfo = self;
      } 
      elseif txt == "nil" {
         self.nilable = true;
         self.nilableTypeInfo = self;
         self.orgTypeInfo = self;
      } 
      elseif not orgTypeInfo {
         if! parentInfo {
            _exp.addChildren( self );
         }  
         self.nilable = false;

         let mut hasNilable = false;

         switch ( kind ) {
            case .Prim, .List, .Array,
                 .Map, .Class, .Stem, 
                 .Module, .IF   
            {
               hasNilable = true;
            }   
            case .Func, .Method {
               hasNilable = true;
            }
         }  
         if hasNilable {
            if txt == "..." {
               self.nilableTypeInfo = self;
            }
            else {
               // self.nilableTypeInfo = new NormalTypeInfo(
               //    false, nil, baseTypeInfo, interfaceList, self, autoFlag, externalFlag,
               //    staticFlag, accessMode, "", parentInfo, typeId + 1,
               //    .Nilable, itemTypeInfoList,
               //    argTypeInfoList, retTypeInfoList );
               self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
               idProv.increment();
               //typeIdSeed = typeIdSeed + 1;
            }
         }
         else {
            self.nilableTypeInfo = headTypeInfo;
         }
         idProv.increment();
         //typeIdSeed = typeIdSeed + 1;
      } 
      else {
         self.nilable = true;
         self.nilableTypeInfo = headTypeInfo;
      } 
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn getParentId(): int {
      return self.parentInfo.$typeId or rootTypeId;
   }

   pub override fn get_baseId(): int {
      return self.baseTypeInfo.$typeId or rootTypeId;
   }

   pub override fn getTxt(
      fullName:bool!, importInfo:&Map<&TypeInfo,ModuleInfoIF>!, localFlag:bool! ) : str
   {
      let mut parentTxt = "";
      if fullName {
         parentTxt = self.getParentFullName( importInfo, localFlag );
      }
      if self.nilable and (self.nilableTypeInfo ~= self.orgTypeInfo) {
         return parentTxt .. (unwrap self.orgTypeInfo).getTxt( fullName, importInfo, localFlag ) .. "!";
      } 
      // if self.kind == .Array {
      //    let! _exp = self.itemTypeInfoList[1] {
      //       return "[@]";
      //    }; 
      //    return _exp.getTxt() .. "[@]";
      // } 
      // if self.kind == .List {
      //    let! _exp = self.itemTypeInfoList[1] {
      //       return "[]";
      //    }; 
      //    return _exp.getTxt() .. "[]";
      // } 
      if #self.itemTypeInfoList > 0 {
         let mut txt = self.rawTxt .. "<";
         foreach typeInfo, index in self.itemTypeInfoList {
            if index ~= 1 {
               txt = txt .. ",";
            }   
            txt = txt .. typeInfo.getTxt( fullName, importInfo, localFlag );
         }  

         return parentTxt .. txt .. ">";
      } 
      if self.$rawTxt {
         return parentTxt .. self.$rawTxt;
      } 
      return "";
   }

   pub override fn get_display_stirng(): str {
      if self.kind == .Nilable {
         return (unwrap self.orgTypeInfo).get_display_stirng() .. "!";
      }
      if self.kind == .Func or self.kind == .Method
      {
         let mut txt = self.$rawTxt .. "(";
         foreach argType, index in self.argTypeInfoList {
            if index ~= 1 {
               txt = txt .. ", ";
            }
            txt = txt .. argType.get_display_stirng();
         }
         txt = txt .. ")";
         foreach retType, index in self.retTypeInfoList {
            if index == 1 {
               txt = txt .. ": ";
            }
            else {
               txt = txt .. ", ";
            }
            txt = txt .. retType.get_display_stirng();
         }
         return txt;
      }
      return self.getTxt();
   }

   
   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      if self.typeId == rootTypeId {
         return;
      }

      let parentId = self.getParentId();
      if self.nilable {
         stream.write(
            '{ parentId=%d, typeId = %d, nilable = true, orgTypeId = %d }\n' (
               parentId, self.typeId, self.orgTypeInfo.$typeId ) );
         return;
      } 

      fn serializeTypeInfoList( name: str, list: &List<&TypeInfo>, onlyPub: bool! ): str {
         let mut work = name;
         foreach typeInfo in list {
            if not onlyPub or typeInfo.$accessMode == .Pub  {
               if #work ~=  #name {
                  work = work .. ", ";
               }    
               work = "%s%d" (work, typeInfo.$typeId );
            }   
         }  
         return work .. "}, ";
      } 

      let txt = ```{ skind=%d, parentId = %d, typeId = %d, baseId = %d, txt = '%s',
        abstractFlag = %s, staticFlag = %s, accessMode = %d, kind = %d, mutable = %s, ```
          ( SerializeKind.Normal, parentId, self.typeId, self.get_baseId(), self.rawTxt,
            self.abstractFlag, self.staticFlag, self.accessMode, self.kind, self.mutable );

      let mut children:List<&TypeInfo> = [];
      let! set = validChildrenSet {
         set = {};
      };
      foreach child in self.$children {
         if set[ child.$typeId ] {
            children.insert( child );
         }
      }
 
      stream.write(
         txt .. serializeTypeInfoList( "itemTypeId = {",
                                       self.itemTypeInfoList ) ..
         serializeTypeInfoList( "ifList = {", self.interfaceList ) ..
         serializeTypeInfoList( "argTypeId = {", self.argTypeInfoList ) ..
         serializeTypeInfoList( "retTypeId = {", self.retTypeInfoList ) ..
         serializeTypeInfoList( "children = {", children, true ) .. "}\n" );
   }

   pub fn equalsSub( mut typeInfo: &TypeInfo ): bool {
      typeInfo = typeInfo.$srcTypeInfo;

      if self.typeId == typeInfo.$typeId {
         return true;
      }

      // プリミティブな設定のチェック
      if self.kind ~= typeInfo.$kind or
         self.staticFlag ~= typeInfo.$staticFlag or
         self.accessMode ~= typeInfo.$accessMode or
         self.autoFlag ~= typeInfo.$autoFlag or
         self.nilable ~= typeInfo.$nilable or
         self.rawTxt ~= typeInfo.$rawTxt or
         self.parentInfo ~= typeInfo.$parentInfo or
         self.baseTypeInfo ~= typeInfo.$baseTypeInfo or
         self ~= typeInfo.$srcTypeInfo
      { 
         // errorLog( "%s, %s" ( self.externalFlag, typeInfo.externalFlag ) );
         // errorLog( "%s, %s" ( self.kind, typeInfo.kind ) );
         // errorLog( "%s, %s" ( self.staticFlag, typeInfo.staticFlag ) );
         // errorLog( "%s, %s" ( self.accessMode, typeInfo.accessMode ) );
         // errorLog( "%s, %s" ( self.autoFlag, typeInfo.autoFlag ) );
         // errorLog( "%s, %s" ( self.nilable, typeInfo.nilable ) );
         return false;
      }

      if ( self.orgTypeInfo ~= typeInfo.$orgTypeInfo )
      { 
         Util.log( "%s, %s" ( self.orgTypeInfo, typeInfo.$orgTypeInfo ) );
         //          error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
         //                                     typeInfo.getTxt(), typeInfo.typeId ) );
         return false;
      }

      if self.itemTypeInfoList {
         if #self.itemTypeInfoList ~= #typeInfo.$itemTypeInfoList {
            return false;
         }  
         foreach item, index in self.itemTypeInfoList {
            if not item.equals( typeInfo.$itemTypeInfoList[ index ] ) {
               // error( "illegal %s:%d %s:%d"
               //    ( self.getTxt(), self.typeId,
               //      typeInfo.getTxt(), typeInfo.$typeId ) );
               return false;
            }   
         }  
      } 

      if self.retTypeInfoList {
         if #self.retTypeInfoList ~= #typeInfo.$retTypeInfoList {
            // error( "illegal %s:%d %s:%d"
            //    ( self.getTxt(), self.typeId,
            //      typeInfo.getTxt(), typeInfo.$typeId ) );
            return false;
         }  
         foreach item, index in self.retTypeInfoList {
            if not item.equals( typeInfo.$retTypeInfoList[ index ] ) {
               // error( "illegal %s:%d %s:%d"
               //    ( self.getTxt(), self.typeId,
               //      typeInfo.getTxt(), typeInfo.$typeId ) );
               return false;
            }   
         }  
      } 

      if self.orgTypeInfo ~= headTypeInfo and
         not self.orgTypeInfo.equals( typeInfo.$orgTypeInfo )
      {     
         error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
                                        typeInfo.getTxt(), typeInfo.$typeId ) );
      }
      return true;
   }

   pub override fn equals( typeInfo: TypeInfo ): bool {
      return self.equalsSub( typeInfo );
   }


   // pub static fn cloneToPublic( typeInfo: TypeInfo ): NormalTypeInfo {
   //    typeIdSeed = typeIdSeed + 1;
   //    return new NormalTypeInfo(
   //       typeInfo.$scope, typeInfo.$baseTypeInfo, nil, typeInfo.$autoFlag,
   //       typeInfo.$externalFlag, typeInfo.$staticFlag,
   //       "pub", typeInfo.$rawTxt, typeInfo.$parentInfo, typeIdSeed, typeInfo.$kind,
   //       typeInfo.$itemTypeInfoList, typeInfo.$argTypeInfoList,
   //       typeInfo.$retTypeInfoList );
   // }



   pub static fn create(
      accessMode:AccessMode, abstractFlag: bool, scope: Scope!, baseInfo: &TypeInfo,
      interfaceList: List<&TypeInfo>, parentInfo: &TypeInfo, staticFlag: bool,
      kind: TypeInfoKind, txt: str, itemTypeInfo: List<&TypeInfo>,
      argTypeInfoList: List<&TypeInfo>, retTypeInfoList: List<&TypeInfo>,
      mutable: bool! ): &TypeInfo
   {  
      if kind == .Prim {
         if! sym2builtInTypeMap[ txt ] {
            return _exp.$typeInfo;
         }
         Util.err( "not found symbol -- %s" (txt ) );
      }
      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;
      let mut info = new NormalTypeInfo(
         abstractFlag, scope, baseInfo, interfaceList, nil, false, true,
         staticFlag, accessMode, txt, parentInfo, idProv.$id, kind,
         itemTypeInfo, argTypeInfoList, retTypeInfoList, mutable ); 
      return info;
   }

}


//pub let typeInfoRoot = rootTypeInfo;

idProv.increment();
//typeIdSeed = typeIdSeed + 1;

pub static fn NormalTypeInfo.createBuiltin(
   idName: str, typeTxt: str,
   kind: TypeInfoKind, typeDDD: TypeInfo! ): &TypeInfo
{
   //let mut typeId = typeIdSeed + 1;
   let mut typeId = idProv.$id + 1;
   if kind == .Root {
      typeId = rootTypeId;
   } 
   else {
      //typeIdSeed = typeIdSeed + 1;
      idProv.increment();
   } 
   let mut argTypeList:List<&TypeInfo> = [];
   let mut retTypeList:List<&TypeInfo> = [];
   if typeTxt == "form" {
      if! typeDDD {
         argTypeList = [ _exp ];
         retTypeList = [ _exp ];
      }  
   } 

   let mut scope:Scope! = nil;
   switch kind {
      case .List, .Class, .Module,
           .IF, .Func, .Method,
           .Macro
      {  
         scope = new Scope(
            rootScope,
            kind == .Class or kind == .Module or kind == .IF or kind == .List, nil );
      }  
   } 
   
   let mut info = new NormalTypeInfo(
      false, scope, nil, nil, nil, false, false, false, AccessMode.Pub,
      typeTxt, headTypeInfo, typeId,
      kind, [], argTypeList, retTypeList, true );
   if scope {
      rootScope.addClass( typeTxt, info );
   } 

   typeInfoKind[ idName ] = info;
   sym2builtInTypeMap[ typeTxt ] = new NormalSymbolInfo(
      SymbolKind.Typ, false, false,
      rootScope, AccessMode.Pub, false, typeTxt, info, false, true );
   if info.$nilableTypeInfo ~= headTypeInfo {
      sym2builtInTypeMap[ typeTxt .. "!" ] = new NormalSymbolInfo(
         SymbolKind.Typ, false, kind == .Func, rootScope,
         AccessMode.Pub, false, typeTxt, info.$nilableTypeInfo, false, true );
      builtInTypeIdSet[ info.$nilableTypeInfo.$typeId ] = info.$nilableTypeInfo;
   } 
   
   builtInTypeIdSet[ info.typeId ] = info;
   return info;
}

pub static fn NormalTypeInfo.createList(
   accessMode: AccessMode, parentInfo: &TypeInfo, itemTypeInfo: List<&TypeInfo> ): &TypeInfo
{
   if #itemTypeInfo == 0 {
      Util.err( "illegal list type: %s" (itemTypeInfo) );
   } 
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, nil, nil, nil, nil, false, false, false, accessMode, "List",
      headTypeInfo, idProv.$id, .List, itemTypeInfo, nil, nil, true );
}

pub static fn NormalTypeInfo.createArray(
   accessMode: AccessMode,
   parentInfo: &TypeInfo, itemTypeInfo: List<&TypeInfo> ): &TypeInfo
{
   //   typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, nil, nil, nil, nil, false, false, false, accessMode, "Array",
      headTypeInfo, idProv.$id, .Array, itemTypeInfo, nil, nil, true );
}

pub static fn NormalTypeInfo.createMap(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   keyTypeInfo: &TypeInfo, valTypeInfo: &TypeInfo ): &TypeInfo
{
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, nil, nil, nil, nil, false, false, false, accessMode, "Map",
      headTypeInfo, idProv.$id, .Map,
      [ keyTypeInfo, valTypeInfo ], nil, nil, true );
}


pub static fn NormalTypeInfo.createModule(
   scope: Scope, parentInfo: &TypeInfo, externalFlag: bool,
   moduleName: str, mutable:bool ): &TypeInfo
{
   if! sym2builtInTypeMap[ moduleName ] {
      return _exp.$typeInfo;
   }

   if Parser.isLuaKeyword( moduleName ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (moduleName) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new ModuleTypeInfo(
      scope, externalFlag, moduleName, parentInfo, idProv.$id, mutable );
   return info;
}


pub static fn NormalTypeInfo.createClass(
   classFlag: bool, abstractFlag: bool, scope: Scope!,
   baseInfo: TypeInfo!, interfaceList: List<&TypeInfo>!,
   parentInfo: &TypeInfo, externalFlag: bool,
   accessMode: AccessMode, className: str ): &TypeInfo
{
   // if className == "str" {
   //     return sym2builtInTypeMap[ className ]@TypeInfo;
   // }
   if! sym2builtInTypeMap[ className ] {
      return _exp.$typeInfo;
      //return classTypeInfo@TypeInfo;
   }

   if Parser.isLuaKeyword( className ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (className) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new NormalTypeInfo(
      abstractFlag, scope, baseInfo, interfaceList, nil, false,
      externalFlag, false, accessMode,
      className, parentInfo, idProv.$id,
      classFlag and TypeInfoKind.Class or TypeInfoKind.IF, nil, nil, nil, true );
   return info;
}

pub static fn NormalTypeInfo.createFunc(
   abstractFlag: bool, builtinFlag:bool, scope: Scope!, kind: TypeInfoKind,
   parentInfo: &TypeInfo, autoFlag: bool, externalFlag: bool,
   staticFlag: bool, accessMode: AccessMode, funcName: str, argTypeList: List<&TypeInfo>!,
   retTypeInfoList: List<&TypeInfo>!, mutable: bool! ): &TypeInfo
{
   if not builtinFlag and Parser.isLuaKeyword( funcName ) {
      Util.err( "This symbol can not use for a function. -- %s" (funcName) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new NormalTypeInfo(
      abstractFlag, scope, nil, nil, nil, autoFlag, externalFlag, staticFlag,
      accessMode, funcName, parentInfo, idProv.$id,
      kind, [], unwrap argTypeList default [],
      unwrap retTypeInfoList default [], mutable );
   return info;
}

pub static fn NormalTypeInfo.createAdvertiseMethodFrom(
   classTypeInfo:&TypeInfo, typeInfo:&TypeInfo ): &TypeInfo
{
   return NormalTypeInfo.createFunc(
      false, false, typeInfo.$scope, typeInfo.$kind,
      classTypeInfo, true, false, false, typeInfo.$accessMode, typeInfo.$rawTxt,
      typeInfo.$argTypeInfoList, typeInfo.$retTypeInfoList, typeInfo.$mutable );
}


let mut typeInfo2ModifierMap:Map<&TypeInfo,TypeInfo> = {};

pub static fn NormalTypeInfo.createModifier(
   srcTypeInfo: &TypeInfo, mutable: bool ): &TypeInfo
{
   if! typeInfo2ModifierMap[ srcTypeInfo ] {
      if _exp.$typeId < userStartId and srcTypeInfo.$typeId >= userStartId {
         Util.err( "on cache" );
      }  
      return _exp;
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let modifier = new ModifierTypeInfo( srcTypeInfo, idProv.$id, mutable ); 
   typeInfo2ModifierMap[ srcTypeInfo ] = modifier;
   if modifier.$typeId < userStartId and srcTypeInfo.$typeId >= userStartId {
      Util.printStackTrace();
      Util.err( "off cache: %s %s %s"
                (srcTypeInfo.getTxt(), modifier.$typeId, srcTypeInfo.$typeId));
   }
   return modifier;
}

pub override fn ModifierTypeInfo.get_orgTypeInfo(): &TypeInfo {
   let orgType = self.srcTypeInfo.$orgTypeInfo;
   if self.mutable or not orgType.$mutable {
      return orgType;
   }
   return NormalTypeInfo.createModifier( orgType, false );
}


pub let builtinTypeNone:TypeInfo = 
   NormalTypeInfo.createBuiltin( "None", "", .Prim );
pub let builtinTypeNeverRet:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Error", "__", .Prim );
pub let builtinTypeStem:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Stem", "stem" , .Stem );
pub let builtinTypeNil:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Nil", "nil" , .Prim );
pub let builtinTypeDDD:TypeInfo =
   NormalTypeInfo.createBuiltin( "DDD", "..." , .Prim );
pub let builtinTypeBool:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Bool", "bool" , .Prim );
pub let builtinTypeInt:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Int", "int" , .Prim );
pub let builtinTypeReal:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Real", "real" , .Prim );
pub let builtinTypeChar:TypeInfo = 
   NormalTypeInfo.createBuiltin( "char", "char" , .Prim );
pub let builtinTypeString:TypeInfo = 
   NormalTypeInfo.createBuiltin( "String", "str" , .Class );
pub let builtinTypeMap:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Map", "Map" , .Map );
pub let builtinTypeList:TypeInfo = 
   NormalTypeInfo.createBuiltin( "List", "List" , .List );
pub let builtinTypeArray:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Array", "Array" , .Array );
pub let builtinTypeForm:TypeInfo =
   NormalTypeInfo.createBuiltin( "Form", "form" , .Func, builtinTypeDDD );
pub let builtinTypeSymbol:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Symbol", "sym" , .Prim );
pub let builtinTypeStat:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Stat", "stat" , .Prim );

pub let builtinTypeStem_ = unwrap builtinTypeStem.$nilableTypeInfo;

let mut numberTypeMap:Map<&TypeInfo,bool> = {};
numberTypeMap[ builtinTypeInt ] = true;
numberTypeMap[ builtinTypeChar ] = true;
numberTypeMap[ builtinTypeReal ] = true;

pub fn isNumberType( typeInfo:&TypeInfo ): bool {
   return numberTypeMap[ typeInfo.$srcTypeInfo ] and true or false;
}


pub static fn NormalTypeInfo.createEnum(
   scope: Scope, parentInfo: &TypeInfo, externalFlag: bool,
   accessMode: AccessMode, enumName: str, valTypeInfo:&TypeInfo, 
   name2EnumValInfo:Map<str,EnumValInfo> ): &TypeInfo
{
   if Parser.isLuaKeyword( enumName ) {
      Util.err( "This symbol can not use for a enum. -- %s"
                (enumName) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new EnumTypeInfo(
      scope, externalFlag, accessMode, enumName,
      parentInfo, idProv.$id, valTypeInfo, name2EnumValInfo );

   let mut getEnumName = NormalTypeInfo.createFunc(
      false, true, nil, .Method, info,
      true, true, false, AccessMode.Pub,
      "get__txt", nil, [ builtinTypeString ], false );
   scope.addMethod( getEnumName, AccessMode.Pub, false, false );

   let mut fromVal = NormalTypeInfo.createFunc(
      false, true, nil, .Func, info,
      true, true, true, AccessMode.Pub,
      "_from", [ NormalTypeInfo.createModifier( valTypeInfo,false ) ],
      [ info.$nilableTypeInfo ], false );
   scope.addFunc( fromVal, AccessMode.Pub, true, false );

   let allListType = NormalTypeInfo.createList( .Pub, info, [ info ] );
   let mut allList = NormalTypeInfo.createFunc(
      false, true, nil, .Func, info,
      true, true, true, AccessMode.Pub,
      "get__allList", [],
      [ NormalTypeInfo.createModifier( allListType, false ) ], false );
   scope.addFunc( allList, AccessMode.Pub, true, false );
   
   return info;
}

pub override fn EnumTypeInfo.serialize(
   stream: oStream, validChildrenSet: Map<int,&TypeInfo>! )
{
   let txt = ```{ skind = %d, parentId = %d, typeId = %d, txt = '%s',
accessMode = %d, kind = %d, valTypeId = %d, ```
       ( SerializeKind.Enum, self.getParentId(), self.typeId, self.rawTxt,
         self.accessMode, TypeInfoKind.Enum, self.valTypeInfo.$typeId );
   stream.write( txt );

   stream.write( "enumValList = {" );
   forsort enumValInfo in self.name2EnumValInfo {
      if self.valTypeInfo.equals( builtinTypeString ) {
         stream.write( "%s = '%s'," (enumValInfo.$name, enumValInfo.$val) );
      }
      else {
         stream.write( "%s = %s," (enumValInfo.$name, enumValInfo.$val) );
      }
   }
   stream.write( "} }\n" );
}




// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NilableTypeInfo.canEvalWith( other:&TypeInfo, opTxt:str ): bool {
   let otherSrc = other.$srcTypeInfo;

   if self == builtinTypeStem_ {
      return true;
   }  
   if otherSrc == builtinTypeNil {
      return true;
   }  
   if self.typeId == otherSrc.$typeId {
      return true;
   }
   if otherSrc.$nilable {
      return self.$orgTypeInfo.canEvalWith( otherSrc.$orgTypeInfo, opTxt );
   }
   return self.$orgTypeInfo.canEvalWith( otherSrc, opTxt );
}
   
macro checkEqualsItemType( type1:sym, type2:sym, index:int ) {
   if not (unwrap ,,type1.$itemTypeInfoList[ ,,index ]).canEvalWith(
      unwrap ,,type2.$itemTypeInfoList[ ,,index ], "=" )
   {
      return false;
   }
};

// other のクラスが、この型のクラスの継承関係にあるか調べる
pub override fn NormalTypeInfo.isInheritFrom( other:&TypeInfo ) : bool
{
   let otherTypeId = other.$typeId;
   if self.$typeId == otherTypeId {
      return true;
   }
   if ( self.$kind ~= .Class and self.$kind ~= .IF ) or
      ( other.$kind ~= .Class and other.$kind ~= .IF )
   {  
      return false;
   }
   let mut baseTypeInfo = self.$baseTypeInfo;
   if baseTypeInfo ~= headTypeInfo {
      if baseTypeInfo.isInheritFrom( other ) {
         return true;
      }
   };
   foreach ifType in self.$interfaceList {
      if ifType.isInheritFrom( other ) {
         return true;
      }
   }
   return false;
}


pub static fn TypeInfo.checkMatchType(
   dstTypeList: &List<&TypeInfo>,
   expTypeList: &List<&TypeInfo>, allowDstShort:bool ) : bool, str
{
   if #expTypeList > 0 {
      foreach expType, index in expTypeList {
         if #dstTypeList == 0 {
            return false, "over exp. expect:0, actual:%d" ( #expTypeList);
         }
         let argType = dstTypeList[ index ];
         if #dstTypeList == index {
            if not argType.equals( builtinTypeDDD ) {
               if not argType.canEvalWith( expType, "=" ) {
                  return false, "exp(%d) type mismatch %s <- %s"
                  ( index, argType.getTxt( true ),
                    expType.getTxt(true ));
               }
               if not allowDstShort and #dstTypeList < #expTypeList {
                  return false, "over exp. expect: %d: actual: %d"
                  (#dstTypeList, #expTypeList );
               }
            }
            break;
         }
         elseif #expTypeList == index {
            // 最終実引数処理
            if expType.equals( builtinTypeDDD ) {
               for argIndex = index, #dstTypeList {
                  let workArgType = dstTypeList[ argIndex ];
                  if not workArgType.canEvalWith( builtinTypeStem_, "=" ) {
                     return false, "exp(%d) type mismatch %s <- %s"
                     ( argIndex, workArgType.getTxt( true ),
                       builtinTypeStem_.getTxt());
                  }
               }
            }
            else {
               let mut workExpType = expType;
               for argIndex = index, #dstTypeList {
                  let argTypeInfo = dstTypeList[ argIndex ];
                  if not argTypeInfo.canEvalWith( workExpType, "=" ) {
                     return false, "exp(%d) type mismatch %s <- %s"
                     ( argIndex, argTypeInfo.getTxt( true ),
                       workExpType.getTxt( true ) );
                  }
                  workExpType = builtinTypeNil;
               }
            }
            break;
         }
         else {
            if not argType.canEvalWith( expType, "=" ) {
               return false, "exp(%d) type mismatch %s <- %s"
               ( index, argType.getTxt( true ),
                 expType.getTxt( true ));
            }  
         }  
      }
   }
   elseif not allowDstShort {
      foreach argType, index in dstTypeList {
         if not argType.canEvalWith( builtinTypeNil, "=" ) {
            return false, "exp(%d) type mismatch %s <- nil"
            ( index, argType.getTxt( true ));
         }
      }
   }
   return true, "";
}

pub static fn TypeInfo.canEvalWithBase(
   dist:&TypeInfo, distMut:bool, other:&TypeInfo, opTxt:str ) : bool
{
   let otherMut = other.$mutable;
   let otherSrc = other.$srcTypeInfo;

   if opTxt == "=" and
      otherSrc ~= builtinTypeNil and
      otherSrc ~= builtinTypeString and
      otherSrc.$kind ~= .Prim and
      otherSrc.$kind ~= .Func and
      otherSrc.$kind ~= .Enum and
      distMut and not otherMut
   {
      return false;
   }
   
   if dist == builtinTypeStem_ or dist == builtinTypeDDD {
      return true;
   }
   if not dist.$nilable and otherSrc.$nilable {
      return false;
   }
   if dist == builtinTypeStem and not otherSrc.$nilable {
      return true;
   }
   if dist == builtinTypeForm and otherSrc.$kind == .Func {
      return true;
   }
   if otherSrc == builtinTypeNil {
      if dist.$kind ~= .Nilable {
         return false;
      } 
      return true;
   }
   if dist.$typeId == otherSrc.$typeId {
      return true;
   }
   if dist.$kind ~= otherSrc.$kind {
      if dist.$kind == .Nilable {
         if otherSrc.$nilable {
            return dist.$orgTypeInfo.canEvalWith( otherSrc.$orgTypeInfo, opTxt );
         }
         return dist.$orgTypeInfo.canEvalWith( otherSrc, opTxt );
      }
      elseif ( dist.$kind == .Class or dist.$kind == .IF ) and
         ( otherSrc.$kind == .Class or otherSrc.$kind == .IF )
      {
         return otherSrc.isInheritFrom( dist );
      }
      elseif otherSrc.$kind == .Enum {
         let enumTypeInfo = otherSrc@@EnumTypeInfo;
         return dist.$canEvalWith( enumTypeInfo.$valTypeInfo, opTxt );
      }
      return false;
   }
   // TypeInfoKind が等しい
   switch ( dist.$kind ) {
      case .Prim {
         if dist == builtinTypeInt and otherSrc == builtinTypeChar or
            dist == builtinTypeChar and otherSrc == builtinTypeInt
         {  
            return true;
         }
         // int から real の代入を暗黙変換を許可すると
         // [ 1, 1.0 ] の型が List<stem> ではなく List<real> なってしまうので
         // 許可しない。
         // if dist == builtinTypeReal and
         //     ( otherSrc == builtinTypeInt or otherSrc == builtinTypeChar )
         // {
         //    return true;
         // }
         return false;
      }       
      case .List, .Array {
         if otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone {
            // literalMap の [], [@] は互換有りとする
            return true;
         }  
         checkEqualsItemType( dist, otherSrc, 1 );
         return true;
      }       
      case .Map {
         if otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone and
            otherSrc.$itemTypeInfoList[ 2 ] == builtinTypeNone
         {  
            // literalMap の {} は互換有りとする
            return true;
         }  
         checkEqualsItemType( dist, otherSrc, 1 );
         checkEqualsItemType( dist, otherSrc, 2 );
         return true;
      }       
      case .Class, .IF {
         return otherSrc.isInheritFrom( dist );
      }       
      case .Func {
         if dist == builtinTypeForm {
            return true;
         }  
         if not TypeInfo.checkMatchType( dist.$argTypeInfoList,
                                         otherSrc.$argTypeInfoList, false ) or
            not TypeInfo.checkMatchType( dist.$retTypeInfoList,
                                         otherSrc.$retTypeInfoList, false ) or
            #dist.$retTypeInfoList ~= #otherSrc.$retTypeInfoList
         {
            return false;
         }
         return true;
      }       
      case .Method {
         if not TypeInfo.checkMatchType( dist.$argTypeInfoList,
                                         otherSrc.$argTypeInfoList, false ) or
            not TypeInfo.checkMatchType( dist.$retTypeInfoList,
                                         otherSrc.$retTypeInfoList, false ) or
            #dist.$retTypeInfoList ~= #otherSrc.$retTypeInfoList
         {
            return false;
         }
         return true;
      }
      case .Nilable {
         return dist.$orgTypeInfo.canEvalWith( otherSrc.$orgTypeInfo, opTxt );
      }
      default {
         return false;
      } 
   }
}


// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NormalTypeInfo.canEvalWith( other:&TypeInfo, opTxt:str ) : bool {
   return TypeInfo.canEvalWithBase( self, self.$mutable, other, opTxt );
}


pub class Filter {
}


/**
制御中断要因。

優先度の高い順に宣言する。
*/
pub enum BreakKind {
   None,
   Break,
   Return,
   NeverRet,
}

pub enum CheckBreakMode {
   /** フローを解析する */
   Normal,
   /** フローを解析する (return 有無の解析)  */
   Return,
   /** フローを解析しない */
   IgnoreFlow,
   /** フローを解析しない (return 有無の解析) */
   IgnoreFlowReturn,
}

pub class Node {
   pri let kind: int { pub };
   pri let pos: &Parser.Position { pub };
   pri let expTypeList: &List<&TypeInfo> { pub };

   pub fn get_expType(): &TypeInfo {
      if #self.expTypeList == 0 {
         return builtinTypeNone;
      }
      return self.expTypeList[ 1 ];
   }; 
   
   pub fn getLiteral(): stem![], List<&TypeInfo> {
      return [nil], [builtinTypeNil];
   }
   pub fn processFilter( filter: Filter, ... ) {
   }

   /** 代入式の左辺になれるかどうか */
   pub fn canBeLeft(): bool {
      return false;
   };     
   /** 代入式の右辺になれるかどうか */
   pub fn canBeRight(): bool {
      return false;
   }
   /** 単体で文になれるかどうか */
   pub fn canBeStatement(): bool {
      return false;
   }
   /**
制御の中断種別を得る。

全てのケースで return で終っている場合や、 error() などをコールしている場合など。

@param checkMode モード
*/
   pub fn getBreakKind( checkMode:CheckBreakMode ): BreakKind {
      return .None;
   }
}



pub class NamespaceInfo {
   pub let name: str;
   pub let scope: Scope;
   pub let typeInfo: &TypeInfo;
}


pub proto abstract class MacroEval;
pub proto class ExpListNode extend Node;
pub proto class DeclArgNode extend Node;

pub class DeclMacroInfo {
   pri let name: &Parser.Token { pub };
   pri let argList: List<&DeclArgNode> { pub };
   pri let ast: &Node! { pub };
   pri let tokenList: List<&Parser.Token> { pub };
}

pub class MacroValInfo {
   pub let val: stem!;
   pub let typeInfo: TypeInfo;
}

pub class MacroInfo {
   pub let func: form;
   pub let declInfo: DeclMacroInfo;
   pub let symbol2MacroValInfoMap: Map<str,MacroValInfo>;
}

let mut nodeKind2NameMap: Map<int,str> = {};
let mut nodeKindSeed = 1;
pub let mut nodeKind: Map<str,int> = {};

fn regKind( name:str ): int {
   let kind = nodeKindSeed;
   nodeKindSeed = nodeKindSeed + 1;
   nodeKind2NameMap[ kind ] = name;
   nodeKind[ name ] = kind;
   return kind;
}

pub fn getNodeKindName( kind: int ): str {
   return unwrap nodeKind2NameMap[ kind ];
}

// let nodeKindNone = regKind( 'None' );
// let nodeKindImport = regKind( 'Import' );
// let nodeKindRoot = regKind( 'Root' );
// let nodeKindRefType = regKind( 'RefType' );
// let nodeKindIf = regKind( 'If' );
// let nodeKindSwitch = regKind( 'Switch' );
// let nodeKindWhile = regKind( 'While' );
// let nodeKindRepeat = regKind( 'Repeat' );
// let nodeKindFor = regKind( 'For' );
// let nodeKindApply = regKind( 'Apply' );
// let nodeKindForeach = regKind( 'Foreach' );
// let nodeKindForsort = regKind( 'Forsort' );
// let nodeKindReturn = regKind( 'Return' );
// let nodeKindBreak = regKind( 'Break' );
// let nodeKindExpNew = regKind( 'ExpNew' );
// let nodeKindExpList = regKind( 'ExpList' );
// let nodeKindExpRef = regKind( 'ExpRef' );
// let nodeKindExpOp2 = regKind( 'ExpOp2' );
// let nodeKindExpCast = regKind( 'ExpCast' );
// let nodeKindExpOp1 = regKind( 'ExpOp1' );
// let nodeKindExpRefItem = regKind( 'ExpRefItem' );
// let nodeKindExpCall = regKind( 'ExpCall' );
// let nodeKindExpCallSuper = regKind( 'ExpCallSuper' );
// let nodeKindExpDDD = regKind( 'ExpDDD' );
// let nodeKindExpParen = regKind( 'ExpParen' );
// let nodeKindExpMacroExp = regKind( 'ExpMacroExp' ); // macro expand
// let nodeKindExpMacroStat = regKind( 'ExpMacroStat' ); // `{}
// let nodeKindBlock = regKind( 'Block' );
// let nodeKindStmtExp = regKind( 'StmtExp' );
// let nodeKindRefField = regKind( 'RefField' );
// let nodeKindDeclVar = regKind( 'DeclVar' );
// let nodeKindDeclFunc = regKind( 'DeclFunc' );
// let nodeKindDeclMethod = regKind( 'DeclMethod' );
// let nodeKindDeclConstr = regKind( 'DeclConstr' );
// let nodeKindDeclMember = regKind( 'DeclMember' );
// let nodeKindDeclArg = regKind( 'DeclArg' );
// let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
// let nodeKindDeclClass = regKind( 'DeclClass' );
// let nodeKindDeclMacro = regKind( 'DeclMacro' );
// let nodeKindLiteralNil = regKind( 'LiteralNil' );
// let nodeKindLiteralChar = regKind( 'LiteralChar' );
// let nodeKindLiteralInt = regKind( 'LiteralInt' );
// let nodeKindLiteralReal = regKind( 'LiteralReal' );
// let nodeKindLiteralArray = regKind( 'LiteralArray' );
// let nodeKindLiteralList = regKind( 'LiteralList' );
// let nodeKindLiteralMap = regKind( 'LiteralMap' );
// let nodeKindLiteralString = regKind( 'LiteralString' );
// let nodeKindLiteralBool = regKind( 'LiteralBool' );
// let nodeKindLiteralSymbol = regKind( 'LiteralSymbol' );

pub class NodeManager {
   let mut nodeKind2NodeList:Map<int,List<&Node>>;

   pub fn __init() {
      self.nodeKind2NodeList = {};
   }

   pub fn getList(kind:int) : &List<&Node>! {
      return self.nodeKind2NodeList[ kind ];
   }
   pub fn addNode(node:&Node) mut {
      let! mut list = self.nodeKind2NodeList[ node.$kind ] {
         list = [];
         self.nodeKind2NodeList[ node.$kind ] = list;
      };
      list.insert( node );
   }
}

pub class NodeKind {
}


macro _declNodeClass(
   baseName:str, super:sym, canBeLeftFlag:bool!, canBeRightFlag:bool!,
   canBeStatementFlag:bool!, fieldInfoList:Map<str,str>[] )
{
   {
      let _className = ,,,"%sNode" (baseName);
      let _nodeKindSym = ,,,"%s" (baseName);
      let _nodeKindGetter = ,,,"get_%s" (baseName);

      let mut fieldStatList:stat[] = [];
      let mut argList:stat[] = [];
      let mut argSymList:stat[] = [];
      let mut initStatList:stat[] = [];
      let mut relateStat:stat[] = [];
      
      if fieldInfoList {
         foreach fieldInfo in fieldInfoList {
            foreach typeName, varName in fieldInfo {
               fieldStatList.insert( `{
                  pri let mut ,,,varName : ,,,typeName { pub };
               });  
               argList.insert( `{ ,,,varName: ,,,typeName, } );
               argSymList.insert( `{, ,,,varName } );
               initStatList.insert( `{ self.,,,varName = ,,,varName; } );
            }   
         }  
      } 

      fieldStatList.insert( `{
         pub override fn processFilter( filter: Filter, ... ) {
            let argList:stem[] = [ ... ];

            filter.,,,"process%s" (baseName) (self, table.unpack( argList ) );
         } } );

      if! canBeRightFlag {
         fieldStatList.insert( `{
            pub override fn canBeRight():bool {
               return ,,, canBeRightFlag;
            } } );
      }
      if! canBeLeftFlag {
         fieldStatList.insert( `{
            pub override fn canBeLeft():bool {
               return ,,, canBeLeftFlag;
            } } );
      }
      if! canBeStatementFlag {
         fieldStatList.insert( `{
            pub override fn canBeStatement():bool {
               return ,,, canBeStatementFlag;
            } } );
      }
      
      let superStat = `{
         super( unwrap nodeKind. ,,_nodeKindSym, pos, typeList );
      };

      relateStat.insert( `{
         pub fn Filter. ,,,"process%s" (baseName) ( node: &,,_className, ... ) mut {
         };
         pub fn NodeManager. ,,,"get%sList" (,,,,_className) () : &List<&,,_className>! {
            return self.getList( unwrap nodeKind. ,,_nodeKindSym )@@List<&,,_className> !;
         }
      } );
      
   }

   pub static fn NodeKind.,,_nodeKindGetter (): int {
      return unwrap nodeKind. ,,_nodeKindSym;
   }
   
   pub proto class ,,_className extend ,,super;
   regKind( ,,baseName );
   ,,relateStat;
   pub class ,,_className extend ,,super {
      ,,fieldStatList;
      pro fn __init( pos: &Parser.Position, typeList: &List<&TypeInfo>, ,,argList ) {
         ,,superStat;
         ,,initStatList;
      }
      pub static fn create( nodeMan:NodeManager, pos: &Parser.Position,
                            typeList: &List<&TypeInfo>, ,,argList ) : ,,_className
      {
         let mut node = new ,,_className( pos, typeList ,,argSymList );
         nodeMan.addNode( node );
         return node;
      }
   }
}

_declNodeClass( "None", Node, false, false, true, []);
_declNodeClass( "Subfile", Node, false, false, true,
                [ { "usePath": "str!" } ]);
_declNodeClass( "Import", Node, false, false, true,
                [ { "modulePath": "str" },
                  { "assignName": "str" },
                  { "moduleTypeInfo": "&TypeInfo" } ]
);


pub proto class ProvideNode extend Node;

pub class LuneHelperInfo {
   pri let useNilAccess:bool { pub };
   pri let useUnwrapExp:bool { pub };
   pri let hasMappingClassDef:bool { pub };
}

pub class ModuleInfo extend (ModuleInfoIF) {
   pri let fullName:str{ pub };
   pri let localTypeInfo2importIdMap:Map<&TypeInfo,int> { pub };
   pri let mut importId2localTypeInfoMap:Map<int,&TypeInfo> { pub& };
   pri let assignName:str{ pub };

   pub fn __init( fullName:str, assignName:str, idMap:Map<&TypeInfo,int> ) {
      self.fullName = fullName;
      self.assignName = assignName;
      self.localTypeInfo2importIdMap = idMap;
      self.importId2localTypeInfoMap = {};
      foreach importId, typeInfo in idMap {
         self.importId2localTypeInfoMap[ importId ] = typeInfo;
      }
   }

   pub fn get_modulePath(): str {
      return self.fullName;
   }
}

pub fn TypeInfo.getFullName( importInfo:&Map<&TypeInfo,ModuleInfoIF>, localFlag:bool! ) : str {
   return self.getParentFullName( importInfo, localFlag ) .. self.$rawTxt;
}


pub class ProcessInfo {
   pub let mut typeInfo2ModifierMap:Map<&TypeInfo,TypeInfo>;
   pub let mut idProvier:IdProvider;
}

_declNodeClass( "Root", Node, false, false, false,
                [ { "children": "List<&Node>" },
                  { "processInfo": "ProcessInfo" },
                  { "moduleTypeInfo": "&TypeInfo" },
                  { "provideNode": "&ProvideNode!" },
                  { "luneHelperInfo": "LuneHelperInfo" },
                  { "nodeManager": "NodeManager" },
                  { "importModule2moduleInfo": "Map<&TypeInfo,ModuleInfo>" },
                  { "typeId2ClassMap": "Map<int,&NamespaceInfo>" } ]
);

pub fn RootNode.set_provide( node: ProvideNode ) mut {
   self.provideNode = node;
}

_declNodeClass( "RefType", Node, false, false, false,
                [ { "name": "&Node" },
                  { "refFlag": "bool" },
                  { "mutFlag": "bool" },
                  { "array": "str" } ]
);

pub enum BlockKind {
   If,
   Elseif,
   Else,
   While,
   Switch,
   Repeat,
   For,
   Apply,
   Foreach,
   Macro,
   Func,
   Default,
   Block,
   Macro,
   LetUnwrap,
   IfUnwrap,
   When,
}

_declNodeClass( "Block", Node, false, false, true,
                [ { "blockKind": "BlockKind" },
                  { "stmtList": "List<&Node>" } ]
);


macro _setBreakKind(work:sym, kind:sym, returnNoneStat:bool, checkMode:sym ) {
   {
      let mut noneStat:stat[] = [];
      if returnNoneStat {
         noneStat.insert( `{ return .None } );
      }
   }

   if ,,checkMode == .IgnoreFlowReturn {
      if ,, work == .Return {
         return .Return;
      }
      if ,, work == .NeverRet {
         return .NeverRet;
      }
   }
   else {
      switch ,,work {
         case .None {
            if ,,checkMode == .Normal or ,,checkMode == .Return {
               ,,noneStat;
            }
         }
         default {
            if ,,kind == .None or ,,kind > work {
               kind = work;               
            }
         }
      }
   }
}


pub override fn BlockNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in self.stmtList {
         let work = stmt.getBreakKind( checkMode );
         _setBreakKind(work, kind, false, checkMode );
      }
      return kind;
   }
   else {
      if #self.stmtList > 0 {
         let node = self.stmtList[ #self.stmtList ];
         return node.getBreakKind( checkMode );
      }
   }
   return .None;
}

pub enum IfKind {
   If,
   ElseIf,
   Else,
}

pub class IfStmtInfo {
   pri let kind: IfKind { pub };
   pri let exp: Node { pub };
   pri let block: BlockNode { pub };
}
_declNodeClass( "If", Node, false, false, true,
                [{ "stmtList": "IfStmtInfo[]" } ]
);


pub override fn IfNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut hasElseFlag = false;
   let mut kind = BreakKind.None;
   foreach stmtInfo in self.stmtList {
      let work = stmtInfo.$block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      if stmtInfo.$kind == .Else {
         hasElseFlag = true;
      }
   }
   if hasElseFlag or ( checkMode ~= .Normal and checkMode ~= .Return ) {
      return kind;
   }
   
   return .None;
}


_declNodeClass( "ExpList", Node, nil, nil, false,
                [ { "expList": "List<&Node>" } ]
);
pub override fn ExpListNode.canBeLeft():bool {
   foreach expNode in self.$expList {
      if not expNode.canBeLeft() {
         return false;
      }
   }
   return true;
}
pub override fn ExpListNode.canBeRight():bool {
   foreach expNode in self.$expList {
      if not expNode.canBeRight() {
         return false;
      }
   }
   return true;
}


pub class CaseInfo {
   pri let expList: ExpListNode { pub };
   pri let block: BlockNode { pub };
}
_declNodeClass( "Switch", Node, false, false, true,
                [ { "exp": "&Node" },
                  { "caseList": "CaseInfo[]" },
                  { "default": "&BlockNode!" } ]
);

pub override fn SwitchNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   let mut kind = BreakKind.None;
   foreach caseInfo in self.caseList {
      let work = caseInfo.$block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
   }
   if! let block = self.default {
      let work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }

   return .None;
}


macro _declLoopGetBreakKind( node:sym, blockMem:sym ) {

   pub override fn ,,node.getBreakKind( checkMode:CheckBreakMode ): BreakKind
   {  
      let mut kind = BreakKind.None;
      if checkMode ~= .Normal and checkMode ~= .Return {
         return self. ,,blockMem .getBreakKind( checkMode );
      }
      return .None;
   }  
}

_declNodeClass( "While", Node, false, false, true,
                [ { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declNodeClass( "Repeat", Node, false, false, true,
                [ { "block": "&BlockNode" },
                  { "exp": "&Node" } ]
);

_declLoopGetBreakKind( RepeatNode, block );

_declNodeClass( "For", Node, false, false, true,
                [ { "block": "&BlockNode" },
                  { "val": "&Parser.Token" },
                  { "init": "&Node" },
                  { "to": "&Node" },
                  { "delta": "&Node!" }] 
);

_declLoopGetBreakKind( ForNode, block );


_declNodeClass( "Apply", Node, false, false, true,
                [ { "varList": "List<&Parser.Token>" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declLoopGetBreakKind( ApplyNode, block );


_declNodeClass( "Foreach", Node, false, false, true,
                [ { "val": "&Parser.Token" },
                  { "key": "&Parser.Token!" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declLoopGetBreakKind( ForeachNode, block );


_declNodeClass( "Forsort", Node, false, false, true,
                [ { "val": "&Parser.Token" },
                  { "key": "&Parser.Token!" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" },
                  { "sort": "bool" } ]
);

_declLoopGetBreakKind( ForsortNode, block );


_declNodeClass( "Return", Node, false, false, true,
                [ { "expList": "&ExpListNode!" } ]
);
pub override fn ReturnNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   return .Return;
}

_declNodeClass( "Break", Node, false, false, true, [] );

pub override fn BreakNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   return .Break;
}

_declNodeClass( "Provide", Node, false, false, true,
                [ { "symbol": "&SymbolInfo" } ]
);

_declNodeClass( "ExpNew", Node, false, true, true,
                [ { "symbol": "&Node" },
                  { "argList": "&ExpListNode!" } ]
);

_declNodeClass( "ExpUnwrap", Node, false, true, false,
                [ { "exp": "&Node" },
                  { "default": "&Node!" } ]
);

_declNodeClass( "ExpRef", Node, nil, nil, false,
                [ { "token": "&Parser.Token" },
                  { "symbolInfo": "&AccessSymbolInfo" } ]
);

pub override fn ExpRefNode.canBeLeft():bool {
   return self.$symbolInfo.$canBeLeft;
}

pub override fn ExpRefNode.canBeRight():bool {
   return self.$symbolInfo.$canBeRight;
}

_declNodeClass( "ExpOp2", Node, false, true, nil,
                [ { "op": "&Parser.Token" },
                  { "exp1": "&Node" },
                  { "exp2": "&Node" } ]
);

pub override fn ExpOp2Node.canBeStatement():bool {
   return self.$op.txt == '=';
}


_declNodeClass( "UnwrapSet", Node, false, false, true,
                [ { "dstExpList": "&ExpListNode" },
                  { "srcExpList": "&ExpListNode" },
                  { "unwrapBlock": "&BlockNode!" } ]              
);

_declNodeClass( "IfUnwrap", Node, false, false, true,
                [ { "varNameList": "List<str>" },
                  { "expNodeList": "List<&Node>" },
                  { "block": "&BlockNode" },
                  { "nilBlock": "&BlockNode!" } ]
);

pub override fn IfUnwrapNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut kind = self.block.getBreakKind( checkMode );
   let mut work = kind;
   _setBreakKind( work, kind, true, checkMode );
   if! let block = self.nilBlock {
      work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }
   return .None;
}


_declNodeClass( "When", Node, false, false, true,
                [ { "varNameList": "List<&str>" },
                  { "expNodeList": "List<&Node>" },
                  { "block": "&BlockNode" },
                  { "elseBlock": "&BlockNode!" } ]
);

pub override fn WhenNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut kind = self.block.getBreakKind( checkMode );
   let mut work = kind;
   _setBreakKind( work, kind, true, checkMode );
   if! let block = self.elseBlock {
      work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }
   return .None;
}


_declNodeClass( "ExpCast", Node, false, true, false,
                [ { "exp": "&Node" } ]
);

pub enum MacroMode {
   None,
   Expand,
   Analyze,
}

_declNodeClass( "ExpOp1", Node, false, true, false,
                [ { "op": "&Parser.Token" },
                  { "macroMode": "MacroMode" },
                  { "exp": "&Node" } ]
);

_declNodeClass( "ExpRefItem", Node, nil, true, false,
                [ { "val": "&Node" },
                  { "nilAccess": "bool" },
                  { "symbol": "str!" },
                  { "index": "&Node!" } ]
);
pub override fn ExpRefItemNode.canBeLeft(): bool {
   if self.val.$expType == builtinTypeStem {
      return false;
   }
   //return self.$expType.$mutable;
   return self.$val.$expType.$mutable and not self.nilAccess;
}

_declNodeClass( "ExpCall", Node, false, true, true,
                [ { "func": "&Node" },
                  { "errorFunc": "bool" },
                  { "nilAccess": "bool" },
                  { "argList": "&ExpListNode!" } ]
);

pub override fn ExpCallNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   if self.errorFunc {
      return .NeverRet;
   }
   return .None;
}


_declNodeClass( "ExpDDD", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

_declNodeClass( "ExpParen", Node, false, true, false,
                [ { "exp": "&Node" } ]
);

_declNodeClass( "ExpMacroExp", Node, false, false, true,
                [ { "stmtList": "List<&Node>" } ]
);

pub override fn ExpMacroExpNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in self.stmtList {
         let work = stmt.getBreakKind( checkMode );
         _setBreakKind(work, kind, false, checkMode );
      }
      return kind;
   }
   else {
      if #self.stmtList > 0 {
         return self.stmtList[ #self.stmtList ].getBreakKind( checkMode );
      }
   }
   return .None;
}


_declNodeClass( "ExpMacroStat", Node, false, true, false,
                [ { "expStrList": "List<&Node>" } ]
);

_declNodeClass( "StmtExp", Node, false, true, nil,
                [ { "exp": "&Node" } ]
);
pub override fn StmtExpNode.canBeStatement():bool {
   return self.$exp.canBeStatement();
}

pub override fn StmtExpNode.getBreakKind( checkMode:CheckBreakMode ):BreakKind {
   return self.$exp.getBreakKind( checkMode );
}

_declNodeClass( "ExpOmitEnum", Node, true, true, false,
                [ { "valToken": "&Parser.Token" },
                  { "enumTypeInfo": "&EnumTypeInfo" }]
);

_declNodeClass( "RefField", Node, nil, true, false,
                [ { "field": "&Parser.Token" },
                  //{ "overrideCanBeLeft": "bool!" },
                  { "symbolInfo": "&AccessSymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "&Node" }] 
);
pub override fn RefFieldNode.canBeLeft():bool {
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return false;
}

_declNodeClass( "GetField", Node, nil, true, false,
                [ { "field": "&Parser.Token" },
                  //{ "overrideCanBeLeft": "bool!" },
                  { "symbolInfo": "&AccessSymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "&Node" },
                  { "getterTypeInfo": "&TypeInfo" } ]               
);
pub override fn GetFieldNode.canBeLeft():bool {
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return false;
}


pub class VarInfo {
   pri let name: &Parser.Token { pub };
   // 宣言している型。 宣言していない場合は nil
   pri let refType: RefTypeNode! { pub };
   // 実際の型。
   pri let actualType: TypeInfo { pub };
}

pub enum DeclVarMode {
   Let,
   Sync,
   Unwrap,
}

_declNodeClass( "DeclVar", Node, false, false, true,
                [ { "mode": "DeclVarMode" },
                  { "accessMode": "AccessMode" },
                  { "staticFlag": "bool" },
                  { "varList": "List<&VarInfo>" },
                  { "expList": "&ExpListNode!" },
                  { "symbolInfoList": "List<&SymbolInfo>"},
                  { "typeInfoList": "List<&TypeInfo>" },
                  { "unwrapFlag": "bool" },
                  { "unwrapBlock": "&BlockNode!" },
                  { "thenBlock": "&BlockNode!" },
                  { "syncVarList": "List<&VarInfo>" },
                  { "syncBlock": "&BlockNode!" } ]
);

pub override fn DeclVarNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   if checkMode ~= .Normal and checkMode ~= .Return {
      if! let block = self.unwrapBlock {
         let kind = block.getBreakKind( checkMode );
         switch kind {
            case .Return, .NeverRet {
               return kind;
            }
         }
      }
      if! let block = self.thenBlock {
         let kind = block.getBreakKind( checkMode );
         switch kind {
            case .Return, .NeverRet {
               return kind;
            }
         }
      }
      if! let block = self.syncBlock {
         let kind = block.getBreakKind( checkMode );
         switch kind {
            case .Return, .NeverRet {
               return kind;
            }
         }
      }
      return .None;
   }
   else {
      let mut kind = BreakKind.None;
      let mut work = BreakKind.None;
      if! let block = self.unwrapBlock {
         work = block.getBreakKind( checkMode );
         _setBreakKind( work, kind, true, checkMode );
         if! let thenBlock = self.thenBlock {
            work = thenBlock.getBreakKind( checkMode );
            _setBreakKind( work, kind, true, checkMode );
            if! let syncBlock = self.syncBlock {
               work = syncBlock.getBreakKind( checkMode );
               _setBreakKind( work, kind, true, checkMode );
               return kind;
            }     
         }  
      }
      return .None;
   }
}



pub class DeclFuncInfo {
   pri let classTypeInfo: &TypeInfo! { pub };
   pri let name: &Parser.Token! { pub };
   pri let argList: List<&Node> { pub };
   pri let staticFlag: bool { pub };
   pri let accessMode: AccessMode { pub };
   pri let body: &BlockNode! { pub };
   pri let retTypeInfoList: List<&TypeInfo> { pub };
   pri let has__func__Symbol:bool { pub };
}
_declNodeClass( "DeclFunc", Node, false, true, true,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclMethod", Node, false, false, true,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclConstr", Node, false, false, true,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclDestr", Node, false, false, true,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "ExpCallSuper", Node, false, false, true,
                [ { "superType": "&TypeInfo" },
                  { "methodType": "&TypeInfo" },
                  { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "DeclMember", Node, false, false, true,
                [ { "name": "&Parser.Token" },
                  { "refType": "&RefTypeNode" },
                  { "symbolInfo": "&SymbolInfo" },
                  { "staticFlag": "bool" },
                  { "accessMode": "AccessMode" },
                  { "getterMutable": "bool" },
                  { "getterMode": "AccessMode" },
                  { "setterMode": "AccessMode" } ]
);

_declNodeClass( "DeclArg", Node, false, false, false,
                [ { "name": "&Parser.Token" },
                  { "argType": "&RefTypeNode" } ]
);

_declNodeClass( "DeclArgDDD", Node, false, false, false, [] );

pub class AdvertiseInfo {
   pri let mut member: &DeclMemberNode { pub };
   pri let prefix: str {pub};
};
_declNodeClass( "DeclClass", Node, false, false, true,
                [ { "accessMode": "AccessMode" },
                  { "name": "&Parser.Token" },
                  { "gluePrefix": "str!" },
                  { "declStmtList": "List<&Node>" },
                  { "fieldList": "List<&Node>" },
                  { "moduleName": "&Parser.Token!" },
                  { "memberList": "List<&DeclMemberNode>" },
                  { "scope": "&Scope" },
                  { "initStmtList": "List<&Node>" },
                  { "advertiseList": "AdvertiseInfo[]" },
                  { "trustList": "List<&TypeInfo>" },
                  { "outerMethodSet": "Map<str,bool>" } ]
);

_declNodeClass( "DeclEnum", Node, false, false, true,
                [ { "accessMode": "AccessMode" },
                  { "name": "&Parser.Token" },
                  { "valueNameList": "List<&Parser.Token>" },
                  { "scope": "&Scope" } ]
);


_declNodeClass( "DeclMacro", Node, false, false, true,
                [ { "declInfo": "DeclMacroInfo" } ]
);

pub abstract class MacroEval {
   pub abstract fn eval( macroNode: DeclMacroNode ): form;
}

_declNodeClass( "LiteralNil", Node, false, true, false, [] );

_declNodeClass( "LiteralChar", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralInt", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralReal", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "real" } ]
);

_declNodeClass( "LiteralArray", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "LiteralList", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

pub class PairItem {
   pri let key: Node { pub };
   pri let val: Node { pub };
}
_declNodeClass( "LiteralMap", Node, false, true, false,
                [ { "map": "Map<&Node,&Node>" },
                  { "pairList": "PairItem[]" } ]
);

_declNodeClass( "LiteralString", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "argList": "List<&Node>" } ]
);

_declNodeClass( "LiteralBool", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

_declNodeClass( "LiteralSymbol", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

pub fn Node.getSymbolInfo(): List<&AccessSymbolInfo> {
   fn processExpNode( node: &Node ): List<&AccessSymbolInfo> {
      switch ( node.$kind ) {
         case NodeKind.$ExpRef {
            return [(node@@ExpRefNode).$symbolInfo];
         }
         case NodeKind.$RefField {
            let refFieldNode = node@@RefFieldNode;
            if! refFieldNode.$symbolInfo {
               return [_exp];
            }
            return [];
         }
         case NodeKind.$GetField {
            let getFieldNode = node@@GetFieldNode;
            if! getFieldNode.$symbolInfo {
               return [_exp];
            }
            return [];
         }
         case NodeKind.$ExpList {
            let expListNode = node@@ExpListNode;
            let mut list: List<&AccessSymbolInfo> = [];
            foreach expNode, index in expListNode.$expList {
               if index == #expListNode.$expList {
                  foreach symbolInfo in processExpNode( expNode ) {
                     list.insert( symbolInfo );
                  }
               }
               else {
                  foreach symbolInfo in processExpNode( expNode ) {
                     list.insert( symbolInfo );
                     break;
                  }
               }
            }
            return list;
         }
      }
      return [];
   }
   return processExpNode( self );
}


pub override fn WhileNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in self.block.$stmtList {
         let work = stmt.getBreakKind( checkMode );
         _setBreakKind(work, kind, false, checkMode );
      }
      return kind;
   }
   else {
      if self.exp.$expType.$nilable {
         return .None;
      }
      if self.exp.$expType.equals( builtinTypeBool ) {
         if self.exp.$kind == NodeKind.$LiteralBool {
            let boolNode = self.exp@@LiteralBoolNode;
            if boolNode.$token.txt == "false" {
               return .None;
            }  
         }
         else {
            return .None;
         }        
      }
      // 条件式が次のもの以外は無条件ループ。
      //  - nilable でない
      //  - bool 型の式でない
      //  - false でもない
      

      // 無条件ループ用のフロー解析に変更する。
      let mut mode = CheckBreakMode.IgnoreFlow;
      if checkMode == .Return {
         mode = .IgnoreFlowReturn;
      }
      let mut kind = BreakKind.None;
      foreach stmt in self.block.$stmtList {
         let work = stmt.getBreakKind( mode );
         
         _setBreakKind(work, kind, false, mode );
      }
      if kind == .Break {
         return .None;
      }
      if kind == .Return {
         return .Return;
      }
      return .NeverRet;
   }
}


pub override fn LiteralNilNode.getLiteral(): stem![], List<&TypeInfo> {
   return [nil], [builtinTypeNil];
}

pub override fn LiteralCharNode.getLiteral(): stem![], List<&TypeInfo> {
   return [self.num], [builtinTypeChar];
}

pub override fn LiteralIntNode.getLiteral(): stem![], List<&TypeInfo> {
   return [self.num], [builtinTypeInt];
}

pub override fn LiteralRealNode.getLiteral(): stem![], List<&TypeInfo> {
   return [self.num], [builtinTypeReal];
}

pub override fn LiteralArrayNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut array:stem![] = [];
   if! self.expList {
      foreach val in _exp.get_expList() {
         let! txt = val.getLiteral()[1] {
            // nil は処理できない。。。
            return [], [];
         };
         array.insert( txt );
      } 
   }
   return [array], [self.get_expType()];
}

pub override fn LiteralListNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut list:stem![] = [];
   if! self.expList {
      foreach val in _exp.get_expList() {
         let! item = val.getLiteral()[1] {
            // nil は処理できない。。。
            return [], [];
         };
         list.insert( item );
      } 
   }
   return [list], [self.get_expType()];
}

pub override fn LiteralMapNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut map:Map<str,stem!> = {};
   foreach val, key in self.map {
      map[ key.getLiteral()[1] ] = val.getLiteral()[1];
   }
   return [map], [self.get_expType()];
}

pub override fn LiteralStringNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut txt = self.token.txt;
   if string.find( txt, '^```' ) {
      txt = txt.sub( 4, -4 );
   }
   else {
      txt = txt.sub( 2, -2 );
   }
   let argList = self.$argList;

   if #argList > 0 {
      let mut argTbl:stem![] = [];
      foreach argNode in argList {
         let arg = argNode.getLiteral();
         if #arg > 1 {
            let! argTxt = arg[1] {
               // nil は処理できない。。。
               return [], [];
            };
            argTbl.insert( argTxt );
         }
      }   
      return [ string.format( txt, table.unpack( argTbl ) )], [builtinTypeString];
   }
   return [txt], [builtinTypeString];
}

pub override fn LiteralBoolNode.getLiteral(): stem![], List<&TypeInfo> {
   return [ self.token.txt == "true"], [builtinTypeBool];
}

pub override fn LiteralSymbolNode.getLiteral(): stem![], List<&TypeInfo> {
   return [[ self.token.txt ]], [ builtinTypeSymbol ];
}

pub override fn RefFieldNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut prefix = (unwrap self.prefix.getLiteral()[1])@@str[];
   if self.nilAccess {
      prefix.insert( "$." );
   }
   else {
      prefix.insert( "." );
   }
   prefix.insert( self.field.txt );
   return [ prefix ], [ builtinTypeSymbol ];
}

pub override fn ExpMacroStatNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut txt = "";
   foreach token in self.expStrList {
      txt = "%s%s" (txt, token.getLiteral()[1]);
   }
   return [txt ], [ self.get_expType() ];
}

pub override fn ExpRefNode.getLiteral(): stem![], List<&TypeInfo> {
   let typeInfo = self.symbolInfo.$typeInfo;
   if typeInfo.$kind ~= .Enum {
      return [], [];
   }
   let enumTypeInfo = typeInfo@@EnumTypeInfo;

   let val = unwrap enumTypeInfo.getEnumValInfo( self.symbolInfo.$name );
   return [ val.$val ], [ enumTypeInfo.$valTypeInfo ];
}

pub override fn ExpOp2Node.getLiteral(): stem![], List<&TypeInfo> {
   let val1List, mut type1List = self.$exp1.getLiteral();
   let val2List, mut type2List = self.$exp2.getLiteral();

   if #val1List ~= 1 or #type1List ~= 1 or #val2List ~= 1 or #type2List ~= 1 {
      return [], [];
   }

   let val1, type1, val2, type2 =
      unwrap val1List[1], type1List[1].$srcTypeInfo,
      unwrap val2List[1], type2List[1].$srcTypeInfo;
   

   if ( type1 == builtinTypeInt or type1 == builtinTypeReal ) and
      ( type2 == builtinTypeInt or type2 == builtinTypeReal )
   {
      let mut retType = builtinTypeInt;
      if type1 == builtinTypeReal or type2 == builtinTypeReal {
         retType = builtinTypeReal;
      }
      let mut int1, mut int2 = 0, 0;
      let mut real1, mut real2 = 0.0, 0.0;
      if type1 == builtinTypeInt {
         int1 = val1@@int;
         real1 = int1@@real;
      }
      else {
         real1 = val1@@real;
      }
      if type2 == builtinTypeInt {
         int2 = val2@@int;
         real2 = int2@@real;
      }
      else {
         real2 = val2@@real;
      }

      switch ( self.op.txt ) {
         case "+" {
            if retType == builtinTypeInt {
               return [ int1 + int2 ], [ retType ];
            }
            return [ real1 + real2 ], [ retType ];
         }
         case "-" {
            if retType == builtinTypeInt {
               return [ int1 - int2 ], [ retType ];
            }
            return [ real1 - real2 ], [ retType ];
         }
         case "*" {
            if retType == builtinTypeInt {
               return [ int1 * int2 ], [ retType ];
            }
            return [ real1 * real2 ], [ retType ];
         }
         case "/" {
            if retType == builtinTypeInt {
               return [ int1 / int2 ], [ retType ];
            }
            return [ real1 / real2 ], [ retType ];
         }
      }
   }
   elseif type1 == builtinTypeString and type2 == builtinTypeString {
      if self.op.txt == ".." {
         return [ val1@@str .. val2@@str ], [ builtinTypeString ];
      }
   }

   return [],[];
}


let mut processInfoQueue:List<ProcessInfo> = [];

pub fn pushProcessInfo( processInfo:ProcessInfo! ): ProcessInfo {

   if #processInfoQueue == 0 {
      if idProv.$id >= userStartId {
         Util.err( "builtinId is over" );
      }
   }

   
   processInfoQueue.insert( new ProcessInfo( typeInfo2ModifierMap, idProv ) );
   when! processInfo {
      idProv = processInfo.idProvier;
      typeInfo2ModifierMap = processInfo.typeInfo2ModifierMap;
   }
   else {
      idProv = new IdProvider( userStartId );
      typeInfo2ModifierMap = {};
   }
   return new ProcessInfo( typeInfo2ModifierMap, idProv );
}

pub fn popProcessInfo() {
   let mut info = processInfoQueue[ #processInfoQueue ];
   idProv = info.idProvier;
   typeInfo2ModifierMap = info.typeInfo2ModifierMap;
   processInfoQueue.remove();
}
