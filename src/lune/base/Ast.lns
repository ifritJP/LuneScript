/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Parser;
import lune.base.Util;

pub class IdProvider {
   let mut id:int {pub};

   pub fn increment() mut {
      self.id = self.id + 1;
   }
   
   pub fn getNewId() mut : int {
      let newId = self.id;
      self.id = self.id + 1;
      return newId;
   }
}

let mut idProv = new IdProvider( 1 );

pub let rootTypeId = idProv.getNewId();
//let mut typeIdSeed = rootTypeId + 1;



pub proto class TypeInfo;
pub proto class SymbolInfo;

pub let mut typeInfoKind:Map<str,TypeInfo> = {};
pub let mut sym2builtInTypeMap:Map<str,SymbolInfo> = {};
pub let mut builtInTypeIdSet:Map<int,&TypeInfo> = {};

pub enum TypeInfoKind {
   Root,
   Macro,
   Prim,
   List,
   Array,
   Map,
   Class,
   IF,
   Func,    
   Method,  
   Nilable, 
   Enum,    
   Module,
   Stem,
}

pub fn isBuiltin( typeId: int ) : bool {
   return builtInTypeIdSet[ typeId ] ~= nil;
}


pub proto class Scope;

pub enum SymbolKind {
   Typ,
   Mbr,
   Mtd,
   Fun,
   Var,
   Arg,
}

pub enum AccessMode {
   None,
   Pub,
   Pro,
   Pri,
   Local,
   Global,
}

let mut txt2AccessModeMap:Map<str,AccessMode> = {};
txt2AccessModeMap.none = .None;
txt2AccessModeMap.pub = .Pub;
txt2AccessModeMap.pro = .Pro;
txt2AccessModeMap.pri = .Pri;
txt2AccessModeMap.local = .Local;
txt2AccessModeMap.global = .Global;
pub fn txt2AccessMode( accessMode:str ) : AccessMode! {
   return txt2AccessModeMap[ accessMode ];
}


/** シンボル情報 */
pub class SymbolInfo {
   /** 左辺値になれる場合 true */
   pub fn get_canBeLeft(): bool;
   /** 右辺値になれる場合 true */
   pub fn get_canBeRight(): bool;
   /** このシンボルの ID */
   pub fn get_symbolId(): int;
   /** このシンボルが属するスコープ */
   pub fn get_scope(): Scope;
   /** シンボルのアクセス */
   pub fn get_accessMode(): AccessMode;
   /** */
   pub fn get_staticFlag(): bool;
   /** シンボルの名前 */
   pub fn get_name(): str;
   /** シンボルの型 */
   pub fn get_typeInfo(): TypeInfo;
   /** このシンボルが mut かどうか */
   pub fn get_mutable(): bool;
   /** このシンボルの種類 SymbolKind */
   pub fn get_kind(): SymbolKind;
   /** このシンボルがデータを保持しているかどうか */
   pub fn get_hasValueFlag(): bool;
   pub fn set_hasValueFlag( arg:bool );

   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub fn canAccess( fromScope:&Scope ): &SymbolInfo!;
}


pub class NormalSymbolInfo extend SymbolInfo {
   pri static let mut symbolIdSeed:int;

   __init {
      NormalSymbolInfo.symbolIdSeed = 0;
   }

   /** 左辺値になれる場合 true */
   pri let canBeLeft: bool { pub };
   /** 右辺値になれる場合 true */
   pri let canBeRight: bool { pub };
   
   /** このシンボルの ID */
   pri let symbolId: int { pub };
   /** このシンボルが属するスコープ */
   pri let scope: Scope { pub };
   /** シンボルのアクセス */
   pri let accessMode: AccessMode { pub };
   /** */
   pri let staticFlag: bool { pub };
   /** シンボルの名前 */
   pri let name: str { pub };
   /** シンボルの型 */
   pri let typeInfo: &TypeInfo { pub };
   /** このシンボルが mut かどうか */
   pri let mutable: bool { pub };
   /** このシンボルの種類 SymbolKind */
   pri let kind: SymbolKind { pub };
   /** このシンボルがデータを保持しているかどうか */
   pri let hasValueFlag: bool { pub, pub };

   pub fn __init(
      kind:SymbolKind, canBeLeft:bool, canBeRight:bool, scope: Scope,
      accessMode: AccessMode, staticFlag: bool, name: str, 
      typeInfo: &TypeInfo, mutable: bool!, hasValueFlag: bool )
   {
      NormalSymbolInfo.symbolIdSeed = NormalSymbolInfo.symbolIdSeed + 1;
      self.kind = kind;
      self.canBeLeft = canBeLeft;
      self.canBeRight = canBeRight;
      self.symbolId = NormalSymbolInfo.symbolIdSeed;
      self.scope = scope;
      self.accessMode = accessMode;
      self.staticFlag = staticFlag;
      self.name = name;
      self.typeInfo = typeInfo;
      self.mutable = mutable and true or false;
      self.hasValueFlag = hasValueFlag;
   }
   
   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub override fn canAccess( fromScope:&Scope ): &SymbolInfo!;
}


pub class DataOwnerInfo {
   pub let hasData:bool;
   pub let symbolInfo: &SymbolInfo;
}

pub class Scope {
   // このスコープのオーナーの TypeInfo。
   // 名前空間に関連する class, function の TypeInfo。
   pri let mut ownerTypeInfo: &TypeInfo! { pub, pub };
   // 親のスコープ。 これが self と等しい場合は root。
   pri let mut parent: Scope { pub };
   // このスコープに登録されているシンボル情報。
   // シンボル名 → TypeInfo のマップ。
   pri let mut symbol2TypeInfoMap: Map<str,&SymbolInfo> { pub };
   // このスコープがクラスのスコープかどうか。
   pri let classFlag: bool;
   // 継承しているスコープ。
   pri let inheritList: List<&Scope> { pub };
   /** 所有権情報 */
   pri let mut symbolId2DataOwnerInfo: Map<int,DataOwnerInfo>;
      
      
   pub fn __init( parent: Scope!, classFlag: bool, inheritList: List<&Scope> ) {
      self.parent = unwrap parent default self;
      self.symbol2TypeInfoMap = {};
      self.inheritList = inheritList;
      self.classFlag = classFlag;
      self.symbolId2DataOwnerInfo = {};
   }

   pub fn isRoot(): bool {
      return self.parent == self;
   }

   pub fn set_ownerTypeInfo( owner: &TypeInfo! ) mut {
      self.ownerTypeInfo = owner;
   }
   
   pub fn getTypeInfoChild( name: str ) : &TypeInfo! {
      if! self.symbol2TypeInfoMap[ name ] {
         return _exp.$typeInfo;
      } 
      return nil;
   }

   pub fn getSymbolInfoChild( name: str ) : &SymbolInfo! {
      return self.symbol2TypeInfoMap[ name ];
   }
   
   pub fn setData( symbolInfo:&SymbolInfo ) mut {
      self.symbolId2DataOwnerInfo[ symbolInfo.$symbolId ] =
      new DataOwnerInfo( true, symbolInfo );
   }

   pub fn getNSTypeInfo(): TypeInfo;
}

// 最上位のスコープ
pub let mut rootScope = new Scope( nil, false, [] );
let dummyList:List<&TypeInfo> = [];
let mut rootChildren:List<&TypeInfo> = [];

class TypeData {
   pri let mut children:List<&TypeInfo> {pub};
   pub fn addChildren( child:&TypeInfo ) mut {
      self.children.insert( child );
   }
}

class TypeManager {
   pri static let mut info2Data:Map<&TypeInfo,TypeData>;

   __init {
      TypeManager.info2Data = {};
   }
   pub static fn add( typeInfo:&TypeInfo ) {
      TypeManager.info2Data[ typeInfo ] = new TypeData( [] );
   }
   pub static fn getData( typeInfo:&TypeInfo ) : TypeData! {
      return TypeManager.info2Data[ typeInfo ];
   }
}


pub class TypeInfo {

   // この TypeInfo のスコープ。
   // class, func など名前空間を持つ TypeInfo は有効。
   pri let scope: Scope! { pub };

   pub fn __init( scope: Scope! ) {
      self.scope = scope;
      if! scope {
         _exp.set_ownerTypeInfo( self );
      }
      TypeManager.add( self );
   }

   pub fn isModule(): bool {
      return true;
   }

   pub fn getParentId(): int {
      return rootTypeId;
   }

   pub fn get_baseId(): int {
      return rootTypeId;
   }

   pub fn isInheritFrom( other:&TypeInfo ) : bool {
      return false;
   }

   pub fn getTxt() : str {
      return "";
   }
   
   pro static fn canEvalWithBase(
      dist:&TypeInfo, distMut: bool, other:&TypeInfo, opTxt:str ): bool;

   pub fn canEvalWith( other:&TypeInfo, opTxt:str ): bool {
      return false;
   }
   
   pub fn get_abstructFlag(): bool {
      return false;
   }
   
   pub fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      return;
   }

   pub fn get_display_stirng(): str {
      return "";
   }

   pub fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }

   pub fn equals( typeInfo: &TypeInfo ): bool {
      return self == typeInfo.$srcTypeInfo;
   }

   pub fn get_externalFlag(): bool {
      return false;
   }
   
   pub fn get_interfaceList(): &List<&TypeInfo> {
      return dummyList;
   }  
   pub fn get_itemTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }  
   pub fn get_argTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }  
   pub fn get_retTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }  
   pub fn get_parentInfo(): &TypeInfo {
      return self;
   }

   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報か？
   */
   pub fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      while true {
         if other == self {
            return true;
         }
         if other.$parentInfo == other {
            break;
         }
         other = other.$parentInfo;
      }
      return false;
   }
   pub fn getModule(): &TypeInfo {
      if self.isModule() {
         return self;
      }
      return self.$parentInfo.getModule();
   }
   pub fn get_rawTxt(): str {
      return "";
   }  
   pub fn get_typeId(): int {
      return rootTypeId;
   }  
   pub fn get_kind(): TypeInfoKind {
      return .Root;
   } 
   pub fn get_staticFlag(): bool {
      return false;
   } 
   pub fn get_accessMode(): AccessMode {
      return AccessMode.Pri;
   }  
   pub fn get_autoFlag(): bool {
      return false;
   }  
   pub fn get_orgTypeInfo(): &TypeInfo {
      return self;
   }  
   pub fn get_baseTypeInfo(): &TypeInfo {
      return self;
   } 
   pub fn get_nilable(): bool {
      return false;
   }
   pub fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   pub fn get_typeData(): TypeData {
      return unwrap TypeManager.getData( self ); 
   }
   pub fn get_children() : &List<&TypeInfo> {
      return self.$typeData.$children;
   }
   pub fn addChildren( child:TypeInfo ) {
      (unwrap TypeManager.getData( self )).addChildren( child );
   }
   pub fn get_mutable(): bool {
      return true;
   }
}

pub fn Scope.filterTypeInfoField(
   includeSelfFlag: bool!, fromScope:&Scope, callback:form ):bool
{
   if self.classFlag {
      if includeSelfFlag {
         foreach symbolInfo in self.symbol2TypeInfoMap {
            if symbolInfo.canAccess( fromScope ) {
               if not callback( symbolInfo ) {
                  return false;
               }        
            }  
         }  
      }
      if self.inheritList {
         foreach scope in self.inheritList {
            if not scope.filterTypeInfoField( true, fromScope, callback ) {
               return false;
            }
         }
      } 
   }

   return true;
}

pub fn Scope.getSymbolInfoField(
   name: str, includeSelfFlag: bool!, fromScope:&Scope ) : &SymbolInfo!
{
   if self.classFlag {
      if includeSelfFlag {
         if! self.symbol2TypeInfoMap$[ name ] {
            let! symbolInfo = _exp.canAccess( fromScope ) {
               return nil;
            };
            return symbolInfo;
         }  
      } 
      if self.inheritList {
         foreach scope in self.inheritList {
            let symbolInfo = scope.getSymbolInfoField( name, true, fromScope );
            if symbolInfo {
               return symbolInfo;
            }   
         }  
      } 
   }

   return nil;
}

pub fn Scope.getTypeInfoField(
   name: str, includeSelfFlag: bool!, fromScope:&Scope ) : TypeInfo!
{
   let symbolInfo = self.getSymbolInfoField( name, includeSelfFlag, fromScope );
   if! symbolInfo {
      return _exp.$typeInfo;
   }
   return nil;
}


/**
このスコープからシンボル name の型情報を取得する。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
@param onlySameNsFlag true の場合、検索対象を同一名前空間内に限定する。
*/
pub fn Scope.getSymbolInfo(
   name: str, fromScope:&Scope, onlySameNsFlag:bool ) : &SymbolInfo!
{
   if! self.symbol2TypeInfoMap[ name ] {
      let! symbolInfo = _exp.canAccess( fromScope ) {
         return nil;
      };
      return symbolInfo;
   }
   if not onlySameNsFlag {
      if self.inheritList {
         foreach scope in self.inheritList {
            let symbolInfo = scope.getSymbolInfoField( name, true, fromScope );
            if symbolInfo {
               return symbolInfo;
            }   
         }   
      } 
   }
   if not onlySameNsFlag or not self.ownerTypeInfo {
      if self.parent ~= self {
         return self.parent.getSymbolInfo( name, fromScope, onlySameNsFlag );
      } 
   }
   if onlySameNsFlag {
      return nil;
   }
   if! sym2builtInTypeMap[ name ] {
      return _exp;
   }
   return nil;
}

pub fn Scope.getTypeInfo(
   name: str, fromScope:Scope, onlySameNsFlag:bool ) : TypeInfo!
{
   let! symbolInfo = self.getSymbolInfo(name, fromScope, onlySameNsFlag ) {
      return nil;
   };
   return symbolInfo.$typeInfo;
}


/**
このスコープからシンボル name の型情報を取得する。
フィールドを除く name。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
*/
pub fn Scope.getSymbolTypeInfo(
   name: str, fromScope:Scope, moduleScope:Scope ) : &SymbolInfo!
{
   let mut typeInfo:TypeInfo! = nil;
   let mut validThisScope = false;

   if! self.ownerTypeInfo {
      if _exp.$kind == .Func or _exp.$kind == .Method or
         self == moduleScope or self == rootScope
      { 
         validThisScope = true;
      } 
      elseif ( _exp.$kind == .IF or _exp.$kind == .Class or
               _exp.$kind == .Module ) and name == "self" {
         validThisScope = true;
      }
      elseif _exp.$kind == .Enum {
         validThisScope = true;
      }
   } 
   else {
      validThisScope = true;
   }
   if validThisScope {
      if! self.symbol2TypeInfoMap[ name ] {
         return _exp.canAccess( fromScope );
      } 
   }
   if self.parent ~= self {
      return self.parent.getSymbolTypeInfo( name, fromScope, moduleScope );
   }
   return sym2builtInTypeMap[ name ];
}


pub fn Scope.filterSymbolTypeInfo(
   fromScope:&Scope, moduleScope:&Scope, callback:form )
{
   if self.classFlag {
      if! self.symbol2TypeInfoMap[ "self" ] {
         callback( _exp );
      }
   }
   if moduleScope == fromScope or not self.classFlag {
      foreach symbolInfo in self.symbol2TypeInfoMap {
         if not callback( symbolInfo ) {
            return;
         }  
      }
   }

   if self.parent ~= self {
      self.parent.filterSymbolTypeInfo( fromScope, moduleScope, callback );
   }
}


pub fn Scope.add( kind: SymbolKind, canBeLeft:bool, canBeRight:bool,
                  name:str, typeInfo: &TypeInfo, accessMode:AccessMode,
                  staticFlag:bool, mutable:bool, hasValueFlag:bool ) mut : &SymbolInfo
{
   let mut symbolInfo = new NormalSymbolInfo(
      kind, canBeLeft, canBeRight,
      self, accessMode, staticFlag, name, typeInfo, mutable, hasValueFlag );
   self.symbol2TypeInfoMap[ name ] = symbolInfo;
   return symbolInfo;
}

pub fn Scope.addLocalVar(
   argFlag:bool, canBeLeft:bool, name:str, typeInfo: &TypeInfo, mutable:bool ) mut
{
   self.add( argFlag and SymbolKind.Arg or SymbolKind.Var,
             canBeLeft, true, name, typeInfo,
             .Local, false, mutable, true );
}

pub fn Scope.addStaticVar(
   argFlag:bool, canBeLeft:bool, name:str, typeInfo: &TypeInfo, mutable:bool ) mut
{
   self.add( argFlag and SymbolKind.Arg or SymbolKind.Var,
             canBeLeft, true, name, typeInfo,
             .Local, true, mutable, true );
}

pub fn Scope.addVar(
   accessMode:AccessMode, name:str,
   typeInfo: &TypeInfo, mutable:bool, hasValueFlag:bool ) mut
{
   self.add( SymbolKind.Var, true, true, name, typeInfo,
             accessMode, false, mutable, hasValueFlag );
}


pub fn Scope.addEnumVal( name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Mbr, false, true,
             name, typeInfo, .Pub, true, true, true );
}

pub fn Scope.addEnum( accessMode:AccessMode, name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Typ, false, false,
             name, typeInfo, accessMode, true, true, true );
}

pub fn Scope.addMember( name:str, typeInfo: &TypeInfo, accessMode:AccessMode,
                        staticFlag:bool, mutable:bool ) mut : &SymbolInfo
{
   return self.add( SymbolKind.Mbr, true, true,
                    name, typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addMethod(
   typeInfo: &TypeInfo, accessMode:AccessMode, staticFlag:bool, mutable:bool ) mut
{
   self.add( SymbolKind.Mtd, true, true, typeInfo.getTxt(),
             typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addFunc(
   typeInfo: &TypeInfo, accessMode:AccessMode, staticFlag:bool, mutable:bool ) mut
{
   self.add( SymbolKind.Fun, true, true, typeInfo.getTxt(),
             typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addClass( name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Typ, false, false, name, typeInfo,
             typeInfo.$accessMode, true, true, true );
} 

fn dumpScopeSub( scope: Scope!, prefix:str, readyIdSet:Map<Scope,bool> ) {
   if! scope {
      if readyIdSet[ _exp ] {
         return;
      } 
      readyIdSet[ _exp ] = true;
      if #prefix > 20 {
         Util.err("illegal");
      }   
      
      forsort symbolInfo, symbol in _exp.$symbol2TypeInfoMap {
         Util.log( "scope: %s, %s, %s" ( prefix, _exp, symbol ) );
         if! let subScope = symbolInfo.$typeInfo.$scope {
            dumpScopeSub( subScope, prefix .. "  ", readyIdSet );
         }
      } 
   };
}

fn dumpScope( scope: Scope!, prefix:str ) {
   dumpScopeSub( scope, prefix, {} );
}



pub let headTypeInfo:TypeInfo = new TypeInfo( rootScope );
//let rootTypeInfo:TypeInfo = new TypeInfo( rootScope );


pub fn Scope.getNSTypeInfo(): &TypeInfo {
   let mut scope = self;
   while true {
      if! let owner = scope.ownerTypeInfo {
         if owner.$kind == .Root {
            return owner;
         }
      }
      if scope.parent == scope {
         break;
      }
      scope = scope.parent;
   }
   return headTypeInfo;
}

pub fn Scope.getClassTypeInfo(): &TypeInfo {
   let mut scope = self;
   while true {
      if! let owner = scope.ownerTypeInfo {
         switch owner.$kind {
            case .Class, .IF, .Module {
               return owner;
            }
         }
      }
      if scope.parent == scope {
         break;
      }
      scope = scope.parent;
   }
   return headTypeInfo;
}


/**
このシンボルが、fromScope のスコープからアクセスできるか調べる。
 */
pub override fn NormalSymbolInfo.canAccess( fromScope:&Scope ): &SymbolInfo!
{
   let typeInfo = self.$typeInfo;
   if self.scope == fromScope {
      return self;
   }
   switch self.$accessMode {
      case .Pub, .Global {
         return self;
      }           
      case .Pro {
         let nsClass = self.scope.getClassTypeInfo();
         let fromClass = fromScope.getClassTypeInfo();
         if fromClass.isInheritFrom( nsClass ) {
            return self;
         }  
         return nil;
      } 
      case .Local {
         return self;
      } 
      case .Pri {
         let nsClass = self.scope.getClassTypeInfo();
         let fromClass = fromScope.getClassTypeInfo();
         if nsClass == fromClass {
            return self;
         }  
         return nil;
      } 
   }
   Util.err( "illegl accessmode -- %s, %s"
               (self.$accessMode, self.$name) );
}


pub class AccessSymbolInfo extend SymbolInfo {
   pri let symbolInfo: SymbolInfo {pub};
   pri let prefixTypeInfo: TypeInfo! {pub};
   pri let overrideCanBeLeft: bool;

   pub override fn get_mutable(): bool {
      if! self.prefixTypeInfo {
         return _exp.$mutable and self.symbolInfo.$mutable;
      }
      return self.symbolInfo.$mutable;
   };

   pub override fn get_canBeLeft(): bool {
      if not self.overrideCanBeLeft {
         return false;
      }
      if! self.prefixTypeInfo {
         if not _exp.$mutable {
            return false;
         }
      }
      return self.symbolInfo.$canBeLeft;
   }

   advertise symbolInfo;
}



pub proto class Node;
pub proto class DeclClassNode extend Node;

pub class NilableTypeInfo extend TypeInfo {
   pri let orgTypeInfo: &TypeInfo { pub };
   pri let typeId: int { pub };

   pub override fn get_kind(): TypeInfoKind {
      return .Nilable;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_nilable(): bool {
      return true;
   } 
   pub override fn getTxt() : str {
      return self.orgTypeInfo.getTxt() .. "!";
   }
   pub override fn get_display_stirng(): str {
      return self.orgTypeInfo.$display_stirng .. "!";
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ parentId = %d, typeId = %d, nilable = true, orgTypeId = %d }\n' (
            parentId, self.typeId, self.orgTypeInfo.$typeId ) );
   }

   pub override fn equals( typeInfo: &TypeInfo ): bool {
      if not typeInfo.$nilable {
         return false;
      }
      return self.orgTypeInfo.equals( typeInfo );
   }

   advertise orgTypeInfo;
}


pub class ModifierTypeInfo extend TypeInfo {
   pri let srcTypeInfo: &TypeInfo { pub };
   pri let typeId: int { pub };
   pri let mutable: bool { pub };

   pub override fn getTxt() : str {
      let mut txt = self.srcTypeInfo.getTxt();
      if not self.mutable {
         txt = "&" .. txt;
      }
      return txt;
   }
   pub override fn get_display_stirng(): str {
      let mut txt = self.srcTypeInfo.get_display_stirng();
      if self.mutable {
         txt = "mut " .. txt;
      }
      return txt;
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ parentId = %d, typeId = %d, srcTypeId = %d, mutable = %s }\n' (
            parentId, self.typeId, self.srcTypeInfo.$typeId,
            self.mutable and true or false ) );
   }

   pub override fn canEvalWith( other:&TypeInfo, opTxt:str ): bool {
      return TypeInfo.canEvalWithBase( self.srcTypeInfo, self.mutable, other, opTxt );
   }
   

   advertise srcTypeInfo;
}


pub class ModuleTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   //
   pri let mutable: bool {pub};

   pub fn __init( scope: Scope, externalFlag: bool,
                  txt: str, mut parentInfo: &TypeInfo!, typeId: int, mutable:bool )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = typeId;
      self.mutable = mutable;

      if! parentInfo {
         _exp.addChildren( self );
      }

      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;
      

      scope.set_ownerTypeInfo( self );
   }

   pub override fn isModule(): bool {
      return true;
   }

   pub override fn get_accessMode(): AccessMode {
      return AccessMode.Pub;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Module;
   } 
   
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   pub override fn getTxt() : str {
      return self.rawTxt;
   }

   pub override fn get_display_stirng(): str {
      return self.getTxt();
   }

   pub override fn canEvalWith( other:&TypeInfo, opTxt:str ): bool {
      return false;
   }

   pub override fn serialize(
      stream: oStream, validChildrenSet: Map<int,&TypeInfo>! )
   {  
      let txt = "{ parentId = %d, typeId = %d, txt = '%s', kind = %d, "
          ( self.getParentId(), self.typeId, self.rawTxt, TypeInfoKind.Module );
      stream.write( txt .. '\n' );

      stream.write( "children = {" );

      let! set = validChildrenSet {
         set = {};
      };
      if! validChildrenSet {
         foreach child in self.$children {
            if set[ child.$typeId ] and
               ( child.$accessMode == .Pub or child.$accessMode == .Global ) {
               stream.write( "%d, " ( child.$typeId ) );
            }  
         }  
      }
      stream.write( "} }\n" );
   }
}

pub class EnumValInfo {
   pri let name: str {pub};
   pri let val:stem {pub};
}

pub class EnumTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   pri let nilableTypeInfo: &TypeInfo { pub };

   // この enum で格納している値の型
   pri let valTypeInfo: &TypeInfo {pub};
   

   // enum 値名 -> EnumValInfo
   pri let name2EnumValInfo: Map<str,EnumValInfo> { pub };
   
   pub fn __init( scope: Scope, externalFlag: bool, accessMode: AccessMode,
                  txt: str, parentInfo: &TypeInfo!, typeId: int, valTypeInfo:&TypeInfo,
                  name2EnumValInfo: Map<str,EnumValInfo> )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = typeId;
      self.name2EnumValInfo = name2EnumValInfo;
      self.valTypeInfo = valTypeInfo;

      if! parentInfo {
         _exp.addChildren( self );
      }

      self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;

      scope.set_ownerTypeInfo( self );
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Enum;
   } 
   
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   pub override fn getTxt() : str {
      return self.rawTxt;
   }

   pub override fn get_display_stirng(): str {
      return self.getTxt();
   }
   
   pub override fn canEvalWith( other:&TypeInfo, opTxt:str ): bool {
      return self == other.$srcTypeInfo;
   }

   pub fn getEnumValInfo( name:str ): EnumValInfo! {
      return self.name2EnumValInfo[ name ];
   }

   pub override fn get_mutable(): bool {
      return true;
   };
}


pub class NormalTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // generic のタイプ
   pri let itemTypeInfoList: List<&TypeInfo> { pub };
   // 引数のタイプ
   pri let argTypeInfoList: List<&TypeInfo> { pub };
   // 戻り値のタイプ
   pri let retTypeInfoList: List<&TypeInfo> { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // タイプの種別
   pri let kind: TypeInfoKind { pub };
   // static かどうか
   pri let staticFlag: bool { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   // コンパイラで自動生成された型情報の場合 true。 accessor 等。
   pri let autoFlag: bool { pub };
   /** */
   pri let abstructFlag: bool { pub };

   // unwrap 後の TypeInfo。 無効な場合は headTypeInfo。
   pri let mut orgTypeInfo: &TypeInfo { pub };
   // 基底クラス。 無効な場合は headTypeInfo。
   pri let baseTypeInfo: &TypeInfo { pub };
   // インタフェースのリスト。
   pri let interfaceList: List<&TypeInfo> { pub };

   // この型が nilable を表わす型かどうか。
   pri let mut nilable: bool { pub };
   // この型の nilable 版の TypeInfo。 無効な場合は headTypeInfo。
   pri let mut nilableTypeInfo: &TypeInfo { pub };
   // このメソッドが mutable かどうか。
   pri let mutable: bool {pub};

   fn __init( abstructFlag:bool, scope: Scope!, baseTypeInfo: TypeInfo!,
              interfaceList: List<&TypeInfo>!, orgTypeInfo: TypeInfo!,
              autoFlag: bool, externalFlag: bool, staticFlag: bool,
              accessMode: AccessMode,
              txt: str, parentInfo: &TypeInfo!, typeId: int, kind: TypeInfoKind,
              itemTypeInfoList: List<&TypeInfo>!, argTypeInfoList:List<&TypeInfo>!,
              retTypeInfoList: List<&TypeInfo>!, mutable: bool! )
   {
      super( scope );

      if type(kind) ~= "number" {
         Util.printStackTrace();
      }
      
      self.abstructFlag = abstructFlag;
      self.baseTypeInfo = unwrap baseTypeInfo default headTypeInfo;
      self.interfaceList = unwrap interfaceList default [];
      self.autoFlag = autoFlag;
      self.externalFlag = externalFlag;
      self.staticFlag = staticFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.kind = kind;
      self.itemTypeInfoList = unwrap itemTypeInfoList default [];
      self.argTypeInfoList = unwrap argTypeInfoList default [];
      self.retTypeInfoList = unwrap retTypeInfoList default [];
      self.orgTypeInfo = unwrap orgTypeInfo default headTypeInfo;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.mutable = mutable and true or false;

      // if dummyRootTypeInfo and not parentInfo {
      //     Util.debugLog();
      //     error( "" );
      // }

      self.typeId = typeId;
      if kind == .Root {
         self.nilable = false;
         // dummyRootTypeInfo = self;
      } 
      elseif txt == "nil" {
         self.nilable = true;
         self.nilableTypeInfo = self;
         self.orgTypeInfo = self;
      } 
      elseif not orgTypeInfo {
         if! parentInfo {
            _exp.addChildren( self );
         }  
         self.nilable = false;

         let mut hasNilable = false;

         switch ( kind ) {
            case .Prim, .List, .Array,
                 .Map, .Class, .Stem, 
                 .Module, .IF   
            {
               hasNilable = true;
            }   
            case .Func, .Method {
               hasNilable = true;
            }
         }  
         if hasNilable {
            if txt == "..." {
               self.nilableTypeInfo = self;
            }
            else {
               // self.nilableTypeInfo = new NormalTypeInfo(
               //    false, nil, baseTypeInfo, interfaceList, self, autoFlag, externalFlag,
               //    staticFlag, accessMode, "", parentInfo, typeId + 1,
               //    .Nilable, itemTypeInfoList,
               //    argTypeInfoList, retTypeInfoList );
               self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
               idProv.increment();
               //typeIdSeed = typeIdSeed + 1;
            }
         }
         else {
            self.nilableTypeInfo = headTypeInfo;
         }
         idProv.increment();
         //typeIdSeed = typeIdSeed + 1;
      } 
      else {
         self.nilable = true;
         self.nilableTypeInfo = headTypeInfo;
      } 
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn getParentId(): int {
      return self.parentInfo.$typeId or rootTypeId;
   }

   pub override fn get_baseId(): int {
      return self.baseTypeInfo.$typeId or rootTypeId;
   }

   pub override fn getTxt() : str {
      if self.nilable and (self.nilableTypeInfo ~= self.orgTypeInfo) {
         return (unwrap self.orgTypeInfo).getTxt() .. "!";
      } 
      // if self.kind == .Array {
      //    let! _exp = self.itemTypeInfoList[1] {
      //       return "[@]";
      //    }; 
      //    return _exp.getTxt() .. "[@]";
      // } 
      // if self.kind == .List {
      //    let! _exp = self.itemTypeInfoList[1] {
      //       return "[]";
      //    }; 
      //    return _exp.getTxt() .. "[]";
      // } 
      if #self.itemTypeInfoList > 0 {
         let mut txt = self.rawTxt .. "<";
         foreach typeInfo, index in self.itemTypeInfoList {
            if index ~= 1 {
               txt = txt .. ",";
            }   
            txt = txt .. typeInfo.getTxt();
         }  

         return txt .. ">";
      } 
      if self.$rawTxt {
         return self.$rawTxt;
      } 
      return "";
   }

   pub override fn get_display_stirng(): str {
      if self.kind == .Nilable {
         return (unwrap self.orgTypeInfo).get_display_stirng() .. "!";
      }
      if self.kind == .Func or self.kind == .Method
      {
         let mut txt = self.$rawTxt .. "(";
         foreach argType, index in self.argTypeInfoList {
            if index ~= 1 {
               txt = txt .. ", ";
            }
            txt = txt .. argType.get_display_stirng();
         }
         txt = txt .. ")";
         foreach retType, index in self.retTypeInfoList {
            if index == 1 {
               txt = txt .. ": ";
            }
            else {
               txt = txt .. ", ";
            }
            txt = txt .. retType.get_display_stirng();
         }
         return txt;
      }
      return self.getTxt();
   }

   
   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      if self.typeId == rootTypeId {
         return;
      }

      let parentId = self.getParentId();
      if self.nilable {
         stream.write(
            '{ parentId = %d, typeId = %d, nilable = true, orgTypeId = %d }\n' (
               parentId, self.typeId, self.orgTypeInfo.$typeId ) );
         return;
      } 

      fn serializeTypeInfoList( name: str, list: &List<&TypeInfo>, onlyPub: bool! ): str {
         let mut work = name;
         foreach typeInfo in list {
            if not onlyPub or typeInfo.$accessMode == .Pub  {
               if #work ~=  #name {
                  work = work .. ", ";
               }    
               work = "%s%d" (work, typeInfo.$typeId );
            }   
         }  
         return work .. "}, ";
      } 

      let txt = ```{ parentId = %d, typeId = %d, baseId = %d, txt = '%s',
        staticFlag = %s, accessMode = %d, kind = %d, mutable = %s, ```
          ( parentId, self.typeId, self.get_baseId(), self.rawTxt,
            self.staticFlag, self.accessMode, self.kind, self.mutable );

      let mut children:List<&TypeInfo> = [];
      let! set = validChildrenSet {
         set = {};
      };
      foreach child in self.$children {
         if set[ child.$typeId ] {
            children.insert( child );
         }
      }
 
      stream.write(
         txt .. serializeTypeInfoList( "itemTypeId = {",
                                       self.itemTypeInfoList ) ..
         serializeTypeInfoList( "ifList = {", self.interfaceList ) ..
         serializeTypeInfoList( "argTypeId = {", self.argTypeInfoList ) ..
         serializeTypeInfoList( "retTypeId = {", self.retTypeInfoList ) ..
         serializeTypeInfoList( "children = {", children, true ) .. "}\n" );
   }

   pub fn equalsSub( mut typeInfo: &TypeInfo ): bool {
      typeInfo = typeInfo.$srcTypeInfo;

      if self.typeId == typeInfo.$typeId {
         return true;
      }

      // プリミティブな設定のチェック
      if self.kind ~= typeInfo.$kind or
         self.staticFlag ~= typeInfo.$staticFlag or
         self.accessMode ~= typeInfo.$accessMode or
         self.autoFlag ~= typeInfo.$autoFlag or
         self.nilable ~= typeInfo.$nilable or
         self.rawTxt ~= typeInfo.$rawTxt or
         self.parentInfo ~= typeInfo.$parentInfo or
         self.baseTypeInfo ~= typeInfo.$baseTypeInfo or
         self ~= typeInfo.$srcTypeInfo
      { 
         // errorLog( "%s, %s" ( self.externalFlag, typeInfo.externalFlag ) );
         // errorLog( "%s, %s" ( self.kind, typeInfo.kind ) );
         // errorLog( "%s, %s" ( self.staticFlag, typeInfo.staticFlag ) );
         // errorLog( "%s, %s" ( self.accessMode, typeInfo.accessMode ) );
         // errorLog( "%s, %s" ( self.autoFlag, typeInfo.autoFlag ) );
         // errorLog( "%s, %s" ( self.nilable, typeInfo.nilable ) );
         return false;
      }

      if ( self.orgTypeInfo ~= typeInfo.$orgTypeInfo )
      { 
         Util.log( "%s, %s" ( self.orgTypeInfo, typeInfo.$orgTypeInfo ) );
         //          error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
         //                                     typeInfo.getTxt(), typeInfo.typeId ) );
         return false;
      }

      if self.itemTypeInfoList {
         if #self.itemTypeInfoList ~= #typeInfo.$itemTypeInfoList {
            return false;
         }  
         foreach item, index in self.itemTypeInfoList {
            if not item.equals( typeInfo.$itemTypeInfoList[ index ] ) {
               // error( "illegal %s:%d %s:%d"
               //    ( self.getTxt(), self.typeId,
               //      typeInfo.getTxt(), typeInfo.$typeId ) );
               return false;
            }   
         }  
      } 

      if self.retTypeInfoList {
         if #self.retTypeInfoList ~= #typeInfo.$retTypeInfoList {
            // error( "illegal %s:%d %s:%d"
            //    ( self.getTxt(), self.typeId,
            //      typeInfo.getTxt(), typeInfo.$typeId ) );
            return false;
         }  
         foreach item, index in self.retTypeInfoList {
            if not item.equals( typeInfo.$retTypeInfoList[ index ] ) {
               // error( "illegal %s:%d %s:%d"
               //    ( self.getTxt(), self.typeId,
               //      typeInfo.getTxt(), typeInfo.$typeId ) );
               return false;
            }   
         }  
      } 

      if self.orgTypeInfo ~= headTypeInfo and
         not self.orgTypeInfo.equals( typeInfo.$orgTypeInfo )
      {     
         error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
                                        typeInfo.getTxt(), typeInfo.$typeId ) );
         return false;
      }
      return true;
   }

   pub override fn equals( typeInfo: TypeInfo ): bool {
      return self.equalsSub( typeInfo );
   }


   // pub static fn cloneToPublic( typeInfo: TypeInfo ): NormalTypeInfo {
   //    typeIdSeed = typeIdSeed + 1;
   //    return new NormalTypeInfo(
   //       typeInfo.$scope, typeInfo.$baseTypeInfo, nil, typeInfo.$autoFlag,
   //       typeInfo.$externalFlag, typeInfo.$staticFlag,
   //       "pub", typeInfo.$rawTxt, typeInfo.$parentInfo, typeIdSeed, typeInfo.$kind,
   //       typeInfo.$itemTypeInfoList, typeInfo.$argTypeInfoList,
   //       typeInfo.$retTypeInfoList );
   // }



   pub static fn create(
      abstructFlag: bool, scope: Scope!, baseInfo: &TypeInfo,
      interfaceList: List<&TypeInfo>, parentInfo: &TypeInfo, staticFlag: bool,
      kind: TypeInfoKind, txt: str, itemTypeInfo: List<&TypeInfo>,
      argTypeInfoList: List<&TypeInfo>, retTypeInfoList: List<&TypeInfo>,
      mutable: bool! ): &TypeInfo
   {  
      if kind == .Prim {
         if! sym2builtInTypeMap[ txt ] {
            return _exp.$typeInfo;
         }
         Util.err( "not found symbol -- %s" (txt ) );
      }
      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;
      let mut info = new NormalTypeInfo(
         abstructFlag, scope, baseInfo, interfaceList, nil, false, true,
         staticFlag, AccessMode.Pub, txt, parentInfo, idProv.$id, kind,
         itemTypeInfo, argTypeInfoList, retTypeInfoList, mutable ); 
      return info;
   }

}


//pub let typeInfoRoot = rootTypeInfo;

idProv.increment();
//typeIdSeed = typeIdSeed + 1;

pub static fn NormalTypeInfo.createBuiltin(
   idName: str, typeTxt: str,
   kind: TypeInfoKind, typeDDD: TypeInfo! ): &TypeInfo
{
   //let mut typeId = typeIdSeed + 1;
   let mut typeId = idProv.$id + 1;
   if kind == .Root {
      typeId = rootTypeId;
   } 
   else {
      //typeIdSeed = typeIdSeed + 1;
      idProv.increment();
   } 
   let mut argTypeList:List<&TypeInfo> = [];
   let mut retTypeList:List<&TypeInfo> = [];
   if typeTxt == "form" {
      if! typeDDD {
         argTypeList = [ _exp ];
         retTypeList = [ _exp ];
      }  
   } 

   let mut scope:Scope! = nil;
   switch kind {
      case .List, .Class, .Module,
           .IF, .Func, .Method,
           .Macro
      {  
         scope = new Scope(
            rootScope,
            kind == .Class or kind == .Module or
            kind == .IF or kind == .List, [] );
      }  
   } 
   
   let mut info = new NormalTypeInfo(
      false, scope, nil, nil, nil, false, false, false, AccessMode.Pub,
      typeTxt, headTypeInfo, typeId,
      kind, [], argTypeList, retTypeList, true );
   if scope {
      rootScope.addClass( typeTxt, info );
   } 

   typeInfoKind[ idName ] = info;
   sym2builtInTypeMap[ typeTxt ] = new NormalSymbolInfo(
      SymbolKind.Typ, false, false,
      rootScope, AccessMode.Pub, false, typeTxt, info, false, true );
   if info.$nilableTypeInfo ~= headTypeInfo {
      sym2builtInTypeMap[ typeTxt .. "!" ] = new NormalSymbolInfo(
         SymbolKind.Typ, false, kind == .Func, rootScope,
         AccessMode.Pub, false, typeTxt, info.$nilableTypeInfo, false, true );
      builtInTypeIdSet[ info.$nilableTypeInfo.$typeId ] = info.$nilableTypeInfo;
   } 
   
   builtInTypeIdSet[ info.typeId ] = info;
   return info;
}

pub static fn NormalTypeInfo.createList(
   accessMode: AccessMode, parentInfo: &TypeInfo, itemTypeInfo: List<&TypeInfo> ): &TypeInfo
{
   if #itemTypeInfo == 0 {
      Util.err( "illegal list type: %s" (itemTypeInfo) );
   } 
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, nil, nil, nil, nil, false, false, false, accessMode, "List",
      headTypeInfo, idProv.$id, .List, itemTypeInfo, nil, nil, true );
}

pub static fn NormalTypeInfo.createArray(
   accessMode: AccessMode,
   parentInfo: &TypeInfo, itemTypeInfo: List<&TypeInfo> ): &TypeInfo
{
   //   typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, nil, nil, nil, nil, false, false, false, accessMode, "Array",
      headTypeInfo, idProv.$id, .Array, itemTypeInfo, nil, nil, true );
}

pub static fn NormalTypeInfo.createMap(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   keyTypeInfo: &TypeInfo, valTypeInfo: &TypeInfo ): &TypeInfo
{
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, nil, nil, nil, nil, false, false, false, accessMode, "Map",
      headTypeInfo, idProv.$id, .Map,
      [ keyTypeInfo, valTypeInfo ], nil, nil, true );
}


pub static fn NormalTypeInfo.createModule(
   scope: Scope, parentInfo: &TypeInfo, externalFlag: bool,
   moduleName: str, mutable:bool ): &TypeInfo
{
   if! sym2builtInTypeMap[ moduleName ] {
      return _exp.$typeInfo;
   }

   if Parser.isLuaKeyword( moduleName ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (moduleName) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new ModuleTypeInfo(
      scope, externalFlag, moduleName, parentInfo, idProv.$id, mutable );
   return info;
}


pub static fn NormalTypeInfo.createClass(
   classFlag: bool, abstructFlag: bool, scope: Scope!,
   baseInfo: TypeInfo!, interfaceList: List<&TypeInfo>!,
   parentInfo: &TypeInfo, externalFlag: bool,
   accessMode: AccessMode, className: str ): &TypeInfo
{
   // if className == "str" {
   //     return sym2builtInTypeMap[ className ]@TypeInfo;
   // }
   if! sym2builtInTypeMap[ className ] {
      return _exp.$typeInfo;
      //return classTypeInfo@TypeInfo;
   }

   if Parser.isLuaKeyword( className ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (className) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new NormalTypeInfo(
      abstructFlag, scope, baseInfo, interfaceList, nil, false,
      externalFlag, false, accessMode,
      className, parentInfo, idProv.$id,
      classFlag and TypeInfoKind.Class or TypeInfoKind.IF, nil, nil, nil, true );
   return info;
}

pub static fn NormalTypeInfo.createFunc(
   abstructFlag: bool, builtinFlag:bool, scope: Scope!, kind: TypeInfoKind,
   parentInfo: &TypeInfo, autoFlag: bool, externalFlag: bool,
   staticFlag: bool, accessMode: AccessMode, funcName: str, argTypeList: List<&TypeInfo>!,
   retTypeInfoList: List<&TypeInfo>!, mutable: bool! ): &TypeInfo
{
   if not builtinFlag and Parser.isLuaKeyword( funcName ) {
      Util.err( "This symbol can not use for a function. -- %s" (funcName) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new NormalTypeInfo(
      abstructFlag, scope, nil, nil, nil, autoFlag, externalFlag, staticFlag,
      accessMode, funcName, parentInfo, idProv.$id,
      kind, [], unwrap argTypeList default [],
      unwrap retTypeInfoList default [], mutable );
   return info;
}

pub static fn NormalTypeInfo.createAdvertiseMethodFrom(
   classTypeInfo:&TypeInfo, typeInfo:&TypeInfo ): &TypeInfo
{
   return NormalTypeInfo.createFunc(
      false, false, typeInfo.$scope, typeInfo.$kind,
      classTypeInfo, true, false, false, typeInfo.$accessMode, typeInfo.$rawTxt,
      typeInfo.$argTypeInfoList, typeInfo.$retTypeInfoList, typeInfo.$mutable );
}


let mut typeInfo2ModifierMap:Map<&TypeInfo,TypeInfo> = {};

pub static fn NormalTypeInfo.createModifier(
   srcTypeInfo: &TypeInfo, mutable: bool ): &TypeInfo
{
   if! typeInfo2ModifierMap[ srcTypeInfo ] {
      return _exp;
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let modifier = new ModifierTypeInfo( srcTypeInfo, idProv.$id, mutable ); 
   typeInfo2ModifierMap[ srcTypeInfo ] = modifier;
   return modifier;
}

pub let builtinTypeNone:TypeInfo = 
   NormalTypeInfo.createBuiltin( "None", "", .Prim );
pub let builtinTypeStem:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Stem", "stem" , .Stem );
pub let builtinTypeNil:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Nil", "nil" , .Prim );
pub let builtinTypeDDD:TypeInfo =
   NormalTypeInfo.createBuiltin( "DDD", "..." , .Prim );
pub let builtinTypeBool:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Bool", "bool" , .Prim );
pub let builtinTypeInt:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Int", "int" , .Prim );
pub let builtinTypeReal:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Real", "real" , .Prim );
pub let builtinTypeChar:TypeInfo = 
   NormalTypeInfo.createBuiltin( "char", "char" , .Prim );
pub let builtinTypeString:TypeInfo = 
   NormalTypeInfo.createBuiltin( "String", "str" , .Class );
pub let builtinTypeMap:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Map", "Map" , .Map );
pub let builtinTypeList:TypeInfo = 
   NormalTypeInfo.createBuiltin( "List", "List" , .List );
pub let builtinTypeArray:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Array", "Array" , .Array );
pub let builtinTypeForm:TypeInfo =
   NormalTypeInfo.createBuiltin( "Form", "form" , .Func, builtinTypeDDD );
pub let builtinTypeSymbol:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Symbol", "sym" , .Prim );
pub let builtinTypeStat:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Stat", "stat" , .Prim );

pub let builtinTypeStem_ = unwrap builtinTypeStem.$nilableTypeInfo;

pub static fn NormalTypeInfo.createEnum(
   scope: Scope, parentInfo: &TypeInfo, externalFlag: bool,
   accessMode: AccessMode, enumName: str, valTypeInfo:&TypeInfo, 
   name2EnumValInfo:Map<str,EnumValInfo> ): &TypeInfo
{
   if Parser.isLuaKeyword( enumName ) {
      Util.err( "This symbol can not use for a enum. -- %s"
                (enumName) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new EnumTypeInfo(
      scope, externalFlag, accessMode, enumName,
      parentInfo, idProv.$id, valTypeInfo, name2EnumValInfo );

   let mut getEnumName = NormalTypeInfo.createFunc(
      false, true, nil, .Method, info,
      true, true, false, AccessMode.Pub,
      "get__txt", nil, [ builtinTypeString ], false );
   scope.addMethod( getEnumName, AccessMode.Pub, false, true );

   let mut fromVal = NormalTypeInfo.createFunc(
      false, true, nil, .Method, info,
      true, true, true, AccessMode.Pub,
      "_from", [ NormalTypeInfo.createModifier( valTypeInfo,false ) ],
      [ info.$nilableTypeInfo ], false );
   scope.addMethod( fromVal, AccessMode.Pub, true, true );
   
   return info;
}

pub override fn EnumTypeInfo.serialize(
   stream: oStream, validChildrenSet: Map<int,&TypeInfo>! )
{
   let txt = ```{ parentId = %d, typeId = %d, txt = '%s',
accessMode = %d, kind = %d, valTypeId = %d, ```
       ( self.getParentId(), self.typeId, self.rawTxt,
         self.accessMode, TypeInfoKind.Enum, self.valTypeInfo.$typeId );
   stream.write( txt );

   stream.write( "enumValList = {" );
   forsort enumValInfo in self.name2EnumValInfo {
      if self.valTypeInfo.equals( builtinTypeString ) {
         stream.write( "%s = '%s'," (enumValInfo.$name, enumValInfo.$val) );
      }
      else {
         stream.write( "%s = %s," (enumValInfo.$name, enumValInfo.$val) );
      }
   }
   stream.write( "} }\n" );
}




// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NilableTypeInfo.canEvalWith( other:&TypeInfo, opTxt:str ): bool {
   let otherSrc = other.$srcTypeInfo;

   if self == builtinTypeStem_ {
      return true;
   }  
   if otherSrc == builtinTypeNil {
      return true;
   }  
   if self.typeId == otherSrc.$typeId {
      return true;
   }
   if otherSrc.$nilable {
      return self.$orgTypeInfo.canEvalWith( otherSrc.$orgTypeInfo, opTxt );
   }
   return self.$orgTypeInfo.canEvalWith( otherSrc, opTxt );
}
   
macro checkEqualsItemType( type1:sym, type2:sym, index:int ) {
   if not (unwrap ,,type1.$itemTypeInfoList[ ,,index ]).canEvalWith(
      unwrap ,,type2.$itemTypeInfoList[ ,,index ], "=" )
   {
      return false;
   }
};

// other のクラスが、この型のクラスの継承関係にあるか調べる
pub override fn NormalTypeInfo.isInheritFrom( other:&TypeInfo ) : bool
{
   let otherTypeId = other.$typeId;
   if self.$typeId == otherTypeId {
      return true;
   }
   if ( self.$kind ~= .Class and self.$kind ~= .IF ) or
      ( other.$kind ~= .Class and other.$kind ~= .IF )
   {  
      return false;
   }
   let mut baseTypeInfo = self.$baseTypeInfo;
   while baseTypeInfo ~= headTypeInfo {
      if otherTypeId == baseTypeInfo.$typeId {
         return true;
      } 
      baseTypeInfo = baseTypeInfo.$baseTypeInfo;
   };
   foreach ifType in self.$interfaceList {
      let mut workType = ifType;
      while workType ~= headTypeInfo {
         if otherTypeId == workType.$typeId {
            return true;
         }
         workType = workType.$baseTypeInfo;
      }; 
   }
   return false;
}


pub static fn TypeInfo.checkMatchType(
   dstTypeList: &List<&TypeInfo>,
   expTypeList: &List<&TypeInfo>, allowDstShort:bool ) : bool, str
{
   if #expTypeList > 0 {
      foreach expType, index in expTypeList {
         if #dstTypeList == 0 {
            return false, "over exp. expect:0, actual:%d" ( #expTypeList);
         }
         let argType = dstTypeList[ index ];
         if #dstTypeList == index {
            if not argType.equals( builtinTypeDDD ) {
               if not argType.canEvalWith( expType, "=" ) {
                  return false, "exp(%d) type mismatch %s <- %s"
                  ( index, argType.getTxt(), expType.getTxt());
               }
               if not allowDstShort and #dstTypeList < #expTypeList {
                  return false, "over exp. expect: %d: actual: %d"
                  (#dstTypeList, #expTypeList );
               }
            }
            break;
         }
         elseif #expTypeList == index {
            // 最終実引数処理
            if expType.equals( builtinTypeDDD ) {
               for argIndex = index, #dstTypeList {
                  let workArgType = dstTypeList[ argIndex ];
                  if not workArgType.canEvalWith( builtinTypeStem_, "=" ) {
                     return false, "exp(%d) type mismatch %s <- %s"
                     ( argIndex, workArgType.getTxt(), builtinTypeStem_.getTxt());
                  }
               }
            }
            else {
               let mut workExpType = expType;
               for argIndex = index, #dstTypeList {
                  let argTypeInfo = dstTypeList[ argIndex ];
                  if not argTypeInfo.canEvalWith( workExpType, "=" ) {
                     return false, "exp(%d) type mismatch %s <- %s"
                     ( argIndex, argTypeInfo.getTxt(), workExpType.getTxt() );
                  }
                  workExpType = builtinTypeNil;
               }
            }
            break;
         }
         else {
            if not argType.canEvalWith( expType, "=" ) {
               return false, "exp(%d) type mismatch %s <- %s"
               ( index, argType.getTxt(), expType.getTxt());
            }  
         }  
      }
   }
   elseif not allowDstShort {
      foreach argType, index in dstTypeList {
         if not argType.canEvalWith( builtinTypeNil, "=" ) {
            return false, "exp(%d) type mismatch %s <- nil"
            ( index, argType.getTxt());
         }
      }
   }
   return true, "";
}

static fn TypeInfo.canEvalWithBase(
   dist:&TypeInfo, distMut:bool, other:&TypeInfo, opTxt:str ) : bool
{
   let otherMut = other.$mutable;
   let otherSrc = other.$srcTypeInfo;

   if opTxt == "=" and
      otherSrc ~= builtinTypeNil and
      otherSrc ~= builtinTypeString and
      otherSrc.$kind ~= .Prim and
      otherSrc.$kind ~= .Func and
      otherSrc.$kind ~= .Enum and
      distMut and not otherMut
   {
      return false;
   }
   
   if dist == builtinTypeStem_ or dist == builtinTypeDDD {
      return true;
   }
   if not dist.$nilable and otherSrc.$nilable {
      return false;
   }
   if dist == builtinTypeStem and not otherSrc.$nilable {
      return true;
   }
   if dist == builtinTypeForm and otherSrc.$kind == .Func {
      return true;
   }
   if otherSrc == builtinTypeNil {
      if dist.$kind ~= .Nilable {
         return false;
      } 
      return true;
   }
   if dist.$typeId == otherSrc.$typeId {
      return true;
   }
   if dist.$kind ~= otherSrc.$kind {
      if dist.$kind == .Nilable {
         if otherSrc.$nilable {
            return dist.$orgTypeInfo.canEvalWith( otherSrc.$orgTypeInfo, opTxt );
         }
         return dist.$orgTypeInfo.canEvalWith( otherSrc, opTxt );
      }
      elseif ( dist.$kind == .Class or dist.$kind == .IF ) and
         ( otherSrc.$kind == .Class or otherSrc.$kind == .IF )
      {
         return otherSrc.isInheritFrom( dist );
      }
      elseif otherSrc.$kind == .Enum {
         let enumTypeInfo = otherSrc@@EnumTypeInfo;
         return dist.$canEvalWith( enumTypeInfo.$valTypeInfo, opTxt );
      }
      return false;
   }
   // TypeInfoKind が等しい
   switch ( dist.$kind ) {
      case .Prim {
         if dist == builtinTypeInt and otherSrc == builtinTypeChar or
            dist == builtinTypeChar and otherSrc == builtinTypeInt
         {  
            return true;
         }  
         return false;
      }       
      case .List, .Array {
         if otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone {
            // literalMap の [], [@] は互換有りとする
            return true;
         }  
         checkEqualsItemType( dist, otherSrc, 1 );
         return true;
      }       
      case .Map {
         if otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone and
            otherSrc.$itemTypeInfoList[ 2 ] == builtinTypeNone
         {  
            // literalMap の {} は互換有りとする
            return true;
         }  
         checkEqualsItemType( dist, otherSrc, 1 );
         checkEqualsItemType( dist, otherSrc, 2 );
         return true;
      }       
      case .Class, .IF {
         return otherSrc.isInheritFrom( dist );
      }       
      case .Func {
         if dist == builtinTypeForm {
            return true;
         }  
         if not TypeInfo.checkMatchType( dist.$argTypeInfoList,
                                         otherSrc.$argTypeInfoList, false ) or
            not TypeInfo.checkMatchType( dist.$retTypeInfoList,
                                         otherSrc.$retTypeInfoList, false )
         {
            return false;
         }
         return true;
      }       
      case .Method {
         if not TypeInfo.checkMatchType( dist.$argTypeInfoList,
                                         otherSrc.$argTypeInfoList, false ) or
            not TypeInfo.checkMatchType( dist.$retTypeInfoList,
                                         otherSrc.$retTypeInfoList, false )
         {
            return false;
         }
         return true;
      }
      case .Nilable {
         return dist.$orgTypeInfo.canEvalWith( otherSrc.$orgTypeInfo, opTxt );
      }
      default {
         return false;
      } 
   }
   return true;
}


// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NormalTypeInfo.canEvalWith( other:&TypeInfo, opTxt:str ) : bool {
   return TypeInfo.canEvalWithBase( self, self.$mutable, other, opTxt );
}


pub class Filter {
}

pub class Node {
   pri let kind: int { pub };
   pri let pos: &Parser.Position { pub };
   pri let expTypeList: &List<&TypeInfo> { pub };

   pub fn get_expType(): &TypeInfo {
      if #self.expTypeList == 0 {
         return builtinTypeNone;
      }
      return self.expTypeList[ 1 ];
   }; 
   
   pub fn getLiteral(): stem![], List<&TypeInfo> {
      return [nil], [builtinTypeNil];
   }
   pub fn processFilter( filter: Filter, ... ) {
   }

   pub fn canBeLeft(): bool {
      return false;
   };     
   pub fn canBeRight(): bool {
      return false;
   }
}



pub class NamespaceInfo {
   pub let name: str;
   pub let scope: Scope;
   pub let typeInfo: &TypeInfo;
}


pub proto class MacroEval;
pub proto class ExpListNode extend Node;
pub proto class DeclArgNode extend Node;

pub class DeclMacroInfo {
   pri let name: &Parser.Token { pub };
   pri let argList: List<&DeclArgNode> { pub };
   pri let ast: &Node! { pub };
   pri let tokenList: List<&Parser.Token> { pub };
}

pub class MacroValInfo {
   pub let val: stem!;
   pub let typeInfo: TypeInfo;
}

pub class MacroInfo {
   pub let func: form;
   pub let declInfo: DeclMacroInfo;
   pub let symbol2MacroValInfoMap: Map<str,MacroValInfo>;
}

let mut nodeKind2NameMap: Map<int,str> = {};
let mut nodeKindSeed = 1;
pub let mut nodeKind: Map<str,int> = {};

fn regKind( name:str ): int {
   let kind = nodeKindSeed;
   nodeKindSeed = nodeKindSeed + 1;
   nodeKind2NameMap[ kind ] = name;
   nodeKind[ name ] = kind;
   return kind;
}

pub fn getNodeKindName( kind: int ): str {
   return unwrap nodeKind2NameMap[ kind ];
}

// let nodeKindNone = regKind( 'None' );
// let nodeKindImport = regKind( 'Import' );
// let nodeKindRoot = regKind( 'Root' );
// let nodeKindRefType = regKind( 'RefType' );
// let nodeKindIf = regKind( 'If' );
// let nodeKindSwitch = regKind( 'Switch' );
// let nodeKindWhile = regKind( 'While' );
// let nodeKindRepeat = regKind( 'Repeat' );
// let nodeKindFor = regKind( 'For' );
// let nodeKindApply = regKind( 'Apply' );
// let nodeKindForeach = regKind( 'Foreach' );
// let nodeKindForsort = regKind( 'Forsort' );
// let nodeKindReturn = regKind( 'Return' );
// let nodeKindBreak = regKind( 'Break' );
// let nodeKindExpNew = regKind( 'ExpNew' );
// let nodeKindExpList = regKind( 'ExpList' );
// let nodeKindExpRef = regKind( 'ExpRef' );
// let nodeKindExpOp2 = regKind( 'ExpOp2' );
// let nodeKindExpCast = regKind( 'ExpCast' );
// let nodeKindExpOp1 = regKind( 'ExpOp1' );
// let nodeKindExpRefItem = regKind( 'ExpRefItem' );
// let nodeKindExpCall = regKind( 'ExpCall' );
// let nodeKindExpCallSuper = regKind( 'ExpCallSuper' );
// let nodeKindExpDDD = regKind( 'ExpDDD' );
// let nodeKindExpParen = regKind( 'ExpParen' );
// let nodeKindExpMacroExp = regKind( 'ExpMacroExp' ); // macro expand
// let nodeKindExpMacroStat = regKind( 'ExpMacroStat' ); // `{}
// let nodeKindBlock = regKind( 'Block' );
// let nodeKindStmtExp = regKind( 'StmtExp' );
// let nodeKindRefField = regKind( 'RefField' );
// let nodeKindDeclVar = regKind( 'DeclVar' );
// let nodeKindDeclFunc = regKind( 'DeclFunc' );
// let nodeKindDeclMethod = regKind( 'DeclMethod' );
// let nodeKindDeclConstr = regKind( 'DeclConstr' );
// let nodeKindDeclMember = regKind( 'DeclMember' );
// let nodeKindDeclArg = regKind( 'DeclArg' );
// let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
// let nodeKindDeclClass = regKind( 'DeclClass' );
// let nodeKindDeclMacro = regKind( 'DeclMacro' );
// let nodeKindLiteralNil = regKind( 'LiteralNil' );
// let nodeKindLiteralChar = regKind( 'LiteralChar' );
// let nodeKindLiteralInt = regKind( 'LiteralInt' );
// let nodeKindLiteralReal = regKind( 'LiteralReal' );
// let nodeKindLiteralArray = regKind( 'LiteralArray' );
// let nodeKindLiteralList = regKind( 'LiteralList' );
// let nodeKindLiteralMap = regKind( 'LiteralMap' );
// let nodeKindLiteralString = regKind( 'LiteralString' );
// let nodeKindLiteralBool = regKind( 'LiteralBool' );
// let nodeKindLiteralSymbol = regKind( 'LiteralSymbol' );

pub class NodeManager {
   let mut nodeKind2NodeList:Map<int,List<&Node>>;

   pub fn __init() {
      self.nodeKind2NodeList = {};
   }

   pub fn getList(kind:int) : &List<&Node>! {
      return self.nodeKind2NodeList[ kind ];
   }
   pub fn addNode(node:&Node) mut {
      let! mut list = self.nodeKind2NodeList[ node.$kind ] {
         list = [];
         self.nodeKind2NodeList[ node.$kind ] = list;
      };
      list.insert( node );
   }
}

macro _declNodeClass(
   baseName:str, super:sym, canBeLeftFlag:bool!, canBeRightFlag:bool!,
   fieldInfoList:Map<str,str>[] )
{
   {
      let _className = ,,,"%sNode" (baseName);
      let _nodeKindSym = ,,,"nodeKind%s" (baseName);

      let mut fieldStatList:stat[] = [];
      let mut argList:stat[] = [];
      let mut argSymList:stat[] = [];
      let mut initStatList:stat[] = [];
      let mut relateStat:stat[] = [];
      
      if fieldInfoList {
         foreach fieldInfo in fieldInfoList {
            foreach typeName, varName in fieldInfo {
               fieldStatList.insert( `{
                  pri let mut ,,,varName : ,,,typeName { pub };
               });  
               argList.insert( `{ ,,,varName: ,,,typeName, } );
               argSymList.insert( `{, ,,,varName } );
               initStatList.insert( `{ self.,,,varName = ,,,varName; } );
            }   
         }  
      } 

      fieldStatList.insert( `{
         pub override fn processFilter( filter: Filter, ... ) {
            let argList:stem[] = [ ... ];

            filter.,,,"process%s" (baseName) (self, table.unpack( argList ) );
         } } );

      if! canBeRightFlag {
         fieldStatList.insert( `{
            pub override fn canBeRight():bool {
               return ,,, canBeRightFlag;
            } } );
      }
      if! canBeLeftFlag {
         fieldStatList.insert( `{
            pub override fn canBeLeft():bool {
               return ,,, canBeLeftFlag;
            } } );
      }
      
      let superStat = `{
         super( ,,_nodeKindSym, pos, typeList );
      };

      relateStat.insert( `{
         pub fn Filter. ,,,"process%s" (baseName) ( node: &,,_className, ... ) mut {
         };
         pub fn NodeManager. ,,,"get%sList" (,,,,_className) () : &List<&,,_className>! {
            return self.getList( ,,_nodeKindSym )@@List<&,,_className> !;
         }
      } );
      
   }

   pub proto class ,,_className extend ,,super;
   pub let ,,_nodeKindSym = regKind( ,,baseName );
   ,,relateStat;
   pub class ,,_className extend ,,super {
      ,,fieldStatList;
      pro fn __init( pos: &Parser.Position, typeList: &List<&TypeInfo>, ,,argList ) {
         ,,superStat;
         ,,initStatList;
      }
      pub static fn create( nodeMan:NodeManager, pos: &Parser.Position,
                            typeList: &List<&TypeInfo>, ,,argList ) : ,,_className
      {
         let mut node = new ,,_className( pos, typeList ,,argSymList );
         nodeMan.addNode( node );
         return node;
      }
   }
}

_declNodeClass( "None", Node, false, false, []);
_declNodeClass( "Subfile", Node, false, false, []);
_declNodeClass( "Import", Node, false, false,
                [ { "modulePath": "str" },
                  { "moduleTypeInfo": "&TypeInfo" } ]
);


pub proto class ProvideNode extend Node;

pub class LuneHelperInfo {
   pri let useNilAccess:bool { pub };
   pri let useUnwrapExp:bool { pub };
}

pub class ModuleInfo {
   pri let fullName:str{ pub };
   //pri let symbolInfo:&SymbolInfo { pub };
   pri let localTypeInfo2importIdMap:Map<&TypeInfo,int> { pub };
   pri let mut importId2localTypeInfoMap:Map<int,&TypeInfo> { pub& };

   //pub fn __init( fullName:str, symbolInfo:&SymbolInfo, idMap:Map<int,int> ) {
   pub fn __init( fullName:str, idMap:Map<&TypeInfo,int> ) {
      self.fullName = fullName;
      //self.symbolInfo = symbolInfo;
      self.localTypeInfo2importIdMap = idMap;
      self.importId2localTypeInfoMap = {};
      foreach importId, typeInfo in idMap {
         self.importId2localTypeInfoMap[ importId ] = typeInfo;
      }
   }
}

pub fn TypeInfo.getFullName( importInfo:&Map<&TypeInfo,ModuleInfo> ) : str {
   let mut typeInfo = self;
   let mut name = typeInfo.$rawTxt;
   while not importInfo[ typeInfo ] {
      typeInfo = typeInfo.$parentInfo;
      if typeInfo == headTypeInfo {
         break;
      }
      name = typeInfo.$rawTxt .. "." .. name;
   }
   return name;
}

_declNodeClass( "Root", Node, false, false,
                [ { "children": "List<&Node>" },
                  { "moduleTypeInfo": "&TypeInfo" },
                  { "provideNode": "&ProvideNode!" },
                  { "luneHelperInfo": "LuneHelperInfo" },
                  { "nodeManager": "NodeManager" },
                  { "importModule2moduleInfo": "Map<&TypeInfo,ModuleInfo>" },
                  { "typeId2ClassMap": "Map<int,&NamespaceInfo>" } ]
);

pub fn RootNode.set_provide( node: ProvideNode ) mut {
   self.provideNode = node;
}

_declNodeClass( "RefType", Node, false, false,
                [ { "name": "&Node" },
                  { "refFlag": "bool" },
                  { "mutFlag": "bool" },
                  { "array": "str" } ]
);

pub enum BlockKind {
   If,
   Elseif,
   Else,
   While,
   Switch,
   Repeat,
   For,
   Apply,
   Foreach,
   Macro,
   Func,
   Default,
   Block,
   Macro,
   LetUnwrap,
   IfUnwrap
}

_declNodeClass( "Block", Node, false, false,
                [ { "blockKind": "BlockKind" },
                  { "stmtList": "List<&Node>" } ]
);

pub class IfStmtInfo {
   pri let kind: str { pub };
   pri let exp: Node { pub };
   pri let block: BlockNode { pub };
}
_declNodeClass( "If", Node, false, false,
                [{ "stmtList": "IfStmtInfo[]" } ]
);

_declNodeClass( "ExpList", Node, true, true,
                [ { "expList": "List<&Node>" } ]
);
pub override fn ExpListNode.canBeLeft():bool {
   foreach expNode in self.$expList {
      if not expNode.canBeLeft() {
         return false;
      }
   }
   return true;
}
pub override fn ExpListNode.canBeRight():bool {
   foreach expNode in self.$expList {
      if not expNode.canBeRight() {
         return false;
      }
   }
   return true;
}


pub class CaseInfo {
   pri let expList: ExpListNode { pub };
   pri let block: BlockNode { pub };
}
_declNodeClass( "Switch", Node, false, false,
                [ { "exp": "&Node" },
                  { "caseList": "CaseInfo[]" },
                  { "default": "&BlockNode!" } ]
);


_declNodeClass( "While", Node, false, false,
                [ { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declNodeClass( "Repeat", Node, false, false,
                [ { "block": "&BlockNode" },
                  { "exp": "&Node" } ]
);

_declNodeClass( "For", Node, false, false,
                [ { "block": "&BlockNode" },
                  { "val": "&Parser.Token" },
                  { "init": "&Node" },
                  { "to": "&Node" },
                  { "delta": "&Node!" }] 
);

_declNodeClass( "Apply", Node, false, false,
                [ { "varList": "List<&Parser.Token>" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declNodeClass( "Foreach", Node, false, false,
                [ { "val": "&Parser.Token" },
                  { "key": "&Parser.Token!" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declNodeClass( "Forsort", Node, false, false,
                [ { "val": "&Parser.Token" },
                  { "key": "&Parser.Token!" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" },
                  { "sort": "bool" } ]
);

_declNodeClass( "Return", Node, false, false,
                [ { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "Break", Node, false, false, [] );

_declNodeClass( "Provide", Node, false, false,
                [ { "symbol": "&SymbolInfo" } ]
);     

_declNodeClass( "ExpNew", Node, false, true,
                [ { "symbol": "&Node" },
                  { "argList": "&ExpListNode!" } ]
);

_declNodeClass( "ExpUnwrap", Node, false, true,
                [ { "exp": "&Node" },
                  { "default": "&Node!" } ]
);

_declNodeClass( "ExpRef", Node, nil, nil,
                [ { "token": "&Parser.Token" },
                  { "symbolInfo": "&AccessSymbolInfo" } ]
);

pub override fn ExpRefNode.canBeLeft():bool {
   return self.$symbolInfo.$canBeLeft;
}

pub override fn ExpRefNode.canBeRight():bool {
   return self.$symbolInfo.$canBeRight;
}

_declNodeClass( "ExpOp2", Node, false, true,
                [ { "op": "&Parser.Token" },
                  { "exp1": "&Node" },
                  { "exp2": "&Node" } ]
);

_declNodeClass( "UnwrapSet", Node, false, false,
                [ { "dstExpList": "&ExpListNode" },
                  { "srcExpList": "&ExpListNode" },
                  { "unwrapBlock": "&BlockNode!" } ]              
);

_declNodeClass( "IfUnwrap", Node, false, false,
                [ { "varNameList": "List<str>" },
                  { "expNodeList": "List<&Node>" },
                  { "block": "&BlockNode" },
                  { "nilBlock": "&BlockNode!" } ]
);


_declNodeClass( "ExpCast", Node, false, true,
                [ { "exp": "&Node" } ]
);

pub enum MacroMode {
   None,
   Expand,
   Analyze,
}

_declNodeClass( "ExpOp1", Node, false, true,
                [ { "op": "&Parser.Token" },
                  { "macroMode": "MacroMode" },
                  { "exp": "&Node" } ]
);

_declNodeClass( "ExpRefItem", Node, true, true,
                [ { "val": "&Node" },
                  { "nilAccess": "bool" },
                  { "symbol": "str!" },
                  { "index": "&Node!" } ]
);
pub override fn ExpRefItemNode.canBeLeft(): bool {
   if self.val.$expType == builtinTypeStem {
      return false;
   }
   //return self.$expType.$mutable;
   return self.$val.$expType.$mutable and not self.nilAccess;
}

_declNodeClass( "ExpCall", Node, false, true,
                [ { "func": "&Node" },
                  { "nilAccess": "bool" },
                  { "argList": "&ExpListNode!" } ]
);

_declNodeClass( "ExpDDD", Node, false, true,
                [ { "token": "&Parser.Token" } ]
);

_declNodeClass( "ExpParen", Node, false, true,
                [ { "exp": "&Node" } ]
);

_declNodeClass( "ExpMacroExp", Node, false, false,
                [ { "stmtList": "List<&Node>" } ]
);

_declNodeClass( "ExpMacroStat", Node, false, true,
                [ { "expStrList": "List<&Node>" } ]
);

_declNodeClass( "StmtExp", Node, false, true,
                [ { "exp": "&Node" } ]
);

_declNodeClass( "ExpOmitEnum", Node, true, true,
                [ { "valToken": "&Parser.Token" },
                  { "enumTypeInfo": "&EnumTypeInfo" }]
);

_declNodeClass( "RefField", Node, true, true,
                [ { "field": "&Parser.Token" },
                  //{ "overrideCanBeLeft": "bool!" },
                  { "symbolInfo": "&AccessSymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "&Node" }] 
);
pub override fn RefFieldNode.canBeLeft():bool {
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return false;
}

_declNodeClass( "GetField", Node, false, true,
                [ { "field": "&Parser.Token" },
                  //{ "overrideCanBeLeft": "bool!" },
                  { "symbolInfo": "&AccessSymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "&Node" },
                  { "getterTypeInfo": "&TypeInfo" } ]               
);
pub override fn GetFieldNode.canBeLeft():bool {
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return false;
}


pub class VarInfo {
   pri let name: &Parser.Token { pub };
   // 宣言している型。 宣言していない場合は nil
   pri let refType: RefTypeNode! { pub };
   // 実際の型。
   pri let actualType: TypeInfo { pub };
}

pub enum DeclVarMode {
   Let,
   Sync,
   Unwrap,
}

_declNodeClass( "DeclVar", Node, false, false,
                [ { "mode": "DeclVarMode" },
                  { "accessMode": "AccessMode" },
                  { "staticFlag": "bool" },
                  { "varList": "List<&VarInfo>" },
                  { "expList": "&ExpListNode!" },
                  { "symbolInfoList": "List<&SymbolInfo>"},
                  { "typeInfoList": "List<&TypeInfo>" },
                  { "unwrapFlag": "bool" },
                  { "unwrapBlock": "&BlockNode!" },
                  { "thenBlock": "&BlockNode!" },
                  { "syncVarList": "List<&VarInfo>" },
                  { "syncBlock": "&BlockNode!" } ]
);

pub class DeclFuncInfo {
   pri let className: &Parser.Token! { pub };
   pri let name: &Parser.Token! { pub };
   pri let argList: List<&Node> { pub };
   pri let staticFlag: bool { pub };
   pri let accessMode: AccessMode { pub };
   pri let body: &BlockNode! { pub };
   pri let retTypeInfoList: List<&TypeInfo> { pub };
}
_declNodeClass( "DeclFunc", Node, false, true,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclMethod", Node, false, false,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclConstr", Node, false, false,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclDestr", Node, false, false,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "ExpCallSuper", Node, false, false,
                [ { "superType": "&TypeInfo" },
                  { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "DeclMember", Node, false, false,
                [ { "name": "&Parser.Token" },
                  { "refType": "&RefTypeNode" },
                  { "symbolInfo": "&SymbolInfo" },
                  { "staticFlag": "bool" },
                  { "accessMode": "AccessMode" },
                  { "getterMutable": "bool" },
                  { "getterMode": "AccessMode" },
                  { "setterMode": "AccessMode" } ]
);

_declNodeClass( "DeclArg", Node, false, false,
                [ { "name": "&Parser.Token" },
                  { "argType": "&RefTypeNode" } ]
);

_declNodeClass( "DeclArgDDD", Node, false, false, [] );

pub class AdvertiseInfo {
   pri let mut member: &DeclMemberNode { pub };
   pri let prefix: str {pub};
};
_declNodeClass( "DeclClass", Node, false, false,
                [ { "accessMode": "AccessMode" },
                  { "name": "&Parser.Token" },
                  { "gluePrefix": "str!" },
                  { "fieldList": "List<&Node>" },
                  { "moduleName": "&Parser.Token!" },
                  { "memberList": "List<&DeclMemberNode>" },
                  { "scope": "&Scope" },
                  { "initStmtList": "List<&Node>" },
                  { "advertiseList": "AdvertiseInfo[]" },
                  { "trustList": "List<&TypeInfo>" },
                  { "outerMethodSet": "Map<str,bool>" } ]
);

_declNodeClass( "DeclEnum", Node, false, false,
                [ { "accessMode": "AccessMode" },
                  { "name": "&Parser.Token" },
                  { "valueNameList": "List<&Parser.Token>" },
                  { "scope": "&Scope" } ]
);


_declNodeClass( "DeclMacro", Node, false, false,
                [ { "declInfo": "DeclMacroInfo" } ]
);

pub class MacroEval {
   pub fn eval( macroNode: DeclMacroNode ): form;
}

_declNodeClass( "LiteralNil", Node, false, true, [] );

_declNodeClass( "LiteralChar", Node, false, true,
                [ { "token": "&Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralInt", Node, false, true,
                [ { "token": "&Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralReal", Node, false, true,
                [ { "token": "&Parser.Token" },
                  { "num": "real" } ]
);

_declNodeClass( "LiteralArray", Node, false, true,
                [ { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "LiteralList", Node, false, true,
                [ { "expList": "&ExpListNode!" } ]
);

pub class PairItem {
   pri let key: Node { pub };
   pri let val: Node { pub };
}
_declNodeClass( "LiteralMap", Node, false, true,
                [ { "map": "Map<&Node,&Node>" },
                  { "pairList": "PairItem[]" } ]
);

_declNodeClass( "LiteralString", Node, false, true,
                [ { "token": "&Parser.Token" },
                  { "argList": "List<&Node>" } ]
);

_declNodeClass( "LiteralBool", Node, false, true,
                [ { "token": "&Parser.Token" } ]
);

_declNodeClass( "LiteralSymbol", Node, false, true,
                [ { "token": "&Parser.Token" } ]
);

pub fn Node.getSymbolInfo(): List<&AccessSymbolInfo> {
   fn processExpNode( node: &Node ): List<&AccessSymbolInfo> {
      switch ( node.$kind ) {
         case nodeKindExpRef {
            return [(node@@ExpRefNode).$symbolInfo];
         }
         case nodeKindRefField {
            let refFieldNode = node@@RefFieldNode;
            if! refFieldNode.$symbolInfo {
               return [_exp];
            }
            return [];
         }
         case nodeKindGetField {
            let getFieldNode = node@@GetFieldNode;
            if! getFieldNode.$symbolInfo {
               return [_exp];
            }
            return [];
         }
         case nodeKindExpList {
            let expListNode = node@@ExpListNode;
            let mut list: List<&AccessSymbolInfo> = [];
            foreach expNode, index in expListNode.$expList {
               if index == #expListNode.$expList {
                  foreach symbolInfo in processExpNode( expNode ) {
                     list.insert( symbolInfo );
                  }
               }
               else {
                  foreach symbolInfo in processExpNode( expNode ) {
                     list.insert( symbolInfo );
                     break;
                  }
               }
            }
            return list;
         }
      }
      return [];
   }
   return processExpNode( self );
}


pub override fn LiteralNilNode.getLiteral(): stem![], List<&TypeInfo> {
   return [nil], [builtinTypeNil];
}

pub override fn LiteralCharNode.getLiteral(): stem![], List<&TypeInfo> {
   return [self.num], [builtinTypeChar];
}

pub override fn LiteralIntNode.getLiteral(): stem![], List<&TypeInfo> {
   return [self.num], [builtinTypeInt];
}

pub override fn LiteralRealNode.getLiteral(): stem![], List<&TypeInfo> {
   return [self.num], [builtinTypeReal];
}

pub override fn LiteralArrayNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut array:stem![] = [];
   if! self.expList {
      foreach val in _exp.get_expList() {
         let! txt = val.getLiteral()[1] {
            // nil は処理できない。。。
            return [], [];
         };
         array.insert( txt );
      } 
   }
   return [array], [self.get_expType()];
}

pub override fn LiteralListNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut list:stem![] = [];
   if! self.expList {
      foreach val in _exp.get_expList() {
         let! item = val.getLiteral()[1] {
            // nil は処理できない。。。
            return [], [];
         };
         list.insert( item );
      } 
   }
   return [list], [self.get_expType()];
}

pub override fn LiteralMapNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut map:Map<str,stem!> = {};
   foreach val, key in self.map {
      map[ key.getLiteral()[1] ] = val.getLiteral()[1];
   }
   return [map], [self.get_expType()];
}

pub override fn LiteralStringNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut txt = self.token.txt;
   if string.find( txt, '^```' ) {
      txt = txt.sub( 4, -4 );
   }
   else {
      txt = txt.sub( 2, -2 );
   }
   let argList = self.$argList;

   if #argList > 0 {
      let mut argTbl:stem![] = [];
      foreach argNode in argList {
         let arg = argNode.getLiteral();
         if #arg > 1 {
            let! argTxt = arg[1] {
               // nil は処理できない。。。
               return [], [];
            };
            argTbl.insert( argTxt );
         }
      }   
      return [ string.format( txt, table.unpack( argTbl ) )], [builtinTypeString];
   }
   return [txt], [builtinTypeString];
}

pub override fn LiteralBoolNode.getLiteral(): stem![], List<&TypeInfo> {
   return [ self.token.txt == "true"], [builtinTypeBool];
}

pub override fn LiteralSymbolNode.getLiteral(): stem![], List<&TypeInfo> {
   return [[ self.token.txt ]], [ builtinTypeSymbol ];
}

pub override fn RefFieldNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut prefix = (unwrap self.prefix.getLiteral()[1])@@str[];
   if self.nilAccess {
      prefix.insert( "$." );
   }
   else {
      prefix.insert( "." );
   }
   prefix.insert( self.field.txt );
   return [ prefix ], [ builtinTypeSymbol ];
}

pub override fn ExpMacroStatNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut txt = "";
   foreach token in self.expStrList {
      txt = "%s%s" (txt, token.getLiteral()[1]);
   }
   return [txt ], [ self.get_expType() ];
}

pub override fn ExpRefNode.getLiteral(): stem![], List<&TypeInfo> {
   let typeInfo = self.symbolInfo.$typeInfo;
   if typeInfo.$kind ~= .Enum {
      return [], [];
   }
   let enumTypeInfo = typeInfo@@EnumTypeInfo;

   let val = unwrap enumTypeInfo.getEnumValInfo( self.symbolInfo.$name );
   return [ val.$val ], [ enumTypeInfo.$valTypeInfo ];
}

pub override fn ExpOp2Node.getLiteral(): stem![], List<&TypeInfo> {
   let val1List, mut type1List = self.$exp1.getLiteral();
   let val2List, mut type2List = self.$exp2.getLiteral();

   if #val1List ~= 1 or #type1List ~= 1 or #val2List ~= 1 or #type2List ~= 1 {
      return [], [];
   }

   let val1, type1, val2, type2 =
      unwrap val1List[1], type1List[1].$srcTypeInfo,
      unwrap val2List[1], type2List[1].$srcTypeInfo;
   

   if ( type1 == builtinTypeInt or type1 == builtinTypeReal ) and
      ( type2 == builtinTypeInt or type2 == builtinTypeReal )
   {
      let mut retType = builtinTypeInt;
      if type1 == builtinTypeReal or type2 == builtinTypeReal {
         retType = builtinTypeReal;
      }
      let mut int1, mut int2 = 0, 0;
      let mut real1, mut real2 = 0.0, 0.0;
      if type1 == builtinTypeInt {
         int1 = val1@@int;
         real1 = int1@@real;
      }
      else {
         real1 = val1@@real;
      }
      if type2 == builtinTypeInt {
         int2 = val2@@int;
         real2 = int2@@real;
      }
      else {
         real2 = val2@@real;
      }

      switch ( self.op.txt ) {
         case "+" {
            if retType == builtinTypeInt {
               return [ int1 + int2 ], [ retType ];
            }
            return [ real1 + real2 ], [ retType ];
         }
         case "-" {
            if retType == builtinTypeInt {
               return [ int1 - int2 ], [ retType ];
            }
            return [ real1 - real2 ], [ retType ];
         }
         case "*" {
            if retType == builtinTypeInt {
               return [ int1 * int2 ], [ retType ];
            }
            return [ real1 * real2 ], [ retType ];
         }
         case "/" {
            if retType == builtinTypeInt {
               return [ int1 / int2 ], [ retType ];
            }
            return [ real1 / real2 ], [ retType ];
         }
      }
   }
   elseif type1 == builtinTypeString and type2 == builtinTypeString {
      if self.op.txt == ".." {
         return [ val1@@str .. val2@@str ], [ builtinTypeString ];
      }
   }

   return [],[];
}
