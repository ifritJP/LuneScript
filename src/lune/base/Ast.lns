/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Parser;
import lune.base.Util;

pub let rootTypeId = 1;
let mut typeIdSeed = rootTypeId + 1;



pub proto class TypeInfo;
pub proto interface SymbolInfo;

pub let typeInfoKind:Map<str,TypeInfo> = {};
pub let sym2builtInTypeMap:Map<str,SymbolInfo> = {};
pub let builtInTypeIdSet:Map<int,TypeInfo> = {};

pub enum TypeInfoKind {
   Root,
   Macro,
   Prim,
   List,
   Array,
   Map,
   Class,
   IF,
   Func,    
   Method,  
   Nilable, 
   Enum,    
   Module,
}

pub fn isBuiltin( typeId: int ) : bool {
   return builtInTypeIdSet[ typeId ] ~= nil;
}

let dummyList:TypeInfo[] = [];

pub proto class Scope;

pub enum SymbolKind {
   Typ,
   Mbr,
   Mtd,
   Fun,
   Var,
   Arg,
}


/** シンボル情報 */
pub interface SymbolInfo {
   /** 左辺値になれる場合 true */
   pub fn get_canBeLeft(): bool;
   /** 右辺値になれる場合 true */
   pub fn get_canBeRight(): bool;
   /** このシンボルの ID */
   pub fn get_symbolId(): int;
   /** このシンボルが属するスコープ */
   pub fn get_scope(): Scope;
   /** シンボルのアクセス */
   pub fn get_accessMode(): str;
   /** */
   pub fn get_staticFlag(): bool;
   /** シンボルの名前 */
   pub fn get_name(): str;
   /** シンボルの型 */
   pub fn get_typeInfo(): TypeInfo;
   /** このシンボルが mut かどうか */
   pub fn get_mutable(): bool;
   /** このシンボルの種類 SymbolKind */
   pub fn get_kind(): SymbolKind;
   /** このシンボルがデータを保持しているかどうか */
   pub fn get_hasValueFlag(): bool;
   pub fn set_hasValueFlag( arg:bool );

   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub fn canAccess( fromScope:Scope ): SymbolInfo!;
}


pub class NormalSymbolInfo extend (SymbolInfo) {
   pri static let mut symbolIdSeed:int;

   __init {
      NormalSymbolInfo.symbolIdSeed = 0;
   }

   /** 左辺値になれる場合 true */
   pri let canBeLeft: bool { pub };
   /** 右辺値になれる場合 true */
   pri let canBeRight: bool { pub };
   
   /** このシンボルの ID */
   pri let symbolId: int { pub };
   /** このシンボルが属するスコープ */
   pri let scope: Scope { pub };
   /** シンボルのアクセス */
   pri let accessMode: str { pub };
   /** */
   pri let staticFlag: bool { pub };
   /** シンボルの名前 */
   pri let name: str { pub };
   /** シンボルの型 */
   pri let typeInfo: TypeInfo { pub };
   /** このシンボルが mut かどうか */
   pri let mutable: bool { pub };
   /** このシンボルの種類 SymbolKind */
   pri let kind: SymbolKind { pub };
   /** このシンボルがデータを保持しているかどうか */
   pri let hasValueFlag: bool { pub, pub };

   pub fn __init(
      kind:SymbolKind, canBeLeft:bool, canBeRight:bool, scope: Scope,
      accessMode: str, staticFlag: bool, name: str, 
      typeInfo: TypeInfo, mutable: bool!, hasValueFlag: bool )
   {
      NormalSymbolInfo.symbolIdSeed = NormalSymbolInfo.symbolIdSeed + 1;
      self.kind = kind;
      self.canBeLeft = canBeLeft;
      self.canBeRight = canBeRight;
      self.symbolId = NormalSymbolInfo.symbolIdSeed;
      self.scope = scope;
      self.accessMode = accessMode;
      self.staticFlag = staticFlag;
      self.name = name;
      self.typeInfo = typeInfo;
      self.mutable = mutable and true or false;
      self.hasValueFlag = hasValueFlag;
   }
   
   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub fn canAccess( fromScope:Scope ): SymbolInfo!;
}


pub class AccessSymbolInfo extend SymbolInfo {
   pri let symbolInfo: SymbolInfo {pub};

   advertise symbolInfo;
}

pub class DataOwnerInfo {
   pub let hasData:bool;
   pub let symbolInfo: SymbolInfo;
}


pub class Scope {
   // このスコープのオーナーの TypeInfo。
   // 名前空間に関連する class, function の TypeInfo。
   pri let ownerTypeInfo: TypeInfo! { pub, pub };
   // 親のスコープ。 これが self と等しい場合は root。
   pri let parent: Scope { pub };
   // このスコープに登録されているシンボル情報。
   // シンボル名 → TypeInfo のマップ。
   pri let symbol2TypeInfoMap: Map<str,SymbolInfo> { pub };
   // このスコープがクラスのスコープかどうか。
   pri let classFlag: bool;
   // 継承しているスコープ。
   pri let inheritList: Scope[] { pub };
   /** 所有権情報 */
   pri let symbolId2DataOwnerInfo: Map<int,DataOwnerInfo>;
      
      
   pub fn __init( parent: Scope!, classFlag: bool, inheritList: Scope[] ) {
      self.parent = unwrap parent default self;
      self.symbol2TypeInfoMap = {};
      self.inheritList = inheritList;
      self.classFlag = classFlag;
      self.symbolId2DataOwnerInfo = {};
   }

   pub fn set_ownerTypeInfo( owner: TypeInfo! ) {
      self.ownerTypeInfo = owner;
   }
   
   pub fn getTypeInfoChild( name: str ) : TypeInfo! {
      if! self.symbol2TypeInfoMap[ name ] {
         return _exp.$typeInfo;
      } 
      return nil;
   }

   pub fn getSymbolInfoChild( name: str ) : SymbolInfo! {
      return self.symbol2TypeInfoMap[ name ];
   }
   
   pub fn setData( symbolInfo:SymbolInfo ) {
      self.symbolId2DataOwnerInfo[ symbolInfo.$symbolId ] =
      new DataOwnerInfo( true, symbolInfo );
   }

   pub fn getNSTypeInfo(): TypeInfo;
}

// 最上位のスコープ
pub let rootScope = new Scope( nil, false, [] );

pub class TypeInfo {

   // この TypeInfo のスコープ。
   // class, func など名前空間を持つ TypeInfo は有効。
   pri let scope: Scope! { pub };

   pub fn __init( scope: Scope! ) {
      self.scope = scope;
      if! scope {
         _exp.set_ownerTypeInfo( self );
      } 
   }

   pub fn isModule(): bool {
      return true;
   }
   
   pub fn getParentId(): int {
      return rootTypeId;
   }

   pub fn get_baseId(): int {
      return rootTypeId;
   }

   pub fn isInheritFrom( other:TypeInfo ) : bool {
      return false;
   }

   pub fn isSettableFrom( other:TypeInfo ) : bool {
      return false;
   }

   pub fn get_abstructFlag(): bool {
      return false;
   }
   
   pub fn getTxt() : str {
      return "";
   }
   
   pub fn serialize( stream: oStream, validChildrenSet: Map<int,TypeInfo>! ) {
      return;
   }

   pub fn get_display_stirng(): str {
      return "";
   }

   pub fn equals( typeInfo: TypeInfo ): bool {
      return self == typeInfo;
   }

   pub fn get_externalFlag(): bool {
      return false;
   }
   
   pub fn get_interfaceList(): TypeInfo[] {
      return dummyList;
   }  
   pub fn get_itemTypeInfoList(): TypeInfo[] {
      return dummyList;
   }  
   pub fn get_argTypeInfoList(): TypeInfo[] {
      return dummyList;
   }  
   pub fn get_retTypeInfoList(): TypeInfo[] {
      return dummyList;
   }  
   pub fn get_parentInfo(): TypeInfo {
      return self;
   }  
   pub fn get_rawTxt(): str {
      return "";
   }  
   pub fn get_typeId(): int {
      return rootTypeId;
   }  
   pub fn get_kind(): TypeInfoKind {
      return TypeInfoKind.Root;
   } 
   pub fn get_staticFlag(): bool {
      return false;
   } 
   pub fn get_accessMode(): str {
      return "pri";
   }  
   pub fn get_autoFlag(): bool {
      return false;
   }  
   pub fn get_orgTypeInfo(): TypeInfo {
      return self;
   }  
   pub fn get_baseTypeInfo(): TypeInfo {
      return self;
   } 
   pub fn get_nilable(): bool {
      return false;
   }
   pub fn get_nilableTypeInfo(): TypeInfo {
      return self;
   }
   pub fn get_children(): TypeInfo[] {
      return dummyList;
   }
   pub fn get_mutable(): bool {
      return false;
   }
}

pub fn Scope.getSymbolInfoField(
   name: str, includeSelfFlag: bool!, fromScope:Scope ) : SymbolInfo!
{
   if self.classFlag {
      if includeSelfFlag {
         if! self.symbol2TypeInfoMap$[ name ] {
            let! symbolInfo = _exp.canAccess( fromScope ) {
               return nil;
            };
            return symbolInfo;
         }  
      } 
      if self.inheritList {
         foreach scope in self.inheritList {
            let symbolInfo = scope.getSymbolInfoField( name, true, fromScope );
            if symbolInfo {
               return symbolInfo;
            }   
         }  
      } 
   }

   return nil;
}

pub fn Scope.getTypeInfoField(
   name: str, includeSelfFlag: bool!, fromScope:Scope ) : TypeInfo!
{
   let symbolInfo = self.getSymbolInfoField( name, includeSelfFlag, fromScope );
   if! symbolInfo {
      return _exp.$typeInfo;
   }
   return nil;
}

pub fn Scope.filterTypeInfoField(
   includeSelfFlag: bool!, fromScope:Scope, callback:form ):bool
{
   if includeSelfFlag {
      foreach symbolInfo in self.symbol2TypeInfoMap {
         if symbolInfo.canAccess( fromScope ) {
            if not callback( symbolInfo ) {
               return false;
            }        
         }
      }  
   } 
   if self.classFlag {
      if self.inheritList {
         foreach scope in self.inheritList {
            if not scope.filterTypeInfoField( true, fromScope, callback ) {
               return false;
            }
         }
      } 
   }

   return true;
}


/**
このスコープからシンボル name の型情報を取得する。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
@param onlySameNsFlag true の場合、検索対象を同一名前空間内に限定する。
*/
pub fn Scope.getSymbolInfo(
   name: str, fromScope:Scope, onlySameNsFlag:bool ) : SymbolInfo!
{
   if! self.symbol2TypeInfoMap[ name ] {
      let! symbolInfo = _exp.canAccess( fromScope ) {
         return nil;
      };
      return symbolInfo;
   }
   if not onlySameNsFlag {
      if self.inheritList {
         foreach scope in self.inheritList {
            let symbolInfo = scope.getSymbolInfoField( name, true, fromScope );
            if symbolInfo {
               return symbolInfo;
            }   
         }   
      } 
   }
   if not onlySameNsFlag or not self.ownerTypeInfo {
      if self.parent ~= self {
         return self.parent.getSymbolInfo( name, fromScope, onlySameNsFlag );
      } 
   }
   if onlySameNsFlag {
      return nil;
   }
   if! sym2builtInTypeMap[ name ] {
      return _exp;
   }
   return nil;
}

pub fn Scope.getTypeInfo(
   name: str, fromScope:Scope, onlySameNsFlag:bool ) : TypeInfo!
{
   let! symbolInfo = self.getSymbolInfo(name, fromScope, onlySameNsFlag ) {
      return nil;
   };
   return symbolInfo.$typeInfo;
}


/**
このスコープからシンボル name の型情報を取得する。
フィールドを除く name。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
*/
pub fn Scope.getSymbolTypeInfo(
   name: str, fromScope:Scope, moduleScope:Scope ) : SymbolInfo!
{
   let mut typeInfo:TypeInfo! = nil;
   let mut validThisScope = false;

   if! self.ownerTypeInfo {
      if _exp.$kind == TypeInfoKind.Func or _exp.$kind == TypeInfoKind.Method or
         self == moduleScope or self == rootScope
      { 
         validThisScope = true;
      } 
      elseif ( _exp.$kind == TypeInfoKind.IF or
               _exp.$kind == TypeInfoKind.Class or
               _exp.$kind == TypeInfoKind.Module ) and name == "self" {
         validThisScope = true;
      }
      elseif _exp.$kind == TypeInfoKind.Enum {
         validThisScope = true;
      }
   } 
   else {
      validThisScope = true;
   }
   if validThisScope {
      if! self.symbol2TypeInfoMap[ name ] {
         return _exp.canAccess( fromScope );
      } 
   }
   if self.parent ~= self {
      return self.parent.getSymbolTypeInfo( name, fromScope, moduleScope );
   }
   return sym2builtInTypeMap[ name ];
}


pub fn Scope.filterSymbolTypeInfo(
   fromScope:Scope, moduleScope:Scope, callback:form )
{
   if self.classFlag {
      if! self.symbol2TypeInfoMap[ "self" ] {
         callback( _exp );
      }
   }
   if moduleScope == fromScope or not self.classFlag {
      foreach symbolInfo in self.symbol2TypeInfoMap {
         if not callback( symbolInfo ) {
            return;
         }  
      }
   }

   if self.parent ~= self {
      self.parent.filterSymbolTypeInfo( fromScope, moduleScope, callback );
   }
}


pub fn Scope.add( kind: SymbolKind, canBeLeft:bool, canBeRight:bool,
                  name:str, typeInfo: TypeInfo, accessMode:str,
                  staticFlag:bool, mutable:bool, hasValueFlag:bool ) : SymbolInfo
{
   let symbolInfo = new NormalSymbolInfo(
      kind, canBeLeft, canBeRight,
      self, accessMode, staticFlag, name, typeInfo, mutable, hasValueFlag );
   self.symbol2TypeInfoMap[ name ] = symbolInfo;
   return symbolInfo;
}

pub fn Scope.addLocalVar(
   argFlag:bool, canBeLeft:bool, name:str, typeInfo: TypeInfo, mutable:bool )
{
   self.add( argFlag and SymbolKind.Arg or SymbolKind.Var,
             canBeLeft, true, name, typeInfo,
             "local", false, mutable, true );
}

pub fn Scope.addStaticVar(
   argFlag:bool, canBeLeft:bool, name:str, typeInfo: TypeInfo, mutable:bool )
{
   self.add( argFlag and SymbolKind.Arg or SymbolKind.Var,
             canBeLeft, true, name, typeInfo,
             "local", true, mutable, true );
}

pub fn Scope.addVar(
   accessMode:str, name:str, typeInfo: TypeInfo, mutable:bool, hasValueFlag:bool )
{
   self.add( SymbolKind.Var, true, true, name, typeInfo,
             accessMode, false, mutable, hasValueFlag );
}


pub fn Scope.addEnumVal( name:str, typeInfo: TypeInfo )
{
   self.add( SymbolKind.Mbr, false, true,
             name, typeInfo, "pub", true, true, true );
}

pub fn Scope.addEnum( accessMode:str, name:str, typeInfo: TypeInfo )
{
   self.add( SymbolKind.Typ, false, false,
             name, typeInfo, accessMode, true, true, true );
}

pub fn Scope.addMember( name:str, typeInfo: TypeInfo, accessMode:str,
                        staticFlag:bool, mutable:bool ) : SymbolInfo
{
   return self.add( SymbolKind.Mbr, true, true,
                    name, typeInfo, accessMode, staticFlag, mutable, false );
}

pub fn Scope.addMethod(
   typeInfo: TypeInfo, accessMode:str, staticFlag:bool, mutable:bool )
{
   self.add( SymbolKind.Mtd, true, true, typeInfo.getTxt(),
             typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addFunc(
   typeInfo: TypeInfo, accessMode:str, staticFlag:bool, mutable:bool )
{
   self.add( SymbolKind.Fun, true, true, typeInfo.getTxt(),
             typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addClass( name:str, typeInfo: TypeInfo )
{
   self.add( SymbolKind.Typ, false, false, name, typeInfo,
             typeInfo.$accessMode, true, true, true );
} 

fn dumpScopeSub( scope: Scope!, prefix:str, readyIdSet:Map<Scope,bool> ) {
   sync! scope = scope { return; }
   then {
      if readyIdSet[ scope ] {
         return;
      } 
      readyIdSet[ scope ] = true;
      if #prefix > 20 {
         Util.err("illegal");
      }   
      
      forsort symbolInfo, symbol in scope.$symbol2TypeInfoMap {
         Util.log( "scope: %s, %s, %s" ( prefix, scope, symbol ) );
         if! symbolInfo.$typeInfo.$scope {
            dumpScopeSub( _exp, prefix .. "  ", readyIdSet );
         }  
      } 
   };
}

fn dumpScope( scope: Scope!, prefix:str ) {
   dumpScopeSub( scope, prefix, {} );
}



pub let rootTypeInfo:TypeInfo = new TypeInfo( rootScope );


pub fn Scope.getNSTypeInfo(): TypeInfo {
   let mut scope = self;
   while scope.ownerTypeInfo ~= rootTypeInfo {
      if! scope.ownerTypeInfo {
         return _exp;
      } 
      scope = scope.parent;
   }
   return rootTypeInfo;
}

pub fn Scope.getClassTypeInfo(): TypeInfo {
   let mut scope = self;
   while scope.ownerTypeInfo ~= rootTypeInfo {
      if! scope.ownerTypeInfo {
         if _exp.$kind == TypeInfoKind.Class or
            _exp.$kind == TypeInfoKind.IF or _exp.$kind == TypeInfoKind.Module {
            return _exp;
         }  
      } 
      scope = scope.parent;
   }
   return rootTypeInfo;
}


/**
このシンボルが、fromScope のスコープからアクセスできるか調べる。
 */
pub fn NormalSymbolInfo.canAccess( fromScope:Scope ): SymbolInfo!
{
   let typeInfo = self.$typeInfo;
   if self.scope == fromScope {
      return self;
   }
   switch self.$accessMode {
      case "pub", "global" {
         return self;
      }           
      case "pro" {
         let nsClass = self.scope.getClassTypeInfo();
         let fromClass = fromScope.getClassTypeInfo();
         if fromClass.isInheritFrom( nsClass ) {
            return self;
         }  
         return nil;
      } 
      case "local" {
         return self;
      } 
      case "pri" {
         let nsClass = self.scope.getClassTypeInfo();
         let fromClass = fromScope.getClassTypeInfo();
         if nsClass == fromClass {
            return self;
         }  
         return nil;
      } 
   }
   Util.err( "illegl accessmode -- %s, %s"
               (self.$accessMode, self.$name) );
}

pub proto class Node;
pub proto class DeclClassNode extend Node;

pub class NilableTypeInfo extend TypeInfo {
   pri let orgTypeInfo: TypeInfo { pub };
   pri let typeId: int { pub };

   pub override fn get_kind(): TypeInfoKind {
      return TypeInfoKind.Nilable;
   } 
   pub override fn get_nilable(): bool {
      return true;
   } 
   pub override fn getTxt() : str {
      return self.orgTypeInfo.getTxt() .. "!";
   }
   pub override fn get_display_stirng(): str {
      return self.orgTypeInfo.$display_stirng .. "!";
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ parentId = %d, typeId = %d, nilable = true, orgTypeId = %d }\n' (
            parentId, self.typeId, self.orgTypeInfo.$typeId ) );
   }
   
   advertise orgTypeInfo;
}


pub class ModifierTypeInfo extend TypeInfo {
   pri let orgTypeInfo: TypeInfo { pub };
   pri let typeId: int { pub };
   pri let mutable: bool! { pub };

   pub override fn getTxt() : str {
      let mut txt = self.orgTypeInfo.getTxt();
      if self.mutable {
         txt = "mut " .. txt;
      }
      return txt;
   }
   pub override fn get_display_stirng(): str {
      let mut txt = self.orgTypeInfo.get_display_stirng();
      if self.mutable {
         txt = "mut " .. txt;
      }
      return txt;
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ parentId = %d, typeId = %d, orgTypeId = %d, mutable = %s }\n' (
            parentId, self.typeId, self.orgTypeInfo.$typeId,
            self.mutable and true or false ) );
   }
   
   advertise orgTypeInfo;
}


pub class ModuleTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let parentInfo: TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // 子のタイプリスト。 このタイプがクラスなら、メソッドが子。
   pri let children: TypeInfo[] { pub };

   pub fn __init( scope: Scope, externalFlag: bool,
                  txt: str, parentInfo: TypeInfo!, typeId: int )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default rootTypeInfo;
      self.typeId = typeId;
      self.children = [];

      if self.parentInfo ~= rootTypeInfo {
         self.parentInfo.$children.insert( self );
      }

      typeIdSeed = typeIdSeed + 1;

      scope.set_ownerTypeInfo( self );
   }

   pub override fn isModule(): bool {
      return true;
   }

   pub override fn get_accessMode(): str {
      return "pub";
   }

   pub override fn get_kind(): TypeInfoKind {
      return TypeInfoKind.Module;
   } 
   
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   pub override fn getTxt() : str {
      return self.rawTxt;
   }

   pub override fn get_display_stirng(): str {
      return self.getTxt();
   }
   
   pub override fn isSettableFrom( other:TypeInfo ) : bool {
      return false;
   }

   pub override fn serialize(
      stream: oStream, validChildrenSet: Map<int,TypeInfo>! )
   {  
      let txt = "{ parentId = %d, typeId = %d, txt = '%s', kind = %d, "
          ( self.getParentId(), self.typeId, self.rawTxt, TypeInfoKind.Module );
      stream.write( txt .. '\n' );

      stream.write( "children = {" );

      let mut children = self.children;
      if! validChildrenSet {
         children = [];
         foreach child in self.children {
            if _exp[ child.$typeId ] {
               children.insert( child );
            }  
         }  
      }
      forsort child in children {
         stream.write( "%d, " ( child.$typeId ) );
      }  
      stream.write( "} }\n" );
   }
}

pub class EnumValInfo {
   pri let name: str {pub};
   pri let val:stem {pub};
}

pub class EnumTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let parentInfo: TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: str { pub };
   pri let nilableTypeInfo: TypeInfo { pub };

   // この enum で格納している値の型
   pri let valTypeInfo: TypeInfo {pub};
   

   // enum 値名 -> EnumValInfo
   pri let name2EnumValInfo: Map<str,EnumValInfo> { pub };
   
   pub fn __init( scope: Scope, externalFlag: bool, accessMode: str,
                  txt: str, parentInfo: TypeInfo!, typeId: int, valTypeInfo:TypeInfo,
                  name2EnumValInfo: Map<str,EnumValInfo> )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default rootTypeInfo;
      self.typeId = typeId;
      self.name2EnumValInfo = name2EnumValInfo;
      self.valTypeInfo = valTypeInfo;

      if self.parentInfo ~= rootTypeInfo {
         self.parentInfo.$children.insert( self );
      }

      self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
      typeIdSeed = typeIdSeed + 1;

      scope.set_ownerTypeInfo( self );
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn get_kind(): TypeInfoKind {
      return TypeInfoKind.Enum;
   } 
   
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   pub override fn getTxt() : str {
      return self.rawTxt;
   }

   pub override fn get_display_stirng(): str {
      return self.getTxt();
   }
   
   pub override fn isSettableFrom( other:TypeInfo ) : bool {
      return self == other;
   }

   pub fn getEnumValInfo( name:str ): EnumValInfo! {
      return self.name2EnumValInfo[ name ];
   }
}


pub class NormalTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // generic のタイプ
   pri let itemTypeInfoList: TypeInfo[] { pub };
   // 引数のタイプ
   pri let argTypeInfoList: TypeInfo[] { pub };
   // 戻り値のタイプ
   pri let retTypeInfoList: TypeInfo[] { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let parentInfo: TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // タイプの種別
   pri let kind: TypeInfoKind { pub };
   // static かどうか
   pri let staticFlag: bool { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: str { pub };
   // コンパイラで自動生成された型情報の場合 true。 accessor 等。
   pri let autoFlag: bool { pub };
   /** */
   pri let abstructFlag: bool { pub };

   // unwrap 後の TypeInfo。 無効な場合は rootTypeInfo。
   pri let mut orgTypeInfo: TypeInfo { pub };
   // 基底クラス。 無効な場合は rootTypeInfo。
   pri let baseTypeInfo: TypeInfo { pub };
   // インタフェースのリスト。
   pri let interfaceList: TypeInfo[] { pub };

   // この型が nilable を表わす型かどうか。
   pri let mut nilable: bool { pub };
   // この型の nilable 版の TypeInfo。 無効な場合は rootTypeInfo。
   pri let mut nilableTypeInfo: TypeInfo { pub };
   // 子のタイプリスト。 このタイプがクラスなら、メソッドが子。
   pri let children: TypeInfo[] { pub };
   // このメソッドが mutable かどうか。
   pri let mutable: bool {pub};

   fn __init( abstructFlag:bool, scope: Scope!, baseTypeInfo: TypeInfo!,
              interfaceList: TypeInfo[]!, orgTypeInfo: TypeInfo!,
              autoFlag: bool, externalFlag: bool, staticFlag: bool, accessMode: str,
              txt: str, parentInfo: TypeInfo!, typeId: int, kind: TypeInfoKind,
              itemTypeInfoList: TypeInfo[]!, argTypeInfoList:TypeInfo[]!,
              retTypeInfoList: TypeInfo[]!, mutable: bool! )
   {
      super( scope );

      if type(kind) ~= "number" {
         Util.printStackTrace();
      }
      
      self.abstructFlag = abstructFlag;
      self.baseTypeInfo = unwrap baseTypeInfo default rootTypeInfo;
      self.interfaceList = unwrap interfaceList default [];
      self.autoFlag = autoFlag;
      self.externalFlag = externalFlag;
      self.staticFlag = staticFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.kind = kind;
      self.itemTypeInfoList = unwrap itemTypeInfoList default [];
      self.argTypeInfoList = unwrap argTypeInfoList default [];
      self.retTypeInfoList = unwrap retTypeInfoList default [];
      self.orgTypeInfo = unwrap orgTypeInfo default rootTypeInfo;
      self.parentInfo = unwrap parentInfo default rootTypeInfo;
      self.children = [];
      self.mutable = mutable and true or false;

      // if dummyRootTypeInfo and not parentInfo {
      //     Util.debugLog();
      //     error( "" );
      // }

      self.typeId = typeId;
      if kind == TypeInfoKind.Root {
         self.nilable = false;
         // dummyRootTypeInfo = self;
      } 
      elseif txt == "nil" {
         self.nilable = true;
         self.nilableTypeInfo = self;
         self.orgTypeInfo = self;
      } 
      elseif not orgTypeInfo {
         if self.parentInfo ~= rootTypeInfo {
            self.parentInfo.$children.insert( self );
         }  
         self.nilable = false;

         let mut hasNilable = false;

         switch ( kind ) {
            case TypeInfoKind.Prim, TypeInfoKind.List, TypeInfoKind.Array,
                 TypeInfoKind.Map, TypeInfoKind.Class,
                 TypeInfoKind.Module, TypeInfoKind.IF   
            {
               hasNilable = true;
            }   
            case TypeInfoKind.Func, TypeInfoKind.Method {
               hasNilable = true;
            }
         }  
         if hasNilable {
            if txt == "..." {
               self.nilableTypeInfo = self;
            }
            else {
               // self.nilableTypeInfo = new NormalTypeInfo(
               //    false, nil, baseTypeInfo, interfaceList, self, autoFlag, externalFlag,
               //    staticFlag, accessMode, "", parentInfo, typeId + 1,
               //    TypeInfoKind.Nilable, itemTypeInfoList,
               //    argTypeInfoList, retTypeInfoList );
               self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
               typeIdSeed = typeIdSeed + 1;
            }
         }
         else {
            self.nilableTypeInfo = rootTypeInfo;
         }  
         typeIdSeed = typeIdSeed + 1;
      } 
      else {
         self.nilable = true;
         self.nilableTypeInfo = rootTypeInfo;
      } 
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn getParentId(): int {
      return self.parentInfo and self.parentInfo.$typeId or rootTypeId;
   }

   pub override fn get_baseId(): int {
      return self.baseTypeInfo and self.baseTypeInfo.$typeId or rootTypeId;
   }

   pub override fn getTxt() : str {
      if self.nilable and (self.nilableTypeInfo ~= self.orgTypeInfo) {
         return (unwrap self.orgTypeInfo).getTxt() .. "!";
      } 
      if self.kind == TypeInfoKind.Array {
         let! _exp = self.itemTypeInfoList[1] {
            return "[@]";
         }; 
         return _exp.getTxt() .. "[@]";
      } 
      if self.kind == TypeInfoKind.List {
         let! _exp = self.itemTypeInfoList[1] {
            return "[]";
         }; 
         return _exp.getTxt() .. "[]";
      } 
      if self.itemTypeInfoList and #self.itemTypeInfoList > 0 {
         let mut txt = self.rawTxt .. "<";
         foreach typeInfo, index in self.itemTypeInfoList {
            if index ~= 1 {
               txt = txt .. ",";
            }   
            txt = txt .. typeInfo.getTxt();
         }  

         return txt .. ">";
      } 
      if self.$rawTxt {
         return self.$rawTxt;
      } 
      return "";
   }

   pub override fn get_display_stirng(): str {
      if self.kind == TypeInfoKind.Nilable {
         return (unwrap self.orgTypeInfo).get_display_stirng() .. "!";
      }
      if self.kind == TypeInfoKind.Func or self.kind == TypeInfoKind.Method
      {
         let mut txt = self.$rawTxt .. "(";
         foreach argType, index in self.argTypeInfoList {
            if index ~= 1 {
               txt = txt .. ", ";
            }
            txt = txt .. argType.get_display_stirng();
         }
         txt = txt .. ")";
         foreach retType, index in self.retTypeInfoList {
            if index == 1 {
               txt = txt .. ": ";
            }
            else {
               txt = txt .. ", ";
            }
            txt = txt .. retType.get_display_stirng();
         }
         return txt;
      }
      return self.getTxt();
   }

   
   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,TypeInfo>! ) {
      if self.typeId == rootTypeId {
         return;
      }

      let parentId = self.getParentId();
      if self.nilable {
         stream.write(
            '{ parentId = %d, typeId = %d, nilable = true, orgTypeId = %d }\n' (
               parentId, self.typeId, self.orgTypeInfo.$typeId ) );
         return;
      } 

      fn serializeTypeInfoList( name: str, list: TypeInfo[], onlyPub: bool! ): str {
         let mut work = name;
         foreach typeInfo in list {
            if not onlyPub or typeInfo.$accessMode == "pub"  {
               if #work ~=  #name {
                  work = work .. ", ";
               }    
               work = "%s%d" (work, typeInfo.$typeId );
            }   
         }  
         return work .. "}, ";
      } 

      let txt = ```{ parentId = %d, typeId = %d, baseId = %d, txt = '%s',
        staticFlag = %s, accessMode = '%s', kind = %d, ```
          ( parentId, self.typeId, self.get_baseId(), self.rawTxt,
            self.staticFlag, self.accessMode, self.kind );

      let mut children = self.children;
      if! validChildrenSet {
         children = [];
         foreach child in self.children {
            if _exp[ child.$typeId ] {
               children.insert( child );
            }
         }
      }

      stream.write(
         txt .. serializeTypeInfoList( "itemTypeId = {",
                                       self.itemTypeInfoList ) ..
         serializeTypeInfoList( "ifList = {", self.interfaceList ) ..
         serializeTypeInfoList( "argTypeId = {", self.argTypeInfoList ) ..
         serializeTypeInfoList( "retTypeId = {", self.retTypeInfoList ) ..
         serializeTypeInfoList( "children = {", children, true ) .. "}\n" );
   }

   pub fn equalsSub( typeInfo: TypeInfo ): bool {
      if not typeInfo {
         return false;
      } 
      if self.typeId == typeInfo.$typeId {
         return true;
      } 
      // プリミティブな設定のチェック
      if //self.externalFlag ~= typeInfo.externalFlag or
      self.kind ~= typeInfo.$kind or
         self.staticFlag ~= typeInfo.$staticFlag or
         self.accessMode ~= typeInfo.$accessMode or
         self.autoFlag ~= typeInfo.$autoFlag or
         self.nilable ~= typeInfo.$nilable
      { 
         // errorLog( "%s, %s" ( self.externalFlag, typeInfo.externalFlag ) );
         // errorLog( "%s, %s" ( self.kind, typeInfo.kind ) );
         // errorLog( "%s, %s" ( self.staticFlag, typeInfo.staticFlag ) );
         // errorLog( "%s, %s" ( self.accessMode, typeInfo.accessMode ) );
         // errorLog( "%s, %s" ( self.autoFlag, typeInfo.autoFlag ) );
         // errorLog( "%s, %s" ( self.nilable, typeInfo.nilable ) );
         return false;
      } 

      if (not self.itemTypeInfoList and typeInfo.$itemTypeInfoList or
           self.itemTypeInfoList and not typeInfo.$itemTypeInfoList or
           not self.retTypeInfoList and typeInfo.$retTypeInfoList or
           self.retTypeInfoList and not typeInfo.$retTypeInfoList or
           self.orgTypeInfo ~= typeInfo.$orgTypeInfo )
      { 
         Util.log( "%s, %s" (self.itemTypeInfoList, typeInfo.$itemTypeInfoList ) );
         Util.log( "%s, %s" ( self.retTypeInfoList, typeInfo.$retTypeInfoList ) );
         Util.log( "%s, %s" ( self.orgTypeInfo, typeInfo.$orgTypeInfo ) );
         //          error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
         //                                     typeInfo.getTxt(), typeInfo.typeId ) );
         return false;
      } 

      if self.itemTypeInfoList {
         if #self.itemTypeInfoList ~= #typeInfo.$itemTypeInfoList {
            return false;
         }  
         foreach item, index in self.itemTypeInfoList {
            if not item.equals( typeInfo.$itemTypeInfoList[ index ] ) {
               //              error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
               //                                             typeInfo.getTxt(), typeInfo.typeId ) );
               return false;
            }   
         }  
      } 

      if self.retTypeInfoList {
         if #self.retTypeInfoList ~= #typeInfo.$retTypeInfoList {
            //              error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
            //                                             typeInfo.getTxt(), typeInfo.typeId ) );
            return false;
         }  
         foreach item, index in self.retTypeInfoList {
            if not item.equals( typeInfo.$retTypeInfoList[ index ] ) {
               //              error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
               //                                             typeInfo.getTxt(), typeInfo.typeId ) );
               return false;
            }   
         }  
      } 

      if self.orgTypeInfo and not self.orgTypeInfo.equals( typeInfo.$orgTypeInfo ) {
         //      error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
         //                                     typeInfo.getTxt(), typeInfo.typeId ) );
         return false;
      } 

      return true;
   }

   pub override fn equals( typeInfo: TypeInfo ): bool {
      return self.equalsSub( typeInfo );
   }


   // pub static fn cloneToPublic( typeInfo: TypeInfo ): NormalTypeInfo {
   //    typeIdSeed = typeIdSeed + 1;
   //    return new NormalTypeInfo(
   //       typeInfo.$scope, typeInfo.$baseTypeInfo, nil, typeInfo.$autoFlag,
   //       typeInfo.$externalFlag, typeInfo.$staticFlag,
   //       "pub", typeInfo.$rawTxt, typeInfo.$parentInfo, typeIdSeed, typeInfo.$kind,
   //       typeInfo.$itemTypeInfoList, typeInfo.$argTypeInfoList,
   //       typeInfo.$retTypeInfoList );
   // }



   pub static fn create(
      abstructFlag: bool, scope: Scope!, baseInfo: TypeInfo,
      interfaceList: TypeInfo[], parentInfo: TypeInfo, staticFlag: bool,
      kind: TypeInfoKind, txt: str, itemTypeInfo: TypeInfo[],
      argTypeInfoList: TypeInfo[], retTypeInfoList: TypeInfo[],
      mutable: bool! ): TypeInfo
   {  
         if kind == TypeInfoKind.Prim {
            if! sym2builtInTypeMap[ txt ] {
               return _exp.$typeInfo;
            }
            Util.err( "not found symbol -- %s" (txt ) );
         }  
         typeIdSeed = typeIdSeed + 1;
         let info = new NormalTypeInfo(
            abstructFlag, scope, baseInfo, interfaceList, nil, false, true,
            staticFlag, "pub", txt, parentInfo, typeIdSeed, kind,
            itemTypeInfo, argTypeInfoList, retTypeInfoList, mutable ); 
         return info;
      } 
}


pub let typeInfoRoot = rootTypeInfo;


typeIdSeed = typeIdSeed + 1;

pub static fn NormalTypeInfo.createBuiltin(
   idName: str, typeTxt: str, kind: TypeInfoKind, typeDDD: TypeInfo! ): TypeInfo {
      let mut typeId = typeIdSeed + 1;
      if kind == TypeInfoKind.Root {
         typeId = rootTypeId;
      } 
      else {
         typeIdSeed = typeIdSeed + 1;
      } 
      let mut argTypeList:TypeInfo[] = [];
      let mut retTypeList:TypeInfo[] = [];
      if typeTxt == "form" {
         if! typeDDD {
            argTypeList = [ _exp ];
            retTypeList = [ _exp ];
         }  
      } 

      let mut scope:Scope! = nil;
      switch kind {
         case TypeInfoKind.List, TypeInfoKind.Class, TypeInfoKind.Module,
              TypeInfoKind.IF, TypeInfoKind.Func, TypeInfoKind.Method,
              TypeInfoKind.Macro
         {  
            scope = new Scope(
               rootScope,
               kind == TypeInfoKind.Class or kind == TypeInfoKind.Module or
               kind == TypeInfoKind.IF or kind == TypeInfoKind.List, [] );
         }  
      } 
      
      let info = new NormalTypeInfo( false, scope, nil, nil, nil, false, false, false,
                                     "pub", typeTxt, typeInfoRoot, typeId, kind,
                                     [], argTypeList, retTypeList, false );
      if scope {
         rootScope.addClass( typeTxt, info );
      } 

      typeInfoKind[ idName ] = info;
      sym2builtInTypeMap[ typeTxt ] = new NormalSymbolInfo(
         SymbolKind.Typ, false, false,
         rootScope, "pub", false, typeTxt, info, false, true );
      if info.$nilableTypeInfo ~= rootTypeInfo {
         sym2builtInTypeMap[ typeTxt .. "!" ] = new NormalSymbolInfo(
            SymbolKind.Typ, false, kind == TypeInfoKind.Func, rootScope, "pub",
            false, typeTxt, info.$nilableTypeInfo, false, true );
         builtInTypeIdSet[ info.$nilableTypeInfo.$typeId ] = info.$nilableTypeInfo;
      } 
      
      builtInTypeIdSet[ info.typeId ] = info;
      return info;
   }

pub static fn NormalTypeInfo.createList(
   accessMode: str, parentInfo: TypeInfo, itemTypeInfo: TypeInfo[] ): TypeInfo {
      if not itemTypeInfo or #itemTypeInfo == 0 {
         Util.err( "illegal list type: %s" (itemTypeInfo) );
      } 
      typeIdSeed = typeIdSeed + 1;
      return new NormalTypeInfo(
         false, nil, nil, nil, nil, false, false, false, accessMode, "",
         typeInfoRoot, typeIdSeed, TypeInfoKind.List, itemTypeInfo, nil, nil, false );
   }

pub static fn NormalTypeInfo.createArray(
   accessMode: str,
   parentInfo: TypeInfo, itemTypeInfo: TypeInfo[] ): TypeInfo {
      typeIdSeed = typeIdSeed + 1;
      return new NormalTypeInfo(
         false, nil, nil, nil, nil, false, false, false, accessMode, "",
         typeInfoRoot, typeIdSeed, TypeInfoKind.Array, itemTypeInfo, nil, nil, false );
   }

pub static fn NormalTypeInfo.createMap(
   accessMode: str, parentInfo: TypeInfo,
   keyTypeInfo: TypeInfo, valTypeInfo: TypeInfo ): TypeInfo
{
   typeIdSeed = typeIdSeed + 1;
   return new NormalTypeInfo(
      false, nil, nil, nil, nil, false, false, false, accessMode, "Map",
      typeInfoRoot, typeIdSeed, TypeInfoKind.Map,
      [ keyTypeInfo, valTypeInfo ], nil, nil, false );
}


pub static fn NormalTypeInfo.createModule(
   scope: Scope, parentInfo: TypeInfo,
   externalFlag: bool, moduleName: str ): TypeInfo
{
   if! sym2builtInTypeMap[ moduleName ] {
      return _exp.$typeInfo;
   }

   if Parser.isLuaKeyword( moduleName ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (moduleName) );
   }
   
   typeIdSeed = typeIdSeed + 1;
   let info = new ModuleTypeInfo(
      scope, externalFlag, moduleName, parentInfo, typeIdSeed );
   return info;
}


pub static fn NormalTypeInfo.createClass(
   classFlag: bool, abstructFlag: bool, scope: Scope!,
   baseInfo: TypeInfo!, interfaceList: TypeInfo[]!,
   parentInfo: TypeInfo, externalFlag: bool,
   accessMode: str, className: str ): TypeInfo
{
   // if className == "str" {
   //     return sym2builtInTypeMap[ className ]@TypeInfo;
   // }
   if! sym2builtInTypeMap[ className ] {
      return _exp.$typeInfo;
      //return classTypeInfo@TypeInfo;
   }

   if Parser.isLuaKeyword( className ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (className) );
   }
   
   typeIdSeed = typeIdSeed + 1;
   let info = new NormalTypeInfo(
      abstructFlag, scope, baseInfo, interfaceList, nil, false,
      externalFlag, false, accessMode,
      className, parentInfo, typeIdSeed,
      classFlag and TypeInfoKind.Class or TypeInfoKind.IF, nil, nil, nil, false );
   return info;
}

pub static fn NormalTypeInfo.createFunc(
   abstructFlag: bool, builtinFlag:bool, scope: Scope!, kind: TypeInfoKind,
   parentInfo: TypeInfo, autoFlag: bool, externalFlag: bool,
   staticFlag: bool, accessMode: str, funcName: str, argTypeList: TypeInfo[]!,
   retTypeInfoList: TypeInfo[]!, mutable: bool! ): TypeInfo
{
   if not builtinFlag and Parser.isLuaKeyword( funcName ) {
      Util.err( "This symbol can not use for a function. -- %s" (funcName) );
   }
   
   typeIdSeed = typeIdSeed + 1;
   let info = new NormalTypeInfo(
      abstructFlag, scope, nil, nil, nil, autoFlag, externalFlag, staticFlag,
      accessMode, funcName, parentInfo, typeIdSeed,
      kind, [], unwrap argTypeList default [],
      unwrap retTypeInfoList default [], mutable );
   return info;
}

pub static fn NormalTypeInfo.createModifier(
   orgTypeInfo: TypeInfo, typeId: int, mutable: bool! ): ModifierTypeInfo
{
   typeIdSeed = typeIdSeed + 1;
   return new ModifierTypeInfo( orgTypeInfo, typeId, mutable ); 
}

pub let builtinTypeNone:TypeInfo = 
   NormalTypeInfo.createBuiltin( "None", "", TypeInfoKind.Prim );
pub let builtinTypeStem:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Stem", "stem" , TypeInfoKind.Prim );
pub let builtinTypeNil:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Nil", "nil" , TypeInfoKind.Prim );
pub let builtinTypeDDD:TypeInfo =
   NormalTypeInfo.createBuiltin( "DDD", "..." , TypeInfoKind.Prim );
pub let builtinTypeBool:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Bool", "bool" , TypeInfoKind.Prim );
pub let builtinTypeInt:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Int", "int" , TypeInfoKind.Prim );
pub let builtinTypeReal:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Real", "real" , TypeInfoKind.Prim );
pub let builtinTypeChar:TypeInfo = 
   NormalTypeInfo.createBuiltin( "char", "char" , TypeInfoKind.Prim );
pub let builtinTypeString:TypeInfo = 
   NormalTypeInfo.createBuiltin( "String", "str" , TypeInfoKind.Class );
pub let builtinTypeMap:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Map", "Map" , TypeInfoKind.Map );
pub let builtinTypeList:TypeInfo = 
   NormalTypeInfo.createBuiltin( "List", "List" , TypeInfoKind.List );
pub let builtinTypeArray:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Array", "Array" , TypeInfoKind.Array );
pub let builtinTypeForm:TypeInfo =
   NormalTypeInfo.createBuiltin( "Form", "form" , TypeInfoKind.Func, builtinTypeDDD );
pub let builtinTypeSymbol:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Symbol", "sym" , TypeInfoKind.Prim );
pub let builtinTypeStat:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Stat", "stat" , TypeInfoKind.Prim );

pub let builtinTypeStem_ = unwrap builtinTypeStem.$nilableTypeInfo;


pub static fn NormalTypeInfo.createEnum(
   scope: Scope, parentInfo: TypeInfo, externalFlag: bool,
   accessMode: str, enumName: str, valTypeInfo:TypeInfo, 
   name2EnumValInfo:Map<str,EnumValInfo> ): TypeInfo
{
   if Parser.isLuaKeyword( enumName ) {
      Util.err( "This symbol can not use for a enum. -- %s"
                (enumName) );
   }
   
   typeIdSeed = typeIdSeed + 1;
   let info = new EnumTypeInfo(
      scope, externalFlag, accessMode, enumName,
      parentInfo, typeIdSeed, valTypeInfo, name2EnumValInfo );

   let getEnumName = NormalTypeInfo.createFunc(
      false, true, nil, TypeInfoKind.Method, info,
      true, true, false, "pub",
      "get__txt", nil, [ builtinTypeString ], false );
   scope.addMethod( getEnumName, "pub", false, true );

   let fromVal = NormalTypeInfo.createFunc(
      false, true, nil, TypeInfoKind.Method, info,
      true, true, true, "pub",
      "_from", [ valTypeInfo ], [ info.$nilableTypeInfo ], false );
   scope.addMethod( fromVal, "pub", true, true );
   
   return info;
}

pub override fn EnumTypeInfo.serialize(
   stream: oStream, validChildrenSet: Map<int,TypeInfo>! )
{
   let txt = ```{ parentId = %d, typeId = %d, txt = '%s',
accessMode = '%s', kind = %d, valTypeId = %d, ```
       ( self.getParentId(), self.typeId, self.rawTxt,
         self.accessMode, TypeInfoKind.Enum, self.valTypeInfo.$typeId );
   stream.write( txt );

   stream.write( "enumValList = {" );
   forsort enumValInfo in self.name2EnumValInfo {
      if self.valTypeInfo == builtinTypeString {
         stream.write( "%s = '%s'," (enumValInfo.$name, enumValInfo.$val) );
      }
      else {
         stream.write( "%s = %s," (enumValInfo.$name, enumValInfo.$val) );
      }
   }
   stream.write( "} }\n" );
}




// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NilableTypeInfo.isSettableFrom( other:TypeInfo ) : bool {
   if not other {
      return false;
   }  
   if self == builtinTypeStem_ {
      return true;
   }  
   if other == builtinTypeNil {
      return true;
   }  
   if self.typeId == other.$typeId {
      return true;
   }
   if other.$nilable {
      return self.$orgTypeInfo.isSettableFrom( other.$orgTypeInfo );
   }
   return self.$orgTypeInfo.isSettableFrom( other );
}
   
macro checkEqualsItemType( type1:sym, type2:sym, index:int ) {
   if not (unwrap ,,type1.$itemTypeInfoList[ ,,index ]).isSettableFrom(
      unwrap ,,type2.$itemTypeInfoList[ ,,index ] )
   {
      return false;
   }
};

// other のクラスが、この型のクラスの継承関係にあるか調べる
pub override fn NormalTypeInfo.isInheritFrom( other:TypeInfo ) : bool
{
   let otherTypeId = other.$typeId;
   if self.$typeId == otherTypeId {
      return true;
   }
   if ( self.$kind ~= TypeInfoKind.Class and self.$kind ~= TypeInfoKind.IF ) or
      ( other.$kind ~= TypeInfoKind.Class and other.$kind ~= TypeInfoKind.IF )
   {  
      return false;
   }
   let mut baseTypeInfo = self.$baseTypeInfo;
   while baseTypeInfo ~= rootTypeInfo {
      if otherTypeId == baseTypeInfo.$typeId {
         return true;
      } 
      baseTypeInfo = baseTypeInfo.$baseTypeInfo;
   };
   foreach ifType in self.$interfaceList {
      let mut workType = ifType;
      while workType ~= rootTypeInfo {
         if otherTypeId == workType.$typeId {
            return true;
         }
         workType = workType.$baseTypeInfo;
      }; 
   }
   return false;
}


// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NormalTypeInfo.isSettableFrom( other:TypeInfo ) : bool {
   if not other {
      return false;
   }
   if self == builtinTypeStem_ or self == builtinTypeDDD {
      return true;
   }
   if self == builtinTypeStem and not other.$nilable {
      return true;
   }
   if self == builtinTypeForm and other.$kind == TypeInfoKind.Func {
      return true;
   }
   if other == builtinTypeNil {
      if self.kind ~= TypeInfoKind.Nilable {
         return false;
      } 
      return true;
   }
   if self.typeId == other.$typeId {
      return true;
   }
   if self.kind ~= other.$kind {
      if self.kind == TypeInfoKind.Nilable {
         if other.$nilable {
            return self.$orgTypeInfo.isSettableFrom( other.$orgTypeInfo );
         }
         return self.$orgTypeInfo.isSettableFrom( other );
      }
      elseif ( self.$kind == TypeInfoKind.Class or self.$kind == TypeInfoKind.IF ) and
         ( other.$kind == TypeInfoKind.Class or other.$kind == TypeInfoKind.IF )
      {
         return other.isInheritFrom( self );
      }
      elseif other.$kind == TypeInfoKind.Enum {
         let enumTypeInfo = other@@EnumTypeInfo;
         return self.isSettableFrom( enumTypeInfo.$valTypeInfo );
      }
      return false;
   }
   switch ( self.kind ) {
      case TypeInfoKind.Prim {
         if self == builtinTypeInt and other == builtinTypeChar or
            self == builtinTypeChar and other == builtinTypeInt
         {  
            return true;
         }  
         return false;
      }       
      case TypeInfoKind.List, TypeInfoKind.Array {
         if other.$itemTypeInfoList[ 1 ] == builtinTypeNone {
            // literalMap の [], [@] は互換有りとする
            return true;
         }  
         checkEqualsItemType( self, other, 1 );
         return true;
      }       
      case TypeInfoKind.Map {
         if other.$itemTypeInfoList[ 1 ] == builtinTypeNone and
            other.$itemTypeInfoList[ 2 ] == builtinTypeNone
         {  
            // literalMap の {} は互換有りとする
            return true;
         }  
         checkEqualsItemType( self, other, 1 );
         checkEqualsItemType( self, other, 2 );
         return true;
      }       
      case TypeInfoKind.Class, TypeInfoKind.IF {
         return other.isInheritFrom( self );
      }       
      case TypeInfoKind.Func {
         if self == builtinTypeForm {
            return true;
         }  
         // 暫定 pending 関数型の互換を見る。
         return false;
      }       
      case TypeInfoKind.Method {
         return false;
      }
      case TypeInfoKind.Nilable {
         return self.$orgTypeInfo.isSettableFrom( other.$orgTypeInfo );
      }
      default {
         return false;
      } 
   }
   return true;
}


pub class Filter {
}

pub class Node {
   pri let kind: int { pub };
   pri let pos: Parser.Position { pub };
   pri let expTypeList: TypeInfo[] { pub };

   pub fn get_expType(): TypeInfo {
      if not self.expTypeList {
         return builtinTypeNone;
      } 
      return self.expTypeList[ 1 ];
   }; 
   
   pub fn getLiteral(): stem![], TypeInfo[] {
      return [nil], [builtinTypeNil];
   }
   pub fn processFilter( filter: Filter, ... ) {
   }

   pub fn canBeLeft(): bool {
      return false;
   };     
   pub fn canBeRight(): bool {
      return false;
   }
}



pub class NamespaceInfo {
   pub let name: str;
   pub let scope: Scope;
   pub let typeInfo: TypeInfo;
}


pub proto class MacroEval;
pub proto class ExpListNode extend Node;
pub proto class DeclArgNode extend Node;

pub class DeclMacroInfo {
   pri let name: Parser.Token { pub };
   pri let argList: DeclArgNode[] { pub };
   pri let ast: Node! { pub };
   pri let tokenList: Parser.Token[] { pub };
}

pub class MacroValInfo {
   pub let val: stem!;
   pub let typeInfo: TypeInfo;
}

pub class MacroInfo {
   pub let func: form;
   pub let declInfo: DeclMacroInfo;
   pub let symbol2MacroValInfoMap: Map<str,MacroValInfo>;
}

let nodeKind2NameMap: Map<int,str> = {};
let mut nodeKindSeed = 1;
pub let nodeKind: Map<str,int> = {};

fn regKind( name:str ): int {
   let kind = nodeKindSeed;
   nodeKindSeed = nodeKindSeed + 1;
   nodeKind2NameMap[ kind ] = name;
   nodeKind[ name ] = kind;
   return kind;
}

pub fn getNodeKindName( kind: int ): str {
   return unwrap nodeKind2NameMap[ kind ];
}

// let nodeKindNone = regKind( 'None' );
// let nodeKindImport = regKind( 'Import' );
// let nodeKindRoot = regKind( 'Root' );
// let nodeKindRefType = regKind( 'RefType' );
// let nodeKindIf = regKind( 'If' );
// let nodeKindSwitch = regKind( 'Switch' );
// let nodeKindWhile = regKind( 'While' );
// let nodeKindRepeat = regKind( 'Repeat' );
// let nodeKindFor = regKind( 'For' );
// let nodeKindApply = regKind( 'Apply' );
// let nodeKindForeach = regKind( 'Foreach' );
// let nodeKindForsort = regKind( 'Forsort' );
// let nodeKindReturn = regKind( 'Return' );
// let nodeKindBreak = regKind( 'Break' );
// let nodeKindExpNew = regKind( 'ExpNew' );
// let nodeKindExpList = regKind( 'ExpList' );
// let nodeKindExpRef = regKind( 'ExpRef' );
// let nodeKindExpOp2 = regKind( 'ExpOp2' );
// let nodeKindExpCast = regKind( 'ExpCast' );
// let nodeKindExpOp1 = regKind( 'ExpOp1' );
// let nodeKindExpRefItem = regKind( 'ExpRefItem' );
// let nodeKindExpCall = regKind( 'ExpCall' );
// let nodeKindExpCallSuper = regKind( 'ExpCallSuper' );
// let nodeKindExpDDD = regKind( 'ExpDDD' );
// let nodeKindExpParen = regKind( 'ExpParen' );
// let nodeKindExpMacroExp = regKind( 'ExpMacroExp' ); // macro expand
// let nodeKindExpMacroStat = regKind( 'ExpMacroStat' ); // `{}
// let nodeKindBlock = regKind( 'Block' );
// let nodeKindStmtExp = regKind( 'StmtExp' );
// let nodeKindRefField = regKind( 'RefField' );
// let nodeKindDeclVar = regKind( 'DeclVar' );
// let nodeKindDeclFunc = regKind( 'DeclFunc' );
// let nodeKindDeclMethod = regKind( 'DeclMethod' );
// let nodeKindDeclConstr = regKind( 'DeclConstr' );
// let nodeKindDeclMember = regKind( 'DeclMember' );
// let nodeKindDeclArg = regKind( 'DeclArg' );
// let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
// let nodeKindDeclClass = regKind( 'DeclClass' );
// let nodeKindDeclMacro = regKind( 'DeclMacro' );
// let nodeKindLiteralNil = regKind( 'LiteralNil' );
// let nodeKindLiteralChar = regKind( 'LiteralChar' );
// let nodeKindLiteralInt = regKind( 'LiteralInt' );
// let nodeKindLiteralReal = regKind( 'LiteralReal' );
// let nodeKindLiteralArray = regKind( 'LiteralArray' );
// let nodeKindLiteralList = regKind( 'LiteralList' );
// let nodeKindLiteralMap = regKind( 'LiteralMap' );
// let nodeKindLiteralString = regKind( 'LiteralString' );
// let nodeKindLiteralBool = regKind( 'LiteralBool' );
// let nodeKindLiteralSymbol = regKind( 'LiteralSymbol' );

macro _declNodeClass(
   baseName:str, super:sym, canBeLeftFlag:bool!, canBeRightFlag:bool!,
   fieldInfoList:Map<str,str>[] )
{
   {
      let _className = ,,,"%sNode" (baseName);
      let _nodeKindSym = ,,,"nodeKind%s" (baseName);

      let fieldStatList:stat[] = [];
      let argList:stat[] = [];
      let initStatList:stat[] = [];
      let relateStat:stat[] = [];
      
      if fieldInfoList {
         foreach fieldInfo in fieldInfoList {
            foreach typeName, varName in fieldInfo {
               fieldStatList.insert( `{
                  pri let mut ,,,varName : ,,,typeName { pub };
               });  
               argList.insert( `{ ,,,varName: ,,,typeName, } );
               initStatList.insert( `{ self.,,,varName = ,,,varName; } );
            }   
         }  
      } 

      fieldStatList.insert( `{
         pub override fn processFilter( filter: Filter, ... ) {
            let argList:stem[] = [ ... ];

            filter.,,,"process%s" (baseName) (self, table.unpack( argList ) );
         } } );

      if! canBeRightFlag {
         fieldStatList.insert( `{
            pub override fn canBeRight():bool {
               return ,,, canBeRightFlag;
            } } );
      }
      if! canBeLeftFlag {
         fieldStatList.insert( `{
            pub override fn canBeLeft():bool {
               return ,,, canBeLeftFlag;
            } } );
      }
      
      let superStat = `{
         super( ,,_nodeKindSym, pos, typeList );
      };

      relateStat.insert( `{
         pub fn Filter. ,,,"process%s" (baseName) ( node: ,,_className, ... ) {
         };               
      } );
      
   }

   pub proto class ,,_className extend ,,super;
   ,,relateStat;
   pub let ,,_nodeKindSym = regKind( ,,baseName );
   pub class ,,_className extend ,,super {
      ,,fieldStatList;
      pub fn __init( pos: Parser.Position, typeList: TypeInfo[], ,,argList ) {
         ,,superStat;
         ,,initStatList;
      }
   }
}

_declNodeClass( "None", Node, false, false, []);
_declNodeClass( "Subfile", Node, false, false, []);
_declNodeClass( "Import", Node, false, false,
                [ { "modulePath": "str" },
                  { "moduleTypeInfo": "TypeInfo" } ]
);


pub proto class ProvideNode extend Node;

_declNodeClass( "Root", Node, false, false,
                [ { "children": "Node[]" },
                  { "provideNode": "ProvideNode!" },
                  { "typeId2ClassMap": "Map<int,NamespaceInfo>" } ]
);

pub fn RootNode.set_provide( node: ProvideNode ) {
   self.provideNode = node;
}

_declNodeClass( "RefType", Node, false, false,
                [ { "name": "Node" },
                  { "refFlag": "bool" },
                  { "mutFlag": "bool" },
                  { "array": "str" } ]
);

_declNodeClass( "Block", Node, false, false,
                [ { "blockKind": "str" },
                  { "stmtList": "Node[]" } ]
);

pub class IfStmtInfo {
   pri let kind: str { pub };
   pri let exp: Node { pub };
   pri let block: BlockNode { pub };
}
_declNodeClass( "If", Node, false, false,
                [{ "stmtList": "IfStmtInfo[]" } ]
);

_declNodeClass( "ExpList", Node, true, true,
                [ { "expList": "Node[]" } ]
);

pub class CaseInfo {
   pri let expList: ExpListNode { pub };
   pri let block: BlockNode { pub };
}
_declNodeClass( "Switch", Node, false, false,
                [ { "exp": "Node" },
                  { "caseList": "CaseInfo[]" },
                  { "default": "BlockNode!" } ]
);


_declNodeClass( "While", Node, false, false,
                [ { "exp": "Node" },
                  { "block": "BlockNode" } ]
);

_declNodeClass( "Repeat", Node, false, false,
                [ { "block": "BlockNode" },
                  { "exp": "Node" } ]
);

_declNodeClass( "For", Node, false, false,
                [ { "block": "BlockNode" },
                  { "val": "Parser.Token" },
                  { "init": "Node" },
                  { "to": "Node" },
                  { "delta": "Node!" }] 
);

_declNodeClass( "Apply", Node, false, false,
                [ { "varList": "Parser.Token[]" },
                  { "exp": "Node" },
                  { "block": "BlockNode" } ]
);

_declNodeClass( "Foreach", Node, false, false,
                [ { "val": "Parser.Token" },
                  { "key": "Parser.Token!" },
                  { "exp": "Node" },
                  { "block": "BlockNode" } ]
);

_declNodeClass( "Forsort", Node, false, false,
                [ { "val": "Parser.Token" },
                  { "key": "Parser.Token!" },
                  { "exp": "Node" },
                  { "block": "BlockNode" },
                  { "sort": "bool" } ]
);

_declNodeClass( "Return", Node, false, false,
                [ { "expList": "ExpListNode!" } ]
);

_declNodeClass( "Break", Node, false, false, [] );

_declNodeClass( "Provide", Node, false, false,
                [ { "val": "Node" } ]
);     

_declNodeClass( "ExpNew", Node, false, true,
                [ { "symbol": "Node" },
                  { "argList": "ExpListNode!" } ]
);

_declNodeClass( "ExpUnwrap", Node, false, true,
                [ { "exp": "Node" },
                  { "default": "Node!" } ]
);

_declNodeClass( "ExpRef", Node, nil, nil,
                [ { "token": "Parser.Token" },
                  { "symbolInfo": "AccessSymbolInfo" } ]              
);

pub override fn ExpRefNode.canBeLeft():bool {
   return self.$symbolInfo.$canBeLeft;
}

pub override fn ExpRefNode.canBeRight():bool {
   return self.$symbolInfo.$canBeRight;
}

_declNodeClass( "ExpOp2", Node, false, true,
                [ { "op": "Parser.Token" },
                  { "exp1": "Node" },
                  { "exp2": "Node" } ]
);

_declNodeClass( "UnwrapSet", Node, false, false,
                [ { "dstExpList": "ExpListNode" },
                  { "srcExpList": "ExpListNode" },
                  { "unwrapBlock": "BlockNode!" } ]              
);

_declNodeClass( "IfUnwrap", Node, false, false,
                [ { "exp": "Node" },
                  { "block": "BlockNode" },
                  { "nilBlock": "BlockNode!" } ]
);


_declNodeClass( "ExpCast", Node, false, true,
                [ { "exp": "Node" } ]
);

_declNodeClass( "ExpOp1", Node, false, true,
                [ { "op": "Parser.Token" },
                  { "macroMode": "str" },
                  { "exp": "Node" } ]
);

_declNodeClass( "ExpRefItem", Node, true, true,
                [ { "val": "Node" },
                  { "nilAccess": "bool" },
                  { "index": "Node" } ]
);

_declNodeClass( "ExpCall", Node, false, true,
                [ { "func": "Node" },
                  { "nilAccess": "bool" },
                  { "argList": "ExpListNode!" } ]
);

_declNodeClass( "ExpDDD", Node, false, true,
                [ { "token": "Parser.Token" } ]
);

_declNodeClass( "ExpParen", Node, false, true,
                [ { "exp": "Node" } ]
);

_declNodeClass( "ExpMacroExp", Node, false, false,
                [ { "stmtList": "Node[]" } ]
);

_declNodeClass( "ExpMacroStat", Node, false, true,
                [ { "expStrList": "Node[]" } ]
);

_declNodeClass( "StmtExp", Node, false, true,
                [ { "exp": "Node" } ]
);

_declNodeClass( "RefField", Node, true, true,
                [ { "field": "Parser.Token" },
                  { "symbolInfo": "AccessSymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "Node" }] 
);
pub override fn RefFieldNode.canBeLeft():bool {
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   return false;
}

_declNodeClass( "GetField", Node, false, true,
                [ { "field": "Parser.Token" },
                  { "symbolInfo": "AccessSymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "Node" },
                  { "getterTypeInfo": "TypeInfo" } ]               
);
pub override fn GetFieldNode.canBeLeft():bool {
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   return false;
}


pub class VarInfo {
   pri let name: Parser.Token { pub };
   // 宣言している型。 宣言していない場合は nil
   pri let refType: RefTypeNode! { pub };
   // 実際の型。
   pri let actualType: TypeInfo { pub };
}
_declNodeClass( "DeclVar", Node, false, false,
                [ { "mode": "str" },
                  { "accessMode": "str" },
                  { "staticFlag": "bool" },
                  { "varList": "VarInfo[]" },
                  { "expList": "ExpListNode!" },
                  { "symbolInfoList": "SymbolInfo[]"},
                  { "typeInfoList": "TypeInfo[]" },
                  { "unwrapFlag": "bool" },
                  { "unwrapBlock": "BlockNode!" },
                  { "thenBlock": "BlockNode!" },
                  { "syncVarList": "VarInfo[]" },
                  { "syncBlock": "BlockNode!" } ]
);

pub class DeclFuncInfo {
   pri let className: Parser.Token! { pub };
   pri let name: Parser.Token! { pub };
   pri let argList: Node[] { pub };
   pri let staticFlag: bool { pub };
   pri let accessMode: str { pub };
   pri let body: Node! { pub };
   pri let retTypeInfoList: TypeInfo[] { pub };
}
_declNodeClass( "DeclFunc", Node, false, true,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclMethod", Node, false, false,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclConstr", Node, false, false,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "ExpCallSuper", Node, false, false,
                [ { "superType": "TypeInfo" },
                  { "expList": "ExpListNode" } ]
);

_declNodeClass( "DeclMember", Node, false, false,
                [ { "name": "Parser.Token" },
                  { "refType": "RefTypeNode" },
                  { "symbolInfo": "SymbolInfo" },
                  { "staticFlag": "bool" },
                  { "accessMode": "str" },
                  { "getterMode": "str" },
                  { "setterMode": "str" } ]
);

_declNodeClass( "DeclArg", Node, false, false,
                [ { "name": "Parser.Token" },
                  { "argType": "RefTypeNode" } ]
);

_declNodeClass( "DeclArgDDD", Node, false, false, [] );

pub class AdvertiseInfo {
   pri let member: DeclMemberNode { pub };
   pri let prefix: str {pub};
};
_declNodeClass( "DeclClass", Node, false, false,
                [ { "accessMode": "str" },
                  { "name": "Parser.Token" },
                  { "fieldList": "Node[]" },
                  { "moduleName": "Parser.Token!" },
                  { "memberList": "DeclMemberNode[]" },
                  { "scope": "Scope" },
                  { "initStmtList": "Node[]" },
                  { "advertiseList": "AdvertiseInfo[]" },
                  { "trustList": "TypeInfo[]" },
                  { "outerMethodSet": "Map<str,bool>" } ]
);

_declNodeClass( "DeclEnum", Node, false, false,
                [ { "accessMode": "str" },
                  { "name": "Parser.Token" },
                  { "valueNameList": "Parser.Token[]" },
                  { "scope": "Scope" } ]
);


_declNodeClass( "DeclMacro", Node, false, false,
                [ { "declInfo": "DeclMacroInfo" } ]
);

pub class MacroEval {
   pub fn eval( macroNode: DeclMacroNode ): form;
}

_declNodeClass( "LiteralNil", Node, false, true, [] );

_declNodeClass( "LiteralChar", Node, false, true,
                [ { "token": "Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralInt", Node, false, true,
                [ { "token": "Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralReal", Node, false, true,
                [ { "token": "Parser.Token" },
                  { "num": "real" } ]
);

_declNodeClass( "LiteralArray", Node, false, true,
                [ { "expList": "ExpListNode!" } ]
);

_declNodeClass( "LiteralList", Node, false, true,
                [ { "expList": "ExpListNode!" } ]
);

pub class PairItem {
   pri let key: Node { pub };
   pri let val: Node { pub };
}
_declNodeClass( "LiteralMap", Node, false, true,
                [ { "map": "Map<Node,Node>" },
                  { "pairList": "PairItem[]" } ]
);

_declNodeClass( "LiteralString", Node, false, true,
                [ { "token": "Parser.Token" },
                  { "argList": "Node[]" } ]
);

_declNodeClass( "LiteralBool", Node, false, true,
                [ { "token": "Parser.Token" } ]
);

_declNodeClass( "LiteralSymbol", Node, false, true,
                [ { "token": "Parser.Token" } ]
);

pub fn Node.getSymbolInfo(): AccessSymbolInfo[] {
   fn processExpNode( node: Node ): AccessSymbolInfo[] {
      switch ( node.$kind ) {
         case nodeKindExpRef {
            return [(node@@ExpRefNode).$symbolInfo];
         }
         case nodeKindRefField {
            let refFieldNode = node@@RefFieldNode;
            if! refFieldNode.$symbolInfo {
               return [_exp];
            }
            return [];
         }
         case nodeKindGetField {
            let getFieldNode = node@@GetFieldNode;
            if! getFieldNode.$symbolInfo {
               return [_exp];
            }
            return [];
         }
         case nodeKindExpList {
            let expListNode = node@@ExpListNode;
            let list: AccessSymbolInfo[] = [];
            foreach expNode, index in expListNode.$expList {
               if index == #expListNode.$expList {
                  foreach symbolInfo in processExpNode( expNode ) {
                     list.insert( symbolInfo );
                  }
               }
               else {
                  foreach symbolInfo in processExpNode( expNode ) {
                     list.insert( symbolInfo );
                     break;
                  }
               }
            }
            return list;
         }
      }
      return [];
   }
   return processExpNode( self );
}


pub override fn LiteralNilNode.getLiteral(): stem![], TypeInfo[] {
   return [nil], [builtinTypeNil];
}

pub override fn LiteralCharNode.getLiteral(): stem![], TypeInfo[] {
   return [self.num], [builtinTypeChar];
}

pub override fn LiteralIntNode.getLiteral(): stem![], TypeInfo[] {
   return [self.num], [builtinTypeInt];
}

pub override fn LiteralRealNode.getLiteral(): stem![], TypeInfo[] {
   return [self.num], [builtinTypeReal];
}

pub override fn LiteralArrayNode.getLiteral(): stem![], TypeInfo[] {
   let array:stem![] = [];
   if! self.expList {
      foreach val in _exp.get_expList() {
         let txt = val.getLiteral()[1];
         array.insert( txt );
      } 
   }
   return [array], [self.get_expType()];
}

pub override fn LiteralListNode.getLiteral(): stem![], TypeInfo[] {
   let list:stem![] = [];
   if! self.expList {
      foreach val in _exp.get_expList() {
         let item = val.getLiteral()[1];
         list.insert( item );
      } 
   }
   return [list], [self.get_expType()];
}

pub override fn LiteralMapNode.getLiteral(): stem![], TypeInfo[] {
   let map:Map<str,stem!> = {};
   foreach val, key in self.map {
      map[ key.getLiteral()[1] ] = val.getLiteral()[1];
   }
   return [map], [self.get_expType()];
}

pub override fn LiteralStringNode.getLiteral(): stem![], TypeInfo[] {
   let mut txt = self.token.txt;
   if string.find( txt, '^```' ) {
      txt = txt.sub( 4, -4 );
   }
   else {
      txt = txt.sub( 2, -2 );
   }
   let argList = self.$argList;

   if #argList > 0 {
      let argTbl:stem![] = [];
      foreach argNode in argList {
         let arg = argNode.getLiteral();
         argTbl.insert( arg[1] );
      }   
      return [ string.format( txt, table.unpack( argTbl ) )], [builtinTypeString];
   }
   return [txt], [builtinTypeString];
}

pub override fn LiteralBoolNode.getLiteral(): stem![], TypeInfo[] {
   return [ self.token.txt == "true"], [builtinTypeBool];
}

pub override fn LiteralSymbolNode.getLiteral(): stem![], TypeInfo[] {
   return [[ self.token.txt ]], [ builtinTypeSymbol ];
}

pub override fn RefFieldNode.getLiteral(): stem![], TypeInfo[] {
   let prefix = (unwrap self.prefix.getLiteral()[1])@@str[];
   if self.nilAccess {
      prefix.insert( "$." );
   }
   else {
      prefix.insert( "." );
   }
   prefix.insert( self.field.txt );
   return [ prefix ], [ builtinTypeSymbol ];
}

pub override fn ExpMacroStatNode.getLiteral(): stem![], TypeInfo[] {
   let mut txt = "";
   foreach token in self.expStrList {
      txt = "%s%s" (txt, token.getLiteral()[1]);
   }
   return [txt ], [ self.get_expType() ];
}

pub override fn ExpRefNode.getLiteral(): stem![], TypeInfo[] {
   let typeInfo = self.symbolInfo.$typeInfo;
   if typeInfo.$kind ~= TypeInfoKind.Enum {
      return [], [];
   }
   let enumTypeInfo = typeInfo@@EnumTypeInfo;

   let val = unwrap enumTypeInfo.getEnumValInfo( self.symbolInfo.$name );
   return [ val.$val ], [ enumTypeInfo.$valTypeInfo ];
}

pub override fn ExpOp2Node.getLiteral(): stem![], TypeInfo[] {
   let val1List, type1List = self.$exp1.getLiteral();
   let val2List, type2List = self.$exp2.getLiteral();

   if #val1List ~= 1 or #type1List ~= 1 or #val2List ~= 1 or #type2List ~= 1 {
      return [], [];
   }

   let val1, type1, val2, type2 =
      unwrap val1List[1], type1List[1], unwrap val2List[1], type2List[1];

   if ( type1 == builtinTypeInt or type1 == builtinTypeReal ) and
      ( type2 == builtinTypeInt or type2 == builtinTypeReal )
   {
      let mut retType = builtinTypeInt;
      if type1 == builtinTypeReal or type2 == builtinTypeReal {
         retType = builtinTypeReal;
      }
      let mut int1, mut int2 = 0, 0;
      let mut real1, mut real2 = 0.0, 0.0;
      if type1 == builtinTypeInt {
         int1 = val1@@int;
         real1 = int1@@real;
      }
      else {
         real1 = val1@@real;
      }
      if type2 == builtinTypeInt {
         int2 = val2@@int;
         real2 = int2@@real;
      }
      else {
         real2 = val2@@real;
      }

      switch ( self.op.txt ) {
         case "+" {
            if retType == builtinTypeInt {
               return [ int1 + int2 ], [ retType ];
            }
            return [ real1 + real2 ], [ retType ];
         }
         case "-" {
            if retType == builtinTypeInt {
               return [ int1 - int2 ], [ retType ];
            }
            return [ real1 - real2 ], [ retType ];
         }
         case "*" {
            if retType == builtinTypeInt {
               return [ int1 * int2 ], [ retType ];
            }
            return [ real1 * real2 ], [ retType ];
         }
         case "/" {
            if retType == builtinTypeInt {
               return [ int1 / int2 ], [ retType ];
            }
            return [ real1 / real2 ], [ retType ];
         }
      }
   }
   elseif type1 == builtinTypeString and type2 == builtinTypeString {
      if self.op.txt == ".." {
         return [ val1@@str .. val2@@str ], [ builtinTypeString ];
      }
   }

   return [],[];
}
