/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

/**
参照する型情報を解析する。

@param accessMode この型のアクセス制御
@param allowDDD ... を型として許す場合 true
@param parentPub この型を使用している親の空間自体が public な場合 true
*/
fn TransUnit.analyzeRefType(
   accessMode: Ast.AccessMode, allowDDD:bool, parentPub:bool ) mut: Nodes.RefTypeNode
{
   let firstToken = self.getToken(##);
   let mut token = firstToken;
   let mutMode:Ast.MutMode!;
   switch token.txt {
      case "&" {
         mutMode = .IMut;
         token = self.getToken(##);
      }
      case "allmut" {
         mutMode = .AllMut;
         token = self.getToken(##);
      }
      default {
         mutMode = nil;
      }
   }
   // builtin の型名などは _ で始まることもあるので、シンボル名チェックしない
   // self.checkSymbol( token, .MustNot_ );

   let name:Nodes.Node;
   if token.txt == "..." {
      // ... は変数シンボルとしても使用するので
      // analyzeExpSymbol で解析すると意図しないシンボルを取ってくる可能性があるため、
      // ここで特別に処理する。
      let dddSym = unwrap self.moduleScope.getSymbolInfo(
         "...", self.moduleScope, true, .Normal );
      name = Nodes.ExpRefNode.create(
         self.nodeManager, token.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ dddSym.$typeInfo ], 
         new Ast.AccessSymbolInfo( self.processInfo, dddSym, .None, true ) );
   }
   else {
      name = self.analyzeExpSymbol( firstToken, token, .Symbol, nil, true, false );
      let symbolList = name.getSymbolInfo();
      if #symbolList > 0 {
         let symbol = symbolList[ 1 ];
         if symbol.$kind ~= .Typ {
            self.addErrMess( name.$pos, "illegal type -- %s" ( symbol.$name ) );
         }
      }
      else {
         self.addErrMess( name.$pos,
                          "illegal symbol node -- %s"
                          ( Nodes.getNodeKindName( name.$kind ) ) );
      }
   }
   return self.analyzeRefTypeWithSymbol(
      accessMode, allowDDD, mutMode, name, parentPub );
}


fn TransUnit.analyzeRefTypeWithSymbol(
   accessMode: Ast.AccessMode, allowDDD:bool,
   mutMode:Ast.MutMode!, symbolNode:&Nodes.Node, parentPub:bool ) mut:
   Nodes.RefTypeNode
{
   let mut typeInfo = symbolNode.$expType;
   if typeInfo.$kind == .Set and not self.helperInfo.useSet {
      self.helperInfo.useSet = true;
   }

   

   if! let aliasType = typeInfo@@@Ast.AliasTypeInfo {
      let aliasSrc = aliasType.$aliasSrcTypeInfo;
      if not self.importModuleSet.has( aliasSrc.getModule() ) and
         self.moduleType.$parentInfo ~= aliasSrc.getModule().$parentInfo
      {
         // 本来は alias の定義元のモジュールのインポートは不要だが、
         // 現状の go への変換では定義元のモジュールが必要になるため、
         // 定義元のモジュールをインポートしていない場合、エラーとする。
         // なお、 go は同じディレクトリ内はインポート不要なので、
         // 異なるディレクトリの場合だけエラーとする。
         self.addErrMess( symbolNode.$pos,
                          "must import '%s' for this alias -- %s"
                          ( aliasSrc.getModule().getFullName(
                             self.typeNameCtrl, self.scope, false ),
                            symbolNode.getSymbolInfo()[1].$name ) );
      }
   }
   

   if parentPub and
      Ast.isPubToExternal( accessMode ) and
      not Ast.isPubToExternal( typeInfo.$accessMode )
   {
      // 公開する型の中で非公開な型を利用するのは NG
      self.addErrMess( symbolNode.$pos,
                       "This type must be public. -- %s" (typeInfo.getTxt(##) ));
   }
   

   let continueToken, continueFlag = self.getContinueToken();
   let mut token = continueToken;
   if continueFlag and token.txt == "!" {
      typeInfo = typeInfo.get_nilableTypeInfo();
      token = self.getToken(##);
   }

   let mut itemNodeList:List<&Nodes.Node> = [];
   let mut arrayMode = "no";
   while true {
      if token.txt == '[' or token.txt == '[@' {
         if token.txt == '[' {
            arrayMode = "list";
            typeInfo = self.processInfo.createList(
               accessMode, self.getCurrentClass(), [ typeInfo ], .Mut );
         }
         else {
            arrayMode = "array";
            typeInfo = self.processInfo.createArray(
               accessMode, self.getCurrentClass(), [ typeInfo ], .Mut );
         }
         token = self.getToken(##);
         if token.txt ~= ']' {
            self.pushback();
            self.checkNextToken( ']' );
         }
         itemNodeList.insert( symbolNode );
      }
      elseif token.txt == "<" {
         let mut genericList: List<&Ast.TypeInfo> = [];
         let mut nextToken: &Parser.Token = Parser.getEofToken();
         repeat {
            let typeExp = self.analyzeRefType( accessMode, false, parentPub );
            itemNodeList.insert( typeExp );
            genericList.insert( typeExp.$expType );
            nextToken = self.getToken(##);
         } nextToken.txt ~= ",";
         self.checkToken( nextToken, '>' );

         fn checkAlternateTypeCount( count:int ) __trans : bool {
            if #genericList ~= count {
               self.addErrMess(
                  symbolNode.$pos,
                  "generic type count is unmatch. -- %d" (#genericList) );
               return false;
            }
            return true;
         }

         switch typeInfo.$kind {
            case .Map {
               if #genericList ~= 2 {
                  self.addErrMess( symbolNode.$pos, "Key or value type is unknown" );
                  typeInfo = self.processInfo.createMap(
                     accessMode, self.getCurrentClass(),
                     Ast.builtinTypeStem, Ast.builtinTypeStem, .Mut );
               }
               else {
                  typeInfo = self.processInfo.createMap(
                     accessMode, self.getCurrentClass(),
                     genericList[ 1 ], genericList[ 2 ], .Mut );
               }
            }
            case .List {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.processInfo.createList(
                     accessMode, self.getCurrentClass(),
                     genericList, .Mut );
               }
            }
            case .Array {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.processInfo.createArray(
                     accessMode, self.getCurrentClass(),
                     genericList, .Mut );
               }
            }
            case .Set {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.processInfo.createSet(
                     accessMode, self.getCurrentClass(),
                     genericList, .Mut );
               }
            }
            case .DDD {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.processInfo.createDDD( genericList[1], false, false );
               }
            }
            case .Class, .IF {
               if checkAlternateTypeCount( #typeInfo.$itemTypeInfoList ) {
                  foreach itemType in genericList {
                     //let altType = unwrap typeInfo.$itemTypeInfoList[ index ]@@@Ast.AlternateTypeInfo;
                     if itemType.$nilable {
                        self.addErrMess(
                           symbolNode.$pos,
                           "can't use nilable type -- %s" (itemType.getTxt(##)) );
                     }
                  }
                  foreach itemType, index in typeInfo.$itemTypeInfoList {
                     if itemType.hasBase() and
                        not genericList[ index ].isInheritFrom(
                           self.processInfo, itemType.$baseTypeInfo ##) 
                     {
                        self.addErrMess(
                           symbolNode.$pos,
                           "'%s' of %s doesn't inherit '%s'"
                           (itemType.getTxt(##), typeInfo.getTxt(##),
                             itemType.$baseTypeInfo.getTxt(##)) );
                     }
                  }
                  typeInfo = self.processInfo.createGeneric(
                     typeInfo, genericList, self.moduleType );
               }
            }
            case .Box {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.processInfo.createBox( accessMode, genericList[1] );
               }
            }
            case .Ext {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.createExtType( symbolNode.$pos, genericList[1] );
               }
            } default {
               self.error( string.format( "not support generic: %s",
                                          typeInfo.getTxt(##) ) );
            }
         }
      } else {
         self.pushback();
         break;
      }
      token = self.getToken(##);
   }
   if token.txt == "!" {
      typeInfo = typeInfo.get_nilableTypeInfo();
      self.getToken(##);
   }

   if not allowDDD {
      if typeInfo.$kind == .DDD {
         self.addErrMess( symbolNode.$pos,
                          "invalid type. -- '%s'" (typeInfo.getTxt(##) ) );
      }
   }

   when! mutMode {
      if typeInfo.$mutMode ~= mutMode {
         typeInfo = self.createModifier( typeInfo, mutMode );
      }
   }

   if typeInfo.$kind == .Module {
      self.addErrMess( symbolNode.$pos,
                       "module can't use as Type. -- %s" ( typeInfo.getTxt(##) ) );
   }

   return Nodes.RefTypeNode.create(
      self.nodeManager, symbolNode.$pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ],
      symbolNode, itemNodeList, mutMode, arrayMode );
}

fn TransUnit.analyzeDeclArgList(
   accessMode:Ast.AccessMode, scope:Ast.Scope,
   argList: List<&Nodes.Node>, parentPub:bool ) mut : &Parser.Token
{
   let mut nextToken: &Parser.Token = Parser.noneToken;
   let mut hasDDDFlag = false;
   repeat {
      nextToken = self.getToken(##);
      if nextToken.txt == ")" {
         break;
      }

      if hasDDDFlag {
         self.addErrMess( nextToken.pos, "Argument exists after '...'." );
      }

      let mut mutable = Ast.MutMode.IMut;
      if nextToken.txt == "mut" {
         mutable = .Mut;
         nextToken = self.getToken(##);
      }
      let mut argName = nextToken;
      if argName.txt == "..." {
         hasDDDFlag = true;

         let workToken, flag = self.getContinueToken();
         self.pushback();

         let mut dddTypeInfo = Ast.builtinTypeDDD;
         if flag and workToken.txt == "<" {
            self.pushbackToken( nextToken );
            let refTypeNode = self.analyzeRefType( accessMode, true, parentPub );
            dddTypeInfo = refTypeNode.$expType;
         }

         argList.insert(
            Nodes.DeclArgDDDNode.create(
               self.nodeManager, argName.pos,
               self.macroCtrl.isInAnalyzeArgMode(), [ dddTypeInfo ] ) );
         scope.addLocalVar(
            self.processInfo, true, true, argName.txt, argName.pos, dddTypeInfo, .IMut );
      }
      else {
         argName = self.checkSymbol( argName, .MustNot_ );

         self.checkShadowing( argName.pos, argName.txt, scope );

         self.checkNextToken( ":" );

         let refType = self.analyzeRefType( accessMode, false, parentPub );
         
         if refType.$expType.$kind == .Class and #refType.$expType.$itemTypeInfoList > 0
         {
            let argType = refType.$expType.$srcTypeInfo;
            if not Ast.isGenericType( argType ) {
               self.addErrMess(
                  refType.$pos,
                  "can't use this type without <T>. please use %s."
                  ( argType.getTxt( ## )));
            }
         }
         
         if! let symbolInfo = scope.addLocalVar(
            self.processInfo, 
            true, true, argName.txt, argName.pos, refType.$expType, mutable )
         {
            let arg = Nodes.DeclArgNode.create(
               self.nodeManager, argName.pos,
               self.macroCtrl.isInAnalyzeArgMode(), refType.$expTypeList,
               argName, symbolInfo, refType );

            argList.insert( arg );
         }
      }
      nextToken = self.getToken(##);
   } nextToken.txt ~= ",";

   self.checkToken( nextToken, ")" );

   return nextToken;
}

fn TransUnit.checkOverrideMethod(
   overrideType:&Ast.TypeInfo, typeInfo:&Ast.TypeInfo ) : List<str>
{
   let accessMode = typeInfo.$accessMode;
   let funcName = typeInfo.$rawTxt;
   let altTypeList= typeInfo.$itemTypeInfoList;
   let mut alt2typeMap = typeInfo.$parentInfo.createAlt2typeMap( false );
   let mut errList:List<str> = [];

   
   fn addErr( mess:str ) __trans {
      let fullName = "%s.%s" (typeInfo.$parentInfo.$rawTxt, typeInfo.$rawTxt );
      errList.insert( "%s: %s: %s -- %s" ( fullName, mess, typeInfo.$display_stirng,
                                           typeInfo.$display_stirng ) );
   }

   if self.ctrl_info.validAsyncCtrl {
      if overrideType.$asyncMode ~= typeInfo.$asyncMode {
         addErr( "mismatch asyncMode --  %s, %s"
                 ( overrideType.$asyncMode.$_txt, typeInfo.$asyncMode.$_txt ) );
      }
   }
   
   if overrideType.get_accessMode() ~= accessMode {
      let mess = "mismatch override accessMode -- %s,%s"
          ( overrideType.get_accessMode().$_txt, accessMode.$_txt );
      addErr( mess );
   }
   if overrideType.get_staticFlag() ~= typeInfo.$staticFlag {
      addErr( "mismatch override staticFlag -- " .. funcName );
   }
   if overrideType.get_kind() ~= .Method {
      addErr( "mismatch override kind -- %s, %d"
                      ( funcName, overrideType.get_kind() ) );
   }
   if overrideType.$mutMode ~= typeInfo.$mutMode {
      addErr( "mismatch mutable -- %s" ( funcName ) );
   }

   if #overrideType.$itemTypeInfoList ~= #altTypeList {
      let mess = "mismatch altTypeList -- %d, %d"
          (#overrideType.$itemTypeInfoList, #altTypeList);
      addErr( mess );
   }
   else {
      foreach alterType, index in overrideType.$itemTypeInfoList {
         alt2typeMap[ alterType ] = altTypeList[ index ];
      }
   }

   let matchFlag, err = overrideType.canEvalWith(
      self.processInfo, typeInfo, .SetEq, alt2typeMap );
   if not matchFlag {
      when! err {
         addErr( "mismatch method type -- %s" (err) );
      } else {
         addErr( "mismatch method type"  );
      }
   }

   foreach retType, index in overrideType.$retTypeInfoList {
      if #typeInfo.$retTypeInfoList >= index {
         if retType.$nonnilableType.$kind == .Alternate and
            typeInfo.$retTypeInfoList[ index ].$nonnilableType.$kind ~= .Alternate
         {
            let mess =
               "not support to override the method has generics at return type. -- %s"
                (funcName);
            addErr( mess );
         }
      }
   }

   return errList;
}


fn TransUnit.checkOverriededMethodOfAllClass() mut
{
   fn process(
      pos:&Parser.Position, alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo>,
      classScope:&Ast.Scope, superScope:&Ast.Scope )
   {
      superScope.filterTypeInfoField(
         true, classScope, self.scopeAccess,
         fn ( symbolInfo:&Ast.SymbolInfo ): bool {
            if symbolInfo.$name == "__init" {
               return true;
            }
            let mut implimented = true;
            if symbolInfo.$typeInfo.$kind == .Method {
               if! let impMethodType = classScope.getTypeInfoField(
                  symbolInfo.$name, true, classScope, self.scopeAccess )
               {
                  if impMethodType == symbolInfo.$typeInfo {
                     if symbolInfo.$typeInfo.$abstractFlag and classScope ~= superScope {
                        implimented = false;
                     }
                  } else {
                     foreach err in self.checkOverrideMethod(
                        symbolInfo.$typeInfo, impMethodType )
                     {
                        self.addErrMess( pos, err );
                     }
                  }
               } else {
                  implimented = false;
               }
            }
            if not implimented {
               self.addErrMess( pos, "not implements method -- %s.%s at %s"
                                ( superScope.$ownerTypeInfo$.getTxt$(##),
                                  symbolInfo.$name,
                                  classScope.$ownerTypeInfo$.getTxt$(##) ) );
            }
            return true;
         } );
   }

   let mut typeId2DeclClassNode:Map<int,&Nodes.DeclClassNode> = {};
   foreach classNode, classTypeInfo in self.typeInfo2ClassNode {
      typeId2DeclClassNode[ classTypeInfo.$typeId.id ] = classNode;
   }

   forsort classNode in typeId2DeclClassNode {
      let classTypeInfo = classNode.$expType;
      // extend のメソッドがオーバーライドされているか確認
      let mut workTypeInfo = classTypeInfo;
      let mut alt2typeMap = classTypeInfo.createAlt2typeMap(false);
      repeat {
         if not classTypeInfo.$abstractFlag {
            if workTypeInfo ~= Ast.headTypeInfo {
               process( classNode.$pos, alt2typeMap,
                        unwrap classTypeInfo.$scope,
                        unwrap workTypeInfo.$scope );
            }
         }
         foreach ifType in workTypeInfo.$interfaceList {
            if ifType ~= Ast.builtinTypeMapping {
               process( classNode.$pos, alt2typeMap,
                        unwrap classTypeInfo.$scope, unwrap ifType.$scope );
            }
         }
         workTypeInfo = workTypeInfo.$baseTypeInfo;
      } workTypeInfo == Ast.headTypeInfo;
   }
}

pub class ASTInfo {
   pri let node: &Nodes.Node { pub };
   pri let exportInfo:frontInterface.ExportInfo { pub };
   pri let streamName:str {pub};
   pri let builtinFunc:&Builtin.BuiltinFuncType {pub};
}

pub fn TransUnit.createAST(
   parserSrc: &Parser.ParserSrc, macroFlag: bool, moduleName: str! ) mut : ASTInfo
{
   let mut parser = Parser.createParserFrom( parserSrc );
   
   Log._log2( .Log, "%s start -- %s" (__func__, parser.getStreamName()) );
   
   self.moduleName = unwrap moduleName default "";

   when! moduleName {
      // 自分自身をインポートしないように、self.importModuleInfo に登録する。
      if self.importModuleInfo.len() == 0 and not self.importModuleInfo.add( moduleName )
      {
         self.error( "already imported -- %s" (moduleName) );
      }
   }
   
   let mut moduleTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   let mut moduleSymboInfo:&Ast.SymbolInfo! = nil;

   __asyncLock {
      when! moduleName {
         apply txt of string.gmatch(
            frontInterface.getLuaModulePath( moduleName ), '[^%.]+' )
         {
            moduleTypeInfo = self.pushModule(
               self.processInfo, false, txt, true ).$typeInfo;
         }
      }
   }
   self.moduleScope = self.scope;
   self.moduleType = moduleTypeInfo;
   self.moduleScope.addVar(
      self.processInfo, 
      .Global, "__mod__", nil, Ast.builtinTypeString, .IMut, true );

   self.typeNameCtrl = new Ast.TypeNameCtrl( moduleTypeInfo );


   self.parser = new Parser.DefaultPushbackParser( parser );

   self.scope.addIgnoredVar( self.processInfo );

   
   let ast:Nodes.Node;
   let globalSymbolList:List<&Ast.SymbolInfo> = [];

   let mut lastStatement:&Nodes.Node! = nil;
   if macroFlag {
      ast = self.analyzeBlock( .Macro, .Ignore ##);
   }
   else {
      let mut children:List<&Nodes.Node> = [];
      let lastLineNo;
      lastStatement, lastLineNo = self.analyzeStatementList( children, false ## );

      let mut statement = Nodes.BlankLineNode.create(
         self.nodeManager, self.createPosition( lastLineNo + 1, 0 ),
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], 0 );
      statement.addComment( self.commentCtrl.$commentList );
      self.commentCtrl.clear();
      children.insert( statement );
      

      let mut token = self.getTokenNoErr();
      if token ~= Parser.getEofToken() {
         self.error( "%s:%d:%d:(%s) not eof -- %s"
                     ( self.parser.getStreamName(),
                       token.pos.lineNo, token.pos.column,
                       token.kind.$_txt, token.txt ) );
      }

      foreach subModule in self.subfileList {
         let file;
         __asyncLock {
            if! frontInterface.searchModule( subModule ) {
               file = _exp;
            } else {
               self.error( "not found subfile -- %s" ( subModule ) );
            }
         }

         if self.scope ~= self.moduleScope {
            self.error( "scope does not close" );
         }

         let! mut subParser = Parser.StreamParser.create( file, false, subModule ) {
            self.error( "open error -- %s" (file) );
         };

         self.parser = new Parser.DefaultPushbackParser( subParser );

         lastStatement = self.analyzeStatementListSubfile( children );

         token = self.getTokenNoErr();
         if token ~= Parser.getEofToken() {
            Util.err( "unknown:%d:%d:(%s) %s"
                      ( token.pos.lineNo, token.pos.column,
                        token.kind.$_txt, token.txt ) );
         }
      }

      self.checkOverriededMethodOfAllClass();


      let mut rootNode = Nodes.RootNode.create(
         self.nodeManager, self.createPosition( 0, 0 ),
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         children, self.moduleScope, self.macroCtrl.$useModuleMacroSet,
         self.moduleId, self.processInfo, moduleTypeInfo, nil,
         self.helperInfo, self.nodeManager,
         unwrap self.importCtrl$.$importModule2ModuleInfo default {},
         self.macroCtrl.$typeId2MacroInfo, self.typeId2ClassMap );
      ast = rootNode;
      if! self.provideNode {
         if lastStatement ~= _exp {
            self.addErrMess( _exp.$pos, "'provide' must be last." );
         }
         rootNode.set_provide( _exp );
         moduleSymboInfo = _exp.$symbol;
      }

      ClosureFun.checkList( self.closureFunList );

      foreach node in children {
         if! let workNode = node@@@Nodes.DeclVarNode {
            foreach symbolInfo in workNode.$symbolInfoList {
               if symbolInfo.$accessMode == .Global {
                  globalSymbolList.insert( symbolInfo );
               }
            }
         }
         if! let workNode = node@@@Nodes.DeclFuncNode {
            if workNode.$declInfo.$accessMode == .Global {
               if! let symbolInfo = workNode.$declInfo.$symbol {
                  globalSymbolList.insert( symbolInfo );
               }
            }
         }
      }
   }

   when! moduleName {
      foreach _ in Util.splitStr( moduleName, '[^%.]+' ) {
         self.popModule();
      }
   }

   fn createId2proto(
      map:Map<&Ast.TypeInfo,TransUnitIF.NSInfo> ) : &Map<int,&TransUnitIF.NSInfo>
   {
      let mut id2proto:Map<int,&TransUnitIF.NSInfo> = {};
      foreach nsInfo, protoType in map {
         id2proto[ protoType.$typeId.id ] = nsInfo;
      }
      return id2proto;
   }
   
   forsort nsInfo in createId2proto( self.nsInfoMap ) {
      if nsInfo.$nobody {
         let protoType = nsInfo.$typeInfo;
         let mess;
         switch protoType.$kind {
            case .Class, .IF {
               mess = "This class doesn't have body. -- %s" ( protoType.getTxt(##) );
            }
            default {
               mess = "This function doesn't have body. -- %s" ( protoType.getTxt(##) );
            }
         }
         self.addErrMess(
            unwrap self.nsInfoMap[ protoType ]$.$pos, mess );
      }
   }

   foreach mess in self.warnMessList {
      Util.errorLog( mess );
   }
   if #self.errMessList > 0 {
      foreach mess in self.errMessList {
         Util.errorLog( mess );
      }
      Util.err( "has error" );
   }
   if self.ctrl_info.stopByWarning and #self.warnMessList > 0 {
      Util.err( "has error" );
   }

   switch self.analyzeMode {
      case .Diag, .Complete, .Inquire {
         os.exit( 0 );
      }
   }
   
   let provideInfo:frontInterface.ModuleProvideInfo;
   when! moduleSymboInfo {
      provideInfo = new frontInterface.ModuleProvideInfo(
         moduleSymboInfo.$typeInfo, moduleSymboInfo.$kind, moduleSymboInfo.$mutable );
   } else {
      provideInfo = new frontInterface.ModuleProvideInfo( moduleTypeInfo, .Typ, false );
   }

   let mut exportInfo = new Nodes.ExportInfo(
      moduleTypeInfo, provideInfo, self.processInfo, globalSymbolList,
      self.macroCtrl.$declMacroInfoMap );
   
   return new ASTInfo( ast, exportInfo, parser.getStreamName(), self.builtinFunc );
}


fn TransUnit.analyzeDeclMacroSub(
   accessMode: Ast.AccessMode,
   firstToken: &Parser.Token, nameToken: &Parser.Token,
   macroScope:Ast.Scope, parentType:Ast.TypeInfo,
   workArgList: List<&Nodes.Node> ) mut : Nodes.DeclMacroNode
{
   if self.macroCtrl.$isDeclaringMacro {
      // macro 定義内に、別のマクロ定義はサポート外
      self.error( "can't declare macro in the macro." );
   }
   
   self.macroCtrl.startDecl();
   
   
   let mut pubFlag = false;
   switch accessMode {
      case .Pub {
         pubFlag = true;
      }
      case .Local, .None {
      }
      default {
         self.addErrMess( firstToken.pos,
                          "macro not support this access mode. -- %s"
                          ( accessMode.$_txt ) );
      }
   }
   
   // let mut workArgList: List<&Nodes.Node> = [];
   let mut argList: List<&Nodes.DeclArgNode> = [];
   // let mut nextToken = self.analyzeDeclArgList( accessMode, workArgList, false );
   let mut argTypeList: List<&Ast.TypeInfo> = [];
   foreach argNode in workArgList {
      if! argNode@@@Nodes.DeclArgNode {
         argList.insert( _exp );
      }
      else {
         self.error( "macro argument can not use '...'." );
      }
      let argType = argNode.$expType;
      argTypeList.insert( argType );
   }

   let mut nextToken = self.getToken(##);

   let retTypeList;
   if nextToken.txt == ":" {
      retTypeList = self.analyzeRefType( accessMode, true, false ).$expTypeList;
      self.checkNextToken( "{");
   }
   else {
      retTypeList = [];
      self.checkToken( nextToken, "{");
   }
   
   nextToken = self.getToken(##);

   let mut stmtNode : Nodes.BlockNode! = nil;
   if nextToken.txt == "{" {
      // macro-statement の解析

      self.macroScope = macroScope;

      // macro-statement のトップの変数のアクセス有無は確認しない。
      macroScope.set_validCheckingUnaccess( false );
  
      

      let funcType = self.processInfo.createFuncAsync(
         false, true, nil, .Func,
         //Ast.getBuiltinMut( Ast.headTypeInfo ), false, true,
         self.processInfo.$dummyParentType, false, true,
         true, .Global, "_lnsLoad", .Async,
         nil, [ Ast.builtinTypeString, Ast.builtinTypeString ],
         [ Ast.builtinTypeStem ], false );
      macroScope.addLocalVar(
         self.processInfo, false, false, "_lnsLoad", nil, funcType, .IMut );

      let macroLocalVarType = self.processInfo.createMap(
         .Local, self.moduleType, Ast.builtinTypeString, Ast.builtinTypeStem, .Mut );
      macroScope.addLocalVar(
         self.processInfo, false, true, "__var", nil, macroLocalVarType, .IMut );

      

      let mut stmtList:List<&Nodes.Node> = [];
      self.prepareTentativeSymbol( self.scope, false, nil );
      self.analyzeStatementList( stmtList, false, "}" );

      stmtNode = Nodes.BlockNode.create(
         self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
         [ Ast.builtinTypeNone ], .Macro, macroScope, stmtList );

      self.checkNextToken( "}" );
      //self.finishTentativeSymbol( false );
      self.finishTentativeSymbol( true );

      

      // self.parser = bakParser;


      
      self.macroScope = nil;
   }
   else {
      self.pushback();
   }

   // self.popScope();

   
   // expand-statemnt の解析。
   // ここではトークン切り出しだけ行なう。
   /// 実際の解析処理は、マクロ展開時(TransUnit.evalMacroOp)に行なう。

   let mut tokenList: List<&Parser.Token> = [];
   let mut braceCount = 0;

   while true {
      nextToken = self.getToken(##);
      if nextToken.txt == "{" {
         braceCount = braceCount + 1;
      }
      elseif nextToken.txt == "}" {
         if braceCount == 0 {
            break;
         }
         braceCount = braceCount - 1;
      }
      tokenList.insert( nextToken );
   }

   let typeInfo = self.processInfo.createFuncAsync(
      false, false, macroScope, .Macro, parentType, false, false, true,
      accessMode, nameToken.txt, .Async, nil, argTypeList, retTypeList## );
   //self.scope.addLocalVar( false, false, nameToken.txt, typeInfo, false );
   // self.scope.addMacro( typeInfo, accessMode );


   let mut declMacroInfo = new Nodes.DeclMacroInfo(
      pubFlag, nameToken, argList, stmtNode, tokenList ) ;
   let mut node = Nodes.DeclMacroNode.create(
      self.nodeManager, firstToken.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], declMacroInfo );

   __asyncLock { 
      self.macroCtrl.regist( self.processInfo, node, macroScope );
   }

   return node;
}


fn TransUnit.analyzeDeclMacro(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclMacroNode
{

   let nameToken = self.getSymbolToken( .Must_ );
   self.checkNextToken( "(" );


   // マクロ内は、独立スコープにするため、
   // マクロ用のスコープを topScope 直下に生成
   let mut scope = Ast.TypeInfo.createScope(
      self.processInfo, self.topScope, false, nil, nil );

   // 名前空間に属させるためのダミーの関数を定義
   self.createDummyNS( scope, nameToken.pos, .Noasync );

   // マクロ引数を解析。
   // このとき、マクロの型名や引数名などは現在のスコープをスコープを利用し、
   // 引数シンボルはマクロ用スコープに登録する。
   let mut workArgList: List<&Nodes.Node> = [];
   self.analyzeDeclArgList( accessMode, scope, workArgList, false );

   // マクロ解析用スコープに変更する前に、登録する namespace を取っおく
   let mut parentInfo = self.getCurrentNamespaceTypeInfoMut();
   
   // スコープをマクロ用スコープに変更
   let mut backScope = self.scope;
   self.scope = scope;

   self.scope.addIgnoredVar( self.processInfo );
   

   let mut node = self.analyzeDeclMacroSub(
      accessMode, firstToken, nameToken, scope, parentInfo, workArgList );

   // スコープを元に戻す
   self.scope = backScope;

   let _, existSym = self.scope.addMacro(
      self.processInfo, nameToken.pos, node.$expType, accessMode );
   if existSym {
      self.addErrMess(
         nameToken.pos, "multiple define symbol -- %s" (nameToken.txt) );
   }
   
   return node;
}

fn TransUnit.analyzeExtend( accessMode:Ast.AccessMode, firstPos: &Parser.Position ) mut :
&Parser.Token, &Ast.TypeInfo!, &List<&Ast.TypeInfo>,
Map<&Ast.TypeInfo,&Ast.TypeInfo>, Nodes.ClassInheritInfo
{
   let mut baseRef:&Nodes.RefTypeNode! = nil;
   let mut interfaceList:List<&Ast.TypeInfo> = [];
   let mut ifAlt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo> = {};
   let mut ifRefList:List<&Nodes.RefTypeNode> = [];

   let mut nextToken = self.getToken(##);
   if nextToken.txt ~= "(" {
      self.pushback();
      let workBaseRefType = self.analyzeRefType(
         accessMode, false, Ast.isPubToExternal( accessMode ) );
      baseRef = workBaseRefType;
      let baseType = workBaseRefType.$expType;
      if baseType.$kind ~= .Class {
         self.addErrMess( workBaseRefType.$pos,
                          "%s is not class." ( baseType.getTxt(##) ) );
      }
      if Ast.isPubToExternal( accessMode ) and
         not Ast.isPubToExternal( baseType.$accessMode )
      {
         self.addErrMess(
            workBaseRefType.$pos,
            "%s can't be external symbol." ( baseType.getTxt(##) ) );
      }
      nextToken = self.getToken(##);
   }
   if nextToken.txt == "(" {
      while true {
         nextToken = self.getToken(##);
         if nextToken.txt == ")" {
            break;
         }
         self.pushback();
         let ifTypeNode = self.analyzeRefType(
            accessMode, false, Ast.isPubToExternal( accessMode ) );
         ifRefList.insert( ifTypeNode );
         let ifType = ifTypeNode.$expType;
         if ifType.$kind ~= .IF {
            self.error( "%s is not interface -- %d"
                        (ifType.getTxt(##), ifType.$kind ) );
         }

         if Ast.isGenericType( ifType ) {
            foreach genType, altType in ifType.createAlt2typeMap(false) {
               ifAlt2typeMap[ altType ] = genType;
            }
         }


         interfaceList.insert( ifType );
         if Ast.isPubToExternal( accessMode ) and
            not Ast.isPubToExternal( ifType.$accessMode )
         {
            self.addErrMess( ifTypeNode.$pos,
                             "%s can't be external symbol." ( ifType.getTxt(##) ) );
         }

         nextToken = self.getToken(##);
         if nextToken.txt ~= "," {
            if nextToken.txt == ")" {
               break;
            }
            self.error( "illegal token" );
         }
      }
      nextToken = self.getToken(##);
   }

   // interface 間の、メソッドのミスマッチをチェックする
   let mut symbol2TypeInfo:Map<str,&Ast.TypeInfo> = {};
   foreach ifType in interfaceList {
      ifType.$scope$.filterTypeInfoField$(
         true, self.scope, self.scopeAccess,
         fn ( symbolInfo:&Ast.SymbolInfo ) __trans : bool {
            if symbolInfo.$kind == .Mtd {
               if! let ifFuncType = symbol2TypeInfo[ symbolInfo.$name ] {
                  let ret, mess = ifFuncType.canEvalWith(
                     self.processInfo, symbolInfo.$typeInfo, .SetOp, ifAlt2typeMap );
                  if not ret {
                     self.addErrMess(
                        firstPos,
                        "mismatch method type -- %s.%s, %s.%s\n%s"
                        (symbolInfo.$typeInfo.$parentInfo.getTxt(##), symbolInfo.$name,
                          ifFuncType.$parentInfo.getTxt(##), ifFuncType.getTxt(##), mess));
                  }
               }
               else {
                  symbol2TypeInfo[ symbolInfo.$name ] = symbolInfo.$typeInfo;
               }
            }
            return true;
         } );
   }



   let mut baseTypeInfo:&Ast.TypeInfo! = nil;
   when! baseRef {
      baseTypeInfo = baseRef.$expType;
   }
   return nextToken, baseTypeInfo, interfaceList,
      ifAlt2typeMap, new Nodes.ClassInheritInfo( baseRef, ifRefList );
}

fn TransUnit.analyzePushClass(
   mode:DeclClassMode, abstractFlag: bool, firstToken:&Parser.Token, name:&Parser.Token,
   allowMultiple:bool, requirePath:&Parser.Token!, moduleLang:Types.Lang!,
   accessMode:Ast.AccessMode, altTypeList:&List<&Ast.AlternateTypeInfo> ) mut :
   &Parser.Token, TransUnitIF.NSInfo, &Nodes.ClassInheritInfo
{
   if Ast.isPubToExternal( accessMode ) and self.moduleScope ~= self.scope
   {
      self.addErrMess( firstToken.pos, "The public class must declare at top scope." );
   }


   // altTypeList のシンボルにアクセスできるように、一時的にスコープを掘る
   let mut tempScope = self.pushScope( false## );
   foreach altType in altTypeList {
      tempScope.addAlternate(
         self.processInfo, accessMode, altType.$rawTxt, name.pos, altType );
   }


   let mut nextToken = self.getToken(##);
   let mut baseTypeInfo:&Ast.TypeInfo! = nil;
   let mut interfaceList:&List<&Ast.TypeInfo>! = nil;
   let inheritInfo;
   if nextToken.txt == "extend" {
      nextToken, baseTypeInfo, interfaceList, _, inheritInfo = self.analyzeExtend(
         accessMode, firstToken.pos );

      when! baseTypeInfo {
         if! let initTypeInfo = baseTypeInfo.$scope$.getTypeInfoChild$("__init") {
            if initTypeInfo.$accessMode == .Pri {
               self.addErrMess(
                  firstToken.pos, "The access mode of '__init' is 'pri'." );
            }
         };
         if baseTypeInfo.isInheritFrom( self.processInfo,
                                        self.builtinFunc.lnsthread_, nil ) and
            not self.helperInfo.pragmaSet.has( LuneControl.Pragma.use_async )
         {
            self.addErrMess( nextToken.pos, "must set '_lune_control use_async'" );
         }
      }
   } else {
      inheritInfo = new Nodes.ClassInheritInfo( nil, [] );
   }


   // 一時的に掘ったスコープを戻す
   self.popScope();

   let mut nsInfo;
   _switch mode {
      case .Module, .LazyModule {
         let mut parentScope = self.scope;
         nsInfo = self.pushExtModule(
            false, name.txt, accessMode, name.pos, mode == .LazyModule,
            unwrap moduleLang, (unwrap requirePath).getExcludedDelimitTxt() );
      }
      case .Class, .Interface {
         nsInfo = self.pushClass(
            self.processInfo, firstToken.pos, mode, abstractFlag, baseTypeInfo,
            interfaceList, altTypeList, false, name.txt, allowMultiple, accessMode ## );
      }
   }

   return nextToken, nsInfo, inheritInfo;
}

fn TransUnit.analyzeDeclAlternateType(
   belongClassFlag:bool, token:&Parser.Token, accessMode: Ast.AccessMode ) mut :
   &Parser.Token, List<&Ast.AlternateTypeInfo>
{
   let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
   let mut nextToken = token;
   let mut altNameSet:Set<str> = (@);
   let mut altIndex = 0;
   while true {
      altIndex = altIndex + 1;
      let genericSymToken = self.getSymbolToken( .MustNot_ );
      if self.scope.getTypeInfo(
         genericSymToken.txt, self.scope, false, self.scopeAccess)
      {
         self.addErrMess( genericSymToken.pos,
                          "shadowing Type -- %s" (genericSymToken.txt) );
      }
      else {
         if altNameSet.has( genericSymToken.txt ) {
            self.addErrMess( genericSymToken.pos,
                             "multiple Type -- %s" (genericSymToken.txt) );
         }
         else {
            altNameSet.add( genericSymToken.txt );
         }
      }
      let mut workToken = self.getToken(##);
      if workToken.txt == "!" {
         self.addErrMess( workToken.pos, "not support nilable" );
         workToken = self.getToken(##);
      }
      let mut baseTypeInfo:&Ast.TypeInfo! = nil;
      let mut interfaceList:&List<&Ast.TypeInfo> = [];
      if workToken.txt == ":" {
         workToken, baseTypeInfo, interfaceList = self.analyzeExtend(
            accessMode, token.pos );
      }

      let altType = self.processInfo.createAlternate(
         belongClassFlag, altIndex, genericSymToken.txt,
         accessMode, self.moduleType, baseTypeInfo, interfaceList );
      altTypeList.insert( altType );

      if workToken.txt == ">" {
         nextToken = self.getToken(##);
         break;
      }
      self.checkToken( workToken, "," );
   }
   return nextToken, altTypeList;
}

fn TransUnit.analyzeDeclProto(
   mut accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut nextToken = self.getToken(##);
   let mut abstractFlag = false;
   if nextToken.txt == "abstract" {
      abstractFlag = true;
      nextToken = self.getToken(##);
   }


   if nextToken.txt == "class" or nextToken.txt == "interface" {
      let name = self.getSymbolToken( .MustNot_ );

      // generic の型宣言解析
      let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
      {
         let mut workToken = self.getToken(##);
         if workToken.txt == "<" {
            workToken, altTypeList = self.analyzeDeclAlternateType(
               true, workToken, accessMode );
         }
         self.pushbackToken( workToken );
      }

      if accessMode == .Local {
         accessMode = .Pri;
      }

      let declMode;
      if nextToken.txt == "class" {
         declMode = DeclClassMode.Class;
      } else {
         declMode = .Interface;
         abstractFlag = true;
      }
      let classTypeInfo:Ast.TypeInfo;
      let inheritInfo;
      let mut nsInfo;
      nextToken, nsInfo, inheritInfo = self.analyzePushClass(
         declMode, abstractFlag,
         firstToken, name, false, nil, nil, accessMode, altTypeList );
      classTypeInfo = nsInfo.$typeInfo;

      nsInfo.set_nobody( true );

      self.popClass();
      self.checkToken( nextToken, ";" );

      return Nodes.ProtoClassNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(),  [ classTypeInfo ], name, inheritInfo );
   }
   self.error( "illegal proto" );
}

fn TransUnit.analyzeDeclEnum(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclEnumNode
{
   if Ast.isPubToExternal( accessMode ) and
      self.scope ~= self.moduleScope and
      self.scope.$ownerTypeInfo$.$kind ~= .Class
   {
      self.addErrMess( firstToken.pos, "can't external at inner scope." );
   }
   
   let name = self.getSymbolToken( .MustNot_ );

   self.checkNextToken( "{" );

   let mut valueList:List<&Parser.Token> = [];
   //let mut valueName2Info:Map<str,Ast.EnumValInfo> = {};

   let mut scope = self.pushScope( true ## );

   let mut workEnumTypeInfo:Ast.EnumTypeInfo! = nil;

   let mut nextToken = self.getToken(##);
   let mut number = 0.0;
   let mut prevValTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   let mut valTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   while nextToken.txt ~= "}" {
      let valName = self.checkSymbol(nextToken, .MustNot_ );

      nextToken = self.getToken(##);

      let mut enumVal = Ast.EnumLiteral.Real( number );
      switch ( prevValTypeInfo ) {
         case Ast.builtinTypeReal {
         }
         case Ast.builtinTypeInt, Ast.headTypeInfo {
            enumVal = .Int( number@@int );
         }
      }

      if nextToken.txt == "=" {
         let exp = self.analyzeExpOneRVal( false, false ## );
         let literal, mess = exp.getLiteral();
         when! literal {
            match literal {
               case .Int( val ) {
                  enumVal = .Int( val );
                  number = val@@real;
                  valTypeInfo = Ast.builtinTypeInt;
               }
               case .Real( val ) {
                  enumVal = .Real( val );
                  number = val;
                  valTypeInfo = Ast.builtinTypeReal;
               }
               case .Str( val ) {
                  enumVal = .Str( val );
                  valTypeInfo = Ast.builtinTypeString;
               }
               default {
                  self.error( "illegal enum val -- %s" ( literal.$_txt ) );
               }
            }
         }
         else {
            self.error( "illegal enum val -- %s" (mess) );
         }

         nextToken = self.getToken(##);
      }
      else {
         switch ( prevValTypeInfo ) {
            case Ast.headTypeInfo {
               valTypeInfo = Ast.builtinTypeInt;
            }
            case Ast.builtinTypeInt, Ast.builtinTypeReal {
               valTypeInfo = prevValTypeInfo;
            }
            default {
               self.addErrMess( valName.pos,
                                "illegal enum val type -- %s" (valTypeInfo.getTxt(##)) );
            }
         }
      }
      if prevValTypeInfo ~= Ast.headTypeInfo and prevValTypeInfo ~= valTypeInfo
      {
         self.addErrMess( valName.$pos,
                          "multiple enum val type. %s, %s"
                          (valTypeInfo.getTxt(##), prevValTypeInfo.getTxt(##)) );
      }
      prevValTypeInfo = valTypeInfo;

      if not workEnumTypeInfo {
         workEnumTypeInfo = self.processInfo.createEnum(
            scope, self.getCurrentNamespaceTypeInfoMut(),
            false, accessMode, name.txt, valTypeInfo );
      }

      when! workEnumTypeInfo {
         let evalValSym = unwrap scope.addEnumVal(
            self.processInfo, valName.txt, valName.pos, workEnumTypeInfo );

         let enumValInfo = new Ast.EnumValInfo( valName.txt, enumVal, evalValSym );
         valueList.insert( valName );

         workEnumTypeInfo.addEnumValInfo( enumValInfo );
      }

      if nextToken.txt == "}" {
         break;
      }
      self.checkToken( nextToken, "," );
      nextToken = self.getToken(##);
      number = number + 1;
   }


   let! enumTypeInfo = workEnumTypeInfo {
      enumTypeInfo = self.processInfo.createEnum(
         scope, self.getCurrentNamespaceTypeInfoMut(),
         false, accessMode, name.txt, Ast.builtinTypeNone );
   };

   self.popScope();

   let _, shadowing = self.scope.addEnum(
      self.processInfo, accessMode, name.txt, name.pos, enumTypeInfo );
   self.errorShadowing( name.pos, shadowing );


   return Nodes.DeclEnumNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(), 
      [ enumTypeInfo ], enumTypeInfo, accessMode, name, valueList, scope );
}



fn TransUnit.analyzeDeclAlge(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclAlgeNode
{
   self.helperInfo.useAlge = true;

   let name = self.getSymbolToken( .MustNot_ );

   self.checkNextToken( "{" );

   let mut scope = self.scope;
   let mut algeScope = self.pushScope( true ## );

   let mut algeTypeInfo = self.processInfo.createAlge(
      algeScope, self.getCurrentNamespaceTypeInfoMut(), false, accessMode, name.txt );
   let _, shadowing = scope.addAlge(
      self.processInfo, accessMode, name.txt, name.pos, algeTypeInfo );
   self.newNSInfo( algeTypeInfo, name.pos );
   self.errorShadowing( name.pos, shadowing );

   let mut algeValList: List<Nodes.DeclAlgeValInfo> = [];

   let mut nextToken = self.getToken(##);
   while nextToken.txt ~= "}" {
      let valName = self.checkSymbol( nextToken, .MustNot_ );
      if algeTypeInfo.getValInfo( valName.txt ) {
         self.addErrMess( valName.pos, "multiple symbole -- %s" (valName.txt) );
      }

      nextToken = self.getToken(##);

      let mut paramList:List<&Nodes.AlgeValParamInfo> = [];
      
      let mut typeInfoList:List<&Ast.TypeInfo> = [];
      if nextToken.txt == "(" {
         // パラメータの宣言
         while true {
            // パラメータ名の確認
            let paramNameToken:&Types.Token!;
            let workToken1 = self.getToken(##);
            let workToken2 = self.getToken(##);
            if workToken2.txt ~= ":" {
               // パラメータ名を省略している場合は戻す
               self.pushback();
               self.pushback();
               paramNameToken = nil;
            } else {
               paramNameToken = workToken1;
            }
            
            let typeNode = self.analyzeRefType(
               .Pub, false, Ast.isPubToExternal( accessMode ) );
            if self.nsInfoMap[ typeNode.$expType ]$.$nobody {
               self.addErrMess(
                  typeNode.$pos,
                  "can't use the prototype class -- %s" ( typeNode.$expType.getTxt(##)) );
            }
            typeInfoList.insert( typeNode.$expType );
            paramList.insert( new Nodes.AlgeValParamInfo( paramNameToken, typeNode ) );
            
            nextToken = self.getToken(##);
            if nextToken.txt ~= "," {
               self.checkToken( nextToken, ")" );
               nextToken = self.getToken(##);
               break;
            }
         }
      }

      let workAlgeValSym, algeValSymShadow = algeScope.addAlgeVal(
         self.processInfo, valName.txt, valName.pos, algeTypeInfo );
      self.errorShadowing( valName.pos, algeValSymShadow );
      let algeValSym = unwrap (workAlgeValSym or shadowing);
      let algeValInfo = new Ast.AlgeValInfo(
         valName.txt, typeInfoList, algeTypeInfo, algeValSym );
      algeTypeInfo.addValInfo( algeValInfo );

      algeValList.insert( new Nodes.DeclAlgeValInfo( algeValSym, paramList ) );

      if nextToken.txt == "}" {
         break;
      }
      self.checkToken( nextToken, "," );
      nextToken = self.getToken(##);
   }

   self.popScope();


   return Nodes.DeclAlgeNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ algeTypeInfo ], accessMode, algeTypeInfo, name, algeValList, algeScope );
}

fn TransUnit.analyzeAlias(
   accessMode: Ast.AccessMode, firstToken:&Parser.Token ) mut : Nodes.AliasNode
{
   if self.scope ~= self.moduleScope {
      self.addErrMess( firstToken.pos, "alias must use at top scope." );
   }

   let newToken = self.getToken(##);
   self.checkNextToken( "=" );

   let srcToken = self.getToken(##);

   let symbolNode = self.analyzeExpSymbol(
      srcToken, srcToken, .Symbol, nil, true, false );


   let mut newTypeInfo = Ast.builtinTypeNone;
   let symbolInfoList = symbolNode.getSymbolInfo();

   let mut newSymbolInfo:&Ast.SymbolInfo = Ast.dummySymbol;

   if #symbolInfoList >= 1 {
      let symbolInfo = symbolInfoList[ 1 ];
      if newToken.txt.find( "^_" ##) and not srcToken.txt.find( "^_" ##) or
         not newToken.txt.find( "^_" ##) and srcToken.txt.find( "^_" ## )
      {
         self.addErrMess( firstToken.pos,
                          "alias symbol unmatch. %s %s" (newToken.txt, newToken.txt) );
      }
      else {
         switch symbolInfo.$kind {
            case .Typ, .Fun {
               let aliasSymbolInfo, shadowing = self.scope.addAlias(
                  self.processInfo, newToken.txt, newToken.pos,
                  false, accessMode, self.moduleType, symbolInfo );
               when! aliasSymbolInfo {
                  newTypeInfo = aliasSymbolInfo.$typeInfo;
                  newSymbolInfo = aliasSymbolInfo;
               }
               else {
                  self.errorShadowing( newToken.pos, shadowing );
               }
            }
            default {
               self.addErrMess(
                  firstToken.pos,
                  "can alias symbol -- %s. (%s)"
                  (srcToken.txt, symbolInfo.$kind.$_txt ) );
            }
         }
      }
   }
   else {
      self.addErrMess( firstToken.pos, "not found symbold -- %s" (srcToken.txt ) );
   }
   self.checkNextToken( ";" );

   return Nodes.AliasNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ newTypeInfo ], newSymbolInfo, symbolNode, newTypeInfo );
}



fn TransUnit.analyzeRetTypeList(
   pubToExtFlag:bool, accessMode:Ast.AccessMode,
   mut token:&Parser.Token, parentPub:bool ) mut :
   List<&Ast.TypeInfo>, &Parser.Token, &List<&Nodes.RefTypeNode>
{
   let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
   let mut retTypeNodeList:List<&Nodes.RefTypeNode> = [];
   if token.txt == ":" {
      let mut hasDDDFlag = false;
      while true {
         let refTypeNode = self.analyzeRefType( accessMode, true, parentPub );
         if hasDDDFlag {
            self.addErrMess( refTypeNode.$pos, "Type exists after '...'." );
         }
         let retType = refTypeNode.$expType;
         if retType.$kind == .DDD {
            hasDDDFlag = true;
         }
         if pubToExtFlag and not Ast.isPubToExternal( retType.$accessMode )
         {
            self.addErrMess( refTypeNode.$pos,
                             "this is not public type -- %s" (retType.getTxt(##)) );
         }

         retTypeInfoList.insert( retType );
         retTypeNodeList.insert( refTypeNode );
         token = self.getToken(##);
         if token.txt ~= "," {
            break;
         }
      }
   }
   return retTypeInfoList, token, retTypeNodeList;
}

fn TransUnit.getMutableAsync( mut token: &Types.Token )
mut : &Types.Token, bool, Ast.Async!
{
   let mut mutable = false;
   let mut asyncMode:Ast.Async! = nil;
   
   while true {
      if token.txt == "mut" {
         mutable = true;
         token = self.getToken(##);
      } elseif token.txt == "__async" {
         asyncMode = .Async;
         token = self.getToken(##);
      } elseif token.txt == "__noasync" {
         asyncMode = .Noasync;
         token = self.getToken(##);
      } elseif token.txt == "__trans" {
         asyncMode = .Transient;
         token = self.getToken(##);
      } else {
         break;
      }
   }
   return token, mutable, asyncMode;
}

fn TransUnit.analyzeDeclForm( accessMode:Ast.AccessMode, firstToken:&Parser.Token )
mut : Nodes.DeclFormNode
{
   let name = self.getSymbolToken( .MustNot_ );

   if self.scope ~= self.moduleScope and Ast.isPubToExternal( accessMode ) {
      self.addErrMess(
         firstToken.pos,
         "You must declare this form at the outside scope. -- %s"
         (name.txt) );
   }
   
   
   self.checkNextToken( "(" );
   let mut argList:List<&Nodes.Node> = [];
   let mut funcBodyScope = self.pushScope( false ## );

   let mut nextToken = self.analyzeDeclArgList(
      accessMode, funcBodyScope, argList, Ast.isPubToExternal( accessMode ) );

   self.checkToken( nextToken, ")" );

   let asyncMode;
   nextToken, _, asyncMode = self.getMutableAsync( self.getToken(##) );
   
   let mut retTypeList:List<&Ast.TypeInfo> = [];
   //nextToken = self.getToken(##);
   let retNodeList;
   retTypeList, nextToken, retNodeList = self.analyzeRetTypeList(
      Ast.isPubToExternal( accessMode ), accessMode, nextToken,
      Ast.isPubToExternal( accessMode ) );

   self.checkToken( nextToken, ";" );

   self.popScope();

   let mut argTypeInfoList:List<&Ast.TypeInfo> = [];
   foreach argNode in argList {
      argTypeInfoList.insert( argNode.$expType );
   }

   let formType = self.processInfo.createFuncAsync(
      false, false, nil, .FormFunc,
      self.getCurrentNamespaceTypeInfoMut(), false, false,
      true, accessMode, name.txt,
      self.getDefaultAsync( .FormFunc, self.getCurrentClass(), asyncMode ),
      nil, argTypeInfoList, retTypeList, false );

   let formSymbol, shadowing = self.scope.addForm(
      self.processInfo, name.pos, formType, accessMode );
   self.errorShadowing( name.pos, shadowing );

   let declFuncInfo = new Nodes.DeclFuncInfo(
      .Form, nil, nil, name, formSymbol or shadowing, argList, false,
      accessMode, asyncMode, nil, retTypeList, retNodeList, false, false );
   
   return Nodes.DeclFormNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ formType ], declFuncInfo );
}

fn TransUnit.analyzeDecl(
   accessMode: Ast.AccessMode, mut staticFlag: bool,
   firstToken: &Parser.Token, mut token: &Parser.Token ) mut : Nodes.Node!
{
   if not staticFlag {
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken(##);
      }
   }
   let mut overrideFlag = false;
   if token.txt == "override" {
      overrideFlag = true;
      token = self.getToken(##);
   }

   let mut abstractFlag = false;
   if token.txt == "abstract" {
      abstractFlag = true;
      token = self.getToken(##);
   }

   if token.txt == "let" {
      return self.analyzeDeclVar( .Let, accessMode, firstToken );
   }
   elseif token.txt == "fn" {
      let nextToken = self.getToken(##);
      self.pushback();
      if nextToken.kind == .Symb or Ast.isPubToExternal( accessMode ) or
         staticFlag or overrideFlag or abstractFlag
      {
         // nextToken が .Symb の場合は、通常の関数定義。
         // anonymous 関数でも、 pub 等が指定されている場合は、
         // エラー処理用に analyzeDeclFunc() をコールする。
         return self.analyzeDeclFunc(
            .Func, false, abstractFlag, overrideFlag,
            accessMode, staticFlag, nil, firstToken, nil );
      }
      // anonymous 関数の場合は、 関数定義ではなく関数オブジェクトを利用した式。
   }
   elseif token.txt == "class" {
      return self.analyzeDeclClass( abstractFlag, accessMode, firstToken, .Class );
   }
   elseif token.txt == "interface" {
      return self.analyzeDeclClass( true, accessMode, firstToken, .Interface );
   }
   elseif token.txt == "module" {
      return self.analyzeDeclClass( false, accessMode, firstToken, .Module );
   }
   // elseif token.txt == "__module" {
   //    return self.analyzeDeclClass( false, accessMode, firstToken, .LazyModule );
   // }
   elseif token.txt == "proto" {
      return self.analyzeDeclProto( accessMode, firstToken );
   }
   elseif token.txt == "macro" {
      return self.analyzeDeclMacro( accessMode, firstToken );
   }
   elseif token.txt == "enum" {
      return self.analyzeDeclEnum( accessMode, firstToken );
   }
   elseif token.txt == "alge" {
      return self.analyzeDeclAlge( accessMode, firstToken );
   }
   elseif token.txt == "form" {
      return self.analyzeDeclForm( accessMode, firstToken );
   }
   elseif token.txt == "alias" {
      return self.analyzeAlias( accessMode, firstToken );
   }
   elseif token.txt == "__test" {
      return self.analyzeTest( firstToken );
   }

   return nil;
}


fn TransUnit.checkPublic( pos:&Parser.Position, typeInfo:&Ast.TypeInfo ) mut {
   let mut checkedTypeSet:Set<&Ast.TypeInfo> = (@);
   fn checkPub( workType:&Ast.TypeInfo ) __trans {
      if checkedTypeSet.has( workType ) {
         return;
      }
      checkedTypeSet.add( workType );
      if workType.$kind ~= .Array and workType.$kind ~= .List
         and workType.$kind ~= .Set
         and workType.$kind ~= .Map and not Ast.isPubToExternal( workType.$accessMode )
      {
         self.addErrMess( pos, "not public this type -- %s" ( workType.getTxt(##)) );
      }
      else {
         foreach itemType in workType.$itemTypeInfoList {
            checkPub( itemType );
         }
      }
   }
   checkPub( typeInfo );
}

fn TransUnit.analyzeDeclMember(
   classTypeInfo: &Ast.TypeInfo, accessMode: Ast.AccessMode,
   staticFlag: bool, firstToken: &Parser.Token ) mut: Nodes.DeclMemberNode
{
      let mut nextToken = self.getToken(##);
      let mut mutMode = Ast.MutMode.IMut;
      switch nextToken.txt {
         case "mut" {
            mutMode = .Mut;
            nextToken = self.getToken(##);
         }
         case "allmut" {
            mutMode = .AllMut;
            nextToken = self.getToken(##);
         }
      }
      let varName = self.checkSymbol( nextToken, .MustNot_ );
      let mut token = self.getToken(##);
      let refType = self.analyzeRefType(
         accessMode, false, Ast.isPubToExternal( classTypeInfo.$accessMode ));
      token = self.getToken(##);

      if refType.$expType.$asyncMode == .Transient {
         self.addErrMess( refType.$pos,
                          "can't hold with the type of __trans. -- %s"
                          (varName.txt) );
      }

      // accessor
      let mut getterMode = Ast.AccessMode.None;
      let mut getterRetType = refType.$expType;
      let mut getterToken:&Types.Token! = nil;
      let mut getterMutable = Ast.MutMode.Mut;
      let mut setterMode = Ast.AccessMode.None;
      let mut setterToken:&Types.Token! = nil;
      if token.txt == "{" {

         fn analyzeAccessorMode():
         Ast.AccessMode, &Ast.TypeInfo, &Parser.Token, &Parser.Token
         {
            let mut retType = Ast.headTypeInfo;
            let mut mode = Ast.AccessMode.None;
            let mut accessorToken = self.getToken(##);
            let mut workToken = accessorToken;
            switch workToken.txt {
               case "pub", "pri", "pro", "local" {
                  mode = unwrap Ast.txt2AccessMode( workToken.txt );
                  workToken = self.getToken(##);
                  if workToken.txt == "&" {
                     getterMutable = .IMut;
                     workToken = self.getToken(##);
                  }
                  if workToken.txt == ":" {
                     let typeNode = self.analyzeRefType(
                        mode, false, Ast.isPubToExternal( classTypeInfo.$accessMode ) );
                     retType = typeNode.$expType;
                     workToken = self.getToken(##);
                  }
               }
               case "non" {
                  workToken = self.getToken(##);
               }
               default {
                  self.addErrMess( workToken.pos,
                                   "access mode is invalid -- %s" (workToken.txt) );
               }
            }
            return mode, retType, accessorToken, workToken;
         }

         {
            let workRetType;
            getterMode, workRetType, getterToken, nextToken = analyzeAccessorMode();
            if workRetType ~= Ast.headTypeInfo {
               if not workRetType.canEvalWith(
                  self.processInfo, getterRetType, .SetOp,
                  classTypeInfo.createAlt2typeMap( false ) )
               {
                  self.addErrMess( firstToken.pos,
                                   "getter type mismatch -- %s <- %s"
                                   (workRetType.getTxt(##), getterRetType.getTxt(##)));
               }
               getterRetType = workRetType;
            }
         }
         if nextToken.txt == "," {
            let dummyRetType;
            setterMode, dummyRetType, setterToken, nextToken = analyzeAccessorMode();
            if setterMode ~= .None and mutMode == .IMut {
               // immutable なメンバに setter 宣言は出来ない
               self.addErrMess(
                  varName.pos,
                  "This member can't have setter, this member is immutable. -- %s"
                  (varName.txt) );
            }
            // pending
            Log._log2( .Debug, "%s" (dummyRetType) );
         }
         self.checkToken( nextToken, "}" );
         token = self.getToken(##);
      }

      self.checkToken( token, ";" );

      let mut typeInfo = refType.$expType;
      // if Ast.TypeInfo.isMut( typeInfo ) and mutMode == .IMut {
      //    typeInfo = self.createModifier( typeInfo, .IMut );
      // }
      if self.ctrl_info.legacyMutableControl {
         if Ast.TypeInfo.isMut( typeInfo ) and typeInfo.$mutMode ~= mutMode {
            typeInfo = self.createModifier( typeInfo, mutMode );
         }
         if Ast.TypeInfo.isMut( getterRetType ) and getterRetType.$mutMode ~= mutMode {
            getterRetType = self.createModifier( getterRetType, mutMode );
         }
      } else {
         if Ast.TypeInfo.isMut( getterRetType ) {
            if getterMutable == .AllMut {
               getterRetType = self.createModifier( getterRetType, .AllMut );
            } elseif getterMutable == .IMut {
               getterRetType = self.createModifier( getterRetType, .IMut );
            }
         }
      }

      if Ast.isPubToExternal( classTypeInfo.$accessMode ) {
         if Ast.isPubToExternal( accessMode ) or Ast.isPubToExternal( setterMode ) {
            self.checkPublic( refType.$pos, typeInfo );
         }
         if Ast.isPubToExternal( getterMode ) {
            self.checkPublic( refType.$pos, getterRetType );
         }
      }

      let symbolInfo, shadowing = self.scope.addMember(
         self.processInfo, varName.txt, varName.pos,
         typeInfo, accessMode, staticFlag, mutMode );

      let workSym = unwrap (symbolInfo or shadowing);
      when! shadowing {
         self.errorShadowing( varName.pos, shadowing );
      }

      return Nodes.DeclMemberNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ],
         varName, refType, workSym, classTypeInfo, 
         staticFlag, accessMode, getterMutable ~= .IMut,
         getterMode, getterToken, getterRetType, setterMode, setterToken );
   }

fn TransUnit.analyzeDeclMethod(
   classTypeInfo: &Ast.TypeInfo, declFuncMode: DeclFuncMode,
   abstractFlag: bool, overrideFlag: bool, accessMode: Ast.AccessMode,
   staticFlag: bool, firstToken: &Parser.Token, name: &Parser.Token ) mut : Nodes.Node
{
   let mut node = self.analyzeDeclFunc(
      declFuncMode, false, abstractFlag,
      overrideFlag, accessMode, staticFlag, classTypeInfo, name, name );
   return node;
}


/**
デフォルトコンストラクタの追加処理

@param pos クラスの定義位置
@param classTypeInfo クラス情報
@param classScope クラスのスコープ
@param memberNodeList メンバーノードリスト
@param methodNameSet メソッド名の集合
*/
fn TransUnit.addDefaultConstructor(
   pos:&Parser.Position, classTypeInfo:Ast.TypeInfo,
   classScope:Ast.Scope, memberNodeList:&List<&Nodes.DeclMemberNode>,
   methodNameSet:Set<str>, oldFlag:bool ) mut
{
   if classScope.getTypeInfoChild( "__init" ) {
      self.addErrMess( pos, "already declare __init()." );
   }

   // デフォルトコンストラクタの引数の型リストを決定する
   let mut argTypeList:List<&Ast.TypeInfo> = [];

   if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
      // 継承している場合
      let superScope = unwrap classTypeInfo.$baseTypeInfo.$scope;
      let superTypeInfo = unwrap superScope.getTypeInfoChild( "__init" );
      foreach argType in superTypeInfo.$argTypeInfoList {
         if oldFlag {
            if not argType.$nilable {
               self.addErrMess( pos, "not found '__init' decl." );
            }
         }
         else {
            argTypeList.insert( argType );
         }
      }
   }

   foreach memberNode in memberNodeList {
      if not memberNode.$staticFlag {
         argTypeList.insert( memberNode.$expType );
      }
   }

   if Ast.isPubToExternal( classTypeInfo.$accessMode ) {
      // クラスが外部公開なら、
      // コンストラクタの型は全て外部公開可能でなければならない。
      foreach memberType in argTypeList {
         if not Ast.isPubToExternal( memberType.$accessMode ) {
            self.addErrMess(
               pos, "The type must be 'pub' becaue using in __init(). -- %s:%s"
               ( memberType.getTxt(##), memberType.$accessMode.$_txt ) );
         }
      }
   }

   // デフォルトコンストラクタの登録
   let mut ctorScope = self.pushScope( false ## );
   let initTypeInfo = self.processInfo.createFuncAsync(
      false, false, ctorScope, .Method, classTypeInfo,
      true, false, false, .Pub, "__init", .Async, nil, argTypeList, [] ## );
   if oldFlag {
      // oldFlag の場合は スコープに "" のシンボルを追加する
      ctorScope.addVar( self.processInfo, .Pri, "", nil, Ast.headTypeInfo, .IMut, true);
   }
   self.popScope();
   classScope.addMethod( self.processInfo, pos, initTypeInfo, .Pub, false, false );
   methodNameSet.add( "__init" );

   // メンバーをセット済みにする
   foreach memberNode in memberNodeList {
      if not memberNode.$staticFlag {
         memberNode.$symbolInfo.updateValue( memberNode.$symbolInfo.$posForLatestMod );
      }
   }
}

/**
関数の本体ブロック処理

@param analyzingState 解析状態
@param firstToken エラー表示用トークン
@param classTypeInfo クラス情報。 メソッドでない場合は nil。
@param retTypeInfoList 関数の戻り値型リスト
@return Nodes.BlockNode 解析結果
*/
fn TransUnit.analyzeFuncBlock(
   analyzingState:AnalyzingState, firstToken: &Parser.Token,
   classTypeInfo:&Ast.TypeInfo!, funcTypeInfo:&Ast.TypeInfo, funcName:str,
   funcBodyScope:Ast.Scope, retTypeInfoList:&List<&Ast.TypeInfo> ) mut : Nodes.BlockNode
{
   if not funcTypeInfo.$staticFlag {
      if classTypeInfo {
         if! let overrideType = self.scope.$parent.getTypeInfoField(
            funcName, false, funcBodyScope, self.scopeAccess )
         {
            if not overrideType.$abstractFlag {
               funcBodyScope.add( self.processInfo, .Fun, false, false, "super", nil,
                                  overrideType, .Local, false, .IMut, true, false );
            }
         }
      }
   }

   self.pushAnalyzingState( analyzingState );

   let mut body = self.analyzeBlock( .Func, .Ignore, funcBodyScope, nil );

   self.popAnalyzingState();

   if #retTypeInfoList ~= 0 {
      let breakKind = body.getBreakKind( .Return );
      if retTypeInfoList[ 1 ] ~= Ast.builtinTypeNeverRet {
         switch breakKind {
            case .Return, .NeverRet {
            }
            default {
               self.addErrMess( firstToken.pos,
                                "This funcion doesn't have return." );
            }
         }
      }
      else {
         if breakKind ~= .NeverRet {
            self.addErrMess( firstToken.pos,
                             "This funcion must be never return. -- %s"
                             (breakKind.$_txt ));
         }
      }
   }
   return body;
}

fn TransUnit.addAccessor(
   memberNode:&Nodes.DeclMemberNode, methodNameSet: Set<str>,
   classScope:Ast.Scope, classTypeInfo:Ast.TypeInfo ) mut
{
   let memberType = memberNode.$expType;
   let memberName = memberNode.$name;
   // getter
   let getterName = "get_" .. memberName.txt;
   let mut accessMode = memberNode.$getterMode;
   let typeKind:Ast.TypeInfoKind;
   if memberNode.$staticFlag {
      typeKind = .Func;
   }
   else {
      typeKind = .Method;
   }
   let asyncMode:Ast.Async;
   if memberType.$mutMode == .AllMut {
      asyncMode = .Noasync;
   } else {
      asyncMode = .Async;
   }
   if accessMode ~= .None {
      if classScope.getTypeInfoChild( getterName ) {
         self.addErrMess( memberName.$pos,
                          "exist -- %s.%s" (classTypeInfo.$rawTxt, getterName) );
      } else {
         let mutable = memberNode.$getterMutable;
         let mut getterMemberType = memberNode.$getterRetType;
         if Ast.TypeInfo.isMut( getterMemberType ) and not mutable {
            getterMemberType = self.createModifier( getterMemberType, .IMut );
         }
         let retTypeInfo = self.processInfo.createFuncAsync(
            false, false, self.pushScope( false ## ),
            typeKind, classTypeInfo,
            false, false, memberNode.$staticFlag, accessMode,
            getterName, asyncMode,
            nil, [], [ getterMemberType ] ## );
         self.popScope();

         classScope.addMethod(
            self.processInfo, 
            memberName.pos, retTypeInfo, accessMode, memberNode.$staticFlag, false );
         methodNameSet.add( getterName );
      }
   }
   // setter
   let setterName = "set_" .. memberName.txt;
   accessMode = memberNode.$setterMode;
   if memberNode.$setterMode ~= .None {
      if classScope.getTypeInfoChild( setterName ) {
         self.addErrMess( memberName.$pos,
                          "exist -- %s.%s" (classTypeInfo.$rawTxt, setterName) );
      } else {
         let mutable;
         //if memberType.$mutMode == .Mut {
         if memberNode.$symbolInfo.$mutMode ~= .AllMut {
            mutable = true;
         }
         else {
            mutable = false;
         }
         classScope.addMethod(
            self.processInfo, memberName.pos,
            self.processInfo.createFuncAsync(
               false, false, self.pushScope( false ## ),
               typeKind, classTypeInfo,
               false, false, memberNode.$staticFlag, accessMode,
               setterName,
               asyncMode,
               nil, [ memberType ], nil, mutable ),
            accessMode, memberNode.$staticFlag, true );
         self.popScope();
         methodNameSet.add( setterName );
      }
   }
}


/**
クラスの本体部の解析。

@param classAccessMode クラスのアクセス制御
@param firstToken クラス定義の先頭トークン
@param mode クラス宣言モード
@param gluePrefix glue の prefix
@param classTypeInfo 宣言するクラスのタイプ
@param name クラス名のトークン
@param moduleName モジュール名
@param nextToken '{' の次のトークン。
@return Nodes.DeclClassNode クラス宣言のノード
@return &Parser.Token 解析終了後のトークン
@return Set<str> 定義されているメソッド名の Set
*/
fn TransUnit.analyzeClassBody(
   hasProto:bool, classAccessMode: Ast.AccessMode, firstToken: &Parser.Token,
   mode:DeclClassMode, gluePrefix:str!, classTypeInfo: Ast.TypeInfo,
   name:&Parser.Token, moduleLang:Types.Lang!,
   moduleName: &Parser.Token!, lazyLoad:Nodes.LazyLoad,
   mut nextToken:&Parser.Token, inheritInfo:&Nodes.ClassInheritInfo ) mut :
   Nodes.DeclClassNode, &Parser.Token, Set<str>
{
   let mut memberName2Node: Map<str,&Nodes.DeclMemberNode> = {};
   let mut allStmtList: List<&Nodes.Node> = [];
   let mut declStmtList: List<&Nodes.Node> = [];
   let mut fieldList:List<&Nodes.Node> = [];
   let mut memberList:List<&Nodes.DeclMemberNode> = [];
   let mut methodNameSet: Set<str> = (@);
   //let mut initStmtList:List<&Nodes.Node> = [];
   let mut initBlockInfo = new Nodes.ClassInitBlockInfo(##);
   let mut advertiseList:Nodes.AdvertiseInfo[] = [];
   let mut trustList:List<&Ast.TypeInfo> = [];
   let mut uninitMemberList:List<&Ast.SymbolInfo> = [];
   let mut node = Nodes.DeclClassNode.create(
      self.nodeManager, firstToken.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ classTypeInfo ],
      classAccessMode, name, inheritInfo, hasProto, gluePrefix, moduleName,
      moduleLang, lazyLoad, false, allStmtList,
      declStmtList, fieldList, memberList, self.scope, initBlockInfo,
      advertiseList, trustList, uninitMemberList, (@) );
   self.typeInfo2ClassNode[ classTypeInfo ] = node;
   let mut alreadyCtorFlag = false;
   let mut hasInitBlock = false;
   let mut hasStaticMember = false;
   let mut classScope = self.scope;

   fn processLet( token:&Parser.Token, staticFlag:bool,
                  accessMode:Ast.AccessMode, alreadyFlag:bool ) __trans
   {
      if staticFlag {
         hasStaticMember = true;
      }
      if mode == .Interface {
         self.addErrMess( token.pos, "interface can not have member" );
      }
      if not staticFlag and alreadyFlag {
         self.addErrMess(
            token.pos, "member can't declare after '__init' method." );
      }
      elseif staticFlag and hasInitBlock {
         self.addErrMess(
            token.pos, "static member can't declare after '__init' block." );
      }
      let memberNode = self.analyzeDeclMember(
         classTypeInfo, accessMode, staticFlag, token );
      allStmtList.insert( memberNode );
      fieldList.insert( memberNode );
      memberList.insert( memberNode );
      memberName2Node[ memberNode.$name.txt ] = memberNode;
      self.addAccessor( memberNode, methodNameSet, classScope, classTypeInfo );
   }

   /**
memberName2Node のメンバに値がセットされたかどうかを調べる。

@param staticFlag true の場合、 static メンバを調べる。
@param pos セットされていなかった場合のエラー表示位置。
nil の場合、メンバの宣言位置。
   */
   fn checkInitializeMember( staticFlag:bool, pos:&Parser.Position! ) __trans {
      foreach memberNode, memberName in memberName2Node {
         if memberNode.$staticFlag == staticFlag {
            let symbolInfo = unwrap self.scope.getSymbolInfoChild( memberName );
            let typeInfo = symbolInfo.$typeInfo;
            if not symbolInfo.$hasValueFlag {
               let msg;
               if staticFlag {
                  msg = "Set member -- %s" ( memberName );
               }
               else {
                  msg = "Set member -- %s.%s" ( name.txt, memberName );
               }
               if not typeInfo.$nilable {
                  self.addErrMess( unwrap pos default memberNode.$pos, msg );
               }
               else {
                  uninitMemberList.insert( symbolInfo );
                  // nilable は、ここで初期化済みとする。
                  self.addWarnMess( unwrap pos default memberNode.$pos, msg );
               }
            }
         }
      }
   }

   fn processFn( token:&Parser.Token, staticFlag:bool, accessMode:Ast.AccessMode,
                 abstractFlag:bool, overrideFlag:bool ) __trans
   {
      let nameToken = self.getSymbolToken( .MustNot_ );
      let mut declFuncMode = DeclFuncMode.Class;
      if mode == .Module or mode == .LazyModule {
         if gluePrefix {
            declFuncMode = .Glue;
         }
         else {
            declFuncMode = .Module;
         }
      }

      if nameToken.txt == "__init" {
         foreach symbolInfo in self.scope.$symbol2SymbolInfoMap {
            if not symbolInfo.$staticFlag {
               // 一旦全てのメンバを値なし状態にセットする
               symbolInfo.clearValue();
            }
         }
      }
      
      let methodNode = self.analyzeDeclMethod(
         classTypeInfo, declFuncMode, abstractFlag, overrideFlag,
         accessMode, staticFlag, token, nameToken );
      allStmtList.insert( methodNode );
      fieldList.insert( methodNode );
      methodNameSet.add( nameToken.txt );
      if nameToken.txt == "__init" {
         alreadyCtorFlag = true;

         checkInitializeMember( false, methodNode.$pos );
      }
   }

   fn processInitBlock( token:&Parser.Token ) __trans {

      if classTypeInfo.$scope$.$parent ~= self.moduleScope {
         // top level クラスでないと、
         // static なメンバのライフタイム制御が難しいので現状はエラーとする。
         self.addErrMess(
            token.pos, "The '__init' block only support at the top level classes." );
      }
      
      if mode ~= .Class {
         self.error( "%s can not have __init block." (mode) );
      }
      hasInitBlock = true;
      foreach symbolInfo in self.scope.$symbol2SymbolInfoMap {
         if symbolInfo.$staticFlag {
            // 一旦全てのメンバを値なし状態にセットする
            symbolInfo.clearValue();
         }
      }

      let mut parentScope = self.scope;
      let mut initBlockScope = self.pushScope( false## );
      self.prepareTentativeSymbol( initBlockScope, false, nil );

      let ininame = "___init";
      let mut funcTypeInfo = self.processInfo.createFuncAsync(
         false, false, initBlockScope, .Func, classTypeInfo,
         false, false, true, .Pri, ininame, .Noasync, nil, nil, nil, false );
      let funcSym, shadowing = parentScope.addFunc(
         self.processInfo, token.$pos, funcTypeInfo, .Pri, true, true );

      self.newNSInfo( funcTypeInfo, token.pos );
      
      
      let block = self.analyzeFuncBlock(
         .InitBlock, token, classTypeInfo, funcTypeInfo, ininame, initBlockScope,
         funcTypeInfo.$retTypeInfoList );

      let mut info = new Nodes.DeclFuncInfo(
         .InitBlock, classTypeInfo, node, token, unwrap (funcSym or shadowing),
         [], true, .Pri, nil, block, [], [], false, false );
      let initBlockNode = Nodes.DeclMethodNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ funcTypeInfo ], info );
      initBlockInfo.set_func( initBlockNode );
      allStmtList.insert( initBlockNode );

      self.popScope();
      self.finishTentativeSymbol( false );
   }

   fn processAdvertise() __trans {
      let memberToken = self.getSymbolToken( .MustNot_ );
      nextToken = self.getToken(##);
      let mut prefix = "";
      if nextToken.txt ~= ";" and nextToken.txt ~= "{" {
         prefix = nextToken.txt;
         nextToken = self.getToken(##);
      }
      self.checkToken( nextToken, ";" );
      let! memberNode = memberName2Node[ memberToken.txt ] {
         self.error( "not found member -- %s" (memberToken.txt) );
      };
      let mut advInfo = new Nodes.AdvertiseInfo( memberNode, prefix, memberToken.pos );
      advertiseList.insert( advInfo );
      allStmtList.insert(
         Nodes.DeclAdvertiseNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], advInfo ) );
      
      self.advertisedTypeSet.add(
         memberNode.$expType.$srcTypeInfo.$genSrcTypeInfo );
   }

   fn processEnum( token:&Parser.Token, accessMode:Ast.AccessMode ) __trans {
      if accessMode ~= .Pri and
          ( classAccessMode == .Pri or classAccessMode == .Local )
      {
         self.addErrMess( token.pos,
                          "unmatch access mode, class('%s') and enum('%s')"
                          (classAccessMode.$_txt, accessMode.$_txt ) );
      }
      let enumNode = self.analyzeDeclEnum( accessMode, token );
      allStmtList.insert( enumNode );
      declStmtList.insert( enumNode );
      
   }

   fn processLuneControl() __trans {
      nextToken = self.getToken(##);

      let pragma;
      switch nextToken.txt {
         case "default__init" {
            pragma = LuneControl.Pragma.default__init;

            alreadyCtorFlag = true;
            
            self.addDefaultConstructor(
               nextToken.pos, classTypeInfo,
               self.scope, memberList, methodNameSet, false );
         }
         case "default__init_old" {
            pragma = LuneControl.Pragma.default__init_old;

            alreadyCtorFlag = true;
            self.addDefaultConstructor(
               nextToken.pos, classTypeInfo,
               self.scope, memberList, methodNameSet, true );
            node.setHasOldCtor();
         }
         case "default_async_this_class" {
            pragma = LuneControl.Pragma.default_async_this_class;
            self.class2defaultAsyncMode[ self.getCurrentNamespaceTypeInfo() ] = .AsyncAll;
         }
         case "default_noasync_this_class" {
            pragma = LuneControl.Pragma.default_noasync_this_class;
            self.class2defaultAsyncMode[ self.getCurrentNamespaceTypeInfo() ] = .NoAsync;
         }
         default {
            self.error( "unknown option -- %s" (nextToken.txt) );
         }
      }
      self.checkNextToken( ";" );

      let ctrlNode = Nodes.LuneControlNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], pragma );
      self.helperInfo.pragmaSet.add( pragma );
      allStmtList.insert( ctrlNode );
   }

   fn processClassFields(inMacro:bool) {
      while true {
         let mut token = self.getToken( inMacro );
         if token.kind == .Eof or token.txt == "}" {
            break;
         }
         let! mut accessMode = Ast.txt2AccessMode( token.txt ) {
            accessMode = .Pri;
         }
         then {
            token = self.getToken(##);
         };
         if mode == .Interface and accessMode ~= .Pub {
            self.addErrMess( token.pos, "interface's fields must be 'pub'." );
         }

         let mut staticFlag = false;
         if token.txt == "static" {
            staticFlag = true;
            token = self.getToken(##);
         }
         let mut overrideFlag = false;
         if token.txt == "override" {
            overrideFlag = true;
            token = self.getToken(##);
         }
         let mut abstractFlag = false;
         if token.txt == "abstract" {
            abstractFlag = true;
            token = self.getToken(##);
         }
         elseif mode == .Interface {
            // 現状 interface にデフォルト処理を書けない。
            abstractFlag = true;
         }


         if token.txt == "let" {
            processLet( token, staticFlag, accessMode, alreadyCtorFlag );
         }
         elseif token.txt == "fn" {
            processFn( token, staticFlag, accessMode, abstractFlag, overrideFlag );
         }
         elseif token.txt == "__init" {
            processInitBlock( token );
         }
         elseif token.txt == "advertise" {
            processAdvertise();
         }
         elseif token.txt == ";" {
         }
         elseif token.txt == "enum" {
            processEnum( token, accessMode );
         }
         elseif token.txt == "_lune_control" {
            processLuneControl();
         }
         else {
            if! let symbolInfo = self.scope.getSymbolInfo(
               token.txt, self.scope, false, self.scopeAccess )
            {
               if symbolInfo.$kind == .Mac {

                  self.checkNextToken( "(" );

                  let mut alt2typeMap, argList = self.prepareExpCall(
                     token.pos, symbolInfo.$typeInfo, [], Ast.headTypeInfo );


                  self.evalMacroOp(
                     token, symbolInfo.$typeInfo, argList,
                     fn () {
                        processClassFields( true );
                     });

                  self.checkNextToken( ";" );
               }
               else {
                  self.error( "illegal field" );
               }
            }
            else {
               self.error( "illegal field" );
            }
         }
      }
   }

   processClassFields( false );

   switch mode {
      case .Module, .LazyModule {
      }
      default {
         if hasStaticMember and not hasInitBlock {
            self.addErrMess(
               node.$pos,
               "This class (%s) need __init block for initialize static members." ( name.txt ) );
         }

         checkInitializeMember( true, nil );
      }
   }

   return node, nextToken, methodNameSet;
}

fn TransUnit.analyzeDeclClass(
   classAbstructFlag: bool,  mut classAccessMode: Ast.AccessMode,
   firstToken: &Parser.Token, mut mode:DeclClassMode ) mut : Nodes.DeclClassNode
{
   if mode == .Module {
      if self.getToken(##).txt == "." {
         switch self.getToken(##).txt {
            case "l" {
               mode = .LazyModule;
            }
            case "d" {
               mode = .Module;
            }
         }
      } else {
         self.pushback();
         if self.ctrl_info.defaultLazy {
            mode = .LazyModule;
         }
      }
   }
   if mode == .LazyModule {
      self.helperInfo.useLazyRequire = true;
   }

   
   switch mode {
      case .Module, .LazyModule {
      }
      default {
         switch self.getCurrentNamespaceTypeInfo().$kind {
            case .IF, .Class, .Module {
            }
            case .Func, .Method {
               switch classAccessMode {
                  case .Pub, .Global {
                     self.addErrMess( firstToken.pos, "Class can't declare on here." );
                  }
               }
            }
            default {
               self.addErrMess( firstToken.pos, "Class can't declare on here." );
            }
         }
      }
   }

   let name = self.getSymbolToken( .MustNot_ );

   // generic の型宣言解析
   let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
   {
      let mut nextToken = self.getToken(##);
      if nextToken.txt == "<" {
         nextToken, altTypeList = self.analyzeDeclAlternateType(
            true, nextToken, classAccessMode );
      }
      self.pushbackToken( nextToken );

      if #altTypeList > 0 and mode ~= .Class {
         // インタフェースの generics を当面禁止する。
         // インタフェースの generics をサポートするには、
         // そのインタフェースを implements しているクラスのどの型情報が
         // 型パラメータに紐付くのかを処理する必要がある。
         self.addErrMess( name.pos, "Only class can use the generics. -- %s " (name.txt) );
      }
   }

   if classAccessMode == .Local {
      classAccessMode = .Pri;
   }

   let mut moduleName: &Parser.Token! = nil;
   let mut gluePrefix:str! = nil;
   let mut moduleLang:Types.Lang! = nil;
   if mode == .Module or mode == .LazyModule {
      self.checkNextToken( "require" );
      moduleName = self.getToken(##);
      let mut nextToken = self.getToken(##);
      if nextToken.txt == "of" {
         let langToken = self.getToken(##);
         if langToken.kind ~= .Str {
            self.error( "it's not a string -- %s" ( langToken.txt ) );
         }
         let langIdToken = langToken.getExcludedDelimitTxt();
         if langIdToken ~= "" {
            foreach langId in Types.Lang.$_allList {
               if! Types.Lang._from( langId ) {
                  let ldName = _exp.$_txt.gsub( ".*%.", "");
                  if ldName == langIdToken {
                     moduleLang = _exp;
                     break;
                  }
               }
            }
            if moduleLang == nil {
               self.errorAt(
                  langToken.pos, "invalid lang -- %s" (langToken.txt) );
            }
         } else {
            moduleLang = .Same;
         }
         
         nextToken = self.getToken(##);
      }
      if nextToken.txt == "glue" {
         gluePrefix = self.getToken(##).getExcludedDelimitTxt();
      }
      else {
         self.pushback();
      }
   }

   let existSymbolInfo = self.scope.getSymbolTypeInfo(
      name.txt, self.scope, self.scope, self.scopeAccess );

   let mut nextToken, mut nsInfo, inheritInfo = self.analyzePushClass(
      mode, classAbstructFlag, firstToken, name, true, moduleName,
      moduleLang or Types.Lang.Same, classAccessMode, altTypeList );
   let mut classTypeInfo = nsInfo.$typeInfo;

   let hasProto;
   if nsInfo.$nobody {
      nsInfo.set_nobody( false );
      hasProto = true;
   } else {
      hasProto = false;
      if existSymbolInfo {
         self.addErrMess( name.pos, "already declare symbol -- %s" (name.txt) );
      }
   }


   let mut classScope = self.scope;

   self.checkToken( nextToken, "{" );


   let mapType = self.processInfo.createMap(
      .Pub, classTypeInfo, Ast.builtinTypeString,
      self.createModifier( Ast.builtinTypeStem, .IMut ), .IMut );
   if classTypeInfo.isInheritFrom(
      self.processInfo, Ast.builtinTypeMapping, nil ) {
      self.helperInfo.hasMappingClassDef = true;

      if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo and
         not classTypeInfo.$baseTypeInfo.isInheritFrom(
            self.processInfo, Ast.builtinTypeMapping, nil ) {
         self.addErrMess(
            firstToken.pos,
            "must extend Mapping at %s" (classTypeInfo.$baseTypeInfo.getTxt(##) ) );
      }
      // _toMap の追加
      let toMapFuncTypeInfo = self.processInfo.createFuncAsync(
         false, false, nil, .Method, classTypeInfo,
         true, false, false, .Pub, "_toMap", .Async, nil, [], [ mapType ], false );
      classScope.addMethod(
         self.processInfo, nil, toMapFuncTypeInfo, .Pub, false, false );
   }


   let mut lazyLoad;
   _switch mode {
      case .LazyModule {
         lazyLoad = Nodes.LazyLoad.On;
      }
      case .Module, .Class, .Interface {
         lazyLoad = Nodes.LazyLoad.Off;
      }
   }

   let mut node, _, mut methodNameSet = self.analyzeClassBody(
      hasProto, classAccessMode, firstToken, mode, gluePrefix, classTypeInfo,
      name, moduleLang, moduleName, lazyLoad, nextToken, inheritInfo );
   //nextToken = workNextToken;


   // デフォルトコンストタクタ設定
   let mut ctorAccessMode = Ast.AccessMode.Pub;
   if! let ctorTypeInfo = classScope.getTypeInfoChild( "__init" ) {
      ctorAccessMode = ctorTypeInfo.$accessMode;
   }
   else {
      self.addDefaultConstructor(
         firstToken.pos, classTypeInfo,
         classScope, node.$memberList, methodNameSet, false );
   }


   // advertise の処理
   foreach advertiseInfo in node.$advertiseList {
      let mut memberType = advertiseInfo.$member.$expType;
      switch memberType.$kind {
         case .Class, .IF {
            foreach mtdName in Ast.getAllMethodName( memberType, .Object ).$list {
               let scope = unwrap memberType.$scope;
               let child = unwrap scope.getTypeInfoField( mtdName, true, scope, .Normal );
               if child.$accessMode ~= .Pri {
                  let childName = advertiseInfo.$prefix .. child.getTxt(##);
                  if not methodNameSet.has( childName ) {
                     let impMtdType = self.processInfo.createAdvertiseMethodFrom(
                        classTypeInfo, child );
                     classScope.addMethod(
                        self.processInfo, advertiseInfo.$pos, impMtdType,
                        child.$accessMode, child.$staticFlag, false );
                  }
               }
            }
         }
         default {
            self.error( "advertise member type is illegal -- %s"
                        (advertiseInfo.$member.$name) );
         }
      }
   }


   if classTypeInfo.isInheritFrom(
      self.processInfo, Ast.builtinTypeMapping, nil )
   {
      // Mapping の制限チェック
      let mut checkedTypeMap:Map<&Ast.TypeInfo,bool> = {};
      foreach memberNode in node.$memberList {
         let memberType = memberNode.$expType;
         if not Ast.NormalTypeInfo.isAvailableMapping(
            self.processInfo, memberType, checkedTypeMap )
         {
            self.addErrMess(
               memberNode.$pos,
               "member type is not Mapping -- %s" ( memberType.getTxt(##)) );
         } elseif memberType.$kind == .IF {
            self.addErrMess(
               memberNode.$pos,
               "Mapping class has not the interface type member. -- %s"
               (memberNode.$name.txt) );
         } elseif memberType.$abstractFlag {
            self.addErrMess(
               memberNode.$pos,
               "Mapping class has not the abstract class member. -- %s"
               (memberNode.$name.txt) );
         }
      }

      // _fromMap の追加
      let fromMapFuncTypeInfo = self.processInfo.createFuncAsync(
         false, false, nil, .Func, classTypeInfo,
         true, false, true, .Pub, "_fromMap", .Async,
         nil, [ mapType.$nilableTypeInfo ],
         [ classTypeInfo.$nilableTypeInfo, Ast.builtinTypeString.$nilableTypeInfo ],
         true );
      classScope.addMethod(
         self.processInfo, nil, fromMapFuncTypeInfo, ctorAccessMode, true, false );

      // _fromStem の追加
      let fromStemFuncTypeInfo = self.processInfo.createFuncAsync(
         false, false, nil, .Func, classTypeInfo,
         true, false, true, .Pub, "_fromStem", .Async,
         nil, [ Ast.builtinTypeStem_ ],
         [ classTypeInfo.$nilableTypeInfo, Ast.builtinTypeString.$nilableTypeInfo ],
         true );
      classScope.addMethod(
         self.processInfo, nil, fromStemFuncTypeInfo, ctorAccessMode, true, false );
   }

   if classTypeInfo.isInheritFrom(
      self.processInfo, Ast.builtinTypeAsyncItem, nil )
   {
      if not classTypeInfo.isInheritFrom(
         self.processInfo, Ast.builtinTypeMapping, nil )
      {
         self.addErrMess(
            firstToken.pos, "__AsyncItem implemented class must inherit Mapping." );
      }

      //
      let pipeType = self.processInfo.createGeneric(
         self.builtinFunc.__pipe_, [classTypeInfo], self.moduleType );
      let createPipeFuncTypeInfo = self.processInfo.createFuncAsync(
         false, false, nil, .Func, classTypeInfo,
         true, false, true, .Pub, "_createPipe", .Async, 
         nil, [ Ast.builtinTypeInt ], [ pipeType.$nilableTypeInfo ], true );
      classScope.addMethod(
         self.processInfo, nil, createPipeFuncTypeInfo, .Pub, true, false );
   }

   self.popClass();

   return node;
}



pri fn TransUnit.addMethod(
   classTypeInfo: &Ast.TypeInfo, methodNode: Nodes.Node, name: str ) mut
{
   let mut classNodeInfo = unwrap self.typeInfo2ClassNode[ classTypeInfo ];

   classNodeInfo.$outerMethodSet.add( name );
   classNodeInfo.$fieldList.insert( methodNode );
}

fn TransUnit.processAddFunc(
   isFunc:bool, mut parentScope:Ast.Scope,
   name:&Parser.Token, mut typeInfo:Ast.TypeInfo,
   alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo> ) mut
: &Ast.SymbolInfo, TransUnitIF.NSInfo
{
   let accessMode = typeInfo.$accessMode;
   if accessMode == .Global {
      //parentScope = Ast.rootScope;
      parentScope = self.globalScope;
   }

   let hasPrototype;
   let mut nsInfo;
   if! let prottype = parentScope.getTypeInfoChild( typeInfo.$rawTxt ) {
      let argTypeList = typeInfo.$argTypeInfoList;
      let retTypeInfoList = typeInfo.$retTypeInfoList;
      let mut matched = true;
      {
         let matchFlag, err = Ast.TypeInfo.checkMatchType(
            self.processInfo,
            prottype.$argTypeInfoList, argTypeList, false, nil, alt2typeMap );
         if matchFlag ~= .Match {
            self.addErrMess( name.pos, "mismatch functype param: " .. err );
            matched = false;
         }
      }
      {
         let matchFlag, err = Ast.TypeInfo.checkMatchType(
            self.processInfo,
            prottype.$retTypeInfoList, retTypeInfoList, false, nil, alt2typeMap );
         if matchFlag ~= .Match {
            self.addErrMess( name.pos, "mismatch functype ret: " .. err );
            matched = false;
         }
      }
      {
         let matchFlag, err = typeInfo.canEvalWith(
            self.processInfo, prottype, .SetOp, alt2typeMap );
         if not matchFlag {
            if err {
               self.addErrMess( name.pos, "mismatch functype -- %s" (err ) );
            } else {
               self.addErrMess(
                  name.pos, "mismatch functype -- %s / %s"
                  ( typeInfo.$display_stirng, prottype.$display_stirng ) );
            }
            matched = false;
         }
      }
      {
         if prottype.$asyncMode ~= typeInfo.$asyncMode {
            self.addErrMess(
               name.pos,
               "mismatch async -- %s / %s"
               (prottype.$asyncMode.$_txt, typeInfo.$asyncMode.$_txt) );
            matched = false;
         }
      }
      
      if! let mut workNsInfo = self.nsInfoMap[ prottype ] {
         nsInfo = workNsInfo;
         if nsInfo.$nobody {
            hasPrototype = true;
            nsInfo.set_nobody( false );
         } else {
            hasPrototype = false;
         }
      } else {
         hasPrototype = false;
         nsInfo = self.newNSInfo( typeInfo, name.pos );
      }
      if matched {
         (unwrap nsInfo.$typeInfo@@@Ast.NormalTypeInfo).switchScopeTo( unwrap typeInfo.$scope );
         typeInfo = nsInfo.$typeInfo;
      }
      if not hasPrototype {
         if not prottype.$autoFlag {
            self.addErrMess( name.pos, "multiple define -- %s" (name.txt) );
         }
      }
   }
   else {
      hasPrototype = false;
      nsInfo = self.newNSInfo( typeInfo, name.pos );
   }

   if typeInfo.$kind == .Method and typeInfo.$accessMode ~= .Pri {
      let classType = typeInfo.$parentInfo;
      if self.advertisedTypeSet.has( classType ) and not hasPrototype {
         self.addErrMess(
            name.pos,
            "This class(%s) is used by advertise. You must declare the prototype of this method."
            (classType.getTxt( ## )) );
      }
   }
   

   let staticFlag = typeInfo.$staticFlag;
   let mutable = Ast.TypeInfo.isMut( typeInfo );

   let funcSym, shadowing;
   if isFunc {
      funcSym, shadowing = parentScope.addFunc(
         self.processInfo, name.pos, typeInfo, accessMode, staticFlag, mutable );
      self.errorShadowing( name.pos, shadowing );
   } else {
      funcSym, shadowing = parentScope.addMethod(
         self.processInfo, name.pos, typeInfo, accessMode, staticFlag, mutable );
   }
   return unwrap (funcSym or shadowing), nsInfo;
}


let CantOverrideMethods = (@ "__init", "__free" );

/**
関数定義の解析。

@parm asyncLocked __asyncLock で指定された関数であることを示す。
*/
fn TransUnit.analyzeDeclFunc(
   declFuncMode: DeclFuncMode, asyncLocked: bool,
   abstractFlag: bool, overrideFlag: bool, mut accessMode: Ast.AccessMode,
   mut staticFlag: bool, mut classTypeInfo: &Ast.TypeInfo!,
   firstToken: &Parser.Token, mut name: &Parser.Token! ) mut : Nodes.Node
{
   let mut token = self.getToken(##);
   if! name {
      if _exp.txt ~= "__main" {
         name = self.checkSymbol( _exp, .MustNot_ );
      }
      if declFuncMode == .Func and _exp.txt == "main" {
         self.addWarnMess( _exp.pos, "LuneScript's main function is __main." );
      }
   }
   else {
      if token.txt ~= "(" {
         if token.txt ~= "__main" {
            name = self.checkSymbol( token, .MustNot_ );
         } else {
            name = token;
         }
         token = self.getToken(##);
      }
   }
   if not name and ( Ast.isPubToExternal( accessMode ) or
                     abstractFlag or overrideFlag or staticFlag )
   {
      // anonymous 関数で pub 等が指定されているのはエラー
      self.addErrMess( firstToken.pos, "The anonymous function must be local." );
   }
   let mut needPopFlag = false;
   if token.txt == "." {
      needPopFlag = true;

      when! name {
         let className = name.txt;

         classTypeInfo = self.scope.getTypeInfoChild( className );

         when! classTypeInfo {
            // self.pushClass(
            //    name.pos, classTypeInfo.$kind == .Class,
            //    classTypeInfo.$abstractFlag, nil, nil, nil, false, className,
            //    classTypeInfo.$accessMode ## );
            self.pushClassScope( name.pos, classTypeInfo,
                                 unwrap self.namespace2Scope[ classTypeInfo ] );       
         }
         else {
            self.error( "not found class -- %s" (className) );
         }
      }
      else {
         self.error( "can't use '.' for any function name" );
      }

      name = self.getSymbolToken( .MustNot_ );
      token = self.getToken(##);

      // if accessMode == .Local {
      //    accessMode = .Pri;
      // }
   }


   let mut isCtorFlag = false;
   let mut kind = Nodes.NodeKind.$DeclConstr;
   let mut typeKind = Ast.TypeInfoKind.Func;
   when! classTypeInfo {
      if not staticFlag {
         typeKind = .Method;
      }
      switch (unwrap name).txt {
         case "__init" {
            isCtorFlag = true;
            kind = Nodes.NodeKind.$DeclConstr;
            foreach symbolInfo in self.scope.$symbol2SymbolInfoMap {
               if not symbolInfo.$staticFlag {
                  // 一旦全てのメンバを値なし状態にセットする
                  symbolInfo.clearValue();
               }
            }
         }
         case "__free" {
            kind = Nodes.NodeKind.$DeclDestr;
            if not self.targetLuaVer.$canUseMetaGc {
               self.addErrMess(
                  firstToken.pos, "this lua version is not support __free." );
            }
         }
         default {
            kind = Nodes.NodeKind.$DeclMethod;
         }
      }
   }
   else {
      kind = Nodes.NodeKind.$DeclFunc;
      if not staticFlag {
         staticFlag = true;
      }
   }

   let orgStaticFlag = staticFlag;
   if declFuncMode == .Module {
      // module で Lua の外部モジュールを宣言した場合、
      // モジュール名でメンバにアクセスできるように、
      // 強制的に static にする。
      staticFlag = true;
   }

   let mut parentScope = self.scope;
   let mut funcBodyScope = self.pushScope( false ## );

   if staticFlag and classTypeInfo {
      self.analyzingStaticMethodArgsScope = funcBodyScope;
   }

   
   let mut altTypeList:&List<&Ast.TypeInfo> = [];
   // generic 宣言
   if token.txt == "<" {
      token, altTypeList = self.analyzeDeclAlternateType( false, token, accessMode );
      foreach altType in altTypeList {
         funcBodyScope.addAlternate(
            self.processInfo, accessMode, altType.$rawTxt, firstToken.pos, altType );
      }

   }

   self.checkToken( token, "(" );


   let parentPub;
   when! classTypeInfo {
      parentPub = Ast.isPubToExternal( classTypeInfo.$accessMode );
   }
   else {
      parentPub = Ast.isPubToExternal( accessMode );
   }
   
   let mut argList:List<&Nodes.Node> = [];
   token = self.analyzeDeclArgList( accessMode, funcBodyScope, argList, parentPub );

   self.checkToken( token, ")" );
   token = self.getToken(##);

   let mut mutable;
   let asyncMode;

   token, mutable, asyncMode = self.getMutableAsync( token );

   let mut pubToExtFlag = Ast.isPubToExternal( accessMode );

   let mut argTypeList:List<&Ast.TypeInfo> = [];
   foreach argNode in argList {
      argTypeList.insert( argNode.$expType );
   }


   let mut alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
   when! classTypeInfo {
      alt2typeMap = classTypeInfo.createAlt2typeMap( false );

      if kind == Nodes.NodeKind.$DeclMethod or
         kind == Nodes.NodeKind.$DeclConstr or
         kind == Nodes.NodeKind.$DeclDestr
      {
         let mut workClass = classTypeInfo;
         if kind == Nodes.NodeKind.$DeclConstr or kind == Nodes.NodeKind.$DeclDestr {
            mutable = true;
         }
         // self シンボルを登録

         if not Ast.isPubToExternal( workClass.$accessMode ) {
            pubToExtFlag = false;
         }


         if Ast.TypeInfo.isMut( workClass ) and not mutable {
            workClass = self.createModifier( workClass, .IMut );
         }
         if not staticFlag {
            self.scope.add(
               self.processInfo, .Arg, false, true, "self", nil,
               workClass, .Pri, false,
               mutable and Ast.MutMode.Mut or Ast.MutMode.IMut, true, false );
         }

         if not workClass.$abstractFlag and abstractFlag {
            self.addErrMess( firstToken.pos,
                             "no abstract class does not have abstract method" );
         }
      }

      if classTypeInfo.isInheritFrom(
         self.processInfo, Ast.builtinTypeRunner ## )
      {
         foreach argNode, index in argList {
            if not Ast.TypeInfo.canBeAsyncParam( argNode.$expType ) {
               self.addErrMess(
                  argNode.$pos,
                  "__Runner can't have the mutable argument. -- %d: %s"
                  (index, argNode.$expType.getTxt(##) ) );
            }
         }
      }
   }


   let retTypeInfoList;
   let retTypeNodeList;
   retTypeInfoList, token, retTypeNodeList = self.analyzeRetTypeList(
      pubToExtFlag, accessMode, token, parentPub );

   let mut namespaceInfo = self.getCurrentNamespaceTypeInfoMut();

   let mut funcName = "";
   when! name {
      funcName = name.txt;

      if kind == Nodes.NodeKind.$DeclFunc {
         switch accessMode {
            case .Pub, .Global {
               if parentScope ~= self.moduleScope {
                  self.addErrMess(
                     firstToken.pos,
                     "'global' or 'pub' function must exist top scope." );
               }
            }
         }
      }
   }

   let typeInfo:Ast.TypeInfo;
   let funcSym:&Ast.SymbolInfo!;
   let mut nsInfo;
   {
      let mut workTypeInfo = self.processInfo.createFuncAsync(
         abstractFlag, false, funcBodyScope,
         typeKind, namespaceInfo, false, false, staticFlag, accessMode,
         funcName,
         self.getDefaultAsync(
            typeKind, classTypeInfo or self.getCurrentClass(), asyncMode ),
         altTypeList, argTypeList, retTypeInfoList, mutable );

      when! name {
         let workSym;
         workSym, nsInfo = self.processAddFunc(
            kind == Nodes.NodeKind.$DeclFunc,
            funcBodyScope.$parent, name, workTypeInfo, alt2typeMap );
         typeInfo = nsInfo.$typeInfo;
         funcSym = workSym;

         if name.txt == "__main" {
            if #typeInfo.$argTypeInfoList ~= 1 or
               typeInfo.$argTypeInfoList[1].$kind ~= .List or
               typeInfo.$argTypeInfoList[1].$itemTypeInfoList[1] ~=
               Ast.builtinTypeString or
               #typeInfo.$retTypeInfoList ~= 1 or
               typeInfo.$retTypeInfoList[1] ~= Ast.builtinTypeInt
            {
               let mess = "'__main' function's type has to be __main( argList:List<str> ) : int -- %s" (typeInfo.$display_stirng );
               self.addErrMess( name.pos, mess );
            }
         }
      } else {
         typeInfo = workTypeInfo;
         funcSym = nil;
         nsInfo = self.newNSInfo( typeInfo, firstToken.pos );
      }
      self.namespace2Scope[ typeInfo ] = funcBodyScope;
   }
   if asyncLocked {
      nsInfo.incLock();
   }

   if overrideFlag {
      // オーバーライドの型チェック

      if not name {
         self.addErrMess( firstToken.pos, "can't override anonymous func" );
      };
      if CantOverrideMethods.has( funcName ) {
         self.addErrMess( firstToken.pos, "This method can't override -- %s" (funcName) );
      }
      if! let overrideType = self.scope.$parent.getTypeInfoField(
         funcName, false, funcBodyScope, self.scopeAccess )
      {
         foreach err in self.checkOverrideMethod( overrideType, typeInfo ) {
            self.addErrMess( firstToken.pos, err );
         }
      }
      else {
         //Ast.dumpScope( self.scope.$parent, "" );
         self.addErrMess( firstToken.pos, "not found override -- " .. funcName );
      }
   }
   else {
      when! name {
         if not CantOverrideMethods.has( name.txt ) {
            if self.scope.$parent.getTypeInfoField(
               name.txt, false, funcBodyScope, .Full )
            {
               // override 宣言していないのに、オーバーライドしている場合エラー
               self.addErrMess( firstToken.pos,
                                "mismatch override --" .. funcName );
            } else {
               if! let ifFunc =
                  self.scope.$parent.getSymbolInfoIfField(
                     name.txt, funcBodyScope, .Full )
               {
                  if not ifFunc.$typeInfo.canEvalWith(
                     self.processInfo, typeInfo, .SetEq, alt2typeMap )
                  {
                     self.addErrMess( firstToken.pos,
                                      "mismatch method type -- %s" (funcName));
                  }
               }
            }
         }
      }
   }

   let mut node = self.createNoneNode( firstToken.pos );
   //let mut needNode = false;

   // 関数 Body の解析
   let mut body:Nodes.BlockNode! = nil;
   if token.txt == ";" {
      // プロトタイプ宣言
      if declFuncMode == .Module or declFuncMode == .Glue {
         //needNode = true;
      }
      else {
         if not abstractFlag {
            nsInfo.set_nobody( true );
         }
         if classTypeInfo$.$kind == .IF {
            //needNode = true;
         }
         else {
            if kind == Nodes.NodeKind.$DeclMethod {
               kind = Nodes.NodeKind.$ProtoMethod;
            }
         }
      }
   }
   else {
      //needNode = true;

      if abstractFlag {
         self.addErrMess( token.pos, "abstract method can't have body." );
      }

      self.pushback();

      let analyzingState:AnalyzingState;
      if isCtorFlag {
         analyzingState = .Constructor;
      }
      elseif staticFlag and classTypeInfo {
         analyzingState = .ClassMethod;
      }
      else {
         analyzingState = .Func;
      }

      funcBodyScope.addLocalVar(
         self.processInfo, 
         false, false, "__func__", firstToken.pos, Ast.builtinTypeString, .IMut );
      
      let mut workBody = self.analyzeFuncBlock(
         analyzingState, firstToken, classTypeInfo, typeInfo,
         funcName, funcBodyScope, typeInfo.$retTypeInfoList );
      body = workBody;
      if #funcBodyScope.$closureSymList > 0 {
         funcBodyScope.set_hasClosureAccess( true );
      }

      if isCtorFlag {
         when! classTypeInfo {
            if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
               // Super クラスを持っている場合、
               // 先頭の処理で super() をコールしているか調べる
               let mut needCall = true;
               foreach stmt in workBody.$stmtList {
                  switch stmt.$kind {
                     case Nodes.nodeKindEnum.ExpCallSuperCtor {
                        needCall = false;
                     }
                     case Nodes.nodeKindEnum.BlankLine {
                     }
                     default {
                        break;
                     }
                  }
               }
               if needCall {
                  self.addErrMess(
                     workBody.$pos,             
                     "__init must call super() with first." );
               }
            }
         }
      }
   }

   if staticFlag and classTypeInfo {
      self.analyzingStaticMethodArgsScope = nil;
   }
   

   fn createDeclFuncInfo( funcKind:Nodes.FuncKind ) __trans : &Nodes.DeclFuncInfo {
      let classDeclNode:Nodes.DeclClassNode!;
      when! classTypeInfo {
         classDeclNode = self.typeInfo2ClassNode[ classTypeInfo ];
      }
      else {
         classDeclNode = nil;
      }
      
      return new Nodes.DeclFuncInfo(
         funcKind, classTypeInfo, classDeclNode, name, funcSym,
         argList, orgStaticFlag, accessMode, asyncMode, body,
         retTypeInfoList, retTypeNodeList,
         self.has__func__Symbol.has( typeInfo ), overrideFlag );
   }

   switch ( kind ) {
      case Nodes.NodeKind.$DeclConstr {
         if classTypeInfo$.isInheritFrom$( self.processInfo, Ast.builtinTypeRunner ## )
         {
            // runner のコンストラクタから、
            // noasync で競合データを取得してメンバにセットされると
            // 競合のガードが破綻するので、
            // コンストラクタの __async をチェックする。
            if typeInfo.$asyncMode ~= .Async {
               let message =
                  "The constructor of the class extended __Runner must be __async. -- %s"
                   (typeInfo.$parentInfo.getTxt(##) );
               self.addErrMess( firstToken.pos, message );
            }
         }
         
         
         let info = createDeclFuncInfo( .Ctor );
         node = Nodes.DeclConstrNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$DeclDestr {
         let info = createDeclFuncInfo( .Dstr );
         node = Nodes.DeclDestrNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$DeclMethod {
         let info = createDeclFuncInfo( .Mtd );
         node = Nodes.DeclMethodNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$ProtoMethod {
         let info = createDeclFuncInfo( .Mtd );
         node = Nodes.ProtoMethodNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$DeclFunc {
         let info = createDeclFuncInfo( .Func );
         node = Nodes.DeclFuncNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      default {
         self.error( "illegal kind -- %d" (kind) );
      }
   }
   self.has__func__Symbol.del( typeInfo );

   self.popScope();

   if needPopFlag {
      self.addMethod( unwrap classTypeInfo, node, funcName );
      self.popClass();
   }

   return node;
}

fn TransUnit.createExpListNode(
   orgExpList:&Nodes.ExpListNode, newExpList:&List<&Nodes.Node> ) mut: Nodes.ExpListNode
{
   // 引数リストを更新する
   let mut newExpTypeList:List<&Ast.TypeInfo> = [];
   foreach expNode in newExpList {
      newExpTypeList.insert( expNode.$expType );
   }
   if #newExpList[ #newExpList ].$expTypeList > 1 {
      self.addErrMess( orgExpList.$pos, "illegal exp -- %d"
                       (#newExpList[ #newExpList ].$expTypeList) );
   }
   if! let mRetIndex = orgExpList.$mRetExp$.$index {
      if mRetIndex > #newExpList {
         self.addErrMess( orgExpList.$pos, "over index -- %d" (mRetIndex) );
      }
      // implicit cast 等で expTypeList が変更されるので、チェックしない。
      // elseif #newExpList[mRetIndex].$expTypeList == 1 {
      //    self.addErrMess( orgExpList.$pos, "unmatch mRetIndex -- %d" (mRetIndex) );
      // }
   }
   return Nodes.ExpListNode.create(
      self.nodeManager, orgExpList.$pos,
      self.macroCtrl.isInAnalyzeArgMode(), newExpTypeList, newExpList,
      orgExpList.$mRetExp, orgExpList.$followOn );
}


fn TransUnit.checkLiteralEmptyCollection(
   pos:&Parser.Position, symbolName:str, expType:&Ast.TypeInfo ) mut
{
   foreach itemType in expType.$itemTypeInfoList {
      if itemType == Ast.builtinTypeNone {
         // [] や {} を型推論はできない。
         self.addErrMess(
            pos,
            "must set the item type of Collection. -- %s:%s"
            (symbolName, expType.$srcTypeInfo.getTxt( self.typeNameCtrl## ) ) );
         break;
      }
   }
}

fn TransUnit.accessSymbol( symbolInfo:&Ast.SymbolInfo, canLeftExp:bool ) mut {
   if symbolInfo.$kind == .Fun {
      self.scope.accessSymbol( self.moduleScope, symbolInfo );
      symbolInfo.set_posForModToRef( symbolInfo.$posForLatestMod );

      
      if self.scope.isClosureAccess( self.moduleScope, symbolInfo ) {
         // 関数の場合、AST 解析中の時点ではクロージャ処理が必要かどうかが
         // 判定できないので、リストに保持して AST 解析後に別途処理する。
         self.closureFunList.insert( new ClosureFun( symbolInfo, self.scope ) );
      }

      
      // クロージャの変数をアクセスありにする
      if! let scope = symbolInfo.$typeInfo.$scope {
         scope.updateClosureRefPos();        
      }
   }
   else {
      self.scope.accessSymbol( self.moduleScope, symbolInfo );
      if canLeftExp {
         self.accessSymbolSetQueue.add( symbolInfo );
      } else {
         symbolInfo.set_posForModToRef( symbolInfo.$posForLatestMod );
      }
   }
}


class LetVarInfo {
   pub let mutable:Ast.MutMode;
   pub let varName: &Parser.Token;
   pub let varType:&Nodes.RefTypeNode!;
}


fn TransUnit.analyzeInitExp(
   firstPos:&Parser.Position, accessMode:Ast.AccessMode, unwrapFlag:bool,
   letVarList:List<&LetVarInfo>, typeInfoList : List<&Ast.TypeInfo> ) mut :
   List<&Ast.TypeInfo>, &List<&LetVarInfo>, &List<&Ast.TypeInfo>, Nodes.ExpListNode!
{
   // 初期値の式を取得
   let mut expList:Nodes.ExpListNode! = nil;
   let mut expectTypeList:List<&Ast.TypeInfo> = [];
   foreach varInfo in letVarList {
      expectTypeList.insert(
         unwrap varInfo.varType$.$expType default Ast.builtinTypeNone );
   }
   
   expList = self.analyzeExpList( false, false, false, nil, expectTypeList ## );
   if not expList {
      self.error( "expList is nil" );
   }
   

   // unwrap 前の型
   let mut orgExpTypeList: List<&Ast.TypeInfo> = [];

   // 型推論の解決と、宣言されている型と初期値との整合性を確認
   when! expList {

      if unwrapFlag {
         // unwrapFlag 値の中に nilable があるかどうか確認する。
         let mut hasNilable = false;
         foreach _, index in letVarList {
            if expList.getExpTypeAt( index ).$nilable {
               hasNilable = true;
               break;
            }
         }
         if not hasNilable {
            self.addWarnMess( firstPos, "has no nilable" );
         }
      }
      
      let mut workList = expList;
      let mut updateExpList = false;
      let mut newExpList:List<&Nodes.Node> = [];
      foreach exp, index in workList.$expList {
         newExpList.insert( exp ) ;
         if not exp.canBeRight( self.processInfo ) {
            self.addErrMess( exp.$pos,
                             "this node(%d) can not be r-value. -- %s"
                             (index, Nodes.getNodeKindName( exp.$kind ) ) );
         }
      }

      //  初期化値の型を反映する
      let mut expTypeList: List<&Ast.TypeInfo> = [];
      foreach expType, index in workList.$expTypeList {
         if index == #workList.$expTypeList and expType.$kind == .DDD
         {
            // 最終要素が ... の場合、残りの変数宣言の分 stem をセットする
            let mut dddItemType = Ast.builtinTypeStem_;
            if #expType.$itemTypeInfoList > 0 {
               dddItemType = expType.$itemTypeInfoList[ 1 ].$nilableTypeInfo;
            }
            for subIndex = index, #letVarList {
               let argType = typeInfoList[ subIndex ];
               let mut checkType = dddItemType;
               if unwrapFlag {
                  checkType = dddItemType.$nonnilableType;
               }
               if not argType.equals( self.processInfo, Ast.builtinTypeEmpty ## ) and
                  not argType.canEvalWith(
                     self.processInfo, checkType, .SetOp, {} )
               {
                  self.addErrMess(
                     firstPos,
                     "unmatch value type (index = %d) %s <- %s"
                     ( subIndex, argType.getTxt( self.typeNameCtrl## ),
                       dddItemType.getTxt(##) ));
               }
               expTypeList.insert( checkType );
               orgExpTypeList.insert( dddItemType );
            }
         }
         else {
            // 最終要素でない場合
            let mut expTypeInfo: &Ast.TypeInfo = expType;
            if expType.$kind == .DDD {
               let itemList = expType.$itemTypeInfoList;
               if #itemList > 0 {
                  expTypeInfo = itemList[ 1 ];
               }
               else {
                  expTypeInfo = Ast.builtinTypeStem_;
               }
            }
            orgExpTypeList.insert( expTypeInfo );
            if expTypeInfo == Ast.builtinTypeNil and index <= #typeInfoList {
               // 初期値が nil の場合、 orgExpTypeList は代入先の nilable 型とする
               orgExpTypeList[ index ] = typeInfoList[ index ].$nilableTypeInfo;
            }
            if unwrapFlag and expTypeInfo.$nilable {
               expTypeInfo = expTypeInfo.$nonnilableType;
            }

            if index <= #typeInfoList {
               let varType = typeInfoList[ index ];
               let mut alt2typeMap =
               Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap(false);
               if varType.$kind == .Box {
                  alt2typeMap = varType.createAlt2typeMap( true );
               }
               Ast.CanEvalCtrlTypeInfo.setupNeedAutoBoxing(
                  alt2typeMap, self.processInfo );   

               if not varType.equals( self.processInfo, Ast.builtinTypeEmpty ## ) and
                  not (unwrapFlag and
                        expTypeInfo.equals( self.processInfo, Ast.builtinTypeNil ## ))
               {
                  let canEval, mess = varType.canEvalWith(
                     self.processInfo, expTypeInfo, .SetOp, alt2typeMap );
                  if not canEval {
                     self.addErrMess(
                        firstPos,
                        "unmatch value type (index:%d) %s <- %s%s"
                        ( index,
                          varType.getTxt( self.typeNameCtrl ## ),
                          expTypeInfo.getTxt( self.typeNameCtrl ## ),
                          mess and " -- %s" ( mess ) or "" ) );
                  }
               }
               if varType.$kind == .Box {
                  typeInfoList[ index ] = self.processInfo.createBox(
                     accessMode, expTypeInfo );
               }
               //if varType.$kind == .Box and expTypeInfo.$srcTypeInfo.$kind ~= .Box {
               if Ast.CanEvalCtrlTypeInfo.canAutoBoxing( varType, expTypeInfo ) {
                  // auto boxing
                  updateExpList = true;
                  let exp = newExpList[ index ];
                  newExpList[ index ] = Nodes.BoxingNode.create(
                     self.nodeManager, exp.$pos,
                     self.macroCtrl.isInAnalyzeArgMode(), [ varType ], exp );
                  if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 1 ) {
                     self.addErrMess( exp.$pos,
                                      "auto boxing error %s <- %s"
                                      ( varType.getTxt(##), expTypeInfo.getTxt(##)) );
                  }
               }
               else {
                  if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 0 ) {
                     self.addErrMess(
                        newExpList[ index ].$pos,
                        "illegal auto boxing error %s <- %s"
                        ( varType.getTxt(##), expTypeInfo.getTxt(##)) );
                  }
               }
            }
            expTypeList.insert( expTypeInfo );
         }
      }
      if updateExpList {
         // 引数リストを更新する
         workList = self.createExpListNode( workList, newExpList );
      }

      {
         let mut alt2typeMap =
         Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap(false);

         if! self.checkImplicitCast(
            alt2typeMap, true, typeInfoList, workList,
            fn ( dstType:&Ast.TypeInfo, expNode:&Nodes.Node ): &Nodes.Node! {
               return nil;
            } )
         {
            workList = _exp;
         }
      }


      // 宣言する変数の数より初期値が少ない場合、
      // nil で初期化されるため変数が nilable かどうか判定
      foreach varType, index in typeInfoList {
         if index > #expTypeList {
            if not varType.$nilable {
               self.addErrMess(
                  firstPos,
                  "unmatch value type (index:%d) %s <- nil"
                  (index, varType.getTxt( self.typeNameCtrl## )));
            }
         }
      }
      // 変数の型を、型推論で初期値から設定
      foreach typeInfo, index in expTypeList {
         if #typeInfoList < index or
         typeInfoList[ index ].equals( self.processInfo, Ast.builtinTypeEmpty ## )
         {
            let workPos;
            let workType;
            let workName;
            if index <= #letVarList {
               let letVar = letVarList[ index ];
               workPos = letVar.varName.pos;
               workName = letVar.varName.txt;
               if Ast.TypeInfo.isMut( typeInfo ) and
                  not Ast.isMutable( letVar.mutable ) 
               {
                  workType = self.createModifier( typeInfo, .IMutRe );
               }
               else {
                  workType = typeInfo;
               }

               if self.analyzeMode == .Inquire and self.isTargetToken( letVar.varName ) {
                  self.dumpSymbolType( accessMode, letVar.varName.txt, workType );
               }
            }
            else {
               workType = typeInfo;
               workPos = firstPos;
               workName = "";
            }
            typeInfoList[ index ] = workType;

            switch workType.$kind {
               case .Func {
                  if #expTypeList ~= 1 or workType.$rawTxt ~= "" {
                     // anonymous 関数宣言の型推論変数宣言は、
                     // 通常関数宣言に置き換えるが、
                     // 2 つ以上の変数を宣言している場合はエラーとする。
                     self.addErrMess(
                        firstPos,
                        "must set the type of variable for function. -- %s"
                        (workName) );
                  }
               }
               case .List, .Array, .Set, .Map {
                  self.checkLiteralEmptyCollection( workPos, workName, workType );
               }
            }
         }
      }
      return typeInfoList, letVarList, orgExpTypeList, workList;
   }

   return typeInfoList, letVarList, orgExpTypeList, nil;
}

/*
let で宣言している変数シンボル、型、初期値の型情報を解析して返す。

スコープへの変数シンボルの登録は行なわない。

@param firstPos エラー発生時に使用する位置情報
@param initMutable 変数の mutable 初期値。
   true を指定した場合、 mut を明示しなくても mutable として扱う。
@param accessMode アクセスモード
@param unwrapFlag unwrap して変数に初期値を格納するかどうか。
@return List<&Ast.TypeInfo> 型推論解決後の変数の型情報リスト
@return LetVarInfo[] 変数のシンボル等の情報リスト
@return List<&Ast.TypeInfo> unwrap 前の初期値のリスト
@return Nodes.ExpListNode! 初期値の ExpListNode。初期値が与えられていない場合は nil。
*/
fn TransUnit.analyzeLetAndInitExp(
   firstPos:&Parser.Position, letFlag:bool, initMutable:Ast.MutMode,
   accessMode:Ast.AccessMode, unwrapFlag:bool ) mut :
   List<&Ast.TypeInfo>, &List<&LetVarInfo>, &List<&Ast.TypeInfo>, Nodes.ExpListNode!
{
   // 宣言している変数の型リスト
   let mut typeInfoList : List<&Ast.TypeInfo> = [];
   // let で宣言している変数名と型の情報リスト
   let mut letVarList:List<&LetVarInfo> = [];

   let mut nextToken = Parser.getEofToken();

   if letFlag {
      repeat {
         // 変数名と : で明示している型情報を取得。
         let mut mutable = initMutable;
         nextToken = self.getToken(##);
         if nextToken.txt == "mut" {
            mutable = .Mut;
            nextToken = self.getToken(##);
         }
         let varName = self.checkSymbol( nextToken, .MustNot_Or_ );
         nextToken = self.getToken(##);
         let mut typeInfo = Ast.builtinTypeEmpty;
         if nextToken.txt == ":" {
            // 型を明示している場合
            let refType = self.analyzeRefType(
               accessMode, false, Ast.isPubToExternal( accessMode ));
            letVarList.insert( new LetVarInfo( mutable, varName, refType ) );
            typeInfo = refType.$expType;
            nextToken = self.getToken(##);
         }
         else {
            // 型を明示していない場合、 mut でなければ .IMutRe とする
            letVarList.insert(
               new LetVarInfo( Ast.isMutable( mutable ) and mutable or Ast.MutMode.IMutRe,
                               varName, nil ) );
         }
         if not typeInfo.equals( self.processInfo, Ast.builtinTypeEmpty ## ) and
            Ast.TypeInfo.isMut( typeInfo ) and not Ast.isMutable( mutable ) and         
            self.ctrl_info.legacyMutableControl            
         {
            typeInfo = self.createModifier( typeInfo, .IMutRe );
         }
         typeInfoList.insert( typeInfo );
      } nextToken.txt ~= ",";
   } else {
      while true {
         let symbolToken = self.getToken(##);
         nextToken = self.getToken(##);

         let verSym = self.scope.getSymbolTypeInfo(
            symbolToken.txt, self.scope, self.moduleScope, self.scopeAccess );
         when! verSym {
            letVarList.insert( new LetVarInfo( verSym.$mutMode, symbolToken, nil ) );
            typeInfoList.insert( verSym.$typeInfo );
         } else {
            self.addErrMess( symbolToken.pos,
                             "not found symbol -- %s" (symbolToken.txt) );
         }
         if nextToken.txt ~= "," {
            break;
         }
      }
   }


   if nextToken.txt ~= "=" {
      self.pushback();
      let mut orgExpTypeList: List<&Ast.TypeInfo> = [];
      return typeInfoList, letVarList, orgExpTypeList, nil;
   }
   return self.analyzeInitExp(
      firstPos, accessMode, unwrapFlag, letVarList, typeInfoList)**;
}

fn TransUnit.analyzeDeclVar(
   mode:Nodes.DeclVarMode,
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut unwrapFlag = false;
   let mut token, continueFlag = self.getContinueToken();
   if continueFlag and token.txt == "!" {
      unwrapFlag = true;
   }
   else {
      self.pushback();
      if mode ~= .Let {
         Util.log( "need '!'" );
      }
   }

   if accessMode == .Pub {
      if self.scope ~= self.moduleScope {
         self.addErrMess( firstToken.pos, "'pub' variable must exist top scope." );
      }
   }

   let mut typeInfoList, mut letVarList, mut orgExpTypeList, mut expList =
      self.analyzeLetAndInitExp(
         firstToken.pos, mode == .Let,
         mode == .Sync and Ast.MutMode.Mut or Ast.MutMode.IMut, accessMode, unwrapFlag );

   if mode == .Let and #typeInfoList == 1 {
      when! expList {
         let typeInfo = typeInfoList[ 1 ];
         let letVaInfo = letVarList[ 1 ];
         if #expList.$expList == 1 and typeInfo.$kind == .Func {
            let mut valExp = expList.$expList[ 1 ];
            if! let macroExp = valExp@@@Nodes.ExpMacroExpNode {
               if macroExp.$expType.$kind == .Func and #macroExp.$stmtList == 1 {
                  valExp = macroExp.$stmtList[1];
               }
            }
            if! let declNode = valExp@@@Nodes.DeclFuncNode {
               if not declNode.$declInfo.$name {
                  if Ast.isMutable( letVaInfo.mutable ) {
                     self.addErrMess(
                        letVaInfo.varName.pos, 
                        "Any function can't be mutable. -- %s" (letVaInfo.varName.txt) );
                  }
                  // anonymous 関数宣言の型推論変数宣言は、
                  // 通常関数宣言に置き換える。
                  // 次のような感じ。
                  // let func = fn () {}; → fn func() {}
                  let letVarInfo = letVarList[ 1 ];
                  let mut newTypeInfo = self.processInfo.createFuncAsync(
                     typeInfo.$abstractFlag, false,
                     unwrap self.namespace2Scope[ typeInfo ],
                     typeInfo.$kind, self.getNSType( typeInfo.$parentInfo ),
                     false, false, typeInfo.$staticFlag, accessMode,
                     letVarInfo.varName.txt, typeInfo.$asyncMode,
                     typeInfo.$itemTypeInfoList,
                     typeInfo.$argTypeInfoList, typeInfo.$retTypeInfoList,
                     Ast.TypeInfo.isMut( typeInfo ) );
                  let funcSym = self.processAddFunc(
                     true, self.scope, letVarInfo.varName, newTypeInfo,
                     Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
                  self.nodeManager.delNode( declNode );

                  let mut declInfo = Nodes.DeclFuncInfo.createFrom(
                     declNode.$declInfo, letVarInfo.varName, funcSym );
                  return Nodes.DeclFuncNode.create(
                     self.nodeManager, declNode.$pos,
                     self.macroCtrl.isInAnalyzeArgMode(), [ newTypeInfo ], declInfo );
               }
            }
         }
      }
   }


   let mut syncScope:Ast.Scope = self.scope;
   if mode == .Sync {
      syncScope = self.pushScope( false ## );
   }


   let mut symbolInfoList: List<&Ast.SymbolInfo> = [];

   let mut varList:List<&Nodes.VarInfo> = [];
   let mut syncSymbolList:List<&Ast.SymbolInfo> = [];
   foreach letVarInfo, index in letVarList {
      let varName = letVarInfo.varName;
      let typeInfo = typeInfoList[ index ];
      let varInfo = new Nodes.VarInfo(
         varName, letVarInfo.varType, typeInfo );
      varList.insert( varInfo );

      if Ast.isPubToExternal( accessMode ) {
         self.checkPublic( varName.pos, typeInfo );
      }

      if not letVarInfo.varType and
         typeInfo.equals( self.processInfo, Ast.builtinTypeNil ## )
      {
         self.addErrMess(
            varName.pos, 'need type -- %s' ( varName.txt ) );
      }
      if mode == .Sync {
         // スコープに登録する前に、シンボルを検索
         if! let symInfo = self.scope.getSymbolInfo(
            varName.txt, self.scope, true, self.scopeAccess )
         {
            syncSymbolList.insert( symInfo );
         }
      }
      // スコープに変数を登録
      if mode == .Let or mode == .Sync {
         if mode == .Let {
            self.checkShadowing( varName.pos, varName.txt, self.scope );
            // if self.scope.getTypeInfo( varName.txt, self.scope, true, self.scopeAccess ) {
            //    self.addErrMess( varName.pos,
            //                     "shadowing variable -- %s" (varName.txt) );
            // }
         }
         let mut orgExpType = Ast.builtinTypeStem_;
         if not unwrapFlag {
            orgExpType = Ast.builtinTypeEmpty;
         }
         if index <= #orgExpTypeList {
            orgExpType = orgExpTypeList[ index ];
         }

         let mut hasValue = false;
         if not unwrapFlag and orgExpType ~= Ast.builtinTypeEmpty or
            unwrapFlag and not orgExpType.$nilable
         {
            hasValue = true;
         }
         self.scope.addVar(
            self.processInfo, accessMode, varName.txt, varName.pos,
            typeInfo, letVarInfo.mutable, hasValue );

         if typeInfo.$asyncMode == .Transient {
            // Transient は変数への代入禁止
            self.addErrMess(
               varName.pos,
               "can't set the __trans type -- index:%d, %s"
               (index, typeInfo.getTxt(##)) );
         }
      }
      symbolInfoList.insert(
         unwrap self.scope.getSymbolInfo( varName.txt, self.scope,
                                          true, self.scopeAccess ) );
   }
   if mode ~= .Sync and self.macroScope {
      self.macroCtrl.registVar( symbolInfoList );
   }
   

   let mut unwrapBlock: Nodes.BlockNode! = nil;
   let mut thenBlock: Nodes.BlockNode! = nil;
   if unwrapFlag {
      let mut scope = self.pushScope( false ## );

      // unwrap ブロックに変数を登録
      foreach letVarInfo, index in letVarList {
         if letVarInfo.varName.txt ~= "_" {
            self.addLocalVar(
               letVarInfo.varName.pos, false, true,
               "_" .. letVarInfo.varName.txt, orgExpTypeList[ index ], .IMut ## );
         }
      }

      unwrapBlock = self.analyzeBlock( .LetUnwrap, .Start, scope, nil );
      self.popScope();

      // unwrap ブロック後には変数にデータがセットされているものとする。
      when! unwrapBlock {
         _switch mode {
            case .Let, .Sync {
               let breakKind = unwrapBlock.getBreakKind( .Normal );
               foreach symbolInfo in symbolInfoList {
                  // let symbolInfo =
                  //    unwrap self.scope.getSymbolInfoChild( letVarInfo.varName.txt );
                  if breakKind ~= .None {
                     self.tentativeSymbol.checkAndExclude( symbolInfo );
                     symbolInfo.updateValue( symbolInfo.$pos );
                  }
                  else {
                     if symbolInfo.$name ~= "_" and
                        not self.tentativeSymbol.checkAndExclude( symbolInfo )
                     {
                        if not symbolInfo.$hasValueFlag {
                           self.addErrMess(
                              unwrapBlock.$pos,
                              "This variable isn't set -- " .. (symbolInfo.$name) );
                        }
                     }
                  }
               }
            }
            case .Unwrap {
               foreach symbolInfo in symbolInfoList {
                  symbolInfo.updateValue( firstToken.pos );
               }
            }
         }
      }

      token = self.getToken( true );
      if token.txt == "then" {
         thenBlock = self.analyzeBlock( .LetUnwrapThenDo, .Finish, scope, nil );
      }
      else {
         self.pushback();
         self.finishTentativeSymbol( true );
      }
   }

   let mut syncBlock: Nodes.BlockNode! = nil;
   if mode == .Sync {
      self.checkNextToken( "do" );
      syncBlock = self.analyzeBlock( .LetUnwrapThenDo, .Simple, syncScope, nil );
      self.popScope();
   }

   self.checkNextToken( ";" );

   let mut node = Nodes.DeclVarNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], mode, accessMode, false,
      varList, expList, symbolInfoList, typeInfoList, unwrapFlag, unwrapBlock,
      thenBlock, syncSymbolList, syncBlock );

   return node;
}

/**
if! の解析。

@param firstToken if 部分のトークン
@return if! のノード
*/
fn TransUnit.analyzeIfUnwrap( firstToken: &Parser.Token ) mut : Nodes.IfUnwrapNode
{
   let mut nextToken = self.getToken(##);
   let mut typeInfoList:List<&Ast.TypeInfo> = [];
   let mut varNameList:List<&Parser.Token> = [];
   let mut expList:&Nodes.ExpListNode;
   let mut varList:List<&Ast.SymbolInfo> = [];

   let mut workTypeInfoList, mut letVarList, workExpList;
   if nextToken.txt == "let" {
      workTypeInfoList, letVarList, _, workExpList = self.analyzeLetAndInitExp(
         firstToken.pos, true, .IMut, .Local, true );
   } else {
      self.pushback();
      let mut tmpTypeInfoList : List<&Ast.TypeInfo> = [ Ast.builtinTypeEmpty ];
      let mut tmpLetVarList:List<&LetVarInfo> = [
         new LetVarInfo(
            .Mut, new Parser.Token( .Symb, "_exp", firstToken.pos, false## ), nil )
      ];
      workTypeInfoList, letVarList, _, workExpList = self.analyzeInitExp(
         firstToken.pos, .Local, true, tmpLetVarList, tmpTypeInfoList );
   }
   typeInfoList = workTypeInfoList;
   when! workExpList {
      expList = workExpList;
   }
   else {
      self.addErrMess( nextToken.pos, "if! let has illegal init val." );
      self.error( "system error" );
   }
   foreach varInfo in letVarList {
      varNameList.insert( varInfo.varName );
   }
   
   let mut scope = self.pushScope( false ## );

   foreach expType, index in typeInfoList {
      if index > #varNameList {
         break;
      }
      let varName = varNameList[ index ];
      varList.insert(
         self.addLocalVar( varName.pos, false, true, varName.txt, expType, .IMut ## ) );
      
   }

   let block = self.analyzeBlock( .IfUnwrap, .Start, scope,  nil );

   self.popScope();

   let mut elseBlock:Nodes.BlockNode! = nil;
   nextToken = self.getToken( true );
   if nextToken.txt == "else" {
      elseBlock = self.analyzeBlock( .Else, .Finish ## );
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   let mut hasCond = false;
   foreach expNode, index in expList.$expList {
      if index ~= #expList.$expList {
         if Ast.isConditionalbe( self.processInfo, expNode.$expType ) {
            hasCond = true;
            break;
         }
      }
      else {
         foreach expType in expNode.$expTypeList {
            if Ast.isConditionalbe( self.processInfo, expType ) {
               hasCond = true;
               break;
            }
         }
      }
   }
   if not hasCond {
      self.addErrMess( firstToken.pos, "This condition never be false" );
   }

   foreach varSym in varList {
      switch varSym.$name {
         case "_", "_exp" {
         }
         default {
            if not varSym.$posForModToRef {
               self.addWarnMess(
                  unwrap varSym.$pos,
                  "This symbol has no referer -- %s" ( varSym.$name) );
            }
         }
      }
   }

   return Nodes.IfUnwrapNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], varList, expList, block, elseBlock );
}

fn TransUnit.analyzeWhen( firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut nextToken, continueFlag = self.getContinueToken();
   //let mut varNameList:str[] = [];

   if not ( continueFlag and nextToken.txt == "!" ) {
      self.pushback();
      self.addErrMess( nextToken.pos, "'when' need '!'" );
   }

   let symListNode = self.analyzeExpList( false, false, false ## );

   let mut scope = self.pushScope( false ## );

   //let mut expNodeList:List<&Nodes.Node> = [];
   let mut symPairList:List<&Nodes.UnwrapSymbolPair> = [];

   foreach expNode in symListNode.$expList {
      if! let refNode = expNode@@@Nodes.ExpRefNode {
         if expNode.$expType.$nilable {
            let symbolInfo = refNode.$symbolInfo;
            // varNameList.insert( refNode.$token.txt );
            let newSymbolInfo = self.addLocalVar(
               firstToken.pos, false, expNode.canBeLeft(), refNode.$symbolInfo.$name,
               expNode.$expType.$nonnilableType,
               //symbolInfo.$mutable and Ast.MutMode.Mut or Ast.MutMode.IMut, true );
               Ast.MutMode.IMut, true );
            symPairList.insert( new Nodes.UnwrapSymbolPair( symbolInfo, newSymbolInfo ) );
         }
         else {
            self.addErrMess( expNode.$pos,
                             "This type isn't nilable. -- %s"
                             ( expNode.$expType.getTxt(##) ) );
         }
      }
      else {
         self.addErrMess( expNode.$pos,
                          "'when' support only local variables or arguments." );
      }
   }

   let block = self.analyzeBlock( .When, .Start, scope, nil );

   self.popScope();

   let mut elseBlock:Nodes.BlockNode! = nil;
   nextToken = self.getToken( true );
   if nextToken.txt == "else" {
      elseBlock = self.analyzeBlock( .Else, .Finish ## );
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   return Nodes.WhenNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], symPairList, block, elseBlock );
}
