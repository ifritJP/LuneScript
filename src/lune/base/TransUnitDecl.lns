/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

/**
参照する型情報を解析する。

@param accessMode この型のアクセス制御
@param allowDDD ... を型として許す場合 true
@param parentPub この型を使用している親の空間自体が public な場合 true
*/
fn TransUnit.analyzeRefType(
   accessMode: Ast.AccessMode, allowDDD:bool, parentPub:bool ) mut:
   Nodes.RefTypeNode
{
   let firstToken = self.getToken(##);
   let mut token = firstToken;
   let mut refFlag = false;
   if token.txt == "&" {
      refFlag = true;
      token = self.getToken(##);
   }
   let mut mutFlag = false;
   if token.txt == "mut" {
      mutFlag = true;
      token = self.getToken(##);
   }
   // builtin の型名などは _ で始まることもあるので、シンボル名チェックしない
   // self.checkSymbol( token, .MustNot_ );

   let name:Nodes.Node;
   if token.txt == "..." {
      // ... は変数シンボルとしても使用するので
      // analyzeExpSymbol で解析すると意図しないシンボルを取ってくる可能性があるため、
      // ここで特別に処理する。
      let dddSym = unwrap self.moduleScope.getSymbolInfo(
         "...", self.moduleScope, true, .Normal );
      name = Nodes.ExpRefNode.create(
         self.nodeManager, token.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ dddSym.$typeInfo ], 
         new Ast.AccessSymbolInfo( dddSym, nil, true ) );
   }
   else {
      name = self.analyzeExpSymbol( firstToken, token, .Symbol, nil, true );
      let symbolList = name.getSymbolInfo();
      if #symbolList > 0 {
         let symbol = symbolList[ 1 ];
         if symbol.$kind ~= .Typ {
            self.addErrMess( name.$pos, "illegal type -- %s" ( symbol.$name ) );
         }
      }
      else {
         self.addErrMess( name.$pos,
                          "illegal symbol node -- %s"
                          ( Nodes.getNodeKindName( name.$kind ) ) );
      }
   }
   return self.analyzeRefTypeWithSymbol(
      accessMode, allowDDD, refFlag, mutFlag, name, parentPub );
}


fn TransUnit.analyzeRefTypeWithSymbol(
   accessMode: Ast.AccessMode, allowDDD:bool,
   refFlag: bool, mutFlag: bool, symbolNode:&Nodes.Node, parentPub:bool ) mut:
   Nodes.RefTypeNode
{
   let mut typeInfo = symbolNode.$expType;

   if parentPub and
      Ast.isPubToExternal( accessMode ) and
      not Ast.isPubToExternal( typeInfo.$accessMode )
   {
      // 公開する型の中で非公開な型を利用するのは NG
      self.addErrMess( symbolNode.$pos,
                       "This type must be public. -- %s" (typeInfo.getTxt(##) ));
   }
   

   let continueToken, continueFlag = self.getContinueToken();
   let mut token = continueToken;
   if continueFlag and token.txt == "!" {
      typeInfo = typeInfo.get_nilableTypeInfo();
      token = self.getToken(##);
   }

   let mut arrayMode = "no";
   while true {
      if token.txt == '[' or token.txt == '[@' {
         if token.txt == '[' {
            arrayMode = "list";
            typeInfo = Ast.NormalTypeInfo.createList(
               accessMode, self.getCurrentClass(), [ typeInfo ], .Mut );
         }
         else {
            arrayMode = "array";
            typeInfo = Ast.NormalTypeInfo.createArray(
               accessMode, self.getCurrentClass(), [ typeInfo ], .Mut );
         }
         token = self.getToken(##);
         if token.txt ~= ']' {
            self.pushback();
            self.checkNextToken( ']' );
         }
      }
      elseif token.txt == "<" {
         let mut genericList: List<&Ast.TypeInfo> = [];
         let mut nextToken: &Parser.Token = Parser.getEofToken();
         repeat {
            let typeExp = self.analyzeRefType( accessMode, false, parentPub );
            genericList.insert( typeExp.$expType );
            nextToken = self.getToken(##);
         } nextToken.txt ~= ",";
         self.checkToken( nextToken, '>' );

         fn checkAlternateTypeCount( count:int ): bool {
            if #genericList ~= count {
               self.addErrMess(
                  symbolNode.$pos,
                  "generic type count is unmatch. -- %d" (#genericList) );
               return false;
            }
            return true;
         }

         switch typeInfo.$kind {
            case .Map {
               if #genericList ~= 2 {
                  self.addErrMess( symbolNode.$pos, "Key or value type is unknown" );
                  typeInfo = Ast.NormalTypeInfo.createMap(
                     accessMode, self.getCurrentClass(),
                     Ast.builtinTypeStem, Ast.builtinTypeStem, .Mut );
               }
               else {
                  typeInfo = Ast.NormalTypeInfo.createMap(
                     accessMode, self.getCurrentClass(),
                     genericList[ 1 ], genericList[ 2 ], .Mut );
               }
            }
            case .List {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createList(
                     accessMode, self.getCurrentClass(),
                     genericList, .Mut );
               }
            }
            case .Array {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createArray(
                     accessMode, self.getCurrentClass(),
                     genericList, .Mut );
               }
            }
            case .Set {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createSet(
                     accessMode, self.getCurrentClass(),
                     genericList, .Mut );
               }
            }
            case .DDD {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createDDD( genericList[1], false );
               }
            }
            case .Class, .IF {
               if checkAlternateTypeCount( #typeInfo.$itemTypeInfoList ) {
                  foreach itemType, index in genericList {
                     let altType = unwrap typeInfo.$itemTypeInfoList[ index ]@@@Ast.AlternateTypeInfo;
                     if itemType.$nilable {
                        self.addErrMess(
                           symbolNode.$pos,
                           "can't use nilable type -- %s" (itemType.getTxt(##)) );
                     }
                  }
                  typeInfo = Ast.NormalTypeInfo.createGeneric(
                     typeInfo, genericList, self.moduleType );
               }
            }
            case .Box {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createBox( accessMode, genericList[1] );
               }
            }
            case .Ext {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createLuaval( genericList[1] );
               }
            }
            default {
               self.error( string.format( "not support generic: %s",
                                          typeInfo.getTxt(##) ) );
            }
         }
      }
      else {
         self.pushback();
         break;
      }
      token = self.getToken(##);
   }
   if token.txt == "!" {
      typeInfo = typeInfo.get_nilableTypeInfo();
      token = self.getToken(##);
   }

   if not allowDDD {
      if typeInfo.$kind == .DDD {
         self.addErrMess( symbolNode.$pos,
                          "invalid type. -- '%s'" (typeInfo.getTxt(##) ) );
      }
   }

   if refFlag {
      typeInfo = self.createModifier( typeInfo, .IMut );
   }

   return Nodes.RefTypeNode.create(
      self.nodeManager, symbolNode.$pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ],
      symbolNode, refFlag, mutFlag, arrayMode );
}

fn TransUnit.analyzeDeclArgList(
   accessMode:Ast.AccessMode, scope:Ast.Scope,
   argList: List<&Nodes.Node>, parentPub:bool ) mut : &Parser.Token
{
   let mut nextToken: &Parser.Token = Parser.noneToken;
   let mut hasDDDFlag = false;
   repeat {
      nextToken = self.getToken(##);
      if nextToken.txt == ")" {
         break;
      }

      if hasDDDFlag {
         self.addErrMess( nextToken.pos, "Argument exists after '...'." );
      }

      let mut mutable = Ast.MutMode.IMut;
      if nextToken.txt == "mut" {
         mutable = .Mut;
         nextToken = self.getToken(##);
      }
      let mut argName = nextToken;
      if argName.txt == "..." {
         hasDDDFlag = true;

         let workToken, flag = self.getContinueToken();
         self.pushback();

         let mut dddTypeInfo = Ast.builtinTypeDDD;
         if flag and workToken.txt == "<" {
            self.pushbackToken( nextToken );
            let refTypeNode = self.analyzeRefType( accessMode, true, parentPub );
            dddTypeInfo = refTypeNode.$expType;
         }

         argList.insert(
            Nodes.DeclArgDDDNode.create(
               self.nodeManager, argName.pos,
               self.macroCtrl.isInAnalyzeArgMode(), [ dddTypeInfo ] ) );
         scope.addLocalVar( true, true, argName.txt, argName.pos, dddTypeInfo, .IMut );
      }
      else {
         argName = self.checkSymbol( argName, .MustNot_ );

         self.checkShadowing( argName.pos, argName.txt, scope );

         // if scope.getSymbolTypeInfo(
         //    argName.txt, scope, self.moduleScope, self.scopeAccess ) {
         //    self.addErrMess( argName.pos,
         //                     "shadowing variable -- %s" (argName.txt) );
         // }

         self.checkNextToken( ":" );
         let refType = self.analyzeRefType( accessMode, false, parentPub );
         if! let symbolInfo = scope.addLocalVar(
            true, true, argName.txt, argName.pos, refType.$expType, mutable )
         {
            let arg = Nodes.DeclArgNode.create(
               self.nodeManager, argName.pos,
               self.macroCtrl.isInAnalyzeArgMode(), refType.$expTypeList,
               argName, symbolInfo );

            argList.insert( arg );
         }
      }
      nextToken = self.getToken(##);
   } nextToken.txt ~= ",";

   self.checkToken( nextToken, ")" );

   return nextToken;
}

fn TransUnit.checkOverriededMethod() mut
{
   fn checkOverrideMethodSub(
      pos:&Parser.Position, alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo>,
      classScope:&Ast.Scope, scope:&Ast.Scope )
   {
      scope.filterTypeInfoField(
         true, classScope, self.scopeAccess,
         fn ( symbolInfo:&Ast.SymbolInfo ): bool {
            if symbolInfo.$name == "__init" {
               return true;
            }
            if symbolInfo.$typeInfo.$kind == .Method {
               let mut noImp = false;
               if! let impMethodType = classScope.getTypeInfoField(
                  symbolInfo.$name, true, classScope, self.scopeAccess )
               {
                  if not impMethodType.canEvalWith(
                     symbolInfo.$typeInfo, .SetOp, alt2typeMap )
                  {
                     self.addErrMess(
                        pos, "mismatch method -- %s %s" (symbolInfo.$typeInfo.$display_stirng,
                                                          impMethodType.$display_stirng ) );
                  }
                  if impMethodType.$abstractFlag {
                     noImp = true;
                  }
               }
               else {
                  noImp = true;
               }
               if noImp {
                  self.addErrMess( pos, "not implements method -- %s.%s"
                                   ( classScope.$ownerTypeInfo$.getTxt$(##),
                                     symbolInfo.$name) );
               }
            }
            return true;
         } );
   }

   let mut typeId2DeclClassNode:Map<int,&Nodes.DeclClassNode> = {};
   foreach classNode, classTypeInfo in self.typeInfo2ClassNode {
      typeId2DeclClassNode[ classTypeInfo.$typeId ] = classNode;
   }

   forsort classNode in typeId2DeclClassNode {
      let classTypeInfo = classNode.$expType;
      if not classTypeInfo.$abstractFlag {
         // extend のメソッドがオーバーライドされているか確認
         let mut workTypeInfo = classTypeInfo;
         let mut alt2typeMap = classTypeInfo.createAlt2typeMap(false);
         repeat {
            if workTypeInfo ~= Ast.headTypeInfo {
               checkOverrideMethodSub(
                  classNode.$pos, alt2typeMap,
                  unwrap classTypeInfo.$scope,
                  unwrap workTypeInfo.$scope );
            }
            foreach ifType in workTypeInfo.$interfaceList {
               if ifType ~= Ast.builtinTypeMapping {
                  checkOverrideMethodSub(
                     classNode.$pos, alt2typeMap,
                     unwrap classTypeInfo.$scope, unwrap ifType.$scope );
               }
            }
            workTypeInfo = workTypeInfo.$baseTypeInfo;
         } workTypeInfo == Ast.headTypeInfo;
      }
   }
}

pub class ASTInfo {
   pri let node: Nodes.Node { pub };
   pri let moduleTypeInfo: Ast.TypeInfo { pub };
   pri let moduleSymbolKind: Ast.SymbolKind { pub };
}

pub fn TransUnit.createAST(
   parser: Parser.Parser, macroFlag: bool, moduleName: str! ) mut : ASTInfo
{
   self.moduleName = unwrap moduleName default "";

   self.registBuiltInScope();

   let mut processInfo = Ast.pushProcessInfo(##);

   let mut moduleTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   let mut moduleSymbolKind = Ast.SymbolKind.Typ;

   when! moduleName {
      apply txt of string.gmatch( moduleName, '[^%.]+' ) {
         // moduleTypeInfo = unwrap self.pushClass(
         //    true, false, nil, nil, false, txt@@str, "pub" );
         moduleTypeInfo = self.pushModule( false, txt, true );
      }
   }
   self.moduleScope = self.scope;
   self.moduleType = moduleTypeInfo;

   self.typeNameCtrl = new Ast.TypeNameCtrl( moduleTypeInfo );


   self.parser = new Parser.DefaultPushbackParser( parser );

   let ast:Nodes.Node;

   let mut lastStatement:&Nodes.Node! = nil;
   if macroFlag {
      ast = self.analyzeBlock( .Macro, .Ignore ##);
   }
   else {
      let mut children:List<&Nodes.Node> = [];
      let lastLineNo;
      lastStatement, lastLineNo = self.analyzeStatementList( children ## );

      let mut statement = Nodes.BlankLineNode.create(
         self.nodeManager, new Parser.Position( lastLineNo + 1, 0 ),
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], 0 );
      statement.addComment( self.commentCtrl.$commentList );
      self.commentCtrl.clear();
      children.insert( statement );
      

      let mut token = self.getTokenNoErr();
      if token ~= Parser.getEofToken() {
         self.error( "%s:%d:%d:(%s) not eof -- %s"
                     ( self.parser.getStreamName(),
                       token.pos.lineNo, token.pos.column,
                       token.kind.$_txt, token.txt ) );
      }

      foreach subModule in self.subfileList {
         let! file = frontInterface.searchModule( subModule ) {
            self.error( "not found subfile -- %s" ( subModule ) );
         };

         if self.scope ~= self.moduleScope {
            self.error( "scope does not close" );
         }

         let! mut subParser = Parser.StreamParser.create( file, false, subModule ) {
            self.error( "open error -- %s" (file) );
         };

         self.parser = new Parser.DefaultPushbackParser( subParser );

         lastStatement = self.analyzeStatementListSubfile( children );

         token = self.getTokenNoErr();
         if token ~= Parser.getEofToken() {
            Util.err( "unknown:%d:%d:(%s) %s"
                      ( token.pos.lineNo, token.pos.column,
                        token.kind.$_txt, token.txt ) );
         }
      }

      self.checkOverriededMethod();


      let mut rootNode = Nodes.RootNode.create(
         self.nodeManager, new Parser.Position( 0, 0 ),
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
         children, self.moduleScope, self.macroCtrl.$useModuleMacroSet,
         self.moduleId, processInfo, moduleTypeInfo, nil, self.helperInfo,
         self.nodeManager, self.importModule2ModuleInfo,
         self.macroCtrl.$typeId2MacroInfo, self.typeId2ClassMap );
      ast = rootNode;
      if! self.provideNode {
         if lastStatement ~= _exp {
            self.addErrMess( _exp.$pos, "'provide' must be last." );
         }
         rootNode.set_provide( _exp );
         moduleSymbolKind = _exp.$symbol.$kind;
      }

      ClosureFun.checkList( self.closureFunList );
   }

   when! moduleName {
      apply txt of string.gmatch( moduleName, '[^%.]+' ) {
         //self.popClass();
         self.popModule();
      }
   }

   Ast.popProcessInfo();


   foreach pos, protoType in self.protoFuncMap {
      self.addErrMess(
         pos, "This function doesn't have body. -- %s" ( protoType.getTxt(##) ) );
   }
   foreach pos, protoType in self.protoClassMap {
      self.addErrMess(
         pos, "This class doesn't have body. -- %s" ( protoType.getTxt(##) ) );
   }


   foreach mess in self.warnMessList {
      Util.errorLog( mess );
   }
   if #self.errMessList > 0 {
      foreach mess in self.errMessList {
         Util.errorLog( mess );
      }
      Util.err( "has error" );
   }
   if self.ctrl_info.stopByWarning and #self.warnMessList > 0 {
      Util.err( "has error" );
   }

   if self.analyzeMode == .Diag or self.analyzeMode == .Complete {
      os.exit( 0 );
   }

   return new ASTInfo( ast, moduleTypeInfo, moduleSymbolKind );
}


fn TransUnit.analyzeDeclMacroSub(
   accessMode: Ast.AccessMode,
   firstToken: &Parser.Token, nameToken: &Parser.Token,
   scope:Ast.Scope, parentType:&Ast.TypeInfo,
   workArgList: List<&Nodes.Node> ) mut : Nodes.DeclMacroNode
{
   self.macroCtrl.startDecl();

   
   let mut pubFlag = false;
   switch accessMode {
      case .Pub {
         pubFlag = true;
      }
      case .Local, .None {
      }
      default {
         self.addErrMess( firstToken.pos,
                          "macro not support this access mode. -- %s"
                          ( accessMode.$_txt ) );
      }
   }
   
   // let mut workArgList: List<&Nodes.Node> = [];
   let mut argList: List<&Nodes.DeclArgNode> = [];
   // let mut nextToken = self.analyzeDeclArgList( accessMode, workArgList, false );
   let mut argTypeList: List<&Ast.TypeInfo> = [];
   foreach argNode, index in workArgList {
      if! argNode@@@Nodes.DeclArgNode {
         argList.insert( _exp );
      }
      else {
         self.error( "macro argument can not use '...'." );
      }
      let argType = argNode.$expType;
      argTypeList.insert( argType );
   }

   let mut nextToken = self.getToken(##);

   let retTypeList;
   if nextToken.txt == ":" {
      retTypeList = self.analyzeRefType( accessMode, true, false ).$expTypeList;
      self.checkNextToken( "{");
   }
   else {
      retTypeList = [];
      self.checkToken( nextToken, "{");
   }
   
   nextToken = self.getToken(##);

   let mut stmtNode : Nodes.BlockNode! = nil;
   if nextToken.txt == "{" {
      //let mut parser = new Parser.WrapParser( self.parser, self.parser.getStreamName() );

      // foreach symbolInfo, symbol in scope.$symbol2SymbolInfoMap {
      //    scope.add( symbol, symbolInfo.$typeInfo, "local", false );
      // }

      self.macroScope = scope;

      let funcType = Ast.NormalTypeInfo.createFunc(
         false, true, nil, .Func, Ast.headTypeInfo, false, true,
         true, .Global, "_lnsLoad",
         nil, [ Ast.builtinTypeString, Ast.builtinTypeString ],
         [ Ast.builtinTypeStem ], false );
      scope.addLocalVar( false, false, "_lnsLoad", nil, funcType, .IMut );


      // let mut bakParser = self.parser;
      // self.parser = parser;

      let mut stmtList:List<&Nodes.Node> = [];
      self.prepareTentativeSymbol( self.scope, false );
      self.analyzeStatementList( stmtList, "}" );

      stmtNode = Nodes.BlockNode.create(
         self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
         [ Ast.builtinTypeNone ], .Macro, scope, stmtList );

      self.checkNextToken( "}" );
      self.finishTentativeSymbol( false );

      // self.parser = bakParser;


      
      self.macroScope = nil;
   }
   else {
      self.pushback();
   }

   // self.popScope();


   let mut tokenList: List<&Parser.Token> = [];
   let mut braceCount = 0;

   while true {
      nextToken = self.getToken(##);
      if nextToken.txt == "{" {
         braceCount = braceCount + 1;
      }
      elseif nextToken.txt == "}" {
         if braceCount == 0 {
            break;
         }
         braceCount = braceCount - 1;
      }
      tokenList.insert( nextToken );
   }

   let typeInfo = Ast.NormalTypeInfo.createFunc(
      false, false, scope, .Macro, parentType, false, false, true,
      accessMode, nameToken.txt, nil, argTypeList, retTypeList## );
   //self.scope.addLocalVar( false, false, nameToken.txt, typeInfo, false );
   // self.scope.addMacro( typeInfo, accessMode );


   let mut declMacroInfo = new Nodes.DeclMacroInfo(
      pubFlag, nameToken, argList, stmtNode, tokenList ) ;
   let mut node = Nodes.DeclMacroNode.create(
      self.nodeManager, firstToken.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], declMacroInfo );

   self.macroCtrl.regist( node );


   return node;
}


fn TransUnit.analyzeDeclMacro(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclMacroNode
{

   let nameToken = self.getSymbolToken( .Must_ );
   self.checkNextToken( "(" );


   // マクロ内は、独立スコープにするため、
   // マクロ用のスコープを topScope 直下に生成
   let mut scope = Ast.TypeInfo.createScope( self.topScope, false, nil, nil );

   // マクロ引数を解析。
   // このとき、マクロの型名や引数名などは現在のスコープをスコープを利用し、
   // 引数シンボルはマクロ用スコープに登録する。
   let mut workArgList: List<&Nodes.Node> = [];
   let mut nextToken = self.analyzeDeclArgList( accessMode, scope, workArgList, false );

   // マクロ解析用スコープに変更する前に、登録する namespace を取っおく
   let parentInfo = self.getCurrentNamespaceTypeInfo();
   
   // スコープをマクロ用スコープに変更
   let mut backScope = self.scope;
   self.scope = scope;   
  
   let mut node = self.analyzeDeclMacroSub(
      accessMode, firstToken, nameToken, scope, parentInfo, workArgList );

   // スコープを元に戻す
   self.scope = backScope;

   self.scope.addMacro( nameToken.pos, node.$expType, accessMode );
   
   return node;
}

fn TransUnit.analyzeExtend( accessMode:Ast.AccessMode, firstPos: &Parser.Position ) mut :
   &Parser.Token, &Ast.TypeInfo!, &List<&Ast.TypeInfo>, Map<&Ast.TypeInfo,&Ast.TypeInfo>
{
   let mut baseRef:&Nodes.Node! = nil;
   let mut interfaceList:List<&Ast.TypeInfo> = [];
   let mut ifAlt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo> = {};

   let mut nextToken = self.getToken(##);
   if nextToken.txt ~= "(" {
      self.pushback();
      let workBaseRefType = self.analyzeRefType(
         accessMode, false, Ast.isPubToExternal( accessMode ) );
      baseRef = workBaseRefType;
      let baseType = workBaseRefType.$expType;
      if baseType.$kind ~= .Class {
         self.addErrMess( workBaseRefType.$pos,
                          "%s is not class." ( baseType.getTxt(##) ) );
      }
      if Ast.isPubToExternal( accessMode ) and
         not Ast.isPubToExternal( baseType.$accessMode )
      {
         self.addErrMess(
            workBaseRefType.$pos,
            "%s can't be external symbol." ( baseType.getTxt(##) ) );
      }
      nextToken = self.getToken(##);
   }
   if nextToken.txt == "(" {
      while true {
         nextToken = self.getToken(##);
         if nextToken.txt == ")" {
            break;
         }
         self.pushback();
         let ifTypeNode = self.analyzeRefType(
            accessMode, false, Ast.isPubToExternal( accessMode ) );
         let ifType = ifTypeNode.$expType;
         if ifType.$kind ~= .IF {
            self.error( "%s is not interface -- %d"
                        (ifType.getTxt(##), ifType.$kind ) );
         }

         if Ast.isGenericType( ifType ) {
            foreach genType, altType in ifType.createAlt2typeMap(false) {
               ifAlt2typeMap[ altType ] = genType;
            }
         }


         interfaceList.insert( ifType );
         if Ast.isPubToExternal( accessMode ) and
            not Ast.isPubToExternal( ifType.$accessMode )
         {
            self.addErrMess( ifTypeNode.$pos,
                             "%s can't be external symbol." ( ifType.getTxt(##) ) );
         }

         nextToken = self.getToken(##);
         if nextToken.txt ~= "," {
            if nextToken.txt == ")" {
               break;
            }
            self.error( "illegal token" );
         }
      }
      nextToken = self.getToken(##);
   }

   // interface 間の、メソッドのミスマッチをチェックする
   let mut symbol2TypeInfo:Map<str,&Ast.TypeInfo> = {};
   foreach ifType in interfaceList {
      ifType.$scope$.filterTypeInfoField$(
         true, self.scope, self.scopeAccess,
         fn ( symbolInfo:&Ast.SymbolInfo ): bool {
            if! let ifFuncType = symbol2TypeInfo[ symbolInfo.$name ] {
               let ret, mess = ifFuncType.canEvalWith(
                  symbolInfo.$typeInfo, .SetOp, ifAlt2typeMap );
               if not ret {
                  self.addErrMess(
                     firstPos,
                     "mismatch method type -- %s.%s, %s.%s\n%s"
                     (symbolInfo.$typeInfo.$parentInfo.getTxt(##), symbolInfo.$name,
                       ifFuncType.$parentInfo.getTxt(##), ifFuncType.getTxt(##), mess));
               }
            }
            else {
               symbol2TypeInfo[ symbolInfo.$name ] = symbolInfo.$typeInfo;
            }
            return true;
         } );
   }



   let mut baseTypeInfo:&Ast.TypeInfo! = nil;
   when! baseRef {
      baseTypeInfo = baseRef.$expType;
   }
   return nextToken, baseTypeInfo, interfaceList, ifAlt2typeMap;
}

fn TransUnit.analyzePushClass(
   classFlag: bool, abstractFlag: bool, firstToken:&Parser.Token, name:&Parser.Token,
   allowMultiple:bool,
   accessMode:Ast.AccessMode, altTypeList:&List<&Ast.AlternateTypeInfo> ) mut :
   &Parser.Token, &Ast.TypeInfo
{
   if classFlag and Ast.isPubToExternal( accessMode ) and
      self.moduleScope ~= self.scope
   {
      self.addErrMess( firstToken.pos, "The public class must declare at top scope." );
   }


   // altTypeList のシンボルにアクセスできるように、一時的にスコープを掘る
   let mut tempScope = self.pushScope( false## );
   foreach altType in altTypeList {
      tempScope.addAlternate( accessMode, altType.$rawTxt, name.pos, altType );
   }


   let mut nextToken = self.getToken(##);
   let mut baseTypeInfo:&Ast.TypeInfo! = nil;
   let mut interfaceList:&List<&Ast.TypeInfo>! = nil;
   if nextToken.txt == "extend" {
      nextToken, baseTypeInfo, interfaceList = self.analyzeExtend(
         accessMode, firstToken.pos );

      when! baseTypeInfo {
         if! let initTypeInfo = baseTypeInfo.$scope$.getTypeInfoChild$("__init") {
            if initTypeInfo.$accessMode == .Pri {
               self.addErrMess(
                  firstToken.pos, "The access mode of '__init' is 'pri'." );
            }
         };
      }
   }


   // 一時的に掘ったスコープを戻す
   self.popScope();


   let classTypeInfo = self.pushClass(
      firstToken.pos, classFlag, abstractFlag, baseTypeInfo,
      interfaceList, altTypeList, false, name.txt, allowMultiple, accessMode ## );

   return nextToken, classTypeInfo;
}

fn TransUnit.analyzeDeclAlternateType(
   belongClassFlag:bool, token:&Parser.Token, accessMode: Ast.AccessMode ) mut :
   &Parser.Token, List<&Ast.AlternateTypeInfo>
{
   let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
   let mut nextToken = token;
   let mut altNameSet:Set<str> = (@);
   let mut altIndex = 0;
   while true {
      altIndex = altIndex + 1;
      let genericSymToken = self.getSymbolToken( .MustNot_ );
      if self.scope.getTypeInfo(
         genericSymToken.txt, self.scope, true, self.scopeAccess)
      {
         self.addErrMess( genericSymToken.pos,
                          "shadowing Type -- %s" (genericSymToken.txt) );
      }
      else {
         if altNameSet.has( genericSymToken.txt ) {
            self.addErrMess( genericSymToken.pos,
                             "multiple Type -- %s" (genericSymToken.txt) );
         }
         else {
            altNameSet.add( genericSymToken.txt );
         }
      }
      let mut workToken = self.getToken(##);
      if workToken.txt == "!" {
         self.addErrMess( workToken.pos, "not support nilable" );
         workToken = self.getToken(##);
      }
      let mut baseTypeInfo:&Ast.TypeInfo! = nil;
      let mut interfaceList:&List<&Ast.TypeInfo> = [];
      if workToken.txt == ":" {
         workToken, baseTypeInfo, interfaceList = self.analyzeExtend(
            accessMode, token.pos );
      }

      let altType = Ast.NormalTypeInfo.createAlternate(
         belongClassFlag, altIndex, genericSymToken.txt,
         accessMode, self.moduleType, baseTypeInfo, interfaceList );
      altTypeList.insert( altType );

      if workToken.txt == ">" {
         nextToken = self.getToken(##);
         break;
      }
      self.checkToken( workToken, "," );
   }
   return nextToken, altTypeList;
}

fn TransUnit.analyzeDeclProto(
   mut accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut nextToken = self.getToken(##);
   let mut abstractFlag = false;
   if nextToken.txt == "abstract" {
      abstractFlag = true;
      nextToken = self.getToken(##);
   }


   if nextToken.txt == "class" or nextToken.txt == "interface" {
      let name = self.getSymbolToken( .MustNot_ );

      // generic の型宣言解析
      let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
      {
         let mut workToken = self.getToken(##);
         if workToken.txt == "<" {
            workToken, altTypeList = self.analyzeDeclAlternateType(
               true, workToken, accessMode );
         }
         self.pushbackToken( workToken );
      }

      if accessMode == .Local {
         accessMode = .Pri;
      }

      let classTypeInfo:&Ast.TypeInfo;
      nextToken, classTypeInfo = self.analyzePushClass(
         nextToken.txt ~= "interface", abstractFlag,
         firstToken, name, false, accessMode, altTypeList );

      self.protoClassMap[ classTypeInfo ] = firstToken.pos;

      self.popClass();
      self.checkToken( nextToken, ";" );
   }
   else {
      self.error( "illegal proto" );
   }
   return self.createNoneNode( firstToken.pos );
}

fn TransUnit.analyzeDeclEnum(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclEnumNode
{
   let name = self.getSymbolToken( .MustNot_ );

   self.checkNextToken( "{" );
   self.commentCtrl.push();

   let mut valueList:List<&Parser.Token> = [];
   let mut valueName2Info:Map<str,Ast.EnumValInfo> = {};


   let mut scope = self.pushScope( true ## );

   let mut enumTypeInfo:Ast.EnumTypeInfo! = nil;

   let mut nextToken = self.getToken(##);
   let mut number = 0.0;
   let mut prevValTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   let mut valTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   while nextToken.txt ~= "}" {
      let valName = self.checkSymbol(nextToken, .MustNot_ );

      nextToken = self.getToken(##);

      let mut enumVal = Ast.EnumLiteral.Real( number );
      switch ( prevValTypeInfo ) {
         case Ast.builtinTypeReal {
         }
         case Ast.builtinTypeInt, Ast.headTypeInfo {
            enumVal = .Int( number@@int );
         }
      }

      if nextToken.txt == "=" {
         let exp = self.analyzeExpOne( false, false ## );
         let literal, mess = exp.getLiteral();
         when! literal {
            match literal {
               case .Int( val ) {
                  enumVal = .Int( val );
                  number = val@@real;
                  valTypeInfo = Ast.builtinTypeInt;
               }
               case .Real( val ) {
                  enumVal = .Real( val );
                  number = val;
                  valTypeInfo = Ast.builtinTypeReal;
               }
               case .Str( val ) {
                  enumVal = .Str( val );
                  valTypeInfo = Ast.builtinTypeString;
               }
               default {
                  self.error( "illegal enum val -- %s" ( literal.$_txt ) );
               }
            }
         }
         else {
            self.error( "illegal enum val -- %s" (mess) );
         }

         nextToken = self.getToken(##);
      }
      else {
         switch ( prevValTypeInfo ) {
            case Ast.headTypeInfo {
               valTypeInfo = Ast.builtinTypeInt;
            }
            case Ast.builtinTypeInt, Ast.builtinTypeReal {
               valTypeInfo = prevValTypeInfo;
            }
            default {
               self.addErrMess( valName.pos,
                                "illegal enum val type -- %s" (valTypeInfo.getTxt(##)) );
            }
         }
      }
      if prevValTypeInfo ~= Ast.headTypeInfo and prevValTypeInfo ~= valTypeInfo
      {
         self.addErrMess( valName.$pos,
                          "multiple enum val type. %s, %s"
                          (valTypeInfo.getTxt(##), prevValTypeInfo.getTxt(##)) );
      }
      prevValTypeInfo = valTypeInfo;

      if not enumTypeInfo {
         enumTypeInfo = Ast.NormalTypeInfo.createEnum(
            scope, self.getCurrentNamespaceTypeInfo(),
            false, accessMode, name.txt, valTypeInfo );
      }

      when! enumTypeInfo {
         scope.addEnumVal( valName.txt, valName.pos, enumTypeInfo );

         let enumValInfo = new Ast.EnumValInfo( valName.txt, enumVal );
         valueList.insert( valName );

         enumTypeInfo.addEnumValInfo( enumValInfo );
      }

      if nextToken.txt == "}" {
         break;
      }
      self.checkToken( nextToken, "," );
      nextToken = self.getToken(##);
      number = number + 1;
   }

   self.commentCtrl.pop();
   
   if not enumTypeInfo {
      enumTypeInfo = Ast.NormalTypeInfo.createEnum(
         scope, self.getCurrentNamespaceTypeInfo(),
         false, accessMode, name.txt, Ast.builtinTypeNone );
   }

   self.popScope();

   let enumSym, shadowing =
      self.scope.addEnum( accessMode, name.txt, name.pos, unwrap enumTypeInfo );
   self.errorShadowing( name.pos, shadowing );


   return Nodes.DeclEnumNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(), 
      [ unwrap enumTypeInfo ], accessMode, name, valueList, scope );
}



fn TransUnit.analyzeDeclAlge(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclAlgeNode
{
   self.helperInfo.useAlge = true;

   let name = self.getSymbolToken( .MustNot_ );

   self.checkNextToken( "{" );

   let mut scope = self.scope;
   let mut algeScope = self.pushScope( true ## );

   let mut algeTypeInfo = Ast.NormalTypeInfo.createAlge(
      algeScope, self.getCurrentNamespaceTypeInfo(), false, accessMode, name.txt );
   let algeSym, shadowing =
      scope.addAlge( accessMode, name.txt, name.pos, algeTypeInfo );
   self.errorShadowing( name.pos, shadowing );

   let mut nextToken = self.getToken(##);
   while nextToken.txt ~= "}" {
      let valName = self.checkSymbol( nextToken, .MustNot_ );
      if algeTypeInfo.getValInfo( valName.txt ) {
         self.addErrMess( valName.pos, "multiple symbole -- %s" (valName.txt) );
      }

      nextToken = self.getToken(##);

      let mut typeInfoList:List<&Ast.TypeInfo> = [];
      if nextToken.txt == "(" {
         // パラメータの宣言
         while true {
            // パラメータ名の確認
            let workToken1 = self.getToken(##);
            let workToken2 = self.getToken(##);
            if workToken2.txt ~= ":" {
               // パラメータ名を省略している場合は戻す
               self.pushback();
               self.pushback();
            }
            
            let typeNode = self.analyzeRefType(
               .Pub, false, Ast.isPubToExternal( accessMode ) );
            typeInfoList.insert( typeNode.$expType );
            nextToken = self.getToken(##);
            if nextToken.txt ~= "," {
               self.checkToken( nextToken, ")" );
               nextToken = self.getToken(##);
               break;
            }
         }
      }

      algeScope.addAlgeVal( valName.txt, valName.pos, algeTypeInfo );
      let algeValInfo = new Ast.AlgeValInfo( valName.txt, typeInfoList );
      algeTypeInfo.addValInfo( algeValInfo );

      if nextToken.txt == "}" {
         break;
      }
      self.checkToken( nextToken, "," );
      nextToken = self.getToken(##);
   }

   self.popScope();


   return Nodes.DeclAlgeNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ algeTypeInfo ], accessMode, algeTypeInfo, algeScope );
}

fn TransUnit.analyzeAlias(
   accessMode: Ast.AccessMode, firstToken:&Parser.Token ) mut : Nodes.AliasNode
{
   if self.scope ~= self.moduleScope {
      self.addErrMess( firstToken.pos, "alias must use at top scope." );
   }

   let newToken = self.getToken(##);
   self.checkNextToken( "=" );

   let srcToken = self.getToken(##);

   let symbolNode = self.analyzeExpSymbol(
      firstToken, srcToken, .Symbol, nil, true );


   let mut newTypeInfo = Ast.builtinTypeNone;
   let symbolInfoList = symbolNode.getSymbolInfo();

   if #symbolInfoList >= 1 {
      let symbolInfo = symbolInfoList[ 1 ];
      if newToken.txt.find( "^_" ##) and not srcToken.txt.find( "^_" ##) or
         not newToken.txt.find( "^_" ##) and srcToken.txt.find( "^_" ## )
      {
         self.addErrMess( firstToken.pos,
                          "alias symbol unmatch. %s %s" (newToken.txt, newToken.txt) );
      }
      else {
         switch symbolInfo.$kind {
            case .Typ, .Fun {
               let aliasSymbolInfo, shadowing = self.scope.addAlias(
                  newToken.txt, newToken.pos,
                  false, accessMode, self.moduleType, symbolInfo );
               when! aliasSymbolInfo {
                  newTypeInfo = aliasSymbolInfo.$typeInfo;
               }
               else {
                  self.errorShadowing( newToken.pos, shadowing );
               }
            }
            default {
               self.addErrMess(
                  firstToken.pos,
                  "can alias symbol -- %s. (%s)"
                  (srcToken.txt, symbolInfo.$kind.$_txt ) );
            }
         }
      }
   }
   else {
      self.addErrMess( firstToken.pos, "not found symbold -- %s" (srcToken.txt ) );
   }
   self.checkNextToken( ";" );

   return Nodes.AliasNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ newTypeInfo ], newToken.txt, symbolNode, newTypeInfo );
}



fn TransUnit.analyzeRetTypeList(
   pubToExtFlag:bool, accessMode:Ast.AccessMode,
   mut token:&Parser.Token, parentPub:bool ) mut :
   List<&Ast.TypeInfo>, &Parser.Token
{
   let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
   if token.txt == ":" {
      let mut hasDDDFlag = false;
      while true {
         let refTypeNode = self.analyzeRefType( accessMode, true, parentPub );
         if hasDDDFlag {
            self.addErrMess( refTypeNode.$pos, "Type exists after '...'." );
         }
         let retType = refTypeNode.$expType;
         if retType.$kind == .DDD {
            hasDDDFlag = true;
         }
         if pubToExtFlag and not Ast.isPubToExternal( retType.$accessMode )
         {
            self.addErrMess( refTypeNode.$pos,
                             "this is not public type -- %s" (retType.getTxt(##)) );
         }
         retTypeInfoList.insert( retType );
         token = self.getToken(##);
         if token.txt ~= "," {
            break;
         }
      }
   }
   return retTypeInfoList, token;
}


fn TransUnit.analyzeDeclForm( accessMode:Ast.AccessMode, firstToken:&Parser.Token )
mut : Nodes.DeclFormNode
{
   let name = self.getSymbolToken( .MustNot_ );
   self.checkNextToken( "(" );
   let mut argList:List<&Nodes.Node> = [];

   let mut funcBodyScope = self.pushScope( false ## );

   let mut nextToken = self.analyzeDeclArgList(
      accessMode, self.scope, argList, Ast.isPubToExternal( accessMode ) );

   self.checkToken( nextToken, ")" );

   let mut retTypeList:List<&Ast.TypeInfo> = [];
   nextToken = self.getToken(##);
   retTypeList, nextToken = self.analyzeRetTypeList(
      Ast.isPubToExternal( accessMode ), accessMode, nextToken,
      Ast.isPubToExternal( accessMode ) );

   self.checkToken( nextToken, ";" );

   self.popScope();

   let mut argTypeInfoList:List<&Ast.TypeInfo> = [];
   foreach argNode in argList {
      argTypeInfoList.insert( argNode.$expType );
   }

   let formType = Ast.NormalTypeInfo.createFunc(
      false, false, nil, .FormFunc,
      self.getCurrentNamespaceTypeInfo(), false, false,
      true, accessMode, name.txt, nil, argTypeInfoList, retTypeList, false );

   self.scope.addForm( name.pos, formType, accessMode );
   // self.scope.add(
   //    .Typ, false, false, name.txt, formType, accessMode, true, .IMut, false );

   return Nodes.DeclFormNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ formType ], argList );
}

fn TransUnit.analyzeDecl(
   accessMode: Ast.AccessMode, mut staticFlag: bool,
   firstToken: &Parser.Token, mut token: &Parser.Token ) mut : Nodes.Node!
{
   let mut count = 0;
   if not staticFlag {
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken(##);
         count = count + 1;
      }
   }
   let mut overrideFlag = false;
   if token.txt == "override" {
      overrideFlag = true;
      token = self.getToken(##);
      count = count + 1;
   }

   let mut abstractFlag = false;
   if token.txt == "abstract" {
      abstractFlag = true;
      token = self.getToken(##);
      count = count + 1;
   }

   if token.txt == "let" {
      return self.analyzeDeclVar( .Let, accessMode, firstToken );
   }
   elseif token.txt == "fn" {
      let nextToken = self.getToken(##);
      self.pushback();
      if nextToken.kind == .Symb or Ast.isPubToExternal( accessMode ) or
         staticFlag or overrideFlag or abstractFlag
      {
         // nextToken が .Symb の場合は、通常の関数定義。
         // anonymous 関数でも、 pub 等が指定されている場合は、
         // エラー処理用に analyzeDeclFunc() をコールする。
         return self.analyzeDeclFunc(
            .Func, abstractFlag, overrideFlag,
            accessMode, staticFlag, nil, firstToken, nil );
      }
      // anonymous 関数の場合は、 関数定義ではなく関数オブジェクトを利用した式。
   }
   elseif token.txt == "class" {
      return self.analyzeDeclClass( abstractFlag, accessMode, firstToken, .Class );
   }
   elseif token.txt == "interface" {
      return self.analyzeDeclClass( true, accessMode, firstToken, .Interface );
   }
   elseif token.txt == "module" {
      return self.analyzeDeclClass( false, accessMode, firstToken, .Module );
   }
   elseif token.txt == "proto" {
      return self.analyzeDeclProto( accessMode, firstToken );
   }
   elseif token.txt == "macro" {
      return self.analyzeDeclMacro( accessMode, firstToken );
   }
   elseif token.txt == "enum" {
      return self.analyzeDeclEnum( accessMode, firstToken );
   }
   elseif token.txt == "alge" {
      return self.analyzeDeclAlge( accessMode, firstToken );
   }
   elseif token.txt == "form" {
      return self.analyzeDeclForm( accessMode, firstToken );
   }
   elseif token.txt == "alias" {
      return self.analyzeAlias( accessMode, firstToken );
   }
   elseif token.txt == "__test" {
      return self.analyzeTest( firstToken );
   }

   return nil;
}


fn TransUnit.checkPublic( pos:&Parser.Position, typeInfo:&Ast.TypeInfo ) mut {
   let mut checkedTypeSet:Set<&Ast.TypeInfo> = (@);
   fn checkPub( workType:&Ast.TypeInfo ) {
      if checkedTypeSet.has( workType ) {
         return;
      }
      checkedTypeSet.add( workType );
      if workType.$kind ~= .Array and workType.$kind ~= .List
         and workType.$kind ~= .Set
         and workType.$kind ~= .Map and not Ast.isPubToExternal( workType.$accessMode )
      {
         self.addErrMess( pos, "not public this type -- %s" ( workType.getTxt(##)) );
      }
      else {
         foreach itemType in workType.$itemTypeInfoList {
            checkPub( itemType );
         }
      }
   }
   checkPub( typeInfo );
}

fn TransUnit.analyzeDeclMember(
   classTypeInfo: &Ast.TypeInfo, accessMode: Ast.AccessMode,
   staticFlag: bool, firstToken: &Parser.Token ) mut: Nodes.DeclMemberNode
{
      let mut nextToken = self.getToken(##);
      let mut mutMode = Ast.MutMode.IMut;
      switch nextToken.txt {
         case "mut" {
            mutMode = .Mut;
            nextToken = self.getToken(##);
         }
         case "allmut" {
            mutMode = .AllMut;
            nextToken = self.getToken(##);
         }
      }
      let varName = self.checkSymbol( nextToken, .MustNot_ );
      let mut token = self.getToken(##);
      let refType = self.analyzeRefType(
         accessMode, false, Ast.isPubToExternal( classTypeInfo.$accessMode ));
      token = self.getToken(##);

      // accessor
      let mut getterMode = Ast.AccessMode.None;
      let mut getterRetType = refType.$expType;
      let mut getterMutable = true;
      let mut setterMode = Ast.AccessMode.None;
      if token.txt == "{" {

         fn analyzeAccessorMode(): Ast.AccessMode, &Ast.TypeInfo, &Parser.Token
         {
            let mut retType = Ast.headTypeInfo;
            let mut mode = Ast.AccessMode.None;
            let mut workToken = self.getToken(##);
            switch workToken.txt {
               case "pub", "pri", "pro" {
                  mode = unwrap Ast.txt2AccessMode( workToken.txt );
                  workToken = self.getToken(##);
                  if workToken.txt == "&" {
                     getterMutable = false;
                     workToken = self.getToken(##);
                  }
                  if workToken.txt == ":" {
                     let typeNode = self.analyzeRefType(
                        mode, false, Ast.isPubToExternal( classTypeInfo.$accessMode ) );
                     retType = typeNode.$expType;
                     workToken = self.getToken(##);
                  }
               }
               case "non" {
                  workToken = self.getToken(##);
               }
               default {
                  self.addErrMess( workToken.pos,
                                   "access mode is invalid -- %s" (workToken.txt) );
               }
            }
            return mode, retType, workToken;
         }

         {
            let workRetType;
            getterMode, workRetType, nextToken = analyzeAccessorMode();
            if workRetType ~= Ast.headTypeInfo {
               if not workRetType.canEvalWith( getterRetType, .SetOp,
                                               classTypeInfo.createAlt2typeMap( false ) )
               {
                  self.addErrMess( firstToken.pos,
                                   "getter type mismatch -- %s <- %s"
                                   (workRetType.getTxt(##), getterRetType.getTxt(##)));
               }
               getterRetType = workRetType;
            }
         }
         if nextToken.txt == "," {
            let dummyRetType;
            setterMode, dummyRetType, nextToken = analyzeAccessorMode();
            if setterMode ~= .None and mutMode == .IMut {
               // immutable なメンバに setter 宣言は出来ない
               self.addErrMess(
                  varName.pos,
                  "This member can't have setter, this member is immutable. -- %s"
                  (varName.txt) );
            }
         }
         self.checkToken( nextToken, "}" );
         token = self.getToken(##);
      }

      self.checkToken( token, ";" );

      let mut typeInfo = refType.$expType;
      // if Ast.TypeInfo.isMut( typeInfo ) and mutMode == .IMut {
      //    typeInfo = self.createModifier( typeInfo, .IMut );
      // }
      if Ast.TypeInfo.isMut( typeInfo ) and typeInfo.$mutMode ~= mutMode {
         typeInfo = self.createModifier( typeInfo, mutMode );
      }
      if Ast.TypeInfo.isMut( getterRetType ) and getterRetType.$mutMode ~= mutMode {
         getterRetType = self.createModifier( getterRetType, mutMode );
      }

      if Ast.isPubToExternal( classTypeInfo.$accessMode ) {
         if Ast.isPubToExternal( accessMode ) or Ast.isPubToExternal( setterMode ) {
            self.checkPublic( refType.$pos, typeInfo );
         }
         if Ast.isPubToExternal( getterMode ) {
            self.checkPublic( refType.$pos, getterRetType );
         }
      }

      let symbolInfo, shadowing = self.scope.addMember(
         varName.txt, varName.pos, typeInfo, accessMode, staticFlag, mutMode );

      let workSym = unwrap (symbolInfo or shadowing);
      when! shadowing {
         self.errorShadowing( varName.pos, shadowing );
      }
      
      return Nodes.DeclMemberNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ],
         varName, refType, workSym, classTypeInfo, 
         staticFlag, accessMode, getterMutable, getterMode, getterRetType, setterMode );
   }

fn TransUnit.analyzeDeclMethod(
   classTypeInfo: &Ast.TypeInfo, declFuncMode: DeclFuncMode,
   abstractFlag: bool, overrideFlag: bool, accessMode: Ast.AccessMode,
   staticFlag: bool, firstToken: &Parser.Token, name: &Parser.Token ) mut : Nodes.Node
{
   let mut node = self.analyzeDeclFunc(
      declFuncMode, abstractFlag,
      overrideFlag, accessMode, staticFlag, classTypeInfo, name, name );
   return node;
}


/**
デフォルトコンストラクタの追加処理

@param pos クラスの定義位置
@param classTypeInfo クラス情報
@param classScope クラスのスコープ
@param memberNodeList メンバーノードリスト
@param methodNameSet メソッド名の集合
*/
fn TransUnit.addDefaultConstructor(
   pos:&Parser.Position, classTypeInfo:&Ast.TypeInfo,
   classScope:Ast.Scope, memberNodeList:&List<&Nodes.DeclMemberNode>,
   methodNameSet:Set<str>, oldFlag:bool ) mut
{
   if classScope.getTypeInfoChild( "__init" ) {
      self.addErrMess( pos, "already declare __init()." );
   }

   // デフォルトコンストラクタの引数の型リストを決定する
   let mut argTypeList:List<&Ast.TypeInfo> = [];

   if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
      // 継承している場合
      let superScope = unwrap classTypeInfo.$baseTypeInfo.$scope;
      let superTypeInfo = unwrap superScope.getTypeInfoChild( "__init" );
      foreach argType in superTypeInfo.$argTypeInfoList {
         if oldFlag {
            if not argType.$nilable {
               self.addErrMess( pos, "not found '__init' decl." );
            }
         }
         else {
            argTypeList.insert( argType );
         }
      }
   }

   foreach memberNode in memberNodeList {
      if not memberNode.$staticFlag {
         argTypeList.insert( memberNode.$expType );
      }
   }

   if Ast.isPubToExternal( classTypeInfo.$accessMode ) {
      // クラスが外部公開なら、
      // コンストラクタの型は全て外部公開可能でなければならない。
      foreach memberType in argTypeList {
         if not Ast.isPubToExternal( memberType.$accessMode ) {
            self.addErrMess(
               pos, "The type must be 'pub' becaue using in __init(). -- %s:%s"
               ( memberType.getTxt(##), memberType.$accessMode.$_txt ) );
         }
      }
   }

   // デフォルトコンストラクタの登録
   let mut ctorScope = self.pushScope( false ## );
   let initTypeInfo = Ast.NormalTypeInfo.createFunc(
      false, false, ctorScope, .Method, classTypeInfo,
      true, false, false, .Pub, "__init", nil, argTypeList, [] ## );
   if oldFlag {
      // oldFlag の場合は スコープに "" のシンボルを追加する
      ctorScope.addVar( .Pri, "", nil, Ast.headTypeInfo, .IMut, true);
   }
   self.popScope();
   classScope.addMethod( pos, initTypeInfo, .Pub, false, false );
   methodNameSet.add( "__init" );

   // メンバーをセット済みにする
   foreach memberNode in memberNodeList {
      if not memberNode.$staticFlag {
         memberNode.$symbolInfo.set_hasValueFlag( true );
      }
   }
}

/**
関数の本体ブロック処理

@param analyzingState 解析状態
@param firstToken エラー表示用トークン
@param classTypeInfo クラス情報。 メソッドでない場合は nil。
@param retTypeInfoList 関数の戻り値型リスト
@return Nodes.BlockNode 解析結果
*/
fn TransUnit.analyzeFuncBlock(
   analyzingState:AnalyzingState, firstToken: &Parser.Token,
   classTypeInfo:&Ast.TypeInfo!, funcTypeInfo:&Ast.TypeInfo, funcName:str,
   funcBodyScope:Ast.Scope, retTypeInfoList:&List<&Ast.TypeInfo> ) mut : Nodes.BlockNode
{
   if not funcTypeInfo.$staticFlag {
      when! classTypeInfo {
         if! let overrideType = self.scope.$parent.getTypeInfoField(
            funcName, false, funcBodyScope, self.scopeAccess )
         {
            if not overrideType.$abstractFlag {
               funcBodyScope.add( .Fun, false, false, "super", nil,
                                  overrideType, .Local, false, .IMut, true );
            }
         }
      }
   }

   self.pushAnalyzingState( analyzingState );

   let mut body = self.analyzeBlock( .Func, .Ignore, funcBodyScope );

   self.popAnalyzingState();

   if #retTypeInfoList ~= 0 {
      let breakKind = body.getBreakKind( .Return );
      if retTypeInfoList[ 1 ] ~= Ast.builtinTypeNeverRet {
         switch breakKind {
            case .Return, .NeverRet {
            }
            default {
               self.addErrMess( firstToken.pos,
                                "This funcion doesn't have return." );
            }
         }
      }
      else {
         if breakKind ~= .NeverRet {
            self.addErrMess( firstToken.pos,
                             "This funcion must be never return. -- %s"
                             (breakKind.$_txt ));
         }
      }
   }
   return body;
}


/**
クラスの本体部の解析。

@param classAccessMode クラスのアクセス制御
@param firstToken クラス定義の先頭トークン
@param mode クラス宣言モード
@param gluePrefix glue の prefix
@param classTypeInfo 宣言するクラスのタイプ
@param name クラス名のトークン
@param moduleName モジュール名
@param nextToken '{' の次のトークン。
@return Nodes.DeclClassNode クラス宣言のノード
@return &Parser.Token 解析終了後のトークン
@return Set<str> 定義されているメソッド名の Set
*/
fn TransUnit.analyzeClassBody(
   classAccessMode: Ast.AccessMode, firstToken: &Parser.Token,
   mode:DeclClassMode, gluePrefix:str!, classTypeInfo: &Ast.TypeInfo,
   name:&Parser.Token, moduleName: &Parser.Token!, mut nextToken:&Parser.Token ) mut :
   Nodes.DeclClassNode, &Parser.Token, Set<str>
{
   let mut memberName2Node: Map<str,&Nodes.DeclMemberNode> = {};
   let mut allStmtList: List<&Nodes.Node> = [];
   let mut declStmtList: List<&Nodes.Node> = [];
   let mut fieldList:List<&Nodes.Node> = [];
   let mut memberList:List<&Nodes.DeclMemberNode> = [];
   let mut methodNameSet: Set<str> = (@);
   //let mut initStmtList:List<&Nodes.Node> = [];
   let mut initBlockInfo = new Nodes.ClassInitBlockInfo(##);
   let mut advertiseList:Nodes.AdvertiseInfo[] = [];
   let mut trustList:List<&Ast.TypeInfo> = [];
   let mut uninitMemberList:List<&Ast.SymbolInfo> = [];
   let mut node = Nodes.DeclClassNode.create(
      self.nodeManager, firstToken.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ classTypeInfo ],
      classAccessMode, name, gluePrefix, moduleName, allStmtList,
      declStmtList, fieldList, memberList, self.scope, initBlockInfo,
      advertiseList, trustList, uninitMemberList, (@) );
   self.typeInfo2ClassNode[ classTypeInfo ] = node;
   let mut alreadyCtorFlag = false;
   let mut hasInitBlock = false;
   let mut hasStaticMember = false;

   fn processLet( token:&Parser.Token, staticFlag:bool, accessMode:Ast.AccessMode ) {
      if staticFlag {
         hasStaticMember = true;
      }
      if mode == .Interface {
         self.addErrMess( token.pos, "interface can not have member" );
      }
      if not staticFlag and alreadyCtorFlag {
         self.addErrMess(
            token.pos, "member can't declare after '__init' method." );
      }
      elseif staticFlag and hasInitBlock {
         self.addErrMess(
            token.pos, "static member can't declare after '__init' block." );
      }
      let memberNode = self.analyzeDeclMember(
         classTypeInfo, accessMode, staticFlag, token );
      allStmtList.insert( memberNode );
      fieldList.insert( memberNode );
      memberList.insert( memberNode );
      memberName2Node[ memberNode.$name.txt ] = memberNode;
   }

   /**
memberName2Node のメンバに値がセットされたかどうかを調べる。

@param staticFlag true の場合、 static メンバを調べる。
@param pos セットされていなかった場合のエラー表示位置。
nil の場合、メンバの宣言位置。
   */
   fn checkInitializeMember( staticFlag:bool, pos:&Parser.Position! ) {
      foreach memberNode, memberName in memberName2Node {
         if memberNode.$staticFlag == staticFlag {
            let symbolInfo = unwrap self.scope.getSymbolInfoChild( memberName );
            let typeInfo = symbolInfo.$typeInfo;
            if not symbolInfo.$hasValueFlag {
               if not typeInfo.$nilable {
                  let msg;
                  if staticFlag {
                     msg = "Set member -- %s" ( memberName );
                  }
                  else {
                     msg = "Set member -- %s.%s" ( name.txt, memberName );
                  }
                  self.addErrMess( unwrap pos default memberNode.$pos, msg );
               }
               else {
                  uninitMemberList.insert( symbolInfo );
               }
            }
         }
      }
   }

   fn processFn( token:&Parser.Token, staticFlag:bool, accessMode:Ast.AccessMode,
                 abstractFlag:bool, overrideFlag:bool ) {
      let nameToken = self.getSymbolToken( .MustNot_ );
      let mut declFuncMode = DeclFuncMode.Class;
      if mode == .Module {
         if gluePrefix {
            declFuncMode = .Glue;
         }
         else {
            declFuncMode = .Module;
         }
      }

      if nameToken.txt == "__init" {
         foreach symbolInfo, symbolName in self.scope.$symbol2SymbolInfoMap {
            if not symbolInfo.$staticFlag {
               // 一旦全てのメンバを値なし状態にセットする
               symbolInfo.set_hasValueFlag( false );
            }
         }
      }
      
      let methodNode = self.analyzeDeclMethod(
         classTypeInfo, declFuncMode, abstractFlag, overrideFlag,
         accessMode, staticFlag, token, nameToken );
      allStmtList.insert( methodNode );
      fieldList.insert( methodNode );
      methodNameSet.add( nameToken.txt );
      if nameToken.txt == "__init" {
         alreadyCtorFlag = true;

         checkInitializeMember( false, methodNode.$pos );
      }
   }

   fn processInitBlock( token:&Parser.Token ) {

      if classTypeInfo.$parentInfo.$scope ~= self.moduleScope {
         // top level クラスでないと、
         // static なメンバのライフタイム制御が難しいので現状はエラーとする。
         self.addErrMess(
            token.pos, "The '__init' block only support at the top level classes." );
      }
      
      // self.pushAnalyzingState( .InitBlock );

      if mode ~= .Class {
         self.error( "%s can not have __init block." (mode) );
      }
      hasInitBlock = true;
      foreach symbolInfo, symbolName in self.scope.$symbol2SymbolInfoMap {
         if symbolInfo.$staticFlag {
            // 一旦全てのメンバを値なし状態にセットする
            symbolInfo.set_hasValueFlag( false );
         }
      }

      let mut initBlockScope = self.pushScope( false## );
      self.prepareTentativeSymbol( initBlockScope, false );

      let ininame = "___init";
      let funcTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, initBlockScope, .Func, classTypeInfo,
         false, false, true, .Pri, ininame, nil, nil, nil, false );
      
      let block = self.analyzeFuncBlock(
         .InitBlock, token, classTypeInfo, funcTypeInfo, ininame, initBlockScope,
         funcTypeInfo.$retTypeInfoList );

      let mut info = new Nodes.DeclFuncInfo(
         .InitBlock, classTypeInfo, node,
         token, [], true, .Pri, block, [], false, false );
      let initBlockNode = Nodes.DeclMethodNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ funcTypeInfo ], info );
      initBlockInfo.set_func( initBlockNode );
      allStmtList.insert( initBlockNode );
      //fieldList.insert( initBlockNode );

      // foreach stmtNode in block.$stmtList {
      //    initStmtList.insert( stmtNode );
      // }
      

      // self.checkNextToken( "{" );
      // self.analyzeStatementList( initStmtList, "}" );
      // self.checkNextToken( "}" );

      self.popScope();
      self.finishTentativeSymbol( false );

      // self.popAnalyzingState();
   }

   fn processAdvertise() {
      let memberToken = self.getSymbolToken( .MustNot_ );
      nextToken = self.getToken(##);
      let mut prefix = "";
      if nextToken.txt ~= ";" and nextToken.txt ~= "{" {
         prefix = nextToken.txt;
         nextToken = self.getToken(##);
      }
      self.checkToken( nextToken, ";" );
      let! memberNode = memberName2Node[ memberToken.txt ] {
         self.error( "not found member -- %s" (memberToken.txt) );
      };
      advertiseList.insert(
         new Nodes.AdvertiseInfo( memberNode, prefix, memberToken.pos ) );
      self.advertisedTypeSet.add(
         memberNode.$expType.$srcTypeInfo.$genSrcTypeInfo );
   }

   fn processEnum( token:&Parser.Token, accessMode:Ast.AccessMode ) {
      if accessMode ~= .Pri and
          ( classAccessMode == .Pri or classAccessMode == .Local )
      {
         self.addErrMess( token.pos,
                          "unmatch access mode, class('%s') and enum('%s')"
                          (classAccessMode.$_txt, accessMode.$_txt ) );
      }
      let enumNode = self.analyzeDeclEnum( accessMode, token );
      allStmtList.insert( enumNode );
      declStmtList.insert( enumNode );
      
   }

   fn processLuneControl() {
      nextToken = self.getToken(##);

      let pragma;
      switch nextToken.txt {
         case "default__init" {
            pragma = LuneControl.Pragma.default__init;

            alreadyCtorFlag = true;
            
            self.addDefaultConstructor(
               nextToken.pos, classTypeInfo,
               self.scope, memberList, methodNameSet, false );
         }
         case "default__init_old" {
            pragma = LuneControl.Pragma.default__init_old;

            alreadyCtorFlag = true;
            self.addDefaultConstructor(
               nextToken.pos, classTypeInfo,
               self.scope, memberList, methodNameSet, true );
         }
         default {
            self.error( "unknown option -- %s" (nextToken.txt) );
         }
      }
      self.checkNextToken( ";" );

      let ctrlNode = Nodes.LuneControlNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], pragma );
      self.helperInfo.pragmaSet.add( pragma );
      allStmtList.insert( ctrlNode );
   }

   fn processClassFields(inMacro:bool) {
      while true {
         let mut token = self.getToken( inMacro );
         if token.kind == .Eof or token.txt == "}" {
            break;
         }
         let! mut accessMode = Ast.txt2AccessMode( token.txt ) {
            accessMode = .Pri;
         }
         then {
            token = self.getToken(##);
         };
         if mode == .Interface and accessMode ~= .Pub {
            self.addErrMess( token.pos, "interface's fields must be 'pub'." );
         }

         let mut staticFlag = false;
         if token.txt == "static" {
            staticFlag = true;
            token = self.getToken(##);
         }
         let mut overrideFlag = false;
         if token.txt == "override" {
            overrideFlag = true;
            token = self.getToken(##);
         }
         let mut abstractFlag = false;
         if token.txt == "abstract" {
            abstractFlag = true;
            token = self.getToken(##);
         }
         elseif mode == .Interface {
            // 現状 interface にデフォルト処理を書けない。
            abstractFlag = true;
         }


         if token.txt == "let" {
            processLet( token, staticFlag, accessMode );
         }
         elseif token.txt == "fn" {
            processFn( token, staticFlag, accessMode, abstractFlag, overrideFlag );
         }
         elseif token.txt == "__init" {
            processInitBlock( token );
         }
         elseif token.txt == "advertise" {
            processAdvertise();
         }
         elseif token.txt == ";" {
         }
         elseif token.txt == "enum" {
            processEnum( token, accessMode );
         }
         elseif token.txt == "_lune_control" {
            processLuneControl();
         }
         else {
            if! let symbolInfo = self.scope.getSymbolInfo(
               token.txt, self.scope, false, self.scopeAccess )
            {
               if symbolInfo.$kind == .Mac {

                  self.checkNextToken( "(" );

                  let mut alt2typeMap, argList = self.prepareExpCall(
                     token.pos, symbolInfo.$typeInfo, [], Ast.headTypeInfo );


                  self.evalMacroOp(
                     token, symbolInfo.$typeInfo, argList,
                     fn () {
                        processClassFields( true );
                     });

                  self.checkNextToken( ";" );
               }
               else {
                  self.error( "illegal field" );
               }
            }
            else {
               self.error( "illegal field" );
            }
         }
      }
   }

   processClassFields( false );

   if mode ~= .Module {
      // when! declCtorNode {
      //    foreach memberNode, memberName in memberName2Node {
      //       if not memberNode.$staticFlag {
      //          let symbolInfo = unwrap self.scope.getSymbolInfoChild( memberName );
      //          let typeInfo = symbolInfo.$typeInfo;
      //          if not symbolInfo.$hasValueFlag and not typeInfo.$nilable {
      //             self.addErrMess( declCtorNode.$pos,
      //                              "Set member -- %s.%s"
      //                              ( name.txt, memberName ) );
      //          }
      //       }
      //    }
      // }

      if hasStaticMember and not hasInitBlock {
         self.addErrMess(
            node.$pos,
            "This class (%s) need __init block for initialize static members." ( name.txt ) );
      }

      checkInitializeMember( true, nil );
   }

   return node, nextToken, methodNameSet;
}

fn TransUnit.analyzeDeclClass(
   classAbstructFlag: bool,  mut classAccessMode: Ast.AccessMode,
   firstToken: &Parser.Token, mode:DeclClassMode ) mut : Nodes.DeclClassNode
{
   if mode ~= .Module {
      switch self.getCurrentNamespaceTypeInfo().$kind {
         case .IF, .Class, .Module {
         }
         case .Func, .Method {
            switch classAccessMode {
               case .Pub, .Global {
                  self.addErrMess( firstToken.pos, "Class can't declare on here." );
               }
            }
         }
         default {
            self.addErrMess( firstToken.pos, "Class can't declare on here." );
         }
      }
   }

   let name = self.getSymbolToken( .MustNot_ );

   // generic の型宣言解析
   let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
   {
      let mut nextToken = self.getToken(##);
      if nextToken.txt == "<" {
         nextToken, altTypeList = self.analyzeDeclAlternateType(
            true, nextToken, classAccessMode );
      }
      self.pushbackToken( nextToken );
   }

   if classAccessMode == .Local {
      classAccessMode = .Pri;
   }

   let mut moduleName: &Parser.Token! = nil;
   let mut gluePrefix:str! = nil;
   if mode == .Module {
      self.checkNextToken( "require" );
      moduleName = self.getToken(##);
      let nextToken = self.getToken(##);
      if nextToken.txt == "glue" {
         gluePrefix = self.getToken(##).getExcludedDelimitTxt();
      }
      else {
         self.pushback();
      }
   }

   let existSymbolInfo = self.scope.getSymbolTypeInfo(
      name.txt, self.scope, self.scope, self.scopeAccess );

   let mut nextToken, classTypeInfo = self.analyzePushClass(
      mode ~= .Interface, classAbstructFlag,
      firstToken, name, true, classAccessMode, altTypeList );

   if self.protoClassMap[ classTypeInfo ] {
      self.protoClassMap[ classTypeInfo ] = nil;
   }
   else {
      if existSymbolInfo {
         self.addErrMess( name.pos, "already declare symbol -- %s" (name.txt) );
      }
   }


   let mut classScope = self.scope;

   self.checkToken( nextToken, "{" );


   let mapType = Ast.NormalTypeInfo.createMap(
      .Pub, classTypeInfo, Ast.builtinTypeString,
      self.createModifier( Ast.builtinTypeStem, .IMut ), .IMut );
   if classTypeInfo.isInheritFrom( Ast.builtinTypeMapping, nil ) {
      self.helperInfo.hasMappingClassDef = true;

      if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo and
         not classTypeInfo.$baseTypeInfo.isInheritFrom( Ast.builtinTypeMapping, nil ) {
         self.addErrMess(
            firstToken.pos,
            "must extend Mapping at %s" (classTypeInfo.$baseTypeInfo.getTxt(##) ) );
      }
      // _toMap の追加
      let toMapFuncTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, nil, .Method, classTypeInfo,
         true, false, false, .Pub, "_toMap", nil, [], [ mapType ], false );
      classScope.addMethod( nil, toMapFuncTypeInfo, .Pub, false, false );
   }




   let mut node, workNextToken, mut methodNameSet = self.analyzeClassBody(
      classAccessMode, firstToken, mode, gluePrefix,
      classTypeInfo, name, moduleName, nextToken );
   nextToken = workNextToken;


   let parentInfo = classTypeInfo;

   // accessor の生成
   foreach memberNode in node.$memberList {
      let memberType = memberNode.$expType;
      let memberName = memberNode.$name;
      // getter
      let getterName = "get_" .. memberName.txt;
      let mut accessMode = memberNode.$getterMode;
      let typeKind:Ast.TypeInfoKind;
      if memberNode.$staticFlag {
         typeKind = .Func;
      }
      else {
         typeKind = .Method;
      }
      if accessMode ~= .None and not classScope.getTypeInfoChild( getterName )
      {
         let mutable = memberNode.$getterMutable;
         let mut getterMemberType = memberNode.$getterRetType;
         if Ast.TypeInfo.isMut( getterMemberType ) and not mutable {
            getterMemberType = self.createModifier( getterMemberType, .IMut );
         }
         let retTypeInfo = Ast.NormalTypeInfo.createFunc(
            false, false, self.pushScope( false ## ),
            typeKind, parentInfo, true, false, memberNode.$staticFlag, accessMode,
            getterName, nil, [], [ getterMemberType ] ## );
         self.popScope();

         classScope.addMethod(
            memberName.pos, retTypeInfo, accessMode, memberNode.$staticFlag, false );
         methodNameSet.add( getterName );
      }
      // setter
      let setterName = "set_" .. memberName.txt;
      accessMode = memberNode.$setterMode;
      if memberNode.$setterMode ~= .None and
         not classScope.getTypeInfoChild( setterName )
      {
         let mutable;
         if memberType.$mutMode == .Mut {
            mutable = true;
         }
         else {
            mutable = false;
         }
         classScope.addMethod(
            memberName.pos,
            Ast.NormalTypeInfo.createFunc(
               false, false, self.pushScope( false ## ),
               typeKind, parentInfo, true, false, memberNode.$staticFlag, accessMode,
               setterName, nil, [ memberType ], nil, mutable ),
            accessMode, memberNode.$staticFlag, true );
         self.popScope();
         methodNameSet.add( setterName );
      }
   }

   // デフォルトコンストタクタ設定
   let mut ctorAccessMode = Ast.AccessMode.Pub;
   if! let ctorTypeInfo = classScope.getTypeInfoChild( "__init" ) {
      ctorAccessMode = ctorTypeInfo.$accessMode;
   }
   else {
      self.addDefaultConstructor(
         firstToken.pos, classTypeInfo,
         classScope, node.$memberList, methodNameSet, false );
   }


   // advertise の処理
   foreach advertiseInfo in node.$advertiseList {
      let mut memberType = advertiseInfo.$member.$expType;
      switch memberType.$kind {
         case .Class, .IF {
            foreach mtdName in Ast.getAllMethodName( memberType, .Object ).$list {
               let scope = unwrap memberType.$scope;
               let child = unwrap scope.getTypeInfoField( mtdName, true, scope, .Normal );
               if child.$accessMode ~= .Pri {
                  let childName = advertiseInfo.$prefix .. child.getTxt(##);
                  if not methodNameSet.has( childName ) {
                     let impMtdType = Ast.NormalTypeInfo.createAdvertiseMethodFrom(
                        classTypeInfo, child );
                     classScope.addMethod(
                        advertiseInfo.$pos, impMtdType,
                        child.$accessMode, child.$staticFlag, false );
                  }
               }
            }
         }
         default {
            self.error( "advertise member type is illegal -- %s"
                        (advertiseInfo.$member.$name) );
         }
      }
   }


   if classTypeInfo.isInheritFrom( Ast.builtinTypeMapping, nil ) {
      // Mapping の制限チェック
      let mut checkedTypeMap:Map<&Ast.TypeInfo,bool> = {};
      foreach memberNode in node.$memberList {
         let memberType = memberNode.$expType;
         //if not isAvailableMapping( memberType, checkedTypeMap ) {
         if not Ast.NormalTypeInfo.isAvailableMapping( memberType, checkedTypeMap ) {
            self.addErrMess(
               memberNode.$pos,
               "member type is not Mapping -- %s" ( memberType.getTxt(##)) );
         }
      }

      // _fromMap の追加
      let fromMapFuncTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, nil, .Func, classTypeInfo,
         true, false, true, .Pub, "_fromMap",
         nil, [ mapType.$nilableTypeInfo ],
         [ classTypeInfo.$nilableTypeInfo, Ast.builtinTypeString.$nilableTypeInfo ],
         true );
      classScope.addMethod( nil, fromMapFuncTypeInfo, ctorAccessMode, true, false );

      // _fromStem の追加
      let fromStemFuncTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, nil, .Func, classTypeInfo,
         true, false, true, .Pub, "_fromStem",
         nil, [ Ast.builtinTypeStem_ ],
         [ classTypeInfo.$nilableTypeInfo, Ast.builtinTypeString.$nilableTypeInfo ],
         true );
      classScope.addMethod( nil, fromStemFuncTypeInfo, ctorAccessMode, true, false );
   }

   // fn checkOverrideMethodSub( scope:&Ast.Scope ) {
   //    scope.filterTypeInfoField(
   //       true, classScope,
   //       fn ( symbolInfo:&Ast.SymbolInfo ): bool {
   //          if symbolInfo.$kind == .Mtd {
   //             let mut noImp = false;
   //             if! let impMethodType = classScope.getTypeInfoField(
   //                symbolInfo.$name, true, classScope )
   //             {
   //                if impMethodType.$abstractFlag {
   //                   noImp = true;
   //                }
   //             }
   //             else {
   //                noImp = true;
   //             }
   //             if noImp {
   //                self.addErrMess( firstToken.pos,
   //                                 "not implements method -- " .. symbolInfo.$name );
   //             }
   //          }
   //          return true;
   //       } );
   // }

   // if not classAbstructFlag {
   //    // extend のメソッドがオーバーライドされているか確認
   //    let mut workTypeInfo = classTypeInfo;
   //    repeat {
   //       if workTypeInfo ~= Ast.headTypeInfo {
   //          checkOverrideMethodSub( unwrap workTypeInfo.$scope );
   //       }
   //       foreach ifType in workTypeInfo.$interfaceList {
   //          checkOverrideMethodSub( unwrap ifType.$scope );
   //       }
   //       workTypeInfo = workTypeInfo.$baseTypeInfo;
   //    } workTypeInfo == Ast.headTypeInfo;
   // }

   self.popClass();

   return node;
}



pri fn TransUnit.addMethod(
   classTypeInfo: &Ast.TypeInfo, methodNode: Nodes.Node, name: str ) mut
{
   let mut classNodeInfo = unwrap self.typeInfo2ClassNode[ classTypeInfo ];

   classNodeInfo.$outerMethodSet.add( name );
   classNodeInfo.$fieldList.insert( methodNode );
}

fn TransUnit.processAddFunc(
   isFunc:bool, mut parentScope:Ast.Scope, name:&Parser.Token,
   typeInfo:&Ast.TypeInfo, alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo> ) mut
{
   let accessMode = typeInfo.$accessMode;
   if accessMode == .Global {
      //parentScope = Ast.rootScope;
      parentScope = self.globalScope;
   }

   let hasPrototype;
   if! let prottype = parentScope.getTypeInfoChild( typeInfo.$rawTxt ) {
      let argTypeList = typeInfo.$argTypeInfoList;
      let retTypeInfoList = typeInfo.$retTypeInfoList;
      {
         let matchFlag, err = Ast.TypeInfo.checkMatchType(
            prottype.$argTypeInfoList, argTypeList, false, nil, alt2typeMap );
         if matchFlag ~= .Match {
            self.addErrMess( name.pos, "mismatch functype param: " .. err );
         }
      }
      {
         let matchFlag, err = Ast.TypeInfo.checkMatchType(
            prottype.$retTypeInfoList, retTypeInfoList, false, nil, alt2typeMap );
         if matchFlag ~= .Match {
            self.addErrMess( name.pos, "mismatch functype ret: " .. err );
         }
      }
      if not typeInfo.canEvalWith( prottype, .SetOp, alt2typeMap ) {
         self.addErrMess( name.pos,
                          "mismatch functype -- %s / %s"
                          (typeInfo.$display_stirng, prottype.$display_stirng ) );
      }

      if self.protoFuncMap[ prottype ] {
         hasPrototype = true;
         self.protoFuncMap[ prottype ] = nil;
      }
      else {
         hasPrototype = false;
         if not prottype.$autoFlag {
            self.addErrMess( name.pos, "multiple define -- %s" (name.txt) );
         }
      }
   }
   else {
      hasPrototype = false;
   }

   if typeInfo.$kind == .Method and typeInfo.$accessMode ~= .Pri {
      let classType = typeInfo.$parentInfo;
      if self.advertisedTypeSet.has( classType ) and not hasPrototype {
         self.addErrMess(
            name.pos,
            "This class(%s) is used by advertise. You must declare the prototype of this method."
            (classType.getTxt( ## )) );
      }
   }
   


   let staticFlag = typeInfo.$staticFlag;
   let mutable = Ast.TypeInfo.isMut( typeInfo );
   if isFunc {
      let funcSym, shadowing = parentScope.addFunc(
         name.pos, typeInfo, accessMode, staticFlag, mutable );
      self.errorShadowing( name.pos, shadowing );
   }
   else {
      parentScope.addMethod( name.pos, typeInfo, accessMode, staticFlag, mutable );
   }
}

fn TransUnit.analyzeDeclFunc(
   declFuncMode: DeclFuncMode, abstractFlag: bool, overrideFlag: bool,
   mut accessMode: Ast.AccessMode,
   mut staticFlag: bool, mut classTypeInfo: &Ast.TypeInfo!,
   firstToken: &Parser.Token, mut name: &Parser.Token! ) mut : Nodes.Node
{
   let mut token = self.getToken(##);
   if! name {
      name = self.checkSymbol( _exp, .MustNot_ );
   }
   else {
      if token.txt ~= "(" {
         name = self.checkSymbol( token, .MustNot_ );
         token = self.getToken(##);
      }
   }
   if not name and ( Ast.isPubToExternal( accessMode ) or
                     abstractFlag or overrideFlag or staticFlag )
   {
      // anonymous 関数で pub 等が指定されているのはエラー
      self.addErrMess( firstToken.pos, "The anonymous function must be local." );
   }
   let mut needPopFlag = false;
   if token.txt == "." {
      needPopFlag = true;

      when! name {
         let className = name.txt;

         classTypeInfo = self.scope.getTypeInfoChild( className );

         when! classTypeInfo {
            // self.pushClass(
            //    name.pos, classTypeInfo.$kind == .Class,
            //    classTypeInfo.$abstractFlag, nil, nil, nil, false, className,
            //    classTypeInfo.$accessMode ## );
            self.pushClassScope( name.pos, classTypeInfo );
         }
         else {
            self.error( "not found class -- %s" (className) );
         }
      }
      else {
         self.error( "can't use '.' for any function name" );
      }

      name = self.getSymbolToken( .MustNot_ );
      token = self.getToken(##);

      if accessMode == .Local {
         accessMode = .Pri;
      }
   }


   let mut isCtorFlag = false;
   let mut kind = Nodes.NodeKind.$DeclConstr;
   let mut typeKind = Ast.TypeInfoKind.Func;
   when! classTypeInfo {
      if not staticFlag {
         typeKind = .Method;
      }
      switch (unwrap name).txt {
         case "__init" {
            isCtorFlag = true;
            kind = Nodes.NodeKind.$DeclConstr;
            foreach symbolInfo, symbolName in self.scope.$symbol2SymbolInfoMap {
               if not symbolInfo.$staticFlag {
                  // 一旦全てのメンバを値なし状態にセットする
                  symbolInfo.set_hasValueFlag( false );
               }
            }
         }
         case "__free" {
            kind = Nodes.NodeKind.$DeclDestr;
            if not self.targetLuaVer.$canUseMetaGc {
               self.addErrMess(
                  firstToken.pos, "this lua version is not support __free." );
            }
         }
         default {
            kind = Nodes.NodeKind.$DeclMethod;
         }
      }
   }
   else {
      kind = Nodes.NodeKind.$DeclFunc;
      if not staticFlag {
         staticFlag = true;
      }
   }

   let orgStaticFlag = staticFlag;
   if declFuncMode == .Module {
      // module で Lua の外部モジュールを宣言した場合、
      // モジュール名でメンバにアクセスできるように、
      // 強制的に static にする。
      staticFlag = true;
   }

   let mut funcName = "";
   when! name {
      funcName = name.txt;

      if kind == Nodes.NodeKind.$DeclFunc {
         switch accessMode {
            case .Pub, .Global {
               if self.scope ~= self.moduleScope {
                  self.addErrMess(
                     firstToken.pos,
                     "'global' or 'pub' function must exist top scope." );
               }
            }
         }
      }
   }


   let mut funcBodyScope = self.pushScope( false ## );
   
   let mut altTypeList:&List<&Ast.TypeInfo> = [];
   // generic 宣言
   if token.txt == "<" {
      token, altTypeList = self.analyzeDeclAlternateType( false, token, accessMode );
      foreach altType in altTypeList {
         funcBodyScope.addAlternate(
            accessMode, altType.$rawTxt, firstToken.pos, altType );
      }

   }

   self.checkToken( token, "(" );


   let parentPub;
   when! classTypeInfo {
      parentPub = Ast.isPubToExternal( classTypeInfo.$accessMode );
   }
   else {
      parentPub = Ast.isPubToExternal( accessMode );
   }
   
   let mut argList:List<&Nodes.Node> = [];
   token = self.analyzeDeclArgList( accessMode, funcBodyScope, argList, parentPub );

   self.checkToken( token, ")" );
   token = self.getToken(##);

   let mut mutable = false;
   if token.txt == "mut" {
      token = self.getToken(##);
      mutable = true;
   }

   let mut pubToExtFlag = Ast.isPubToExternal( accessMode );

   let mut argTypeList:List<&Ast.TypeInfo> = [];
   foreach argNode in argList {
      argTypeList.insert( argNode.$expType );
   }
   

   let mut alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
   when! classTypeInfo {
      alt2typeMap = classTypeInfo.createAlt2typeMap( false );

      if kind == Nodes.NodeKind.$DeclMethod or
         kind == Nodes.NodeKind.$DeclConstr or
         kind == Nodes.NodeKind.$DeclDestr
      {
         let mut workClass = classTypeInfo;
         if kind == Nodes.NodeKind.$DeclConstr or kind == Nodes.NodeKind.$DeclDestr {
            mutable = true;
         }
         // self シンボルを登録

         if not Ast.isPubToExternal( workClass.$accessMode ) {
            pubToExtFlag = false;
         }


         if Ast.TypeInfo.isMut( workClass ) and not mutable {
            workClass = self.createModifier( workClass, .IMut );
         }
         if not staticFlag {
            self.scope.add(
               .Arg, false, true, "self", nil,
               workClass, .Pri, false,
               mutable and Ast.MutMode.Mut or Ast.MutMode.IMut, true );
         }

         if not workClass.$abstractFlag and abstractFlag {
            self.addErrMess( firstToken.pos,
                             "no abstract class does not have abstract method" );
         }
      }
   }


   let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
   retTypeInfoList, token = self.analyzeRetTypeList(
      pubToExtFlag, accessMode, token, parentPub );

   let namespaceInfo = self.getCurrentNamespaceTypeInfo();

   let typeInfo = Ast.NormalTypeInfo.createFunc(
      abstractFlag, false, funcBodyScope,
      typeKind, namespaceInfo,
      false, false, staticFlag, accessMode,
      funcName, altTypeList, argTypeList, retTypeInfoList, mutable );

   when! name {
      self.processAddFunc(
         kind == Nodes.NodeKind.$DeclFunc,
         funcBodyScope.$parent, name, typeInfo, alt2typeMap );
   }

   if overrideFlag {
      // オーバーライドの型チェック
      if not name {
         self.addErrMess( firstToken.pos, "can't override anonymous func" );
      };
      if! let overrideType = self.scope.$parent.getTypeInfoField(
         funcName, false, funcBodyScope, self.scopeAccess )
      {
         if overrideType.get_accessMode() ~= accessMode {
            self.addErrMess( firstToken.pos, "mismatch override accessMode -- %s,%s,%s"
                             ( funcName, overrideType.get_accessMode().$_txt,
                               accessMode.$_txt ) );
         }
         if overrideType.get_staticFlag() ~= staticFlag {
            self.addErrMess( firstToken.pos,
                             "mismatch override staticFlag -- " .. funcName );
         }
         if overrideType.get_kind() ~= .Method {
            self.addErrMess( firstToken.pos, "mismatch override kind -- %s, %d"
                             ( funcName, overrideType.get_kind() ) );
         }
         if overrideType.$mutMode ~= typeInfo.$mutMode {
            self.addErrMess( firstToken.pos, "mismatch mutable -- %s" ( funcName ) );
         }

         if #overrideType.$itemTypeInfoList ~= #altTypeList {
            self.addErrMess( firstToken.pos,
                             "mismatch altTypeList -- %d, %d"
                             (#overrideType.$itemTypeInfoList, #altTypeList) );
         }
         else {
            foreach alterType, index in overrideType.$itemTypeInfoList {
               alt2typeMap[ alterType ] = altTypeList[ index ];
            }
         }

         if not overrideType.canEvalWith( typeInfo, .SetOp, alt2typeMap ) {
            self.addErrMess( firstToken.pos, "mismatch method type -- %s" (funcName));
         }
      }
      else {
         //Ast.dumpScope( self.scope.$parent, "" );
         self.addErrMess( firstToken.pos, "not found override -- " .. funcName );
      }
   }
   else {
      when! name {
         if name.txt ~= "__init" {
            if self.scope.$parent.getTypeInfoField(
               name.txt, false, funcBodyScope, self.scopeAccess ) {
               // override 宣言していないのに、オーバーライドしている場合エラー
               self.addErrMess( firstToken.pos, "mismatch override --" .. funcName );
            }
            else {
               if! let ifFunc =
                  self.scope.$parent.getSymbolInfoIfField(
                     name.txt, funcBodyScope, self.scopeAccess )
               {
                  if not ifFunc.$typeInfo.canEvalWith( typeInfo, .SetOp, alt2typeMap ) {
                     self.addErrMess( firstToken.pos,
                                      "mismatch method type -- %s" (funcName));
                  }
               }
            }
         }
      }
   }

   let mut node = self.createNoneNode( firstToken.pos );
   let mut needNode = false;

   // 関数 Body の解析
   let mut body:Nodes.BlockNode! = nil;
   if token.txt == ";" {
      // プロトタイプ宣言
      if declFuncMode == .Module or declFuncMode == .Glue {
         needNode = true;
      }
      else {
         if not abstractFlag {
            self.protoFuncMap[ typeInfo ] = firstToken.pos;
         }
         if classTypeInfo$.$kind == .IF {
            needNode = true;
         }
         else {
            if kind == Nodes.NodeKind.$DeclMethod {
               kind = Nodes.NodeKind.$ProtoMethod;
            }
         }
      }
   }
   else {
      needNode = true;

      if abstractFlag {
         self.addErrMess( token.pos, "abstract method can't have body." );
      }

      self.pushback();

      let analyzingState:AnalyzingState;
      if isCtorFlag {
         analyzingState = .Constructor;
      }
      elseif staticFlag and classTypeInfo {
         analyzingState = .ClassMethod;
      }
      else {
         analyzingState = .Func;
      }

      funcBodyScope.addLocalVar(
         false, false, "__func__", nil, Ast.builtinTypeString, .IMut );

      let mut workBody = self.analyzeFuncBlock(
         analyzingState, firstToken, classTypeInfo, typeInfo,
         funcName, funcBodyScope, typeInfo.$retTypeInfoList );
      body = workBody;

      if isCtorFlag {
         when! classTypeInfo {
            if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
               // Super クラスを持っている場合、
               // 先頭の処理で super() をコールしているか調べる
               let mut needCall = true;
               foreach stmt in workBody.$stmtList {
                  switch stmt.$kind {
                     case Nodes.nodeKind.ExpCallSuper {
                        needCall = false;
                     }
                     case Nodes.nodeKind.BlankLine {
                     }
                     default {
                        break;
                     }
                  }
               }
               if needCall {
                  self.addErrMess(
                     workBody.$pos,             
                     "__init must call super() with first." );
               }
            }
         }
      }
   }

   fn createDeclFuncInfo( funcKind:Nodes.FuncKind ): &Nodes.DeclFuncInfo {
      let classDeclNode:Nodes.DeclClassNode!;
      when! classTypeInfo {
         classDeclNode = self.typeInfo2ClassNode[ classTypeInfo ];
      }
      else {
         classDeclNode = nil;
      }
      return new Nodes.DeclFuncInfo(
         funcKind, classTypeInfo, classDeclNode, name, argList, orgStaticFlag, accessMode,
         body, retTypeInfoList, self.has__func__Symbol.has( typeInfo ), overrideFlag );
   }

   switch ( kind ) {
      case Nodes.NodeKind.$DeclConstr {
         let info = createDeclFuncInfo( .Ctor );
         node = Nodes.DeclConstrNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$DeclDestr {
         let info = createDeclFuncInfo( .Dstr );
         node = Nodes.DeclDestrNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$DeclMethod {
         let info = createDeclFuncInfo( .Mtd );
         node = Nodes.DeclMethodNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$ProtoMethod {
         let info = createDeclFuncInfo( .Mtd );
         node = Nodes.ProtoMethodNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$DeclFunc {
         let info = createDeclFuncInfo( .Func );
         node = Nodes.DeclFuncNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      default {
         self.error( "illegal kind -- %d" (kind) );
      }
   }
   self.has__func__Symbol.del( typeInfo );

   self.popScope();

   if needPopFlag {
      self.addMethod( unwrap classTypeInfo, node, funcName );
      self.popClass();
   }

   return node;
}

fn TransUnit.createExpListNode(
   orgExpList:&Nodes.ExpListNode, newExpList:&List<&Nodes.Node> ) mut: Nodes.ExpListNode
{
   // 引数リストを更新する
   let mut newExpTypeList:List<&Ast.TypeInfo> = [];
   foreach expNode, listIndex in newExpList {
      newExpTypeList.insert( expNode.$expType );
   }
   if #newExpList[ #newExpList ].$expTypeList > 1 {
      self.addErrMess( orgExpList.$pos, "illegal exp -- %d"
                       (#newExpList[ #newExpList ].$expTypeList) );
   }
   if! let mRetIndex = orgExpList.$mRetExp$.$index {
      if mRetIndex > #newExpList {
         self.addErrMess( orgExpList.$pos, "over index -- %d" (mRetIndex) );
      }
      // implicit cast 等で expTypeList が変更されるので、チェックしない。
      // elseif #newExpList[mRetIndex].$expTypeList == 1 {
      //    self.addErrMess( orgExpList.$pos, "unmatch mRetIndex -- %d" (mRetIndex) );
      // }
   }
   // 最終ノードが複数の値を持つ場合は、その型を追加する
   // foreach expType, listIndex in newExpList[ #newExpList ].$expTypeList {
   //    if listIndex ~= 1 {
   //       newExpTypeList.insert( expType );
   //    }
   // }
   return Nodes.ExpListNode.create(
      self.nodeManager, orgExpList.$pos,
      self.macroCtrl.isInAnalyzeArgMode(), newExpTypeList, newExpList,
      orgExpList.$mRetExp, orgExpList.$followOn );
}


fn TransUnit.checkLiteralEmptyCollection(
   pos:&Parser.Position, symbolName:str, expType:&Ast.TypeInfo ) mut
{
   foreach itemType in expType.$itemTypeInfoList {
      if itemType == Ast.builtinTypeNone {
         // [] や {} を型推論はできない。
         self.addErrMess(
            pos,
            "must set the item type of Collection. -- %s:%s"
            (symbolName, expType.$srcTypeInfo.getTxt( self.typeNameCtrl## ) ) );
         break;
      }
   }
}


class LetVarInfo {
   pub let mutable:Ast.MutMode;
   pub let varName: &Parser.Token;
   pub let varType:Nodes.RefTypeNode!;
}


/*
let で宣言している変数シンボル、型、初期値の型情報を解析して返す。

スコープへの変数シンボルの登録は行なわない。

@param firstPos エラー発生時に使用する位置情報
@param initMutable 変数の mutable 初期値。
   true を指定した場合、 mut を明示しなくても mutable として扱う。
@param accessMode アクセスモード
@param unwrapFlag unwrap して変数に初期値を格納するかどうか。
@return List<&Ast.TypeInfo> 型推論解決後の変数の型情報リスト
@return LetVarInfo[] 変数のシンボル等の情報リスト
@return List<&Ast.TypeInfo> unwrap 前の初期値のリスト
@return Nodes.ExpListNode! 初期値の ExpListNode。初期値が与えられていない場合は nil。
*/
fn TransUnit.analyzeLetAndInitExp(
   firstPos:&Parser.Position, initMutable:Ast.MutMode,
   accessMode:Ast.AccessMode, unwrapFlag:bool ) mut :
   List<&Ast.TypeInfo>, &List<&LetVarInfo>, &List<&Ast.TypeInfo>, Nodes.ExpListNode!
{
   // 宣言している変数の型リスト
   let mut typeInfoList : List<&Ast.TypeInfo> = [];
   // let で宣言している変数名と型の情報リスト
   let mut letVarList:List<&LetVarInfo> = [];

   let mut nextToken = Parser.getEofToken();

   repeat {
      // 変数名と : で明示している型情報を取得。
      let mut mutable = initMutable;
      nextToken = self.getToken(##);
      if nextToken.txt == "mut" {
         mutable = .Mut;
         nextToken = self.getToken(##);
      }
      let varName = self.checkSymbol( nextToken, .MustNot_ );
      nextToken = self.getToken(##);
      let mut typeInfo = Ast.builtinTypeEmpty;
      if nextToken.txt == ":" {
         // 型を明示している場合
         let refType = self.analyzeRefType(
            accessMode, false, Ast.isPubToExternal( accessMode ));
         letVarList.insert( new LetVarInfo( mutable, varName, refType ) );
         typeInfo = refType.$expType;
         nextToken = self.getToken(##);
      }
      else {
         // 型を明示していない場合、 mut でなければ .IMutRe とする
         letVarList.insert(
            new LetVarInfo( Ast.isMutable( mutable ) and mutable or Ast.MutMode.IMutRe,
                            varName, nil ) );
      }
      if not typeInfo.equals( Ast.builtinTypeEmpty ## ) and
         Ast.TypeInfo.isMut( typeInfo ) and not Ast.isMutable( mutable )
      {
         typeInfo = self.createModifier( typeInfo, .IMutRe );
      }
      typeInfoList.insert( typeInfo );
   } nextToken.txt ~= ",";

   // 初期値の式を取得
   let mut expList:Nodes.ExpListNode! = nil;
   if nextToken.txt == "=" {
      let mut expectTypeList:List<&Ast.TypeInfo> = [];
      foreach varInfo in letVarList {
         expectTypeList.insert(
            unwrap varInfo.varType$.$expType default Ast.builtinTypeNone );
      }
      
      expList = self.analyzeExpList( false, false, nil, expectTypeList ## );
      if not expList {
         self.error( "expList is nil" );
      }
   }
   else {
      self.pushback();
   }

   // unwrap 前の型
   let mut orgExpTypeList: List<&Ast.TypeInfo> = [];

   // 型推論の解決と、宣言されている型と初期値との整合性を確認
   when! expList {
      let mut updateExpList = false;
      let mut newExpList:List<&Nodes.Node> = [];
      foreach exp, index in expList.$expList {
         newExpList.insert( exp ) ;
         if not exp.canBeRight() {
            self.addErrMess( exp.$pos,
                             "this node(%d) can not be r-value. -- %s"
                             (index, Nodes.getNodeKindName( exp.$kind ) ) );
         }
      }

      //  初期化値の型を反映する
      let mut expTypeList: List<&Ast.TypeInfo> = [];
      foreach expType, index in expList.$expTypeList {
         let processedFlag = false;
         if index == #expList.$expTypeList and expType.$kind == .DDD
         {
            // 最終要素が ... の場合、残りの変数宣言の分 stem をセットする
            let mut dddItemType = Ast.builtinTypeStem_;
            if #expType.$itemTypeInfoList > 0 {
               dddItemType = expType.$itemTypeInfoList[ 1 ].$nilableTypeInfo;
            }
            for subIndex = index, #letVarList {
               let argType = typeInfoList[ subIndex ];
               let mut checkType = dddItemType;
               if unwrapFlag {
                  checkType = dddItemType.$nonnilableType;
               }
               if not argType.equals( Ast.builtinTypeEmpty ## ) and
                  not argType.canEvalWith( checkType, .SetOp, {} )
               {
                  self.addErrMess(
                     firstPos,
                     "unmatch value type (index = %d) %s) <- %s"
                     ( subIndex, argType.getTxt( self.typeNameCtrl## ),
                       dddItemType.getTxt(##) ));
               }
               expTypeList.insert( checkType );
               orgExpTypeList.insert( dddItemType );
            }
         }
         else {
            // 最終要素でない場合
            let mut expTypeInfo: &Ast.TypeInfo = expType;
            if expType.$kind == .DDD {
               let itemList = expType.$itemTypeInfoList;
               if #itemList > 0 {
                  expTypeInfo = itemList[ 1 ];
               }
               else {
                  expTypeInfo = Ast.builtinTypeStem_;
               }
            }
            orgExpTypeList.insert( expTypeInfo );
            if expTypeInfo == Ast.builtinTypeNil and index <= #typeInfoList {
               // 初期値が nil の場合、 orgExpTypeList は代入先の nilable 型とする
               orgExpTypeList[ index ] = typeInfoList[ index ].$nilableTypeInfo;
            }
            if unwrapFlag and expTypeInfo.$nilable {
               expTypeInfo = expTypeInfo.$nonnilableType;
            }

            if index <= #typeInfoList {
               let varType = typeInfoList[ index ];
               let mut alt2typeMap =
                  Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap(false);
               if varType.$kind == .Box {
                  alt2typeMap = varType.createAlt2typeMap( true );
               }
               Ast.CanEvalCtrlTypeInfo.setupNeedAutoBoxing( alt2typeMap );

               if not varType.equals( Ast.builtinTypeEmpty ## ) and
                  not varType.canEvalWith( expTypeInfo, .SetOp, alt2typeMap ) and
                  not (unwrapFlag and expTypeInfo.equals( Ast.builtinTypeNil ## ))
               {
                  self.addErrMess(
                     firstPos,
                     "unmatch value type (index:%d) %s <- %s"
                     (index,
                       varType.getTxt( self.typeNameCtrl ## ),
                       expTypeInfo.getTxt( self.typeNameCtrl ## )));
               }
               if varType.$kind == .Box {
                  typeInfoList[ index ] = Ast.NormalTypeInfo.createBox(
                     accessMode, expTypeInfo );
               }
               //if varType.$kind == .Box and expTypeInfo.$srcTypeInfo.$kind ~= .Box {
               if Ast.CanEvalCtrlTypeInfo.canAutoBoxing( varType, expTypeInfo ) {
                  // auto boxing
                  updateExpList = true;
                  let exp = newExpList[ index ];
                  newExpList[ index ] = Nodes.BoxingNode.create(
                     self.nodeManager, exp.$pos,
                     self.macroCtrl.isInAnalyzeArgMode(), [ varType ], exp );
                  if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 1 ) {
                     self.addErrMess( exp.$pos,
                                      "auto boxing error %s <- %s"
                                      ( varType.getTxt(##), expTypeInfo.getTxt(##)) );
                  }
               }
               else {
                  if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 0 ) {
                     self.addErrMess(
                        newExpList[ index ].$pos,
                        "illegal auto boxing error %s <- %s"
                        ( varType.getTxt(##), expTypeInfo.getTxt(##)) );
                  }
               }
            }
            expTypeList.insert( expTypeInfo );
         }
      }
      if updateExpList {
         // 引数リストを更新する
         expList = self.createExpListNode( expList, newExpList );
      }

      {
         let mut alt2typeMap =
            Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap(false);

         if! let mut workList = self.checkImplicitCast(
            alt2typeMap, typeInfoList, expList,
            fn ( dstType:&Ast.TypeInfo, expNode:&Nodes.Node ): &Nodes.Node! {
               return nil;
            } )
         {
            expList = workList;
         }
      }


      // 宣言する変数の数より初期値が少ない場合、
      // nil で初期化されるため変数が nilable かどうか判定
      foreach varType, index in typeInfoList {
         if index > #expTypeList {
            if not varType.$nilable {
               self.addErrMess(
                  firstPos,
                  "unmatch value type (index:%d) %s <- nil"
                  (index, varType.getTxt( self.typeNameCtrl## )));
            }
         }
      }
      // 変数の型を、型推論で初期値から設定
      foreach typeInfo, index in expTypeList {
         if #typeInfoList < index or
            typeInfoList[ index ].equals( Ast.builtinTypeEmpty ## )
         {
            let workPos;
            let workType;
            let workName;
            if index <= #letVarList { 
               workPos = letVarList[ index ].varName.pos;
               workName = letVarList[ index ].varName.txt;
               if Ast.TypeInfo.isMut( typeInfo ) and
                  not Ast.isMutable( letVarList[ index ].mutable )
               {
                  workType = self.createModifier( typeInfo, .IMutRe );
               }
               else {
                  workType = typeInfo;
               }
            }
            else {
               workType = typeInfo;
               workPos = firstPos;
               workName = "";
            }
            typeInfoList[ index ] = workType;

            switch workType.$kind {
               case .Func {
                  if #expTypeList ~= 1 or workType.$rawTxt ~= "" {
                     // anonymous 関数宣言の型推論変数宣言は、
                     // 通常関数宣言に置き換えるが、
                     // 2 つ以上の変数を宣言している場合はエラーとする。
                     self.addErrMess(
                        firstPos,
                        "must set the type of variable for function. -- %s"
                        (workName) );
                  }
               }
               case .List, .Array, .Set, .Map {
                  self.checkLiteralEmptyCollection( workPos, workName, workType );
               }
            }
         }
      }
   }

   return typeInfoList, letVarList, orgExpTypeList, expList;
}

fn TransUnit.analyzeDeclVar(
   mode:Nodes.DeclVarMode,
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut unwrapFlag = false;
   let mut token, continueFlag = self.getContinueToken();
   if continueFlag and token.txt == "!" {
      unwrapFlag = true;
   }
   else {
      self.pushback();
      if mode ~= .Let {
         Util.log( "need '!'" );
      }
   }

   if accessMode == .Pub {
      if self.scope ~= self.moduleScope {
         self.addErrMess( firstToken.pos, "'pub' variable must exist top scope." );
      }
   }

   let mut typeInfoList, mut letVarList, mut orgExpTypeList, mut expList =
      self.analyzeLetAndInitExp(
         firstToken.pos, mode == .Sync and Ast.MutMode.Mut or Ast.MutMode.IMut,
         accessMode, unwrapFlag );

   if mode == .Let and #typeInfoList == 1 {
      when! expList {
         let typeInfo = typeInfoList[ 1 ];
         let letVaInfo = letVarList[ 1 ];
         if #expList.$expList == 1 and typeInfo.$kind == .Func {
            if! let declNode = expList.$expList[ 1 ]@@@Nodes.DeclFuncNode {
               if not declNode.$declInfo.$name {
                  if Ast.isMutable( letVaInfo.mutable ) {
                     self.addErrMess(
                        letVaInfo.varName.pos, 
                        "Any function can't be mutable. -- %s" (letVaInfo.varName.txt) );
                  }
                  // anonymous 関数宣言の型推論変数宣言は、
                  // 通常関数宣言に置き換える。
                  // 次のような感じ。
                  // let func = fn () {}; → fn func() {}
                  let letVarInfo = letVarList[ 1 ];
                  let newTypeInfo = Ast.NormalTypeInfo.createFunc(
                     typeInfo.$abstractFlag, false, typeInfo.$scope,
                     typeInfo.$kind, typeInfo.$parentInfo,
                     false, false, typeInfo.$staticFlag, accessMode,
                     letVarInfo.varName.txt, typeInfo.$itemTypeInfoList,
                     typeInfo.$argTypeInfoList, typeInfo.$retTypeInfoList,
                     Ast.TypeInfo.isMut( typeInfo ) );
                  self.processAddFunc(
                     true, self.scope, letVarInfo.varName, newTypeInfo,
                     Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
                  self.nodeManager.delNode( declNode );

                  let mut declInfo = Nodes.DeclFuncInfo.createFrom(
                     declNode.$declInfo, letVarInfo.varName );
                  return Nodes.DeclFuncNode.create(
                     self.nodeManager, declNode.$pos,
                     self.macroCtrl.isInAnalyzeArgMode(), [ newTypeInfo ], declInfo );
               }
            }
         }
      }
   }


   let mut syncScope:Ast.Scope = self.scope;
   if mode == .Sync {
      syncScope = self.pushScope( false ## );
   }


   let mut symbolInfoList: List<&Ast.SymbolInfo> = [];

   let mut varList:List<&Nodes.VarInfo> = [];
   let mut syncSymbolList:List<&Nodes.VarInfo> = [];
   foreach letVarInfo, index in letVarList {
      let varName = letVarInfo.varName;
      let typeInfo = typeInfoList[ index ];
      let varInfo = new Nodes.VarInfo(
         varName, letVarInfo.varType, typeInfo );
      varList.insert( varInfo );

      if Ast.isPubToExternal( accessMode ) {
         self.checkPublic( varName.pos, typeInfo );
      }

      if not letVarInfo.varType and typeInfo.equals( Ast.builtinTypeNil ## ) {
         self.addErrMess(
            varName.pos, 'need type -- %s' ( varName.txt ) );
      }
      if mode == .Sync {
         // スコープに登録する前に、シンボルを検索
         if self.scope.getTypeInfo( varName.txt, self.scope, true, self.scopeAccess ) {
            syncSymbolList.insert( varInfo );
         }
      }
      // スコープに変数を登録
      if mode == .Let or mode == .Sync {
         if mode == .Let {
            self.checkShadowing( varName.pos, varName.txt, self.scope );
            // if self.scope.getTypeInfo( varName.txt, self.scope, true, self.scopeAccess ) {
            //    self.addErrMess( varName.pos,
            //                     "shadowing variable -- %s" (varName.txt) );
            // }
         }
         let mut orgExpType = Ast.builtinTypeStem_;
         if not unwrapFlag {
            orgExpType = Ast.builtinTypeEmpty;
         }
         if index <= #orgExpTypeList {
            orgExpType = orgExpTypeList[ index ];
         }

         let mut hasValue = false;
         if not unwrapFlag and orgExpType ~= Ast.builtinTypeEmpty or
            unwrapFlag and not orgExpType.$nilable
         {
            hasValue = true;
         }
         self.scope.addVar( accessMode, varName.txt, varName.pos,
                            typeInfo, letVarInfo.mutable, hasValue );
      }
      symbolInfoList.insert(
         unwrap self.scope.getSymbolInfo( varName.txt, self.scope,
                                          true, self.scopeAccess ) );
   }
   if mode ~= .Sync and self.macroScope {
      self.macroCtrl.registVar( symbolInfoList );
   }
   

   let mut unwrapBlock: Nodes.BlockNode! = nil;
   let mut thenBlock: Nodes.BlockNode! = nil;
   if unwrapFlag {
      let mut scope = self.pushScope( false ## );

      // unwrap ブロックに変数を登録
      foreach letVarInfo, index in letVarList {
         self.addLocalVar(
            letVarInfo.varName.pos, false, true,
            "_" .. letVarInfo.varName.txt, orgExpTypeList[ index ], .IMut ## );
      }

      unwrapBlock = self.analyzeBlock( .LetUnwrap, .Start, scope );
      self.popScope();

      // unwrap ブロック後には変数にデータがセットされているものとする。
      if mode == .Let or mode == .Sync {
         when! unwrapBlock {
            let breakKind = unwrapBlock.getBreakKind( .Normal );
            foreach letVarInfo in letVarList {
               let symbolInfo =
                  unwrap self.scope.getSymbolInfoChild( letVarInfo.varName.txt );
               if breakKind ~= .None {
                  self.tentativeSymbol.checkAndExclude( symbolInfo );
                  symbolInfo.set_hasValueFlag( true );
               }
               else {
                  if not self.tentativeSymbol.checkAndExclude( symbolInfo ) {
                     if not symbolInfo.$hasValueFlag {
                        self.addErrMess(
                           unwrapBlock.$pos,
                           "This variable isn't set -- " .. (symbolInfo.$name) );
                     }
                  }
               }
            }
         }
      }

      token = self.getToken( true );
      if token.txt == "then" {
         thenBlock = self.analyzeBlock( .LetUnwrapThenDo, .Finish, scope );
      }
      else {
         self.pushback();
         self.finishTentativeSymbol( true );
      }
   }

   let mut syncBlock: Nodes.BlockNode! = nil;
   if mode == .Sync {
      self.checkNextToken( "do" );
      syncBlock = self.analyzeBlock( .LetUnwrapThenDo, .Simple, syncScope );
      self.popScope();
   }

   self.checkNextToken( ";" );

   let mut node = Nodes.DeclVarNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], mode, accessMode, false,
      varList, expList, symbolInfoList, typeInfoList, unwrapFlag, unwrapBlock,
      thenBlock, syncSymbolList, syncBlock );

   return node;
}

/**
if! の解析。

@param firstToken if 部分のトークン
@return if! のノード
*/
fn TransUnit.analyzeIfUnwrap( firstToken: &Parser.Token ) mut : Nodes.IfUnwrapNode
{
   let mut nextToken = self.getToken(##);
   let mut typeInfoList:List<&Ast.TypeInfo> = [];
   let mut varNameList:List<&Parser.Token> = [];
   let mut expList:&Nodes.ExpListNode;
   let mut varList:List<&Ast.SymbolInfo> = [];

   if nextToken.txt == "let" {
      let mut workTypeInfoList, mut letVarList, mut orgExpTypeList, workExpList =
         self.analyzeLetAndInitExp( firstToken.pos, .IMut, .Local, true );
      typeInfoList = workTypeInfoList;
      when! workExpList {
         expList = workExpList;
      }
      else {
         self.addErrMess( nextToken.pos, "if! let has illegal init val." );
         self.error( "system error" );
      }
      foreach varInfo in letVarList {
         varNameList.insert( varInfo.varName );
      }
   }
   else {
      self.pushback();
      expList = self.analyzeExpList( false, false ## );
      let exp = expList.$expList[ 1 ];
      if exp.$expType.$nilable {
         typeInfoList.insert( exp.$expType.$nonnilableType );
      }
      else {
         typeInfoList.insert( exp.$expType );
      }
      varNameList.insert(
         new Parser.Token( .Symb, "_exp", firstToken.pos, false, nil ) );
   }

   let mut scope = self.pushScope( false ## );

   foreach expType, index in typeInfoList {
      if index > #varNameList {
         break;
      }
      let varName = varNameList[ index ];
      varList.insert(
         self.addLocalVar( varName.pos, false, true, varName.txt, expType, .IMut ## ) );
      
   }

   let block = self.analyzeBlock( .IfUnwrap, .Start, scope );

   self.popScope();

   let mut elseBlock:Nodes.BlockNode! = nil;
   nextToken = self.getToken( true );
   if nextToken.txt == "else" {
      elseBlock = self.analyzeBlock( .Else, .Finish ## );
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   let mut hasCond = false;
   foreach expNode, index in expList.$expList {
      if index ~= #expList.$expList {
         if Ast.isConditionalbe( expNode.$expType ) {
            hasCond = true;
            break;
         }
      }
      else {
         foreach expType in expNode.$expTypeList {
            if Ast.isConditionalbe( expType ) {
               hasCond = true;
               break;
            }
         }
      }
   }
   if not hasCond {
      self.addErrMess( firstToken.pos, "This condition never be false" );
   }

   return Nodes.IfUnwrapNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], varList, expList, block, elseBlock );
}

fn TransUnit.analyzeWhen( firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut nextToken, continueFlag = self.getContinueToken();
   //let mut varNameList:str[] = [];

   if not ( continueFlag and nextToken.txt == "!" ) {
      self.pushback();
      self.addErrMess( nextToken.pos, "'when' need '!'" );
   }

   let symListNode = self.analyzeExpList( false, false ## );

   let mut scope = self.pushScope( false ## );

   let mut expNodeList:List<&Nodes.Node> = [];
   let mut symPairList:List<&Nodes.UnwrapSymbolPair> = [];

   foreach expNode in symListNode.$expList {
      if! let refNode = expNode@@@Nodes.ExpRefNode {
         if expNode.$expType.$nilable {
            let symbolInfo = refNode.$symbolInfo;
            // varNameList.insert( refNode.$token.txt );
            let newSymbolInfo = self.addLocalVar(
               firstToken.pos, false, expNode.canBeLeft(), refNode.$symbolInfo.$name,
               expNode.$expType.$nonnilableType,
               symbolInfo.$mutable and Ast.MutMode.Mut or Ast.MutMode.IMut, true );
            symPairList.insert( new Nodes.UnwrapSymbolPair( symbolInfo, newSymbolInfo ) );
         }
         else {
            self.addErrMess( expNode.$pos,
                             "This type isn't nilable. -- %s"
                             ( expNode.$expType.getTxt(##) ) );
         }
      }
      else {
         self.addErrMess( expNode.$pos,
                          "'when' support only local variables or arguments." );
      }
   }

   let block = self.analyzeBlock( .When, .Start, scope );

   self.popScope();

   let mut elseBlock:Nodes.BlockNode! = nil;
   nextToken = self.getToken( true );
   if nextToken.txt == "else" {
      elseBlock = self.analyzeBlock( .Else, .Finish ## );
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   return Nodes.WhenNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], symPairList, block, elseBlock );
}
