/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

fn TransUnit.analyzeRefType( accessMode: Ast.AccessMode, allowDDD:bool ) mut:
   Ast.RefTypeNode
{
   let firstToken = self.getToken();
   let mut token = firstToken;
   let mut refFlag = false;
   if token.txt == "&" {
      refFlag = true;
      token = self.getToken();
   }
   let mut mutFlag = false;
   if token.txt == "mut" {
      mutFlag = true;
      token = self.getToken();
   }
   let mut typeInfo = Ast.builtinTypeStem_;
   self.checkSymbol( token );


   let name = self.analyzeExpSymbol( firstToken, token, .Symbol, nil, true );
   typeInfo = name.$expType;

   let continueToken, continueFlag = self.getContinueToken();
   token = continueToken;
   if continueFlag and token.txt == "!" {
      typeInfo = unwrap typeInfo.get_nilableTypeInfo();
      token = self.getToken();
   }

   let mut arrayMode = "no";
   while true {
      if token.txt == '[' or token.txt == '[@' {
         if token.txt == '[' {
            arrayMode = "list";
            typeInfo = Ast.NormalTypeInfo.createList(
               accessMode, self.getCurrentClass(), [ typeInfo ] );
         }   
         else {
            arrayMode = "array";
            typeInfo = Ast.NormalTypeInfo.createArray(
               accessMode, self.getCurrentClass(), [ typeInfo ] );
         }   
         token = self.getToken();
         if token.txt ~= ']' {
            self.pushback();
            self.checkNextToken( ']' );
         }   
      }   
      elseif token.txt == "<" {
         let mut genericList: List<&Ast.TypeInfo> = [];
         let mut nextToken: &Parser.Token = Parser.getEofToken();
         repeat {
            let typeExp = self.analyzeRefType( accessMode, false );

            genericList.insert( typeExp.$expType );
            nextToken = self.getToken();
         } nextToken.txt ~= ",";
         self.checkToken( nextToken, '>' );
         if typeInfo.$kind == .Map {
            typeInfo = Ast.NormalTypeInfo.createMap(
               accessMode, self.getCurrentClass(),
               genericList[1] or Ast.builtinTypeStem,
               genericList[2] or Ast.builtinTypeStem );
         }
         elseif typeInfo.$kind == .List {
            typeInfo = Ast.NormalTypeInfo.createList(
               accessMode, self.getCurrentClass(),
               [ genericList[1] ] or [ Ast.builtinTypeStem ] );
         }
         else {
            self.error( string.format( "not support generic: %s",
                                       typeInfo.getTxt() ) );
         }   
      }   
      else {
         self.pushback();
         break;
      }
      token = self.getToken();
   }
   if token.txt == "!" {
      typeInfo = unwrap typeInfo.get_nilableTypeInfo();
      token = self.getToken();
   }
   if not allowDDD and typeInfo.equals( Ast.builtinTypeDDD ) {
      self.addErrMess(
         firstToken.pos, "invalid type. -- '%s'" (typeInfo.getTxt() ) );
   }

   if refFlag {
      typeInfo = self.createModifier( typeInfo, false );
   }

   return Ast.RefTypeNode.create(
      self.nodeManager, firstToken.pos, [ typeInfo ],
      name, refFlag, mutFlag, arrayMode );
}

fn TransUnit.analyzeDeclArgList(
   accessMode:Ast.AccessMode, argList: List<&Ast.Node> ) mut : &Parser.Token
{
   let mut nextToken: &Parser.Token = Parser.noneToken;
   repeat {
      nextToken = self.getToken();
      if nextToken.txt == ")" {
         break;
      }
      let mut mutable = false;
      if nextToken.txt == "mut" {
         mutable = true;
         nextToken = self.getToken();
      }
      let mut argName = nextToken;
      if argName.txt == "..." {
         argList.insert( 
            Ast.DeclArgDDDNode.create(
               self.nodeManager, argName.pos, [ Ast.builtinTypeDDD ] ) );
         self.scope.addLocalVar(
            false, true, argName.txt, Ast.builtinTypeDDD, false );
      }
      else {
         argName = self.checkSymbol( argName );

         if self.scope.getSymbolTypeInfo( argName.txt, self.scope, self.moduleScope ) {
            self.addErrMess( argName.pos,
                             "shadowing variable -- %s" (argName.txt) );
         }

         self.checkNextToken( ":" );
         let refType = self.analyzeRefType( accessMode, false );
         let arg = Ast.DeclArgNode.create(
            self.nodeManager, argName.pos, refType.$expTypeList,
            argName, refType );    
         
         self.scope.addLocalVar( false, true, argName.txt, refType.$expType, mutable );
         argList.insert( arg );
      }
      nextToken = self.getToken();
   } nextToken.txt ~= ",";

   self.checkToken( nextToken, ")" );

   return nextToken;
}

pub class ASTInfo {
   pri let node: Ast.Node { pub };
   pri let moduleTypeInfo: Ast.TypeInfo { pub };
   pri let moduleSymbolKind: Ast.SymbolKind { pub };
}

pub fn TransUnit.createAST(
   parser: Parser.Parser, macroFlag: bool, moduleName: str! ) mut : ASTInfo
{
   self.moduleName = unwrap moduleName default "";

   self.registBuiltInScope();

   let mut moduleTypeInfo = Ast.headTypeInfo;
   let mut moduleSymbolKind = Ast.SymbolKind.Typ;

   if! moduleName {
      apply txt of string.gmatch( _exp, '[^%.]+' ) {
         // moduleTypeInfo = unwrap self.pushClass(
         //    true, false, nil, nil, false, txt@@str, "pub" );
         moduleTypeInfo = self.pushModule( false, txt@@str, true );
      }
   }
   self.moduleScope = self.scope;
   self.moduleType = moduleTypeInfo;

   
   self.parser = parser;

   let mut ast:Ast.Node! = nil;

   let mut lastStatement:Ast.Node! = nil;
   if macroFlag {
      ast = self.analyzeBlock( .Macro );
   }
   else {
      let mut children:List<&Ast.Node> = [];
      lastStatement = self.analyzeStatementList( children );

      let mut token = self.getTokenNoErr();
      if token ~= Parser.getEofToken() {
         Util.err( "%s:%d:%d:(%s) not eof -- %s"
                   ( self.parser.getStreamName(),
                     token.pos.lineNo, token.pos.column,
                     token.kind.$_txt, token.txt ) );
      }

      foreach subModule in self.subfileList {
         let! file = frontInterface.searchModule( subModule ) {
            self.error( "not found subfile -- %s" ( subModule ) );
         };

         if self.scope ~= self.moduleScope {
            self.error( "scope does not close" );
         }

         let! mut subParser = Parser.StreamParser.create( file, false, subModule ) {
            self.error( "open error -- %s" (file) );
         };

         self.parser = subParser;

         lastStatement = self.analyzeStatementListSubfile( children );

         token = self.getTokenNoErr();
         if token ~= Parser.getEofToken() {
            Util.err( "unknown:%d:%d:(%s) %s"
                      ( token.pos.lineNo, token.pos.column,
                        token.kind.$_txt, token.txt ) );
         }  
      }

      let mut luneHelperInfo = new Ast.LuneHelperInfo(
         self.useNilAccess, self.useUnwrapExp, self.hasMappingClassDef );
      let mut rootNode = Ast.RootNode.create(
         self.nodeManager, new Parser.Position( 0, 0 ),
         [ Ast.builtinTypeNone ], children,
         moduleTypeInfo, nil, luneHelperInfo, self.nodeManager,
         self.importModule2ModuleInfo, self.typeId2ClassMap );
      ast = rootNode;
      if! self.provideNode {
         if lastStatement ~= _exp {
            self.addErrMess( _exp.$pos, "'provide' must be last." );
         }
         rootNode.set_provide( _exp );
         moduleSymbolKind = _exp.$symbol.$kind;
      }
   }

   if! moduleName {
      apply txt of string.gmatch( _exp, '[^%.]+' ) {
         //self.popClass();
         self.popModule();
      }
   }

   foreach mess in self.warnMessList {
      Util.errorLog( mess );
   }
   if #self.errMessList > 0 {
      foreach mess in self.errMessList {
         Util.errorLog( mess );
      }
      Util.err( "has error" );
   }
   if self.analyzeMode == .Diag or self.analyzeMode == .Complete {
      os.exit( 0 );
   }

   return new ASTInfo( unwrap ast, moduleTypeInfo, moduleSymbolKind );
}


fn TransUnit.analyzeDeclMacro(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Ast.Node
{
   let nameToken = self.getToken();
   self.checkNextToken( "(" );

   let scope = self.pushScope( false );

   let mut workArgList: List<&Ast.Node> = [];
   let mut argList: List<&Ast.DeclArgNode> = [];
   let mut nextToken = self.analyzeDeclArgList( accessMode, workArgList );
   let mut argTypeList: List<&Ast.TypeInfo> = [];
   foreach argNode, index in workArgList {
      if argNode.$kind == Ast.nodeKindDeclArg {
         argList.insert( argNode@@Ast.DeclArgNode );
      }
      else {
         self.error( "macro argument can not use '...'." );
      }
      let argType = argNode.$expType;
      argTypeList.insert( argType );
   }


   self.checkNextToken( "{" );

   nextToken = self.getToken();

   let mut ast : Ast.Node! = nil;
   if nextToken.txt == "{" {
      let mut parser = new Parser.WrapParser(
         self.parser, "decl macro %s" (nameToken.txt) );

      // foreach symbolInfo, symbol in scope.$symbol2TypeInfoMap {
      //    scope.add( symbol, symbolInfo.$typeInfo, "local", false );
      // }

      self.macroScope = scope;
      
      let mut bakParser = self.parser;
      self.parser = parser;
      
      let mut stmtList:List<&Ast.Node> = [];
      self.analyzeStatementList( stmtList, "}" );
      self.checkNextToken( "}" );


      self.parser = bakParser;


      self.macroScope = nil;
      ast = Ast.BlockNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], .Macro, stmtList );
   }
   else {
      self.pushback();
   }

   self.popScope();

   
   let mut tokenList: List<&Parser.Token> = [];
   let mut braceCount = 0;

   while true {
      nextToken = self.getToken();
      if nextToken.txt == "{" {
         braceCount = braceCount + 1;
      }
      elseif nextToken.txt == "}" {
         if braceCount == 0 {
            break;
         }
         braceCount = braceCount - 1;
      }
      tokenList.insert( nextToken );
   }

   let typeInfo = Ast.NormalTypeInfo.createFunc(
      false, false, scope, .Macro, self.getCurrentNamespaceTypeInfo(),
      false, false, false, accessMode, nameToken.txt, argTypeList );
   self.scope.addLocalVar( false, false, nameToken.txt, typeInfo, false );


   let mut declMacroInfo = new Ast.DeclMacroInfo( nameToken, argList, ast, tokenList ) ;
   let mut node = Ast.DeclMacroNode.create(
      self.nodeManager, firstToken.pos, [ typeInfo ], declMacroInfo );

   let macroObj = self.macroEval.eval( node );

   self.typeId2MacroInfo[ typeInfo.get_typeId() ] =
      new Ast.MacroInfo( macroObj, declMacroInfo, self.symbol2ValueMapForMacro );
   self.symbol2ValueMapForMacro = {};

   return node;
}

fn TransUnit.analyzePushClass(
   classFlag: bool, abstructFlag: bool,
   firstToken:&Parser.Token, name:&Parser.Token, accessMode:Ast.AccessMode ) mut :
   &Parser.Token, &Ast.TypeInfo
{
   let mut nextToken = self.getToken();
   let mut baseRef:Ast.Node! = nil;
   let mut interfaceList:List<&Ast.TypeInfo> = [];
   if nextToken.txt == "extend" {
      nextToken = self.getToken();
      if nextToken.txt ~= "(" {
         self.pushback();
         sync! baseRef = self.analyzeRefType( accessMode, false ) {}
         do {
            if baseRef.$expType.$kind ~= .Class {
               self.addErrMess( baseRef.$pos,
                                "%s is not class." ( baseRef.$expType.getTxt() ) );
            }
         };
         nextToken = self.getToken();
      }
      if nextToken.txt == "(" {
         while true {
            nextToken = self.getToken();
            if nextToken.txt == ")" {
               break;
            }
            self.pushback();
            let ifType = self.analyzeRefType( accessMode, false );
            if ifType.$expType.$kind ~= .IF {
               self.error( "%s is not interface -- %d"
                           (ifType.$expType.getTxt(), ifType.$expType.$kind ) );
            }
            interfaceList.insert( ifType.$expType );
            nextToken = self.getToken();
            if nextToken.txt ~= "," {
               if nextToken.txt == ")" {
                  break;
               }
               self.error( "illegal token" );
            }
         }
         nextToken = self.getToken();
      }
   }

   let mut typeInfo:Ast.TypeInfo! = nil;
   if! baseRef {
      let baseTypeInfo = _exp.get_expType(); 
      typeInfo = baseTypeInfo;
      let! initTypeInfo = baseTypeInfo.$scope$.getTypeInfoChild$("__init") {
         // プロトタイプ宣言時は __init がないこともある。
      }     
      then {
         if initTypeInfo.$accessMode == .Pri {
            self.addErrMess(
               firstToken.pos, "The access mode of '__init' is 'pri'." );
         }
      };
   }
   
   let classTypeInfo = self.pushClass(
      classFlag, abstructFlag, typeInfo, interfaceList, false, name.txt, accessMode );
   return nextToken, classTypeInfo;
}

fn TransUnit.analyzeDeclProto(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Ast.Node
{
   let mut nextToken = self.getToken();
   let mut abstructFlag = false;
   if nextToken.txt == "abstruct" {
      abstructFlag = true;
      nextToken = self.getToken();
   }

   
   if nextToken.txt == "class" or nextToken.txt == "interface" {
      let name = self.getSymbolToken();
      
      nextToken = self.analyzePushClass(
         nextToken.txt ~= "interface", abstructFlag, firstToken, name, accessMode );
      self.popClass();
      self.checkToken( nextToken, ";" );
   }
   else {
      self.error( "illegal proto" );
   }
   return self.createNoneNode( firstToken.pos );
}

fn TransUnit.analyzeDeclEnum(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Ast.DeclEnumNode
{
   let name = self.getSymbolToken();

   self.checkNextToken( "{" );

   let mut valueList:List<&Parser.Token> = [];
   let mut valueName2Info:Map<str,Ast.EnumValInfo> = {};


   let mut scope = self.pushScope( true );

   let mut enumTypeInfo = Ast.headTypeInfo;
   
   let mut nextToken = self.getToken();
   let mut number = 0.0;
   let mut prevValTypeInfo = Ast.headTypeInfo;
   let mut valTypeInfo = Ast.headTypeInfo;
   while nextToken.txt ~= "}" {
      let valName = nextToken;
      nextToken = self.getToken();

      let mut enumVal:stem = number;
      switch ( prevValTypeInfo ) {
         case Ast.builtinTypeReal {
         }
         case Ast.builtinTypeInt, Ast.headTypeInfo {
            enumVal = number@@int;
         }
      }
      
      if nextToken.txt == "=" {
         let exp = self.analyzeExp( false );
         let valList, typeInfoList = exp.getLiteral();
         if #valList ~= 1 or #typeInfoList ~= 1 {
            self.error( "illegal enum val -- %d %d" ( #valList, #typeInfoList ) );
         }  
         valTypeInfo = typeInfoList[ 1 ];

         
         switch ( valTypeInfo ) {
            case Ast.builtinTypeString {
               enumVal = (unwrap valList[1])@@str;
            }  
            case Ast.builtinTypeInt {
               let val = (unwrap valList[1])@@int;
               enumVal = val;
               number = val@@real;
            }
            case Ast.builtinTypeReal {
               number = (unwrap valList[1])@@real;
               enumVal = number;
            }  
            default {
               self.error( "illegal enum val type -- %s"
                           (valTypeInfo.getTxt() ) );
            }
         }
         nextToken = self.getToken();
      }
      else {
         switch ( prevValTypeInfo ) {
            case Ast.headTypeInfo {
               valTypeInfo = Ast.builtinTypeInt;
            }
            case Ast.builtinTypeInt, Ast.builtinTypeReal {
               valTypeInfo = prevValTypeInfo;
            }
            default {
               self.addErrMess( valName.pos,
                                "illegal enum val type -- %s" (valTypeInfo.getTxt()) );
            }
         }
      }
      if prevValTypeInfo ~= Ast.headTypeInfo and prevValTypeInfo ~= valTypeInfo
      {        
         self.addErrMess( valName.$pos,
                          "multiple enum val type. %s, %s"
                          (valTypeInfo.getTxt(), prevValTypeInfo.getTxt()) );
      }
      prevValTypeInfo = valTypeInfo;

      if enumTypeInfo == Ast.headTypeInfo {
         enumTypeInfo = Ast.NormalTypeInfo.createEnum(
            scope, self.getCurrentNamespaceTypeInfo(),
            false, accessMode, name.txt, valTypeInfo, valueName2Info );
      }
      
      scope.addEnumVal( valName.txt, enumTypeInfo );
      let enumValInfo = new Ast.EnumValInfo( valName.txt, enumVal );
      valueList.insert( valName );
      valueName2Info[ valName.txt ] = enumValInfo;

      if nextToken.txt == "}" {
         break;
      }
      self.checkToken( nextToken, "," );
      nextToken = self.getToken();
      number = number + 1;
   }

   if enumTypeInfo == Ast.headTypeInfo {
      enumTypeInfo = Ast.NormalTypeInfo.createEnum(
         scope, self.getCurrentNamespaceTypeInfo(),
         false, accessMode, name.txt, Ast.builtinTypeNone, valueName2Info );
   }

   self.popScope();

   self.scope.addEnum( accessMode, name.txt, enumTypeInfo );

   
   return Ast.DeclEnumNode.create(
      self.nodeManager, firstToken.pos,
      [ enumTypeInfo ], accessMode, name, valueList, scope );
}


fn TransUnit.analyzeDecl(
   accessMode: Ast.AccessMode, mut staticFlag: bool,
   firstToken: &Parser.Token, mut token: &Parser.Token ) mut : Ast.Node!
{
   if not staticFlag {
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken();
      }
   }
   let mut overrideFlag = false;
   if token.txt == "override" {
      overrideFlag = true;
      token = self.getToken();
   }

   let mut abstructFlag = false;
   if token.txt == "abstruct" {
      abstructFlag = true;
      token = self.getToken();
   }

   if token.txt == "let" {
      return self.analyzeDeclVar( .Let, accessMode, firstToken );
   }
   elseif token.txt == "fn" {
      return self.analyzeDeclFunc(
         .Func, abstructFlag, overrideFlag,
         accessMode, staticFlag, nil, firstToken, nil );
   }
   elseif token.txt == "class" {
      return self.analyzeDeclClass( abstructFlag, accessMode, firstToken, .Class );
   }
   elseif token.txt == "interface" {
      return self.analyzeDeclClass( true, accessMode, firstToken, .Interface );
   }
   elseif token.txt == "module" {
      return self.analyzeDeclClass( false, accessMode, firstToken, .Module );
   }
   elseif token.txt == "proto" {
      return self.analyzeDeclProto( accessMode, firstToken );
   }
   elseif token.txt == "macro" {
      return self.analyzeDeclMacro( accessMode, firstToken );
   }
   elseif token.txt == "enum" {
      return self.analyzeDeclEnum( accessMode, firstToken );
   }  

   return nil;
}

fn TransUnit.analyzeDeclMember(
   accessMode: Ast.AccessMode, staticFlag: bool, firstToken: &Parser.Token ) mut:
   Ast.DeclMemberNode
{
      let mut nextToken = self.getToken();
      let mut mutable = false;
      if nextToken.txt == "mut" {
         mutable = true;
         nextToken = self.getToken();
      }
      let varName = self.checkSymbol(nextToken);
      let mut token = self.getToken();
      let refType = self.analyzeRefType( accessMode, false );
      token = self.getToken();

      let mut getterMode = Ast.AccessMode.None;
      let mut getterMutable = true;
      let mut setterMode = Ast.AccessMode.None;
      if token.txt == "{" {

         fn analyzeAccessorMode(): Ast.AccessMode, &Parser.Token
         {        
            let mut mode = Ast.AccessMode.None;
            let mut workToken = self.getToken();
            switch workToken.txt {
               case "pub", "pri", "pro" {
                  mode = unwrap Ast.txt2AccessMode( workToken.txt );
                  workToken = self.getToken();
                  if workToken.txt == "&" {
                     getterMutable = false;
                     workToken = self.getToken();
                  }
               }
            }
            return mode, workToken;
         }

         getterMode, nextToken = analyzeAccessorMode();
         if nextToken.txt == "," {
            setterMode, nextToken = analyzeAccessorMode();
         }
         self.checkToken( nextToken, "}" );
         token = self.getToken();
      }

      // accessor
      self.checkToken( token, ";" );

      let mut typeInfo = refType.$expType;
      if typeInfo.$mutable and not mutable {
         typeInfo = self.createModifier( typeInfo, false );
      }
         
      let symbolInfo = self.scope.addMember(
         varName.txt, typeInfo, accessMode, staticFlag, mutable );

      return Ast.DeclMemberNode.create(
         self.nodeManager, firstToken.pos, [ typeInfo ], varName, refType, symbolInfo,
         staticFlag, accessMode, getterMutable, getterMode, setterMode );
   }

fn TransUnit.analyzeDeclMethod(
   declFuncMode: DeclFuncMode,
   abstructFlag: bool, overrideFlag: bool, accessMode: Ast.AccessMode,
   staticFlag: bool, className: &Parser.Token,
   firstToken: &Parser.Token, name: &Parser.Token ) mut : Ast.Node
{
   let mut node = self.analyzeDeclFunc(
      declFuncMode, abstructFlag,
      overrideFlag, accessMode, staticFlag, className, name, name );
   return node;
}

fn TransUnit.analyzeClassBody(
   classAccessMode: Ast.AccessMode, firstToken: &Parser.Token,
   mode:DeclClassMode, gluePrefix:str!, classTypeInfo: &Ast.TypeInfo,
   name:&Parser.Token, moduleName: &Parser.Token!, mut nextToken:&Parser.Token ) mut :
   Ast.DeclClassNode, &Parser.Token, Map<str,bool>
{
   let mut memberName2Node: Map<str,Ast.DeclMemberNode> = {};
   let mut declStmtList: List<&Ast.Node> = [];
   let mut fieldList:List<&Ast.Node> = [];
   let mut memberList:List<&Ast.DeclMemberNode> = [];
   let mut methodNameSet: Map<str,bool> = {};
   let mut initStmtList:List<&Ast.Node> = [];
   let mut advertiseList:Ast.AdvertiseInfo[] = [];
   let mut trustList:List<&Ast.TypeInfo> = [];
   let mut node = Ast.DeclClassNode.create(
      self.nodeManager, firstToken.pos, [ classTypeInfo ],
      classAccessMode, name, gluePrefix, declStmtList, fieldList, moduleName,
      memberList, self.scope, initStmtList, advertiseList, trustList, {} );
   self.typeInfo2ClassNode[ classTypeInfo ] = node;
   let mut declCtorNode:Ast.Node! = nil;
   let mut hasInitBlock = false;
   let mut hasStaticMember = false;
   
   while true {
      let mut token = self.getToken();
      if token.txt == "}" {
         break;
      }   
      let! mut accessMode = Ast.txt2AccessMode( token.txt ) {
         accessMode = .Pri;
      }
      then {
         token = self.getToken();
      };
      if mode == .Interface and accessMode ~= .Pub {
         self.addErrMess( token.pos, "interface's fields must be 'pub'." );
      }
      
      let mut staticFlag = false;
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken();
      }   
      let mut overrideFlag = false;
      if token.txt == "override" {
         overrideFlag = true;
         token = self.getToken();
      }   
      let mut abstructFlag = false;
      if token.txt == "abstruct" {
         abstructFlag = true;
         token = self.getToken();
      }
      elseif mode == .Interface {
         // 現状 interface にデフォルト処理を書けない。
         abstructFlag = true;
      }
          

      if token.txt == "let" {
         if staticFlag {
            hasStaticMember = true;
         }
         if mode == .Interface {
            self.addErrMess( token.pos, "interface can not have member" );
         }
         if not staticFlag and declCtorNode {
            self.addErrMess(
               token.pos, "member can't declare after '__init' method." );
         }
         elseif staticFlag and hasInitBlock {
            self.addErrMess(
               token.pos, "static member can't declare after '__init' block." );
         }
         let memberNode = self.analyzeDeclMember( accessMode, staticFlag, token );
         fieldList.insert( memberNode );
         memberList.insert( memberNode );
         memberName2Node[ memberNode.$name.txt ] = memberNode;
      }
      elseif token.txt == "fn" {
         let nameToken = self.getSymbolToken();
         let mut declFuncMode = DeclFuncMode.Class;
         if mode == .Module {
            if gluePrefix {
               declFuncMode = .Glue;
            }
            else {
               declFuncMode = .Module;
            }
         }

         let methodNode = self.analyzeDeclMethod(
            declFuncMode, abstructFlag, overrideFlag,
            accessMode, staticFlag, name, token, nameToken );
         fieldList.insert( methodNode );
         methodNameSet[ nameToken.txt ] = true;
         if nameToken.txt == "__init" {
            declCtorNode = methodNode;
         }
      }
      elseif token.txt == "__init" {
         if mode ~= .Class {
            self.error( "%s can not have __init method" (mode) );
         }
         hasInitBlock = true;
         foreach symbolInfo, symbolName in self.scope.$symbol2TypeInfoMap {
            if symbolInfo.$staticFlag {
               // 一旦全てのメンバを値なし状態にセットする
               symbolInfo.set_hasValueFlag( false );
            }
         }
         
         self.checkNextToken( "{" );
         self.analyzeStatementList( initStmtList, "}" );
         self.checkNextToken( "}" );
      }
      elseif token.txt == "advertise" {
         let memberToken = self.getSymbolToken();
         nextToken = self.getToken();
         let mut prefix = "";
         if nextToken.txt ~= ";" and nextToken.txt ~= "{" {
            prefix = nextToken.txt;
            nextToken = self.getToken();
         }
         self.checkToken( nextToken, ";" );
         let! memberNode = memberName2Node[ memberToken.txt ] {
            self.error( "not found member -- %s" (memberToken.txt) );
         };
         advertiseList.insert( new Ast.AdvertiseInfo( memberNode, prefix ) );
      }
      elseif token.txt == ";" {
      }
      elseif token.txt == "enum" {
         if accessMode ~= .Pri and
             ( classAccessMode == .Pri or classAccessMode == .Local )
         {
            self.addErrMess( token.pos,
                             "unmatch access mode, class('%s') and enum('%s')"
                             (classAccessMode.$_txt, accessMode.$_txt ) );
         }
         declStmtList.insert( self.analyzeDeclEnum( accessMode, token ) );
      }
      else {
         self.error( "illegal field" );
      }
   }

   if mode ~= .Module {
      if! declCtorNode {
         foreach memberNode, memberName in memberName2Node {
            if not memberNode.$staticFlag {
               let symbolInfo = unwrap self.scope.getSymbolInfoChild( memberName );
               let typeInfo = symbolInfo.$typeInfo;
               if not symbolInfo.$hasValueFlag and not typeInfo.$nilable {
                  self.addErrMess( _exp.$pos,
                                   "does not set member -- %s.%s %s"
                                   ( name.txt, memberName, symbolInfo.$symbolId ) );
               }  
            }  
         }  
      }

      if hasStaticMember and not hasInitBlock {
         self.addErrMess(
            node.$pos,
            "This class (%s) need __init block for initialize static members." ( name.txt ) );   
      }  

      foreach memberNode, memberName in memberName2Node {
         if memberNode.$staticFlag {
            let symbolInfo = unwrap self.scope.getSymbolInfoChild( memberName );
            let typeInfo = symbolInfo.$typeInfo;
            if not symbolInfo.$hasValueFlag and not typeInfo.$nilable {
               self.addErrMess( memberNode.$pos,
                                "does not set member -- %s %s"
                                ( memberName, symbolInfo.$symbolId ) );
            }  
         }  
      }
   }

   return node, nextToken, methodNameSet;
}

fn TransUnit.analyzeDeclClass(
   classAbstructFlag: bool,  classAccessMode: Ast.AccessMode,
   firstToken: &Parser.Token, mode:DeclClassMode ) mut : Ast.DeclClassNode
{
   let name = self.getSymbolToken();

   let mut moduleName: &Parser.Token! = nil;
   let mut gluePrefix:str! = nil;
   if mode == .Module {
      self.checkNextToken( "require" );
      moduleName = self.getToken();
      let nextToken = self.getToken();
      if nextToken.txt == "glue" {
         gluePrefix = self.getToken().getExcludedDelimitTxt();
      }
      else {
         self.pushback();
      }
   }

   let mut nextToken, classTypeInfo = self.analyzePushClass(
      mode ~= .Interface, classAbstructFlag, firstToken, name, classAccessMode );

   let mut classScope = self.scope;

   self.checkToken( nextToken, "{" );

   let mut node, workNextToken, mut methodNameSet = self.analyzeClassBody(
      classAccessMode, firstToken, mode, gluePrefix,
      classTypeInfo, name, moduleName, nextToken );
   nextToken = workNextToken;
   

   let parentInfo = classTypeInfo;

   let mut memberTypeList:List<&Ast.TypeInfo> = [];

   // accessor の生成
   foreach memberNode in node.$memberList {
      let memberType = memberNode.$expType;
      if not memberNode.$staticFlag {
         memberTypeList.insert( memberType );
      }
      let memberName = memberNode.$name;
      // getter
      let getterName = "get_" .. memberName.txt;
      let mut accessMode = memberNode.$getterMode;
      if accessMode ~= .None and not classScope.getTypeInfoChild( getterName )
      {
         let mutable = memberNode.$getterMutable;
         let mut getterMemberType = memberType;
         if memberType.$mutable and not mutable {
            getterMemberType = self.createModifier( memberType, false );
         }
         let retTypeInfo = Ast.NormalTypeInfo.createFunc(
            false, false, self.pushScope( false ),
            .Method, parentInfo, true, false,
            memberNode.$staticFlag, accessMode,
            getterName, [], [ getterMemberType ] );
         self.popScope();
         
         classScope.addMethod(
            retTypeInfo, accessMode, memberNode.$staticFlag, false );
         methodNameSet[ getterName ] = true;
      }
      // setter
      let setterName = "set_" .. memberName.txt;
      accessMode = memberNode.$setterMode;
      if memberNode.$setterMode ~= .None and
         not classScope.getTypeInfoChild( setterName )
      {   
         classScope.addMethod(
            Ast.NormalTypeInfo.createFunc(
               false, false, self.pushScope( false ),
               .Method, parentInfo, true, false,
               memberNode.$staticFlag, accessMode,
               setterName, [ memberType ], nil, true 
            ), accessMode, memberNode.$staticFlag, true );
         self.popScope();
         methodNameSet[ setterName ] = true;
      }   
   }

   let mut ctorAccessMode = Ast.AccessMode.Pub;
   if! let ctorTypeInfo = classScope.getTypeInfoChild( "__init" ) {
      ctorAccessMode = ctorTypeInfo.$accessMode;
   }
   else {
      if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
         let superScope = unwrap classTypeInfo.$baseTypeInfo.$scope;
         let superTypeInfo = unwrap superScope.getTypeInfoChild( "__init" );
         foreach argType in superTypeInfo.$argTypeInfoList {
            if not argType.$nilable {
               self.addErrMess( firstToken.pos, "not found '__init' decl." );
            }
         }
      }
      
      // デフォルトコンストラクタの登録
      let initTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, self.pushScope( false ),
         .Method, parentInfo, true, false, false, .Pub,
         "__init", memberTypeList, [] );
      self.popScope();
      classScope.addMethod( initTypeInfo, .Pub, false, false );
      methodNameSet[ "__init" ] = true;

      // メンバーをセット済みにする
      foreach memberNode in node.$memberList {
         if not memberNode.$staticFlag {
            memberNode.$symbolInfo.set_hasValueFlag( true );
         }
      }
   }


   // advertise の処理
   foreach advertiseInfo in node.$advertiseList {
      let mut memberType = advertiseInfo.$member.$expType;
      switch memberType.$kind {
         case .Class, .IF {
            foreach child in memberType.$children {
               if child.$kind == .Method and
                  child.$accessMode ~= .Pri and
                  not child.$staticFlag
               {
                  let childName = advertiseInfo.$prefix .. child.getTxt();
                  if not methodNameSet[ childName ] {
                     let impMtdType = Ast.NormalTypeInfo.createAdvertiseMethodFrom(
                        classTypeInfo, child );
                     classScope.addMethod(
                        impMtdType, child.$accessMode, child.$staticFlag, false );
                  }
               }
            }
         }
         default {
            self.error( "advertise member type is illegal -- %s"
                        (advertiseInfo.$member.$name) );
         }
      }
   }


   if classTypeInfo.isInheritFrom( typeInfoMappingIF ) {
      self.hasMappingClassDef = true;
      
      if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo and
         not classTypeInfo.$baseTypeInfo.isInheritFrom( typeInfoMappingIF ) {
         self.addErrMess(
            firstToken.pos,
            "must extend Mapping at %s" (classTypeInfo.$baseTypeInfo.getTxt() ) );
      }
      
      // Mapping の制限チェック
      fn isAvailableMapping( typeInfo:&Ast.TypeInfo ): bool {
         switch typeInfo.$kind {
            case .Prim, .Enum {
               return true;
            }
            case .Stem {
               // stem は mapping 不能なデータもあるが、
               // それは実行時エラーとする。
               return true;
            }
            case .Class, .IF {
               if typeInfo.equals( Ast.builtinTypeString ) {
                  return true;
               }
               return typeInfo.isInheritFrom( typeInfoMappingIF );
            }
            case .List, .Array {
               return isAvailableMapping( typeInfo.$itemTypeInfoList[1] );
            }
            case .Map {
               if isAvailableMapping( typeInfo.$itemTypeInfoList[2] ) {
                  let keyType = typeInfo.$itemTypeInfoList[1];
                  if keyType.equals( Ast.builtinTypeString ) or
                     keyType.$kind == .Prim or keyType.$kind == .Enum
                  {
                     return true;
                  }
               }
               return false;
            }
            case .Nilable {
               return isAvailableMapping( typeInfo.$orgTypeInfo );
            }
            default {
               return false;
            }
         }
      }
      foreach memberNode in node.$memberList {
         let memberType = memberNode.$expType;
         if not isAvailableMapping( memberType ) {
            self.addErrMess(
               memberNode.$pos,
               "member type is not Mapping -- %s" ( memberType.getTxt()) );
         }
      }

      // _toMap の追加
      let mapType = self.createModifier( 
         Ast.NormalTypeInfo.createMap(
            .Pub, classTypeInfo, Ast.builtinTypeString,
            self.createModifier( Ast.builtinTypeStem, false ) ), false );
      let toMapFuncTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, nil, .Method, classTypeInfo,
         true, false, false, .Pub, "_toMap", [], [ mapType ], false );
      classScope.addMethod( toMapFuncTypeInfo, .Pub, false, false );

      // _fromMap の追加
      let fromMapFuncTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, nil, .Func, classTypeInfo,
         true, false, true, .Pub, "_fromMap",
         [ mapType ], [ classTypeInfo.$nilableTypeInfo ], true );
      classScope.addMethod( fromMapFuncTypeInfo, ctorAccessMode, true, false );

      // _fromStem の追加
      let fromStemFuncTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, nil, .Func, classTypeInfo,
         true, false, true, .Pub, "_fromStem",
         [ Ast.builtinTypeStem_ ], [ classTypeInfo.$nilableTypeInfo ], true );
      classScope.addMethod( fromStemFuncTypeInfo, ctorAccessMode, true, false );
   }
   
   fn checkOverrideMethod( scope:&Ast.Scope ) {
      scope.filterTypeInfoField(
         true, classScope,
         fn ( symbolInfo:&Ast.SymbolInfo ): bool {
            if symbolInfo.$kind == .Mtd {
               let mut noImp = false;
               if! let impMethodType = classScope.getTypeInfoField(
                  symbolInfo.$name, true, classScope )
               {              
                  if impMethodType.$abstructFlag {
                     noImp = true;
                  }
               }
               else {
                  noImp = true;
               }
               if noImp {
                  self.addErrMess( firstToken.pos,
                                   "not implements method -- " .. symbolInfo.$name );
               }
            }
            return true;
         } );
      
   }
   
   // extend のメソッドがオーバーライドされているか確認
   if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
      checkOverrideMethod( unwrap classTypeInfo.$baseTypeInfo.$scope );
   }
   foreach ifType in classTypeInfo.$interfaceList {
      checkOverrideMethod( unwrap ifType.$scope );
   }

   self.popClass();

   return node;
}   

pri fn TransUnit.addMethod( className: str, methodNode: Ast.Node, name: str ) mut {
   let classTypeInfo = self.scope.getTypeInfo(
      className, self.scope, false );
   let mut classNodeInfo = unwrap self.typeInfo2ClassNode[ classTypeInfo ];

   classNodeInfo.$outerMethodSet[ name ] = true;
   classNodeInfo.$fieldList.insert( methodNode );
}


fn TransUnit.analyzeDeclFunc(
   declFuncMode: DeclFuncMode, abstructFlag: bool, overrideFlag: bool,
   accessMode: Ast.AccessMode,
   mut staticFlag: bool, mut classNameToken: &Parser.Token!,
   firstToken: &Parser.Token, mut name: &Parser.Token! ) mut : Ast.Node
{
   let mut token = self.getToken();
   if! name {
      name = self.checkSymbol( _exp );
   }
   else {
      if token.txt ~= "(" {
         name = self.checkSymbol( token );
         token = self.getToken();
      }
   }
   let mut needPopFlag = false;
   if token.txt == "." {
      needPopFlag = true;
      classNameToken = name;
      
      let classTypeInfo = unwrap self.scope.getTypeInfoChild( (unwrap name).txt );

      self.pushClass(
         classTypeInfo.$kind == .Class,
         classTypeInfo.$abstructFlag, nil, nil, false, (unwrap name).txt, .Pub );

      name = self.getSymbolToken();
      token = self.getToken();
   }

   let mut kind = Ast.nodeKindDeclConstr;
   let mut typeKind = Ast.TypeInfoKind.Func;
   if classNameToken {
      if not staticFlag {
         typeKind = .Method;
      }
      switch (unwrap name).txt {
         case "__init" {
            kind = Ast.nodeKindDeclConstr;
            foreach symbolInfo, symbolName in self.scope.$symbol2TypeInfoMap {
               if not symbolInfo.$staticFlag {
                  // 一旦全てのメンバを値なし状態にセットする
                  symbolInfo.set_hasValueFlag( false );
               }  
            }
         }
         case "__free" {
            kind = Ast.nodeKindDeclDestr;
         }
         default {
            kind = Ast.nodeKindDeclMethod;
         }
      }
   }
   else {
      kind = Ast.nodeKindDeclFunc;
      if not staticFlag {
         staticFlag = true;
      }
   }

   let orgStaticFlag = staticFlag;
   if declFuncMode == .Module {
      // module で Lua の外部モジュールを宣言した場合、
      // モジュール名でメンバにアクセスできるように、
      // 強制的に static にする。
      staticFlag = true;
   }

   let mut funcName = "";
   if! name {
      funcName = _exp.txt;

      if kind == Ast.nodeKindDeclFunc {
         switch accessMode {
            case .Pub, .Global {
               if self.scope ~= self.moduleScope {
                  self.addErrMess(
                     firstToken.pos,      
                     "'global' or 'pub' function must exist top scope." );
               }
            }
         }
      }  
   }
   
   self.checkToken( token, "(" );

   let mut funcBodyScope = self.pushScope( false );

   let mut argList:List<&Ast.Node> = [];
   token = self.analyzeDeclArgList( accessMode, argList );
   let mut argTypeList:List<&Ast.TypeInfo> = [];
   foreach argNode in argList {
      argTypeList.insert( argNode.$expType );
   }

   self.checkToken( token, ")" );
   token = self.getToken();

   let mut mutable = false;
   if token.txt == "mut" {
      token = self.getToken();
      mutable = true;
   }

   let mut pubToExtFlag = Ast.isPubToExternal( accessMode );
   if kind == Ast.nodeKindDeclMethod or
      kind == Ast.nodeKindDeclConstr or
      kind == Ast.nodeKindDeclDestr
   {
      if kind == Ast.nodeKindDeclConstr or kind == Ast.nodeKindDeclDestr {
         mutable = true;
      }
      // self シンボルを登録
      let mut classTypeInfo:&Ast.TypeInfo = unwrap funcBodyScope.$parent.$ownerTypeInfo;
      if not Ast.isPubToExternal( classTypeInfo.$accessMode ) {
         pubToExtFlag = false;
      }

      
      if classTypeInfo.$mutable and not mutable {
         classTypeInfo = self.createModifier( classTypeInfo, false );
      }
      self.scope.add(
         .Var, false, true, "self",
         classTypeInfo, .Pri, false, mutable, true );

      if not classTypeInfo.$abstructFlag and abstructFlag {
         self.addErrMess( firstToken.pos,
                          "no abstruct class does not have abstruct method" );
      }
   }

   
   
   let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
   if token.txt == ":" {
      repeat {
         let refTypeNode = self.analyzeRefType( accessMode, true );
         let retType = refTypeNode.$expType;
         if pubToExtFlag and not Ast.isPubToExternal( retType.$accessMode )
         {
            self.addErrMess( refTypeNode.$pos,
                             "this is not public type -- %s" (retType.getTxt()) );
         }
         retTypeInfoList.insert( retType );
         token = self.getToken();
      } token.txt ~= ",";
   }

   let typeInfo = Ast.NormalTypeInfo.createFunc(
      abstructFlag, false, funcBodyScope,
      typeKind, self.getCurrentNamespaceTypeInfo(),
      false, false, staticFlag, accessMode,
      funcName, argTypeList, retTypeInfoList, mutable );
   
   if! name {
      let mut parentScope = funcBodyScope.get_parent();
      if accessMode == .Global {
         parentScope = Ast.rootScope;
      }
      
      if kind == Ast.nodeKindDeclFunc {
         parentScope.addFunc( typeInfo, accessMode, staticFlag, mutable );
      }
      else {
         parentScope.addMethod( typeInfo, accessMode, staticFlag, mutable );
      }
   }

   if overrideFlag {
      // オーバーライドの型チェック
      if not name {
         self.addErrMess( firstToken.pos, "can't override anonymous func" );
      };
      let! overrideType =
         self.scope.$parent.getTypeInfoField( funcName, false, funcBodyScope )
      {
         self.addErrMess( firstToken.pos, "not found override -- " .. funcName );
      }
      then {
         if overrideType.get_accessMode() ~= accessMode {
            self.addErrMess( firstToken.pos, "mismatch override accessMode -- %s,%s,%s"
                             ( funcName, overrideType.get_accessMode().$_txt,
                               accessMode.$_txt ) );
         }  
         if overrideType.get_staticFlag() ~= staticFlag {
            self.addErrMess( firstToken.pos,
                             "mismatch override staticFlag -- " .. funcName );
         }  
         if overrideType.get_kind() ~= .Method {
            self.addErrMess( firstToken.pos, "mismatch override kind -- %s, %d"
                             ( funcName, overrideType.get_kind() ) );
         }
         if overrideType.$mutable ~= typeInfo.$mutable {
            self.addErrMess( firstToken.pos, "mismatch mutable -- %s" ( funcName ) );
         }
         if not overrideType.canEvalWith( typeInfo, "=" ) {
            self.addErrMess( firstToken.pos, "mismatch method type -- %s" (funcName));
         }
      };
   }
   else {
      if! name {
         if _exp.txt ~= "__init" and
            self.scope.$parent.getTypeInfoField( _exp.txt, false, funcBodyScope )
         {          
            // override 宣言していないのに、オーバーライドしている場合エラー
            self.error( "mismatch override --" .. funcName );
         }
      }
   }

   let mut node = self.createNoneNode( firstToken.pos );
   let mut needNode = false;

   let mut body:Ast.BlockNode! = nil;
   if token.txt == ";" {
      if declFuncMode == .Module or declFuncMode == .Glue {
         needNode = true;
      }
   }
   else {
      needNode = true;
      if abstructFlag {
         self.addErrMess( token.pos, "abstruct method can't have body." );
      }

      let __func__Symbol = funcBodyScope.addLocalVar(
         false, false, "__func__", Ast.builtinTypeString, false );
      self.has__func__Symbol = false;
      
      self.pushback();
      body = self.analyzeBlock( .Func, funcBodyScope );
   }

   if needNode {
      let mut info = new Ast.DeclFuncInfo(
         classNameToken, name, argList, orgStaticFlag, accessMode,
         body, retTypeInfoList, self.has__func__Symbol );
      // node = self.createNode( kind, firstToken.pos, [ typeInfo ], info );

      switch ( kind ) {
         case Ast.nodeKindDeclConstr {
            node = Ast.DeclConstrNode.create(
               self.nodeManager, firstToken.pos, [ typeInfo ], info );
         }
         case Ast.nodeKindDeclDestr {
            node = Ast.DeclDestrNode.create(
               self.nodeManager, firstToken.pos, [ typeInfo ], info );
         }
         case Ast.nodeKindDeclMethod {
            node = Ast.DeclMethodNode.create(
               self.nodeManager, firstToken.pos, [ typeInfo ], info );
         }
         case Ast.nodeKindDeclFunc {
            node = Ast.DeclFuncNode.create(
               self.nodeManager, firstToken.pos, [ typeInfo ], info );
         }
         default {
            self.error( "illegal kind -- %d" (kind) );
         }
      }
   }

   self.popScope();

   if needPopFlag {
      self.addMethod( (unwrap classNameToken).txt, node, funcName );
      self.popClass();
   }

   return node;
}

class LetVarInfo {
   pub let mutable:bool;
   pub let varName: &Parser.Token;
   pub let varType:Ast.RefTypeNode!;
}


/*
let で宣言している変数シンボル、型、初期値の型情報を解析して返す。

スコープへの変数シンボルの登録は行なわない。

@param firstPos エラー発生時に使用する位置情報
@param initMutable 変数の mutable 初期値。
   true を指定した場合、 mut を明示しなくても mutable として扱う。
@param accessMode アクセスモード
@param unwrapFlag unwrap して変数に初期値を格納するかどうか。
@return List<&Ast.TypeInfo> 型推論解決後の変数の型情報リスト
@return LetVarInfo[] 変数のシンボル等の情報リスト
@return List<&Ast.TypeInfo> unwrap 前の初期値のリスト
@return Ast.ExpListNode! 初期値の ExpListNode。初期値が与えられていない場合は nil。
*/
fn TransUnit.analyzeLetAndInitExp(
   firstPos:&Parser.Position, initMutable:bool,
   accessMode:Ast.AccessMode, unwrapFlag:bool ) mut :
   List<&Ast.TypeInfo>, LetVarInfo[], List<&Ast.TypeInfo>, Ast.ExpListNode!
{
   let mut typeInfoList : List<&Ast.TypeInfo> = [];
   let mut letVarList:LetVarInfo[] = [];

   let mut nextToken = Parser.getEofToken();
   
   repeat {
      // 変数名と : で明示している型情報を取得。
      let mut mutable = initMutable;
      nextToken = self.getToken();
      if nextToken.txt == "mut" {
         mutable = true;
         nextToken = self.getToken();
      }
      let varName = self.checkSymbol( nextToken );
      nextToken = self.getToken();
      let mut typeInfo = Ast.builtinTypeNone;
      if nextToken.txt == ":" {
         let refType = self.analyzeRefType( accessMode, false );
         letVarList.insert( new LetVarInfo( mutable, varName, refType ) );
         typeInfo = refType.$expType;
         nextToken = self.getToken();
      }
      else {
         letVarList.insert( new LetVarInfo( mutable, varName, nil ) );
      }
      if not typeInfo.equals( Ast.builtinTypeNone ) and
         typeInfo.$mutable and not mutable
      {     
         typeInfo = self.createModifier( typeInfo, false );
      }
      typeInfoList.insert( typeInfo );
   } nextToken.txt ~= ",";

   // 初期値の式を取得
   let mut expList:Ast.ExpListNode! = nil;
   if nextToken.txt == "=" {
      expList = self.analyzeExpList( false );
      if not expList {
         self.error( "expList is nil" );
      }
   }

   // unwrap 前の型
   let mut orgExpTypeList: List<&Ast.TypeInfo> = [];
   
   // 型推論の解決と、宣言されている型と初期値との整合性を確認
   if! expList {
      foreach exp, index in _exp.$expList {
         if not exp.canBeRight() {
            self.addErrMess( exp.$pos,
                             "this node can not be r-value. -- %s"
                             (Ast.getNodeKindName( exp.$kind ) ) );
         }
      }

      //  初期化値の型を反映する
      let mut expTypeList: List<&Ast.TypeInfo> = [];
      foreach expType, index in _exp.$expTypeList {
         let processedFlag = false;
         if index == #_exp.$expTypeList and
            _exp.$expTypeList[ index ].equals( Ast.builtinTypeDDD )
         {        
            // 最終要素が ... の場合
            // ... なら、残りの変数宣言の分 stem をセットする
            for subIndex = index, #letVarList {
               let argType = typeInfoList[ subIndex ];
               let mut checkType = Ast.builtinTypeStem_;
               if unwrapFlag {
                  checkType = Ast.builtinTypeStem;
               }
               if not argType.equals( Ast.builtinTypeNone ) and
                  not argType.canEvalWith( checkType, "=" )
               {
                  self.addErrMess(
                     firstPos,
                     "unmatch value type (index = %d) %s(%d) <- %s(%d)"
                     ( subIndex, argType.getTxt(), argType.$typeId,
                       Ast.builtinTypeStem_.getTxt(), Ast.builtinTypeStem_.$typeId ));
               }
               expTypeList.insert( checkType );
               orgExpTypeList.insert( Ast.builtinTypeStem_ );
            }
         }
         else {
            // 最終要素でない場合
            let mut expTypeInfo: &Ast.TypeInfo = expType;
            if expType.equals( Ast.builtinTypeDDD ) {
               expTypeInfo = Ast.builtinTypeStem_;
            }
            orgExpTypeList.insert( expTypeInfo );
            if unwrapFlag and expTypeInfo.$nilable {
               expTypeInfo = unwrap expTypeInfo.$orgTypeInfo;
            }

            if index <= #typeInfoList {
               let argType = typeInfoList[ index ];
               if not argType.equals( Ast.builtinTypeNone ) and
                  not argType.canEvalWith( expTypeInfo, "=" ) and
                  not (unwrapFlag and expTypeInfo.equals( Ast.builtinTypeNil ))
               {               
                  self.addErrMess(
                     firstPos,
                     "unmatch value type (index:%d) %s <- %s"
                     (index, argType.getTxt(), expTypeInfo.getTxt()));
               }
            }
            expTypeList.insert( expTypeInfo );
         }
      }
      // 宣言する変数の数より初期値が少ない場合、
      // nil で初期化されるため変数が nilable かどうか判定
      foreach varType, index in typeInfoList {
         if index > #expTypeList {
            if not varType.$nilable {
               self.addErrMess(
                  firstPos,
                  "unmatch value type (index:%d) %s <- nil"
                  (index, varType.getTxt()));
            }
         }
      }
      // 変数の型を、型推論で初期値から設定
      foreach typeInfo, index in expTypeList {
         if #typeInfoList < index or
            typeInfoList[ index ].equals( Ast.builtinTypeNone )
         {
            if typeInfo.$mutable and
               index <= #letVarList and not letVarList[ index ].mutable
            {
               typeInfoList[ index ] = self.createModifier( typeInfo, false );
            }
            else {
               typeInfoList[ index ] = typeInfo;
            }
         }
      }
   }

   return typeInfoList, letVarList, orgExpTypeList, expList;
}

fn TransUnit.analyzeDeclVar(
   mode:Ast.DeclVarMode,
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Ast.Node
{
   let mut unwrapFlag = false;
   let mut token, continueFlag = self.getContinueToken();
   if continueFlag and token.txt == "!" {
      unwrapFlag = true;
   }
   else {
      self.pushback();
      if mode ~= .Let {
         Util.log( "need '!'" );
      }
   }

   if accessMode == .Pub {
      if self.scope ~= self.moduleScope {
         self.addErrMess( firstToken.pos, "'pub' variable must exist top scope." );
      }
   }

   let mut typeInfoList, mut letVarList, mut orgExpTypeList, mut expList =
      self.analyzeLetAndInitExp( firstToken.pos, mode == .Sync, accessMode, unwrapFlag );
   

   if mode ~= .Sync and self.macroScope {
      foreach letVarInfo, index in letVarList {
         let typeInfo = typeInfoList[ index ];
         
         self.symbol2ValueMapForMacro[ letVarInfo.varName.txt ] =
            new Ast.MacroValInfo( nil, typeInfo);
      }
   }

   let mut syncScope:Ast.Scope = self.scope;
   if mode == .Sync {
      syncScope = self.pushScope( false );
   }


   let mut symbolInfoList: List<&Ast.SymbolInfo> = [];
   
   let mut varList:List<&Ast.VarInfo> = [];
   let mut syncSymbolList:List<&Ast.VarInfo> = [];
   foreach letVarInfo, index in letVarList {
      let varName = letVarInfo.varName;
      let typeInfo = typeInfoList[ index ];
      let varInfo = new Ast.VarInfo(
         varName, letVarInfo.varType, typeInfo );
      varList.insert( varInfo );
      if not letVarInfo.varType and typeInfo.equals( Ast.builtinTypeNil ) {
         self.addErrMess(
            varName.pos, 'need type -- %s' ( varName.txt ) ); 
      }
      if mode == .Sync {
         // スコープに登録する前に、シンボルを検索
         if self.scope.getTypeInfo( varName.txt, self.scope, true ) {
            syncSymbolList.insert( varInfo );
         }
      }
      // スコープに変数を登録
      if mode == .Let or mode == .Sync {
         if mode == .Let {
            if self.scope.getTypeInfo( varName.txt, self.scope, true ) {
               self.addErrMess( varName.pos,
                                "shadowing variable -- %s" (varName.txt) );
            }
         }
         self.scope.addVar( accessMode, varName.txt, typeInfo,
                            letVarInfo.mutable, not unwrapFlag );
      }
      symbolInfoList.insert(
         unwrap self.scope.getSymbolInfo( varName.txt, self.scope, true ) );
   }

   let mut unwrapBlock: Ast.BlockNode! = nil;
   let mut thenBlock: Ast.BlockNode! = nil;
   if unwrapFlag {
      let scope = self.pushScope( false );

      // unwrap ブロックに変数を登録
      foreach letVarInfo, index in letVarList {
         self.addLocalVar(
            letVarInfo.varName.pos, false, true, "_" .. letVarInfo.varName.txt,
            orgExpTypeList[ index ], false );
      }
      
      unwrapBlock = self.analyzeBlock( .LetUnwrap, scope );
      self.popScope();

      // unwrap ブロック後には変数にデータがセットされているものとする。
      if mode == .Let or mode == .Sync {
         foreach letVarInfo, index in letVarList {
            let symbolInfo =
               unwrap self.scope.getSymbolInfoChild( letVarInfo.varName.txt );
            symbolInfo.set_hasValueFlag( true );
         }
      }

      token = self.getToken( true );
      if token.txt == "then" {
         thenBlock = self.analyzeBlock( .LetUnwrap, scope );
      }
      else {
         self.pushback();
      }
   }

   let mut syncBlock: Ast.BlockNode! = nil;
   if mode == .Sync {
      self.checkNextToken( "do" );
      syncBlock = self.analyzeBlock( .LetUnwrap, syncScope );
      self.popScope();
   }

   self.checkNextToken( ";" );

   let mut node = Ast.DeclVarNode.create(
      self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], mode, accessMode, false,
      varList, expList, symbolInfoList, typeInfoList, unwrapFlag, unwrapBlock,
      thenBlock, syncSymbolList, syncBlock );

   return node;
}

fn TransUnit.analyzeIfUnwrap( firstToken: &Parser.Token ) mut : Ast.Node
{
   let mut nextToken = self.getToken();
   let mut typeInfoList:List<&Ast.TypeInfo> = [];
   let mut varNameList:str[] = [];

   let mut expNodeList:List<&Ast.Node> = [];
   
   if nextToken.txt == "let" {  
      let mut workTypeInfoList, mut letVarList, mut orgExpTypeList, expList =
         self.analyzeLetAndInitExp( firstToken.pos, false, .Local, true );
      typeInfoList = workTypeInfoList;
      foreach exp in (unwrap expList).$expList {
         expNodeList.insert( exp );
      }
      foreach varInfo in letVarList {
         varNameList.insert( varInfo.varName.txt );
      }
   }
   else {
      self.pushback();
      let exp = self.analyzeExp( false );
      expNodeList.insert( exp );
      if exp.$expType.$nilable {
         typeInfoList.insert( exp.$expType.$orgTypeInfo );
      }
      else {
         typeInfoList.insert( exp.$expType );
      }
      varNameList.insert( "_exp" );
   }

   let mut scope = self.pushScope( false );

   foreach expType, index in typeInfoList {
      if index > #varNameList {
         break;
      }
      let varName = varNameList[ index ];
      self.addLocalVar( firstToken.pos, false, true, varName, expType, false );
   }
   
   let block = self.analyzeBlock( .IfUnwrap, scope );

   self.popScope();

   let mut elseBlock:Ast.BlockNode! = nil;
   nextToken = self.getToken( true );
   if nextToken.txt == "else" {
      elseBlock = self.analyzeBlock( .IfUnwrap );
   }
   else {
      self.pushback();
   }

   return Ast.IfUnwrapNode.create(
      self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ],
      varNameList, expNodeList, block, elseBlock );
}
