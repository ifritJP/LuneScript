/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

fn TransUnit.analyzeRefType( accessMode: str, allowDDD:bool ) mut: Ast.RefTypeNode {
   let firstToken = self.getToken();
   let mut token = firstToken;
   let mut refFlag = false;
   if token.txt == "&" {
      refFlag = true;
      token = self.getToken();
   }
   let mut mutFlag = false;
   if token.txt == "mut" {
      mutFlag = true;
      token = self.getToken();
   }
   let mut typeInfo = Ast.builtinTypeStem_;
   self.checkSymbol( token );


   let name = self.analyzeExpSymbol( firstToken, token, "symbol", nil, true );
   typeInfo = name.$expType;

   let continueToken, continueFlag = self.getContinueToken();
   token = continueToken;
   if continueFlag and token.txt == "!" {
      typeInfo = unwrap typeInfo.get_nilableTypeInfo();
      token = self.getToken();
   }

   let mut arrayMode = "no";
   while true {
      if token.txt == '[' or token.txt == '[@' {
         if token.txt == '[' {
            arrayMode = "list";
            typeInfo = Ast.NormalTypeInfo.createList(
               accessMode, self.getCurrentClass(), [ typeInfo ] );
         }   
         else {
            arrayMode = "array";
            typeInfo = Ast.NormalTypeInfo.createArray(
               accessMode, self.getCurrentClass(), [ typeInfo ] );
         }   
         token = self.getToken();
         if token.txt ~= ']' {
            self.pushback();
            self.checkNextToken( ']' );
         }   
      }   
      elseif token.txt == "<" {
         let mut genericList: List<&Ast.TypeInfo> = [];
         let mut nextToken: &Parser.Token = Parser.getEofToken();
         repeat {
            let typeExp = self.analyzeRefType( accessMode, false );

            genericList.insert( typeExp.$expType );
            nextToken = self.getToken();
         } nextToken.txt ~= ",";
         self.checkToken( nextToken, '>' );
         if typeInfo.$kind == Ast.TypeInfoKind.Map {
            typeInfo = Ast.NormalTypeInfo.createMap(
               accessMode, self.getCurrentClass(),
               genericList[1] or Ast.builtinTypeStem,
               genericList[2] or Ast.builtinTypeStem );
         }
         elseif typeInfo.$kind == Ast.TypeInfoKind.List {
            typeInfo = Ast.NormalTypeInfo.createList(
               accessMode, self.getCurrentClass(),
               [ genericList[1] ] or [ Ast.builtinTypeStem ] );
         }
         else {
            self.error( string.format( "not support generic: %s",
                                       typeInfo.getTxt() ) );
         }   
      }   
      else {
         self.pushback();
         break;
      }
      token = self.getToken();
   }
   if token.txt == "!" {
      typeInfo = unwrap typeInfo.get_nilableTypeInfo();
      token = self.getToken();
   }
   if not allowDDD and typeInfo.equals( Ast.builtinTypeDDD ) {
      self.addErrMess(
         firstToken.pos, "invalid type. -- '%s'" (typeInfo.getTxt() ) );
   }

   if refFlag {
      typeInfo = self.createModifier( typeInfo, false );
   }

   return new Ast.RefTypeNode( firstToken.pos, [ typeInfo ],
                               name, refFlag, mutFlag, arrayMode );
}

fn TransUnit.analyzeDeclArgList(
   accessMode:str, argList: List<&Ast.Node> ) mut : &Parser.Token
{
   let mut nextToken: &Parser.Token = Parser.noneToken;
   repeat {
      nextToken = self.getToken();
      if nextToken.txt == ")" {
         break;
      }
      let mut mutable = false;
      if nextToken.txt == "mut" {
         mutable = true;
         nextToken = self.getToken();
      }
      let mut argName = nextToken;
      if argName.txt == "..." {
         argList.insert( 
            new Ast.DeclArgDDDNode( argName.pos, [ Ast.builtinTypeDDD ] ) );
         self.scope.addLocalVar(
            false, true, argName.txt, Ast.builtinTypeDDD, false );
      }
      else {
         argName = self.checkSymbol( argName );

         if self.scope.getSymbolTypeInfo( argName.txt, self.scope, self.moduleScope ) {
            self.addErrMess( argName.pos,
                             "shadowing variable -- %s" (argName.txt) );
         }

         self.checkNextToken( ":" );
         let refType = self.analyzeRefType( accessMode, false );
         let arg = new Ast.DeclArgNode( argName.pos, refType.$expTypeList,
                                        argName, refType );    
         
         self.scope.addLocalVar( false, true, argName.txt, refType.$expType, mutable );
         argList.insert( arg );
      }
      nextToken = self.getToken();
   } nextToken.txt ~= ",";

   self.checkToken( nextToken, ")" );

   return nextToken;
}

pub class ASTInfo {
   pri let node: Ast.Node { pub };
   pri let moduleTypeInfo: Ast.TypeInfo { pub };
}

pub fn TransUnit.createAST(
   parser: Parser.Parser, macroFlag: bool, moduleName: str! ) mut : ASTInfo
{
   self.moduleName = unwrap moduleName default "";

   self.registBuiltInScope();

   let mut moduleTypeInfo = Ast.typeInfoRoot;

   if! moduleName {
      apply txt of string.gmatch( _exp, '[^%.]+' ) {
         // moduleTypeInfo = unwrap self.pushClass(
         //    true, false, nil, nil, false, txt@@str, "pub" );
         moduleTypeInfo = unwrap self.pushModule( false, txt@@str, true );
      }
   }
   self.moduleScope = self.scope;

   
   self.parser = parser;

   let mut ast:Ast.Node! = nil;

   let mut lastStatement:Ast.Node! = nil;
   if macroFlag {
      ast = self.analyzeBlock( "macro" );
   }
   else {
      let mut children:List<&Ast.Node> = [];
      lastStatement = self.analyzeStatementList( children );

      let mut token = self.getTokenNoErr();
      if token ~= Parser.getEofToken() {
         Util.err( "unknown:%d:%d:(%s) %s"
                     ( token.pos.lineNo, token.pos.column,
                       Parser.getKindTxt( token.kind ), token.txt ) );
      }

      foreach subModule in self.subfileList {
         let! file = _luneScript.searchModule( subModule ) {
            self.error( "not found subfile -- %s" ( subModule ) );
         };

         if self.scope ~= self.moduleScope {
            self.error( "scope does not close" );
         }

         let! mut subParser = Parser.StreamParser.create( file, false, subModule ) {
            self.error( "open error -- %s" (file) );
         };

         self.parser = subParser;

         lastStatement = self.analyzeStatementListSubfile( children );

         token = self.getTokenNoErr();
         if token ~= Parser.getEofToken() {
            Util.err( "unknown:%d:%d:(%s) %s"
                      ( token.pos.lineNo, token.pos.column,
                        Parser.getKindTxt( token.kind ), token.txt ) );
         }  
      }

      let mut luneHelperInfo =
         new Ast.LuneHelperInfo( self.useNilAccess, self.useUnwrapExp );
      let mut rootNode = new Ast.RootNode(
         new Parser.Position( 0, 0 ), [ Ast.builtinTypeNone ],
         children, nil, luneHelperInfo, self.typeId2ClassMap );
      ast = rootNode;
      if! self.provideNode {
         if lastStatement ~= _exp {
            self.addErrMess( _exp.$pos, "'provide' must be last." );
         }
         rootNode.set_provide( _exp );
      }
   }

   if! moduleName {
      apply txt of string.gmatch( _exp, '[^%.]+' ) {
         //self.popClass();
         self.popModule();
      }
   }

   if #self.errMessList > 0 {
      foreach mess in self.errMessList {
         Util.errorLog( mess );
      }
      Util.err( "has error" );
   }
   if self.analyzeMode == "diag" or self.analyzeMode == "comp" {
      os.exit( 0 );
   }

   return new ASTInfo( unwrap ast, moduleTypeInfo );
}


fn TransUnit.analyzeDeclMacro( accessMode: str, firstToken: &Parser.Token ) mut : Ast.Node
{
   let nameToken = self.getToken();
   self.checkNextToken( "(" );

   let scope = self.pushScope( false );

   let mut workArgList: List<&Ast.Node> = [];
   let mut argList: List<&Ast.DeclArgNode> = [];
   let mut nextToken = self.analyzeDeclArgList( accessMode, workArgList );
   let mut argTypeList: List<&Ast.TypeInfo> = [];
   foreach argNode, index in workArgList {
      if argNode.$kind == Ast.nodeKindDeclArg {
         argList.insert( argNode@@Ast.DeclArgNode );
      }
      else {
         self.error( "macro argument can not use '...'." );
      }
      let argType = argNode.$expType;
      argTypeList.insert( argType );
   }


   self.checkNextToken( "{" );

   nextToken = self.getToken();

   let mut ast : Ast.Node! = nil;
   if nextToken.txt == "{" {
      let mut parser = new Parser.WrapParser(
         self.parser, "decl macro %s" (nameToken.txt) );

      // foreach symbolInfo, symbol in scope.$symbol2TypeInfoMap {
      //    scope.add( symbol, symbolInfo.$typeInfo, "local", false );
      // }

      self.macroScope = scope;
      
      let mut bakParser = self.parser;
      self.parser = parser;
      
      let mut stmtList:List<&Ast.Node> = [];
      self.analyzeStatementList( stmtList, "}" );
      self.checkNextToken( "}" );


      self.parser = bakParser;


      self.macroScope = nil;
      ast = new Ast.BlockNode(
         firstToken.pos, [ Ast.builtinTypeNone ], "macro", stmtList );
   }
   else {
      self.pushback();
   }

   self.popScope();

   
   let mut tokenList: List<&Parser.Token> = [];
   let mut braceCount = 0;

   while true {
      nextToken = self.getToken();
      if nextToken.txt == "{" {
         braceCount = braceCount + 1;
      }
      elseif nextToken.txt == "}" {
         if braceCount == 0 {
            break;
         }
         braceCount = braceCount - 1;
      }
      tokenList.insert( nextToken );
   }

   let typeInfo = Ast.NormalTypeInfo.createFunc(
      false, false, scope, Ast.TypeInfoKind.Macro, self.getCurrentNamespaceTypeInfo(),
      false, false, false, accessMode, nameToken.txt, argTypeList );
   self.scope.addLocalVar( false, false, nameToken.txt, typeInfo, false );


   let mut declMacroInfo = new Ast.DeclMacroInfo( nameToken, argList, ast, tokenList ) ;
   let mut node = new Ast.DeclMacroNode( firstToken.pos, [ typeInfo ], declMacroInfo );

   let macroObj = self.macroEval.eval( node );

   self.typeId2MacroInfo[ typeInfo.get_typeId() ] =
      new Ast.MacroInfo( macroObj, declMacroInfo, self.symbol2ValueMapForMacro );
   self.symbol2ValueMapForMacro = {};

   return node;
}

fn TransUnit.analyzePushClass(
   classFlag: bool, abstructFlag: bool,
   firstToken:&Parser.Token, name:&Parser.Token, accessMode:str ) mut :
   &Parser.Token, &Ast.TypeInfo
{
   let mut nextToken = self.getToken();
   let mut baseRef:Ast.Node! = nil;
   let mut interfaceList:List<&Ast.TypeInfo> = [];
   if nextToken.txt == "extend" {
      nextToken = self.getToken();
      if nextToken.txt ~= "(" {
         self.pushback();
         baseRef = self.analyzeRefType( accessMode, false );
         nextToken = self.getToken();
      }
      if nextToken.txt == "(" {
         while true {
            nextToken = self.getToken();
            if nextToken.txt == ")" {
               break;
            }
            self.pushback();
            let ifType = self.analyzeRefType( accessMode, false );
            if ifType.$expType.$kind ~= Ast.TypeInfoKind.IF {
               self.error( "%s is not interface -- %d"
                           (ifType.$expType.getTxt(), ifType.$expType.$kind ) );
            }
            interfaceList.insert( ifType.$expType );
            nextToken = self.getToken();
            if nextToken.txt ~= "," {
               if nextToken.txt == ")" {
                  break;
               }
               self.error( "illegal token" );
            }
         }
         nextToken = self.getToken();
      }
   }

   let mut typeInfo:Ast.TypeInfo! = nil;
   if! baseRef {
      let baseTypeInfo = _exp.get_expType(); 
      typeInfo = baseTypeInfo;
      let! initTypeInfo = baseTypeInfo.$scope$.getTypeInfoChild$("__init") {
         // プロトタイプ宣言時は __init がないこともある。
      }     
      then {
         if initTypeInfo.$accessMode == "pri" {
            self.addErrMess(
               firstToken.pos, "The access mode of '__init' is 'pri'." );
         }
      };
   }
   
   let classTypeInfo = self.pushClass(
      classFlag, abstructFlag, typeInfo, interfaceList, false, name.txt, accessMode );
   return nextToken, classTypeInfo;
}

fn TransUnit.analyzeDeclProto( accessMode: str, firstToken: &Parser.Token ) mut : Ast.Node
{
   let mut nextToken = self.getToken();
   let mut abstructFlag = false;
   if nextToken.txt == "abstruct" {
      abstructFlag = true;
      nextToken = self.getToken();
   }

   
   if nextToken.txt == "class" or nextToken.txt == "interface" {
      let name = self.getSymbolToken();
      
      nextToken = self.analyzePushClass(
         nextToken.txt ~= "interface", abstructFlag, firstToken, name, accessMode );
      self.popClass();
      self.checkToken( nextToken, ";" );
   }
   else {
      self.error( "illegal proto" );
   }
   return self.createNoneNode( firstToken.pos );
}

fn TransUnit.analyzeDeclEnum(
   accessMode: str, firstToken: &Parser.Token ) mut : Ast.DeclEnumNode
{
   let name = self.getSymbolToken();

   self.checkNextToken( "{" );

   let mut valueList:List<&Parser.Token> = [];
   let mut valueName2Info:Map<str,Ast.EnumValInfo> = {};


   let mut scope = self.pushScope( false );

   let mut enumTypeInfo = Ast.rootTypeInfo;
   
   let mut nextToken = self.getToken();
   let mut number = 0.0;
   let mut prevValTypeInfo = Ast.rootTypeInfo;
   let mut valTypeInfo = Ast.rootTypeInfo;
   while nextToken.txt ~= "}" {
      let valName = nextToken;
      nextToken = self.getToken();

      let mut enumVal:stem = number;
      switch ( prevValTypeInfo ) {
         case Ast.builtinTypeReal {
         }
         case Ast.builtinTypeInt, Ast.rootTypeInfo {
            enumVal = number@@int;
         }
      }
      
      if nextToken.txt == "=" {
         let exp = self.analyzeExp( false );
         let valList, typeInfoList = exp.getLiteral();
         if #valList ~= 1 or #typeInfoList ~= 1 {
            self.error( "illegal enum val -- %d %d" ( #valList, #typeInfoList ) );
         }  
         valTypeInfo = typeInfoList[ 1 ];

         
         switch ( valTypeInfo ) {
            case Ast.builtinTypeString {
               enumVal = (unwrap valList[1])@@str;
            }  
            case Ast.builtinTypeInt {
               let val = (unwrap valList[1])@@int;
               enumVal = val;
               number = val@@real;
            }
            case Ast.builtinTypeReal {
               number = (unwrap valList[1])@@real;
               enumVal = number;
            }  
            default {
               self.error( "illegal enum val type -- %s"
                           (valTypeInfo.getTxt() ) );
            }
         }
         nextToken = self.getToken();
      }
      else {
         switch ( prevValTypeInfo ) {
            case Ast.rootTypeInfo {
               valTypeInfo = Ast.builtinTypeInt;
            }
            case Ast.builtinTypeInt, Ast.builtinTypeReal {
               valTypeInfo = prevValTypeInfo;
            }
            default {
               self.addErrMess( valName.pos,
                                "illegal enum val type -- %s" (valTypeInfo.getTxt()) );
            }
         }
      }
      if prevValTypeInfo ~= Ast.rootTypeInfo and prevValTypeInfo ~= valTypeInfo
      {        
         self.addErrMess( valName.$pos,
                          "multiple enum val type. %s, %s"
                          (valTypeInfo.getTxt(), prevValTypeInfo.getTxt()) );
      }
      prevValTypeInfo = valTypeInfo;

      if enumTypeInfo == Ast.rootTypeInfo {
         enumTypeInfo = Ast.NormalTypeInfo.createEnum(
            scope, self.getCurrentNamespaceTypeInfo(),
            false, accessMode, name.txt, valTypeInfo, valueName2Info );
      }
      
      scope.addEnumVal( valName.txt, enumTypeInfo );
      let enumValInfo = new Ast.EnumValInfo( valName.txt, enumVal );
      valueList.insert( valName );
      valueName2Info[ valName.txt ] = enumValInfo;

      if nextToken.txt == "}" {
         break;
      }
      self.checkToken( nextToken, "," );
      nextToken = self.getToken();
      number = number + 1;
   }

   if enumTypeInfo == Ast.rootTypeInfo {
      enumTypeInfo = Ast.NormalTypeInfo.createEnum(
         scope, self.getCurrentNamespaceTypeInfo(),
         false, accessMode, name.txt, Ast.builtinTypeNone, valueName2Info );
   }

   self.popScope();

   self.scope.addEnum( accessMode, name.txt, enumTypeInfo );

   
   return new Ast.DeclEnumNode(
      firstToken.pos, [ enumTypeInfo ], accessMode, name, valueList, scope );
}


fn TransUnit.analyzeDecl(
   accessMode: str, mut staticFlag: bool,
   firstToken: &Parser.Token, mut token: &Parser.Token ) mut : Ast.Node!
{
   if not staticFlag {
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken();
      }
   }
   let mut overrideFlag = false;
   if token.txt == "override" {
      overrideFlag = true;
      token = self.getToken();
   }

   let mut abstructFlag = false;
   if token.txt == "abstruct" {
      abstructFlag = true;
      token = self.getToken();
   }

   if token.txt == "let" {
      return self.analyzeDeclVar( "let", accessMode, firstToken );
   }
   elseif token.txt == "fn" {
      return self.analyzeDeclFunc(
         false, abstructFlag, overrideFlag,
         accessMode, staticFlag, nil, firstToken, nil );
   }
   elseif token.txt == "abstruct" {
      self.checkNextToken( "class" );
      return self.analyzeDeclClass( true, accessMode, firstToken, "class" );
   }
   elseif token.txt == "class" {
      return self.analyzeDeclClass( false, accessMode, firstToken, "class" );
   }
   elseif token.txt == "interface" {
      return self.analyzeDeclClass( true, accessMode, firstToken, "interface" );
   }
   elseif token.txt == "module" {
      return self.analyzeDeclClass( false, accessMode, firstToken, "module" );
   }
   elseif token.txt == "proto" {
      return self.analyzeDeclProto( accessMode, firstToken );
   }
   elseif token.txt == "macro" {
      return self.analyzeDeclMacro( accessMode, firstToken );
   }
   elseif token.txt == "enum" {
      return self.analyzeDeclEnum( accessMode, firstToken );
   }  

   return nil;
}

fn TransUnit.analyzeDeclMember(
   accessMode: str, staticFlag: bool, firstToken: &Parser.Token ) mut:
   Ast.DeclMemberNode
{
      let mut nextToken = self.getToken();
      let mut mutable = false;
      if nextToken.txt == "mut" {
         mutable = true;
         nextToken = self.getToken();
      }
      let varName = self.checkSymbol(nextToken);
      let mut token = self.getToken();
      let refType = self.analyzeRefType( accessMode, false );
      token = self.getToken();

      let mut getterMode = "none";
      let mut getterMutable = true;
      let mut setterMode = "none";
      if token.txt == "{" {

         fn analyzeAccessorMode(): str, &Parser.Token
         {        
            let mut mode = "none";
            let mut workToken = self.getToken();
            switch workToken.txt {
               case "pub", "pri", "pro" {
                  mode = workToken.txt;
                  workToken = self.getToken();
                  if workToken.txt == "&" {
                     getterMutable = false;
                     workToken = self.getToken();
                  }
               }
            }
            return mode, workToken;
         }

         getterMode, nextToken = analyzeAccessorMode();
         if nextToken.txt == "," {
            setterMode, nextToken = analyzeAccessorMode();
         }
         self.checkToken( nextToken, "}" );
         token = self.getToken();
      }

      // accessor
      self.checkToken( token, ";" );

      let mut typeInfo = refType.$expType;
      if typeInfo.$mutable and not mutable {
         typeInfo = self.createModifier( typeInfo, false );
      }
         
      let symbolInfo = self.scope.addMember(
         varName.txt, typeInfo, accessMode, staticFlag, mutable );

      return new Ast.DeclMemberNode(
         firstToken.pos, [ typeInfo ], varName, refType, symbolInfo,
         staticFlag, accessMode, getterMutable, getterMode, setterMode );
   }

fn TransUnit.analyzeDeclMethod(
   moduleFlag: bool, abstructFlag: bool, overrideFlag: bool, accessMode: str,
   staticFlag: bool, className: &Parser.Token,
   firstToken: &Parser.Token, name: &Parser.Token ) mut : Ast.Node
{
   let mut node = self.analyzeDeclFunc(
      moduleFlag, abstructFlag,
      overrideFlag, accessMode, staticFlag, className, name, name );
   return node;
}

fn TransUnit.analyzeClassBody(
   classAccessMode: str, firstToken: &Parser.Token,
   mode:str, classTypeInfo: &Ast.TypeInfo,
   name:&Parser.Token, moduleName: &Parser.Token!, mut nextToken:&Parser.Token ) mut :
   Ast.DeclClassNode, &Parser.Token, Map<str,bool>
{
   let mut memberName2Node: Map<str,Ast.DeclMemberNode> = {};
   let mut fieldList:List<&Ast.Node> = [];
   let mut memberList:List<&Ast.DeclMemberNode> = [];
   let mut methodNameSet: Map<str,bool> = {};
   let mut initStmtList:List<&Ast.Node> = [];
   let mut advertiseList:Ast.AdvertiseInfo[] = [];
   let mut trustList:List<&Ast.TypeInfo> = [];
   let mut node = new Ast.DeclClassNode(
      firstToken.pos, [ classTypeInfo ],
      classAccessMode, name, fieldList, moduleName,
      memberList, self.scope, initStmtList, advertiseList, trustList, {} );
   self.typeInfo2ClassNode[ classTypeInfo ] = node;
   let mut declCtorNode:Ast.Node! = nil;
   
   while true {
      let mut token = self.getToken();
      if token.txt == "}" {
         break;
      }   
      let mut accessMode = "pri";
      if token.txt == "pub" or token.txt == "pro" or
         token.txt == "pri" or token.txt == "global"
      {   
         accessMode = token.txt;
         token = self.getToken();
      }
      let mut staticFlag = false;
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken();
      }   
      let mut overrideFlag = false;
      if token.txt == "override" {
         overrideFlag = true;
         token = self.getToken();
      }   
      let mut abstructFlag = false;
      if token.txt == "abstructFlag" {
         abstructFlag = true;
         token = self.getToken();
      }   

      if token.txt == "let" {
         if mode == "interface" {
            self.error( "interface can not have member" );
         }
         if not staticFlag and declCtorNode {
            self.addErrMess( token.pos, "member can't declare after '__init' method." );
         }
         let memberNode = self.analyzeDeclMember( accessMode, staticFlag, token );
         fieldList.insert( memberNode );
         memberList.insert( memberNode );
         memberName2Node[ memberNode.$name.txt ] = memberNode;
      }   
      elseif token.txt == "fn" {
         let nameToken = self.getToken();
         let methodNode = self.analyzeDeclMethod(
            mode == "module", abstructFlag, overrideFlag,
            accessMode, staticFlag, name, token, nameToken );
         fieldList.insert( methodNode );
         methodNameSet[ nameToken.txt ] = true;
         if nameToken.txt == "__init" {
            declCtorNode = methodNode;
         }
      }
      elseif token.txt == "__init" {
         if mode ~= "class" {
            self.error( "%s can not have __init method" (mode) );
         }
         foreach symbolInfo, symbolName in self.scope.$symbol2TypeInfoMap {
            if symbolInfo.$staticFlag {
               // 一旦全てのメンバを値なし状態にセットする
               symbolInfo.set_hasValueFlag( false );
            }
         }
         
         self.checkNextToken( "{" );
         self.analyzeStatementList( initStmtList, "}" );
         self.checkNextToken( "}" );
      }
      elseif token.txt == "advertise" {
         let memberToken = self.getSymbolToken();
         nextToken = self.getToken();
         let mut prefix = "";
         if nextToken.txt ~= ";" and nextToken.txt ~= "{" {
            prefix = nextToken.txt;
            nextToken = self.getToken();
         }
         self.checkToken( nextToken, ";" );
         let! memberNode = memberName2Node[ memberToken.txt ] {
            self.error( "not found member -- %s" (memberToken.txt) );
         };
         advertiseList.insert( new Ast.AdvertiseInfo( memberNode, prefix ) );
      }
      elseif token.txt == ";" {
      }
      else {
         self.error( "illegal field" );
      }
   }

   if! declCtorNode {
      foreach memberNode, memberName in memberName2Node {
         if not memberNode.$staticFlag {
            let symbolInfo = unwrap self.scope.getSymbolInfoChild( memberName );
            let typeInfo = symbolInfo.$typeInfo;
            if not symbolInfo.$hasValueFlag and not typeInfo.$nilable {
               self.addErrMess( _exp.$pos,
                                "does not set member -- %s %s"
                                ( memberName, symbolInfo.$symbolId ) );
            }
         }
      }
   }

   return node, nextToken, methodNameSet;
}

fn TransUnit.analyzeDeclClass(
   classAbstructFlag: bool, 
   classAccessMode: str, firstToken: &Parser.Token, mode:str ) mut : Ast.DeclClassNode
{
   let name = self.getSymbolToken();

   let mut moduleName: &Parser.Token! = nil;
   if mode == "module" {
      self.checkNextToken( "require" );
      moduleName = self.getToken();
   }

   let mut nextToken, classTypeInfo = self.analyzePushClass(
      mode ~= "interface", classAbstructFlag, firstToken, name, classAccessMode );

   self.checkToken( nextToken, "{" );

   // if mode == "class" {
   //    // self シンボルを登録
   //    self.scope.add(
   //       Ast.SymbolKind.Var, false, true, "self",
   //       classTypeInfo, "pri", false, true, true );
   // }



   let mut node, workNextToken, mut methodNameSet = self.analyzeClassBody(
      classAccessMode, firstToken, mode, classTypeInfo, name, moduleName, nextToken );
   nextToken = workNextToken;
   

   let parentInfo = classTypeInfo;

   let mut memberTypeList:List<&Ast.TypeInfo> = [];

   // accessor の生成
   foreach memberNode in node.$memberList {
      let memberType = memberNode.$expType;
      if not memberNode.$staticFlag {
         memberTypeList.insert( memberType );
      }
      let memberName = memberNode.$name;
      // getter
      let getterName = "get_" .. memberName.txt;
      let mut accessMode = memberNode.$getterMode;
      if accessMode ~= "none" and not self.scope.getTypeInfoChild( getterName )
      {
         let mutable = memberNode.$getterMutable;
         let mut getterMemberType = memberType;
         if memberType.$mutable and not mutable {
            getterMemberType = self.createModifier( memberType, false );
         }
         let retTypeInfo = Ast.NormalTypeInfo.createFunc(
            false, false, self.pushScope( false ),
            Ast.TypeInfoKind.Method, parentInfo, true, false, false, accessMode,
            getterName, [], [ getterMemberType ] );
         self.popScope();
         
         self.scope.addMethod( retTypeInfo, accessMode, false, false );
         methodNameSet[ getterName ] = true;
      }
      // setter
      let setterName = "set_" .. memberName.txt;
      accessMode = memberNode.$setterMode;
      if memberNode.$setterMode ~= "none" and
         not self.scope.getTypeInfoChild( setterName )
      {   
         self.scope.addMethod(
            Ast.NormalTypeInfo.createFunc(
               false, false, self.pushScope( false ),
               Ast.TypeInfoKind.Method, parentInfo, true, false, false, accessMode,
               setterName, [ memberType ], nil, true 
            ), accessMode, false, true );
         self.popScope();
         methodNameSet[ setterName ] = true;
      }   
   }

   if not self.scope.getTypeInfoChild( "__init" ) {
      if classTypeInfo.$baseTypeInfo ~= Ast.rootTypeInfo {
         let superScope = unwrap classTypeInfo.$baseTypeInfo.$scope;
         let superTypeInfo = unwrap superScope.getTypeInfoChild( "__init" );
         foreach argType in superTypeInfo.$argTypeInfoList {
            if not argType.$nilable {
               self.addErrMess( firstToken.pos, "not found '__init' decl." );
            }
         }
      }
      
      // デフォルトコンストラクタの登録
      let initTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, self.pushScope( false ),
         Ast.TypeInfoKind.Method, parentInfo, true, false, false, "pub",
         "__init", memberTypeList, [] );
      self.popScope();
      self.scope.addMethod( initTypeInfo, "pub", false, false );
      methodNameSet[ "__init" ] = true;

      // メンバーをセット済みにする
      foreach memberNode in node.$memberList {
         if not memberNode.$staticFlag {
            memberNode.$symbolInfo.set_hasValueFlag( true );
         }
      }
   }


   // advertise の処理
   foreach advertiseInfo in node.$advertiseList {
      let mut memberType = advertiseInfo.$member.$expType;
      switch memberType.$kind {
         case Ast.TypeInfoKind.Class, Ast.TypeInfoKind.IF {
            foreach child in memberType.$children {
               if child.$kind == Ast.TypeInfoKind.Method and
                  child.$accessMode ~= "pri" and
                  not child.$staticFlag
               {
                  let childName = advertiseInfo.$prefix .. child.getTxt();
                  if not methodNameSet[ childName ] {
                     self.scope.addMethod(
                        child, child.$accessMode, child.$staticFlag, false );
                  }
               }
            }
         }
         default {
            self.error( "advertise member type is illegal -- %s"
                        (advertiseInfo.$member.$name) );
         }
      }
   }
   

   self.popClass();

   return node;
}   

pri fn TransUnit.addMethod( className: str, methodNode: Ast.Node, name: str ) mut {
   let classTypeInfo = self.scope.getTypeInfo(
      className, self.scope, false );
   let mut classNodeInfo = unwrap self.typeInfo2ClassNode[ classTypeInfo ];

   classNodeInfo.$outerMethodSet[ name ] = true;
   classNodeInfo.$fieldList.insert( methodNode );
}


fn TransUnit.analyzeDeclFunc(
   moduleFlag: bool, abstructFlag: bool, overrideFlag: bool, accessMode: str,
   mut staticFlag: bool, mut classNameToken: &Parser.Token!,
   firstToken: &Parser.Token, mut name: &Parser.Token! ) mut : Ast.Node
{
   let mut token = self.getToken();
   if! name {
      name = self.checkSymbol( _exp );
   }
   else {
      if token.txt ~= "(" {
         name = self.checkSymbol( token );
         token = self.getToken();
      }
   }
   let mut needPopFlag = false;
   if token.txt == "." {
      needPopFlag = true;
      classNameToken = name;
      
      let classTypeInfo = unwrap self.scope.getTypeInfoChild( (unwrap name).txt );

      self.pushClass(
         classTypeInfo.$kind == Ast.TypeInfoKind.Class,
         classTypeInfo.$abstructFlag, nil, nil, false, (unwrap name).txt, "pub" );

      name = self.getSymbolToken();
      token = self.getToken();
   }

   let mut kind = Ast.nodeKindDeclConstr;
   let mut typeKind = Ast.TypeInfoKind.Func;
   if classNameToken {
      if moduleFlag or not staticFlag {
         // module で Lua の外部モジュールを宣言した場合、
         // static なメソッド呼び出しが必要なので。。。
         typeKind = Ast.TypeInfoKind.Method;
      }
      if (unwrap name).txt == "__init" {
         kind = Ast.nodeKindDeclConstr;
         foreach symbolInfo, symbolName in self.scope.$symbol2TypeInfoMap {
            if not symbolInfo.$staticFlag {
               // 一旦全てのメンバを値なし状態にセットする
               symbolInfo.set_hasValueFlag( false );
            }
         }
      }
      else {
         kind = Ast.nodeKindDeclMethod;
      }
   }
   else {
      kind = Ast.nodeKindDeclFunc;
      if not staticFlag {
         staticFlag = true;
      }
   }

   if moduleFlag {
      // module で Lua の外部モジュールを宣言した場合、
      // モジュール名でメンバにアクセスできるように、
      // 強制的に static にする。
      staticFlag = true;
   }

   let mut funcName = "";
   if! name {
      funcName = _exp.txt;

      if kind == Ast.nodeKindDeclFunc {
         switch accessMode {
            case "pub", "global" {
               if self.scope ~= self.moduleScope {
                  self.addErrMess( firstToken.pos,
                                   "'global' or 'pub' function must exist top scope." );
               }
            }
         }
      }  
   }
   
   self.checkToken( token, "(" );

   let mut scope = self.pushScope( false );

   let mut argList:List<&Ast.Node> = [];
   token = self.analyzeDeclArgList( accessMode, argList );
   let mut argTypeList:List<&Ast.TypeInfo> = [];
   foreach argNode in argList {
      argTypeList.insert( argNode.$expType );
   }

   self.checkToken( token, ")" );
   token = self.getToken();

   let mut mutable = false;
   if token.txt == "mut" {
      token = self.getToken();
      mutable = true;
   }

   if kind == Ast.nodeKindDeclMethod or
      kind == Ast.nodeKindDeclConstr
   {
      if kind == Ast.nodeKindDeclConstr {
         mutable = true;
      }
      // self シンボルを登録
      let mut classTypeInfo:&Ast.TypeInfo = unwrap scope.$parent.$ownerTypeInfo;
      if classTypeInfo.$mutable and not mutable {
         classTypeInfo = self.createModifier( classTypeInfo, false );
      }
      self.scope.add(
         Ast.SymbolKind.Var, false, true, "self",
         classTypeInfo, "pri", false, mutable, true );
   }

   
   
   let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
   if token.txt == ":" {
      repeat {
         let refType = self.analyzeRefType( accessMode, true );
         retTypeInfoList.insert( refType.$expType );
         token = self.getToken();
      } token.txt ~= ",";
   }

   let typeInfo = Ast.NormalTypeInfo.createFunc(
      abstructFlag, false, scope,
      typeKind, self.getCurrentNamespaceTypeInfo(),
      false, false, staticFlag, accessMode,
      funcName, argTypeList, retTypeInfoList, mutable );
   if! name {
      let mut parentScope = scope.get_parent();
      if accessMode == "global" {
         parentScope = Ast.rootScope;
      }
      
      if kind == Ast.nodeKindDeclFunc {
         parentScope.addFunc( typeInfo, accessMode, staticFlag, mutable );
      }
      else {
         parentScope.addMethod( typeInfo, accessMode, staticFlag, mutable );
      }
   }

   if overrideFlag {
      // オーバーライドの型チェック
      if not name {
         self.addErrMess( firstToken.pos, "can't override anonymous func" );
      };
      let! overrideType =
         self.scope.$parent.getTypeInfoField( funcName, false, scope )
      {
         self.addErrMess( firstToken.pos, "not found override -- " .. funcName );
      }
      then {
         if overrideType.get_accessMode() ~= accessMode {
            self.addErrMess( firstToken.pos, "mismatch override accessMode -- %s,%s,%s"
                             ( funcName, overrideType.get_accessMode(), accessMode ) );
         }  
         if overrideType.get_staticFlag() ~= staticFlag {
            self.addErrMess( firstToken.pos,
                             "mismatch override staticFlag -- " .. funcName );
         }  
         if overrideType.get_kind() ~= Ast.TypeInfoKind.Method {
            self.addErrMess( firstToken.pos, "mismatch override kind -- %s, %d"
                             ( funcName, overrideType.get_kind() ) );
         }
         if overrideType.$mutable ~= typeInfo.$mutable {
            self.addErrMess( firstToken.pos, "mismatch mutable -- %s" ( funcName ) );
         }
         if not overrideType.canEvalWith( typeInfo, "=" ) {
            self.addErrMess( firstToken.pos, "mismatch method type -- %s" (funcName));
         }
      };
   }
   else {
      if! name {
         if _exp.txt ~= "__init" and
            self.scope.$parent.getTypeInfoField( _exp.txt, false, scope )
         {          
            // override 宣言していないのに、オーバーライドしている場合エラー
            self.error( "mismatch override --" .. funcName );
         }
      }
   }


   

   let mut node:Ast.Node = self.createNoneNode( firstToken.pos );
   if token.txt == ";" {
      node = self.createNoneNode( firstToken.pos );
   }
   else {
      self.pushback();
      let body = self.analyzeBlock( "func", scope );
      let mut info = new Ast.DeclFuncInfo(
         classNameToken, name, argList, staticFlag, accessMode,
         body, retTypeInfoList );
      // node = self.createNode( kind, firstToken.pos, [ typeInfo ], info );

      switch ( kind ) {
         case Ast.nodeKindDeclConstr {
            node = new Ast.DeclConstrNode( firstToken.pos, [ typeInfo ], info );
         }
         case Ast.nodeKindDeclMethod {
            node = new Ast.DeclMethodNode( firstToken.pos, [ typeInfo ], info );
         }
         case Ast.nodeKindDeclFunc {
            node = new Ast.DeclFuncNode( firstToken.pos, [ typeInfo ], info );
         }
         default {
            self.error( "illegal kind -- %d" (kind) );
         }
      }
   }

   self.popScope();

   if needPopFlag {
      self.addMethod( (unwrap classNameToken).txt, node, funcName );
      self.popClass();
   }

   return node;
}

class LetVarInfo {
   pub let mutable:bool;
   pub let varName: &Parser.Token;
   pub let varType:Ast.RefTypeNode!;
}

fn TransUnit.analyzeDeclVar(
   mode:str, accessMode: str, firstToken: &Parser.Token ) mut : Ast.Node
{
   let mut unwrapFlag = false;
   let mut token, continueFlag = self.getContinueToken();
   if continueFlag and token.txt == "!" {
      unwrapFlag = true;
   }
   else {
      self.pushback();
      if mode ~= "let" {
         Util.log( "need '!'" );
      }
   }

   let mut typeInfoList : List<&Ast.TypeInfo> = [];
   let mut symbolInfoList: List<&Ast.SymbolInfo> = [];

   if accessMode == "pub" {
      if self.scope ~= self.moduleScope {
         self.addErrMess( firstToken.pos, "'pub' variable must exist top scope." );
      }
   }

   let mut letVarList:LetVarInfo[] = [];
   repeat {
      // 変数名と : で明示している型情報を取得。
      let mut mutable = (mode == "sync");
      let mut nextToken = self.getToken();
      if nextToken.txt == "mut" {
         mutable = true;
         nextToken = self.getToken();
      }
      let varName = self.checkSymbol( nextToken );
      token = self.getToken();
      let mut typeInfo = Ast.builtinTypeNone;
      if token.txt == ":" {
         let refType = self.analyzeRefType( accessMode, false );
         letVarList.insert( new LetVarInfo( mutable, varName, refType ) );
         typeInfo = refType.$expType;
         token = self.getToken();
      }
      else {
         letVarList.insert( new LetVarInfo( mutable, varName, nil ) );
      }
      if not typeInfo.equals( Ast.builtinTypeNone ) and
         typeInfo.$mutable and not mutable
      {     
         typeInfo = self.createModifier( typeInfo, false );
      }
      typeInfoList.insert( typeInfo );
   } token.txt ~= ",";

   let mut expList:Ast.ExpListNode! = nil;
   if token.txt == "=" {
      expList = self.analyzeExpList( false );
      if not expList {
         self.error( "expList is nil" );
      }
   }

   let mut orgExpTypeList: List<&Ast.TypeInfo> = [];
   if! expList {
      foreach exp, index in _exp.$expList {
         if not exp.canBeRight() {
            self.addErrMess( exp.$pos,
                             "this node can not be r-value. -- %s"
                             (Ast.getNodeKindName( exp.$kind ) ) );
         }
      }

      //  初期化値の型を反映する
      let mut expTypeList: List<&Ast.TypeInfo> = [];
      foreach expType, index in _exp.$expTypeList {
         let processedFlag = false;
         if index == #_exp.$expTypeList and
            _exp.$expTypeList[ index ].equals( Ast.builtinTypeDDD )
         {        
            // 最終要素が ... の場合
            // ... なら、残りの変数宣言の分 stem をセットする
            for subIndex = index, #letVarList {
               let argType = typeInfoList[ subIndex ];
               let mut checkType = Ast.builtinTypeStem_;
               if unwrapFlag {
                  checkType = Ast.builtinTypeStem;
               }
               if not argType.equals( Ast.builtinTypeNone ) and
                  not argType.canEvalWith( checkType, "=" )
               {
                  self.addErrMess(
                     firstToken.pos,
                     "unmatch value type (index = %d) %s(%d) <- %s(%d)"
                     ( subIndex, argType.getTxt(), argType.$typeId,
                       Ast.builtinTypeStem_.getTxt(), Ast.builtinTypeStem_.$typeId ));
               }
               expTypeList.insert( checkType );
               orgExpTypeList.insert( Ast.builtinTypeStem_ );
            }
         }
         else {
            // 最終要素でない場合
            let mut expTypeInfo: &Ast.TypeInfo = expType;
            if expType.equals( Ast.builtinTypeDDD ) {
               expTypeInfo = Ast.builtinTypeStem_;
            }
            orgExpTypeList.insert( expTypeInfo );
            if unwrapFlag and expTypeInfo.$nilable {
               expTypeInfo = unwrap expTypeInfo.$orgTypeInfo;
            }

            if index <= #typeInfoList {
               let argType = typeInfoList[ index ];
               if not argType.equals( Ast.builtinTypeNone ) and
                  not argType.canEvalWith( expTypeInfo, "=" ) and
                  not (unwrapFlag and expTypeInfo.equals( Ast.builtinTypeNil ))
               {               
                  self.addErrMess(
                     firstToken.pos,
                     "unmatch value type (index:%d) %s <- %s"
                     (index, argType.getTxt(), expTypeInfo.getTxt()));
               }
            }
            expTypeList.insert( expTypeInfo );
         }
      }
      // 宣言する変数の数より初期値が少ない場合、
      // nil で初期化されるため変数が nilable かどうか判定
      foreach varType, index in typeInfoList {
         if index > #expTypeList {
            if not varType.$nilable {
               self.addErrMess(
                  firstToken.pos,
                  "unmatch value type (index:%d) %s <- nil"
                  (index, varType.getTxt()));
            }
         }
      }
      // 変数の型を、型推論で初期値から設定
      foreach typeInfo, index in expTypeList {
         if not typeInfoList[ index ] or
            typeInfoList[ index ].equals( Ast.builtinTypeNone )
         {
            if typeInfo.$mutable and
               index <= #letVarList and not letVarList[ index ].mutable
            {           
               typeInfoList[ index ] = self.createModifier( typeInfo, false );
            }
            else {
               typeInfoList[ index ] = typeInfo;
            }
         }
      }
   }

   if self.macroScope {
      foreach letVarInfo, index in letVarList {
         let typeInfo = typeInfoList[ index ];
         
         self.symbol2ValueMapForMacro[ letVarInfo.varName.txt ] =
            new Ast.MacroValInfo( nil, typeInfo);
      }
   }


   let mut syncScope:Ast.Scope = self.scope;
   if mode == "sync" {
      syncScope = self.pushScope( false );
   }
   
   let mut varList:List<&Ast.VarInfo> = [];
   let mut syncSymbolList:List<&Ast.VarInfo> = [];
   foreach letVarInfo, index in letVarList {
      let varName = letVarInfo.varName;
      let typeInfo = typeInfoList[ index ];
      let varInfo = new Ast.VarInfo(
         varName, letVarInfo.varType, typeInfo );
      varList.insert( varInfo );
      if not letVarInfo.varType and typeInfo.equals( Ast.builtinTypeNil ) {
         self.addErrMess(
            varName.pos, 'need type -- %s' ( varName.txt ) ); 
      }
      if mode == "sync" {
         // スコープに登録する前に、シンボルを検索
         if self.scope.getTypeInfo( varName.txt, self.scope, true ) {
            syncSymbolList.insert( varInfo );
         }
      }
      // スコープに変数を登録
      if mode == "let" or mode == "sync" {
         if mode == "let" {
            if self.scope.getTypeInfo( varName.txt, self.scope, true ) {
               self.addErrMess( varName.pos,
                                "shadowing variable -- %s" (varName.txt) );
            }
         }
         self.scope.addVar( accessMode, varName.txt, typeInfo,
                            letVarInfo.mutable, not unwrapFlag );
      }
      symbolInfoList.insert(
         unwrap self.scope.getSymbolInfo( varName.txt, self.scope, true ) );
   }

   let mut unwrapBlock: Ast.BlockNode! = nil;
   let mut thenBlock: Ast.BlockNode! = nil;
   if unwrapFlag {
      let scope = self.pushScope( false );

      // unwrap ブロックに変数を登録
      foreach letVarInfo, index in letVarList {
         self.scope.addLocalVar(
            false, true, "_" .. letVarInfo.varName.txt,
            orgExpTypeList[ index ], false );
      }
      
      unwrapBlock = self.analyzeBlock( "let!", scope );
      self.popScope();

      // unwrap ブロック後には変数にデータがセットされているものとする。
      if mode == "let" or mode == "sync" {
         foreach letVarInfo, index in letVarList {
            let symbolInfo =
               unwrap self.scope.getSymbolInfoChild( letVarInfo.varName.txt );
            symbolInfo.set_hasValueFlag( true );
         }
      }

      token = self.getToken( true );
      if token.txt == "then" {
         thenBlock = self.analyzeBlock( "let!", scope );
      }
      else {
         self.pushback();
      }
   }

   let mut syncBlock: Ast.BlockNode! = nil;
   if mode == "sync" {
      let nextToken = self.getToken();
      if nextToken.txt == "do" {
         syncBlock = self.analyzeBlock( "let!", syncScope );
      }
      else {
         self.pushback();
      }
      self.popScope();
   }

   self.checkNextToken( ";" );

   let mut node = new Ast.DeclVarNode(
      firstToken.pos, [ Ast.builtinTypeNone ], mode, accessMode, false,
      varList, expList, symbolInfoList, typeInfoList, unwrapFlag, unwrapBlock,
      thenBlock, syncSymbolList, syncBlock );

   return node;
}
