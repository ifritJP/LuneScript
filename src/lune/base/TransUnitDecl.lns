/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

fn TransUnit.analyzeRefType( accessMode: str ): Ast.RefTypeNode {
   let firstToken = self.getToken();
   let token = firstToken;
   let refFlag = false;
   if token.txt == "&" {
      refFlag = true;
      token = self.getToken();
   }
   let mutFlag = false;
   if token.txt == "mut" {
      mutFlag = true;
      token = self.getToken();
   }
   let typeInfo = Ast.builtinTypeStem_;
   self.checkSymbol( token );


   let name = self.analyzeExpSymbol( firstToken, token, "symbol", nil, true );
   typeInfo = name.$expType;

   let continueToken, continueFlag = self.getContinueToken();
   token = continueToken;
   if continueFlag and token.txt == "!" {
      typeInfo = unwrap typeInfo.get_nilableTypeInfo();
      token = self.getToken();
   }

   let arrayMode = "no";
   while true {
      if token.txt == '[' or token.txt == '[@' {
         if token.txt == '[' {
            arrayMode = "list";
            typeInfo = Ast.NormalTypeInfo.createList(
               accessMode, self.getCurrentClass(), [ typeInfo ] );
         }   
         else {
            arrayMode = "array";
            typeInfo = Ast.NormalTypeInfo.createArray(
               accessMode, self.getCurrentClass(), [ typeInfo ] );
         }   
         token = self.getToken();
         if token.txt ~= ']' {
            self.pushback();
            self.checkNextToken( ']' );
         }   
      }   
      elseif token.txt == "<" {
         let genericList: Ast.TypeInfo[] = [];
         let nextToken: Parser.Token = Parser.getEofToken();
         repeat {
            let typeExp = self.analyzeRefType( accessMode );

            genericList.insert( typeExp.$expType );
            nextToken = self.getToken();
         } nextToken.txt ~= ",";
         self.checkToken( nextToken, '>' );
         if typeInfo.$kind == Ast.TypeInfoKindMap {
            typeInfo = Ast.NormalTypeInfo.createMap(
               accessMode, self.getCurrentClass(),
               genericList[1] or Ast.builtinTypeStem,
               genericList[2] or Ast.builtinTypeStem );
         }   
         else {
            self.error( string.format( "not support generic: %s",
                                       typeInfo.getTxt() ) );
         }   
      }   
      else {
         self.pushback();
         break;
      }
      token = self.getToken();
   }
   if token.txt == "!" {
      typeInfo = unwrap typeInfo.get_nilableTypeInfo();
      token = self.getToken();
   }

   return new Ast.RefTypeNode( firstToken.pos, [ typeInfo ],
                               name, refFlag, mutFlag, arrayMode );
}

fn TransUnit.analyzeDeclArgList( accessMode:str, argList: Ast.Node[] ) : Parser.Token {
   let token: Parser.Token = Parser.noneToken;
   repeat {
      let argName = self.getToken();
      if argName.txt == ")" {
         token = argName;
         break;
      }
      elseif argName.txt == "..." {
         argList.insert( 
            new Ast.DeclArgDDDNode( argName.pos, [ Ast.builtinTypeDDD ] ) );
      }
      else {
         argName = self.checkSymbol( argName );

         self.checkNextToken( ":" );
         let refType = self.analyzeRefType( accessMode );
         let arg = new Ast.DeclArgNode( argName.pos, refType.$expTypeList,
                                        argName, refType );    
         
         self.scope.addLocalVar( false, true, argName.txt, refType.$expType, false );
         argList.insert( arg );
      }
      token = self.getToken();
   } token.txt ~= ",";

   self.checkToken( token, ")" );

   return token;
}

pub class ASTInfo {
   pri let node: Ast.Node { pub };
   pri let moduleTypeInfo: Ast.TypeInfo { pub };
}

pub fn TransUnit.createAST(
   parser: Parser.Parser, macroFlag: bool, moduleName: str! ): ASTInfo
{
   self.moduleName = unwrap moduleName default "";

   self.registBuiltInScope();

   let moduleTypeInfo = Ast.typeInfoRoot;

   if! moduleName {
      apply txt of string.gmatch( _exp, '[^%.]+' ) {
         moduleTypeInfo = unwrap self.pushClass(
            true, false, nil, nil, false, txt@@str, "pub" );
      }
   }
   self.moduleScope = self.scope;

   
   self.parser = parser;

   let ast:Ast.Node! = nil;

   let lastStatement:Ast.Node! = nil;
   if macroFlag {
      ast = self.analyzeBlock( "macro" );
   }
   else {
      let children:Ast.Node[] = [];
      let rootNode = new Ast.RootNode(
         new Parser.Position( 0, 0 ), [ Ast.builtinTypeNone ],
         children, nil, self.typeId2ClassMap );
      ast = rootNode;
      lastStatement = self.analyzeStatementList( children );

      let token = self.getTokenNoErr();
      if! token {
         Util.err( "unknown:%d:%d:(%s) %s"
                     ( _exp.pos.lineNo, _exp.pos.column,
                       Parser.getKindTxt( _exp.kind ), _exp.txt ) );
      }

      foreach subModule in self.subfileList {
         let! file = _luneScript.searchModule( subModule ) {
            self.error( "not found subfile -- %s" ( subModule ) );
         };

         if self.scope ~= self.moduleScope {
            self.error( "scope does not close" );
         }

         let! subParser = Parser.StreamParser.create( file, false, subModule ) {
            self.error( "open error -- %s" (file) );
         };

         self.parser = subParser;

         lastStatement = self.analyzeStatementListSubfile( children );

         token = self.getTokenNoErr();
         if! token {
            Util.err( "unknown:%d:%d:(%s) %s"
                        ( _exp.pos.lineNo, _exp.pos.column,
                          Parser.getKindTxt( _exp.kind ), _exp.txt ) );
         }
      }

      if! self.provideNode {
         if lastStatement ~= _exp {
            self.addErrMess( _exp.$pos, "'provide' must be last." );
         }
         rootNode.set_provide( _exp );
      }
   }

   if! moduleName {
      apply txt of string.gmatch( _exp, '[^%.]+' ) {
         self.popClass();
      }
   }

   if #self.errMessList > 0 {
      foreach mess in self.errMessList {
         Util.errorLog( mess );
      }
      Util.err( "has error" );
   }
   if self.analyzeMode == "diag" or self.analyzeMode == "comp" {
      os.exit( 0 );
   }

   return new ASTInfo( unwrap ast, moduleTypeInfo );
}


fn TransUnit.analyzeDeclMacro( accessMode: str, firstToken: Parser.Token ) : Ast.Node
{
   let nameToken = self.getToken();
   self.checkNextToken( "(" );

   let scope = self.pushScope( false );

   let workArgList: Ast.Node[] = [];
   let argList: Ast.DeclArgNode[] = [];
   let nextToken = self.analyzeDeclArgList( accessMode, workArgList );
   let argTypeList: Ast.TypeInfo[] = [];
   foreach argNode, index in workArgList {
      if argNode.$kind == Ast.nodeKindDeclArg {
         argList.insert( argNode@@Ast.DeclArgNode );
      }
      else {
         self.error( "macro argument can not use '...'." );
      }
      let argType = argNode.$expType;
      argTypeList.insert( argType );
   }


   self.checkNextToken( "{" );

   nextToken = self.getToken();

   let ast : Ast.Node! = nil;
   if nextToken.txt == "{" {
      let parser = new Parser.WrapParser(
         self.parser, "decl macro %s" (nameToken.txt) );

      // foreach symbolInfo, symbol in scope.$symbol2TypeInfoMap {
      //    scope.add( symbol, symbolInfo.$typeInfo, "local", false );
      // }

      self.macroScope = scope;
      
      let bakParser = self.parser;
      self.parser = parser;
      
      let stmtList:Ast.Node[] = [];
      self.analyzeStatementList( stmtList, "}" );
      self.checkNextToken( "}" );


      self.parser = bakParser;


      self.macroScope = nil;
      ast = new Ast.BlockNode(
         firstToken.pos, [ Ast.builtinTypeNone ], "macro", stmtList );
   }
   else {
      self.pushback();
   }

   self.popScope();

   
   let tokenList: Parser.Token[] = [];
   let braceCount = 0;

   while true {
      nextToken = self.getToken();
      if nextToken.txt == "{" {
         braceCount = braceCount + 1;
      }
      elseif nextToken.txt == "}" {
         if braceCount == 0 {
            break;
         }
         braceCount = braceCount - 1;
      }
      tokenList.insert( nextToken );
   }

   let typeInfo = Ast.NormalTypeInfo.createFunc(
      false, false, scope, Ast.TypeInfoKindMacro, self.getCurrentNamespaceTypeInfo(),
      false, false, false, accessMode, nameToken.txt, argTypeList );
   self.scope.addLocalVar( false, false, nameToken.txt, typeInfo, false );


   let declMacroInfo = new Ast.DeclMacroInfo( nameToken, argList, ast, tokenList ) ;
   let node = new Ast.DeclMacroNode( firstToken.pos, [ typeInfo ], declMacroInfo );

   let macroObj = self.macroEval.eval( node );

   self.typeId2MacroInfo[ typeInfo.get_typeId() ] =
      new Ast.MacroInfo( macroObj, declMacroInfo, self.symbol2ValueMapForMacro );
   self.symbol2ValueMapForMacro = {};

   return node;
}

fn TransUnit.analyzePushClass(
   classFlag: bool, abstructFlag: bool,
   firstToken:Parser.Token, name:Parser.Token, accessMode:str ):
   Parser.Token, Ast.TypeInfo
{
   let nextToken = self.getToken();
   let baseRef:Ast.Node! = nil;
   let interfaceList:Ast.TypeInfo[] = [];
   if nextToken.txt == "extend" {
      nextToken = self.getToken();
      if nextToken.txt ~= "(" {
         self.pushback();
         baseRef = self.analyzeRefType( accessMode );
         nextToken = self.getToken();
      }
      if nextToken.txt == "(" {
         while true {
            nextToken = self.getToken();
            if nextToken.txt == ")" {
               break;
            }
            self.pushback();
            let ifType = self.analyzeRefType( accessMode );
            if ifType.$expType.$kind ~= Ast.TypeInfoKindIF {
               self.error( "%s is not interface" (ifType.$expType.getTxt()) );
            }
            interfaceList.insert( ifType.$expType );
            nextToken = self.getToken();
            if nextToken.txt ~= "," {
               if nextToken.txt == ")" {
                  break;
               }
               self.error( "illegal token" );
            }
         }
         nextToken = self.getToken();
      }
   }

   let typeInfo:Ast.TypeInfo! = nil;
   if! baseRef {
      let baseTypeInfo = _exp.get_expType(); 
      typeInfo = baseTypeInfo;
      let! initTypeInfo = baseTypeInfo.$scope$.getTypeInfoChild$("__init") {
         // プロトタイプ宣言時は __init がないこともある。
      }     
      then {
         if initTypeInfo.$accessMode == "pri" {
            self.addErrMess(
               firstToken.pos, "The access mode of '__init' is 'pri'." );
         }
      };
   }
   
   let classTypeInfo = self.pushClass(
      classFlag, abstructFlag, typeInfo, interfaceList, false, name.txt, accessMode );
   return nextToken, classTypeInfo;
}

fn TransUnit.analyzeDeclProto( accessMode: str, firstToken: Parser.Token ) : Ast.Node
{
   let nextToken = self.getToken();
   let abstructFlag = false;
   if nextToken.txt == "abstruct" {
      abstructFlag = true;
      nextToken = self.getToken();
   }

   
   if nextToken.txt == "class" {
      let name = self.getSymbolToken();
      
      nextToken = self.analyzePushClass(
         true, abstructFlag, firstToken, name, accessMode );
      self.popClass();
      self.checkToken( nextToken, ";" );
   }
   else {
      self.error( "illegal proto" );
   }
   return self.createNoneNode( firstToken.pos );
}

fn TransUnit.analyzeDecl(
   accessMode: str, staticFlag: bool,
   firstToken: Parser.Token, token: Parser.Token ): Ast.Node!
{
   if not staticFlag {
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken();
      }
   }
   let overrideFlag = false;
   if token.txt == "override" {
      overrideFlag = true;
      token = self.getToken();
   }

   let abstructFlag = false;
   if token.txt == "abstruct" {
      abstructFlag = true;
      token = self.getToken();
   }

   if token.txt == "let" {
      return self.analyzeDeclVar( "let", accessMode, firstToken );
   }
   elseif token.txt == "fn" {
      return self.analyzeDeclFunc(
         abstructFlag, overrideFlag, accessMode, staticFlag, nil, firstToken, nil );
   }
   elseif token.txt == "abstruct" {
      self.checkNextToken( "class" );
      return self.analyzeDeclClass( true, accessMode, firstToken, "class" );
   }
   elseif token.txt == "class" {
      return self.analyzeDeclClass( false, accessMode, firstToken, "class" );
   }
   elseif token.txt == "interface" {
      return self.analyzeDeclClass( true, accessMode, firstToken, "interface" );
   }
   elseif token.txt == "module" {
      return self.analyzeDeclClass( false, accessMode, firstToken, "module" );
   }
   elseif token.txt == "proto" {
      return self.analyzeDeclProto( accessMode, firstToken );
   }
   elseif token.txt == "macro" {
      return self.analyzeDeclMacro( accessMode, firstToken );
   }

   return nil;
}

fn TransUnit.analyzeDeclMember(
   accessMode: str, staticFlag: bool, firstToken: Parser.Token ): Ast.DeclMemberNode {
      let varName = self.getSymbolToken();
      let token = self.getToken();
      let refType = self.analyzeRefType( accessMode );
      token = self.getToken();

      let getterMode = "none";
      let setterMode = "none";
      if token.txt == "{" {
         let nextToken = self.getToken();
         if nextToken.txt == "pub" or nextToken.txt == "pri" {
            getterMode = nextToken.txt;
            nextToken = self.getToken();
            if nextToken.txt == "," {
               nextToken = self.getToken();
               if nextToken.txt == "pub" or nextToken.txt == "pri" {
                  setterMode = nextToken.txt;
                  nextToken = self.getToken();
               }
            }
         }
         self.checkToken( nextToken, "}" );
         token = self.getToken();
      }

      // accessor
      self.checkToken( token, ";" );

      self.scope.addMember(
         varName.txt, refType.$expType, accessMode, staticFlag, false );

      return new Ast.DeclMemberNode(
         firstToken.pos, refType.$expTypeList,
         varName, refType, staticFlag, accessMode, getterMode, setterMode );
   }

fn TransUnit.analyzeDeclMethod(
   abstructFlag: bool, overrideFlag: bool, accessMode: str,
   staticFlag: bool, className: Parser.Token,
   firstToken: Parser.Token, name: Parser.Token ): Ast.Node
{
   let node = self.analyzeDeclFunc(
      abstructFlag, overrideFlag, accessMode, staticFlag, className, name, name );
   return node;
}

fn TransUnit.analyzeClassBody(
   classAccessMode: str, firstToken: Parser.Token,
   mode:str, classTypeInfo: Ast.TypeInfo,
   name:Parser.Token, moduleName: Parser.Token!, nextToken:Parser.Token ) :
   Ast.DeclClassNode, Parser.Token, Map<str,bool>
{
   let memberName2Node: Map<str,Ast.DeclMemberNode> = {};
   let fieldList:Ast.Node[] = [];
   let memberList:Ast.DeclMemberNode[] = [];
   let methodNameSet: Map<str,bool> = {};
   let initStmtList:Ast.Node[] = [];
   let advertiseList:Ast.AdvertiseInfo[] = [];
   let trustList:Ast.TypeInfo[] = [];
   let node = new Ast.DeclClassNode(
      firstToken.pos, [ classTypeInfo ],
      classAccessMode, name, fieldList, moduleName,
      memberList, self.scope, initStmtList, advertiseList, trustList, {} );
   self.typeInfo2ClassNode[ classTypeInfo ] = node;
   
   while true {
      let token = self.getToken();
      if token.txt == "}" {
         break;
      }   
      let accessMode = "pri";
      if token.txt == "pub" or token.txt == "pro" or
         token.txt == "pri" or token.txt == "global"
      {   
         accessMode = token.txt;
         token = self.getToken();
      }
      let staticFlag = false;
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken();
      }   
      let overrideFlag = false;
      if token.txt == "override" {
         overrideFlag = true;
         token = self.getToken();
      }   
      let abstructFlag = false;
      if token.txt == "abstructFlag" {
         abstructFlag = true;
         token = self.getToken();
      }   

      if token.txt == "let" {
         if mode == "interface" {
            self.error( "interface can not have member" );
         }
         let memberNode = self.analyzeDeclMember( accessMode, staticFlag, token );
         fieldList.insert( memberNode );
         memberList.insert( memberNode );
         memberName2Node[ memberNode.$name.txt ] = memberNode;
      }   
      elseif token.txt == "fn" {
         let nameToken = self.getToken();
         let methodNode = self.analyzeDeclMethod(
            abstructFlag, overrideFlag, accessMode, staticFlag, name, token, nameToken );
         fieldList.insert( methodNode );
         methodNameSet[ nameToken.txt ] = true;
      }
      elseif token.txt == "__init" {
         if mode ~= "class" {
            self.error( "%s can not have __init method" (mode) );
         }
         self.checkNextToken( "{" );
         self.analyzeStatementList( initStmtList, "}" );
         self.checkNextToken( "}" );
      }
      elseif token.txt == "advertise" {
         let memberToken = self.getSymbolToken();
         nextToken = self.getToken();
         let prefix = "";
         if nextToken.txt ~= ";" and nextToken.txt ~= "{" {
            prefix = nextToken.txt;
            nextToken = self.getToken();
         }
         self.checkToken( nextToken, ";" );
         let! memberNode = memberName2Node[ memberToken.txt ] {
            self.error( "not found member -- %s" (memberToken.txt) );
         };
         advertiseList.insert( new Ast.AdvertiseInfo( memberNode, prefix ) );
      }
      elseif token.txt == ";" {
      }
      else {
         self.error( "illegal field" );
      }
   }

   return node, nextToken, methodNameSet;
}

fn TransUnit.analyzeDeclClass(
   classAbstructFlag: bool, 
   classAccessMode: str, firstToken: Parser.Token, mode:str ): Ast.DeclClassNode
{
   let name = self.getSymbolToken();

   let moduleName: Parser.Token! = nil;
   if mode == "module" {
      self.checkNextToken( "require" );
      moduleName = self.getToken();
   }

   let nextToken, classTypeInfo = self.analyzePushClass(
      mode ~= "interface", classAbstructFlag, firstToken, name, classAccessMode );

   self.checkToken( nextToken, "{" );

   if mode == "class" {
      self.scope.add(
         Ast.SymbolKind.Var, false, true, "self", classTypeInfo, "pri", false, false );
   }



   let node, workNextToken, methodNameSet = self.analyzeClassBody(
      classAccessMode, firstToken, mode, classTypeInfo, name, moduleName, nextToken );
   nextToken = workNextToken;
   

   let parentInfo = classTypeInfo;

   let memberTypeList:Ast.TypeInfo[] = [];
   
   // accessor の生成
   foreach memberNode in node.$memberList {
      let memberType = memberNode.$expType;
      if not memberNode.$staticFlag {
         memberTypeList.insert( memberType );
      }
      let memberName = memberNode.$name;
      let getterName = "get_" .. memberName.txt;
      let accessMode = memberNode.$getterMode;
      if accessMode ~= "none" and not self.scope.getTypeInfoChild( getterName )
      {   
         let retTypeInfo = Ast.NormalTypeInfo.createFunc(
            false, false, self.pushScope( false ),
            Ast.TypeInfoKindMethod, parentInfo, true, false, false, accessMode,
            getterName, [], [ memberType ] );
         self.popScope();
         
         self.scope.addMethod( retTypeInfo, accessMode, false, false );
         methodNameSet[ getterName ] = true;
      }
      let setterName = "set_" .. memberName.txt;
      accessMode = memberNode.$setterMode;
      if memberNode.$setterMode ~= "none" and
         not self.scope.getTypeInfoChild( setterName )
      {   
         self.scope.addMethod(
            Ast.NormalTypeInfo.createFunc(
               false, false, self.pushScope( false ),
               Ast.TypeInfoKindMethod, parentInfo, true, false, false, accessMode,
               setterName, [ memberType ], nil 
            ), accessMode, false, false );
         self.popScope();
         methodNameSet[ setterName ] = true;
      }   
   }

   if not self.scope.getTypeInfoChild( "__init" ) {
      // デフォルトコンストラクタの登録
      let initTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, self.pushScope( false ),
         Ast.TypeInfoKindMethod, parentInfo, true, false, false, "pub",
         "__init", memberTypeList, [] );
      self.popScope();
      self.scope.addMethod( initTypeInfo, "pub", false, false );
      methodNameSet[ "__init" ] = true;
   }


   // advertise の処理
   foreach advertiseInfo in node.$advertiseList {
      let memberType = advertiseInfo.$member.$expType;
      switch memberType.$kind {
         case Ast.TypeInfoKindClass, Ast.TypeInfoKindIF {
            foreach child in memberType.$children {
               if child.$kind == Ast.TypeInfoKindMethod and
                  child.$accessMode ~= "pri" and
                  not child.$staticFlag
               {
                  let childName = advertiseInfo.$prefix .. child.getTxt();
                  if not methodNameSet[ childName ] {
                     self.scope.addMethod(
                        child, child.$accessMode, child.$staticFlag, false );
                  }
               }
            }
         }
         default {
            self.error( "advertise member type is illegal -- %s"
                        (advertiseInfo.$member.$name) );
         }
      }
   }
   

   self.popClass();

   return node;
}   

pri fn TransUnit.addMethod( className: str, methodNode: Ast.Node, name: str ) {
   let classTypeInfo = self.scope.getTypeInfo(
      className, self.scope, false );
   let classNodeInfo = unwrap self.typeInfo2ClassNode[ classTypeInfo ];

   classNodeInfo.$outerMethodSet[ name ] = true;
   classNodeInfo.$fieldList.insert( methodNode );
}


fn TransUnit.analyzeDeclFunc(
   abstructFlag: bool, overrideFlag: bool, accessMode: str,
   staticFlag: bool, classNameToken: Parser.Token!,
   firstToken: Parser.Token, name: Parser.Token! ) : Ast.Node
{
   let token = self.getToken();
   if! name {
      name = self.checkSymbol( _exp );
   }
   else {
      if token.txt ~= "(" {
         name = self.checkSymbol( token );
         token = self.getToken();
      }
   }
   let needPopFlag = false;
   if token.txt == "." {
      needPopFlag = true;
      classNameToken = name;
      
      let classTypeInfo = unwrap self.scope.getTypeInfoChild( (unwrap name).txt );

      self.pushClass(
         classTypeInfo.$kind == Ast.TypeInfoKindClass,
         classTypeInfo.$abstructFlag, nil, nil, false, (unwrap name).txt, "pub" );

      name = self.getSymbolToken();
      token = self.getToken();
   }

   let kind = Ast.nodeKindDeclConstr;
   let typeKind = Ast.TypeInfoKindFunc;
   if classNameToken {
      if not staticFlag {
         typeKind = Ast.TypeInfoKindMethod;
      }
      if (unwrap name).txt == "__init" {
         kind = Ast.nodeKindDeclConstr;
      }
      else {
         kind = Ast.nodeKindDeclMethod;
      }
   }
   else {
      kind = Ast.nodeKindDeclFunc;
      if not staticFlag {
         staticFlag = true;
      }
   }

   let funcName = "";
   if! name {
      funcName = _exp.txt;

      if kind == Ast.nodeKindDeclFunc {
         switch accessMode {
            case "pub", "global" {
               if self.scope ~= self.moduleScope {
                  self.addErrMess( firstToken.pos,
                                   "'global' or 'pub' function must exist top scope." );
               }
            }
         }
      }  
   }
   
   if overrideFlag {
      // オーバーライドの型チェック
      if not name {
         self.error( "name is nil" );
      };       
      let! overrideType = self.scope.getTypeInfoField( funcName,
                                                       false, self.scope )
      {
         self.error( "not found override -- " .. funcName );
      };
      if overrideType.get_accessMode() ~= accessMode {
         self.error( "missmatch override accessMode -- %s,%s,%s"
                     ( funcName, overrideType.get_accessMode(), accessMode ) );
      }
      if overrideType.get_staticFlag() ~= staticFlag {
         self.error( "missmatch override staticFlag -- " .. funcName );
      }
      if overrideType.get_kind() ~= Ast.TypeInfoKindMethod {
         self.error( "missmatch override kind -- %s, %d"
                     ( funcName, overrideType.get_kind() ) );
      }
   }
   else {
      if! name {
         if _exp.txt ~= "__init" and
            self.scope.getTypeInfoField( _exp.txt, false, self.scope )
         {          
            // override 宣言していないのに、オーバーライドしている場合エラー
            self.error( "missmatch override --" .. funcName );
         }
      }
   }


   self.checkToken( token, "(" );

   let scope = self.pushScope( false );

   let argList:Ast.Node[] = [];
   token = self.analyzeDeclArgList( accessMode, argList );
   let argTypeList:Ast.TypeInfo[] = [];
   foreach argNode in argList {
      argTypeList.insert( argNode.$expType );
   }

   self.checkToken( token, ")" );

   token = self.getToken();
   let retTypeInfoList:Ast.TypeInfo[] = [];
   if token.txt == ":" {
      repeat {
         let refType = self.analyzeRefType( accessMode );
         retTypeInfoList.insert( refType.$expType );
         token = self.getToken();
      } token.txt ~= ",";
   }

   let typeInfo = Ast.NormalTypeInfo.createFunc(
      abstructFlag, false, scope,
      typeKind, self.getCurrentNamespaceTypeInfo(),
      false, false, staticFlag, accessMode,
      funcName, argTypeList, retTypeInfoList );
   if! name {
      let parentScope = scope.get_parent();
      if accessMode == "global" {
         parentScope = Ast.rootScope;
      }
      
      if kind == Ast.nodeKindDeclFunc {
         parentScope.addFunc( typeInfo, accessMode, staticFlag, false );
      }
      else {
         parentScope.addMethod( typeInfo, accessMode, staticFlag, false );
      }
   }

   let node:Ast.Node = self.createNoneNode( firstToken.pos );
   if token.txt == ";" {
      node = self.createNoneNode( firstToken.pos );
   }
   else {
      self.pushback();
      let body = self.analyzeBlock( "func", scope );
      let info:Ast.DeclFuncInfo = new Ast.DeclFuncInfo(
         classNameToken, name, argList, staticFlag, accessMode,
         body, retTypeInfoList );
      // node = self.createNode( kind, firstToken.pos, [ typeInfo ], info );

      switch ( kind ) {
         case Ast.nodeKindDeclConstr {
            node = new Ast.DeclConstrNode( firstToken.pos, [ typeInfo ], info );
         }
         case Ast.nodeKindDeclMethod {
            node = new Ast.DeclMethodNode( firstToken.pos, [ typeInfo ], info );
         }
         case Ast.nodeKindDeclFunc {
            node = new Ast.DeclFuncNode( firstToken.pos, [ typeInfo ], info );
         }
         default {
            self.error( "illegal kind -- %d" (kind) );
         }
      }
   }

   self.popScope();

   if needPopFlag {
      self.addMethod( (unwrap classNameToken).txt, node, funcName );
      self.popClass();
   }

   return node;
}

fn TransUnit.analyzeDeclVar(
   mode:str, accessMode: str, firstToken: Parser.Token ): Ast.Node
{
   let unwrapFlag = false;
   let token, continueFlag = self.getContinueToken();
   if continueFlag and token.txt == "!" {
      unwrapFlag = true;
   }
   else {
      self.pushback();
      if mode ~= "let" {
         Util.log( "need '!'" );
      }
   }

   let typeInfoList : Ast.TypeInfo[] = [];

   if accessMode == "pub" {
      if self.scope ~= self.moduleScope {
         self.addErrMess( firstToken.pos, "'pub' variable must exist top scope." );
      }
   }
   
   let varNameList:Parser.Token[] = [];
   let varTypeList:Ast.RefTypeNode![] = [];
   repeat {
      let varName = self.getSymbolToken();
      token = self.getToken();
      let typeInfo = Ast.builtinTypeNone;
      if token.txt == ":" {
         let refType = self.analyzeRefType( accessMode );
         varTypeList.insert( refType );
         typeInfo = refType.$expType;
         token = self.getToken();
      }
      else {
         varTypeList.insert( nil );
      }
      varNameList.insert( varName );
      typeInfoList.insert( typeInfo );
   } token.txt ~= ",";

   let expList:Ast.ExpListNode! = nil;
   if token.txt == "=" {
      expList = self.analyzeExpList( false );
      if not expList {
         self.error( "expList is nil" );
      }
   }

   let orgExpTypeList: Ast.TypeInfo[] = [];
   if! expList {
      //  初期化値の型を反映する
      let expTypeList: Ast.TypeInfo[] = [];
      foreach exp, index in _exp.$expList {
         if not exp.canBeRight() {
            self.addErrMess( exp.$pos,
                             "this node can not be r-value. -- %s"
                             (Ast.getNodeKindName( exp.$kind ) ) );
         }
         if index == #_exp.$expList {
            // 最終要素の場合
            if exp.$expType == Ast.builtinTypeDDD {
               // ... なら、残りの変数宣言の分 stem をセットする
               for subIndex = index, #varNameList {
                  let argType = typeInfoList[ subIndex ];
                  if argType ~= Ast.builtinTypeNone and
                     not argType.isSettableFrom( Ast.builtinTypeStem_ )
                  {
                     self.addErrMess(
                        firstToken.pos,
                        "unmatch value type %s(%d) <- %s(%d)"
                        ( argType.getTxt(), argType.$typeId,
                          Ast.builtinTypeStem_.getTxt(), Ast.builtinTypeStem_.$typeId ));
                  }
                  if unwrapFlag {
                     expTypeList.insert( Ast.builtinTypeStem );
                  }
                  else {
                     expTypeList.insert( Ast.builtinTypeStem_ );
                  }
                  orgExpTypeList.insert( Ast.builtinTypeStem_ );
               }
            }
            else {
               foreach typeInfo in exp.$expTypeList {
                  orgExpTypeList.insert( typeInfo );
                  if unwrapFlag and typeInfo.$nilable {
                     typeInfo = unwrap typeInfo.$orgTypeInfo;
                  }
                  expTypeList.insert( typeInfo );
                  let argType = typeInfoList[ index ];
                  if not (unwrapFlag and typeInfo == Ast.builtinTypeNil) and
                     argType ~= Ast.builtinTypeNone  and
                     not argType.isSettableFrom( typeInfo )
                  {                       
                     self.addErrMess(
                        firstToken.pos,
                        "unmatch value type %s <- %s"
                        (argType.getTxt(), typeInfo.getTxt()));
                  }
               }
            }
         }
         else {
            // 最終要素でない場合
            let expTypeInfo: Ast.TypeInfo = Ast.builtinTypeStem_;
            if exp.$expType == Ast.builtinTypeDDD {
               expTypeInfo = Ast.builtinTypeStem_;
            }
            else {
               expTypeInfo = exp.$expType;
            }
            orgExpTypeList.insert( expTypeInfo );
            if unwrapFlag and expTypeInfo.$nilable {
               expTypeInfo = unwrap expTypeInfo.$orgTypeInfo;
            }
            
            let argType = typeInfoList[ index ];
            if argType ~= Ast.builtinTypeNone and
               not argType.isSettableFrom( expTypeInfo )
            {               
               self.addErrMess(
                  firstToken.pos,
                  "unmatch value type %s <- %s"
                  (argType.getTxt(), expTypeInfo.getTxt()));
            }
            expTypeList.insert( expTypeInfo );
         }
      }
      foreach typeInfo, index in expTypeList {
         if not typeInfoList[ index ] or typeInfoList[ index ] == Ast.builtinTypeNone {
            typeInfoList[ index ] = typeInfo;
         }
      }
   }

   if self.macroScope {
      foreach varName, index in varNameList {
         let typeInfo = typeInfoList[ index ];
         
         self.symbol2ValueMapForMacro[ varName.txt ] =
            new Ast.MacroValInfo( nil, typeInfo);
      }
   }


   let syncScope:Ast.Scope = self.scope;
   if mode == "sync" {
      syncScope = self.pushScope( false );
   }
   
   let varList:Ast.VarInfo[] = [];
   let sameSymbolList:Ast.VarInfo[] = [];
   let currentClass = self.getCurrentClass();
   foreach varName, index in varNameList {
      let typeInfo = typeInfoList[ index ];
      let varInfo = new Ast.VarInfo( varName, varTypeList[ index ], typeInfo );
      varList.insert( varInfo );
      if not varTypeList[ index ] and typeInfo == Ast.builtinTypeNil {
         self.addErrMess(
            varName.pos, 'need type -- %s' ( varName.txt ) ); 
      }
      let sameTypeInfo = self.scope.getTypeInfo( varName.txt, self.scope, true );
      if! sameTypeInfo {
         sameSymbolList.insert( varInfo );
      }
      // スコープに変数を登録
      if mode == "let" or mode == "sync" {
         if mode == "let" {
            if self.scope.getTypeInfo( varName.txt, self.scope, true ) {
               self.addErrMess( varName.pos,
                                "shadowing variable -- %s" (varName.txt) );
            }
         }
         self.scope.addVar( accessMode, varName.txt, typeInfo, false );
      }
   }

   let unwrapBlock: Ast.BlockNode! = nil;
   let thenBlock: Ast.BlockNode! = nil;
   if unwrapFlag {
      let scope = self.pushScope( false );

      // unwrap ブロックに変数を登録
      foreach varName, index in varNameList {
         self.scope.addLocalVar(
            false, true, "_" .. varName.txt, orgExpTypeList[ index ], false );
      }
      
      unwrapBlock = self.analyzeBlock( "let!", scope );
      self.popScope();

      token = self.getToken();
      if token.txt == "then" {
         thenBlock = self.analyzeBlock( "let!", scope );
      }
      else {
         self.pushback();
      }
   }

   let syncBlock: Ast.BlockNode! = nil;
   if mode == "sync" {
      let nextToken = self.getToken();
      if nextToken.txt == "do" {
         syncBlock = self.analyzeBlock( "let!", syncScope );
      }
      else {
         self.pushback();
      }
      self.popScope();
   }

   self.checkNextToken( ";" );

   let node = new Ast.DeclVarNode(
      firstToken.pos, [ Ast.builtinTypeNone ], mode, accessMode, false,
      varList, expList, typeInfoList, unwrapFlag, unwrapBlock,
      thenBlock, sameSymbolList, syncBlock );
   
   return node;
}
