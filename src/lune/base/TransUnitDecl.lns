/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

/**
タプル型の解析。
*/
fn TransUnit.analyzeRefTypeTuple(
   firstToken:&Types.Token, accessMode: Ast.AccessMode, allowDDD:bool, parentPub:bool,
   allowOmitTypeParamFlag:bool, allowToSetAlt:bool ) mut : Nodes.RefTypeNode
{
   let tupleParamList:List<&Nodes.TupleParamInfo> = [];
   let typeList:List<&Ast.TypeInfo> = [];
   while true {
      let mut symToken:&Types.Token! = nil;
      {
         let work = self.getToken(##);
         if work.kind == .Symb {
            if self.getToken(##).txt == ":" {
               symToken = work;
            } else {
               self.pushback();
            }
         } else {
            self.pushback();
         }
      }
      
      let refTypeNode = self.analyzeRefType(
         accessMode, allowDDD, parentPub, allowOmitTypeParamFlag, allowToSetAlt );
      tupleParamList.insert( new Nodes.TupleParamInfo( symToken, refTypeNode ) );
      typeList.insert( refTypeNode.$expType );
      // if refTypeNode.$expType.$nilable {
      //    self.addErrMess(
      //       refTypeNode.$pos,
      //       "tuple can't include nilable -- %s" (refTypeNode.$expType.getTxt(##)) );
      // }
      let token = self.getToken(##);
      if token.txt == ")" {
         break;
      }
      self.checkToken( token, "," );
   }

   if #tupleParamList == 0 {
      self.addErrMess( firstToken.pos, "tuple size is 0." );
   }

   let mut tupleTypeInfo:&Ast.TypeInfo =
      self.processInfo.createTuple( false, accessMode, typeList );

   let nextToken = self.getToken(##);
   if nextToken.txt == "!" {
      tupleTypeInfo = tupleTypeInfo.$nilableTypeInfo;
   } else {
      self.pushback();
   }

   let declTupleNode = Nodes.DeclTupleNode.create(
      self.nodeManager, firstToken.$pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ tupleTypeInfo ], tupleParamList );
   
   return Nodes.RefTypeNode.create(
      self.nodeManager, firstToken.$pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ tupleTypeInfo ],
      declTupleNode, [], {}, .IMut, "no" );
}

/**
参照する型情報を解析する。

@param accessMode この型のアクセス制御
@param allowDDD ... を型として許す場合 true
@param parentPub この型を使用している親の空間自体が public な場合 true
@param allowOmitTypeParamFlag generics の型参照の時、
    <> の型パラメータを省略を許可するかどうか。
*/
fn TransUnit.analyzeRefType(
   accessMode: Ast.AccessMode, allowDDD:bool, parentPub:bool,
   allowOmitTypeParamFlag:bool, allowToSetAlt:bool ) mut: Nodes.RefTypeNode
{
   let firstToken = self.getToken(##);

   if firstToken.txt == "(" {
      return self.analyzeRefTypeTuple( firstToken, accessMode, allowDDD, parentPub,
                                       allowOmitTypeParamFlag, allowToSetAlt );
   }

   
   let mut token = firstToken;
   let mutMode:Ast.MutMode!;
   switch token.txt {
      case "&" {
         mutMode = .IMut;
         token = self.getToken(##);
      }
      case "allmut" {
         mutMode = .AllMut;
         token = self.getToken(##);
      }
      case "#" {
         mutMode = .Depend;
         token = self.getToken(##);
      }
      default {
         mutMode = nil;
      }
   }
   // builtin の型名などは _ で始まることもあるので、シンボル名チェックしない
   // self.checkSymbol( token, .MustNot_ );

   let name:Nodes.Node;
   if token.txt == "..." {
      // ... は変数シンボルとしても使用するので
      // analyzeExpSymbol で解析すると意図しないシンボルを取ってくる可能性があるため、
      // ここで特別に処理する。
      let dddSym = unwrap self.moduleScope.getSymbolInfo(
         "...", self.moduleScope, true, .Normal );
      name = Nodes.ExpRefNode.create(
         self.nodeManager, token.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ dddSym.$typeInfo ], 
         new Ast.AccessSymbolInfo( self.processInfo, dddSym, .None, true ) );
   }
   else {
      name = self.analyzeExpSymbol( firstToken, token, .Symbol, nil, true, false, false );
      let symbolList = name.getSymbolInfo();
      if #symbolList > 0 {
         let symbol = symbolList[ 1 ];
         if symbol.$kind ~= .Typ {
            self.addErrMess( name.$pos, "illegal type -- %s" ( symbol.$name ) );
         }
      }
      else {
         self.addErrMess( name.$pos,
                          "illegal symbol node -- %s"
                          ( Nodes.getNodeKindName( name.$kind ) ) );
      }
   }

   let mut refTypeNode = self.analyzeRefTypeWithSymbol(
      accessMode, allowDDD, mutMode, name, parentPub, allowToSetAlt );

   if not allowOmitTypeParamFlag {
      let valid, mess = refTypeNode.checkValidGenerics();
      if not valid {
         self.addErrMess( refTypeNode.$pos, mess );
      }
   }
   return refTypeNode;
}

fn TransUnit.createGeneric(
   pos:&Types.Position, genSrcTypeInfo:&Ast.TypeInfo,
   itemTypeInfoList:&List<&Ast.TypeInfo> ) mut : Ast.GenericTypeInfo, Ast.Scope
{
   foreach itemType, index in genSrcTypeInfo.$itemTypeInfoList {
      if itemType.hasBase() and
         not itemTypeInfoList[ index ].isInheritFrom(
            self.processInfo, itemType.$baseTypeInfo ##) 
      {
         self.addErrMess(
            pos,
            "'%s' of %s doesn't inherit '%s'"
            (itemType.getTxt(##), genSrcTypeInfo.getTxt(##),
              itemType.$baseTypeInfo.getTxt(##)) );
      }
      foreach ifType in itemType.$interfaceList {
         if not itemTypeInfoList[ index ].isInheritFrom( self.processInfo, ifType ##) {
            self.addErrMess(
               pos,
               "'%s' of %s doesn't inherit '%s'"
               (itemType.getTxt(##), genSrcTypeInfo.getTxt(##), ifType.getTxt(##)) );
         }
      }
   }
   return self.processInfo.createGeneric(
      genSrcTypeInfo, itemTypeInfoList, self.moduleType )**;
}

/**
generic の型引数の実引数の解析。

Map<int,str> の <int,str> を解析する。
このを実行する前に '<' を読み込んでおく。

@param accessMode この型のアクセス制御
@param parentPub この型を使用している親の空間自体が public な場合 true
@param itemIndex2alt <T=int,str> の T= の部分の、 型パラメータ index -> AlternateTypeInfo>。
   この情報を定義できない場合は、 nil を指定する。
@return 型引数の実引数の型のリスト。
*/
fn TransUnit.analyzeTypeParamArg(
   accessMode: Ast.AccessMode, parentPub:bool, itemNodeList:List<&Nodes.Node>,
   itemIndex2alt:Map<int,&Ast.AlternateTypeInfo>! ) mut : &List<&Ast.TypeInfo>
{
   let mut genericList: List<&Ast.TypeInfo> = [];
   let mut nextToken: &Parser.Token = Parser.getEofToken();
   repeat {
      let altToken = self.getToken(##);
      let altMode;
      if self.getToken(##).txt ~= "=" {
         altMode = false;
         self.pushback();
         self.pushback();
      } else {
         altMode = true;
      }
      
      let typeExp = self.analyzeRefType( accessMode, false, parentPub, false, false );
      if altMode {
         let altType = self.processInfo.createAlternate(
            false, #genericList + 1, altToken.txt,
            accessMode, self.moduleType, nil, [], typeExp.$expType );
         when! itemIndex2alt {
            itemIndex2alt[ #genericList + 1 ] = altType;
         } else {
            self.addErrMess(
               altToken.pos,  
               "It can't use the type parameter's name. -- %s" (altToken.txt) );
         }
      }
      
      itemNodeList.insert( typeExp );
      genericList.insert( typeExp.$expType );
      if typeExp.$expType.$mutMode == .Depend {
         self.addErrMess(
            typeExp.$pos,
            "type parameter can't have dep attribute. -- %s"
            (typeExp.$expType.getTxt(##)) );
      }
      nextToken = self.getToken(##);
   } nextToken.txt ~= ",";
   self.checkToken( nextToken, '>' );

   return genericList;
}

fn TransUnit.analyzeRefTypeWithSymbol(
   accessMode: Ast.AccessMode, allowDDD:bool, mutMode:Ast.MutMode!,
   symbolNode:&Nodes.Node, parentPub:bool, allowToSetAlt:bool ) mut:
   Nodes.RefTypeNode
{
   let mut typeInfo = symbolNode.$expType;
   if typeInfo.$kind == .Set and not self.helperInfo.useSet {
      self.helperInfo.useSet = true;
   } elseif typeInfo == self.builtinFunc.__ret_ and not self.helperInfo.useResult {
      self.helperInfo.useResult = true;
   } elseif typeInfo == self.builtinFunc.__er_ and not self.helperInfo.useError {
      self.helperInfo.useError = true;
   }
   

   if! let aliasType = typeInfo@@@Ast.AliasTypeInfo {
      let aliasSrc = aliasType.$aliasSrcTypeInfo;
      if not self.importModuleSet.has( aliasSrc.getModule() ) and
         self.moduleType.$parentInfo ~= aliasSrc.getModule().$parentInfo
      {
         // 本来は alias の定義元のモジュールのインポートは不要だが、
         // 現状の go への変換では定義元のモジュールが必要になるため、
         // 定義元のモジュールをインポートしていない場合、エラーとする。
         // なお、 go は同じディレクトリ内はインポート不要なので、
         // 異なるディレクトリの場合だけエラーとする。
         self.addErrMess(
            symbolNode.$pos,
            "must import '%s' for this alias -- %s (%s,%s)"
            ( aliasSrc.getModule().getFullName(
               self.typeNameCtrl, self.$scope, false ),
              symbolNode.getSymbolInfo()[1].$name,
              self.moduleType.$typeId.id,
              aliasSrc.getModule().$typeId.id ) );
      }
   }
   

   if parentPub and
      Ast.isPubToExternal( accessMode ) and
      not Ast.isPubToExternal( typeInfo.$accessMode )
   {
      // 公開する型の中で非公開な型を利用するのは NG
      self.addErrMess( symbolNode.$pos,
                       "This type must be public. -- %s" (typeInfo.getTxt(##) ));
   }
   

   let continueToken, continueFlag = self.getContinueToken();
   let mut token = continueToken;
   if continueFlag and token.txt == "!" {
      typeInfo = typeInfo.get_nilableTypeInfo();
      token = self.getToken(##);
   }

   let mut itemNodeList:List<&Nodes.Node> = [];
   let mut arrayMode = "no";
   let itemIndex2alt:Map<int,&Ast.AlternateTypeInfo>! = allowToSetAlt and {} or nil;

   while true {
      if #itemNodeList > 0 {
         self.pushback();
         break;
      }
      if token.txt == '[' or token.txt == '[@' {
         if token.txt == '[' {
            arrayMode = "list";
            typeInfo = self.processInfo.createList(
               accessMode, self.getCurrentClass(), [ typeInfo ], .Mut );
         }
         else {
            arrayMode = "array";
            typeInfo = self.processInfo.createArray(
               accessMode, self.getCurrentClass(), [ typeInfo ], .Mut );
         }
         token = self.getToken(##);
         if token.txt ~= ']' {
            self.pushback();
            self.checkNextToken( ']' );
         }
         itemNodeList.insert( symbolNode );
      }
      elseif token.txt == "<" {
         // if token.txt == "<" {
         let genericList = self.analyzeTypeParamArg(
            accessMode, parentPub, itemNodeList, itemIndex2alt );

         fn checkAlternateTypeCount( count:int ) __trans : bool {
            if #genericList ~= count {
               self.addErrMess(
                  symbolNode.$pos,
                  "generic type count is unmatch. -- %d" (#genericList) );
               return false;
            }
            return true;
         }

         switch typeInfo.$kind {
            case .Map {
               if #genericList ~= 2 {
                  self.addErrMess( symbolNode.$pos, "Key or value type is unknown" );
                  typeInfo = self.processInfo.createMap(
                     accessMode, self.getCurrentClass(),
                     Ast.builtinTypeStem, Ast.builtinTypeStem, .Mut );
               }
               else {
                  typeInfo = self.processInfo.createMap(
                     accessMode, self.getCurrentClass(),
                     genericList[ 1 ], genericList[ 2 ], .Mut );
                  if genericList[ 1 ].$nilable or genericList[ 2 ].$nilable {
                     self.addErrMess(
                        symbolNode.$pos,
                        "The key or value type must not be nilable. -- %s"
                        (typeInfo.getTxt(##)) );
                  }
               }
            }
            case .List {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.processInfo.createList(
                     accessMode, self.getCurrentClass(),
                     genericList, .Mut );
               }
            }
            case .Array {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.processInfo.createArray(
                     accessMode, self.getCurrentClass(),
                     genericList, .Mut );
               }
            }
            case .Set {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.processInfo.createSet(
                     accessMode, self.getCurrentClass(),
                     genericList, .Mut );
                  if genericList[ 1 ].$nilable {
                     self.addErrMess(
                        symbolNode.$pos,
                        "The value type must not be nilable. -- %s"
                        (typeInfo.getTxt(##)) );
                  }
               }
            }
            case .DDD {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.processInfo.createDDD( genericList[1], false, false );
               }
            }
            case .Class, .IF, .Alge, .FormFunc {
               if checkAlternateTypeCount( #typeInfo.$itemTypeInfoList ) {
                  foreach itemType in genericList {
                     if itemType.$nilable {
                        self.addErrMess(
                           symbolNode.$pos,
                           "can't use nilable type -- %s" (itemType.getTxt(##)) );
                     }
                  }
                  typeInfo = self.createGeneric( symbolNode.$pos, typeInfo, genericList );
               }
            }
            case .Box {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.processInfo.createBox( accessMode, genericList[1] );
               }
            }
            case .Ext {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = self.createExtType( symbolNode.$pos, genericList[1] );
               }
            } default {
               self.error( string.format( "not support generic: %s", // 要対応
                                          typeInfo.getTxt(##) ) );
            }
         }
      } else {
         self.pushback();
         break;
      }
      token = self.getToken(##);
   }
   if token.txt == "!" {
      typeInfo = typeInfo.get_nilableTypeInfo();
      self.getToken(##);
   }

   if not allowDDD {
      if typeInfo.$kind == .DDD {
         self.addErrMess( symbolNode.$pos,
                          "invalid type. -- '%s'" (typeInfo.getTxt(##) ) );
      }
   }

   when! mutMode {
      if typeInfo.$mutMode ~= mutMode {
         typeInfo = self.createModifier( typeInfo, mutMode );
      }
   }

   if typeInfo.$kind == .Module {
      self.addErrMess( symbolNode.$pos,
                       "module can't use as Type. -- %s" ( typeInfo.getTxt(##) ) );
   }

   return Nodes.RefTypeNode.create(
      self.nodeManager, symbolNode.$pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ],
      symbolNode, itemNodeList, unwrap itemIndex2alt default {}, mutMode, arrayMode );
}

fn TransUnit.analyzeDeclArgList(
   accessMode:Ast.AccessMode, scope:Ast.Scope,
   argList: List<&Nodes.Node>, parentPub:bool ) mut : &Parser.Token
{
   let mut nextToken: &Parser.Token = Parser.noneToken;
   let mut hasDDDFlag = false;
   repeat {
      nextToken = self.getToken(##);
      if nextToken.txt == ")" {
         break;
      }

      if hasDDDFlag {
         self.addErrMess( nextToken.pos, "Argument exists after '...'." );
      }

      let mut mutable = Ast.MutMode.IMut;
      if nextToken.txt == "mut" {
         mutable = .Mut;
         nextToken = self.getToken(##);
      }
      let mut argName = nextToken;
      if argName.txt == "..." {
         hasDDDFlag = true;

         let workToken, flag = self.getContinueToken();
         self.pushback();

         let mut dddTypeInfo = Ast.builtinTypeDDD;
         if flag and workToken.txt == "<" {
            self.pushbackToken( nextToken );
            let refTypeNode = self.analyzeRefType(
               accessMode, true, parentPub, false, false );
            dddTypeInfo = refTypeNode.$expType;
         }

         argList.insert(
            Nodes.DeclArgDDDNode.create(
               self.nodeManager, argName.pos, self.inTestBlock,
               self.macroCtrl.isInAnalyzeArgMode(), [ dddTypeInfo ] ) );
         scope.addLocalVar(
            self.processInfo, true, true, argName.txt, argName.pos, dddTypeInfo, .IMut );
      }
      else {
         argName = self.checkSymbol( argName, .MustNot_ );

         self.checkShadowing( argName.pos, argName.txt, scope );

         self.checkNextToken( ":" );

         let refType = self.analyzeRefType( accessMode, false, parentPub, false, false );
         
         if refType.$expType.$kind == .Class and #refType.$expType.$itemTypeInfoList > 0
         {
            let argType = refType.$expType.$srcTypeInfo;
            if not Ast.isGenericType( argType ) {
               self.addErrMess(
                  refType.$pos,
                  "can't use this type without <T>. please use %s."
                  ( argType.getTxt( ## )));
            }
         }
         
         if! let symbolInfo = scope.addLocalVar(
            self.processInfo, 
            true, true, argName.txt, argName.pos, refType.$expType, mutable )
         {
            let arg = Nodes.DeclArgNode.create(
               self.nodeManager, argName.pos, self.inTestBlock,
               self.macroCtrl.isInAnalyzeArgMode(), refType.$expTypeList,
               argName, symbolInfo, refType );

            argList.insert( arg );
         }
      }
      nextToken = self.getToken(##);
   } nextToken.txt ~= ",";

   self.checkToken( nextToken, ")" );

   return nextToken;
}

fn TransUnit.checkOverrideMethod(
   overrideType:&Ast.TypeInfo, typeInfo:&Ast.TypeInfo ) : List<str>
{
   let accessMode = typeInfo.$accessMode;
   let funcName = typeInfo.$rawTxt;
   let altTypeList= typeInfo.$itemTypeInfoList;
   let mut alt2typeMap = typeInfo.$parentInfo.createAlt2typeMap( false );
   let mut errList:List<str> = [];

   
   fn addErr( mess:str ) __trans {
      let fullName = "%s.%s" (typeInfo.$parentInfo.$rawTxt, typeInfo.$rawTxt );
      errList.insert( "%s: %s: %s -- %s" ( fullName, mess, typeInfo.$display_stirng,
                                           typeInfo.$display_stirng ) );
   }

   if self.ctrl_info.validAsyncCtrl {
      if overrideType.$asyncMode ~= typeInfo.$asyncMode {
         addErr( "mismatch asyncMode --  %s, %s"
                 ( overrideType.$asyncMode.$_txt, typeInfo.$asyncMode.$_txt ) );
      }
   }
   
   if overrideType.get_accessMode() ~= accessMode {
      let mess = "mismatch override accessMode -- %s,%s"
          ( overrideType.get_accessMode().$_txt, accessMode.$_txt );
      addErr( mess );
   }
   if overrideType.get_staticFlag() ~= typeInfo.$staticFlag {
      addErr( "mismatch override staticFlag -- " .. funcName );
   }
   if overrideType.get_kind() ~= .Method {
      addErr( "mismatch override kind -- %s, %d"
                      ( funcName, overrideType.get_kind() ) );
   }
   if overrideType.$mutMode ~= typeInfo.$mutMode {
      addErr( "mismatch mutable -- %s" ( funcName ) );
   }

   if #overrideType.$itemTypeInfoList ~= #altTypeList {
      let mess = "mismatch altTypeList -- %d, %d"
          (#overrideType.$itemTypeInfoList, #altTypeList);
      addErr( mess );
   }
   else {
      foreach alterType, index in overrideType.$itemTypeInfoList {
         alt2typeMap[ alterType ] = altTypeList[ index ];
      }
   }

   let matchFlag, err = overrideType.canEvalWith(
      self.processInfo, typeInfo, .SetEq, alt2typeMap );
   if not matchFlag {
      when! err {
         addErr( "mismatch method type -- %s" (err) );
      } else {
         addErr( "mismatch method type"  );
      }
   }

   foreach retType, index in overrideType.$retTypeInfoList {
      if #typeInfo.$retTypeInfoList >= index {
         if retType.$nonnilableType.$kind == .Alternate and
            typeInfo.$retTypeInfoList[ index ].$nonnilableType.$kind ~= .Alternate
         {
            let mess =
               "not support to override the method has generics at return type. -- %s"
                (funcName);
            addErr( mess );
         }
      }
   }

   return errList;
}


local fn TransUnit.checkOverriededMethodOfAllClass() mut
{
   fn process(
      pos:&Parser.Position, alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo>,
      classScope:&Ast.Scope, superScope:&Ast.Scope )
   {
      superScope.filterTypeInfoField(
         true, classScope, self.scopeAccess,
         fn ( symbolInfo:&Ast.SymbolInfo ): bool {
            if symbolInfo.$name == "__init" {
               return true;
            }
            let mut implimented = true;
            if symbolInfo.$typeInfo.$kind == .Method {
               if! let impMethodType = classScope.getTypeInfoField(
                  symbolInfo.$name, true, classScope, self.scopeAccess )
               {
                  if impMethodType == symbolInfo.$typeInfo {
                     if symbolInfo.$typeInfo.$abstractFlag and classScope ~= superScope {
                        implimented = false;
                     }
                  } else {
                     foreach err in self.checkOverrideMethod(
                        symbolInfo.$typeInfo, impMethodType )
                     {
                        self.addErrMess( pos, err );
                     }
                  }
               } else {
                  implimented = false;
               }
            }
            if not implimented {
               self.addErrMess( pos, "not implements method -- %s.%s at %s"
                                ( superScope.$ownerTypeInfo$.getTxt$(##),
                                  symbolInfo.$name,
                                  classScope.$ownerTypeInfo$.getTxt$(##) ) );
            }
            return true;
         } );
   }

   let mut typeId2DeclClassNode:Map<int,&Nodes.DeclClassNode> = {};
   foreach classNode, classTypeInfo in self.typeInfo2ClassNode {
      typeId2DeclClassNode[ classTypeInfo.$typeId.id ] = classNode;
   }

   forsort classNode in typeId2DeclClassNode {
      let classTypeInfo = classNode.$expType;
      // extend のメソッドがオーバーライドされているか確認
      let mut workTypeInfo = classTypeInfo;
      let mut alt2typeMap = classTypeInfo.createAlt2typeMap(false);
      repeat {
         if not classTypeInfo.$abstractFlag {
            if workTypeInfo ~= Ast.headTypeInfo {
               process( classNode.$pos, alt2typeMap,
                        unwrap classTypeInfo.$scope,
                        unwrap workTypeInfo.$scope );
            }
         }
         foreach ifType in workTypeInfo.$interfaceList {
            if ifType ~= Ast.builtinTypeMapping {
               process( classNode.$pos, alt2typeMap,
                        unwrap classTypeInfo.$scope, unwrap ifType.$scope );
            }
         }
         workTypeInfo = workTypeInfo.$baseTypeInfo;
      } workTypeInfo == Ast.headTypeInfo;
   }
}

fn getAnalyzingState( typeInfo:&Ast.TypeInfo ) : AnalyzingState {
   if typeInfo.$rawTxt == "__init" and typeInfo.$kind == .Method {
      return .Constructor;
   }
   elseif typeInfo.$staticFlag and typeInfo.$kind == .Method {
      return .ClassMethod;
   }
   else {
      return .Func;
   }
}

fn getFirstStmt( stmtList:&List<&Nodes.Node> ) : &Nodes.Node! {
   foreach stmt in stmtList {
      switch stmt.$kind {
         case Nodes.nodeKindEnum.BlankLine {
         }
         default {
            return stmt;
         }
      }
   }
   return nil;
}

fn TransUnit.declFuncPostProcess(
   typeInfo:&Ast.TypeInfo, classTypeInfo: &Ast.TypeInfo!,
   workBody:Nodes.BlockNode, funcBodyScope:Ast.Scope ) mut
{
   if #funcBodyScope.$closureSymList > 0 {
      funcBodyScope.set_hasClosureAccess( true );
   }
   
   when! classTypeInfo {
      let isCtorFlag = typeInfo.$rawTxt == "__init";
      if isCtorFlag and classTypeInfo.hasBase() {
         // Super クラスを持っている場合、
         // 先頭の処理で super() をコールしているか調べる
         let mut needCall = true;
         if! let firstNode = getFirstStmt( workBody.$stmtList ) {
            if firstNode.$kind == Nodes.nodeKindEnum.ExpCallSuperCtor {
               needCall = false;
            }
         }
         if needCall {
            self.addErrMess(
               workBody.$pos,             
               "__init must call super() with first." );
         }
      }
      // if classTypeInfo.isInheritFrom(
      //    self.processInfo, Ast.builtinTypeRunner, nil )
      // {
      //    if typeInfo.$accessMode == .Pub and #typeInfo.$retTypeInfoList > 0 {
      //       let mut callJoin = false;
      //       if! let firstNode = getFirstStmt( workBody.$stmtList ) {
      //          if! let stmtNode = firstNode@@@Nodes.StmtExpNode {
      //             if! let callNode = stmtNode.$exp@@@Nodes.ExpCallNode {
      //                if callNode.$func.$expType == self.builtinFunc.lns___join {
      //                   callJoin = true;
      //                }
      //             }
      //          }
      //       }
      //       if not callJoin {
      //          self.addErrMess(
      //             workBody.$pos,       
      //             "public method to return the value must call __join. -- %s"
      //             (typeInfo.getTxt(##)));
      //       }
      //    }
      // }
   }
}

pub form ReadyExportInfo( exportInfo:&frontInterface.ExportInfo ) __trans;


fn TransUnit.analyzeDeclMacroSub(
   accessMode: Ast.AccessMode,
   firstToken: &Parser.Token, nameToken: &Parser.Token,
   macroScope:Ast.Scope, parentType:&Ast.TypeInfo,
   typeDataAccessor:Ast.TypeDataAccessor,
   workArgList: List<&Nodes.Node> ) mut : Nodes.DeclMacroNode
{
   if self.macroCtrl.$isDeclaringMacro {
      // macro 定義内に、別のマクロ定義はサポート外
      self.error( "can't declare the macro in the macro." ); // 要対応
   }
   
 
   
   let mut pubFlag = false;
   switch accessMode {
      case .Pub {
         pubFlag = true;
      }
      case .Local, .None {
      }
      default {
         self.addErrMess( firstToken.pos,
                          "macro not support this access mode. -- %s"
                          ( accessMode.$_txt ) );
      }
   }
   
   // let mut workArgList: List<&Nodes.Node> = [];
   let mut argList: List<&Nodes.DeclArgNode> = [];
   // let mut nextToken = self.analyzeDeclArgList( accessMode, workArgList, false );
   let mut argTypeList: List<&Ast.TypeInfo> = [];
   foreach argNode in workArgList {
      if! argNode@@@Nodes.DeclArgNode {
         argList.insert( _exp );
      }
      else {
         self.error( "macro argument can not use '...'." ); // 要対応
      }
      let argType = argNode.$expType;
      argTypeList.insert( argType );
   }

   let mut nextToken = self.getToken(##);

   let retTypeList;
   if nextToken.txt == ":" {
      retTypeList = self.analyzeRefType(
         accessMode, true, false, false, false ).$expTypeList;
      self.checkNextToken( "{");
   }
   else {
      retTypeList = [];
      self.checkToken( nextToken, "{");
   }

   let typeInfo = self.processInfo.createFuncAsync(
      false, false, macroScope, .Macro, parentType, typeDataAccessor,
      false, false, true,
      accessMode, nameToken.txt, .Async, nil, argTypeList, retTypeList, .IMut );
   //self.scope.addLocalVar( false, false, nameToken.txt, typeInfo, false );
   // self.scope.addMacro( typeInfo, accessMode );


   self.macroCtrl.startDecl( typeInfo );
   
   
   nextToken = self.getToken(##);

   let mut stmtNode : Nodes.BlockNode! = nil;
   if nextToken.txt == "{" {
      // macro-statement の解析

      self.macroScope = macroScope;

      // macro-statement のトップの変数のアクセス有無は確認しない。
      macroScope.set_validCheckingUnaccess( false );
  
      

      let funcType = Ast.builtinTypeLnsLoad;
      macroScope.addLocalVar(
         self.processInfo, false, false, "_lnsLoad", nil, funcType, .IMut );

      let macroLocalVarType = self.processInfo.createMap(
         .Local, self.moduleType, Ast.builtinTypeString, Ast.builtinTypeStem, .Mut );

      if not pubFlag {
         macroScope.addLocalVar(
            self.processInfo, false, true, "__var", nil, macroLocalVarType, .IMut );
      }

      let mut stmtList:List<&Nodes.Node> = [];
      self.prepareTentativeSymbol( self.$scope, false, nil );
      self.analyzeStatementList( stmtList, false, "}" );

      if #stmtList > 0 {
         stmtNode = Nodes.BlockNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(),
            [ Ast.builtinTypeNone ], .Macro, macroScope, stmtList );
      }

      self.checkNextToken( "}" );
      //self.finishTentativeSymbol( false );
      self.finishTentativeSymbol( true );

      

      // self.parser = bakParser;


      
      self.macroScope = nil;
   }
   else {
      self.pushback();
   }

   // self.popScope();

   
   // expand-statemnt の解析。
   // ここではトークン切り出しだけ行なう。
   /// 実際の解析処理は、マクロ展開時(TransUnit.evalMacroOp)に行なう。

   let mut tokenList: List<&Parser.Token> = [];
   let mut braceCount = 0;

   while true {
      nextToken = self.getToken(##);
      if nextToken.txt == "{" {
         braceCount = braceCount + 1;
      }
      elseif nextToken.txt == "}" {
         if braceCount == 0 {
            break;
         }
         braceCount = braceCount - 1;
      }
      tokenList.insert( nextToken );
   }



   let mut declMacroInfo = new Nodes.DeclMacroInfo(
      pubFlag, nameToken, argList, stmtNode, tokenList ) ;
   let mut node = Nodes.DeclMacroNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], declMacroInfo );

   if! self.macroCtrl.regist( self.processInfo, node, macroScope, self.baseDir ) {
      self.errorAt( nameToken.pos, _exp );
   }

   return node;
}


fn TransUnit.analyzeDeclMacro(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclMacroNode
{

   let nameToken = self.getSymbolToken( .Must_ );
   self.checkNextToken( "(" );


   // マクロ内は、独立スコープにするため、
   // マクロ用のスコープを topScope 直下に生成
   let mut scope = Ast.TypeInfo.createScope(
      self.processInfo, self.topScope, .Other, nil, nil );

   // 名前空間に属させるためのダミーの関数を定義
   self.createDummyNS( scope, nameToken.pos, .Noasync );

   // マクロ引数を解析。
   // このとき、マクロの型名や引数名などは現在のスコープをスコープを利用し、
   // 引数シンボルはマクロ用スコープに登録する。
   let mut workArgList: List<&Nodes.Node> = [];
   self.analyzeDeclArgList( accessMode, scope, workArgList, false );

   // マクロ解析用スコープに変更する前に、登録する namespace を取っおく
   let mut parentNsInfo = self.$curNsInfo;
   let mut parentInfo = parentNsInfo.$typeInfo;
   
   // スコープをマクロ用スコープに変更
   let mut backScope = self.$scope;
   self.setScope( scope, .FromScope );

   self.$scope.addIgnoredVar( self.processInfo );
   

   let mut node = self.analyzeDeclMacroSub(
      accessMode, firstToken, nameToken, scope,
      parentInfo, parentNsInfo.$typeDataAccessor, workArgList );

   // スコープを元に戻す
   //self.$scope = backScope;
   self.setScope( backScope, .FromScope );

   let _, existSym = self.$scope.addMacro(
      self.processInfo, nameToken.pos, node.$expType, accessMode );
   if existSym {
      self.addErrMess(
         nameToken.pos, "multiple define symbol -- %s" (nameToken.txt) );
   }
   
   return node;
}

fn TransUnit.analyzeExtend( accessMode:Ast.AccessMode, firstPos: &Parser.Position ) mut :
&Parser.Token, &Ast.TypeInfo!, &List<&Ast.TypeInfo>,
Map<&Ast.TypeInfo,&Ast.TypeInfo>, Nodes.ClassInheritInfo
{
   let mut baseRef:&Nodes.RefTypeNode! = nil;
   let mut interfaceList:List<&Ast.TypeInfo> = [];
   let mut ifAlt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo> = {};
   let mut ifRefList:List<&Nodes.RefTypeNode> = [];

   let mut nextToken = self.getToken(##);
   if nextToken.txt ~= "(" {
      self.pushback();
      let workBaseRefType = self.analyzeRefType(
         accessMode, false, Ast.isPubToExternal( accessMode ), false, true );
      baseRef = workBaseRefType;
      let baseType = workBaseRefType.$expType;
      if baseType.$kind ~= .Class {
         self.addErrMess( workBaseRefType.$pos,
                          "%s is not class." ( baseType.getTxt(##) ) );
      }
      if baseType.$finalFlag {
         self.addErrMess( workBaseRefType.$pos,
                          "final class can't extend -- (%s)" (baseType.getTxt(##)));
      }
      if Ast.isPubToExternal( accessMode ) and
         not Ast.isPubToExternal( baseType.$accessMode )
      {
         self.addErrMess(
            workBaseRefType.$pos,
            "%s can't be external symbol." ( baseType.getTxt(##) ) );
      }
      nextToken = self.getToken(##);
   }
   if nextToken.txt == "(" {
      while true {
         nextToken = self.getToken(##);
         if nextToken.txt == ")" {
            break;
         }
         self.pushback();
         let ifTypeNode = self.analyzeRefType(
            accessMode, false, Ast.isPubToExternal( accessMode ), false, true );
         ifRefList.insert( ifTypeNode );
         let ifType = ifTypeNode.$expType;
         if ifType.$kind ~= .IF {
            self.error( "%s is not interface -- %d" // 要対応
                        (ifType.getTxt(##), ifType.$kind ) );
         }

         if Ast.isGenericType( ifType ) {
            foreach genType, altType in ifType.createAlt2typeMap(false) {
               ifAlt2typeMap[ altType ] = genType;
            }
         }


         interfaceList.insert( ifType );
         if Ast.isPubToExternal( accessMode ) and
            not Ast.isPubToExternal( ifType.$accessMode )
         {
            self.addErrMess( ifTypeNode.$pos,
                             "%s can't be external symbol." ( ifType.getTxt(##) ) );
         }

         nextToken = self.getToken(##);
         if nextToken.txt ~= "," {
            if nextToken.txt == ")" {
               break;
            }
            self.error( "illegal token" ); // 要対応
         }
      }
      nextToken = self.getToken(##);
   }

   // interface 間の、メソッドのミスマッチをチェックする
   let mut symbol2TypeInfo:Map<str,&Ast.TypeInfo> = {};
   foreach ifType in interfaceList {
      if ifType == Ast.builtinTypeAbsImmut {
         when! baseRef {
            self.addErrMess( baseRef.$pos,
                             "__absimmut can't extend the class -- %s"
                             (baseRef.$expType.getTxt(##)));
         }
      }
      
      ifType.$scope$.filterTypeInfoField$(
         true, self.$scope, self.scopeAccess,
         fn ( symbolInfo:&Ast.SymbolInfo ) __trans : bool {
            if symbolInfo.$kind == .Mtd {
               if! let ifFuncType = symbol2TypeInfo[ symbolInfo.$name ] {
                  let ret, mess = ifFuncType.canEvalWith(
                     self.processInfo, symbolInfo.$typeInfo, .SetOp, ifAlt2typeMap );
                  if not ret {
                     self.addErrMess(
                        firstPos,
                        "mismatch method type -- %s.%s, %s.%s\n%s"
                        (symbolInfo.$typeInfo.$parentInfo.getTxt(##), symbolInfo.$name,
                          ifFuncType.$parentInfo.getTxt(##), ifFuncType.getTxt(##), mess));
                  }
               }
               else {
                  symbol2TypeInfo[ symbolInfo.$name ] = symbolInfo.$typeInfo;
               }
            }
            return true;
         } );
   }



   let mut baseTypeInfo:&Ast.TypeInfo! = nil;
   when! baseRef {
      baseTypeInfo = baseRef.$expType;
      if baseRef.$expType.isInheritFrom(
         self.processInfo, Ast.builtinTypeAbsImmut, nil )
      {
         self.addErrMess(
            baseRef.$pos,
            "can't extend the __absimmut. (%s)" (baseRef.$expType.getTxt(##)));
      }
   }
   return nextToken, baseTypeInfo, interfaceList,
      ifAlt2typeMap, new Nodes.ClassInheritInfo( baseRef, ifRefList );
}

fn TransUnit.analyzePushClass(
   mode:DeclClassMode, finalFlag:bool, abstractFlag: bool,
   firstToken:&Parser.Token, name:&Parser.Token,
   allowMultiple:bool, requirePath:&Parser.Token!, moduleLang:Types.Lang!,
   accessMode:Ast.AccessMode, altTypeList:&List<&Ast.AlternateTypeInfo> ) mut :
(&Parser.Token, TransUnitIF.NSInfo, &Nodes.ClassInheritInfo)!
{
   if Ast.isPubToExternal( accessMode ) and self.moduleScope ~= self.$scope
   {
      self.addErrMess( firstToken.pos, "The public class must declare at top scope." );
   }


   // altTypeList のシンボルにアクセスできるように、一時的にスコープを掘る
   let mut tempScope = self.pushScope( .Other## );
   foreach altType in altTypeList {
      tempScope.addAlternate(
         self.processInfo, accessMode, altType.$rawTxt, name.pos, altType );
   }


   let mut nextToken = self.getToken(##);
   let mut baseTypeInfo:&Ast.TypeInfo! = nil;
   let mut interfaceList:&List<&Ast.TypeInfo>! = nil;
   let inheritInfo;
   if nextToken.txt == "extend" {
      nextToken, baseTypeInfo, interfaceList, _, inheritInfo = self.analyzeExtend(
         accessMode, firstToken.pos );

      when! baseTypeInfo {
         if! let initTypeInfo = baseTypeInfo.$scope$.getTypeInfoChild$("__init") {
            if initTypeInfo.$accessMode == .Pri {
               self.addErrMess(
                  firstToken.pos, "The access mode of '__init' is 'pri'." );
            }
         } else {
            return nil;
         }
      }
   } else {
      inheritInfo = new Nodes.ClassInheritInfo( nil, [] );
   }


   // 一時的に掘ったスコープを戻す
   self.popScope();

   let mut nsInfo;
   _switch mode {
      case .Module, .LazyModule {
         let mut parentScope = self.$scope;
         nsInfo = self.pushExtModule(
            false, name.txt, accessMode, name.pos, mode == .LazyModule,
            unwrap moduleLang, (unwrap requirePath).getExcludedDelimitTxt() );
      }
      case .Class, .Interface {
         nsInfo = self.pushClass(
            self.processInfo, firstToken.pos, mode,
            finalFlag, abstractFlag, baseTypeInfo,
            interfaceList, altTypeList, false, name.txt, allowMultiple, accessMode ## );
      }
   }

   return nextToken, nsInfo, inheritInfo;
}

fn TransUnit.analyzeDeclAlternateType(
   belongClassFlag:bool, token:&Parser.Token, accessMode: Ast.AccessMode ) mut :
   &Parser.Token, List<&Ast.AlternateTypeInfo>
{
   let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
   let mut nextToken = token;
   let mut altNameSet:Set<str> = (@);
   let mut altIndex = 0;
   while true {
      altIndex = altIndex + 1;
      let genericSymToken = self.getSymbolToken( .MustNot_ );
      if self.$scope.getTypeInfo(
         genericSymToken.txt, self.$scope, false, self.scopeAccess)
      {
         self.addErrMess( genericSymToken.pos,
                          "shadowing Type -- %s" (genericSymToken.txt) );
      }
      else {
         if altNameSet.has( genericSymToken.txt ) {
            self.addErrMess( genericSymToken.pos,
                             "multiple Type -- %s" (genericSymToken.txt) );
         }
         else {
            altNameSet.add( genericSymToken.txt );
         }
      }
      let mut workToken = self.getToken(##);
      if workToken.txt == "!" {
         self.addErrMess( workToken.pos, "not support nilable" );
         workToken = self.getToken(##);
      }
      let mut baseTypeInfo:&Ast.TypeInfo! = nil;
      let mut interfaceList:&List<&Ast.TypeInfo> = [];
      if workToken.txt == ":" {
         workToken, baseTypeInfo, interfaceList = self.analyzeExtend(
            accessMode, token.pos );
      }

      let altType = self.processInfo.createAlternate(
         belongClassFlag, altIndex, genericSymToken.txt,
         accessMode, self.moduleType, baseTypeInfo, interfaceList ## );
      altTypeList.insert( altType );

      if workToken.txt == ">" {
         nextToken = self.getToken(##);
         break;
      }
      self.checkToken( workToken, "," );
   }
   return nextToken, altTypeList;
}

fn TransUnit.analyzeDeclProto(
   mut accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.Node!
{
   let mut nextToken = self.getToken(##);
   let mut abstractFlag = false;
   if nextToken.txt == "abstract" {
      abstractFlag = true;
      nextToken = self.getToken(##);
   }
   let mut finalFlag = false;
   if nextToken.txt == "final" {
      finalFlag = true;
      nextToken = self.getToken(##);
   }


   if nextToken.txt == "class" or nextToken.txt == "interface" {
      let name = self.getSymbolToken( .MustNot_ );

      // generic の型宣言解析
      let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
      {
         let mut workToken = self.getToken(##);
         if workToken.txt == "<" {
            workToken, altTypeList = self.analyzeDeclAlternateType(
               true, workToken, accessMode );
         }
         self.pushbackToken( workToken );
      }

      if accessMode == .Local {
         accessMode = .Pri;
      }

      let declMode;
      if nextToken.txt == "class" {
         declMode = DeclClassMode.Class;
      } else {
         declMode = .Interface;
         abstractFlag = true;
      }
      let classTypeInfo:&Ast.TypeInfo;
      let inheritInfo;
      let mut nsInfo;
      nextToken, nsInfo, inheritInfo = self.analyzePushClass(
         declMode, finalFlag, abstractFlag,
         firstToken, name, false, nil, nil, accessMode, altTypeList );
      classTypeInfo = nsInfo.$typeInfo;

      nsInfo.set_nobody( true );

      self.popClass();
      self.checkToken( nextToken, ";" );

      return Nodes.ProtoClassNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(),  [ classTypeInfo ], name, inheritInfo );
   }
   self.error( "illegal proto" ); // 要対応
}

fn TransUnit.analyzeDeclEnum(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclEnumNode
{
   if Ast.isPubToExternal( accessMode ) and
      self.$scope ~= self.moduleScope and
      self.$scope.$ownerTypeInfo$.$kind ~= .Class
   {
      self.addErrMess( firstToken.pos, "can't external at inner scope." );
   }
   
   let name = self.getSymbolToken( .MustNot_ );

   self.checkNextToken( "{" );

   let mut valueList:List<&Parser.Token> = [];
   //let mut valueName2Info:Map<str,Ast.EnumValInfo> = {};

   let mut scope = self.pushScope( .Class ## );

   let mut workEnumTypeInfo:Ast.EnumTypeInfo! = nil;

   let mut parentNsInfo = self.$curNsInfo;
   
   let mut nextToken = self.getToken(##);
   let mut number = 0.0;
   let mut prevValTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   let mut valTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   while nextToken.txt ~= "}" {
      let valName = self.checkSymbol(nextToken, .MustNot_ );

      nextToken = self.getToken(##);

      let mut enumVal = Ast.EnumLiteral.Real( number );
      switch ( prevValTypeInfo ) {
         case Ast.builtinTypeReal {
         }
         case Ast.builtinTypeInt, Ast.headTypeInfo {
            enumVal = .Int( number@@int );
         }
      }

      if nextToken.txt == "=" {
         let exp = self.analyzeExpOneRVal( false, false ## );
         let literal, mess = exp.getLiteral();
         when! literal {
            match literal {
               case .Int( val ) {
                  enumVal = .Int( val );
                  number = val@@real;
                  valTypeInfo = Ast.builtinTypeInt;
               }
               case .Real( val ) {
                  enumVal = .Real( val );
                  number = val;
                  valTypeInfo = Ast.builtinTypeReal;
               }
               case .Str( val ) {
                  enumVal = .Str( val );
                  valTypeInfo = Ast.builtinTypeString;
               }
               default {
                  self.error( "illegal enum val -- %s" ( literal.$_txt ) ); // 要対応
               }
            }
         }
         else {
            self.error( "illegal enum val -- %s" (mess) ); // 要対応
         }

         nextToken = self.getToken(##);
      }
      else {
         switch ( prevValTypeInfo ) {
            case Ast.headTypeInfo {
               valTypeInfo = Ast.builtinTypeInt;
            }
            case Ast.builtinTypeInt, Ast.builtinTypeReal {
               valTypeInfo = prevValTypeInfo;
            }
            default {
               self.addErrMess( valName.pos,
                                "illegal enum val type -- %s" (valTypeInfo.getTxt(##)) );
            }
         }
      }
      if prevValTypeInfo ~= Ast.headTypeInfo and prevValTypeInfo ~= valTypeInfo
      {
         self.addErrMess( valName.$pos,
                          "multiple enum val type. %s, %s"
                          (valTypeInfo.getTxt(##), prevValTypeInfo.getTxt(##)) );
      }
      prevValTypeInfo = valTypeInfo;

      if not workEnumTypeInfo {
         workEnumTypeInfo = self.processInfo.createEnum(
            scope, parentNsInfo.$typeInfo, parentNsInfo.$typeDataAccessor,
            false, accessMode, name.txt, valTypeInfo );
      }

      when! workEnumTypeInfo {
         let evalValSym = unwrap scope.addEnumVal(
            self.processInfo, valName.txt, valName.pos, workEnumTypeInfo );

         let enumValInfo = new Ast.EnumValInfo( valName.txt, enumVal, evalValSym );
         valueList.insert( valName );

         workEnumTypeInfo.addEnumValInfo( enumValInfo );
      }

      if nextToken.txt == "}" {
         break;
      }
      self.checkToken( nextToken, "," );
      nextToken = self.getToken(##);
      number = number + 1;
   }


   let! enumTypeInfo = workEnumTypeInfo {
      enumTypeInfo = self.processInfo.createEnum(
         scope, parentNsInfo.$typeInfo, parentNsInfo.$typeDataAccessor,
         false, accessMode, name.txt, Ast.builtinTypeNone );
   };

   self.popScope();

   let _, shadowing = self.$scope.addEnum(
      self.processInfo, accessMode, name.txt, name.pos, enumTypeInfo );
   self.errorShadowing( name.pos, shadowing );


   return Nodes.DeclEnumNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), 
      [ enumTypeInfo ], enumTypeInfo, accessMode, name, valueList, scope );
}



fn TransUnit.analyzeDeclAlge(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclAlgeNode
{
   if not self.helperInfo.useAlge {
      self.helperInfo.useAlge = true;
   }

   let name = self.getSymbolToken( .MustNot_ );

   // generic の型宣言解析
   let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
   {
      let mut nextToken = self.getToken(##);
      if nextToken.txt == "<" {
         nextToken, altTypeList = self.analyzeDeclAlternateType(
            true, nextToken, accessMode );
      }
      self.pushbackToken( nextToken );
   }
   

   self.checkNextToken( "{" );

   let mut scope = self.$scope;
   let mut algeScope = self.pushScope( .Class ## );
   let mut parentNsInfo = self.$curNsInfo;

   // generic の型をスコープに登録
   foreach altType in altTypeList {
      algeScope.addAlternate(
         self.processInfo, accessMode, altType.$rawTxt, name.pos, altType );
   }
   
   
   let mut algeTypeInfo = self.processInfo.createAlge(
      algeScope, parentNsInfo.$typeInfo, parentNsInfo.$typeDataAccessor,
      false, accessMode, name.txt, altTypeList );
   let _, shadowing = scope.addAlge(
      self.processInfo, accessMode, name.txt, name.pos, algeTypeInfo );
   self.newNSInfo( algeTypeInfo, name.pos );
   self.errorShadowing( name.pos, shadowing );

   let mut algeValList: List<Nodes.DeclAlgeValInfo> = [];

   let mut nextToken = self.getToken(##);
   while nextToken.txt ~= "}" {
      let valName = self.checkSymbol( nextToken, .MustNot_ );
      if algeTypeInfo.getValInfo( valName.txt ) {
         self.addErrMess( valName.pos, "multiple symbole -- %s" (valName.txt) );
      }

      nextToken = self.getToken(##);

      let mut paramList:List<&Nodes.AlgeValParamInfo> = [];
      
      let mut typeInfoList:List<&Ast.TypeInfo> = [];
      if nextToken.txt == "(" {
         // パラメータの宣言
         while true {
            // パラメータ名の確認
            let paramNameToken:&Types.Token!;
            let workToken1 = self.getToken(##);
            let workToken2 = self.getToken(##);
            if workToken2.txt ~= ":" {
               // パラメータ名を省略している場合は戻す
               self.pushback();
               self.pushback();
               paramNameToken = nil;
            } else {
               paramNameToken = workToken1;
            }
            
            let typeNode = self.analyzeRefType(
               .Pub, false, Ast.isPubToExternal( accessMode ), false, false );
            if self.nsInfoMap[ typeNode.$expType ]$.$nobody {
               self.addErrMess(
                  typeNode.$pos,
                  "can't use the prototype class -- %s" ( typeNode.$expType.getTxt(##)) );
            }
            typeInfoList.insert( typeNode.$expType );
            paramList.insert( new Nodes.AlgeValParamInfo( paramNameToken, typeNode ) );
            
            nextToken = self.getToken(##);
            if nextToken.txt ~= "," {
               self.checkToken( nextToken, ")" );
               nextToken = self.getToken(##);
               break;
            }
         }
      }

      let workAlgeValSym, algeValSymShadow = algeScope.addAlgeVal(
         self.processInfo, valName.txt, valName.pos, algeTypeInfo );
      self.errorShadowing( valName.pos, algeValSymShadow );
      let algeValSym = unwrap (workAlgeValSym or shadowing);
      let algeValInfo = new Ast.AlgeValInfo(
         valName.txt, typeInfoList, algeTypeInfo, algeValSym );
      algeTypeInfo.addValInfo( algeValInfo );

      algeValList.insert( new Nodes.DeclAlgeValInfo( algeValSym, paramList ) );

      if nextToken.txt == "}" {
         break;
      }
      self.checkToken( nextToken, "," );
      nextToken = self.getToken(##);
   }

   self.popScope();


   return Nodes.DeclAlgeNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ algeTypeInfo ], accessMode, algeTypeInfo, name, algeValList, algeScope );
}

fn TransUnit.analyzeAlias(
   accessMode: Ast.AccessMode, firstToken:&Parser.Token ) mut : Nodes.AliasNode
{
   if self.$scope ~= self.moduleScope {
      self.addErrMess( firstToken.pos, "alias must use at top scope." );
   }

   let newToken = self.getToken(##);
   self.checkNextToken( "=" );

   let srcToken = self.getToken(##);

   let symbolNode = self.analyzeExpSymbol(
      srcToken, srcToken, .Symbol, nil, true, false, false );


   let mut newTypeInfo = Ast.builtinTypeNone;
   let symbolInfoList = symbolNode.getSymbolInfo();

   let mut newSymbolInfo:&Ast.SymbolInfo = Ast.dummySymbol;

   if #symbolInfoList >= 1 {
      let symbolInfo = symbolInfoList[ 1 ];
      if newToken.txt.find( "^_" ##) and not srcToken.txt.find( "^_" ##) or
         not newToken.txt.find( "^_" ##) and srcToken.txt.find( "^_" ## )
      {
         self.addErrMess( firstToken.pos,
                          "alias symbol unmatch. %s %s" (newToken.txt, newToken.txt) );
      }
      else {
         switch symbolInfo.$kind {
            case .Typ, .Fun {
               let aliasSymbolInfo, shadowing = self.$scope.addAlias(
                  self.processInfo, newToken.txt, newToken.pos,
                  false, accessMode, self.moduleType, symbolInfo );
               when! aliasSymbolInfo {
                  newTypeInfo = aliasSymbolInfo.$typeInfo;
                  newSymbolInfo = aliasSymbolInfo;
               }
               else {
                  self.errorShadowing( newToken.pos, shadowing );
               }
            }
            default {
               self.addErrMess(
                  firstToken.pos,
                  "can alias symbol -- %s. (%s)"
                  (srcToken.txt, symbolInfo.$kind.$_txt ) );
            }
         }
      }
   }
   else {
      self.addErrMess( firstToken.pos, "not found symbold -- %s" (srcToken.txt ) );
   }
   self.checkNextToken( ";" );

   return Nodes.AliasNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ newTypeInfo ], newSymbolInfo, symbolNode, newTypeInfo );
}



fn TransUnit.analyzeRetTypeList(
   pubToExtFlag:bool, accessMode:Ast.AccessMode,
   mut token:&Parser.Token, parentPub:bool ) mut :
   List<&Ast.TypeInfo>, &Parser.Token, &List<&Nodes.RefTypeNode>
{
   let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
   let mut retTypeNodeList:List<&Nodes.RefTypeNode> = [];
   if token.txt == ":" {
      let mut hasDDDFlag = false;
      while true {
         let refTypeNode = self.analyzeRefType(
            accessMode, true, parentPub, false, false );
         if hasDDDFlag {
            self.addErrMess( refTypeNode.$pos, "Type exists after '...'." );
         }
         let retType = refTypeNode.$expType;
         if retType.$kind == .DDD {
            hasDDDFlag = true;
         }
         if pubToExtFlag and not Ast.isPubToExternal( retType.$accessMode )
         {
            self.addErrMess( refTypeNode.$pos,
                             "this is not public type -- %s" (retType.getTxt(##)) );
         }

         retTypeInfoList.insert( retType );
         retTypeNodeList.insert( refTypeNode );
         token = self.getToken(##);
         if token.txt ~= "," {
            break;
         }
      }
   }
   return retTypeInfoList, token, retTypeNodeList;
}

fn TransUnit.getMutableAsync( mut token: &Types.Token )
mut : &Types.Token, Ast.MutMode, Ast.Async!
{
   let mut asyncMode:Ast.Async! = nil;

   switch token.txt {
      case "__async" {
         asyncMode = .Async;
         token = self.getToken(##);
      }
      case "__noasync" {
         asyncMode = .Noasync;
         token = self.getToken(##);
      }
      case "__trans" {
         asyncMode = .Transient;
         token = self.getToken(##);
      }
   }
   
   let mutMode:Ast.MutMode;
   switch token.txt {
      case "mut" {
         mutMode = .Mut;
         token = self.getToken(##);
      }
      case "dep" {
         mutMode = .Depend;
         token = self.getToken(##);
      }
      default {
         mutMode = .IMut;
      }
   }
   return token, mutMode, asyncMode;
}

fn TransUnit.analyzeDeclForm( accessMode:Ast.AccessMode, firstToken:&Parser.Token )
mut : Nodes.DeclFormNode
{
   let name = self.getSymbolToken( .MustNot_ );

   if self.$scope ~= self.moduleScope and Ast.isPubToExternal( accessMode ) {
      self.addErrMess(
         firstToken.pos,
         "You must declare this form at the outside scope. -- %s"
         (name.txt) );
   }

   // generic の型宣言解析
   let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
   {
      let mut nextToken = self.getToken(##);
      if nextToken.txt == "<" {
         nextToken, altTypeList = self.analyzeDeclAlternateType(
            true, nextToken, accessMode );
      }
      self.pushbackToken( nextToken );
   }

   let mut bodyScope = self.pushScope( .Other ## );
   // generic の型をスコープに登録
   foreach altType in altTypeList {
      bodyScope.addAlternate(
         self.processInfo, accessMode, altType.$rawTxt, name.pos, altType );
   }
   
   
   
   self.checkNextToken( "(" );
   let mut argList:List<&Nodes.Node> = [];

   let mut nextToken = self.analyzeDeclArgList(
      accessMode, bodyScope, argList, Ast.isPubToExternal( accessMode ) );

   self.checkToken( nextToken, ")" );

   let asyncMode;
   nextToken, _, asyncMode = self.getMutableAsync( self.getToken(##) );
   
   let mut retTypeList:List<&Ast.TypeInfo> = [];
   //nextToken = self.getToken(##);
   let retNodeList;
   retTypeList, nextToken, retNodeList = self.analyzeRetTypeList(
      Ast.isPubToExternal( accessMode ), accessMode, nextToken,
      Ast.isPubToExternal( accessMode ) );

   self.checkToken( nextToken, ";" );

   self.popScope();

   let mut argTypeInfoList:List<&Ast.TypeInfo> = [];
   foreach argNode in argList {
      argTypeInfoList.insert( argNode.$expType );
   }

   let mut parentNsInfo = self.$curNsInfo;
   let formType = self.processInfo.createFuncAsync(
      false, false, bodyScope, .FormFunc,
      parentNsInfo.$typeInfo,
      parentNsInfo.$typeDataAccessor,
      false, false,
      true, accessMode, name.txt,
      self.getDefaultAsync( .FormFunc, self.getCurrentClass(), asyncMode ),
      altTypeList, argTypeInfoList, retTypeList, .IMut );

   let formSymbol, shadowing = self.$scope.addForm(
      self.processInfo, name.pos, formType, accessMode );
   self.errorShadowing( name.pos, shadowing );

   let declFuncInfo = new Nodes.DeclFuncInfo(
      .Form, nil, nil, false, name, formSymbol or shadowing, argList, false,
      accessMode, asyncMode, nil, retTypeList, retNodeList, false, false, 0 );
   
   return Nodes.DeclFormNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ formType ], declFuncInfo );
}

pro fn TransUnit.analyzeDeclToken(
   accessMode: Ast.AccessMode, mut staticFlag: bool,
   firstToken: &Parser.Token, mut token: &Parser.Token ) mut : Nodes.Node!
{
   return nil;
}

/**
宣言文の解析

@return Nodes.Node! 宣言文の Node
@return bool 解析成功した場合 true。
Nodes.Node! が nil の場合も、解析に成功した場合は true。
*/
fn TransUnit.analyzeDecl(
   mut accessMode: Ast.AccessMode, mut staticFlag: bool,
   firstToken: &Parser.Token, mut token: &Parser.Token ) mut : Nodes.Node!, bool
{
   if not staticFlag {
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken(##);
      }
   }
   let mut overrideFlag = false;
   if token.txt == "override" {
      overrideFlag = true;
      token = self.getToken(##);
   }

   let mut abstractFlag = false;
   if token.txt == "abstract" {
      abstractFlag = true;
      token = self.getToken(##);
   }
   let mut finalFlag = false;
   if token.txt == "final" {
      finalFlag = true;
      token = self.getToken(##);
   }

   if accessMode == .None and token.txt ~= "fn" {
      // fn 以外で None の場合は、 Local に設定。
      // fn は、 analyzeDeclFunc() 内で適宜変更。
      accessMode = .Local;
   }

   
   if token.txt == "let" {
      return self.analyzeDeclVar( .Let, accessMode, firstToken ), true;
   }
   elseif token.txt == "fn" {
      let nextToken = self.getToken(##);
      self.pushback();
      if nextToken.kind == .Symb or Ast.isPubToExternal( accessMode ) or
         staticFlag or overrideFlag or abstractFlag
      {
         // nextToken が .Symb の場合は、通常の関数定義。
         // anonymous 関数でも、 pub 等が指定されている場合は、
         // エラー処理用に analyzeDeclFunc() をコールする。
         return self.analyzeDeclFunc(
            .Func, false, abstractFlag, overrideFlag,
            accessMode, staticFlag, nil, firstToken, nil ), true;
      }
      // anonymous 関数の場合は、 関数定義ではなく関数オブジェクトを利用した式。
   }
   elseif token.txt == "class" {
      return self.analyzeDeclClass( finalFlag, abstractFlag, accessMode, firstToken, .Class );
   }
   elseif token.txt == "interface" {
      return self.analyzeDeclClass( false, true, accessMode, firstToken, .Interface );
   }
   elseif token.txt == "module" {
      return self.analyzeDeclClass( true, false, accessMode, firstToken, .Module );
   }
   // elseif token.txt == "__module" {
   //    return self.analyzeDeclClass( false, accessMode, firstToken, .LazyModule );
   // }
   elseif token.txt == "proto" {
      return self.analyzeDeclProto( accessMode, firstToken ), true;
   }
   elseif token.txt == "macro" {
      return self.analyzeDeclMacro( accessMode, firstToken ),  true;
   }
   elseif token.txt == "enum" {
      return self.analyzeDeclEnum( accessMode, firstToken ), true;
   }
   elseif token.txt == "alge" {
      return self.analyzeDeclAlge( accessMode, firstToken ), true;
   }
   elseif token.txt == "form" {
      return self.analyzeDeclForm( accessMode, firstToken ), true;
   }
   elseif token.txt == "alias" {
      return self.analyzeAlias( accessMode, firstToken ), true;
   }
   // elseif token.txt == "__test" {
   //    return self.analyzeTest( firstToken );
   // }

   return self.analyzeDeclToken( accessMode, staticFlag, firstToken, token ), true;

}


fn TransUnit.checkPublic( pos:&Parser.Position, typeInfo:&Ast.TypeInfo ) mut {
   let mut checkedTypeSet:Set<&Ast.TypeInfo> = (@);
   fn checkPub( workType:&Ast.TypeInfo ) __trans {
      if checkedTypeSet.has( workType ) {
         return;
      }
      checkedTypeSet.add( workType );
      if workType.$kind ~= .Array and workType.$kind ~= .List
         and workType.$kind ~= .Set
         and workType.$kind ~= .Map and not Ast.isPubToExternal( workType.$accessMode )
      {
         self.addErrMess( pos, "not public this type -- %s" ( workType.getTxt(##)) );
      }
      else {
         foreach itemType in workType.$itemTypeInfoList {
            checkPub( itemType );
         }
      }
   }
   checkPub( typeInfo );
}

fn TransUnit.analyzeDeclMember(
   classTypeInfo: &Ast.TypeInfo, accessMode: Ast.AccessMode,
   staticFlag: bool, firstToken: &Parser.Token ) mut: Nodes.DeclMemberNode
{
      let mut nextToken = self.getToken(##);
      let mut mutMode = Ast.MutMode.IMut;
      switch nextToken.txt {
         case "mut" {
            mutMode = .Mut;
            nextToken = self.getToken(##);
         }
         case "allmut" {
            mutMode = .AllMut;
            nextToken = self.getToken(##);
         }
      }
      let varName = self.checkSymbol( nextToken, .MustNot_ );
      let mut token = self.getToken(##);
      let refType = self.analyzeRefType(
         accessMode, false,
         Ast.isPubToExternal( classTypeInfo.$accessMode ), false, false);
      token = self.getToken(##);

      if classTypeInfo.isInheritFrom( self.processInfo, Ast.builtinTypeAbsImmut ## ) {
         if mutMode ~= .IMut {
            self.addErrMess(
               varName.pos,
               "__absimmut can't have mutable member. -- %s" (varName.txt));
         }
         if not Ast.TypeInfo.canBeAbsImmutMember( refType.$expType ) {
            self.addErrMess(
               refType.$pos,
               "__absimmut can't have member of mutable type. -- %s"
               (refType.$expType.getTxt(##)));
         }
         
      }
      
      if refType.$expType.$asyncMode == .Transient {
         self.addErrMess( refType.$pos,
                          "can't hold with the type of __trans. -- %s"
                          (varName.txt) );
      }

      // accessor
      let mut getterMode = Ast.AccessMode.None;
      let mut getterRetType = refType.$expType;
      let mut getterToken:&Types.Token! = nil;
      let mut getterMutable = Ast.MutMode.Mut;
      let mut setterMode = Ast.AccessMode.None;
      let mut setterToken:&Types.Token! = nil;
      if token.txt == "{" {

         fn analyzeAccessorMode():
         Ast.AccessMode, &Ast.TypeInfo, &Parser.Token, &Parser.Token
         {
            let mut retType = Ast.headTypeInfo;
            let mut mode = Ast.AccessMode.None;
            let mut accessorToken = self.getToken(##);
            let mut workToken = accessorToken;
            switch workToken.txt {
               case "pub", "pri", "pro", "local" {
                  mode = unwrap Ast.txt2AccessMode( workToken.txt );
                  workToken = self.getToken(##);
                  if workToken.txt == "&" {
                     getterMutable = .IMut;
                     workToken = self.getToken(##);
                  }
                  if workToken.txt == ":" {
                     let typeNode = self.analyzeRefType(
                        mode, false,
                        Ast.isPubToExternal( classTypeInfo.$accessMode ),
                        false, false ); 
                     retType = typeNode.$expType;
                     workToken = self.getToken(##);
                  }
               }
               case "non" {
                  workToken = self.getToken(##);
               }
               default {
                  self.addErrMess( workToken.pos,
                                   "access mode is invalid -- %s" (workToken.txt) );
               }
            }
            return mode, retType, accessorToken, workToken;
         }

         {
            let workRetType;
            getterMode, workRetType, getterToken, nextToken = analyzeAccessorMode();
            if workRetType ~= Ast.headTypeInfo {
               if not workRetType.canEvalWith(
                  self.processInfo, getterRetType, .SetOp,
                  classTypeInfo.createAlt2typeMap( false ) )
               {
                  self.addErrMess( firstToken.pos,
                                   "getter type mismatch -- %s <- %s"
                                   (workRetType.getTxt(##), getterRetType.getTxt(##)));
               }
               getterRetType = workRetType;
            }
         }
         if nextToken.txt == "," {
            let dummyRetType;
            setterMode, dummyRetType, setterToken, nextToken = analyzeAccessorMode();
            if setterMode ~= .None and mutMode == .IMut {
               // immutable なメンバに setter 宣言は出来ない
               self.addErrMess(
                  varName.pos,
                  "This member can't have setter, this member is immutable. -- %s"
                  (varName.txt) );
            }
            // pending
            Log._log2( .Debug, "%s" (dummyRetType) );
         }
         self.checkToken( nextToken, "}" );
         token = self.getToken(##);
      }

      self.checkToken( token, ";" );

      let mut typeInfo = refType.$expType;
      // if Ast.TypeInfo.isMut( typeInfo ) and mutMode == .IMut {
      //    typeInfo = self.createModifier( typeInfo, .IMut );
      // }
      if self.ctrl_info.legacyMutableControl {
         if Ast.TypeInfo.isMut( typeInfo ) and typeInfo.$mutMode ~= mutMode {
            typeInfo = self.createModifier( typeInfo, mutMode );
         }
         if Ast.TypeInfo.isMut( getterRetType ) and getterRetType.$mutMode ~= mutMode {
            getterRetType = self.createModifier( getterRetType, mutMode );
         }
      } else {
         if Ast.TypeInfo.isMut( getterRetType ) {
            if getterMutable == .AllMut {
               getterRetType = self.createModifier( getterRetType, .AllMut );
            } elseif getterMutable == .IMut {
               getterRetType = self.createModifier( getterRetType, .IMut );
            }
         }
      }

      if Ast.isPubToExternal( classTypeInfo.$accessMode ) {
         if Ast.isPubToExternal( accessMode ) or Ast.isPubToExternal( setterMode ) {
            self.checkPublic( refType.$pos, typeInfo );
         }
         if Ast.isPubToExternal( getterMode ) {
            self.checkPublic( refType.$pos, getterRetType );
         }
      }

      let symbolInfo, shadowing = self.$scope.addMember(
         self.processInfo, varName.txt, varName.pos,
         typeInfo, accessMode, staticFlag, mutMode );

      let workSym = unwrap (symbolInfo or shadowing);
      when! shadowing {
         self.errorShadowing( varName.pos, shadowing );
      }

      return Nodes.DeclMemberNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ],
         varName, refType, workSym, classTypeInfo, 
         staticFlag, accessMode, getterMutable ~= .IMut,
         getterMode, getterToken, getterRetType, setterMode, setterToken );
   }

fn TransUnit.analyzeDeclMethod(
   classTypeInfo: &Ast.TypeInfo, declFuncMode: DeclFuncMode,
   abstractFlag: bool, overrideFlag: bool, accessMode: Ast.AccessMode,
   staticFlag: bool, firstToken: &Parser.Token, name: &Parser.Token ) mut : Nodes.Node
{
   let mut node = self.analyzeDeclFunc(
      declFuncMode, false, abstractFlag,
      overrideFlag, accessMode, staticFlag, classTypeInfo, name, name );
   return node;
}


/**
デフォルトコンストラクタの追加処理

@param pos クラスの定義位置
@param classTypeInfo クラス情報
@param classScope クラスのスコープ
@param memberNodeList メンバーノードリスト
@param methodNameSet メソッド名の集合
*/
fn TransUnit.addDefaultConstructor(
   pos:&Parser.Position, classTypeInfo:&Ast.TypeInfo,
   typeDataAccessor:Ast.TypeDataAccessor,
   classScope:Ast.Scope, memberNodeList:&List<&Nodes.DeclMemberNode>,
   methodNameSet:Set<str>, oldFlag:bool ) mut
{
   if classScope.getTypeInfoChild( "__init" ) {
      self.addErrMess( pos, "already declare __init()." );
   }

   // デフォルトコンストラクタの引数の型リストを決定する
   let mut argTypeList:List<&Ast.TypeInfo> = [];

   if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
      // 継承している場合
      let superScope = unwrap classTypeInfo.$baseTypeInfo.$scope;
      let superTypeInfo = unwrap superScope.getTypeInfoChild( "__init" );
      foreach argType in superTypeInfo.$argTypeInfoList {
         if oldFlag {
            if not argType.$nilable {
               self.addErrMess( pos, "not found '__init' decl." );
            }
         }
         else {
            argTypeList.insert( argType );
         }
      }
   }

   foreach memberNode in memberNodeList {
      if not memberNode.$staticFlag {
         argTypeList.insert( memberNode.$expType );
      }
   }

   if Ast.isPubToExternal( classTypeInfo.$accessMode ) {
      // クラスが外部公開なら、
      // コンストラクタの型は全て外部公開可能でなければならない。
      foreach memberType in argTypeList {
         if not Ast.isPubToExternal( memberType.$accessMode ) {
            self.addErrMess(
               pos, "The type must be 'pub' becaue using in __init(). -- %s:%s"
               ( memberType.getTxt(##), memberType.$accessMode.$_txt ) );
         }
      }
   }

   // デフォルトコンストラクタの登録
   let mut ctorScope = self.pushScope( .Other ## );
   let initTypeInfo = self.processInfo.createFuncAsync(
      false, false, ctorScope, .Method, classTypeInfo, typeDataAccessor,
      true, false, false, .Pub, "__init", .Async, nil, argTypeList, [], .IMut );
   if oldFlag {
      // oldFlag の場合は スコープに "" のシンボルを追加する
      ctorScope.addVar( self.processInfo, .Pri, "", nil, Ast.headTypeInfo, .IMut, true);
   }
   self.popScope();
   classScope.addMethod( self.processInfo, pos, initTypeInfo, .Pub, false );
   methodNameSet.add( "__init" );

   // メンバーをセット済みにする
   foreach memberNode in memberNodeList {
      if not memberNode.$staticFlag {
         memberNode.$symbolInfo.updateValue( memberNode.$symbolInfo.$posForLatestMod );
      }
   }
}

/**
関数の本体ブロック処理

@param analyzingState 解析状態
@param firstToken エラー表示用トークン
@param classTypeInfo クラス情報。 メソッドでない場合は nil。
@param retTypeInfoList 関数の戻り値型リスト
@return Nodes.BlockNode 解析結果
*/
fn TransUnit.analyzeFuncBlock(
   analyzingState:AnalyzingState, firstToken: &Parser.Token,
   classTypeInfo:&Ast.TypeInfo!, funcTypeInfo:&Ast.TypeInfo, funcName:str,
   funcBodyScope:Ast.Scope, retTypeInfoList:&List<&Ast.TypeInfo> ) mut : Nodes.BlockNode
{
   if not funcTypeInfo.$staticFlag {
      when! classTypeInfo {
         if! let overrideType = classTypeInfo.$scope$.getTypeInfoField$(
            funcName, false, funcBodyScope, self.scopeAccess )
         {
            if not overrideType.$abstractFlag {
               funcBodyScope.add( self.processInfo, .Fun, false, false, "super", nil,
                                  overrideType, .Local, false, .IMut, true, false );
            }
         }
      }
   }


   let mut body;
   if self.isValidBlockWithoutTesting() {

      self.pushAnalyzingState( analyzingState );
      
      body = self.analyzeBlock( .Func, .Ignore, funcBodyScope, nil );

      self.popAnalyzingState();

      if #retTypeInfoList ~= 0 {
         let breakKind = body.getBreakKind( .Return );
         if retTypeInfoList[ 1 ] ~= Ast.builtinTypeNeverRet {
            switch breakKind {
               case .Return, .NeverRet {
               }
               default {
                  self.addErrMess( firstToken.pos,
                                   "This funcion doesn't have return." );
               }
            }
         }
         else {
            if breakKind ~= .NeverRet {
               self.addErrMess( firstToken.pos,
                                "This funcion must be never return. -- %s"
                                (breakKind.$_txt ));
            }
         }
      }
   } else {
      // テスト無効の場合、テストブロック内は解析せずにダミーを生成する
      body = self.skipAndCreateDummyBlock();
      // let blockToken = self.checkNextToken( "{" );
      // self.pushback();
      // let blockScope = self.pushScope( .Other ## );
      // let stmtList:List<&Nodes.Node> = [];
      // self.popScope();
      // body = Nodes.BlockNode.create(
      //    self.nodeManager, blockToken.pos, self.inTestBlock,
      //    self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      //    .Func, blockScope, stmtList );

      // self.skipBlock( false );
   }

   return body;
}

fn TransUnit.addAccessor(
   memberNode:&Nodes.DeclMemberNode, methodNameSet: Set<str>,
   classScope:Ast.Scope, classTypeInfo:&Ast.TypeInfo,
   typeDataAccessor:Ast.TypeDataAccessor ) mut
{
   let memberType = memberNode.$expType;
   let memberName = memberNode.$name;
   // getter
   let getterName = "get_" .. memberName.txt;
   let mut accessMode = memberNode.$getterMode;
   let typeKind:Ast.TypeInfoKind;
   if memberNode.$staticFlag {
      typeKind = .Func;
   }
   else {
      typeKind = .Method;
   }
   let asyncMode:Ast.Async;
   if memberType.$mutMode == .AllMut {
      asyncMode = .Noasync;
   } else {
      asyncMode = .Async;
   }
   if accessMode ~= .None {
      if classScope.getTypeInfoChild( getterName ) {
         self.addErrMess( memberName.$pos,
                          "exist -- %s.%s" (classTypeInfo.$rawTxt, getterName) );
      } else {
         let mutable = memberNode.$getterMutable;
         let mut getterMemberType = memberNode.$getterRetType;
         if Ast.TypeInfo.isMut( getterMemberType ) and not mutable {
            getterMemberType = self.createModifier( getterMemberType, .IMut );
         }
         let retTypeInfo = self.processInfo.createFuncAsync(
            false, false, self.pushScope( .Other ## ),
            typeKind, classTypeInfo, typeDataAccessor,
            false, false, memberNode.$staticFlag, accessMode,
            getterName, asyncMode,
            nil, [], [ getterMemberType ], .IMut  );
         self.popScope();

         classScope.addMethod(
            self.processInfo, 
            memberName.pos, retTypeInfo, accessMode, memberNode.$staticFlag );
         methodNameSet.add( getterName );
      }
   }
   // setter
   let setterName = "set_" .. memberName.txt;
   accessMode = memberNode.$setterMode;
   if memberNode.$setterMode ~= .None {
      if classScope.getTypeInfoChild( setterName ) {
         self.addErrMess( memberName.$pos,
                          "exist -- %s.%s" (classTypeInfo.$rawTxt, setterName) );
      } else {
         let mutMode:Ast.MutMode;
         //if memberType.$mutMode == .Mut {
         if memberNode.$symbolInfo.$mutMode ~= .AllMut {
            mutMode = .Mut;
         }
         else {
            mutMode = .IMut;
         }
         classScope.addMethod(
            self.processInfo, memberName.pos,
            self.processInfo.createFuncAsync(
               false, false, self.pushScope( .Other ## ),
               typeKind, classTypeInfo, typeDataAccessor,
               false, false, memberNode.$staticFlag, accessMode,
               setterName,
               asyncMode,
               nil, [ memberType ], nil, mutMode ),
            accessMode, memberNode.$staticFlag );
         self.popScope();
         methodNameSet.add( setterName );
      }
   }
}


/**
クラスの本体部の解析。

@param classAccessMode クラスのアクセス制御
@param firstToken クラス定義の先頭トークン
@param mode クラス宣言モード
@param gluePrefix glue の prefix
@param classTypeInfo 宣言するクラスのタイプ
@param name クラス名のトークン
@param moduleName モジュール名
@param nextToken '{' の次のトークン。
@return Nodes.DeclClassNode クラス宣言のノード
@return &Parser.Token 解析終了後のトークン
@return Set<str> 定義されているメソッド名の Set
*/
fn TransUnit.analyzeClassBody(
   hasProto:bool, classAccessMode: Ast.AccessMode, firstToken: &Parser.Token,
   mode:DeclClassMode, gluePrefix:str!, classTypeInfo: &Ast.TypeInfo,
   typeDataAccessor: Ast.TypeDataAccessor,
   name:&Parser.Token, moduleLang:Types.Lang!,
   moduleName: &Parser.Token!, lazyLoad:Nodes.LazyLoad,
   mut nextToken:&Parser.Token, inheritInfo:&Nodes.ClassInheritInfo ) mut :
   Nodes.DeclClassNode, &Parser.Token, Set<str>
{
   let mut memberName2Node: Map<str,&Nodes.DeclMemberNode> = {};
   let mut allStmtList: List<&Nodes.Node> = [];
   let mut declStmtList: List<&Nodes.Node> = [];
   let mut fieldList:List<&Nodes.Node> = [];
   let mut memberList:List<&Nodes.DeclMemberNode> = [];
   let mut methodNameSet: Set<str> = (@);
   //let mut initStmtList:List<&Nodes.Node> = [];
   let mut initBlockInfo = new Nodes.ClassInitBlockInfo(##);
   let mut advertiseList:Nodes.AdvertiseInfo[] = [];
   let mut trustList:List<&Ast.TypeInfo> = [];
   let mut uninitMemberList:List<&Ast.SymbolInfo> = [];
   let mut node = Nodes.DeclClassNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ classTypeInfo ],
      classAccessMode, name, inheritInfo, hasProto, gluePrefix, moduleName,
      moduleLang, lazyLoad, false, allStmtList,
      declStmtList, fieldList, memberList, self.$scope, initBlockInfo,
      advertiseList, trustList, uninitMemberList, (@) );
   self.typeInfo2ClassNode[ classTypeInfo ] = node;
   let mut alreadyCtorFlag = false;
   let mut hasInitBlock = false;
   let mut hasStaticMember = false;
   let mut classScope = self.$scope;

   fn processLet( token:&Parser.Token, staticFlag:bool,
                  accessMode:Ast.AccessMode, alreadyFlag:bool ) __trans
   {
      if staticFlag {
         hasStaticMember = true;
      }
      if mode == .Interface {
         self.addErrMess( token.pos, "interface can not have member" );
      }
      if not staticFlag and alreadyFlag {
         self.addErrMess(
            token.pos, "member can't declare after '__init' method." );
      }
      elseif staticFlag and hasInitBlock {
         self.addErrMess(
            token.pos, "static member can't declare after '__init' block." );
      }
      let memberNode = self.analyzeDeclMember(
         classTypeInfo, accessMode, staticFlag, token );
      allStmtList.insert( memberNode );
      fieldList.insert( memberNode );
      memberList.insert( memberNode );
      memberName2Node[ memberNode.$name.txt ] = memberNode;
      self.addAccessor(
         memberNode, methodNameSet, classScope, classTypeInfo, typeDataAccessor );
   }

   /**
memberName2Node のメンバに値がセットされたかどうかを調べる。

@param staticFlag true の場合、 static メンバを調べる。
@param pos セットされていなかった場合のエラー表示位置。
nil の場合、メンバの宣言位置。
   */
   fn checkInitializeMember( staticFlag:bool, pos:&Parser.Position! ) __trans {
      if self.isValidBlockWithoutTesting() {
         // テストブロック外が、テスト有効な場合処理する。
         foreach memberNode, memberName in memberName2Node {
            if memberNode.$staticFlag == staticFlag {
               let symbolInfo = unwrap self.$scope.getSymbolInfoChild( memberName );
               let typeInfo = symbolInfo.$typeInfo;
               if not symbolInfo.$hasValueFlag {
                  let msg;
                  if staticFlag {
                     msg = "Set member -- %s" ( memberName );
                  }
                  else {
                     msg = "Set member -- %s.%s" ( name.txt, memberName );
                  }
                  if not typeInfo.$nilable {
                     self.addErrMess( unwrap pos default memberNode.$pos, msg );
                  }
                  else {
                     uninitMemberList.insert( symbolInfo );
                     // nilable は、ここで初期化済みとする。
                     self.addWarnMess( unwrap pos default memberNode.$pos, msg );
                  }
               }
            }
         }
      }
   }

   fn processFn( token:&Parser.Token, staticFlag:bool, accessMode:Ast.AccessMode,
                 abstractFlag:bool, overrideFlag:bool ) __trans
   {
      let nameToken = self.getSymbolToken( .MustNot_ );
      let mut declFuncMode = DeclFuncMode.Class;
      if mode == .Module or mode == .LazyModule {
         if gluePrefix {
            declFuncMode = .Glue;
         }
         else {
            declFuncMode = .Module;
         }
      }

      if nameToken.txt == "__init" {
         foreach symbolInfo in self.$scope.$symbol2SymbolInfoMap {
            if not symbolInfo.$staticFlag {
               // 一旦全てのメンバを値なし状態にセットする
               symbolInfo.clearValue();
            }
         }
      }
      
      let methodNode = self.analyzeDeclMethod(
         classTypeInfo, declFuncMode, abstractFlag, overrideFlag,
         accessMode, staticFlag, token, nameToken );
      allStmtList.insert( methodNode );
      fieldList.insert( methodNode );
      methodNameSet.add( nameToken.txt );
      if nameToken.txt == "__init" {
         alreadyCtorFlag = true;

         checkInitializeMember( false, methodNode.$pos );
      }
   }

   fn processInitBlock( token:&Parser.Token ) __trans {

      if classTypeInfo.$scope$.$parent ~= self.moduleScope {
         // top level クラスでないと、
         // static なメンバのライフタイム制御が難しいので現状はエラーとする。
         self.addErrMess(
            token.pos, "The '__init' block only support at the top level classes." );
      }
      
      if mode ~= .Class {
         self.error( "%s can not have __init block." (mode) ); // 要対応
      }
      hasInitBlock = true;
      foreach symbolInfo in self.$scope.$symbol2SymbolInfoMap {
         if symbolInfo.$staticFlag {
            // 一旦全てのメンバを値なし状態にセットする
            symbolInfo.clearValue();
         }
      }

      let mut parentScope = self.$scope;
      let mut initBlockScope = self.pushScope( .Other ## );
      self.prepareTentativeSymbol( initBlockScope, false, nil );

      let ininame = "___init";
      let mut funcTypeInfo = self.processInfo.createFuncAsync(
         false, false, initBlockScope, .Func, classTypeInfo, typeDataAccessor, 
         false, false, true, .Pri, ininame, .Noasync, nil, nil, nil, .IMut );
      let funcSym, shadowing = parentScope.addFunc(
         self.processInfo, token.$pos, funcTypeInfo, .Pri, true, true );

      let mut nsInfo = self.newNSInfo( funcTypeInfo, token.pos );
      
      
      let block = self.analyzeFuncBlock(
         .InitBlock, token, classTypeInfo, funcTypeInfo, ininame, initBlockScope,
         funcTypeInfo.$retTypeInfoList );

      let mut info = new Nodes.DeclFuncInfo(
         .InitBlock, classTypeInfo, node, true, token, unwrap (funcSym or shadowing),
         [], true, .Pri, nil, block, [], [], false, false, nsInfo.$stmtNum );
      let initBlockNode = Nodes.DeclMethodNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ funcTypeInfo ], info );
      initBlockInfo.set_func( initBlockNode );
      allStmtList.insert( initBlockNode );

      self.popScope();
      self.finishTentativeSymbol( false );
   }

   fn processAdvertise() __trans {
      let memberToken = self.getSymbolToken( .MustNot_ );
      nextToken = self.getToken(##);
      let mut prefix = "";
      if nextToken.txt ~= ";" and nextToken.txt ~= "{" {
         prefix = nextToken.txt;
         nextToken = self.getToken(##);
      }
      self.checkToken( nextToken, ";" );
      let! memberNode = memberName2Node[ memberToken.txt ] {
         self.error( "not found member -- %s" (memberToken.txt) ); // 要対応
      };
      let mut advInfo = new Nodes.AdvertiseInfo( memberNode, prefix, memberToken.pos );
      advertiseList.insert( advInfo );
      allStmtList.insert(
         Nodes.DeclAdvertiseNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], advInfo ) );
      
      self.advertisedTypeSet.add(
         memberNode.$expType.$srcTypeInfo.$genSrcTypeInfo );
   }

   fn processEnum( token:&Parser.Token, accessMode:Ast.AccessMode ) __trans {
      if accessMode ~= .Pri and
          ( classAccessMode == .Pri or classAccessMode == .Local )
      {
         self.addErrMess( token.pos,
                          "unmatch access mode, class('%s') and enum('%s')"
                          (classAccessMode.$_txt, accessMode.$_txt ) );
      }
      let enumNode = self.analyzeDeclEnum( accessMode, token );
      allStmtList.insert( enumNode );
      declStmtList.insert( enumNode );
      
   }

   fn processLuneControl() __trans {
      nextToken = self.getToken(##);

      let pragma;
      switch nextToken.txt {
         case "default__init" {
            pragma = LuneControl.Pragma.default__init;

            alreadyCtorFlag = true;
            
            self.addDefaultConstructor(
               nextToken.pos, classTypeInfo, typeDataAccessor,
               self.$scope, memberList, methodNameSet, false );
         }
         case "default__init_old" {
            pragma = LuneControl.Pragma.default__init_old;

            alreadyCtorFlag = true;
            self.addDefaultConstructor(
               nextToken.pos, classTypeInfo, typeDataAccessor,
               self.$scope, memberList, methodNameSet, true );
            node.setHasOldCtor();
         }
         case "default_async_this_class" {
            pragma = LuneControl.Pragma.default_async_this_class;
            self.class2defaultAsyncMode[ self.getCurrentNamespaceTypeInfo() ] = .AsyncAll;
         }
         case "default_noasync_this_class" {
            pragma = LuneControl.Pragma.default_noasync_this_class;
            self.class2defaultAsyncMode[ self.getCurrentNamespaceTypeInfo() ] = .NoAsync;
         }
         default {
            self.error( "unknown option -- %s" (nextToken.txt) ); // 要対応
         }
      }
      self.checkNextToken( ";" );

      let ctrlNode = Nodes.LuneControlNode.create(
         self.nodeManager, firstToken.pos, self.inTestBlock,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], pragma );
      self.helperInfo.pragmaSet.add( pragma );
      allStmtList.insert( ctrlNode );
   }

   fn processClassFields(inMacro:bool) {
      while true {
         let mut token = self.getToken( inMacro );
         if token.kind == .Eof or token.txt == "}" {
            break;
         }
         let! mut accessMode = Ast.txt2AccessMode( token.txt ) {
            accessMode = .Pri;
         }
         then {
            token = self.getToken(##);
         };
         if mode == .Interface and accessMode ~= .Pub {
            self.addErrMess( token.pos, "interface's fields must be 'pub'." );
         }

         let mut staticFlag = false;
         if token.txt == "static" {
            staticFlag = true;
            token = self.getToken(##);
         }
         let mut overrideFlag = false;
         if token.txt == "override" {
            overrideFlag = true;
            token = self.getToken(##);
         }
         let mut abstractFlag = false;
         if token.txt == "abstract" {
            abstractFlag = true;
            token = self.getToken(##);
         }
         elseif mode == .Interface {
            // 現状 interface にデフォルト処理を書けない。
            abstractFlag = true;
         }


         if token.txt == "let" {
            processLet( token, staticFlag, accessMode, alreadyCtorFlag );
         }
         elseif token.txt == "fn" {
            processFn( token, staticFlag, accessMode, abstractFlag, overrideFlag );
         }
         elseif token.txt == "__init" {
            processInitBlock( token );
         }
         elseif token.txt == "advertise" {
            processAdvertise();
         }
         elseif token.txt == ";" {
         }
         elseif token.txt == "enum" {
            processEnum( token, accessMode );
         }
         elseif token.txt == "_lune_control" {
            processLuneControl();
         }
         else {
            if! let symbolInfo = self.$scope.getSymbolInfo(
               token.txt, self.$scope, false, self.scopeAccess )
            {
               if symbolInfo.$kind == .Mac {

                  self.checkNextToken( "(" );

                  let mut alt2typeMap, argList = self.prepareExpCall(
                     token.pos, symbolInfo.$typeInfo, [], Ast.headTypeInfo );


                  self.evalMacroOp(
                     token, symbolInfo.$typeInfo, argList,
                     fn () {
                        processClassFields( true );
                     });

                  self.checkNextToken( ";" );
               }
               else {
                  self.error( "illegal field" ); // 要対応
               }
            }
            else {
               self.error( "illegal field" ); // 要対応
            }
         }
      }
   }

   processClassFields( false );

   switch mode {
      case .Module, .LazyModule {
      }
      default {
         if hasStaticMember and not hasInitBlock {
            self.addErrMess(
               node.$pos,
               "This class (%s) need __init block for initialize static members." ( name.txt ) );
         }

         checkInitializeMember( true, nil );
      }
   }

   return node, nextToken, methodNameSet;
}

fn TransUnit.analyzeDeclClass(
   finalFlag:bool, 
   classAbstructFlag: bool,  mut classAccessMode: Ast.AccessMode,
   firstToken: &Parser.Token, mut mode:DeclClassMode ) mut : Nodes.DeclClassNode!, bool
{
   if mode == .Module {
      if self.getToken(##).txt == "." {
         switch self.getToken(##).txt {
            case "l" {
               mode = .LazyModule;
            }
            case "d" {
               mode = .Module;
            }
         }
      } else {
         self.pushback();
         if self.ctrl_info.defaultLazy {
            mode = .LazyModule;
         }
      }
   }
   if mode == .LazyModule {
      self.helperInfo.useLazyRequire = true;
   }

   
   switch mode {
      case .Module, .LazyModule {
      }
      default {
         switch self.getCurrentNamespaceTypeInfo().$kind {
            case .IF, .Class, .Module {
            }
            case .Func, .Method {
               switch classAccessMode {
                  case .Pub, .Global {
                     self.addErrMess( firstToken.pos, "Class can't declare on here." );
                  }
               }
            }
            default {
               self.addErrMess( firstToken.pos, "Class can't declare on here." );
            }
         }
      }
   }

   let name = self.getSymbolToken( .MustNot_ );

   // generic の型宣言解析
   let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
   {
      let mut nextToken = self.getToken(##);
      if nextToken.txt == "<" {
         nextToken, altTypeList = self.analyzeDeclAlternateType(
            true, nextToken, classAccessMode );
      }
      self.pushbackToken( nextToken );

      // if #altTypeList > 0 and mode ~= .Class {
      //    // インタフェースの generics を当面禁止する。
      //    // インタフェースの generics をサポートするには、
      //    // そのインタフェースを implements しているクラスのどの型情報が
      //    // 型パラメータに紐付くのかを処理する必要がある。
      //    self.addErrMess( name.pos, "Only class can use the generics. -- %s " (name.txt) );
      // }
   }

   if classAccessMode == .Local {
      classAccessMode = .Pri;
   }

   let mut moduleName: &Parser.Token! = nil;
   let mut gluePrefix:str! = nil;
   let mut moduleLang:Types.Lang! = nil;
   if mode == .Module or mode == .LazyModule {
      self.checkNextToken( "require" );
      moduleName = self.getToken(##);
      let mut nextToken = self.getToken(##);
      if nextToken.txt == "of" {
         let langToken = self.getToken(##);
         if langToken.kind ~= .Str {
            self.error( "it's not a string -- %s" ( langToken.txt ) ); // 要対応
         }
         let langIdToken = langToken.getExcludedDelimitTxt();
         if langIdToken ~= "" {
            foreach langId in Types.Lang.$_allList {
               if! Types.Lang._from( langId ) {
                  let ldName = _exp.$_txt.gsub( ".*%.", "");
                  if ldName == langIdToken {
                     moduleLang = _exp;
                     break;
                  }
               }
            }
            if moduleLang == nil {
               self.errorAt(
                  langToken.pos, "invalid lang -- %s" (langToken.txt) );
            }
         } else {
            moduleLang = .Same;
         }
         
         nextToken = self.getToken(##);
      }
      if nextToken.txt == "glue" {
         gluePrefix = self.getToken(##).getExcludedDelimitTxt();
      }
      else {
         self.pushback();
      }
   }

   let existSymbolInfo = self.$scope.getSymbolTypeInfo(
      name.txt, self.$scope, self.$scope, self.scopeAccess );

   let mut nextToken, mut nsInfo, inheritInfo = self.analyzePushClass(
      mode, finalFlag, classAbstructFlag, firstToken, name, true, moduleName,
      moduleLang or Types.Lang.Same, classAccessMode, altTypeList );
   let classTypeInfo = nsInfo.$typeInfo;
   let mut typeDataAccessor = nsInfo.$typeDataAccessor;

   let hasProto;
   if nsInfo.$nobody {
      nsInfo.set_nobody( false );
      hasProto = true;
   } else {
      hasProto = false;
      if existSymbolInfo {
         self.addErrMess( name.pos, "already declare symbol -- %s" (name.txt) );
      }
   }


   let mut classScope = self.$scope;


   // extend Hoge<T=int> の T の AlternateTypeInfo を登録する
   if! let baseNode = inheritInfo.$base {
      foreach altType in baseNode.$itemIndex2alt {
         classScope.addAlternate(
            self.processInfo, classAccessMode, altType.$rawTxt, firstToken.pos, altType );
      }
   }
   foreach ifTypeNode in inheritInfo.$impliments {
      foreach altType in ifTypeNode.$itemIndex2alt {
         classScope.addAlternate(
            self.processInfo, classAccessMode, altType.$rawTxt, firstToken.pos, altType );
      }
   }

   

   self.checkToken( nextToken, "{" );


   let mapType = self.processInfo.createMap(
      .Pub, classTypeInfo, Ast.builtinTypeString,
      self.createModifier( Ast.builtinTypeStem, .IMut ), .IMut );
   if classTypeInfo.isInheritFrom(
      self.processInfo, Ast.builtinTypeMapping, nil ) {
      self.helperInfo.hasMappingClassDef = true;

      if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo and
         not classTypeInfo.$baseTypeInfo.isInheritFrom(
            self.processInfo, Ast.builtinTypeMapping, nil ) {
         self.addErrMess(
            firstToken.pos,
            "must extend Mapping at %s" (classTypeInfo.$baseTypeInfo.getTxt(##) ) );
      }
      // _toMap の追加
      let toMapFuncTypeInfo = self.processInfo.createFuncAsync(
         false, false, nil, .Method, classTypeInfo, typeDataAccessor,
         true, false, false, .Pub, "_toMap", .Async, nil, [], [ mapType ], .IMut );
      classScope.addMethod(
         self.processInfo, nil, toMapFuncTypeInfo, .Pub, false );
   }


   let mut lazyLoad;
   _switch mode {
      case .LazyModule {
         lazyLoad = Nodes.LazyLoad.On;
      }
      case .Module, .Class, .Interface {
         lazyLoad = Nodes.LazyLoad.Off;
      }
   }

   let mut node, _, mut methodNameSet = self.analyzeClassBody(
      hasProto, classAccessMode, firstToken, mode, gluePrefix,
      classTypeInfo, typeDataAccessor,
      name, moduleLang, moduleName, lazyLoad, nextToken, inheritInfo );
   //nextToken = workNextToken;


   // デフォルトコンストタクタ設定
   let mut ctorAccessMode = Ast.AccessMode.Pub;
   if! let ctorTypeInfo = classScope.getTypeInfoChild( "__init" ) {
      ctorAccessMode = ctorTypeInfo.$accessMode;
   }
   else {
      self.addDefaultConstructor(
         firstToken.pos, classTypeInfo, typeDataAccessor,
         classScope, node.$memberList, methodNameSet, false );
   }


   // advertise の処理
   foreach advertiseInfo in node.$advertiseList {
      let mut memberType = advertiseInfo.$member.$expType;
      switch memberType.$kind {
         case .Class, .IF {
            foreach mtdName in Ast.getAllMethodName( memberType, .Object ).$list {
               let scope = unwrap memberType.$scope;
               let child = unwrap scope.getTypeInfoField( mtdName, true, scope, .Normal );
               if child.$accessMode ~= .Pri {
                  let childName = advertiseInfo.$prefix .. child.getTxt(##);
                  if not methodNameSet.has( childName ) {
                     let impMtdType = self.processInfo.createAdvertiseMethodFrom(
                        classTypeInfo, typeDataAccessor, child );
                     classScope.addMethod(
                        self.processInfo, advertiseInfo.$pos, impMtdType,
                        child.$accessMode, child.$staticFlag );
                  }
               }
            }
         }
         default {
            self.error( "advertise member type is illegal -- %s" // 要対応
                        (advertiseInfo.$member.$name) );
         }
      }
   }


   if classTypeInfo.isInheritFrom(
      self.processInfo, Ast.builtinTypeMapping, nil )
   {
      // Mapping の制限チェック
      let mut checkedTypeMap:Map<&Ast.TypeInfo,bool> = {};
      foreach memberNode in node.$memberList {
         let memberType = memberNode.$expType;
         let ret, workMess = Ast.NormalTypeInfo.isAvailableMapping(
            self.processInfo, memberType, checkedTypeMap );
         if not ret {
            let mess;
            when! workMess {
               mess = ": %s" (workMess);
            } else {
               mess = "";
            }
            self.addErrMess(
               memberNode.$pos,
               "member type is not Mapping -- %s%s" ( memberType.getTxt(##), mess ) );
         } elseif memberType.$kind == .IF {
            self.addErrMess(
               memberNode.$pos,
               "Mapping class has not the interface type member. -- %s"
               (memberNode.$name.txt) );
         } elseif memberType.$abstractFlag {
            self.addErrMess(
               memberNode.$pos,
               "Mapping class has not the abstract class member. -- %s"
               (memberNode.$name.txt) );
         }
      }

      // _fromMap の追加
      let fromMapFuncTypeInfo = self.processInfo.createFuncAsync(
         false, false, nil, .Func, classTypeInfo, typeDataAccessor,
         true, false, true, .Pub, "_fromMap", .Async,
         nil, [ mapType.$nilableTypeInfo ],
         [ classTypeInfo.$nilableTypeInfo, Ast.builtinTypeString.$nilableTypeInfo ],
         .IMut );  
      classScope.addMethod(
         self.processInfo, nil, fromMapFuncTypeInfo, ctorAccessMode, true );

      // _fromStem の追加
      let fromStemFuncTypeInfo = self.processInfo.createFuncAsync(
         false, false, nil, .Func, classTypeInfo, typeDataAccessor,
         true, false, true, .Pub, "_fromStem", .Async,
         nil, [ Ast.builtinTypeStem_ ],
         [ classTypeInfo.$nilableTypeInfo, Ast.builtinTypeString.$nilableTypeInfo ],
         .IMut );
      classScope.addMethod(
         self.processInfo, nil, fromStemFuncTypeInfo, ctorAccessMode, true );
   }

   // if classTypeInfo.isInheritFrom(
   //    self.processInfo, Ast.builtinTypeAsyncItem, nil )
   // {
   //    // if not classTypeInfo.isInheritFrom(
   //    //    self.processInfo, Ast.builtinTypeMapping, nil )
   //    // {
   //    //    self.addErrMess(
   //    //       firstToken.pos, "__AsyncItem implemented class must inherit Mapping." );
   //    // }

   //    //
   //    let pipeType = self.createGeneric(
   //       firstToken.pos, self.builtinFunc.__pipe_, [classTypeInfo] );
   //    let createPipeFuncTypeInfo = self.processInfo.createFuncAsync(
   //       false, false, nil, .Func, classTypeInfo, typeDataAccessor,
   //       true, false, true, .Pub, "_createPipe", .Async, 
   //       nil, [ Ast.builtinTypeInt ], [ pipeType.$nilableTypeInfo ], .IMut );
   //    classScope.addMethod(
   //       self.processInfo, nil, createPipeFuncTypeInfo, .Pub, true );
   // }

   self.popClass();

   return node;
}



pri fn TransUnit.addMethod(
   classTypeInfo: &Ast.TypeInfo, methodNode: Nodes.Node, name: str ) mut
{
   let mut classNodeInfo = unwrap self.typeInfo2ClassNode[ classTypeInfo ];

   classNodeInfo.$outerMethodSet.add( name );
   classNodeInfo.$fieldList.insert( methodNode );
}

fn TransUnit.processAddFunc(
   isFunc:bool, mut parentScope:Ast.Scope,
   name:&Parser.Token, typeInfoMut:Ast.TypeInfo,
   alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo> ) mut
: &Ast.SymbolInfo, TransUnitIF.NSInfo
{
   let accessMode = typeInfoMut.$accessMode;
   let mut typeDataAccessor:Ast.TypeDataAccessor = typeInfoMut;
   let mut typeInfo:&Ast.TypeInfo = typeInfoMut;
   if accessMode == .Global {
      //parentScope = Ast.rootScope;
      parentScope = self.globalScope;
   }

   let hasPrototype;
   let mut nsInfo;
   if! let prottype = parentScope.getTypeInfoChild( typeInfo.$rawTxt ) {
      let argTypeList = typeInfo.$argTypeInfoList;
      let retTypeInfoList = typeInfo.$retTypeInfoList;
      let mut matched = true;
      {
         let matchFlag, err = Ast.TypeInfo.checkMatchType(
            self.processInfo,
            prottype.$argTypeInfoList, argTypeList, false, nil, alt2typeMap );
         if matchFlag ~= .Match {
            self.addErrMess( name.pos, "mismatch functype param: " .. err );
            matched = false;
         }
      }
      {
         let matchFlag, err = Ast.TypeInfo.checkMatchType(
            self.processInfo,
            prottype.$retTypeInfoList, retTypeInfoList, false, nil, alt2typeMap );
         if matchFlag ~= .Match {
            self.addErrMess( name.pos, "mismatch functype ret: " .. err );
            matched = false;
         }
      }
      {
         let matchFlag, err = typeInfo.canEvalWith(
            self.processInfo, prottype, .SetOp, alt2typeMap );
         if not matchFlag {
            if err {
               self.addErrMess( name.pos, "mismatch functype -- %s" (err ) );
            } else {
               self.addErrMess(
                  name.pos, "mismatch functype -- %s / %s"
                  ( typeInfo.$display_stirng, prottype.$display_stirng ) );
            }
            matched = false;
         }
      }
      {
         if prottype.$asyncMode ~= typeInfo.$asyncMode {
            self.addErrMess(
               name.pos,
               "mismatch async -- %s / %s"
               (prottype.$asyncMode.$_txt, typeInfo.$asyncMode.$_txt) );
            matched = false;
         }
      }
      {
         if prottype.$accessMode ~= typeInfo.$accessMode {
            self.addErrMess(
               name.pos,
               "mismatch accessMode -- %s / %s"
               (prottype.$accessMode.$_txt, typeInfo.$accessMode.$_txt) );
            matched = false;
         }
      }
      
      if! let mut workNsInfo = self.nsInfoMap[ prottype ] {
         nsInfo = workNsInfo;
         if nsInfo.$nobody {
            hasPrototype = true;
            nsInfo.set_nobody( false );
         } else {
            hasPrototype = false;
         }
      } else {
         hasPrototype = false;
         nsInfo = self.newNSInfoWithTypeData( typeInfo, typeDataAccessor, name.pos );
      }
      if matched {
         (unwrap nsInfo.$typeInfo@@@Ast.NormalTypeInfo).switchScopeTo( unwrap typeInfo.$scope );
         typeInfo = nsInfo.$typeInfo;
         typeDataAccessor = nsInfo.$typeDataAccessor;
      }
      if not hasPrototype {
         if not prottype.$autoFlag {
            self.addErrMess( name.pos, "multiple define -- %s" (name.txt) );
         }
      }
   }
   else {
      hasPrototype = false;
      nsInfo = self.newNSInfoWithTypeData( typeInfo, typeDataAccessor, name.pos );
   }

   if typeInfo.$kind == .Method and typeInfo.$accessMode ~= .Pri {
      let classType = typeInfo.$parentInfo;
      if self.advertisedTypeSet.has( classType ) and not hasPrototype {
         self.addErrMess(
            name.pos,
            "This class(%s) is used by advertise. You must declare the prototype of this method."
            (classType.getTxt( ## )) );
      }
   }
   

   let staticFlag = typeInfo.$staticFlag;
   let mutable = Ast.TypeInfo.isMut( typeInfo );

   let funcSym, shadowing;
   if isFunc {
      funcSym, shadowing = parentScope.addFunc(
         self.processInfo, name.pos, typeInfo, accessMode, staticFlag, mutable );
      self.errorShadowing( name.pos, shadowing );
   } else {
      funcSym, shadowing = parentScope.addMethod(
         self.processInfo, name.pos, typeInfo, accessMode, staticFlag );
   }

   self.set_curNsInfo( nsInfo );
   return unwrap (funcSym or shadowing), nsInfo;
}

local fn TransUnit.addFuncBlockInfoList( funcBlockInfo:FuncBlockInfo ) mut {
   Util.err( "not implemented" ); // バグ
}


let CantOverrideMethods = (@ "__init", "__free" );

/**
関数定義の解析。

@parm asyncLocked __asyncLock で指定された関数であることを示す。
*/
fn TransUnit.analyzeDeclFunc(
   declFuncMode: DeclFuncMode, asyncLocked: bool,
   abstractFlag: bool, overrideFlag: bool, mut accessMode: Ast.AccessMode,
   mut staticFlag: bool, mut classTypeInfo: &Ast.TypeInfo!,
   firstToken: &Parser.Token, mut name: &Parser.Token! ) mut : Nodes.Node
{
   let mut token = self.getToken(##);
   if! name {
      if _exp.txt ~= "__main" {
         name = self.checkSymbol( _exp, .MustNot_ );
      }
      if declFuncMode == .Func and _exp.txt == "main" {
         self.addWarnMess( _exp.pos, "LuneScript's main function is __main." );
      }
   }
   else {
      if token.txt ~= "(" {
         if token.txt ~= "__main" {
            name = self.checkSymbol( token, .MustNot_ );
         } else {
            name = token;
         }
         token = self.getToken(##);
      }
   }
   if not name and ( Ast.isPubToExternal( accessMode ) or
                     abstractFlag or overrideFlag or staticFlag )
   {
      // anonymous 関数で pub 等が指定されているのはエラー
      self.addErrMess( firstToken.pos, "The anonymous function must be local." );
   }

   let outsizeOfClass = classTypeInfo == nil;
   
   let mut needPopFlag = false;
   if token.txt == "." {
      needPopFlag = true;

      when! name {
         let className = name.txt;

         classTypeInfo = self.$scope.getTypeInfoChild( className );

         when! classTypeInfo {
            // self.pushClass(
            //    name.pos, classTypeInfo.$kind == .Class,
            //    classTypeInfo.$abstractFlag, nil, nil, nil, false, className,
            //    classTypeInfo.$accessMode ## );
            self.pushClassScope( name.pos, classTypeInfo,
                                 unwrap self.namespace2Scope[ classTypeInfo ] );       
         }
         else {
            self.error( "not found class -- %s" (className) ); // 要対応
         }
      }
      else {
         self.error( "can't use '.' for any function name" ); // 要対応
      }

      name = self.getSymbolToken( .MustNot_ );
      token = self.getToken(##);

      if accessMode == .None {
         accessMode = .Pri;
      }
   } else {
      // ここまで来て .None のままなら .Local に設定。
      // メソッド宣言の場合は、この直前の処理で .Pri に設定される。
      if accessMode == .None {
         accessMode = .Local;
      }
   }


   let mut kind = Nodes.NodeKind.$DeclConstr;
   let mut typeKind = Ast.TypeInfoKind.Func;
   when! classTypeInfo {
      if not staticFlag {
         typeKind = .Method;
      }
      switch (unwrap name).txt {
         case "__init" {
            kind = Nodes.NodeKind.$DeclConstr;
            foreach symbolInfo in self.$scope.$symbol2SymbolInfoMap {
               if not symbolInfo.$staticFlag {
                  // 一旦全てのメンバを値なし状態にセットする
                  symbolInfo.clearValue();
               }
            }
         }
         case "__free" {
            kind = Nodes.NodeKind.$DeclDestr;
            if not self.targetLuaVer.$canUseMetaGc {
               self.addErrMess(
                  firstToken.pos, "this lua version is not support __free." );
            }
         }
         default {
            kind = Nodes.NodeKind.$DeclMethod;
         }
      }
   }
   else {
      kind = Nodes.NodeKind.$DeclFunc;
      if not staticFlag {
         staticFlag = true;
      }
   }

   let orgStaticFlag = staticFlag;
   if declFuncMode == .Module {
      // module で Lua の外部モジュールを宣言した場合、
      // モジュール名でメンバにアクセスできるように、
      // 強制的に static にする。
      staticFlag = true;
   }

   let mut parentScope = self.$scope;
   let mut funcBodyScope = self.pushScope( .Other ## );

   if staticFlag and classTypeInfo {
      self.analyzingStaticMethodArgsScope = funcBodyScope;
   }

   
   let mut altTypeList:&List<&Ast.TypeInfo> = [];
   // generic 宣言
   if token.txt == "<" {
      token, altTypeList = self.analyzeDeclAlternateType( false, token, accessMode );
      foreach altType in altTypeList {
         funcBodyScope.addAlternate(
            self.processInfo, accessMode, altType.$rawTxt, firstToken.pos, altType );
      }

   }

   self.checkToken( token, "(" );


   let parentPub;
   when! classTypeInfo {
      parentPub = Ast.isPubToExternal( classTypeInfo.$accessMode );
   }
   else {
      parentPub = Ast.isPubToExternal( accessMode );
   }
   
   let mut argList:List<&Nodes.Node> = [];
   token = self.analyzeDeclArgList( accessMode, funcBodyScope, argList, parentPub );

   self.checkToken( token, ")" );
   token = self.getToken(##);

   let mut mutMode;
   let asyncMode;

   token, mutMode, asyncMode = self.getMutableAsync( token );

   let mut pubToExtFlag = Ast.isPubToExternal( accessMode );

   let mut argTypeList:List<&Ast.TypeInfo> = [];
   foreach argNode in argList {
      argTypeList.insert( argNode.$expType );
   }


   let mut alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
   when! classTypeInfo {
      alt2typeMap = classTypeInfo.createAlt2typeMap( false );

      if kind == Nodes.NodeKind.$DeclMethod or
         kind == Nodes.NodeKind.$DeclConstr or
         kind == Nodes.NodeKind.$DeclDestr
      {
         let mut workClass = classTypeInfo;
         if kind == Nodes.NodeKind.$DeclConstr or kind == Nodes.NodeKind.$DeclDestr {
            mutMode = .Mut;
         }
         // self シンボルを登録

         if not Ast.isPubToExternal( workClass.$accessMode ) {
            pubToExtFlag = false;
         }


         if Ast.TypeInfo.isMut( workClass ) and mutMode ~= .Mut {
            workClass = self.createModifier( workClass, mutMode );
         }
         if not staticFlag {
            self.$scope.add(
               self.processInfo, .Arg, false, true, "self", nil,
               workClass, .Pri, false,
               mutMode, true, false );
         }

         if not workClass.$abstractFlag and abstractFlag {
            self.addErrMess( firstToken.pos,
                             "no abstract class does not have abstract method" );
         }
      }

      if classTypeInfo.isInheritFrom( self.processInfo, Ast.builtinTypeRunner ## ) and
         Ast.isPubToExternal( accessMode )
      {
         // public なメソッドは、 mutable な引数を持てないようにする。
         // mutable 引数を渡せると、別スレッドとのメモリー競合が発生する可能性があるので、
         // 競合防止のため。
         // protected などは、同じスレッドになるので許可する。
         foreach argNode, index in argList {
            if not self.canBeAsyncParam( argNode.$expType ) {
               self.addErrMess(
                  argNode.$pos,
                  "__Runner can't have the mutable argument with public method. -- %d: %s"
                  (index, argNode.$expType.getTxt(##) ) );
            }
         }
      }
   }


   let retTypeInfoList;
   let retTypeNodeList;
   retTypeInfoList, token, retTypeNodeList = self.analyzeRetTypeList(
      pubToExtFlag, accessMode, token, parentPub );

   // let mut parentNsInfo = self.getCurrentNSInfoFromScope();
   let mut parentNsInfo = self.$curNsInfo;

   let mut funcName = "";
   when! name {
      funcName = name.txt;

      if kind == Nodes.NodeKind.$DeclFunc {
         switch accessMode {
            case .Pub, .Global {
               if parentScope ~= self.moduleScope {
                  self.addErrMess(
                     firstToken.pos,
                     "'global' or 'pub' function must exist top scope." );
               }
            }
         }
      }
   }

   let typeInfo:&Ast.TypeInfo;
   let mut typeDataAccessor:Ast.TypeDataAccessor;
   let funcSym:&Ast.SymbolInfo!;
   let mut nsInfo;
   {
      let mut workTypeInfo = self.processInfo.createFuncAsync(
         abstractFlag, false, funcBodyScope,
         typeKind, parentNsInfo.$typeInfo, parentNsInfo.$typeDataAccessor,
         false, false, staticFlag, accessMode,
         funcName,
         self.getDefaultAsync(
            typeKind, classTypeInfo or self.getCurrentClass(), asyncMode ),
         altTypeList, argTypeList, retTypeInfoList, mutMode );

      when! name {
         let workSym;
         workSym, nsInfo = self.processAddFunc(
            kind == Nodes.NodeKind.$DeclFunc,
            funcBodyScope.$outerScope, name, workTypeInfo, alt2typeMap );
         typeDataAccessor = nsInfo.$typeDataAccessor;
         typeInfo = nsInfo.$typeInfo;

         funcSym = workSym;

         if name.txt == "__main" {
            if #typeInfo.$argTypeInfoList ~= 1 or
               typeInfo.$argTypeInfoList[1].$mutMode ~= .IMut or
               typeInfo.$argTypeInfoList[1].$kind ~= .List or
               typeInfo.$argTypeInfoList[1].$itemTypeInfoList[1] ~=
               Ast.builtinTypeString or
               #typeInfo.$retTypeInfoList ~= 1 or
               typeInfo.$retTypeInfoList[1] ~= Ast.builtinTypeInt or
               typeInfo.$accessMode ~= .Pub
            {
               let mess = "'__main' function's type has to be 'pub fn __main( argList:&List<str> ) : int' -- %s" (typeInfo.$display_stirng );
               self.addErrMess( name.pos, mess );
            }
         }
      } else {
         typeInfo = workTypeInfo;
         typeDataAccessor = workTypeInfo;
         funcSym = nil;
         nsInfo = self.newNSInfo( workTypeInfo, firstToken.pos );
      }
      self.namespace2Scope[ typeInfo ] = funcBodyScope;
   }
   if asyncLocked {
      nsInfo.incLock( .AsyncLock );
   }

   if overrideFlag {
      // オーバーライドの型チェック

      if not name {
         self.addErrMess( firstToken.pos, "can't override anonymous func" );
      };
      if CantOverrideMethods.has( funcName ) {
         self.addErrMess( firstToken.pos, "This method can't override -- %s" (funcName) );
      }
      if! let overrideType = self.$scope.$parent.getTypeInfoField(
         funcName, false, funcBodyScope, self.scopeAccess )
      {
         foreach err in self.checkOverrideMethod( overrideType, typeInfo ) {
            self.addErrMess( firstToken.pos, err );
         }
      }
      else {
         //Ast.dumpScope( self.scope.$parent, "" );
         self.addErrMess( firstToken.pos, "not found override -- " .. funcName );
      }
   }
   else {
      when! name {
         if not CantOverrideMethods.has( name.txt ) {
            if! let sameNameType = self.$scope.$parent.getTypeInfoField(
               name.txt, false, funcBodyScope, .Full )
            {
               if not staticFlag or not sameNameType.$staticFlag {
                  self.addErrMess( firstToken.pos,
                                   "can't exist the same name func --" .. funcName );
               }
            } else {
               if! let ifFunc = self.$scope.$parent.getSymbolInfoIfField(
                  name.txt, funcBodyScope, .Full )
               {
                  if not ifFunc.$typeInfo.canEvalWith(
                     self.processInfo, typeInfo, .SetEq, alt2typeMap )
                  {
                     self.addErrMess( firstToken.pos,
                                      "mismatch method type -- %s" (funcName));
                  }
               }
            }
         }
      }
   }

   let mut node = self.createNoneNode( firstToken.pos );
   //let mut needNode = false;

   // 関数 Body の解析
   let mut body:Nodes.BlockNode! = nil;
   let mut blockTokenList:&List<&Parser.Token> = [];
   let mut needFuncBlockInfo = false;
   
   let inMacroExpand = self.macroCtrl.isInExpandMode();
   
   let stmtNum;
      
   if token.txt == ";" {
      // プロトタイプ宣言
      if declFuncMode == .Module or declFuncMode == .Glue {
         //needNode = true;
      }
      else {
         if not abstractFlag {
            nsInfo.set_nobody( true );
         }
         if classTypeInfo$.$kind == .IF {
            //needNode = true;
         }
         else {
            if kind == Nodes.NodeKind.$DeclMethod {
               kind = Nodes.NodeKind.$ProtoMethod;
            }
         }
      }
      stmtNum = 0;
   }
   else {
      //needNode = true;

      if abstractFlag {
         self.addErrMess( token.pos, "abstract method can't have body." );
      }

      self.pushback();

      let analyzingState = getAnalyzingState( typeInfo );
      // if isCtorFlag {
      //    analyzingState = .Constructor;
      // }
      // elseif staticFlag and classTypeInfo {
      //    analyzingState = .ClassMethod;
      // }
      // else {
      //    analyzingState = .Func;
      // }

      funcBodyScope.addLocalVar(
         self.processInfo, 
         false, false, "__func__", firstToken.pos, Ast.builtinTypeString, .IMut );


      _switch self.analyzePhase {
         case .Meta {
            let declScope:&Ast.Scope!;
            when! classTypeInfo {
               declScope = (unwrap classTypeInfo.$scope).$parent;
            } else {
               declScope = (unwrap typeInfo.$scope).$parent;
            }
            
            if analyzingState == .Constructor or
               self.macroCtrl.$isDeclaringMacro or
               declScope ~= self.moduleScope or
               name == nil
            {
               // 以下のケースは、関数本体処理を解析しないと問題がある。
               // - コンストラクタは、メンバ設定チェックがある
               // - マクロの macro-statment は、解析しないとマクロを実行できない
               // - モジュールスコープと異なる関数は、クロージャチェックが必要
               // - 名前なしは、 let foo = fn () {} のケースがある
            } else {
               needFuncBlockInfo = true;
            }
         }
         case .Main, .Runner {
         }
      }

      if needFuncBlockInfo {
         blockTokenList = self.skipBlock( true );
         stmtNum = #blockTokenList;
      } else {
         let mut workBody = self.analyzeFuncBlock(
            analyzingState, firstToken, classTypeInfo, typeInfo,
            funcName, funcBodyScope, typeInfo.$retTypeInfoList );
         body = workBody;

         self.declFuncPostProcess( typeInfo, classTypeInfo, workBody, funcBodyScope );
         stmtNum = nsInfo.$stmtNum;
      }
   }

   if staticFlag and classTypeInfo {
      self.analyzingStaticMethodArgsScope = nil;
   }


   fn createDeclFuncInfo( funcKind:Nodes.FuncKind ) __trans : &Nodes.DeclFuncInfo {
      let classDeclNode:Nodes.DeclClassNode!;
      when! classTypeInfo {
         classDeclNode = self.typeInfo2ClassNode[ classTypeInfo ];
      }
      else {
         classDeclNode = nil;
      }

      let mut declFuncInfo = new Nodes.DeclFuncInfo(
         funcKind, classTypeInfo, classDeclNode, outsizeOfClass, name, funcSym,
         argList, orgStaticFlag, accessMode, asyncMode, body,
         retTypeInfoList, retTypeNodeList,
         self.has__func__Symbol.has( typeInfo ), overrideFlag, stmtNum );

      if needFuncBlockInfo {
         let pos = self.getLineNo( blockTokenList[1] );
         let orgPos:&Parser.Position!;
         if inMacroExpand {
            orgPos = pos;
         } else {
            orgPos = nil;
         }

         let mut funcBlockInfo = new FuncBlockInfo(
            declFuncInfo, nsInfo, typeInfo, typeDataAccessor,
            funcBodyScope, blockTokenList, pos, orgPos );
         self.addFuncBlockInfoList( funcBlockInfo );
      }
      
      return declFuncInfo;
   }

   switch ( kind ) {
      case Nodes.NodeKind.$DeclConstr {
         if classTypeInfo$.isInheritFrom$( self.processInfo, Ast.builtinTypeRunner ## )
         {
            // runner のコンストラクタから、
            // noasync で競合データを取得してメンバにセットされると
            // 競合のガードが破綻するので、
            // コンストラクタの __async をチェックする。
            if typeInfo.$asyncMode ~= .Async {
               let message =
                  "The constructor of the class extended __Runner must be __async. -- %s"
                   (typeInfo.$parentInfo.getTxt(##) );
               self.addErrMess( firstToken.pos, message );
            }
         }
         
         
         let info = createDeclFuncInfo( .Ctor );
         node = Nodes.DeclConstrNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$DeclDestr {
         if typeInfo.$accessMode ~= .Pri {
            self.addErrMess( firstToken.$pos, "__free must be private." );
         }
         let info = createDeclFuncInfo( .Dstr );
         node = Nodes.DeclDestrNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$DeclMethod {
         let info = createDeclFuncInfo( .Mtd );
         node = Nodes.DeclMethodNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$ProtoMethod {
         let info = createDeclFuncInfo( .Mtd );
         node = Nodes.ProtoMethodNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      case Nodes.NodeKind.$DeclFunc {
         let info = createDeclFuncInfo( .Func );
         node = Nodes.DeclFuncNode.create(
            self.nodeManager, firstToken.pos, self.inTestBlock,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], info );
      }
      default {
         self.error( "illegal kind -- %d" (kind) ); // バグ
      }
   }
   self.has__func__Symbol.del( typeInfo );

   self.popScope();

   if needPopFlag {
      self.addMethod( unwrap classTypeInfo, node, funcName );
      self.popClass();
   }

   return node;
}

fn TransUnit.createExpListNode(
   orgExpList:&Nodes.ExpListNode, newExpList:&List<&Nodes.Node> ) mut: Nodes.ExpListNode
{
   // 引数リストを更新する
   let mut newExpTypeList:List<&Ast.TypeInfo> = [];
   foreach expNode in newExpList {
      newExpTypeList.insert( expNode.$expType );
   }
   if #newExpList[ #newExpList ].$expTypeList > 1 {
      self.addErrMess( orgExpList.$pos, "illegal exp -- %d"
                       (#newExpList[ #newExpList ].$expTypeList) );
   }
   if! let mRetIndex = orgExpList.$mRetExp$.$index {
      if mRetIndex > #newExpList {
         self.addErrMess( orgExpList.$pos, "over index -- %d" (mRetIndex) );
      }
      // implicit cast 等で expTypeList が変更されるので、チェックしない。
      // elseif #newExpList[mRetIndex].$expTypeList == 1 {
      //    self.addErrMess( orgExpList.$pos, "unmatch mRetIndex -- %d" (mRetIndex) );
      // }
   }
   return Nodes.ExpListNode.create(
      self.nodeManager, orgExpList.$pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), newExpTypeList, newExpList,
      orgExpList.$mRetExp, orgExpList.$followOn );
}


fn TransUnit.checkLiteralEmptyCollection(
   pos:&Parser.Position, symbolName:str, expType:&Ast.TypeInfo ) mut
{
   foreach itemType in expType.$itemTypeInfoList {
      if itemType == Ast.builtinTypeNone {
         // [] や {} を型推論はできない。
         self.addErrMess(
            pos,
            "must set the item type of Collection. -- %s:%s"
            (symbolName, expType.$srcTypeInfo.getTxt( self.typeNameCtrl## ) ) );
         break;
      }
   }
}

fn TransUnit.accessSymbol( symbolInfo:&Ast.SymbolInfo, canLeftExp:bool ) mut {
   if symbolInfo.$kind == .Fun {
      self.$scope.accessSymbol( self.moduleScope, symbolInfo );
      symbolInfo.set_posForModToRef( symbolInfo.$posForLatestMod );

      
      if self.$scope.isClosureAccess( self.moduleScope, symbolInfo ) {
         // 関数の場合、AST 解析中の時点ではクロージャ処理が必要かどうかが
         // 判定できないので、リストに保持して AST 解析後に別途処理する。
         self.closureFunList.insert( new ClosureFun( symbolInfo, self.$scope ) );
      }

      
      // クロージャの変数をアクセスありにする
      if! let scope = symbolInfo.$typeInfo.$scope {
         scope.updateClosureRefPos();        
      }
   }
   else {
      self.$scope.accessSymbol( self.moduleScope, symbolInfo );
      if canLeftExp {
         self.accessSymbolSetQueue.add( symbolInfo );
      } else {
         symbolInfo.set_posForModToRef( symbolInfo.$posForLatestMod );
      }
   }
}


class LetVarInfo {
   pub let mutable:Ast.MutMode;
   pub let varName: &Parser.Token;
   pub let varType:&Nodes.RefTypeNode!;
}


/**
代入文の右辺の式の解析。

@param firstPos 左辺の位置
@param accessMode 代入先の AccessMode
@param unwrapFlag 右辺の式の結果を unwrap する場合 true
@param letVarList 左辺の変数リスト
@param typeInfoList 左辺の変数の型リスト
@return List<&Ast.TypeInfo> unwrap 後の右辺の型リスト
@return &List<&LetVarInfo> letVarList
@return &List<&Ast.TypeInfo> unwrap 前の右辺の型
@return Nodes.ExpListNode! 右辺の Node
*/
fn TransUnit.analyzeInitExp(
   firstPos:&Parser.Position, accessMode:Ast.AccessMode, unwrapFlag:bool,
   letVarList:List<&LetVarInfo>, typeInfoList : List<&Ast.TypeInfo> ) mut :
List<&Ast.TypeInfo>, &List<&LetVarInfo>, &List<&Ast.TypeInfo>, Nodes.ExpListNode!
{
   // 初期値の式を取得
   let mut expList:Nodes.ExpListNode! = nil;
   let mut expectTypeList:List<&Ast.TypeInfo> = [];
   foreach varInfo in letVarList {
      expectTypeList.insert(
         unwrap varInfo.varType$.$expType default Ast.builtinTypeNone );
   }
   
   expList = self.analyzeExpList( false, false, false, true, nil, expectTypeList ## );
   if not expList {
      self.error( "expList is nil" ); // 要対応
   }
   

   // unwrap 前の型
   let mut orgExpTypeList: List<&Ast.TypeInfo> = [];

   // 型推論の解決と、宣言されている型と初期値との整合性を確認
   when! expList {

      if unwrapFlag {
         // unwrapFlag 値の中に nilable があるかどうか確認する。
         let mut hasNilable = false;
         foreach varInfo, index in letVarList {
            if expList.getExpTypeAt( index ).$nilable and varInfo.varName.txt ~= "_"
            {
               hasNilable = true;
               break;
            }
         }
         if not hasNilable {
            self.addErrMess( firstPos, "has no nilable" );
         }
      }
      
      let mut workList = expList;
      let mut updateExpList = false;
      let mut newExpList:List<&Nodes.Node> = [];
      foreach exp, index in workList.$expList {
         newExpList.insert( exp ) ;
         if not exp.canBeRight( self.processInfo ) {
            self.addErrMess( exp.$effectivePos,
                             "this node(%d) can not be r-value. -- %s"
                             (index, Nodes.getNodeKindName( exp.$kind ) ) );
         }
      }

      //  初期化値の型を反映する
      let mut expTypeList: List<&Ast.TypeInfo> = [];
      foreach expType, index in workList.$expTypeList {
         if index == #workList.$expTypeList and expType.$kind == .DDD
         {
            // 最終要素が ... の場合、残りの変数宣言の分 stem をセットする
            let mut dddItemType = Ast.builtinTypeStem_;
            if #expType.$itemTypeInfoList > 0 {
               dddItemType = expType.$itemTypeInfoList[ 1 ].$nilableTypeInfo;
            }
            for subIndex = index, #letVarList {
               let argType = typeInfoList[ subIndex ];
               let mut checkType = dddItemType;
               if unwrapFlag {
                  checkType = dddItemType.$nonnilableType;
               }
               if not argType.equals( self.processInfo, Ast.builtinTypeEmpty ## ) and
                  not argType.canEvalWith(
                     self.processInfo, checkType, .SetOp, {} )
               {
                  self.addErrMess(
                     firstPos,
                     "unmatch value type (index = %d) %s <- %s"
                     ( subIndex, argType.getTxt( self.typeNameCtrl## ),
                       dddItemType.getTxt(##) ));
               }
               expTypeList.insert( checkType );
               orgExpTypeList.insert( dddItemType );
            }
         }
         else {
            // 最終要素でない場合
            let mut expTypeInfo: &Ast.TypeInfo = expType;
            if expType.$kind == .DDD {
               let itemList = expType.$itemTypeInfoList;
               if #itemList > 0 {
                  expTypeInfo = itemList[ 1 ];
               }
               else {
                  expTypeInfo = Ast.builtinTypeStem_;
               }
            }
            orgExpTypeList.insert( expTypeInfo );
            if expTypeInfo == Ast.builtinTypeNil and index <= #typeInfoList {
               // 初期値が nil の場合、 orgExpTypeList は代入先の nilable 型とする
               orgExpTypeList[ index ] = typeInfoList[ index ].$nilableTypeInfo;
            }
            if unwrapFlag and expTypeInfo.$nilable {
               expTypeInfo = expTypeInfo.$nonnilableType;
            }

            if index <= #typeInfoList {
               let varType = typeInfoList[ index ];
               let mut alt2typeMap =
               Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap(false);
               if varType.$kind == .Box {
                  alt2typeMap = varType.createAlt2typeMap( true );
               }
               Ast.CanEvalCtrlTypeInfo.setupNeedAutoBoxing(
                  alt2typeMap, self.processInfo );   

               if not varType.equals( self.processInfo, Ast.builtinTypeEmpty ## ) and
                  not (unwrapFlag and
                        expTypeInfo.equals( self.processInfo, Ast.builtinTypeNil ## ))
               {
                  let canEval, mess = varType.canEvalWith(
                     self.processInfo, expTypeInfo, .SetOp, alt2typeMap );
                  if not canEval {
                     self.addErrMess(
                        firstPos,
                        "unmatch value type (index:%d) %s <- %s%s"
                        ( index,
                          varType.getTxt( self.typeNameCtrl ## ),
                          expTypeInfo.getTxt( self.typeNameCtrl ## ),
                          mess and " -- %s" ( mess ) or "" ) );
                  }
               }
               if varType.$kind == .Box {
                  typeInfoList[ index ] = self.processInfo.createBox(
                     accessMode, expTypeInfo );
               }
               //if varType.$kind == .Box and expTypeInfo.$srcTypeInfo.$kind ~= .Box {
               if Ast.CanEvalCtrlTypeInfo.canAutoBoxing( varType, expTypeInfo ) {
                  // auto boxing
                  updateExpList = true;
                  let exp = newExpList[ index ];
                  newExpList[ index ] = Nodes.BoxingNode.create(
                     self.nodeManager, exp.$pos, self.inTestBlock,
                     self.macroCtrl.isInAnalyzeArgMode(), [ varType ], exp );
                  if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 1 ) {
                     self.addErrMess( exp.$pos,
                                      "auto boxing error %s <- %s"
                                      ( varType.getTxt(##), expTypeInfo.getTxt(##)) );
                  }
               }
               else {
                  if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 0 ) {
                     self.addErrMess(
                        newExpList[ index ].$pos,
                        "illegal auto boxing error %s <- %s"
                        ( varType.getTxt(##), expTypeInfo.getTxt(##)) );
                  }
               }
            }
            expTypeList.insert( expTypeInfo );
         }
      }
      if updateExpList {
         // 引数リストを更新する
         workList = self.createExpListNode( workList, newExpList );
      }

      {
         let mut alt2typeMap =
         Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap(false);

         if! self.checkImplicitCast(
            alt2typeMap, true, typeInfoList, workList,
            fn ( dstType:&Ast.TypeInfo, expNode:&Nodes.Node ): &Nodes.Node! {
               return nil;
            } )
         {
            workList = _exp;
         }
      }


      // 宣言する変数の数より初期値が少ない場合、
      // nil で初期化されるため変数が nilable かどうか判定
      foreach varType, index in typeInfoList {
         if index > #expTypeList {
            if not varType.$nilable {
               self.addErrMess(
                  firstPos,
                  "unmatch value type (index:%d) %s <- nil"
                  (index, varType.getTxt( self.typeNameCtrl## )));
            }
         }
      }
      // 変数の型を、型推論で初期値から設定
      foreach typeInfo, index in expTypeList {
         if #typeInfoList < index or
         typeInfoList[ index ].equals( self.processInfo, Ast.builtinTypeEmpty ## )
         {
            let workPos;
            let workType;
            let workName;
            if index <= #letVarList {
               let letVar = letVarList[ index ];
               workPos = letVar.varName.pos;
               workName = letVar.varName.txt;
               if Ast.TypeInfo.isMut( typeInfo ) and
                  not Ast.isMutable( letVar.mutable ) 
               {
                  workType = self.createModifier( typeInfo, .IMutRe );
               }
               else {
                  workType = typeInfo;
               }

               if self.analyzeMode == .Inquire and self.isTargetToken( letVar.varName ) {
                  self.dumpSymbolType( accessMode, letVar.varName.txt, workType );
               }
            }
            else {
               workType = typeInfo;
               workPos = firstPos;
               workName = "";
            }
            typeInfoList[ index ] = workType;

            switch workType.$kind {
               case .Func {
                  if #expTypeList ~= 1 or workType.$rawTxt ~= "" {
                     // anonymous 関数宣言の型推論変数宣言は、
                     // 通常関数宣言に置き換えるが、
                     // 2 つ以上の変数を宣言している場合はエラーとする。
                     self.addErrMess(
                        firstPos,
                        "must set the type of variable for function. -- %s"
                        (workName) );
                  }
               }
               case .List, .Array, .Set, .Map {
                  self.checkLiteralEmptyCollection( workPos, workName, workType );
               }
            }
         }
      }
      return typeInfoList, letVarList, orgExpTypeList, workList;
   }

   return typeInfoList, letVarList, orgExpTypeList, nil;
}

fn TransUnit.analyzeExpandTuple(
   firstPos:&Types.Position, condRetInfo:&Nodes.CondRetInfo!,
   typeInfoList:&List<&Ast.TypeInfo>, varList:&List<&Nodes.VarInfo>,
   symbolInfoList:&List<&Ast.SymbolInfo>,
   expList:&Nodes.ExpListNode ) mut : Nodes.ExpandTupleNode
{
   return Nodes.ExpandTupleNode.create(
      self.nodeManager, firstPos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
      condRetInfo, varList, expList, symbolInfoList );
}


/*
let で宣言している変数シンボル、型、初期値の型情報を解析して返す。

スコープへの変数シンボルの登録は行なわない。

@param firstPos エラー発生時に使用する位置情報
@param initMutable 変数の mutable 初期値。
   true を指定した場合、 mut を明示しなくても mutable として扱う。
@param accessMode アクセスモード
@param unwrapFlag unwrap して変数に初期値を格納するかどうか。
@return List<&Ast.TypeInfo> 型推論解決後の変数の型情報リスト
@return LetVarInfo[] 変数のシンボル等の情報リスト
@return List<&Ast.TypeInfo> unwrap 前の初期値の型リスト
@return Nodes.ExpListNode! 初期値の ExpListNode。初期値が与えられていない場合は nil。
*/
fn TransUnit.analyzeLetAndInitExp(
   firstPos:&Parser.Position, letFlag:bool, initMutable:Ast.MutMode,
   accessMode:Ast.AccessMode, unwrapFlag:bool, expandTuple:bool ) mut :
&List<&Ast.TypeInfo>, &List<&LetVarInfo>, &List<&Ast.TypeInfo>, &Nodes.ExpListNode!
{
   // 宣言している変数の型リスト
   let mut typeInfoList : List<&Ast.TypeInfo> = [];
   // let で宣言している変数名と型の情報リスト
   let mut letVarList:List<&LetVarInfo> = [];

   let mut nextToken = Parser.getEofToken();

   if letFlag {
      let mut hasValidName = false;
      repeat {
         // 変数名と : で明示している型情報を取得。
         let mut mutable = initMutable;
         nextToken = self.getToken(##);
         switch nextToken.txt {
            case "mut" {
               mutable = .Mut;
               nextToken = self.getToken(##);
            }
         }
         let varName = self.checkSymbol( nextToken, .MustNot_Or_ );
         if varName.txt ~= "_" {
            hasValidName = true;
         }
         nextToken = self.getToken(##);
         let mut typeInfo = Ast.builtinTypeEmpty;
         if nextToken.txt == ":" {
            // 型を明示している場合
            let refType = self.analyzeRefType(
               accessMode, false, Ast.isPubToExternal( accessMode ), false, false );
            letVarList.insert( new LetVarInfo( mutable, varName, refType ) );
            typeInfo = refType.$expType;
            if unwrapFlag and typeInfo.$nilable {
               // unwrap しているのに代入先が nilable なのは変なので
               // warning する。
               self.addWarnMess(
                  refType.$pos,
                  "it shouldn use non-nilable type -- %s" (typeInfo.getTxt(##)) );
            }
            nextToken = self.getToken(##);
         }
         else {
            // 型を明示していない場合、 mut でなければ .IMutRe とする
            letVarList.insert(
               new LetVarInfo( Ast.isMutable( mutable ) and mutable or Ast.MutMode.IMutRe,
                               varName, nil ) );
         }
         if not typeInfo.equals( self.processInfo, Ast.builtinTypeEmpty ## ) and
            Ast.TypeInfo.isMut( typeInfo ) and not Ast.isMutable( mutable ) and         
            self.ctrl_info.legacyMutableControl            
         {
            typeInfo = self.createModifier( typeInfo, .IMutRe );
         }
         typeInfoList.insert( typeInfo );
      } nextToken.txt ~= ",";
      if not hasValidName {
         self.addErrMess( firstPos, "all '_' symbol is invalid." );
      }
   } else {
      while true {
         let symbolToken = self.getToken(##);
         nextToken = self.getToken(##);

         let verSym = self.$scope.getSymbolTypeInfo(
            symbolToken.txt, self.$scope, self.moduleScope, self.scopeAccess );
         when! verSym {
            letVarList.insert( new LetVarInfo( verSym.$mutMode, symbolToken, nil ) );
            typeInfoList.insert( verSym.$typeInfo );
         } else {
            self.addErrMess( symbolToken.pos,
                             "not found symbol -- %s" (symbolToken.txt) );
         }
         if nextToken.txt ~= "," {
            break;
         }
      }
   }

   if expandTuple {
      self.checkToken( nextToken, ")" );
      self.checkNextToken( "=" );

      let expListNode = self.analyzeExpList( false, false, false, true ## );
      let expType = expListNode.$expType;
      if expType.$kind ~= .Tuple {
         self.errorAt( expListNode.$pos,
                       "expects the tuple value, but -- %s" (expType.getTxt(##)) );
      }
      if #expListNode.$expTypeList ~= 1 {
         self.addErrMess(
            expListNode.$pos,
            "expects 1 tuple value, but -- %d value" (#expListNode.$expTypeList) );
      }
      if #expType.$itemTypeInfoList ~= #letVarList {
         self.errorAt(
            expListNode.$pos,
            "expects %d item tuple, but -- %d item"
            (#letVarList, #expType.$itemTypeInfoList) );
      }
      return expType.$itemTypeInfoList, letVarList, expType.$itemTypeInfoList, expListNode;
   }
   
   if nextToken.txt ~= "=" {
      self.pushback();
      let mut orgExpTypeList: List<&Ast.TypeInfo> = [];
      return typeInfoList, letVarList, orgExpTypeList, nil;
   }
   return self.analyzeInitExp(
      firstPos, accessMode, unwrapFlag, letVarList, typeInfoList)**;
}

fn TransUnit.analyzeDeclVar(
   mode:Nodes.DeclVarMode,
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut unwrapFlag = false;
   let mut token, continueFlag = self.getContinueToken();
   if continueFlag and token.txt == "!" {
      unwrapFlag = true;
   }
   else {
      self.pushback();
      if mode ~= .Let {
         Util.log( "need '!'" );
      }
   }

   if accessMode == .Pub {
      if self.$scope ~= self.moduleScope {
         self.addErrMess( firstToken.pos, "'pub' variable must exist top scope." );
      }
   }

   let expandTuple;
   {
      let workToken = self.getToken(##);
      if workToken.txt == "(" and mode == .Let {
         expandTuple = true;
      } else {
         expandTuple = false;
         self.pushback();
      }
   }
   
   let mut typeInfoList, mut letVarList, mut orgExpTypeList, mut expList =
      self.analyzeLetAndInitExp(
         firstToken.pos, mode == .Let,
         mode == .Sync and Ast.MutMode.Mut or Ast.MutMode.IMut,
         accessMode, unwrapFlag, expandTuple );

   let condRetInfo = self.checkCondRet();


   if mode == .Let and #typeInfoList == 1 {
      when! expList {
         let typeInfo = typeInfoList[ 1 ];
         let letVaInfo = letVarList[ 1 ];
         if #expList.$expList == 1 and typeInfo.$kind == .Func {
            let mut valExp = expList.$expList[ 1 ];
            if! let macroExp = valExp@@@Nodes.ExpMacroExpNode {
               if macroExp.$expType.$kind == .Func and #macroExp.$stmtList == 1 {
                  valExp = macroExp.$stmtList[1];
               }
            }
            if! let declNode = valExp@@@Nodes.DeclFuncNode {
               if not declNode.$declInfo.$name {
                  if Ast.isMutable( letVaInfo.mutable ) {
                     self.addErrMess(
                        letVaInfo.varName.pos, 
                        "Any function can't be mutable. -- %s" (letVaInfo.varName.txt) );
                  }
                  // anonymous 関数宣言の型推論変数宣言は、
                  // 通常関数宣言に置き換える。
                  // 次のような感じ。
                  // let func = fn () {}; → fn func() {}
                  let letVarInfo = letVarList[ 1 ];
                  let mut newTypeInfo = self.processInfo.createFuncAsync(
                     typeInfo.$abstractFlag, false,
                     unwrap self.namespace2Scope[ typeInfo ],
                     typeInfo.$kind, typeInfo.$parentInfo,
                     self.getNSInfo( typeInfo.$parentInfo ).$typeDataAccessor,
                     false, false, typeInfo.$staticFlag, accessMode,
                     letVarInfo.varName.txt, typeInfo.$asyncMode,
                     typeInfo.$itemTypeInfoList, typeInfo.$argTypeInfoList,
                     typeInfo.$retTypeInfoList, typeInfo.$mutMode );
                  let funcSym = self.processAddFunc(
                     true, self.$scope, letVarInfo.varName, newTypeInfo,
                     Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
                  self.nodeManager.delNode( declNode );

                  let mut declInfo = Nodes.DeclFuncInfo.createFrom(
                     declNode.$declInfo, letVarInfo.varName, funcSym );
                  return Nodes.DeclFuncNode.create(
                     self.nodeManager, declNode.$pos, self.inTestBlock,
                     self.macroCtrl.isInAnalyzeArgMode(), [ newTypeInfo ], declInfo );
               }
            }
         }
      }
   }


   let mut syncScope:Ast.Scope = self.$scope;
   if mode == .Sync {
      syncScope = self.pushScope( .Other ## );
   }


   let mut nsInfo = self.$curNsInfo;
   
   let mut symbolInfoList: List<&Ast.SymbolInfo> = [];

   let mut varList:List<&Nodes.VarInfo> = [];
   let mut syncSymbolList:List<&Ast.SymbolInfo> = [];
   foreach letVarInfo, index in letVarList {
      let varName = letVarInfo.varName;
      let typeInfo = typeInfoList[ index ];
      let varInfo = new Nodes.VarInfo(
         varName, letVarInfo.varType, typeInfo );
      varList.insert( varInfo );

      if Ast.isPubToExternal( accessMode ) {
         self.checkPublic( varName.pos, typeInfo );
      }

      if not letVarInfo.varType and
         typeInfo.equals( self.processInfo, Ast.builtinTypeNil ## )
      {
         self.addErrMess(
            varName.pos, 'need type -- %s' ( varName.txt ) );
      }
      if mode == .Sync {
         // スコープに登録する前に、シンボルを検索
         if! let symInfo = self.$scope.getSymbolInfo(
            varName.txt, self.$scope, true, self.scopeAccess )
         {
            syncSymbolList.insert( symInfo );
         }
      }
      // スコープに変数を登録
      if mode == .Let or mode == .Sync {
         if mode == .Let {
            self.checkShadowing( varName.pos, varName.txt, self.$scope );
            // if self.scope.getTypeInfo( varName.txt, self.scope, true, self.scopeAccess ) {
            //    self.addErrMess( varName.pos,
            //                     "shadowing variable -- %s" (varName.txt) );
            // }
         }
         let mut orgExpType = Ast.builtinTypeStem_;
         if not unwrapFlag {
            orgExpType = Ast.builtinTypeEmpty;
         }
         if index <= #orgExpTypeList {
            orgExpType = orgExpTypeList[ index ];
         }

         let mut hasValue = false;
         if not unwrapFlag and orgExpType ~= Ast.builtinTypeEmpty or
            unwrapFlag and not orgExpType.$nilable
         {
            hasValue = true;
         }
         self.$scope.addVar(
            self.processInfo, accessMode, varName.txt, varName.pos,
            typeInfo, letVarInfo.mutable, hasValue );

         if typeInfo.$asyncMode == .Transient {
            // Transient は変数への代入禁止
            self.addErrMess(
               varName.pos,
               "can't set the __trans type -- index:%d, %s"
               (index, typeInfo.getTxt(##)) );
         }
      }
      symbolInfoList.insert( nsInfo.registerSym(
         unwrap self.$scope.getSymbolInfo( varName.txt, self.$scope,
                                           true, self.scopeAccess ) ) );
   }


   if mode ~= .Sync and self.macroScope {
      self.macroCtrl.registVar( symbolInfoList );
   }

   if expandTuple {
      when! expList {
         return self.analyzeExpandTuple( firstToken.pos, condRetInfo, typeInfoList,
                                         varList, symbolInfoList, expList );
      } else {
         self.errorAt( firstToken.pos, "expanding tuple must set init value." );
      }
   }

   let mut unwrapBlock: Nodes.BlockNode! = nil;
   let mut thenBlock: Nodes.BlockNode! = nil;
   if unwrapFlag {
      let mut scope = self.pushScope( .Other ## );

      if #orgExpTypeList < #letVarList {
         if #orgExpTypeList > 0 and orgExpTypeList[ #orgExpTypeList ].$kind == .DDD {
            // 最終が ... の場合は、初期値が足りない場合も OK
         } else {
            // let! の初期値が足りない場合はエラー
            self.errorAt(
               firstToken.pos,
               "'let!' needs initial values. need %d but %d."
               (#letVarList, #orgExpTypeList) );
         }
      }

      
      // unwrap ブロックに変数を登録
      foreach letVarInfo, index in letVarList {
         if letVarInfo.varName.txt ~= "_" {
            self.addLocalVar(
               letVarInfo.varName.pos, false, true,
               "_" .. letVarInfo.varName.txt, orgExpTypeList[ index ], .IMut ## );
         }
      }

      unwrapBlock = self.analyzeBlock( .LetUnwrap, .Start, scope, nil );
      self.popScope();

      // unwrap ブロック後には変数にデータがセットされているものとする。
      when! unwrapBlock {
         _switch mode {
            case .Let, .Sync {
               let breakKind = unwrapBlock.getBreakKind( .Normal );
               foreach symbolInfo in symbolInfoList {
                  // let symbolInfo =
                  //    unwrap self.scope.getSymbolInfoChild( letVarInfo.varName.txt );
                  if breakKind ~= .None {
                     self.tentativeSymbol.checkAndExclude( symbolInfo );
                     symbolInfo.updateValue( symbolInfo.$pos );
                  }
                  else {
                     if symbolInfo.$name ~= "_" and
                        not self.tentativeSymbol.checkAndExclude( symbolInfo )
                     {
                        if not symbolInfo.$hasValueFlag {
                           self.addErrMess(
                              unwrapBlock.$pos,
                              "This variable isn't set -- " .. (symbolInfo.$name) );
                        }
                     }
                  }
               }
            }
            case .Unwrap {
               foreach symbolInfo in symbolInfoList {
                  symbolInfo.updateValue( firstToken.pos );
               }
            }
         }
      }

      token = self.getToken( true );
      if token.txt == "then" {
         thenBlock = self.analyzeBlock( .LetUnwrapThenDo, .Finish, scope, nil );
      }
      else {
         self.pushback();
         self.finishTentativeSymbol( true );
      }
   }

   let mut syncBlock: Nodes.BlockNode! = nil;
   if mode == .Sync {
      self.checkNextToken( "do" );
      syncBlock = self.analyzeBlock( .LetUnwrapThenDo, .Simple, syncScope, nil );
      self.popScope();
   }

   self.checkNextToken( ";" );

   let mut node = Nodes.DeclVarNode.create(
      self.nodeManager, firstToken.pos,  self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], mode, accessMode, false, condRetInfo,
      varList, expList, symbolInfoList, typeInfoList, unwrapFlag, unwrapBlock,
      thenBlock, syncSymbolList, syncBlock );

   return node;
}

/**
if! の解析。

@param firstToken if 部分のトークン
@return if! のノード
*/
fn TransUnit.analyzeIfUnwrap( firstToken: &Parser.Token ) mut : Nodes.IfUnwrapNode
{
   let mut nextToken = self.getToken(##);
   let mut typeInfoList:&List<&Ast.TypeInfo> = [];
   let mut varNameList:List<&Parser.Token> = [];
   let mut expList:&Nodes.ExpListNode;
   let mut varList:List<&Ast.SymbolInfo> = [];

   let mut workTypeInfoList, mut letVarList, workExpList;
   if nextToken.txt == "let" {
      workTypeInfoList, letVarList, _, workExpList = self.analyzeLetAndInitExp(
         firstToken.pos, true, .IMut, .Local, true, false );
   } else {
      self.pushback();
      let mut tmpTypeInfoList : List<&Ast.TypeInfo> = [ Ast.builtinTypeEmpty ];
      let mut tmpLetVarList:List<&LetVarInfo> = [
         new LetVarInfo(
            .Mut, new Parser.Token( .Symb, "_exp", firstToken.pos, false## ), nil )
      ];
      workTypeInfoList, letVarList, _, workExpList = self.analyzeInitExp(
         firstToken.pos, .Local, true, tmpLetVarList, tmpTypeInfoList );
   }
   let condRetInfo = self.checkCondRet();
   typeInfoList = workTypeInfoList;
   when! workExpList {
      expList = workExpList;
   }
   else {
      self.addErrMess( nextToken.pos, "if! let has illegal init val." );
      self.error( "system error" ); // 要対応
   }
   foreach varInfo in letVarList {
      varNameList.insert( varInfo.varName );
   }
   
   let mut scope = self.pushScope( .Other ## );

   let mut nsInfo = self.$curNsInfo;

   foreach expType, index in typeInfoList {
      if index > #varNameList {
         break;
      }
      let varName = varNameList[ index ];
      varList.insert( nsInfo.registerSym(
         self.addLocalVar( varName.pos, false, true, varName.txt, expType, .IMut ## ) ) );
      
   }

   let block = self.analyzeBlock( .IfUnwrap, .Start, scope,  nil );

   self.popScope();

   let mut elseBlock:Nodes.BlockNode! = nil;
   nextToken = self.getToken( true );
   if nextToken.txt == "else" {
      elseBlock = self.analyzeBlock( .Else, .Finish ## );
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   let mut hasCond = false;
   foreach expNode, index in expList.$expList {
      if index ~= #expList.$expList {
         if Ast.isConditionalbe( self.processInfo, expNode.$expType ) {
            hasCond = true;
            break;
         }
      }
      else {
         foreach expType in expNode.$expTypeList {
            if Ast.isConditionalbe( self.processInfo, expType ) {
               hasCond = true;
               break;
            }
         }
      }
   }
   if not hasCond {
      self.addErrMess( firstToken.pos, "This condition never be false" );
   }

   foreach varSym in varList {
      switch varSym.$name {
         case "_", "_exp" {
         }
         default {
            if not varSym.$posForModToRef {
               self.addWarnMess(
                  unwrap varSym.$pos,
                  "This symbol has no referer -- %s" ( varSym.$name) );
            }
         }
      }
   }

   return Nodes.IfUnwrapNode.create(
      self.nodeManager, firstToken.pos, self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], varList, condRetInfo, expList, block, elseBlock );
}

fn TransUnit.analyzeWhen( firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut nextToken, continueFlag = self.getContinueToken();
   //let mut varNameList:str[] = [];

   if not ( continueFlag and nextToken.txt == "!" ) {
      self.pushback();
      self.addErrMess( nextToken.pos, "'when' need '!'" );
   }

   let symListNode = self.analyzeExpList( false, false, false, false ## );

   let mut scope = self.pushScope( .Other ## );

   //let mut expNodeList:List<&Nodes.Node> = [];
   let mut symPairList:List<&Nodes.UnwrapSymbolPair> = [];

   foreach expNode in symListNode.$expList {
      if! let refNode = expNode@@@Nodes.ExpRefNode {
         if expNode.$expType.$nilable {
            let symbolInfo = refNode.$symbolInfo;
            // varNameList.insert( refNode.$token.txt );
            let newSymbolInfo = self.addLocalVar(
               firstToken.pos, false, expNode.canBeLeft(), refNode.$symbolInfo.$name,
               expNode.$expType.$nonnilableType,
               //symbolInfo.$mutable and Ast.MutMode.Mut or Ast.MutMode.IMut, true );
               Ast.MutMode.IMut, true );
            symPairList.insert( new Nodes.UnwrapSymbolPair( symbolInfo, newSymbolInfo ) );
         }
         else {
            self.addErrMess( expNode.$pos,
                             "This type isn't nilable. -- %s"
                             ( expNode.$expType.getTxt(##) ) );
         }
      }
      else {
         self.addErrMess( expNode.$pos,
                          "'when' support only local variables or arguments." );
      }
   }

   let block = self.analyzeBlock( .When, .Start, scope, nil );

   self.popScope();

   let mut elseBlock:Nodes.BlockNode! = nil;
   nextToken = self.getToken( true );
   if nextToken.txt == "else" {
      elseBlock = self.analyzeBlock( .Else, .Finish ## );
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   return Nodes.WhenNode.create(
      self.nodeManager, firstToken.pos,  self.inTestBlock,
      self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], symPairList, block, elseBlock );
}

local fn TransUnit.processFuncBlockInfo(
   funcBlockCtlIF: FuncBlockCtlIF,
   streamName:str ) mut : Map<&FuncBlockInfo,FuncBlockResult>
{
   let resultMap:Map<&FuncBlockInfo,FuncBlockResult> = {};

   let mut bakParser = self.parser;
   
   let mut outerScope = self.pushScope( .Other## );

   while true {
      let! mut funcBlockInfo = funcBlockCtlIF.getNext() {
         break;
      };

      let typeInfo = funcBlockInfo.$funcType;
      self.parser = new Parser.DefaultPushbackParser(
         new Parser.TokenListParser(
            funcBlockInfo.$tokenList, streamName,
            funcBlockInfo.$tokenList[1].pos.orgPos ) );

      let mut declFuncInfo = funcBlockInfo.$declFuncInfo;
      let classTypeInfo = declFuncInfo.$classTypeInfo;

      self.funcBlockInfoLinkNo = funcBlockInfo.$orgPos;
      
      let mut funcBodyScope = new Ast.ScopeWithRef(
         self.processInfo, outerScope, funcBlockInfo.$funcScope, .Other ## );
      self.setScope( funcBodyScope, .FromScope );
      
      
      let mut workBody = self.analyzeFuncBlock(
         getAnalyzingState( typeInfo ),
         funcBlockInfo.$tokenList[1], classTypeInfo, typeInfo,
         typeInfo.$rawTxt, funcBodyScope, typeInfo.$retTypeInfoList );
      self.declFuncPostProcess( typeInfo, classTypeInfo, workBody, funcBodyScope );

      self.funcBlockInfoLinkNo = nil;

      let has_func_sym = self.has__func__Symbol.has( typeInfo );
      if has_func_sym {
         self.has__func__Symbol.del( typeInfo );
      }

      resultMap[ funcBlockInfo ] = new FuncBlockResult(
         funcBlockInfo, workBody, has_func_sym, self.$curNsInfo.$stmtNum );  

   }

   self.popScope();

   self.parser = bakParser;
   
   return resultMap;
}

