/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

_lune_control default_async_all;

import lune.base.Util;
import lune.base.Nodes;
import lune.base.Ast;
import lune.base.Parser;
import lune.base.Types;
import lune.base.Formatter;
import lune.base.DependLuaOnLns;
import lune.base.Builtin;

/**
code に格納されている lua code をロード・実行する。
このとき、実行しているスレッドに依存した環境上で実行する。

code の実行エラーした場合は、 error() させる。
*/
fn loadCode( code:str ) : Luaval<&stem> {
   let ret;
   __luaDepend {
      let loaded, mess = _load( code ## );
      when! loaded {
         if! let obj = loaded(##) {
            ret = obj;
         } else {
            // ここでは、lua code の実行ができない場合はエラーとする
            Util.err( "failed to load" ); // 要対応   
         }
      } else {
         // ここでは、lua code の実行ができない場合はエラーとする
         Util.err( "%s -- %s" (mess, code) ); // バグ
      }
   }
   return ret;
}

fn runLuaOnLns( code:str, baseDir:str!, async:bool ) : Luaval<&stem>!, str {
   let loadFunc, err = DependLuaOnLns.runLuaOnLns( code, baseDir, async );
   when! loadFunc {
      let mut mod:Luaval<&stem>! = nil;
      if async {
         __luaDepend {
            mod = loadFunc(##);
         }
      } else {
         __luaLock {
            mod = loadFunc(##);
         }
      }
      when! mod {
         return mod, "";
      }
      return nil, "load error";
   }
   return nil, err;
}

fn runLuaOnLnsToMacroProc(
   code:str, baseDir:str!, async:bool ) : Luaval<Nodes.macroStatmentProc>!, str
{
   let luaObj, err = runLuaOnLns( code, baseDir, async );
   when! luaObj {
      return luaObj@@Luaval<Nodes.macroStatmentProc>, "";
   }
   return nil, err;
}

   

// pub form toListLua( val:Luaval<&stem> ) __noasync : &List<&stem>;
// pub let toList = loadCode( "return function( ... ) return { ... } end" )@@toListLua;
pub form toListEmptyLua() : &List<&stem>;
pub form toLuavalLuaFunc( val:&stem! ) __async : &stem!;
pub let toLuavalNoasync =
   loadCode( "return function( val ) return val end" )@@toLuavalLuaFunc;


class MacroMetaArgInfo extend (Mapping) {
   pub let name:str;
   pub let typeId:int;
}
class MacroMetaInfo extend (Mapping) {
   pub let name:str;
   pub let pos:&List<int>;
   pub let argList:&List<MacroMetaArgInfo>;
   pub let symList:&List<MacroMetaArgInfo>;
   pub let stmtBlock:str!;
   pub let tokenList:&List<&List<stem>>;
}


class MacroParser extend Parser.Parser {
   let tokenList: &List<&Parser.Token>;
   let mut pos: int;
   let name: str;
   let overridePos:&Types.Position!;

   pub fn __init( tokenList: &List<&Parser.Token>,
                  name: str, overridePos:&Types.Position! )
   {
      super();
      self.pos = 1;
      self.tokenList = tokenList;
      self.name = name;
      self.overridePos = overridePos$.$orgPos;
   }

   pub override fn createPosition( lineNo: int, column: int ) : &Types.Position {
      return Types.Position.create( lineNo, column,
                                    self.getStreamName(), self.overridePos );
   }
   
   pub override fn getToken() mut : &Parser.Token! {
      if #self.tokenList < self.pos {
         return nil;
      }
      let token = self.tokenList[ self.pos ];
      self.pos = self.pos + 1;

      // Util.errorLog( "getToken: %s" (token.txt) );

      if! self.overridePos {
         return new Types.Token(
            token.kind, token.txt,
            self.createPosition( token.pos.lineNo, token.pos.column ),
            token.consecutive, token.$commentList );
      }
      return token;
   }
   pub override fn getStreamName(): str {
      return self.name;
   }
}


fn getLiteralMacroVal( obj:Nodes.Literal ) : stem! {
   _match obj {
      case .Nil {
         return nil;
      }
      case .Int( val ) {
         return val;
      }
      case .Real( val ) {
         return val;
      }
      case .Str( val ) {
         return val;
      }
      case .Bool( val ) {
         return val;
      }
      case .Symbol( val ) {
         return [ val ];
      }
      case .Field( val ) {
         return val;
      }
      case .LIST( list ) {
         let mut newList:List<stem!> = [];
         foreach item, index in list {
            newList[ index ] = getLiteralMacroVal( item );
         }
         return newList;
      }
      case .ARRAY( list ) {
         let mut newList:List<stem!> = [];
         foreach item, index in list {
            newList[ index ] = getLiteralMacroVal( item );
         }
         return newList;
      }
      case .SET( list ) {
         let mut newSet:Set<stem> = (@);
         foreach item in list {
            if! getLiteralMacroVal( item ) {
               newSet.add( _exp );
            }
         }
         return newSet;
      }
      case .MAP( map ) {
         let mut newMap:Map<&stem,&stem> = {};
         foreach val, key in map {
            let keyObj = getLiteralMacroVal( key );
            let valObj = getLiteralMacroVal( val );
            when! keyObj, valObj {
               newMap[ keyObj ] = valObj;
            }
         }
         return newMap;
      }
   }
}

class ExtMacroInfo extend Nodes.MacroInfo {
   pri let name:str {pub};
   pri let argList:&List<&Nodes.MacroArgInfo>;
   pri let tokenList:&List<&Parser.Token>;
   let baseDir:str! {pub};

   pub override fn getArgList():&List<&Nodes.MacroArgInfo> {
      return self.argList;
   }
   pub override fn getTokenList():&List<&Parser.Token>{
      return self.tokenList;
   }

   pub fn __init( name:str, func: Luaval<Nodes.macroStatmentProc>,
                  symbol2MacroValInfoMap: Map<str,Nodes.MacroValInfo>,
                  argList:&List<&Nodes.MacroArgInfo>,
                  tokenList:&List<&Parser.Token>,
                  baseDir:str! )
   {
      super( func, symbol2MacroValInfoMap );
      self.name = name;
      self.argList = argList;
      self.tokenList = tokenList;
      self.baseDir = baseDir;
   }
}

pub class MacroAnalyzeInfo {
   let typeInfo:&Ast.TypeInfo {pub};
   let mode:Nodes.MacroMode {pub};
   let mut argIndex:int {pub};

   pub fn __init( typeInfo:&Ast.TypeInfo, mode:Nodes.MacroMode ) {
      self.typeInfo = typeInfo;
      self.mode = mode;
      self.argIndex = 1;
   }

   pub fn clone() : MacroAnalyzeInfo {
      let mut obj = new MacroAnalyzeInfo( self.typeInfo, self.mode );
      obj.argIndex = self.argIndex;
      return obj;
   }

   pub fn equalsArgTypeList( argTypeList: &List<&Ast.TypeInfo>! ) : bool {
      return self.typeInfo.$argTypeInfoList == argTypeList;
   }
   pub fn getCurArgType():&Ast.TypeInfo {
      if #self.typeInfo.$argTypeInfoList < self.argIndex {
         return Ast.builtinTypeNone;
      }
      return self.typeInfo.$argTypeInfoList[ self.argIndex ];
   }
   pub fn nextArg() mut {
      self.argIndex = self.argIndex + 1;
   }

   pub fn isAnalyzingSymArg(): bool {
      return self.mode == .AnalyzeArg and self.getCurArgType() == Ast.builtinTypeSymbol;
   }
   pub fn isAnalyzingExpArg(): bool {
      return self.mode == .AnalyzeArg and self.getCurArgType() == Ast.builtinTypeExp;
   }
   pub fn isAnalyzingBlockArg(): bool {
      return self.mode == .AnalyzeArg and self.getCurArgType() == Ast.builtinTypeBlockArg;
   }
}

// マクロを構成するための情報
class DefMacroSrc {
   let luaCode:str! {pub};
   let declInfo: Nodes.DeclMacroInfo {pub};
   let symbol2MacroValInfoMap: Map<str,Nodes.MacroValInfo> {pub};
   let baseDir:str! {pub};
   let asyncFlag:bool {pub};
}

class DefMacroInfoWithSrc extend Nodes.DefMacroInfo {
   let srcInfo:&DefMacroSrc {local};

   pub fn __init( func: Luaval<Nodes.macroStatmentProc>!,
                  srcInfo:&DefMacroSrc,
                  symbol2MacroValInfoMap: &Map<str,Nodes.MacroValInfo> )
   {
      super( func, srcInfo.$declInfo, symbol2MacroValInfoMap );

      self.srcInfo = srcInfo;
   }
}


pub class MacroCtrl
{
   let mut useModuleMacroSet:Set<&Ast.TypeInfo> {pub&};
   /** マクロを展開する際にマクロを評価する MacroEval のオブジェクト */
   pri let macroEval: &Nodes.MacroEval;
   /** マクロの TypeId -> インポートしたマクロ情報。 */
   let mut typeId2ImportedMacroInfo: Map<&Ast.IdInfo,&Nodes.MacroInfo>;
   /** マクロの TypeId -> モジュール内で定義したマクロ情報. pub only。 */
   let declPubMacroInfoMap: Map<&Ast.IdInfo,&Nodes.MacroInfo> {pub&};
   /** マクロの TypeId -> モジュール内で定義したマクロ情報. not pub only */
   let declMacroInfoMap: Map<&Ast.IdInfo,DefMacroInfoWithSrc>;
   // /** declMacroInfoMap の登録ソース */
   // let declMacroInfoSrcMap: Map<&Ast.IdInfo,&DefMacroSrc>;
   
   /**
   * 現在展開中の macro-expand 内で利用できるシンボルと値の紐付けマップ。
   * macro-statment 内の stat の展開でも利用する。
   */
   pri let mut symbol2ValueMapForMacro: Map<str,Nodes.MacroValInfo>;
   /** マクロのモード */
   pri let mut analyzeInfo: MacroAnalyzeInfo {pub};
   pri let macroAnalyzeInfoStack: List<MacroAnalyzeInfo>;
   /** true の場合、Token 展開中 */
   pri let mut tokenExpanding:bool {pub};
   /** マクロをコールしている行番号 */
   pri let mut macroCallLineNo: &Parser.Position! {pub};
   /**
   * マクロ内で利用可能な、マクロ共通ローカルマップ。
   * マクロ横断で共通。
   */
   pri let mut macroLocalVarMap:Luaval<&stem>!;
   /** マクロ定義中の場合 true */
   pri let mut declaringType:&Ast.TypeInfo! {pub};

   pub fn get_isDeclaringMacro():bool {
      return self.declaringType ~= nil;
   }

   /** マクロの型→ __var へのアクセス有無 */
   pri let mut id2use___var:Map<&Ast.IdInfo,bool>;
   /** macroType で指定したマクロが __var を使用するかどうか */
   pub fn isUsing__var( macroType:&Ast.TypeInfo ) : bool {
      let typeId = macroType.$typeId;
      if self.typeId2ImportedMacroInfo[ typeId ] {
         return false;
      }
      if! self.id2use___var[ typeId ] {
         return _exp;
      }
      Util.err( "unknown macro -- %s" (macroType.getTxt(##)) ); // バグ
   }

   pub fn setUsing__var() mut {
      if! self.declaringType {
         self.id2use___var[ _exp.$typeId ] = true;
      }
   }

   /** _lnsLoad を使用している場合 true */
   let mut useLnsLoad:bool;

   let mut toLuavalLuaAsync:Luaval<toLuavalLuaFunc>!;

   // マクロ処理を非同期に行なう場合 true
   let validAsyncMacro:bool;


   pub fn __init( macroEval: &Nodes.MacroEval, validAsyncMacro:bool )
   {
      self.id2use___var = {};

      __asyncLock {
         // builtin マクロの情報を設定する
         foreach funcType in Builtin.getBuiltinFunc().$allFuncTypeSet {
            if funcType.$kind == .Macro {
               self.id2use___var[ funcType.$typeId ] = false;
            }
         }
      }
      
      
      self.validAsyncMacro = validAsyncMacro;
      self.toLuavalLuaAsync = nil;
      self.useLnsLoad = false;
      self.declMacroInfoMap = {};
      self.declPubMacroInfoMap = {};
      // self.declMacroInfoSrcMap = {};
      self.declaringType = nil;
      self.tokenExpanding = false;
      self.useModuleMacroSet = (@);
      self.typeId2ImportedMacroInfo = {};
      self.symbol2ValueMapForMacro = {};
      self.macroEval = macroEval;
      self.analyzeInfo = new MacroAnalyzeInfo( Ast.builtinTypeNone, .None );
      self.macroCallLineNo = nil;
      self.macroAnalyzeInfoStack = [ self.analyzeInfo ];

      self.macroLocalVarMap = nil;
   }

   pub fn clone() : MacroCtrl {
      let mut obj = new MacroCtrl( self.macroEval, self.validAsyncMacro );

      if not self.validAsyncMacro {
         obj.toLuavalLuaAsync = self.toLuavalLuaAsync;
      }
      obj.useLnsLoad = self.useLnsLoad;

      macro _cloneMap( dst:__exp, src:__exp ) {
         {}
         {
            foreach val, key in ,,src {
               ,,dst[ key ] = val;
            }
         }
      }

      obj.tokenExpanding = self.tokenExpanding;
      obj.useModuleMacroSet.or( self.useModuleMacroSet );
      _cloneMap( obj.typeId2ImportedMacroInfo, self.typeId2ImportedMacroInfo );
      // _cloneMap( obj.declMacroInfoSrcMap, self.declMacroInfoSrcMap );
      _cloneMap( obj.declPubMacroInfoMap, self.declPubMacroInfoMap );
      _cloneMap( obj.id2use___var, self.id2use___var );


      if self.validAsyncMacro {
         // マクロを同期実行する場合、
         // stmtFunc を非同期処理内で生成しなおす必要がある。
         foreach defInfo, key in self.declMacroInfoMap {
            let srcInfo = defInfo.$srcInfo;
            let stmtFunc:Luaval<Nodes.macroStatmentProc>!;
            // ここで stmtFunc を生成すると、
            // 使用しないマクロの stmtFunc を生成することになって無駄なので、
            // ここでは stmtFunc は nil で設定しておく。
            // マクロを使うタイミング(evalMacroOp)で stmtFunc を生成する。
            stmtFunc = nil;
            obj.declMacroInfoMap[ key ] = new DefMacroInfoWithSrc(
               stmtFunc, srcInfo, srcInfo.$symbol2MacroValInfoMap );
         }
      } else {
         // マクロを非同期実行しないのであれば、
         // stmtFunc をクローンせずにそのまま利用できるので、
         // declMacroInfoMap を単純にクローンする。
         _cloneMap( obj.declMacroInfoMap, self.declMacroInfoMap );
      }

      _cloneMap( obj.symbol2ValueMapForMacro, self.symbol2ValueMapForMacro );
      obj.analyzeInfo = self.analyzeInfo.clone();
      obj.macroCallLineNo = self.macroCallLineNo;
      foreach val in self.macroAnalyzeInfoStack {
         obj.macroAnalyzeInfoStack.insert( val );
      }
      
      return obj;
   }

   pub fn mergeFrom( macroCtrl:&MacroCtrl ) mut {
      self.useModuleMacroSet.or( macroCtrl.useModuleMacroSet );
   }

   pub fn setToUseLnsLoad() mut {
      if self.declaringType {
         self.useLnsLoad = true;
      }
   }
}

fn equalsType( typeInfo:&Ast.TypeInfo, builtinType:&Ast.TypeInfo ) : bool {
   return typeInfo.$srcTypeInfo == builtinType;
}

/**
指定マクロ macroTypeInfo を展開し、展開したマクロを Parse する Parser を返す。

@param streamName 現在のストリーム名
@param firstToken マクロを展開する場所
@param macroTypeInfo 展開するマクロの型
@param expList マクロに渡す引数
@return Parser.Parser! 展開したマクロの Parser。 失敗した場合 nil
@return str! マクロ展開に失敗した場合のエラーメッセージ
*/
pub fn MacroCtrl.evalMacroOp(
   moduleTypeInfo:&Ast.TypeInfo,
   streamName:str, firstToken: &Parser.Token, macroTypeInfo: &Ast.TypeInfo,
   expList: &Nodes.ExpListNode! ) mut: Parser.Parser!, str!
{
   self.useModuleMacroSet.add( macroTypeInfo.getModule() );

   when! expList {
      foreach exp in expList.$expList {
         let kind = exp.$kind;
         switch kind {
            case Nodes.NodeKind.$LiteralNil,
                 Nodes.NodeKind.$LiteralChar,
                 Nodes.NodeKind.$LiteralInt,
                 Nodes.NodeKind.$LiteralReal,
                 Nodes.NodeKind.$LiteralArray,
                 Nodes.NodeKind.$LiteralList,
                 Nodes.NodeKind.$LiteralMap,
                 Nodes.NodeKind.$LiteralString,
                 Nodes.NodeKind.$LiteralBool,
                 Nodes.NodeKind.$LiteralSymbol,
                 Nodes.NodeKind.$RefField,
                 Nodes.NodeKind.$ExpMacroStat,
                 Nodes.NodeKind.$ExpMacroArgExp,
                 Nodes.NodeKind.$ExpOmitEnum,
                 Nodes.NodeKind.$ExpCast,
                 Nodes.NodeKind.$ExpOp2
            {
            }
            default {
               let mess = "Macro arguments must be literal value. -- %d:%d:%s"
                   ( exp.$pos.lineNo, exp.$pos.column, 
                     Nodes.getNodeKindName(kind));
               return nil, mess;
            }
         }
      }
   }


   let macroInfo;
   if! self.typeId2ImportedMacroInfo[ macroTypeInfo.$typeId ] or
      self.declPubMacroInfoMap[ macroTypeInfo.$typeId ]
   {
      macroInfo = _exp;
   } else {
      if! self.declMacroInfoMap[ macroTypeInfo.$typeId ] {
         let mut defInfo = _exp;
         let srcInfo = defInfo.$srcInfo;
         if not defInfo.$func {
            if! let luaCode = srcInfo.$luaCode {
               // func が nil で、 luaCode が非 nil の場合、func を生成する。
               let stmtFunc = unwrap runLuaOnLnsToMacroProc(
                  luaCode, srcInfo.$baseDir, srcInfo.$asyncFlag );
               defInfo.set_func( stmtFunc );
            }
         }
         macroInfo = defInfo;
      } else {
         Util.err( "not found macroInfo -- %d" (macroTypeInfo.$typeId.$id) ); // バグ
      }
   }
   
   fn process() : str! {
      
      let mut argValMap:Map<int,&stem> = {};
      let macroArgNodeList = macroInfo.getArgList();

      // マクロ引数名 → 引数の Node
      let mut macroArgName2ArgNode:Map<str,&Nodes.Node> = {};

      let mut errmess:str! = nil;

      let innerMacro = macroTypeInfo.getModule() == moduleTypeInfo;

      // マクロの Lua VM 実行を非同期で行なうかどうか。
      // 内部宣言マクロで、外部公開してないマクロのみ非同期で行なう。
      // 外部公開マクロは、別のスレッドで実行できるように、
      // 標準 Lua VM 用に生成される。
      let asyncMacro =
         self.validAsyncMacro and innerMacro and
         not Ast.isPubToExternal( macroTypeInfo.$accessMode );

      // __var は、公開マクロにすると意味不明な動作になるので、
      // 非公開マクロに限定する。
      let valid__var =
         innerMacro and not Ast.isPubToExternal( macroTypeInfo.$accessMode );

      let toLuaval;
      if asyncMacro {
         // コンストラクタで生成すると、
         // 実行時とのスレッドが異なって 
         // luaval の処理が正常に動作しない可能性があるため、
         // nilable にして実行時時に生成する。
         let! work = self.toLuavalLuaAsync {
            work = loadCode( "return function( val ) return val end" )@@toLuavalLuaFunc;
            self.toLuavalLuaAsync = work;
         };
         toLuaval = work;
      } else {
         toLuaval = toLuavalNoasync;
      }

      let macroArgValMap:Map<str,Luaval<&stem>> = {};
      macro _callMacroState(block:__block) {
         if asyncMacro {
            //__luago {
            __luaDepend {
               ,,block;
            }
         } else {
            __luaLock {
               ,,block;
            }
         }
      }
      _callMacroState( {
         if! let func = macroInfo.$func {
            when! expList {
               // マクロに渡す引数をセットする
               foreach argNode, index in expList.$expList {
                  let declArgNode = macroArgNodeList[ index ];
                  macroArgName2ArgNode[ declArgNode.$name ] = argNode;
                  let literal, mess = argNode.getLiteral();
                  when! literal {
                     if! let val = getLiteralMacroVal( literal ) {
                        argValMap[ index ] = val;

                        let argVal;
                        if argNode.$expType == Ast.builtinTypeSymbol {
                           argVal = toLuaval( val[ 1 ] );
                        }
                        else {
                           argVal = toLuaval( val );
                        }
                        when! argVal {
                           macroArgValMap[ declArgNode.$name ] = argVal;
                        }
                     }
                  }
                  else {
                     errmess =
                     "not support node at arg(%d) -- %s:%s"
                     ( index, Nodes.getNodeKindName( argNode.$kind ), mess );
                     break;
                  }
               }
            }

            if not errmess {
               // マクロ内共通変数 __var の設定
               let! varMap = self.macroLocalVarMap {
                  let toListEmpty =
                     loadCode( "return function() return {} end" )@@toListEmptyLua;
                  varMap = toListEmpty();
               };
               if valid__var {
                  macroArgValMap[ "__var" ] = varMap;
               }

               // マクロの macro-statment を実行
               let mut macroVars = unwrap expandLuavalMap( func( macroArgValMap ) );

               // macroVars.__var に、 macro-statment 内で実行した結果が入ってくるので
               // self.macroLocalVarMap に入れなおす。
               if valid__var {
                  self.macroLocalVarMap = unwrap macroVars.__var;
               }

               // macro-statment の実行結果から、
               // symbol2ValueMapForMacro にシンボル名と値を紐付け。
               // macroVars.__names には、
               // macro-statment で定義された変数シンボル名が入る。
               // これは convLua の processDeclVar() でセットしている。
               foreach name in (unwrap macroVars.__names)@@Map<int,str> {
                  let! valInfo = macroInfo.$symbol2MacroValInfoMap[ name ] {
                     Util.err( "not found macro symbol -- %s" (name) ); // バグ
                  };
                  let typeInfo = valInfo.typeInfo;
                  // macro-statment で定義する変数は、
                  // expandLuavalMap 時に Lua の Table が Map として展開されるので、
                  // List ではなく Map で登録してやる。
                  let mut valMap:&stem;
                  if! let mut val = macroVars[ name ] {
                     if equalsType( typeInfo, Ast.builtinTypeSymbol ) {
                        valMap = { 1: val };
                     } else {
                        valMap = val;
                     }
                  } else {
                     valMap = {};
                  }
                  self.symbol2ValueMapForMacro[ name ] =
                     new Nodes.MacroValInfo( valMap, typeInfo, nil );
               }
            }
         } else {
            when! expList {
               foreach argNode, index in expList.$expList {
                  let declArgNode = macroArgNodeList[ index ];
                  macroArgName2ArgNode[ declArgNode.$name ] = argNode;
                  let literal, mess = argNode.getLiteral();
                  when! literal {
                     if! let val = getLiteralMacroVal( literal ) {
                        argValMap[ index ] = val;
                     }
                  }
                  else {
                     errmess =
                     "not support node at arg(%d) -- %s:%s"
                     ( index, Nodes.getNodeKindName( argNode.$kind ), mess );
                     break;
                  }
               }
            }
         }
      });
      when! errmess {
         return errmess;
      }

      foreach arg, index in macroInfo.getArgList() {
         if arg.$typeInfo.$kind ~= .DDD {
            let argType = arg.$typeInfo;
            let argName = arg.$name;
            self.symbol2ValueMapForMacro[ argName ] = new Nodes.MacroValInfo(
               argValMap[ index ], argType, macroArgName2ArgNode[ argName ] );
         }
         else {
            return "not support ... in macro";
         }
      }
      return nil;
   }

   if! let mess = process() {
      return nil, mess;
   }

   return new MacroParser(
      macroInfo.getTokenList(),
      "%s:%d:%d: (macro %s)" ( streamName, firstToken.pos.lineNo, firstToken.pos.column,
                               macroTypeInfo.getTxt(##)),
      firstToken.pos.$orgPos ), nil;
}


pub fn MacroCtrl.importMacro(
   processInfo:Ast.ProcessInfo, lnsPath:str, 
   macroInfoStem:&stem!, macroTypeInfo:&Ast.TypeInfo,
   typeId2TypeInfo: &Map<int,&Ast.TypeInfo>,
   importedMacroInfoMap:Map<&Ast.IdInfo,&Nodes.MacroInfo>, baseDir:str! ) __noasync mut
{
   let macroInfo, mut err;
   macroInfo, err = MacroMetaInfo._fromStem( macroInfoStem );
   when! macroInfo {
      let orgPos;
      if #macroInfo.pos == 2 {
         orgPos = new Types.Position(
            macroInfo.pos[ 1 ], macroInfo.pos[ 2 ], lnsPath ## );
      } else {
         Util.err( "macroInfo.pos is illegal" ); // バグ
      }
      let mut argList:List<&Nodes.MacroArgInfo> = [];
      let mut argNameList:List<str> = [];
      let mut symbol2MacroValInfoMap:Map<str,Nodes.MacroValInfo> = {};
      foreach argInfo in macroInfo.argList {
         let argTypeInfo = unwrap typeId2TypeInfo[ argInfo.typeId ];
         argList.insert( new Nodes.MacroArgInfo( argInfo.name, argTypeInfo ) );
         argNameList.insert( argInfo.name );
      }
      foreach symInfo in macroInfo.symList {
         let symTypeInfo = unwrap typeId2TypeInfo[ symInfo.typeId ];
         symbol2MacroValInfoMap[ symInfo.name ] =
            new Nodes.MacroValInfo( nil, symTypeInfo, nil );
      }

      let mut tokenList:List<&Parser.Token> = [];
      let mut lineNo = 0;
      let mut column = 1;
      foreach tokenInfo in macroInfo.tokenList {
         let txt = tokenInfo[2]@@str;
         if txt == "\n" {
            lineNo = lineNo + 1;
            column = 1;
         }
         else {
            let pos = Types.Position.create(
               lineNo, column, "macro:%s" (macroInfo.name), orgPos );
            tokenList.insert(
               new Parser.Token(
                  unwrap Parser.TokenKind._from( tokenInfo[1]@@int ),
                  txt, pos, false ## ) );
            column = column + #txt + 1;
         }
      }

      let luaCode = self.macroEval.evalFromCodeToLuaCode(
         processInfo, macroInfo.name, argNameList, macroInfo.stmtBlock );
      let stmtFunc;
      stmtFunc, err = runLuaOnLnsToMacroProc( luaCode, baseDir, false );
      when! stmtFunc {
         let mut extMacroInfo = new ExtMacroInfo(
            macroInfo.name, stmtFunc,
            symbol2MacroValInfoMap, argList, tokenList, baseDir );

         self.typeId2ImportedMacroInfo[ macroTypeInfo.$typeId ] = extMacroInfo;
         importedMacroInfoMap[ macroTypeInfo.$typeId ] = extMacroInfo;
         return;
      }
   }
   Util.errorLog( "macro load fail -- %s: %s "
                     (macroTypeInfo.getTxt(##), unwrap err default "") );
}

pub fn MacroCtrl.importMacroInfo(
   importedMacroInfoMap:&Map<&Ast.IdInfo,&Nodes.MacroInfo>) mut
{
   foreach macroInfo, typeId in importedMacroInfoMap {
      self.typeId2ImportedMacroInfo[ typeId ] = macroInfo;
   }
}


pub fn MacroCtrl.regist(
   processInfo:Ast.ProcessInfo, node:Nodes.DeclMacroNode,
   macroScope:&Ast.Scope, baseDir:str! ) mut : str!
{
   let luaCode:str!;
   let stmtFunc, mut err:str!;
   let asyncFlag =
      self.validAsyncMacro and not Ast.isPubToExternal( node.$expType.$accessMode );
   let ok;
   if node.$declInfo.$stmtBlock {
      let workCode = self.macroEval.evalToLuaCode( processInfo, node );
      luaCode = workCode;
      stmtFunc, err = runLuaOnLnsToMacroProc( workCode, baseDir, asyncFlag );
      if stmtFunc {
         ok = true;
         err = nil;
      } else {
         ok = false;
      }
   } else {
      ok = true;
      stmtFunc, err = nil, nil;
      luaCode = nil;
   }


   if ok {
      // registVar() した時に確定していない変数の型を、ここで確定する。
      let remap:Map<str,Nodes.MacroValInfo> = {};
      foreach macroValInfo, name in self.symbol2ValueMapForMacro {
         if equalsType( macroValInfo.typeInfo, Ast.builtinTypeEmpty ) {
            if! let typeInfo = macroScope.getTypeInfoChild( name ) {
               remap[ name ] = new Nodes.MacroValInfo(
                  macroValInfo.val, typeInfo, macroValInfo.argNode );
            } else {
               remap[ name ] = macroValInfo;
            }
         } else {
            remap[ name ] = macroValInfo;
         }
      }

      // マクロ情報を登録
      let srcInfo = new DefMacroSrc(
         luaCode, node.$declInfo, remap, baseDir, asyncFlag );
      let mut macroInfo = new DefMacroInfoWithSrc( stmtFunc, srcInfo, remap );
      if Ast.isPubToExternal( node.$expType.$accessMode ) {
         self.declPubMacroInfoMap[ node.$expType.$typeId ] = macroInfo;
      } else {
         self.declMacroInfoMap[ node.$expType.$typeId ] = macroInfo;
      }
   }



   if not self.id2use___var[ node.$expType.$typeId ] {
      self.id2use___var[ node.$expType.$typeId ] = false;
   }
   
   self.symbol2ValueMapForMacro = {};
   self.declaringType = nil;

   
   return err;
}

fn expandVal( tokenList:List<&Parser.Token>,
              workval: Luaval<&stem>!, pos: &Parser.Position ): str!
{
   when! workval {
      let val = workval@@stem;
      switch type( val ) {
         case "boolean" {
            let token = "%s" (val);
            let kind = Parser.TokenKind.Kywd;
            tokenList.insert( new Parser.Token( kind, token, pos, false ## ) );
         }
         case "number" {
            let num = "%g" (val@@real);
            let mut kind = Parser.TokenKind.Int;
            if string.find( num, ".", 1, true ) {
               kind = Parser.TokenKind.Real;
            }
            tokenList.insert( new Parser.Token( kind, num, pos, false ## ) );
         }
         case "string" {
            tokenList.insert(
               new Parser.Token(
                  Parser.TokenKind.Str,
                  //'%q' (val@@str),
                  Parser.quoteStr( val@@str ),
                  pos, false ## ) );
            // val 中に \n 等の制御コードが入ると正常に処理されない。
            // val 内の制御コードを \xXX に変換する必要がある。
         }
         default {
            return "not support ,, List -- %s" ( type( val ) );
         }
      }
   }
   return nil;
}

/**
txtList の文字列リストを parse して、
pushbackParser に pushback する。

@param pushbackParser PushbackParser
@param txtList 文字列リスト
@param streamName ストリーム名
@param pos parse したトークンの位置情報に置き換える値
*/
fn pushbackTxt( pushbackParser:Parser.PushbackParser,
                txtList:&List<str>, streamName:str, pos:&Parser.Position )
{
   let mut tokenList:List<&Parser.Token> = [];
   foreach txt in txtList {
      let mut parser = Parser.StreamParser.create(
         Types.ParserSrc.LnsCode(
            txt, "macro symbol -- %s" (streamName), nil ), false, nil, pos.$RawOrgPos );
      let mut workParser = new Parser.DefaultPushbackParser( parser );
      while true {
         let worktoken = workParser.getTokenNoErr(##);
         if worktoken.kind == .Eof {
            break;
         }
         tokenList.insert( new Parser.Token(
            worktoken.kind, worktoken.txt, pos, false ## ) );
      }
   }
   for index = #tokenList, 1, -1 {
      pushbackParser.pushbackToken( tokenList[ index ] );
   }
}


/**
macro-expand 内のトークン処理。

,, や ,,,の展開を行なう。

*/
pub fn MacroCtrl.expandMacroVal(
   typeNameCtrl:&Ast.TypeNameCtrl, scope:&Ast.Scope,
   parser:Parser.PushbackParser, mut token:&Parser.Token ) mut : &Parser.Token
{
   if self.tokenExpanding {
      return token;
   }

   fn getToken() __trans : &Parser.Token {
      self.tokenExpanding = true;
      let work = parser.getTokenNoErr(##);
      self.tokenExpanding = false;
      return work;
   }
   
   fn macroVal2strList( name:str, macroVal: &Nodes.MacroValInfo ) : &List<str> {
      let! val = macroVal.val {
         Util.err( "macroVal is nil -- %s" (name) ); // バグ
      };
      if macroVal.argNode {
         // マクロ引数の場合、そのまま List<str> にキャスト
         return val@@List<str>;
      }
      let list:List<str> = [];
      forsort item in val@@Map<int,str> {
         list.insert( item );
      }
      return list;
   }

   
   let tokenTxt = token.txt;

   
   if tokenTxt == ',,' or tokenTxt == ',,,' or tokenTxt == ',,,,' {
      let mut nextToken = getToken();

      let! macroVal = self.symbol2ValueMapForMacro[ nextToken.txt ] {
         Util.err( "unknown macro val -- %s" (nextToken.txt) ); // 要対応
      };

      if tokenTxt == ',,' {
         //Util.errorLog( "nextToken: %s" ( nextToken.txt ) );
         if equalsType( macroVal.typeInfo, Ast.builtinTypeSymbol ) {
            let mut txtList:List<str> = [];
            foreach txt in macroVal2strList( nextToken.txt, macroVal ) {
               txtList.insert( txt );
            }
            pushbackTxt( parser, txtList, nextToken.txt, nextToken.pos ); 
         }
         elseif equalsType( macroVal.typeInfo, Ast.builtinTypeStat ) or
            equalsType( macroVal.typeInfo, Ast.builtinTypeBlockArg )
         {
            let pos = macroVal.argNode$.$pos$.$RawOrgPos or
               nextToken.pos.$RawOrgPos or token.$pos.$orgPos;
            let txt = unwrap macroVal.val default "";
            parser.pushbackStr( nil, "macroVal %s" (nextToken.txt), txt@@str, pos );
         }
         elseif equalsType( macroVal.typeInfo, Ast.builtinTypeExp ) or
            equalsType( macroVal.typeInfo, Ast.builtinTypeMultiExp )
         {
            let pos = macroVal.argNode$.$pos$.$RawOrgPos or
               nextToken.pos.$RawOrgPos or token.$pos.$orgPos;
            let txt = unwrap macroVal.val default "nil";
            parser.pushbackStr( nil, "macroVal %s" (nextToken.txt), txt@@str, pos );
         }
         elseif macroVal.typeInfo.$kind == .Array or
            macroVal.typeInfo.get_kind() == .List
         {
            if equalsType( macroVal.typeInfo.$itemTypeInfoList[ 1 ],
                           Ast.builtinTypeStat )
            {
               let pos = macroVal.argNode$.$pos$.$RawOrgPos or
                  nextToken.pos.$RawOrgPos or token.$pos.$orgPos;
               let strList = macroVal2strList( nextToken.txt, macroVal );
               for index = #strList, 1, -1 {
                  parser.pushbackStr(
                     nil, "macroVal %s[%d]" (nextToken.txt, index),
                     strList[ index ], pos );
               }
            }
            else {
               let mut tokenList: List<&Parser.Token> = [];

               if! let argNode = macroVal.argNode {
                  if not argNode.setupLiteralTokenList( tokenList ) {
                     Util.err( "illegal macro val ,, -- %s" (nextToken.txt) ); // 要対応
                  }
               }
               else {
                  Util.err( "not support ,, -- %s" (nextToken.txt) ); // 要対応
               }

               parser.newPushback( tokenList );
            }
         }
         elseif macroVal.typeInfo.get_kind() == .Enum {
            let enumTypeInfo = unwrap macroVal.typeInfo.$aliasSrc@@@Ast.EnumTypeInfo;
            let fullname = macroVal.typeInfo.getFullName( typeNameCtrl, scope, true );
            // let mut nameList:List<str> = [];
            // apply name of fullname.gmatch( "[^%.]+" ) {
            //    nameList.insert( name );
            // }
            let nameList = Util.splitStr( fullname, "[^%.]+" );
            let enumValInfo = unwrap enumTypeInfo.$val2EnumValInfo[ unwrap macroVal.val ];
            nextToken = new Parser.Token(
               .Symb, enumValInfo.$name, nextToken.pos, false ## );
            parser.pushbackToken( nextToken );
            for index = #nameList, 1, -1 {
               nextToken = new Parser.Token( .Dlmt, ".", nextToken.pos, false ## );
               parser.pushbackToken( nextToken );
               nextToken = new Parser.Token(
                  .Symb, nameList[ index ], nextToken.pos, false ## );
               parser.pushbackToken( nextToken );
            }
         }
         else {
            let mut tokenList: List<&Parser.Token> = [];

            if! let argNode = macroVal.argNode {
               if not argNode.setupLiteralTokenList( tokenList ) {
                  Util.err( "illegal macro val ,, -- %s" (nextToken.txt) ); // 要対応
               }
            }
            else {
               expandVal( tokenList, macroVal.val, nextToken.pos );
            }

            parser.newPushback( tokenList );
         }
      }
      elseif tokenTxt == ',,,' {
         if equalsType( macroVal.typeInfo, Ast.builtinTypeString ) {
            pushbackTxt( parser, [ (unwrap macroVal.val)@@str ],
                         nextToken.txt, nextToken.pos );
         }
         else {
            Util.err( "',,,' does not support this type -- %s" // 要対応
                      (macroVal.typeInfo.getTxt(##)) );
         }
      }
      elseif tokenTxt == ',,,,' {
         if equalsType( macroVal.typeInfo, Ast.builtinTypeSymbol ) {
            let txtList = (unwrap macroVal.val)@@str[];
            let mut newToken = "";
            foreach txt in txtList {
               newToken = "%s%s" (newToken, txt);
            }
            nextToken = new Parser.Token(
               Parser.TokenKind.Str, "'%s'" (newToken), nextToken.pos, false ## );
            parser.pushbackToken( nextToken );
         }
         elseif equalsType( macroVal.typeInfo, Ast.builtinTypeStat ) or
            equalsType( macroVal.typeInfo, Ast.builtinTypeExp ) or
            equalsType( macroVal.typeInfo, Ast.builtinTypeMultiExp ) or
            equalsType( macroVal.typeInfo, Ast.builtinTypeBlockArg ) 
         {
            let txt = (unwrap macroVal.val)@@str;
            let rawTxt;
            if txt.find( "^```"## ) {
               //rawTxt = "%q" (txt);
               rawTxt = Parser.quoteStr( txt );
            }
            else {
               //rawTxt = "%q" (txt);
               rawTxt = Parser.quoteStr( txt );
            }
            nextToken = new Parser.Token(
               Parser.TokenKind.Str, rawTxt, nextToken.pos, false ##);
            parser.pushbackToken( nextToken );
         }
         else {
            Util.err( "not support this symbol -- %s%s" // 要対応
                      (tokenTxt, nextToken.txt) );
         }
      }
      nextToken = getToken();

      token = nextToken;
   }

   self.tokenExpanding = false;

   return token;
}

pub class ErrorMess {
   pub let pos:Parser.Position;
   pub let mess:str;
}

pub fn MacroCtrl.expandSymbol(
   parser:Parser.PushbackParser, inTestBlock:bool, prefixToken:&Parser.Token,
   mut exp:&Nodes.Node, nodeManager:Nodes.NodeManager,
   errMessList:List<&ErrorMess>) mut : &Nodes.LiteralStringNode
{
   let nextToken = parser.getTokenNoErr(##);
   if nextToken.txt ~= "~~" {
      parser.pushbackToken( nextToken );
   }
   
   let mut format = prefixToken.txt == ",,," and "' %s '" or '"\'%s\'"';

   if prefixToken.txt == ",," {
      if! let refNode = exp@@@Nodes.ExpRefNode {
         let symbolInfo = refNode.$symbolInfo;
         let macroInfo = self.symbol2ValueMapForMacro[ symbolInfo.$name ];
         when! macroInfo {
            let valType = macroInfo.typeInfo;
            if equalsType( valType, Ast.builtinTypeSymbol ) or
               equalsType( valType, Ast.builtinTypeExp ) or
               equalsType( valType, Ast.builtinTypeMultiExp ) or
               equalsType( valType, Ast.builtinTypeBlockArg ) or
               equalsType( valType, Ast.builtinTypeStat )
            {
               format = "' %s '";
            }
            elseif valType.$kind == .List and
               equalsType( valType.$itemTypeInfoList[1], Ast.builtinTypeStat )
            {
               format = "' %s '";
               exp = Nodes.ExpMacroStatListNode.create(
                  nodeManager, prefixToken.pos, inTestBlock,
                  self.analyzeInfo.$mode == .AnalyzeArg, [ Ast.builtinTypeString ], exp );
            }
            elseif equalsType( Ast.builtinTypeString, valType ) {
               //
            }
            elseif equalsType( valType, Ast.builtinTypeInt ) or
               equalsType( valType, Ast.builtinTypeReal )
            {
               format = "' %s' ";
            }
            else {
               errMessList.insert(
                  new ErrorMess( unwrap symbolInfo.$pos,
                                 "not support ,, -- %s" (valType.getTxt(##)) ) );
            }
         }
         else {
            if equalsType( exp.$expType, Ast.builtinTypeInt ) or
               equalsType( exp.$expType, Ast.builtinTypeReal )
            {
               format = "' %s' ";
            }
            elseif equalsType( exp.$expType, Ast.builtinTypeSymbol ) or
               equalsType( exp.$expType, Ast.builtinTypeExp ) or
               equalsType( exp.$expType, Ast.builtinTypeMultiExp ) or
               equalsType( exp.$expType, Ast.builtinTypeBlockArg ) or
               equalsType( exp.$expType, Ast.builtinTypeStat )
            {
               format = "' %s '";
            }
         }
      }
   }
   let newToken = new Parser.Token(
      Parser.TokenKind.Str, format, prefixToken.pos, prefixToken.consecutive ## );

   let expListNode = Nodes.ExpListNode.create(
      nodeManager, exp.$pos, inTestBlock,
      self.analyzeInfo.$mode == .AnalyzeArg,
      exp.$expTypeList, [ exp ], nil, false );
   let dddNode = Nodes.ExpToDDDNode.create(
      nodeManager, exp.$pos, inTestBlock,
      self.analyzeInfo.$mode == .AnalyzeArg,
         exp.$expTypeList, expListNode );
   
   let literalStr = Nodes.LiteralStringNode.create(
      nodeManager, prefixToken.pos, inTestBlock,
      self.analyzeInfo.$mode == .AnalyzeArg,
      [ Ast.builtinTypeString ], newToken,
      expListNode,
      Nodes.ExpListNode.create(
         nodeManager, exp.$pos, inTestBlock,
         self.analyzeInfo.$mode == .AnalyzeArg,
         exp.$expTypeList, [ dddNode ], nil, false ) );
   return literalStr;
}

/**
macro-statment 内で定義している変数を登録する。

このときはまだ変数宣言しているだけなので、
実際の値はマクロ展開時にセットする。

変数の型

@param symbolList 変数一覧
*/
pub fn MacroCtrl.registVar( symbolList:&List<&Ast.SymbolInfo> ) mut
{
   foreach symbolInfo in symbolList {
      let mut info = new Nodes.MacroValInfo( nil, symbolInfo.$typeInfo, nil);
      self.symbol2ValueMapForMacro[ symbolInfo.$name ] = info;
   }
}

pub fn MacroCtrl.startDecl( declaringType:&Ast.TypeInfo ) mut {
   self.symbol2ValueMapForMacro = {};
   self.declaringType = declaringType;   
   self.useLnsLoad = false;
}

pub form EvalMacroCallback() __trans;

pub fn MacroCtrl.finishMacroMode() mut {
   self.macroAnalyzeInfoStack.remove(##);
   self.analyzeInfo = self.macroAnalyzeInfoStack[ #self.macroAnalyzeInfoStack ];
}


pub fn MacroCtrl.startExpandMode(
   pos:&Parser.Position, typeInfo:&Ast.TypeInfo, callback:EvalMacroCallback ) mut
{
   self.analyzeInfo = new MacroAnalyzeInfo( typeInfo, .Expand );
   self.macroCallLineNo = pos;
   self.macroAnalyzeInfoStack.insert( self.analyzeInfo );

   callback();

   self.finishMacroMode();
}

pub fn MacroCtrl.startAnalyzeArgMode( macroFuncType:&Ast.TypeInfo ) mut {
   self.analyzeInfo = new MacroAnalyzeInfo( macroFuncType, .AnalyzeArg );
   self.macroAnalyzeInfoStack.insert( self.analyzeInfo );
}

pub fn MacroCtrl.switchMacroMode() mut {
   self.analyzeInfo = self.macroAnalyzeInfoStack[ #self.macroAnalyzeInfoStack - 1 ];
   self.macroAnalyzeInfoStack.insert( self.analyzeInfo );
}

pub fn MacroCtrl.restoreMacroMode() mut {
   self.macroAnalyzeInfoStack.remove(##);
   self.analyzeInfo = self.macroAnalyzeInfoStack[ #self.macroAnalyzeInfoStack ];
}

pub fn MacroCtrl.isInMode( mode:Nodes.MacroMode ): bool {
   if #self.macroAnalyzeInfoStack == 0 {
      return false;
   }
   foreach info in self.macroAnalyzeInfoStack {
      if info.$mode == mode {
         return true;
      }
   }
   return false;
}

/**
現在の Macroモード が AnalyzeArg か調べる。
Macroモード がネストされている場合、ネストを辿って調べる。
*/
pub fn MacroCtrl.isInAnalyzeArgMode(): bool {
   return self.isInMode( .AnalyzeArg );
}

/**
現在の Macroモード が Expand か調べる。
Macroモード がネストされている場合、ネストを辿って調べる。
*/
pub fn MacroCtrl.isInExpandMode(): bool {
   return self.isInMode( .Expand );
}


/**
マクロ用にノードを展開する。

@param node 展開する Node
@param moduleTypeInfo 現在のモジュールタイプ
@return str 展開後の Lns コード
*/
pub fn nodeToCodeTxt(node:&Nodes.Node, moduleTypeInfo:&Ast.TypeInfo ) :str
{
   let code;
   let mut memStream = new Util.memStream();
   let mut formatter = Formatter.createFilter( moduleTypeInfo, memStream, true );

   node.processFilter( formatter, new Formatter.Opt( node ) );
   
   code = memStream.$txt;
   return code;
}

__test case1(ctrl) {
}

