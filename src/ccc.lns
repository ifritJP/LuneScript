macro _section()
{
   print( "-----", __line__,  "-----" );
}
let mut g_val = 100;

// {
//    _section();
//    class Test {
//       fn bar() {
//          print( "hoge" );
//       }
//       pub fn func() {
//          fn sub() {
//             self.bar();
//          }
//          fn foo() {
//             sub();
//          }
//          foo();
//       }
//    }
//    let test = new Test();
//    test.func();   
// }
// {
//    _section();
//    form funcType( val:stem! );

//    let mut work:funcType! = nil;
//    {
//       let func = fn ( val:stem! ) {
//          when! val {
//             work = val@@funcType;
//          }
//          print( work and "has" );
//       };
//       func( func );
//    }
//    work$(nil);
// }

class SuperS {
   let val:int! {pub};
   pub fn __init() {
   }
   
   static let val2:int! {pub};
   static let val3:int {pub};
   __init {
      SuperS.val3 = 1;
   }
}
{
   _section();
   let hoge = new SuperS();
   if! let val = hoge.$val {
      print( val + 10 );
   }
   else {
      print( "OK" );
   }
   if! let val = SuperS.$val2 {
      print( val + 100 );
   }
   else {
      print( "OK" );
   }
}
{
   _section();
   fn func(txt:str!): str! {
      let val = txt and "abc" or nil;
      return val;
   }
   let mut work:str! = nil;
   repeat {
      let val = func( work );
      work = val or "1";
   } val;
   print( work );
}
{
   _section();
   fn func( val:int! ) {
      fn process() {
         when! val {
            print( "nonnil" );
         }
         else {
            print( "nil" );
         }
      }
      process();
      print( val );
   }
   func( 1 );
   func( nil );
}
{
   _section();
   enum Val {
      Val1,
      Val2,
   }
   fn func( val:Val ) {
      fn process() {
         if val == .Val1 {
            print( "match" );
         }
         else {
            print( "unmatch" );
         }
      }
      process();
      print( val );
   }
   func( .Val1 );
   func( .Val2 );
}
{
   _section();
   class Hoge {
      let val:str! {pub};
   }
   fn func(): str {
      return "hoge";
   }
   class Sub extend Hoge {
      pub fn __init() {
         super( func() );
      }
   }
   let sub = new Sub();
   print( sub.$val );
}
{
   _section();
   class Hoge {
      let val:str;
      pub fn get_val(): str {
         return self.val;
      }
   }
   class Sub extend Hoge {
   }
   class Test extend Hoge {
      let sub:Sub;

      advertise sub;
   }
   class Test2 extend Sub {
      let sub:Sub;

      advertise sub;
   }

   {
      let test = new Test( "xyz", new Sub( "abc" ) );
      print( test.$val );
   }
   {
      let test2 = new Test2( "XYZ", new Sub( "ABC" ) );
      print( test2.$val );
   }
}
{
   _section();
   class Hoge {
      let txt:str;
      pub fn get_val(): int {
         return 0;
      }
   }
   pub fn Hoge.func(): str {
      return self.txt;
   }

   class Sub extend Hoge {
   }

   class Test extend Hoge {
      let sub:Sub;

      advertise sub;
   }

   class Test2 extend Hoge {
      let sub:Sub;

      advertise sub;
   }

   {
      let test = new Test( "xyz", new Sub( "abc" ) );
      print( test.func() );
   }
   {
      let test2 = new Test2( "XYZ", new Sub( "ABC" ) );
      print( test2.func() );
   }
}
{
   _section();
   class Hoge {
      pub fn get_val(): int {
         return 0;
      }
   }

   class Test {
      let val:int {pub};
      let hoge:Hoge;

      advertise hoge;
   }

   let test = new Test( 10, new Hoge() );
   print( test.$val );
}
{
   _section();
   fn func( val1:int ) : int!, str {
      if val1 == 1 {
         return nil, "abc";
      }
      return 1, "xyz";
   }
   fn sub(val:int) {
      let! val1, val2 = func( val ) {
         print( _val1, _val2 );
         return;
      };
      print( val1, val2 );
   }
   sub(0);
   sub(1);
}
{
   _section();
   class Test {
      let val:int {pub};
      let val2:real {pub};
      let val3:bool {pub};
      let val4:str {pub};
      let val5:int! {pub};
      pub fn func() {
         print( "hoge" );
      }
   }
   fn func( test:Test! ) {
      print( test$.$val, test$.$val2, test$.$val3, test$.$val4, test$.$val5 );
      test$.func$();
   }
   func( new Test( 1, 2.5, true, "abc", 10 ) );
   func( nil );
}
{
   _section();
   for index = 1, 5 {
      print( index );
   }
   for index = 5, 1, -1 {
      print( index );
   }
}
{
   _section();
   let json = {
      "lv1": {
         "lv2": {
            "lv3": [
               1  
            ]
         }
      }
   };
   print( unwrap json.lv1$.lv2$.lv3$[ 1 ] + 10 );
}
{
   _section();
   macro _declFunc(num:int, memType:str ) {
      {
         let funcName = "func%d" (num);
         let valName = "val%d" (num);
         let typeName = `{ ,,,memType };
      }
      pub fn ,,,funcName():,,typeName {
         return self.,,,valName;
      }
   }
   class Test {
      pub let val1:int;
      pub let val2:real;
      pub let val3:bool;
      pub let val4:str;
      pub let val5:int!;
      pub let val6:str!;
      _declFunc( 1, "int" );
      _declFunc( 2, "real" );
      _declFunc( 3, "bool" );
      _declFunc( 4, "str" );
      _declFunc( 5, "int!" );
      _declFunc( 6, "str!" );
      pub fn func():int, real, bool, str, int!, str! {
         return self.val1, self.val2, self.val3, self.val4, self.val5, self.val6;
      }
   }
   fn func( test:Test! ) {
      print( (unwrap test$.func1$() default 100) + 2 );
      print( (unwrap test$.func2$() default 100.0) + 2.0 );
      print( unwrap test$.func3$() default false );
      print( (unwrap test$.func4$() default "yyy") .. "YY" );
      print( (unwrap test$.func5$() default 1000) + 2 );
      print( (unwrap test$.func6$() default "zzz") .. "ZZ" );
      print( (unwrap test$.func$() default 100) + 2 );
   }
   func( nil );
   func( new Test( 10, 20.5, true, "abc", 100, "xyz" ) );
}
{
   _section();
   fn func1() {
      let val = "str";
      while true {
         {
            {
               print( __line__ );
               break;
            }
         }
      }
   }
   fn func2() {
      let val = "str";
      while true {
         {
            print( __line__ );
            break;
         }
      }
   }
   fn func3() {
      let val = "str";
      while true {
         print( __line__ );
         break;
      }
   }
   func1();
   func2();
   func3();
}
{
   _section();
   class Test extend (Mapping) {
      let list:List<List<List<int>>> {pub};
   }
   let test = new Test([[[1,2],[3,4]]] );
   let map = test._toMap();
   let test2 = unwrap Test._fromMap( map );
   foreach list in test2.$list {
      foreach list2 in list {
         foreach val in list2 {
            print( val );
         }
      }
   }
}
{
   _section();
   class Hoge extend (Mapping) {
      let val:str {pub};
   }
   class Test extend (Mapping) {
      let map1:Map<int,int> {pub};
      let map2:Map<real,real> {pub};
      let map3:Map<str,str> {pub};
      let map4:Map<bool,bool> {pub};
      let map5:Map<int,stem> {pub};
      let map6:Map<int,Hoge> {pub};
   }
   class Sub extend (Mapping) {
      let test:Test {pub};
   }
   let test = new Test( { 1: 2 }, { 1.5: 2.5}, { "abc": "xyz" },
                        { true: false }, { 1: "abc" },
                        { 10:new Hoge( "hoge1" ), 20:new Hoge( "hoge2" ) } );
   let sub = new Sub( test );
   let map = sub._toMap();
   let sub2 = unwrap Sub._fromMap( map );
   let test2 = sub2.$test;

   macro _dumpSeq( seq:__exp ) {
      {}
      {
         let mut workMap:Map<str,&stem> = {};
         foreach val, key in ,,seq {
            workMap[ "%s" ( key ) ] = val;
         }
         forsort val, key in workMap {
            print( key, val );
         }
      }
   }

   macro _dumpSeq2( seq:__exp ) {
      {}
      {
         forsort hoge, key in ,,seq {
            print( key, hoge.$val );
         }
      }
   }
   
   
   _dumpSeq( test2.$map1 );
   _dumpSeq( test2.$map2 );
   _dumpSeq( test2.$map3 );
   _dumpSeq( test2.$map4 );
   _dumpSeq( test2.$map5 );
   _dumpSeq2( test2.$map6 );

   print( Test._fromMap( {} )** );
   print( Test._fromMap( { "map1": {} } )** );
   print( Test._fromMap( { "map1": { 1:1 } } )** );
   print( Test._fromMap( { "map1": {}, "map2": {}, "map3": {},
                           "map4": {}, "map5": {} } )** );
}
{
   _section();
   class Hoge extend (Mapping) {
      let val:str {pub};
   }
   class Test extend (Mapping) {
      let list1:List<int> {pub};
      let list2:List<real> {pub};
      let list3:List<str> {pub};
      let list4:List<bool> {pub};
      let list5:List<stem> {pub};
      let list6:List<Hoge> {pub};
   }
   class Sub extend (Mapping) {
      let test:Test {pub};
   }
   let test = new Test( [ 1, 2, 3 ], [ 1.5, 2.5], [ "abc", "xyz" ],
                        [ true, false ], [ 1, "abc" ],
                        [ new Hoge( "hoge1" ), new Hoge( "hoge2" ) ] );
   let sub = new Sub( test );
   let map = sub._toMap();
   let sub2 = unwrap Sub._fromMap( map );
   let test2 = sub2.$test;

   macro _dumpSeq( seq:__exp ) {
      {}
      {
         let mut workMap:Map<str,&stem> = {};
         foreach val in ,,seq {
            workMap[ "%s" ( val ) ] = val;
         }
         forsort val in workMap {
            print( val );
         }
      }
   }

   macro _dumpSeq2( seq:__exp ) {
      {}
      {
         let mut workMap:Map<str,&Hoge> = {};
         foreach hoge in ,,seq {
            workMap[ "%s" ( hoge.$val ) ] = hoge;
         }
         forsort hoge in workMap {
            print( hoge.$val );
         }
      }
   }
   
   
   _dumpSeq( test2.$list1 );
   _dumpSeq( test2.$list2 );
   _dumpSeq( test2.$list3 );
   _dumpSeq( test2.$list4 );
   _dumpSeq( test2.$list5 );
   _dumpSeq2( test2.$list6 );

   print( Test._fromMap( {} )** );
   print( Test._fromMap( { "list1": [] } )** );
   print( Test._fromMap( { "list1": [ "str" ] } )** );
   print( Test._fromMap( { "list1": [], "list2": [], "list3": [],
                           "list4": [], "list5": [] } )** );
}
{
   _section();
   class Hoge extend (Mapping) {
      let val:str {pub};
   }
   class Test extend (Mapping) {
      let set1:Set<int> {pub};
      let set2:Set<real> {pub};
      let set3:Set<str> {pub};
      let set4:Set<bool> {pub};
      let set5:Set<stem> {pub};
      let set6:Set<Hoge> {pub};
   }
   class Sub extend (Mapping) {
      let test:Test {pub};
   }
   let test = new Test( (@ 1, 2, 3 ), (@ 1.5, 2.5), (@ "abc", "xyz" ),
                        (@ true, false ), (@ 1, "abc" ),
                        (@ new Hoge( "hoge1" ), new Hoge( "hoge2" ) ) );
   let sub = new Sub( test );
   let map = sub._toMap();
   let sub2 = unwrap Sub._fromMap( map );
   let test2 = sub2.$test;

   macro _dumpSeq( seq:__exp ) {
      {}
      {
         let mut workMap:Map<str,&stem> = {};
         foreach val in ,,seq {
            workMap[ "%s" ( val ) ] = val;
         }
         forsort val in workMap {
            print( val );
         }
      }
   }

   macro _dumpSeq2( seq:__exp ) {
      {}
      {
         let mut workMap:Map<str,&Hoge> = {};
         foreach hoge in ,,seq {
            workMap[ "%s" ( hoge.$val ) ] = hoge;
         }
         forsort hoge in workMap {
            print( hoge.$val );
         }
      }
   }
   
   
   _dumpSeq( test2.$set1 );
   _dumpSeq( test2.$set2 );
   _dumpSeq( test2.$set3 );
   _dumpSeq( test2.$set4 );
   _dumpSeq( test2.$set5 );
   _dumpSeq2( test2.$set6 );

   print( Test._fromMap( {} )** );
   print( Test._fromMap( { "set1": (@) } )** );
   print( Test._fromMap( { "set1": (@ "str" ) } )** );
   print( Test._fromMap( { "set1": (@), "set2": (@), "set3": (@),
                           "set4": (@), "set5": (@) } )** );
}


{
   _section();
   class Sub extend (Mapping) {
      let val1:int {pub};
      let val2:str {pub};
   }
   class Test extend (Mapping){
      let val3:Sub {pub};
   }
   let test = new Test( new Sub( 1, "abc" ) );
   let map = test._toMap();
   print( (unwrap map.val3).val1, (unwrap map.val3).val2 ); // 1 abc
   let test_2;
   {
      test_2 = unwrap Test._fromMap( map );
   }
   print( test_2.$val3.$val1, test_2.$val3.$val2 ); // 1 abc
   print( Test._fromMap( {} )** );
   print( Test._fromMap( { "val3": {} } )** );
}

{
   _section();
   class Sub extend (Mapping) {
      let val1:int {pub};
      let val2:str! {pub};
   }
   class Test extend (Mapping){
      let val3:Sub {pub};
   }
   let test = new Test( new Sub( 1, nil ) );
   let map = test._toMap();
   print( (unwrap map.val3).val1, (unwrap map.val3).val2 ); // 1 abc
   let test_2;
   {
      test_2 = unwrap Test._fromMap( map );
   }
   print( test_2.$val3.$val1, test_2.$val3.$val2 ); // 1 abc
   print( Test._fromMap( {} )** );
   print( Test._fromMap( { "val3": {} } )** );
}
{
   _section();
   class Test extend (Mapping) {
      let val1:int {pub};
      let val2:real {pub};
      let val3:bool {pub};
      let val4:str {pub};
   }
   let test = new Test( 1, 2.0, true, "abc" );
}
{
   _section();
   class SuperSuper {
      pub fn func( val:int ):int {
         return 1 + val;
      }
   }

   class Super extend SuperSuper {
   }

   class Test extend Super {
      pub override fn func( val:int ): int {
         return super( val );
      }
   }
   let test = new Test();
   print( test.func( 10 ) );
}
{
   _section();
   fn func(): ...<int> {
      return 1, 2, 3;
   }
   fn sub2( val1:int!, ... ) {
      print( val1, ... );
   }
   fn sub3( ... ) {
      print( ... );
   }
   sub2( func()** );
   sub3( func()** );
}
{
   _section();
   interface IF {
      pub fn func():str;
   }
   class Super {
   }
   class Test extend Super (IF) {
      pub fn func() : str {
         return "hoge";
      }
   }

   fn func( val:stem ) {
      if! val@@@int {
         print( "int:%d" ( _exp ) );
      }
      if! val@@@real {
         print( "real:%g" ( _exp ) );
      }
      if! val@@@str {
         print( "str:%s" ( _exp ) );
      }
      if! val@@@Test {
         print( "class", _exp.func() );
      }
      if! val@@@IF {
         print( "IF", _exp.func() );
      }
   }
   func( 1 );
   func( 1.0 );
   func( "abc" );
   func( new Test() );
   func( new Test() );
   func( new Super() );
}
{
   _section();
   fn func( val:int! ) {
      let! mut work = val { return; };
      print( work );
   }
   func( 1 );
   func( nil );
}
{
   _section();
   fn func( val:stem! ) {
      switch val {
         case 1, "abc" {
            print( "hoge" );
         }
         case 2.0, nil {
            print( "foo" );
         }
         default {
            print( "bar" );
         }
      }
   }
   func( 1 );
   func( "abc" );
   func( 2.0 );
   func( nil );
   func( 3 );
}
{
   _section();
   {
      fn func( val:int ) {
         switch val {
            case 1 {
               print( "hoge" );
            }
            case 2 {
               print( "foo" );
            }
            default {
               print( "bar" );
            }
         }
      }
      func( 1 );
      func( 2 );
      func( 3 );
   }
   {
      fn func( val:str ) {
         switch val {
            case "abc" {
               print( "hoge" );
            }
            case "xyz" {
               print( "foo" );
            }
            default {
               print( "bar" );
            }
         }
      }
      func( "abc" );
      func( "xyz" );
      func( "aaa" );
   }
   {
      fn func( val:int! ) {
         switch val {
            case 1 {
               print( "hoge" );
            }
            case nil {
               print( "foo" );
            }
            default {
               print( "bar" );
            }
         }
      }
      func( 1 );
      func( nil );
      func( 2 );
   }
}
{
   _section();
   {
      fn func1(): int,int {
         return 1, 2;
      }
      fn func2( val1:int, val2:int!) {
         print( val1, val2 );
      }

      func2( func1()** );
   }
   {
      fn func1(): int,str {
         return 1, "abc";
      }
      fn func2( val1:int, val2:str!) {
         print( val1, val2 );
      }

      func2( func1()** );
   }
   {
      fn func1(): int,int! {
         return 1, nil;
      }
      fn func2( val1:int, val2:int!) {
         print( val1, val2 );
      }

      func2( func1()** );
   }
}
{
   _section();
   form Func( ... );

   fn func( val:stem!, val2:stem!, ... )
   {
      print( val, val2, ... );
   }

   let sub:Func = func;
   sub( 1, 2, 3, 4 );
}

{
   _section();
   form Func1( ...<stem!> );
   form Func2( val:stem! );
   fn sub0( func:form ) {
      func( 1 );
   }
   fn sub1( func:Func1 ) {
      func( 1 );
   }
   fn sub2( func:Func2 ) {
      func( 1 );
   }
   let func:form = fn ( val:stem! ) { print( val ); };
   sub0( func );  // 1
   sub0( fn ( val:stem! ) { print( val ); } );  // 1
   sub1( fn ( val:stem! ) { print( val ); } );  // 1
   sub2( fn ( val:stem! ) { print( val ); } );  // 1
}

{
   _section();
   pub interface IF_test {
      pub fn func();
   }

   abstract class Test_class extend (IF_test) {
   }

   class Sub_class extend Test_class {
      pub fn func() {
         print( "hoge" );
      }
   }

   fn func( test:IF_test ) {
      test.func();
   }
   func( new Sub_class() );
}
class SubG extend (Mapping)
{
   let work1:real;
   static let work1_2:int;
   let work2:str;

   __init {
      SubG.work1_2 = 0;
   }
}
{
   _section();
   class Hoge {
   }

   class Sub2 extend SubG {
      let work3:int;
   }

   class Test extend (Mapping)
   {
      let val1:int;
      let val2:str;
      let val3:SubG;
   }

   fn func( test:&Test ) {
      forsort val, key in test._toMap() {
         if key == "val3" {
            forsort val2, key2 in val@@Map<str,stem> {
               print( key, key2, val2 );
            }
         }
         else {
            print( key, val );
         }
      }
   }

   fn func2( sub:&SubG ) {
      forsort val, key in sub._toMap() {
         print( key, val );
      }
   }

   func( new Test( 100, "abc", new SubG( 1.0, "xyz" ) ) );
   func2( new Sub2( 1.5, "ABC", 10 ) );
}
{
   _section();
   class Test {
      static fn func() {
      }
      pub fn sub() {
         print( "hoge" );
      }
      
   }
   let test = new Test();
   test.sub();
}
{
   _section();
   class Super {
      let val:int;
      pub fn func() mut {
         fn sub() {
            print( "%s" (self.val) );
         }
         print( self.val );
      }
   }
   let mut test = new Super( 1 );
   test.func();
}
{
   _section();
   class Test {
      pub fn func( val:str, val2:str! ) {
         fn sub():str, str {
            return val .. "xyz", (unwrap val2) .. "123";
         }
         print( sub()** );
      }
      pub fn func2( mut val:str, mut val2:str!, mut val3:int ) {
         print( val, val2, val3 );
      }
   }
   fn func( val:str, val2:str! ) {
      fn sub():str, str {
         return val .. "xyz", (unwrap val2) .. "123";
      }
      print( sub()** );
   }
   fn func2( mut val:str, mut val2:str!, mut val3:int ) {
      print( val, val2, val3 );
   }
   let test = new Test();
   test.func( "ABC", "abc" );
   test.func2( "ABC", "abc", 1 );
   func( "abc", "ABC" );
   func2( "abc", "ABC", 1 );
}
{
   _section();
   let mut test = "";
   while true {
      test = test .. "a";
      if #test > 10 {
         break;
      }
   }
   print( test );
}
{
   _section();
   let txt = "123";
   print( txt.sub( 0 ##) );
   print( txt.sub( 1 ##) );
   print( txt.sub( 2 ##) );
   print( txt.sub( 3 ##) );
   print( txt.sub( 4 ##) );
   print( txt.sub( -1 ##) );
   print( txt.sub( -2 ##) );
   print( txt.sub( -3 ##) );
   print( txt.sub( -4 ##) );
   print( txt.sub( 1, 0) );
   print( txt.sub( 1, 1) );
   print( txt.sub( 1, 2) );
   print( txt.sub( 1, 3) );
   print( txt.sub( 1, 4) );
   print( txt.sub( 1, -1) );
   print( txt.sub( 1, -2) );
   print( txt.sub( 1, -3) );
   print( txt.sub( 1, -4) );
}
{
   _section();
   class Hoge {
      let val:int;
      pub fn func() {
         print( self.val );
      }
      pro fn sub():int {
         return self.val;      
      }
   }
   class Test {
      let hoge:Hoge;

      advertise hoge;
   }
   pub fn Test.func2() {
      print( self.sub() );
   }
   let test = new Test( new Hoge( 100 ) );
   test.func();
   test.func2();
}
{
   _section();
   class Test1 {
      pub fn func() {
         print( __func__ );
      }
   }

   class Test2 extend Test1 {
      pub override fn func() {
         print( __func__ );
      }
   }

   class Test3 extend Test2{
      pub override fn func() {
         print( __func__ );
      }
   }

   fn func( test:Test1 ) {
      test.func();
   }

   func( new Test1() );
   func( new Test2() );
   func( new Test3() );
}
{
   _section();
   let txt = "a b c";
   let func:form, param, state = string.gmatch( txt, "[a-z]+" );
   print( func( param, state )** );
   print( func( param, state )** );
   print( func( param, state )** );
   apply val of string.gmatch( txt, "[a-z]+" ) {
      print( val );
   }
}
{
   _section();
   fn func( param:str, status:str! ): str!, str!
   {
      when! status {
         if #status >= 20 {
            return nil, nil;
         }
      }
      return param .. "%s" (status or "hoge"), (status or "hoge") .. "_";
   }


   form ApplyForm( param:str, status:str! ): str!, str!;

   fn sub( val:str ) : ApplyForm, str, str!  {
      return func, val, nil;
   }

   apply val1, val2 of func, "abc", nil
   {
      print( val1, val2 );
   }
   apply val1, val2 of sub( "abc" )
   {
      print( val1, val2 );
   }
}
{
   _section();
   class Test<T> {
      pub static fn func(val:T): T {
         return val;
      }
   }

   print( Test.func( 100 ) );
}
{
   _section();
   class Test<T> {
      let val:T {pub};
      pub fn func( val:T ):T {
         return val;
      }
   }

   fn sub<T>( val:T ): T {
      return val;
   }

   let test = new Test(1);
   print( test.$val + 1 );
   print( test.func( 10 ) + 10 );
   print( sub( 100 ) );
}
{
   _section();
   import subC;

   foreach val in subC.TestEnum.$_allList {
      print( val );
   }
}
{
   _section();
   fn func(): ...<int> {
      return 1, 2, 3;
   }
   fn sub2( val1:int!, ... ) {
      print( val1, ... );
   }
   sub2( func()** );
}
{
   _section();
   let mut val = 0;
   let func:form = fn (): ... {
      val = val + 1;
      return val + 1, val + 2;
   };
   let work1, work2 = func();
   print( work1, work2 );
}
{
   _section();
   let func, mess = _load( ```
local obj = {}
obj.val1 = 1
obj.val2 = "abc"
obj.val3 = 3.5
obj.val4 = { "a", "b", "c" }
return obj
```## );
   when! func {
      let map, err = func();
      when! map {
         print( map );
         let mut workmap:Map<stem,stem> = {};
         foreach val, key in map@@Luaval<Map<stem,stem>> {
            workmap[ key ] = val;
         }
         forsort val, key in workmap {
            if key == "val4" {
               foreach val2, index in val@@Luaval<List<stem>> {
                  print( key, index, val2 );
               }
            }
            else {
               print( key, val );
            }
         }
      } else {
         print( err );
      }
   }
}
{
   _section();
   macro _test() {
      fn func( val:Test ) {
         print( val == .Val1 );
      }
      func( .Val1 );
      func( .Val2 );
   }
   {
      enum Test {
         Val1,
         Val2,
      }
      _test();
   }
   {
      enum Test {
         Val1 = 1.0,
         Val2,
      }
      _test();
   }
   {
      enum Test {
         Val1 = "a",
         Val2 = "b",
      }
      _test();
      {
         let work = Test.Val1;
         print( work == "a" );
      }
   }
}
{
   _section();
   class Test {
      pub let val:int;
   }
   class Test2 {
      pub let dummy:int;
      pub let val:int;
   }
   fn func( val1:stem, val2:stem, val3:stem )
   {
      print( val1@@int + 10, val2@@real + 100, (val3@@=Test).$val,
             // lua は名前で動的にアクセスするのでが、
             // C では静的に決定したアドレスでアクセスするため、この場合はズレる
             "diff->", (val3@@=Test2).$val );

   }
   func( 1, 2.0, new Test( 1000 ) );
}
{
   _section();
   {
      fn func( flag:bool, index:int! )
      {
         if flag or index and true {
            print( "true" );
         }
         else {
            print( "false" );
         }
      }
      func( false, nil );
      func( false, 1 );
      func( true, nil );
      func( true, 1 );
   }
   {
      fn func( val:bool, flag:bool, index:int! )
      {
         if flag and val or index and true {
            print( "true" );
         }
         else {
            print( "false" );
         }
      }
      func( false, false, nil );
      func( false, false, 1 );
      func( false, true, nil );
      func( false, true, 1 );
      func( true, false, nil );
      func( true, false, 1 );
      func( true, true, nil );
      func( true, true, 1 );
   }
}
{
   _section();
   fn sub( val:bool ) {
      if ( val ) {
         print( "OK" );
      }
      else {
         print( "NG" );
      }
   }
   fn func( val1:bool, val2:bool, val3:bool ) {
      sub( val1 or val2 or val3 );
   }
   fn func2( val1:bool, val2:bool, val3:bool ) {
      sub( val1 and val2 and val3 );
   }
   func( true, true, true );
   func( true, true, false );
   func( true, false, true );
   func( true, false, false );
   func( false, true, true );
   func( false, true, false );
   func( false, false, true );
   func( false, false, false );


   func2( true, true, true );
   func2( true, true, false );
   func2( true, false, true );
   func2( true, false, false );
   func2( false, true, true );
   func2( false, true, false );
   func2( false, false, true );
   func2( false, false, false );
}
{
   _section();
   fn func( val1:int!, val2:stem!, val3:stem! ) {
      print( "-----", val1, val2, val3 );
      print( "or or", val1 or val2 or val3 );
      print( "or and", val1 or val2 and val3 );
      print( "and or", val1 and val2 or val3 );
      print( "and and", val1 and val2 and val3 );
   }
   func( nil, nil, nil );
   func( nil, nil, "a" );
   func( nil, 1.5, nil );
   func( nil, 1.5, "a" );
   func( 1, nil, nil );
   func( 1, nil, "a" );
   func( 1, 1.5, nil );
   func( 1, 1.5, "a" );
}
{
   _section();
   let mut work1:form = fn() {};
   let mut work2:form = fn() {};
   fn func() {
      let mut val = 1;
      fn sub() {
         work1 = fn () {
            val = val + 1;
         };
         work2 = fn () {
            print( val );
         };
      }
      sub();
   }
   func();
   work2();
   work1();
   work2();
}
{
   _section();
   class Test {
      pub let mut val:int;
   }

   fn func( val1:Test! ):form, form
   {
      if! val1 {
         return fn () { print( _exp.val ); }, fn () { _exp.val = _exp.val + 1; };
      }
      return fn () { print( "no" ); }, fn () {};
   }
   fn hoge( val:Test! ) {
      let sub1, sub2 = func( val );
      sub1();
      sub2();
      sub1();
   }

   hoge( nil );
   hoge( new Test( 0 ) );
}
{
   _section();
   form Sub():bool!;
   fn func( sub:Sub )
   {
      let work1 = sub();
      print( work1 );
   }
   func( fn ():bool! { return nil; } );
   func( fn ():bool! { return nil; } );
   func( fn ():bool! { return true; } );
   func( fn ():bool! { return true; } );
   func( fn ():bool! { return false; } );
   func( fn ():bool! { return false; } );
}
{
   _section();
   form Sub():int!,str!;

   fn func( sub:Sub )
   {
      if! let work1, work2 = sub() {
         print( work1, work2 );
      }
      else {
         if! sub() {
            print( _exp );
         }
      }
   }
   func( fn ():int!, str! { return nil, nil; } );
   func( fn ():int!, str! { return 1, nil; } );
   func( fn ():int!, str! { return 1, "str"; } );
}
{
   _section();
   form testFunc( val:int, val2:int ): int;

   let val = 1;
   
   fn func0( val1:int, val2:int ): int {
      return val1 + val2;
   }
   fn func1( val1:int, val2:int ): int {
      return val + val1 + val2;
   }
   fn sub() {
      {
         print( val );
      }
   }
   let func2_0:testFunc = func0;
   let func2_1:testFunc = func1;
   let func3:form = sub;
   func0( 1, 2 );
   func2_0( 1, 2 );
   func2_1( 1, 2 );
   sub();
}
{
   _section();
   fn func( val:int!, val2:real!, val3:str! )
   {
      when! val, val2, val3 {
         print( val + 10, val2 + 100.0, val3 );
      }
   }
   func( nil, nil, nil );
   func( 1, 1.0, "abc" );
}
{
   _section();
   fn func( val:int!, val2:real!, val3:str! ): form
   {
      when! val, val2, val3 {
         return fn () {
            print( val + 10, val2 + 100.0, val3 );
         };
      }
      return fn () {
         print( "dummy" );
      };
   }
   func( nil, nil, nil )();
   func( 1, 1.0, "abc" )();
}
{
   _section();
   let mut map:Map<int,int> = {};
   map[ 1 ] = 2;
   foreach val, key in map {
      print( key, val );
   }
}
{
   _section();
   let mut map:Map<stem,stem> = {};
   map[ "abc" ] = "xyz";
   foreach val, key in map {
      print( key, val );
   }
}
{
   _section();
   form Form();
   macro _loopClosure( set:stat ) {
      {}
      {
         let mut map:Map<stem,Form> = {};
         foreach val in ,,set
         {
            map[ val ] = fn () {
               print( val );
            };
         }
         forsort func in map {
            func();
         }
      }
   }

   _loopClosure( `{ [ 1, 2, 3, 4 ] } );
   _loopClosure( `{ [ "a", "b", "c", "d" ] } );
   _loopClosure( `{ (@ 1, 2, 3, 4 ) } );
   _loopClosure( `{ (@ "a", "b", "c", "d" ) } );
   _loopClosure( `{ { "a": 1, "b":2, "c":3 } } );
}
{
   _section();
   form Form();
   let mut work:Form = fn () {};
   let mut work2:Form = fn () {};
   fn func( mut val:int, mut val2:stem ) {
      work = fn () {
         print( val, val2 );
         val = 10;
      };
      work2 = fn () {
         print( val, val2 );
      };
   }
   func( 1, 2 );
   work();
   work2();
   func( 10, "abc" );
   work();
   work2();
}
{
   _section();
   let func = fn () {
      print( "hoge" );
   }
   func();
}
{
   _section();
   let func:form;
   let func2:form;
   {
      let mut val = 1;
      print( "hoge", val );
      func = fn () {
         print( val );
      };
      func2 = fn () {
         val = val + 1;
      };
      val = 2;
   }
   func();
   func2();
   func();
}
{
   _section();
   let func:form;
   let func2:form;
   {
      let mut val = "a1";
      print( "hoge", val );
      func = fn () {
         print( val );
      };
      func2 = fn () {
         val = "a3";
      };
      val = "a2";
   }
   func();
   func2();
   func();
}

class Testzz {
   static let val:int;
   __init {
      Testzz.val = 1;
   }
   pub static fn funcS(): int, int {
      return Testzz.val, 2;
   }
   pub fn func(): int, int {
      return 1, 2;
   }
}
{
   _section();
   fn funcL(): int, int {
      return 1, 2;
   }
   fn sub( val1:int, val2:int ) {
      print( val1, val2 );
   }
   print( "---" );
   sub( Testzz.funcS()** );
   sub( Testzz.funcS() + 1, 0 );
   sub( Testzz.funcS(), 0 );
   sub( ( Testzz.funcS() ), 0 );
   sub( ( Testzz.funcS() ) + 1, 0 );


   print( "---" );
   print( Testzz.funcS()** );
   print( Testzz.funcS() + 1, 0 );
   print( Testzz.funcS(), 0 );
   print( ( Testzz.funcS() ), 0 );
   print( ( Testzz.funcS() ) + 1, 0 );
   print( 0, Testzz.funcS()** );


   print( "---" );
   let test = new Testzz();
   sub( test.func()** );
   sub( test.func() + 1, 0 );
   sub( test.func(), 0 );
   sub( ( test.func() ), 0 );
   sub( ( test.func() ) + 1, 0 );
} 
{
   _section();
   fn func(): int, int, int {
      return 1, 2, 3;
   }
   fn sub2( val1:int, ... ) {
      print( val1, ... );
   }
   sub2( func(), 1 );


   print( func()@@real + 10 );
   print( -func() + 10 );
   print( ~func() + 10 );
   print( func(), 10 );
   print( ( func() ) );
   print( func()** );

   sub2( func()@@int + 10 ## );
   sub2( func()@@int + 10 );
   sub2( -func() + 10 ## );
   sub2( ~func() + 10 ## );
   sub2( func(), 10 );
   sub2( ( func() ) ## );
   sub2( func()** );
}
{
   _section();
   alge Test {
      Val1,
      Val2,
      Val3( val:int ),
      Val4( val1:int, val2:str ),
   }

   fn func( test:Test ) {
      print( test == .Val1 );
      match test {
         case .Val1 {
            print( ".Val1" );
         }
         case .Val2 {
            print( ".Val2" );
         }
         case .Val3( arg ) {
            print( ".Val3", arg );
         }
         case .Val4( arg1, arg2 ) {
            print( ".Val4", arg1, arg2 );
         }
      }
   }

   func( Test.Val1 );
   func( Test.Val2 );
   func( Test.Val3( 3 ) );
   func( Test.Val4( 3, "val" ) );
}
{
   _section();
   form FF( val:int, ... );
   fn func( val:int, ... ) {
      print( val, ... );
   }
   fn func2( ... ) {
      print( ... );
   }
   form FF3( ...<&stem!> );

   fn ret(): int, int, int {
      return 1, 2, 3;
   }
   fn sub( ff:FF ) {
      ff( ret()** );
      ff( 0, ret()** );
      ff( -1, 0, ret()** );
   }
   fn sub2( ff:form ) {
      ff( 1 );
      ff( ret()** );
      ff( 0, ret()** );
      ff( -1, 0, ret()** );
   }
   fn sub3( ff:FF3 ) {
      ff( ret()** );
      ff( 0, ret()** );
      ff( -1, 0, ret()** );
   }
   sub( func );
   sub2( func2 );
   sub3( print );
}
let valxx = 1000;
let mut val3xx = 0;
class Test1 {
   static let val:int;
   __init {
      Test1.val = 100 + valxx;
      val3xx = 10;
   }
   pub static fn func(): int {
      return Test1.val;
   }
}
let val2xx = 10000;
class Test2 {
   static let val:int;
   __init {
      Test2.val = 200 + val2xx;
   }
   pub static fn func(): int {
      return Test2.val + Test1.func();
   }
}
{
   _section();
   print( Test2.func(), val3xx );
}
{
   _section();
   fn func(): int, int, int {
      return 1, 2, 3;
   }
   fn func2(): str, int, int {
      return "1", 2, 3;
   }
   fn sub( val1:int, val2:int, val3:int ) {
      print( val1, val2, val3 );
   }
   fn sub2( val1:int, ... ) {
      print( val1, ... );
   }
   fn sub3( val1:str, ... ) {
      print( val1, ... );
   }
   print( func() + 1 );
   print( (func()) + 1 );
   print( func()** );
   sub( func()** );
   sub2( func()** );
   sub2( func(), 1 );
   sub3( func2(), 1 );
   let work1, work2 = func();
   print( work1, work2 );
}
{
   _section();
   fn func( arg:int ) {
      class Test {
         let val:int;
         pub fn func(): int {
            return self.val;
         }
      }
      let test = new Test( arg );
      print( test.func() );
   }
   fn func2( arg:int ) {
      class Test {
         let val:int;
         pub fn func(): int {
            return self.val + 100;
         }
      }
      let test = new Test( arg );
      print( test.func() );
   }
   func(1);
   func2(2);
   func(3);
}
{
   _section();
   interface IF {
      pub fn func();
   }
   class TestA extend (IF) {
      pub fn func() {
         print( "TestA" );
      }
   }
   class TestB extend (IF) {
      pub fn func() {
         print( "TestB" );
      }
   }

   class Hoge<T> {
      let mut val:T {pub,pub};
   }

   {
      let test:Hoge<&IF> = new Hoge( new TestA() );
      test.$val.func();
   }
   {
      let test:Hoge<&IF> = new Hoge( new TestB() );
      test.$val.func();
   }
}
{
   _section();
   interface IF {
      pub fn func();
   }

   class Test extend (IF) {
      pub fn sub() {
         print( "sub" );
      }
      pub fn func() {
         print( "hoge" );
      }
   }

   class Hoge<T> {
      let val:&T;
      pub fn func(): &T {
         return self.val;
      }
      pub fn func2(): &T, &T {
         return self.val, self.val;
      }
   }

   fn func( obj:&IF ) {
      obj.func();
   }

   let test = new Test();
   let hoge = new Hoge(test);
   let list:List<&IF> = [ test ];
   let list2 = [ 1 ];
   print( list2[ 1 ] );
   func( test );
   func( list[ 1 ] );
   func( hoge.func() );
   foreach item in list {
      item.func();
   }
   let val1, val2 = hoge.func2();
   val1.func();
   val2.func();

   func( ( hoge.func() ) );
}
{
   _section();
   class Test {
      let mut val:int {pub,pub};
      let mut val2:str {pub,pub};
      pub fn func( val:int ): int {
         return self.val + val;
      }
      pub fn sub( val:str ): str {
         return self.val2;
      }
   }

   let mut test = new Test(1, "abc" );
   print( test.$val, test.func( 10 ), test.sub( "xyz" ) );
   test.set_val( 2 );
   test.set_val2( "ABC" );
   print( test.$val, test.func( 20 ), test.sub( "XYZ" ) );

   class Val {
      let test:Test {pub};
      let val3:int {pub};
      pub fn __init( test1:Test ) {
         self.test = test1;
         self.val3 = 1;
      }
   }
   let val = new Val( test );
   print( val.$test.$val, val.$test.$val2 );

   class Sub extend Test {
   }

   let sub = new Sub( 10, "xyz" );
   print( sub.$val, sub.$val2 );
}
{
   _section();
   enum Test {
      Val1 = "abc",
      Val2 = "xyz",
   }

   let val = Test.Val1;
   print( val );
   foreach item in Test.$_allList {
      print( item, item.$_txt );
   }
}
{
   _section();
   enum Test {
      Val1 = 1,
      Val2,
   }

   let val = Test.Val1;
   print( val + 10 );
   foreach item in Test.$_allList {
      print( item, item.$_txt );
   }
}
{
   _section();
   fn func( val:int! ): int {
      return unwrap val default 10;
   }
   print( func( 1 ) + 1 );
   print( func( nil ) + 1 );
}
{
   _section();
   fn func( val:real! ): real {
      return unwrap val default 10.0;
   }
   print( func( 1.0 ) + 1 );
   print( func( nil ) + 1 );
}
{
   _section();
   fn func( val:str! ): str {
      return unwrap val default "abc";
   }
   print( func( "xyz" ) );
   print( func( nil ) );
}
{
   _section();
   fn func( val: int ) {
      fn comp( val1:int, val2:int ): bool {
         return val1 == val2;
      }

      if comp( val, 0 ) {
         print( "case 0" );
      }
      elseif comp( val, 1 ) {
         print( "case 1" );
      }
      else {
         print( "default" );
      }
   }
   func( 0 );
   func( 1 );
   func( 2 );
}
{
   _section();
   print( nil or false or 1 );
   print( nil or 2 or 3 );
   print( 4 or 5 );
   print( nil or false );

   print( 1 and 2 and 3 and nil );
   print( 1 and 2 and 3 );
   print( 1 and false and 2 );   
}
{
   _section();
   let val = "abc";
   fn func( val2:str ) {
      forsort item in (@ g_val, 3.5, 1, 2, 0 ) {
         print( item );
      }
      forsort item, key in { val: g_val, val2: 3.5, "999": 1, "888": 2, "777": 3 } {
         print( key, item );
      }
   }
   func( "xyz" );
}
{
   _section();
   let val = 10;
   fn func( val2:str ) {
      foreach list in [ [ val, g_val ], [ 3.5, val2 ] ] {
         foreach item in list {
            print( item );
         }
      }
      foreach set in [ (@ val, g_val ), (@ 3.5, val2 ) ] {
         foreach item in set {
            print( item );
         }
      }
      foreach map in [ { val: g_val }, { 3.5: val2 } ] {
         foreach item, key in map {
            print( key, item );
         }
      }
   }
   func( "xyz" );
}
{
   _section();
   fn func(...<int!>) {
      print( ... );
      print( 10, ... );
      print( 10, ..., 100 );
   }
   func( 1, nil, 2 );
}
{
   _section();
   let form1;
   {
      let mut val = "abc";
      fn func1(): form {
         return fn () {
            print( val );
         };
      }
      form1 = func1();
      print( val );
      val = "xyz";
   }
   form1();
}
{
   _section();
   form formfunc(val:int, val2:real);
   let form1:formfunc;
   {
      let mut val1 = "abc";
      form1 = fn(val:int, val2:real) {
         val1 = "xyz";
         print( val1, val, val2 );
      };
      print( val1 );
   }
   form1( 10, 20.1 );
}

{
   _section();
   let mut val1 = "abc";
   fn func() {
      val1 = "xyz";
   }
   func();
   print( val1 );
}

let mut g_val2 = "ABC";
{
   _section();
   let val1;
   {
      let val2;
      {
         let val3 = "abc";
         val2 = val3;
         g_val2 = "XYZ";
      }
      val1 = val2;
   }
   print( val1, g_val2 );
}

fn func1( val:int ):int {
   return val + 1;
}


fn func2( val:int, val2:real ):int, real {
   let test1, test2 = 1, g_val;
   return val + test1, val2 + test2;
}

fn func3( val:int, val2:real, val3:bool ):int, real, bool {
   let test1, test2 = func2( 1, 2.0 );
   return val + test1, val2 + test2, not val3;
}

{
   _section();
   let mut val1 = "abc";
   let mut val2 = 1;
   let mut val3 = 1;
   fn test1() {
      val1 = "xyz";
      val2 = val2 + 10;
      g_val2 = "XYZ";
   }
   val2 = val2 + 100;
   val3 = val3 + 20;
   test1();
   g_val = g_val + 100;
   print( "closure:", val1, val2, val3, g_val, g_val2 );
}


{
   _section();
   print( g_val, g_val2 );

   print( func1( 1 ) );
   print( func2( 1, 10.5 )** );
   print( func2( 2, 10.5 ), "AB");
   print( ( func2( 2, 10.5 ) ), "ABC");
   print( func2( 2, 10.5 ) + 1 );
   print( func3( 3, 10.1, true ) ** );
   print( "Hello world.", 1, 1.2, false, nil);
}
{
   _section();
   fn func()
   {
      let val = "abc";
      {
         return; // ブロック階層を一度に抜ける処理
      }
   }
   func();
}
{
   _section();
   fn func():int,real,bool,str,int!,Map<int,int> {
      return 1,2.5,false,"abc",nil,{};
   }
   print( "hoge:%d,%g,%s,%s,%s,%s" (func()) );
   io.stdout.write( "age\n" );
}
{
   _section();
   class Test {
      pub let mut val:int;
   }
   class Hoge<T:Test> {
      let mut test:T {pub};

      pub fn __init( test:T ) {
         self.test = test;
      }
      pri fn current() : T {
         return self.test;
      }
      pub fn set(val:int) {
         let mut info = self.current();
         info.val = val;
      }
   }
   let hoge = new Hoge( new Test( 1 ) );
   print( hoge.$test.val );
   hoge.set( 100 );
   print( hoge.$test.val );
}
{
   _section();
   fn func( ...<int> ) {
      let mut val:int!;
      val = ...;
      print( val );  
   }
   func( 1, 2 );
}

