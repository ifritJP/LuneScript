/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Parser;
import lune.base.Util;
import lune.base.Code;

pub class IdProvider {
   let mut id:int {pub};
   let maxId:int;

   pub fn increment() mut {
      self.id = self.id + 1;
      if self.id >= self.maxId {
         Util.err( "id is over" );
      }
   }

   pub fn getNewId() mut : int {
      let newId = self.id;
      self.id = self.id + 1;
      if self.id >= self.maxId {
         Util.err( "id is over" );
      }
      return newId;
   }
}

let extStartId = 100000;
let extMaxId = 10000000;

/** 解析対象モジュールの ID 管理 */
let mut idProvBase = new IdProvider( 1, extStartId );
/** import する外部モジュールの ID 管理 */
let mut idProvExt = new IdProvider( extStartId, extMaxId );
let mut idProv = idProvBase;

/**
ビルトインでないユーザが定義した型情報の ID 開始番号。

import 等で、別モジュールを解析する際に、モジュール毎の開始番号として使用する。
*/
let userStartId = 1000;

pub let rootTypeId = idProv.getNewId();
//let mut typeIdSeed = rootTypeId + 1;



pub proto class TypeInfo;
pub interface ModuleInfoIF {
   /** import したモジュールを assign したシンボル名 */
   pub fn get_assignName():str;
   /** import したモジュールのパス */
   pub fn get_modulePath():str;
}

/** 所定の TypeInfo が属するモジュールの ModuleInfoIF の問い合わせを行なう */
pub interface ModuleInfoManager {
   pub fn getModuleInfo( typeInfo:&TypeInfo ) : &ModuleInfoIF!;
}

pub class DummyModuleInfoManager extend (ModuleInfoManager) {
   pri static let instance:DummyModuleInfoManager {pub};
   pri fn __init() {
   }
   __init {
      DummyModuleInfoManager.instance = new DummyModuleInfoManager();
   }
   pub fn getModuleInfo( typeInfo:&TypeInfo ) : &ModuleInfoIF! {
      return nil;
   }
}

pub enum AccessMode {
   None,
   Pub,
   Pro,
   Pri,
   Local,
   Global,
}

pub enum SymbolKind {
   /** 型 */
   Typ,
   /** メンバ */
   Mbr,
   /** メソッド */
   Mtd,
   /** 関数 */
   Fun,
   /** 変数 */
   Var,
   /** 引数 */
   Arg,
   /** マクロ */
   Mac,
}

pub proto class Scope extend(ModuleInfoManager);

pub interface LowSymbol {
   /** このシンボルが属するスコープ */
   pub fn get_scope(): &Scope;
   /** シンボルのアクセス */
   pub fn get_accessMode(): AccessMode;
   /** このシンボルの ID */
   pub fn get_symbolId(): int;
   /** シンボルの名前 */
   pub fn get_name(): str;
   /** このシンボルが mut かどうか */
   pub fn get_mutable(): bool;
   /** シンボルの型 */
   pub fn get_typeInfo(): &TypeInfo;
   /** このシンボルの種類 SymbolKind */
   pub fn get_kind(): SymbolKind;
   /** このシンボルが、 closuer 内からセットされているかどうか */
   pub fn get_hasAccessFromClosure(): bool;
   /** 変換モジュール用パラメータ */
   pub fn get_convModuleParam():stem!;
   /** */
   pub fn get_staticFlag(): bool;
}

pub proto abstract class SymbolInfo extend (LowSymbol) ;


//pub let mut typeInfoKind:Map<str,TypeInfo> = {};
pub let mut sym2builtInTypeMap:Map<str,SymbolInfo> = {};
pub let mut builtInTypeIdSet:Map<int,&TypeInfo> = {};

pub enum SerializeKind {
   Nilable,
   Modifier,
   Module,
   Normal,
   Enum,
   Alge,
   DDD,
   Alias,
   Alternate,
   Generic,
   Box,
}

pub enum TypeInfoKind {
   Root,
   Macro,
   Prim,
   List,
   Array,
   Map,
   Class,
   IF,
   Func,
   Method,
   Nilable,
   Enum,
   Module,
   Stem,
   Alge,
   /** ... */
   DDD,
   /** 省略 ## */
   Abbr,
   Set,
   Alternate,
   Box,
   CanEvalCtrl,
   Etc,
   Form,
   FormFunc,
   Ext,
}

pub fn isBuiltin( typeId: int ) : bool {
   return builtInTypeIdSet[ typeId ] ~= nil;
}


pub fn isPubToExternal( mode:AccessMode ): bool {
   switch mode {
      case .Pub, .Pro, .Global {
         return true;
      }
   }
   return false;
}

let mut txt2AccessModeMap:Map<str,AccessMode> = {};
txt2AccessModeMap[ "none" ] = .None;
txt2AccessModeMap[ "pub" ] = .Pub;
txt2AccessModeMap[ "pro" ] = .Pro;
txt2AccessModeMap[ "pri" ] = .Pri;
txt2AccessModeMap[ "local" ] = .Local;
txt2AccessModeMap[ "global" ] = .Global;
pub fn txt2AccessMode( accessMode:str ) : AccessMode! {
   return txt2AccessModeMap[ accessMode ];
}

let mut accessMode2txtMap:Map<AccessMode,str> = {};
accessMode2txtMap[ .None ] = "none";
accessMode2txtMap[ .Pub ] = "pub";
accessMode2txtMap[ .Pro ] = "pro";
accessMode2txtMap[ .Pri ] = "pri";
accessMode2txtMap[ .Local ] = "local";
accessMode2txtMap[ .Global ] = "global";
pub fn accessMode2txt( accessMode:AccessMode ) : str {
   return unwrap accessMode2txtMap[ accessMode ];
}

pub enum MutMode {
   IMut,
   /**
   メンバの中身を含めて Imutable。
   例えば List<Hoge> の List が IMutRe の時、Hoge も Imutable。
   */ 
   IMutRe,
   Mut,
   AllMut,
}
pub fn isMutable( mode:MutMode ): bool {
   switch mode {
      case .AllMut, .Mut {
         return true;
      }
   }
   return false;
}

// pub enum AccessFromClosuer {
//    /** アクセスなし */
//    None,
//    /** 読み込みアクセス */
//    Read,
//    /** 書き込みアクセス */
//    Write,
// }

pub class TypeNameCtrl {
   /** 現在解析中モジュールの型情報 */
   let mut moduleTypeInfo:&TypeInfo {pub,pub};
   
   pub fn getParentFullName(
      mut typeInfo:&TypeInfo, mut importInfo:&ModuleInfoManager!, localFlag:bool! ) : str;
}

pub enum ScopeAccess {
   Normal,
   Full,
}

/** シンボル情報 */
pub abstract class SymbolInfo extend (LowSymbol) {
   pri let allmut namespaceTypeInfo: &TypeInfo!;

   pro fn __init() {
      self.namespaceTypeInfo = nil;
   }
   
   /** 左辺値になれる場合 true */
   pub abstract fn get_canBeLeft(): bool;
   /** 右辺値になれる場合 true */
   pub abstract fn get_canBeRight(): bool;
   /** このシンボルの ID */
   pub abstract fn get_symbolId(): int;
   /** このシンボルが属するスコープ */
   pub abstract fn get_scope(): &Scope;
   /** シンボルのアクセス */
   pub abstract fn get_accessMode(): AccessMode;
   /** */
   pub abstract fn get_staticFlag(): bool;
   /** シンボルの名前 */
   pub abstract fn get_name(): str;
   /**
シンボルの定義位置。実際の定義位置とズレることがある。参考程度にすること。
外部シンボルや、ビルトインの場合は nil。
 */
   pub abstract fn get_pos(): &Parser.Position!;
   /** シンボルの型 */
   pub abstract fn get_typeInfo(): &TypeInfo;
   /** シンボルの型 */
   pub abstract fn set_typeInfo(typeInfo:&TypeInfo);
   /** このシンボルが mut かどうか */
   pub abstract fn get_mutable(): bool;
   pub abstract fn get_mutMode(): MutMode;
   /** このシンボルの種類 SymbolKind */
   pub abstract fn get_kind(): SymbolKind;
   /** このシンボルがデータを保持しているかどうか */
   pub abstract fn get_hasValueFlag(): bool;
   pub abstract fn set_hasValueFlag( arg:bool );
   /** このシンボルが、 closuer 内からセットされているかどうか */
   pub abstract fn get_hasAccessFromClosure(): bool;
   pub abstract fn set_hasAccessFromClosure(flag:bool);
   // pub abstract fn get_accessFromClosure(): AccessFromClosuer;
   // pub abstract fn set_accessFromClosure( mode: AccessFromClosuer );
   /** 変換モジュール用パラメータ */
   pub abstract fn set_convModuleParam( param:stem! );
   pub abstract fn get_convModuleParam():stem!;


   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub abstract fn canAccess( fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!;

   pub abstract fn getOrg(): &SymbolInfo;


   /** このシンボルを定義している名前空間の TypeInfo*/
   pub fn get_namespaceTypeInfo(): &TypeInfo;
}


pub class DataOwnerInfo {
   pub let hasData:bool;
   pub let symbolInfo: &SymbolInfo;
}

pub class Scope extend (ModuleInfoManager) {
   pri static let mut seedId:int;
   
   __init {
      Scope.seedId = 0;
   }

   pri let scopeId:int {pub};
   
   // このスコープのオーナーの TypeInfo。
   // 名前空間に関連する class, function の TypeInfo。
   pri let mut ownerTypeInfo: &TypeInfo! { pub, pub };
   // 親のスコープ。 これが self と等しい場合は root。
   pri let mut parent: Scope { pub };
   // このスコープに登録されているシンボル情報。
   // シンボル名 → SymbolInfo のマップ。
   pri let mut symbol2SymbolInfoMap: Map<str,&SymbolInfo> { pub& };
   // このスコープがクラスのスコープかどうか。
   pri let classFlag: bool;
   // 継承しているスコープ。
   pri let mut inherit: &Scope! {pub};
   // 継承しているスコープ。
   pri let ifScopeList: List<&Scope>;
   /** 所有権情報 */
   pri let mut symbolId2DataOwnerInfo: Map<int,DataOwnerInfo>;
   /** このスコープ内でアクセスしている closure シンボル */
   pri let mut closureSymMap: Map<int,&SymbolInfo> {pub};
   pri let mut closureSymList: List<&SymbolInfo> {pub};
   pri let mut closureSym2NumMap: Map<&SymbolInfo,int> {pub};
   pri let mut typeInfo2ModuleInfoMap: Map<&TypeInfo,&ModuleInfoIF>;
   

   pub fn __init( parent: Scope!, classFlag: bool,
                  inherit: &Scope!, ifScopeList:List<&Scope>! )
   {
      self.scopeId = Scope.seedId;
      Scope.seedId = Scope.seedId + 1;

      self.typeInfo2ModuleInfoMap = {};
      self.closureSymMap = {};
      self.closureSym2NumMap = {};
      self.closureSymList = [];
      self.parent = unwrap parent default self;
      self.symbol2SymbolInfoMap = {};
      self.inherit = inherit;
      self.classFlag = classFlag;
      self.symbolId2DataOwnerInfo = {};
      self.ifScopeList = unwrap ifScopeList default [];
   }

   pub fn getNamespaceTypeInfo() : &TypeInfo;

   
   pub fn isRoot(): bool {
      return self.parent == self;
   }

   pub fn set_ownerTypeInfo( owner: &TypeInfo! ) mut {
      if not self.ownerTypeInfo {
         self.ownerTypeInfo = owner;
      }
   }

   pub fn getTypeInfoChild( name: str ) : &TypeInfo! {
      if! self.symbol2SymbolInfoMap[ name ] {
         return _exp.$typeInfo;
      }
      return nil;
   }

   pub fn getSymbolInfoChild( name: str ) : &SymbolInfo! {
      return self.symbol2SymbolInfoMap[ name ];
   }

   pub fn setData( symbolInfo:&SymbolInfo ) mut {
      self.symbolId2DataOwnerInfo[ symbolInfo.$symbolId ] =
      new DataOwnerInfo( true, symbolInfo );
   }

   pub fn remove( name: str ) mut {
      self.symbol2SymbolInfoMap[ name ] = nil;
   }

   pub fn addSymbol( symbolInfo: SymbolInfo ) mut {
      self.symbol2SymbolInfoMap[ symbolInfo.$name ] = symbolInfo;
   }

   pub fn addModule( typeInfo:&TypeInfo, moduleInfo:&ModuleInfoIF ) mut {
      self.typeInfo2ModuleInfoMap[ typeInfo ] = moduleInfo;
   }

   pub fn getModuleInfo( typeInfo:&TypeInfo ) : &ModuleInfoIF! {
      if! let moduleInfo = self.typeInfo2ModuleInfoMap[ typeInfo ] {
         return moduleInfo;
      }
      if self.parent ~= self {
         return self.parent.getModuleInfo( typeInfo );
      }
      return nil;
   }
}

pub fn SymbolInfo.get_namespaceTypeInfo(): &TypeInfo {
   if! self.namespaceTypeInfo {
      return _exp;
   }
   let work = self.$scope.getNamespaceTypeInfo();
   self.namespaceTypeInfo = work;
   return work;
}

// 最上位のスコープ
pub let mut rootScope = new Scope( nil, false, nil## );

/**
このスコープが scope の同じか内部のスコープか調べる。

@return bool: 同じか内部のスコープの場合 true。
*/
pub fn Scope.isInnerOf( scope:&Scope ): bool {
   let mut workScope = self;
   while workScope ~= rootScope {
      if workScope == scope {
         return true;
      }
      workScope = workScope.parent;
   }
   return false;
}


let dummyList:List<&TypeInfo> = [];
let mut rootChildren:List<&TypeInfo> = [];

/**
TypeInfo の付随した情報で、かつ mutable な情報。
*/
pub class TypeData {
   pri let mut children:List<&TypeInfo> {pub};
   pub fn addChildren( child:&TypeInfo ) mut {
      self.children.insert( child );
   }
}

/** TypeInfo と TypeData の紐付け管理 */
// class TypeManager {
//    pri static let mut info2Data:Map<&TypeInfo,TypeData>;

//    __init {
//       TypeManager.info2Data = {};
//    }
//    pub static fn add( typeInfo:&TypeInfo ) {
//       TypeManager.info2Data[ typeInfo ] = new TypeData( [] );
//    }
//    pub static fn getData( typeInfo:&TypeInfo ) : TypeData! {
//       return TypeManager.info2Data[ typeInfo ];
//    }
// }


// let mut typeInfo2ScopeMap:Map<&TypeInfo,Scope> = {};

// pub fn getScope( typeInfo:&TypeInfo ): Scope! {
//    return typeInfo.$scope;
//    //return typeInfo2ScopeMap[ typeInfo ];
// }

pub enum CanEvalType {
   /** 代入(アップキャスト可能な型は代入 OK とする)。 代入先は IMut で確定。 */
   SetOpIMut,
   /** 代入(アップキャスト可能な型は代入 OK とする)。 代入先は IMut かどうか不正。  */
   SetOp,
   /** 代入(アップキャスト可能な型でも、同一の型でない場合は NG とする) */
   SetEq,
   /** 算術演算 */
   Math,
   /** 大小比較演算 */
   Comp,
   /** 論理演算 */
   Logical,
}


pub class TypeInfo {

   // この TypeInfo のスコープ。
   // class, func など名前空間を持つ TypeInfo は有効。
   pri let allmut scope: Scope! {pub};

   pri let allmut typeData: TypeData {pub};

   // pub fn get_scope(): Scope! {
   //    return typeInfo2ScopeMap[ self ];
   // }

   pub fn __init( scope: Scope! ) {
      //typeInfo2ScopeMap[ self ] = scope;
      self.scope = scope;
      if! scope {
         _exp.set_ownerTypeInfo( self );
      }
      self.typeData = new TypeData( [] );
      //TypeManager.add( self );
   }

   pub static fn getModulePath( fullname:str ) : str {
      return ( fullname.gsub( "@", "" ) );
   }

   /** この型がモジュールを示す型の場合 true  */
   pub fn isModule(): bool {
      return true;
   }

   /** 親の typeId  */
   pub fn getParentId(): int {
      return rootTypeId;
   }

   /** スーパークラスの typeId */
   pub fn get_baseId(): int {
      return rootTypeId;
   }

   /** この型が other を継承しているかどうか */
   pub fn isInheritFrom( other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool {
      return false;
   }

   /** シンプルな型名 */
   pub fn get_rawTxt(): str {
      return "";
   }

   /**
   この型の名前を取得する。

   型のフルパス名を取得する場合は、
    typeNameCtrl に現在の解析対象モジュールの TypeInfo を指定する。
    */  
   pro fn getTxtWithRaw(
      raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "";
   }

   /**
   この型の名前を取得する。

   型のフルパス名を取得する場合は、
    typeNameCtrl に現在の解析対象モジュールの TypeInfo を指定する。
    */  
   pub fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }

   /** other 型から dest 型への canEvalType の評価が可能かどうか */
   pro static fn canEvalWithBase(
      dest:&TypeInfo, destMut: bool, other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!;

   /** other 型からこの型への canEvalType の評価が可能かどうか */
   pub fn canEvalWith( other:&TypeInfo, canEvalType:CanEvalType,
                       alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return false, nil;
   }

   /** この型が abstract かどうか */
   pub fn get_abstractFlag(): bool {
      return false;
   }

   /** この型情報を oStream にシリアライズする */
   pub fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      return;
   }


   /** 表示用文字列取得 */
   pub fn get_display_stirng_with( raw:str ): str {
      return "";
   }

   /** 表示用文字列取得 */
   pub fn get_display_stirng(): str {
      return self.get_display_stirng_with( "" );
   }


   /** Modifier の元となる型情報 */
   pub fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }

   /** この型と typeInfo が等しいかどうか */
   pub fn equals( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                  checkModifer:bool! ): bool {
      return self == typeInfo;
   }

   /** この型が外部モジュールで定義した型かどうか */
   pub fn get_externalFlag(): bool {
      return false;
   }

   /** この型が実装しているインタフェースリスト */
   pub fn get_interfaceList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** generics の型リスト */
   pub fn get_itemTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** 引数の型リスト */
   pub fn get_argTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** 戻り値の型リスト */
   pub fn get_retTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** 名前空間の親 */
   pub fn get_parentInfo(): &TypeInfo {
      return self;
   }

   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報が宣言されているか？
   */
   pub fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      while true {
         if other == self {
            return true;
         }
         if other.$parentInfo == other {
            break;
         }
         other = other.$parentInfo;
      }
      return false;
   }
   /** この型が属しているモジュールを取得 */
   pub fn getModule(): &TypeInfo {
      if self.isModule() {
         return self;
      }
      return self.$parentInfo.getModule();
   }
   /** typeId を取得 */
   pub fn get_typeId(): int {
      return rootTypeId;
   }
   /** 型の種別 */
   pub fn get_kind(): TypeInfoKind {
      return .Root;
   }
   /**
static な型か。

メソッドでない関数は全て static となる。
   */
   pub fn get_staticFlag(): bool {
      return false;
   }
   /** アクセスモード */
   pub fn get_accessMode(): AccessMode {
      return AccessMode.Pri;
   }
   /** ユーザ定義でなく自動的に生成したかどうか */
   pub fn get_autoFlag(): bool {
      return false;
   }
   /** 非 nilable の型情報 */
   pub fn get_nonnilableType(): &TypeInfo {
      return self;
   }
   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub fn get_baseTypeInfo(): &TypeInfo {
      return self;
   }
   /** nilable かどうか */
   pub fn get_nilable(): bool {
      return false;
   }
   /** nilable な型情報 */
   pub fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   /** TypeData の取得 */
   // pub fn get_typeData(): TypeData {
   //    return unwrap TypeManager.getData( self );
   // }
   /** 子リスト取得 */
   pub fn get_children() : &List<&TypeInfo> {
      return self.typeData.$children;
   }
   /** 子の追加 */
   pub fn addChildren( child:TypeInfo ) {
      //(unwrap TypeManager.getData( self )).addChildren( child );
      self.typeData.addChildren( child );
   }
   /** mutable かどうか */
   pub fn get_mutMode(): MutMode {
      return .Mut;
   }

   pub static fn isMut( typeInfo:&TypeInfo ): bool {
      return isMutable( typeInfo.$mutMode );
   }

   /** 親の完全限定名を取得する */
   pub fn getParentFullName(
      typeNameCtrl:&TypeNameCtrl, 
      mut importInfo:&ModuleInfoManager!,
      localFlag:bool! ) : str
   {
      return typeNameCtrl.getParentFullName( self, importInfo, localFlag );
   }

   pub fn applyGeneric( alt2typeMap:&Map<&TypeInfo,&TypeInfo>,
                        moduleTypeInfo:&TypeInfo ): &TypeInfo!
   {
      return self;
   }

   pub fn get_genSrcTypeInfo(): &TypeInfo {
      return self;
   }

   pro fn serializeTypeInfoList(
      name: str, list: &List<&TypeInfo>, onlyPub: bool! ): str
   {
      let mut work = name;
      foreach typeInfo in list {
         if not onlyPub or typeInfo.$accessMode == .Pub  {
            if #work ~=  #name {
               work = work .. ", ";
            }
            work = "%s%d" (work, typeInfo.$typeId );
         }
      }
      return work .. "}, ";
   }

   pub static fn createScope(
      parent: Scope!, classFlag: bool,
      baseInfo: &TypeInfo!, interfaceList: &List<&TypeInfo>! ) : Scope
   {
      let mut inheritScope:Scope! = nil;
      when! baseInfo {
         //inheritScope = unwrap getScope( baseInfo );
         inheritScope = unwrap baseInfo.$scope;
      }
      let mut ifScopeList:List<&Scope> = [];
      when! interfaceList {
         foreach ifType in interfaceList {
            ifScopeList.insert( unwrap ifType.$scope );
         }
      }
      return new Scope( parent, classFlag, inheritScope, ifScopeList );
   }

   // prototype
   pub fn createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo>;
   pub fn getFullName(
      typeNameCtrl:&TypeNameCtrl, importInfo:&ModuleInfoManager, localFlag:bool! ) : str;
   
}


pub enum MethodKind {
   /** 全メソッド */
   All,
   /** static メソッド */
   Static,
   /** 非 static メソッド */
   Object,
}

/**
指定のクラスが持つ全メソッド名を取得する。

指定クラスが派生クラスだった場合、親クラスのメソッドも取得する。
*/
pub fn getAllNameForKind( classInfo:&TypeInfo, kind:MethodKind,
                          symbolKind:SymbolKind ) : &Util.OrderedSet<str>
{
   let mut nameSet = new Util.OrderedSet<str>();
   fn process( scope:&Scope ) {
      if! let inherit = scope.$inherit {
         process( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case symbolKind {
               if symbolKind == .Mtd and symbolInfo.$name == "__init" {
                  // ピックアップ対象外
               }
               else {
                  let staticFlag = symbolInfo.$staticFlag;
                  if kind == .All or
                     kind == .Static and staticFlag or
                     kind == .Object and not staticFlag
                  {
                     nameSet.add( symbolInfo.$name );
                  }
               }
            }
         }
      }
   }

   if! let scope = classInfo.$scope {
      process( scope );
   }
   return nameSet;
}

pub fn getAllMethodName( classInfo:&TypeInfo, kind:MethodKind ) : &Util.OrderedSet<str> {
   return getAllNameForKind( classInfo, kind, .Mtd );
}


pub fn TypeNameCtrl.getModuleName(
   workTypeInfo:&TypeInfo, name:str, moduleInfoMan:&ModuleInfoManager ): str
{
   if! let moduleInfo = moduleInfoMan.getModuleInfo( workTypeInfo ) {
      let txt = moduleInfo.$assignName;
      return txt .. "." .. name;
   }
   else {
      if self.moduleTypeInfo ~= workTypeInfo {
         return workTypeInfo.$rawTxt .. "." .. name;
      }
   }
   return name;
}

pub fn TypeNameCtrl.getParentFullName(
   mut typeInfo:&TypeInfo, mut importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
{
   let mut workTypeInfo = typeInfo;
   let mut name = "";
   // let! mut infoMap = importInfo {
   //    infoMap = {};
   // };
   //while not infoMap[ typeInfo ] {
   let! moduleInfoMan = importInfo {
      moduleInfoMan = DummyModuleInfoManager.$instance;
   };
   //while not moduleInfoMan.getModuleInfo( workTypeInfo ) {
   while true {
      workTypeInfo = workTypeInfo.$parentInfo;
      let mut txt = workTypeInfo.$rawTxt;
      if workTypeInfo == workTypeInfo.$parentInfo {
         break;
      }
      if localFlag {
         if workTypeInfo.isModule() {
            name = self.getModuleName( workTypeInfo, name, moduleInfoMan );
            break;
         }
      }
      name = txt .. "." .. name;
   }
   return name;
}




pub fn getScope( typeInfo:&TypeInfo ): Scope! {
   return typeInfo.$scope;
   //return typeInfo2ScopeMap[ typeInfo ];
}


pub fn isExtId(typeInfo:&TypeInfo): bool {
   if typeInfo.$typeId >= extStartId {
      return true;
   }
   return false;
}


/** TypeInfo の head。 */
pub let headTypeInfo:TypeInfo = new TypeInfo( rootScope );
//let rootTypeInfo:TypeInfo = new TypeInfo( rootScope );

pub let defaultTypeNameCtrl = new TypeNameCtrl( headTypeInfo );

pub fn TypeInfo.hasBase(): bool {
   return self.$baseTypeInfo ~= headTypeInfo;
}


pub fn Scope.getNamespaceTypeInfo() : &TypeInfo {
   let typeInfo = headTypeInfo;
   let mut scope = self;
   repeat {
      if! scope.$ownerTypeInfo {
         return _exp;
      }
      scope = scope.$parent;
   } scope.isRoot();
   return typeInfo;
}

pub class NormalSymbolInfo extend SymbolInfo {
   pri static let mut symbolIdSeed:int;

   __init {
      NormalSymbolInfo.symbolIdSeed = 0;
   }

   /** 左辺値になれる場合 true */
   pri let canBeLeft: bool { pub };
   /** 右辺値になれる場合 true */
   pri let canBeRight: bool { pub };

   /** このシンボルの ID */
   pri let symbolId: int { pub };
   /** このシンボルが属するスコープ */
   pri let scope: &Scope { pub };
   /** シンボルのアクセス */
   pri let accessMode: AccessMode { pub };
   /** */
   pri let staticFlag: bool { pub };
   /** シンボルの名前 */
   pri let name: str { pub };
   /** シンボルの名前 */
   pri let pos: &Parser.Position! { pub };
   /** シンボルの型 */
   pri let allmut typeInfo: &TypeInfo { pub, pub };
   /** このシンボルの種類 SymbolKind */
   pri let kind: SymbolKind { pub };
   /** このシンボルがデータを保持しているかどうか */
   pri let allmut hasValueFlag: bool { pub, pub };
   pri let mutMode: MutMode {pub};
   // pri let allmut accessFromClosure: AccessFromClosuer { pub, pub };
   pri let allmut hasAccessFromClosure: bool {pub,pub};
   /** 変換モジュール用パラメータ */
   pri let allmut convModuleParam:stem! {pub,pub}; 
   
   pub override fn get_mutable(): bool {
      return isMutable( self.mutMode );
   }

   // pub override fn get_hasAccessFromClosure() : bool {
   //    return self.$accessFromClosure ~= .None;
   // }

   pub override fn getOrg(): &SymbolInfo {
      return self;
   }

   pub fn __init(
      kind:SymbolKind, canBeLeft:bool, canBeRight:bool, scope: Scope,
      accessMode: AccessMode, staticFlag: bool, name: str, pos:&Parser.Position!,
      typeInfo: &TypeInfo, mutMode: MutMode!, hasValueFlag: bool )
   {
      super();
      self.convModuleParam = nil;
      //self.accessFromClosure = .None;
      self.hasAccessFromClosure = false;
      NormalSymbolInfo.symbolIdSeed = NormalSymbolInfo.symbolIdSeed + 1;
      self.kind = kind;
      self.canBeLeft = canBeLeft;
      self.canBeRight = canBeRight;
      self.symbolId = NormalSymbolInfo.symbolIdSeed;
      self.scope = scope;
      self.accessMode = accessMode;
      self.staticFlag = staticFlag;
      self.name = name;
      self.pos = pos;
      self.typeInfo = typeInfo;
      self.mutMode = unwrap mutMode default MutMode.IMut;
      self.hasValueFlag = hasValueFlag;
   }

   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub override fn canAccess( fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!;
}

pro static fn TypeInfo.isInherit(
   typeInfo:&TypeInfo, other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ): bool
{
   let baseTypeInfo = typeInfo.$baseTypeInfo;
   let interfaceList = typeInfo.$interfaceList;
   let otherTypeId = other.$typeId;
   if typeInfo.$typeId == otherTypeId {
      return true;
   }
   if baseTypeInfo ~= headTypeInfo {
      if baseTypeInfo.isInheritFrom( other, alt2type ) {
         return true;
      }
   };
   foreach ifType in typeInfo.$interfaceList {
      if ifType.isInheritFrom( other, alt2type ) {
         return true;
      }
   }
   return false;
}



pub class AutoBoxingInfo extend TypeInfo {
   static let mut allObj:Map<&TypeInfo,AutoBoxingInfo>;

   let mut count:int{pub};

   pub fn __init() {
      super( nil );
      self.count = 0;
      AutoBoxingInfo.allObj[ self ] = self;
   }


   __init {
      AutoBoxingInfo.allObj = {};
   }


   pub override fn get_kind(): TypeInfoKind {
      return .Etc;
   }

   pub fn inc() {
      let mut obj = unwrap AutoBoxingInfo.allObj[ self ];
      obj.count = obj.count + 1;
   }

   pub fn unregist() {
      AutoBoxingInfo.allObj[ self ] = nil;
   }
}

pub class CanEvalCtrlTypeInfo extend TypeInfo {
   pub static let detectAlt:CanEvalCtrlTypeInfo;
   pub static let needAutoBoxing:CanEvalCtrlTypeInfo;
   pub static let checkTypeTarget:CanEvalCtrlTypeInfo;


   // pub fn __init() {
   //    super( nil );
   // }
   _lune_control default__init_old;
   //_lune_control default__init;

   __init {
      CanEvalCtrlTypeInfo.detectAlt = new CanEvalCtrlTypeInfo();
      CanEvalCtrlTypeInfo.needAutoBoxing = new CanEvalCtrlTypeInfo();
      CanEvalCtrlTypeInfo.checkTypeTarget = new CanEvalCtrlTypeInfo();
   }

   pub override fn get_kind(): TypeInfoKind {
      return .CanEvalCtrl;
   }

   pub override fn get_typeId(): int {
      return -1;
   }

   pub static fn createDefaultAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      if detectFlag {
         let mut map:Map<&TypeInfo,&TypeInfo> = {};
         map[ CanEvalCtrlTypeInfo.detectAlt ] = headTypeInfo;
         return map;
      }
      return {};
   }

   pub static fn isValidApply( alt2type:Map<&TypeInfo,&TypeInfo> ) : bool {
      return alt2type[ CanEvalCtrlTypeInfo.detectAlt ] ~= nil;
   }

   pub static fn setupNeedAutoBoxing( alt2type:Map<&TypeInfo,&TypeInfo> ) {
      alt2type[ CanEvalCtrlTypeInfo.needAutoBoxing ] = new AutoBoxingInfo();
   }

   pub static fn updateNeedAutoBoxing( alt2type:Map<&TypeInfo,&TypeInfo> ) {
      if! alt2type[ CanEvalCtrlTypeInfo.needAutoBoxing ] {
         if! let mut autoBoxingInfo = _exp@@@AutoBoxingInfo {
            autoBoxingInfo.inc();
         }
      }
      else {
         Util.err( "no exist needAutoBoxing" );
      }
   }

   pub static fn hasNeedAutoBoxing( alt2type:Map<&TypeInfo,&TypeInfo> ): bool {
      if! alt2type[ CanEvalCtrlTypeInfo.needAutoBoxing ] {
         if! let mut autoBoxingInfo = _exp@@@AutoBoxingInfo {
            return autoBoxingInfo.$count ~= 0;
         }
      }
      return false;
   }
   

   pub static fn finishNeedAutoBoxing(
      alt2type:Map<&TypeInfo,&TypeInfo>, count:int ): bool
   {
      if! alt2type[ CanEvalCtrlTypeInfo.needAutoBoxing ] {
         if! let mut autoBoxingInfo = _exp@@@AutoBoxingInfo {
            autoBoxingInfo.unregist();
            return autoBoxingInfo.$count == count;
         }
      }
      return false;
   }

   /**
dst に対して autoBoxing 可能かどうか調べる。

追加で canEvalWith() を実行して評価可能かどうか確認する必要がある。
   */
   pub static fn canAutoBoxing( dst:&TypeInfo, src:&TypeInfo ): bool
   {
      let dstSrc = dst.$srcTypeInfo.$nonnilableType;
      if dstSrc.$kind ~= .Box {
         return false;
      }
      let srcSrc = src.$srcTypeInfo.$nonnilableType;
      if srcSrc.$kind == .Box {
         return false;
      }
      return true;
   }
}

pub class AliasTypeInfo extend TypeInfo {
   pri let rawTxt: str { pub };
   pri let accessMode: AccessMode { pub };
   pri let parentInfo: &TypeInfo { pub };
   pri let aliasSrcTypeInfo: &TypeInfo { pub };
   pri let externalFlag:bool { pub };
   pri let typeId: int { pub };

   // pub fn __init( rawTxt: str, accessMode: AccessMode, parentInfo: &TypeInfo,
   //                aliasSrcTypeInfo: &TypeInfo, externalFlag:bool, typeId: int )
   // {
   //    super( nil );
   //    self.rawTxt = rawTxt;
   //    self.accessMode = accessMode;
   //    self.parentInfo = parentInfo;
   //    self.aliasSrcTypeInfo = aliasSrcTypeInfo;
   //    self.externalFlag = externalFlag;
   //    self.typeId = typeId;
   // }

   _lune_control default__init_old;

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.rawTxt, typeNameCtrl, importInfo, localFlag );
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, rawTxt = %q, srcTypeId = %d }\n' (
            SerializeKind.Alias, parentId, self.typeId, self.rawTxt,
            self.aliasSrcTypeInfo.$typeId ) );
   }

   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.rawTxt );
   }

   /** 親の typeId  */
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   pub override fn applyGeneric(
      alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ): &TypeInfo!
   {
      let typeInfo = self.aliasSrcTypeInfo.applyGeneric( alt2typeMap, moduleTypeInfo );
      if typeInfo == self.aliasSrcTypeInfo {
         return self;
      }
      return nil;
   }

   advertise aliasSrcTypeInfo;
}


/**
列挙したシンボル情報を処理するコールバック。

@return 列挙を続ける場合は true
*/
pub form filterForm( symbolInfo:&SymbolInfo ): bool;

/**
このスコープからアクセス可能なフィールドを列挙し callback を実行する。

@param includeSelfFlag true の場合、
自分自身のスコープに登録されているシンボルを列挙対象にする。
@param fromScope アクセスを開始しているスコープ。
@param callback コールバック。
@return bool 列挙を続ける場合 true
*/
pub fn Scope.filterTypeInfoField( includeSelfFlag: bool!, fromScope:&Scope,
                                  access:ScopeAccess, callback:filterForm ):bool
{
   if self.classFlag {
      if includeSelfFlag {
         forsort symbolInfo in self.symbol2SymbolInfoMap {
            if symbolInfo.canAccess(  fromScope, access ) {
               if not callback( symbolInfo ) {
                  return false;
               }
            }
         }
      }
      if! let scope = self.inherit {
         if not scope.filterTypeInfoField(
            true, fromScope, access, callback ) {
            return false;
         }
      }
   }

   return true;
}

/**
このスコープからアクセス可能な name のフィールドを取得する。

インタフェースは含めない。
*/
pub fn Scope.getSymbolInfoField( name: str, includeSelfFlag: bool!,
                                 fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!
{
   if self.classFlag {
      if includeSelfFlag {
         if! self.symbol2SymbolInfoMap[ name ] {
            let! symbolInfo = _exp.canAccess(  fromScope, access ) {
               return nil;
            };
            return symbolInfo;
         }
      }
      if! let mut scope = self.inherit {
         let symbolInfo = scope.getSymbolInfoField( name, true, fromScope, access );
         if symbolInfo {
            return symbolInfo;
         }
      }
   }

   return nil;
}

/**
このスコープからアクセス可能な name のフィールドを取得する。

インタフェースを含む。
*/
pub fn Scope.getSymbolInfoIfField(
   name: str, fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!
{
   if self.classFlag {
      foreach scope in self.ifScopeList {
         if! let symbolInfo =
            scope.getSymbolInfoField( name, true, fromScope, access )
         {
            return symbolInfo;
         }
      }
   }

   if! let scope = self.inherit {
      if! let symbolInfo = scope.getSymbolInfoIfField( name, fromScope, access ) {
         return symbolInfo;
      }
   }

   return nil;
}

/**
このスコープからアクセス可能なフィールドを列挙し callback を実行する。

インタフェースを含む。
*/
pub fn Scope.filterSymbolInfoIfField(
   fromScope:&Scope, access:ScopeAccess, callback:filterForm ) : bool
{
   foreach scope in self.ifScopeList {
      if not scope.filterTypeInfoField( true, fromScope, access, callback ) {
         return false;
      }
   }

   if! let scope = self.inherit {
      if not scope.filterSymbolInfoIfField( fromScope, access, callback ) {
         return false;
      }
   }

   return true;
}



pub fn Scope.getTypeInfoField(
   name: str, includeSelfFlag: bool!, fromScope:&Scope, access:ScopeAccess ) : &TypeInfo!
{
   let symbolInfo =
      self.getSymbolInfoField( name, includeSelfFlag, fromScope, access );
   if! symbolInfo {
      return _exp.$typeInfo;
   }
   return nil;
}


/**
このスコープからシンボル name の型情報を取得する。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
@param onlySameNsFlag true の場合、検索対象を同一名前空間内に限定する。
  ここで、「同一名前空間内」とは、このスコープから辿れる名前空間という意味である。
*/
pub fn Scope.getSymbolInfo( name: str, fromScope:&Scope,
                            onlySameNsFlag:bool, access:ScopeAccess ) : &SymbolInfo!
{
   if! self.symbol2SymbolInfoMap[ name ] {
      let! symbolInfo = _exp.canAccess( fromScope, access  ) {
         return nil;
      };
      return symbolInfo;
   }
   if not onlySameNsFlag {
      if! let scope = self.inherit {
         let symbolInfo = scope.getSymbolInfoField( name, true, fromScope, access );
         if symbolInfo {
            return symbolInfo;
         }
      }
   }

   if not onlySameNsFlag or not self.ownerTypeInfo {
      if self.parent ~= self {
         return self.parent.getSymbolInfo( name, fromScope, onlySameNsFlag, access );
      }
   }
   else {
      let mut workScope = self.parent;
      while workScope.parent ~= workScope {
         if workScope.ownerTypeInfo$.$kind ~= TypeInfoKind.Class {
            return workScope.getSymbolInfo( name, fromScope, onlySameNsFlag, access );
         }
         workScope = workScope.parent;
      }
   }
   if! sym2builtInTypeMap[ name ] {
      return _exp;
   }
   return nil;
      
   // if not onlySameNsFlag or not self.ownerTypeInfo or
   //    self.ownerTypeInfo$.$kind == TypeInfoKind.Module
   // {
   //    if self.parent ~= self {
   //       return self.parent.getSymbolInfo( name, fromScope, onlySameNsFlag, access );
   //    }
   // }
   // if onlySameNsFlag and self.ownerTypeInfo and
   //    self.ownerTypeInfo$.$kind ~= TypeInfoKind.Module
   // {
   //    return nil;
   // }
   // if! sym2builtInTypeMap[ name ] {
   //    return _exp;
   // }
   // return nil;
}

pub fn Scope.getTypeInfo(
   name: str, fromScope:&Scope, onlySameNsFlag:bool, access:ScopeAccess ) : &TypeInfo!
{
   let! symbolInfo = self.getSymbolInfo(name, fromScope, onlySameNsFlag, access ) {
      return nil;
   };
   return symbolInfo.$typeInfo;
}


/**
このスコープからシンボル name の型情報を取得する。
フィールドを除く name。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
*/
pub fn Scope.getSymbolTypeInfo( name: str, fromScope:&Scope,
                                moduleScope:&Scope, access:ScopeAccess ) : &SymbolInfo!
{
   let mut validThisScope = false;
   let mut limitSymbol = false;

   if! self.ownerTypeInfo {
      if _exp.$kind == .Func or _exp.$kind == .Method or
         self == moduleScope or self == rootScope
      {
         validThisScope = true;
      }
      elseif _exp.$kind == .IF or _exp.$kind == .Class or _exp.$kind == .Module
      {
         // class 系の場合、アクセスできるシンボルは self と Alternate に限定する
         limitSymbol = true;
         validThisScope = true;
      }
      elseif _exp.$kind == .Enum or _exp.$kind == .Alge {
         validThisScope = true;
      }
   }
   else {
      validThisScope = true;
   }
   if validThisScope {
      if! let symbolInfo = self.symbol2SymbolInfoMap[ name ] {
         if not limitSymbol or name == "self" or
            ( symbolInfo.$typeInfo.$kind == .Alternate and
              symbolInfo.$kind == .Typ )
         {
            return symbolInfo.canAccess( fromScope, access  );
         }
      }
   }
   if self.parent ~= self {
      return self.parent.getSymbolTypeInfo( name, fromScope, moduleScope, access );
   }
   return sym2builtInTypeMap[ name ];
}


pub fn Scope.filterSymbolTypeInfo(
   fromScope:&Scope, moduleScope:&Scope, access:ScopeAccess, callback:filterForm )
{
   if self.classFlag {
      if! self.symbol2SymbolInfoMap[ "self" ] {
         callback( _exp );
      }
   }
   if moduleScope == fromScope or moduleScope == self or not self.classFlag {
      foreach symbolInfo in self.symbol2SymbolInfoMap {
         if not callback( symbolInfo ) {
            return;
         }
      }
   }

   if self.parent ~= self {
      self.parent.filterSymbolTypeInfo( fromScope, moduleScope, access, callback );
   }
}


pub fn Scope.add(
   kind: SymbolKind, canBeLeft:bool, canBeRight:bool, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo, accessMode:AccessMode, staticFlag:bool,
   mutMode:MutMode, hasValueFlag:bool ) mut : &SymbolInfo!, &SymbolInfo!
{
   switch kind {
      case .Typ, .Fun {
         let existSymbol;
         switch typeInfo.$kind {
            case .Enum {
               if self.ownerTypeInfo$.$kind == .Class {
                  existSymbol = self.getSymbolInfoField(name, true, self, .Full);
               }
               else {
                  existSymbol = self.getSymbolInfo( name, self, true, .Full );
               }
            }
            default {
               existSymbol = self.getSymbolInfo( name, self, true, .Full );
            }
         }
         when! existSymbol {
            if typeInfo.$kind ~= existSymbol.$typeInfo.$kind or
               not isBuiltin( existSymbol.$typeInfo.$typeId )
            {
               return nil, existSymbol;
            }
         }
      }
   }
   
   let mut symbolInfo = new NormalSymbolInfo(
      kind, canBeLeft, canBeRight, self, accessMode, staticFlag,
      name, pos, typeInfo, mutMode, hasValueFlag );
   self.symbol2SymbolInfoMap[ name ] = symbolInfo;
   return symbolInfo, nil;
}

pub fn Scope.addLocalVar(
   argFlag:bool, canBeLeft:bool, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo, mutable:MutMode ) mut : &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      argFlag and SymbolKind.Arg or SymbolKind.Var,
      canBeLeft, true, name, pos, typeInfo, .Local, false, mutable, true )**;
}

pub let dummySymbol =
   unwrap rootScope.addLocalVar( false, false, "$$", nil, headTypeInfo, .IMut );

pub fn Scope.addStaticVar(
   argFlag:bool, canBeLeft:bool, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo, mutable:MutMode ) mut : &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      argFlag and SymbolKind.Arg or SymbolKind.Var,
      canBeLeft, true, name, pos, typeInfo, .Local, true, mutable, true )**;
}

pub fn Scope.addVar(
   accessMode:AccessMode, name:str, pos:&Parser.Position!,
   typeInfo: &TypeInfo, mutable:MutMode, hasValueFlag:bool ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add( SymbolKind.Var, true, true, name, pos, typeInfo,
                    accessMode, false, mutable, hasValueFlag )**;
}


pub fn Scope.addEnumVal( name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add( SymbolKind.Mbr, false, true,
                    name, pos, typeInfo, .Pub, true, .Mut, true )**;
}

pub fn Scope.addEnum(
   accessMode:AccessMode, name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add( SymbolKind.Typ, false, false,
                    name, pos, typeInfo, accessMode, true, .Mut, true )**;
}

pub fn Scope.addAlgeVal( name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add( SymbolKind.Mbr, false, true,
                    name, pos, typeInfo, .Pub, true, .Mut, true )**;
}

pub fn Scope.addAlge(
   accessMode:AccessMode, name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add( SymbolKind.Typ, false, false,
                    name, pos, typeInfo, accessMode, true, .Mut, true )**;
}

pub fn Scope.addAlternate(
   accessMode:AccessMode, name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Typ, false, false,
             name, pos, typeInfo, accessMode, true, .Mut, true );
}

pub fn Scope.addMember(
   name:str, pos:&Parser.Position!, typeInfo: &TypeInfo, accessMode:AccessMode,
   staticFlag:bool, mutMode:MutMode ) mut : &SymbolInfo!, &SymbolInfo!
{
   return self.add( SymbolKind.Mbr, true, true, name, pos,
                    typeInfo, accessMode, staticFlag, mutMode, true )**;
}

pub fn Scope.addMethod(
   pos:&Parser.Position!, typeInfo: &TypeInfo,
   accessMode:AccessMode, staticFlag:bool, mutable:bool ) mut
{
   self.add( SymbolKind.Mtd, true, staticFlag, typeInfo.$rawTxt, pos,
             typeInfo, accessMode,
             staticFlag, mutable and MutMode.Mut or MutMode.IMut, true );
}

pub fn Scope.addFunc(
   pos:&Parser.Position!, typeInfo: &TypeInfo,
   accessMode:AccessMode, staticFlag:bool, mutable:bool ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   return self.add(
      SymbolKind.Fun, true, true, typeInfo.$rawTxt, pos, typeInfo, accessMode,
      staticFlag, mutable and MutMode.Mut or MutMode.IMut, true )**;
}

pub fn Scope.addForm(
   pos:&Parser.Position!, typeInfo: &TypeInfo, accessMode:AccessMode ) mut
{
   self.add( .Typ, false, false, typeInfo.$rawTxt, pos, typeInfo, accessMode,
             true, .IMut, false );
}

pub fn Scope.addMacro(
   pos:&Parser.Position!, typeInfo: &TypeInfo, accessMode:AccessMode ) mut
{
   self.add( SymbolKind.Mac, false, false, typeInfo.$rawTxt, pos,
             typeInfo, accessMode, true, .IMut, true );
}


pub fn Scope.addClass( name:str, pos:&Parser.Position!, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Typ, false, false, name, pos, typeInfo,
             typeInfo.$accessMode, true, .Mut, true );
}


/**
デバッグ用。 scope 内のシンボル情報を出力する。
*/
pub fn dumpScope( workscope: &Scope!, workprefix:str ) {

   /**
デバッグ用。 scope 内のシンボル情報を出力する。
*/
   fn dumpScopeSub( scope: &Scope!, prefix:str, readyIdSet:Set<&Scope> ) {
      if! scope {
         if readyIdSet.has( _exp ) {
            return;
         }
         readyIdSet.add( _exp );
         if #prefix > 20 {
            Util.err("illegal");
         }

         forsort symbolInfo, symbol in _exp.$symbol2SymbolInfoMap {
            Util.log( "scope: %s, %s, %s" ( prefix, _exp, symbol ) );
            if! let subScope = symbolInfo.$typeInfo.$scope {
               dumpScopeSub( subScope, prefix .. "  ", readyIdSet );
            }
         }
      };
   }

   dumpScopeSub( workscope, workprefix, (@) );
}

/**
スコープを遡って、クロージャのシンボルを登録する。

事前に isClosureAccess() で、 symbol がクロージャであることを判定しておく必要がある。
*/
pub fn Scope.setClosure( symbol:&SymbolInfo ) mut {
   let targetFuncType = symbol.$namespaceTypeInfo;
   let mut funcType = self.getNamespaceTypeInfo();
   
   while true {
      let mut funcScope = unwrap funcType.$scope;
      if not funcScope.closureSymMap[ symbol.$symbolId ] {
         funcScope.closureSymMap[ symbol.$symbolId ] = symbol;
         funcScope.closureSym2NumMap[ symbol ] = #funcScope.closureSymList;
         funcScope.closureSymList.insert( symbol );
         funcType = funcScope.parent.getNamespaceTypeInfo();
      }
      else {
         break;
      }
      if funcType == targetFuncType {
         break;
      }
   }
   if not symbol.$hasAccessFromClosure {
      symbol.set_hasAccessFromClosure( true );
   }
}

/**
@param moduleScope このモジュールの最上位スコープ
@param symbol シンボル
*/
pub fn Scope.isClosureAccess( moduleScope:&Scope, symbol:&SymbolInfo) : bool
{
   switch symbol.$kind {
      case .Var, .Arg, .Fun {
         if symbol.$scope == moduleScope or symbol.$scope == rootScope {
            // symbol が、最上位スコープで定義されているなら、
            // 大域変数なのでクロージャではない
         }
         elseif symbol.$name == "self" {
            let funcType = self.getNamespaceTypeInfo();
            if funcType.$parentInfo.isInheritFrom(
               symbol.$namespaceTypeInfo.$parentInfo ## )
            {
               // self の場合、メソッド内からのアクセスはクロージャではない
            }
            else {
               return true;
            }
         }
         else {
            // このシンボルアクセスが、クロージャかどうかを確認する。
            // symbol の定義位置が異なる名前空間の場合、クロージャとして判定する。
            let funcType = self.getNamespaceTypeInfo();
            if funcType ~= symbol.$namespaceTypeInfo {
               // クロージャならシンボル情報を登録する。
               return true;
            }
         }
      }
   }
   return false;
}


/**
@param moduleScope このモジュールの最上位スコープ
@param symbol シンボル
*/
pub fn Scope.accessSymbol( moduleScope:&Scope, symbol:&SymbolInfo ) mut
{
   if self.isClosureAccess( moduleScope, symbol ) {
      self.setClosure( symbol );
   }
}




/**

*/
pub fn TypeInfo.createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
   return CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( detectFlag );
}


pub class NilTypeInfo extend TypeInfo {
   pri let typeId:int {pub};

   pub fn __init() {
      super( nil );

      idProv.increment();
      self.typeId = idProv.$id;
   }

   /** この型がモジュールを示す型の場合 true  */
   pub override fn isModule(): bool {
      return false;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "nil";
   }


   /** other 型からこの型への canEvalType の評価が可能かどうか */
   pub override fn canEvalWith(
      other:&TypeInfo, canEvalType:CanEvalType,
      alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return other.$nilable, nil;
   }

   /** 表示用文字列取得 */
   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( "nil" );
   }


   /** この型と typeInfo が等しいかどうか */
   pub override fn equals( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      return self == typeInfo;
   }

   /** 名前空間の親 */
   pub override fn get_parentInfo(): &TypeInfo {
      return headTypeInfo;
   }

   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報が宣言されているか？
   */
   pub override fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      return true;
   }

   /** シンプルな型名 */
   pub override fn get_rawTxt(): str {
      return "nil";
   }
   /** 型の種別 */
   pub override fn get_kind(): TypeInfoKind {
      return .Prim;
   }
   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }
   /** nilable かどうか */
   pub override fn get_nilable(): bool {
      return true;
   }
   /** mutable かどうか */
   pub override fn get_mutMode(): MutMode {
      return .IMut;
   }

   /** 親の完全限定名を取得する */
   pub override fn getParentFullName(
      typeNameCtrl:&TypeNameCtrl, 
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "";
   }
}


pub fn Scope.getClassTypeInfo(): &TypeInfo {
   let mut scope = self;
   while true {
      if! let owner = scope.ownerTypeInfo {
         switch owner.$kind {
            case .Class, .IF, .Module {
               return owner;
            }
         }
      }
      if scope.parent == scope {
         break;
      }
      scope = scope.parent;
   }
   return headTypeInfo;
}


/**
このシンボルが、fromScope のスコープからアクセスできるか調べる。
 */
pub override fn NormalSymbolInfo.canAccess(
   fromScope:&Scope, access:ScopeAccess ) : &SymbolInfo!
{
   if access == .Full {
      return self;
   }
   
   let typeInfo = self.$typeInfo;
   if self.scope == fromScope {
      return self;
   }
   switch self.$accessMode {
      case .Pub, .Global {
         return self;
      }
      case .Pro {
         let nsClass = self.scope.getClassTypeInfo();
         let fromClass = fromScope.getClassTypeInfo();
         if fromClass.isInheritFrom( nsClass, nil ) {
            return self;
         }
         return nil;
      }
      case .Local {
         return self;
      }
      case .Pri {
         // let nsClass = self.scope.getClassTypeInfo();
         // let fromClass = fromScope.getClassTypeInfo();
         // if nsClass == fromClass {
         //    return self;
         // }
         // return nil;
         if fromScope.isInnerOf( self.scope ) {
            return self;
         }
         return nil;
      }
   }
   Util.err( "illegl accessmode -- %s, %s"
             (self.$accessMode, self.$name) );
}


pub class AccessSymbolInfo extend SymbolInfo {
   pri let symbolInfo: SymbolInfo {pub};
   pri let prefixTypeInfo: TypeInfo! {pub};
   pri let overrideCanBeLeft: bool;

   pub override fn getOrg(): &SymbolInfo {
      return self.symbolInfo.getOrg();
   }

   pub override fn get_mutable(): bool {
      if! self.prefixTypeInfo {
         switch self.symbolInfo.$mutMode {
            case .AllMut {
               return true;
            }
            case .IMut, .IMutRe {
               return false;
            }
         }
         return TypeInfo.isMut( _exp );
      }
      return self.symbolInfo.$mutable;
   };

   pub override fn get_canBeLeft(): bool {
      if not self.overrideCanBeLeft {
         return false;
      }
      // if not self.symbolInfo.$canBeLeft {
      //    return false;
      // }
      // return self.get_mutable();
      // if! self.prefixTypeInfo {
      //    switch self.symbolInfo.$mutMode {
      //       case .AllMut {
      //          return true;
      //       }
      //       case .IMut {
      //          return false;
      //       }
      //    }
      //    return _exp.$mutMode ~= .IMut;
      // }
      // return true;
      // if! self.prefixTypeInfo {
      //    if _exp.$mutMode == .IMut {
      //       return false;
      //    }
      // }
      return self.symbolInfo.$canBeLeft;
   }

   advertise symbolInfo;
}


pub class NilableTypeInfo extend TypeInfo {
   pri let nonnilableType: &TypeInfo { pub };
   pri let typeId: int { pub };

   // pub fn __init( nonnilableType: &TypeInfo, typeId: int ) {
   //    super( nil );
   //    self.nonnilableType = nonnilableType;
   //    self.typeId = typeId;
   // }
   _lune_control default__init_old;

   pub override fn get_kind(): TypeInfoKind {
      return .Nilable;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_nilable(): bool {
      return true;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.nonnilableType.getTxtWithRaw(
         raw, typeNameCtrl, importInfo, localFlag ) .. "!";
   }


   pub override fn get_display_stirng_with( raw:str ): str {
      return self.nonnilableType.get_display_stirng_with( raw ) .. "!";
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, nilable = true, orgTypeId = %d }\n' (
            SerializeKind.Nilable, parentId, self.typeId, self.nonnilableType.$typeId ) );
   }

   pub override fn equals( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      if not typeInfo.$nilable {
         return false;
      }
      return self.nonnilableType.equals(
         typeInfo.$nonnilableType, alt2type, checkModifer );
   }

   pub override fn applyGeneric(
      alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ): &TypeInfo!
   {
      let typeInfo = self.nonnilableType.applyGeneric( alt2typeMap, moduleTypeInfo );
      if typeInfo == self.nonnilableType {
         return self;
      }
      when! typeInfo {
         return typeInfo.$nilableTypeInfo;
      }
      return nil;
   }

   advertise nonnilableType;
}



/**
Generic クラスや関数で利用する代用型。

Set<T> の T を表わす型情報。
*/
pub class AlternateTypeInfo extend TypeInfo {
   pri let typeId:int {pub};
   pri let txt:str {pub};
   pri let moduleTypeInfo:&TypeInfo;
   pri let nilableTypeInfo: NilableTypeInfo {pub:&TypeInfo};
   pri let accessMode: AccessMode {pub};
   // 基底クラス。 無効な場合は headTypeInfo。
   pri let baseTypeInfo: &TypeInfo { pub };
   // インタフェースのリスト。
   pri let interfaceList: &List<&TypeInfo> { pub };

   /** クラスの型パラメータとして使う場合 true */
   pri let belongClassFlag: bool;
   /** 何番目の型パラメータか */
   pri let altIndex:int;


   pub fn __init( belongClassFlag:bool, altIndex:int,
                  txt:str, accessMode:AccessMode, moduleTypeInfo:&TypeInfo,
                  baseTypeInfo: &TypeInfo!, interfaceList: &List<&TypeInfo>! )
   {
      super( TypeInfo.createScope( nil, true, baseTypeInfo, interfaceList ) );

      idProv.increment();
      self.typeId = idProv.$id;

      self.txt = txt;
      self.accessMode = accessMode;
      self.moduleTypeInfo = moduleTypeInfo;
      self.baseTypeInfo = unwrap baseTypeInfo default headTypeInfo;
      self.interfaceList = unwrap interfaceList default [];
      self.belongClassFlag = belongClassFlag;
      self.altIndex = altIndex;

      idProv.increment();
      self.nilableTypeInfo = new NilableTypeInfo( self, idProv.$id );
   }

   /** この型がモジュールを示す型の場合 true  */
   pub override fn isModule(): bool {
      return false;
   }

   /** 親の typeId  */
   pub override fn getParentId(): int {
      return self.moduleTypeInfo.$typeId;
   }

   pub override fn get_baseId(): int {
      return self.baseTypeInfo.$typeId;
   }

   pub override fn get_parentInfo(): &TypeInfo {
      return self.moduleTypeInfo;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.txt;
   }

   pub static fn getAssign(
      typeInfo:&TypeInfo, alt2type:&Map<&TypeInfo,&TypeInfo> ) : &TypeInfo;
   

   pri fn canSetFrom(
      other:&TypeInfo, canEvalType:CanEvalType!, alt2type:Map<&TypeInfo,&TypeInfo> ): bool
   {
      let otherWork = AlternateTypeInfo.getAssign( other, alt2type );
      if self == otherWork {
         return true;
      }

      if! let genType = alt2type[ self ] {
         when! canEvalType {
            return (genType.canEvalWith( otherWork, canEvalType, alt2type ));
         }
         return genType.equals( otherWork, alt2type ## );
      }
      if not CanEvalCtrlTypeInfo.isValidApply( alt2type ) {
         return false;
      }

      if self.baseTypeInfo ~= headTypeInfo {
         if not other.isInheritFrom( self.baseTypeInfo, alt2type ) {
            return false;
         }
      };
      foreach ifType in self.interfaceList {
         if not other.isInheritFrom( ifType, alt2type ) {
            return false;
         }
      }

      alt2type[ self ] = otherWork;
      return true;
   }

   /** この型が other を継承しているかどうか */
   pub override fn isInheritFrom(
      other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool
   {
      when! alt2type {
         let otherWork = AlternateTypeInfo.getAssign( other, alt2type );
         if self == otherWork.$srcTypeInfo {
            return true;
         }

         if! let genType = alt2type[ self ] {
            return genType.isInheritFrom( otherWork, alt2type );
         }
         if not CanEvalCtrlTypeInfo.isValidApply( alt2type ) {
            return false;
         }
      }
      if self == other.$srcTypeInfo {
         return true;
      }

      fn check(): bool {
         if self.baseTypeInfo ~= headTypeInfo {
            if self.baseTypeInfo.isInheritFrom( other, alt2type ) {
               return true;
            }
         };
         foreach ifType in self.interfaceList {
            if ifType.isInheritFrom( other, alt2type ) {
               return true;
            }
         }
         return false;
      }

      if check() {
         when! alt2type {
            alt2type[ self ] = other;
         }
         return true;
      }
      return false;
   }


   /** other 型からこの型への canEvalType の評価が可能かどうか */
   pub override fn canEvalWith(
      other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      if self == other.$srcTypeInfo {
         return true, nil;
      }
      if other.$nilable {
         return false, nil;
      }
      if not self.belongClassFlag {
         if! let altType = other@@@AlternateTypeInfo {
            if not altType.belongClassFlag and
               altType.altIndex == self.altIndex
            {
               // 関数の型パラメータは、インデックスが同じならば同じものとする
               return true, nil;
            }
         }
      }

      //let mut otherWork = unwrap other.applyGeneric( alt2type ) default other;
      return self.canSetFrom( other, canEvalType, alt2type ), nil;
      // let otherWork = AlternateTypeInfo.getAssign( other, alt2type );
      // if! let genType = alt2type[ self ] {
      //    return genType.canEvalWith( otherWork, canEvalType, alt2type );
      // }
      // if not CanEvalCtrlTypeInfo.isValidApply( alt2type ) {
      //    return false;
      // }
      // alt2type[ self ] = otherWork;
      // return true;
   }

   /** 表示用文字列取得 */
   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.txt );
   }


   /** この型と typeInfo が等しいかどうか */
   pub override fn equals( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      if self == typeInfo {
         return true;
      }
      if not self.belongClassFlag {
         if! let altType = typeInfo@@@AlternateTypeInfo {
            if not altType.belongClassFlag and
               altType.altIndex == self.altIndex
            {
               // 関数の型パラメータは、インデックスが同じならば同じものとする
               return true;
            }
         }
      }

      when! alt2type {
         return self.canSetFrom( typeInfo, nil, alt2type );

         // let mut otherWork = AlternateTypeInfo.getAssign( typeInfo, alt2type );
         // if! let genType = alt2type[ self ] {
         //    return genType.equals( otherWork, alt2type );
         // }
         // if not CanEvalCtrlTypeInfo.isValidApply( alt2type ) {
         //    return false;
         // }
         // alt2type[ self ] = otherWork;
         // return true;
      }
      return false;
   }

   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報が宣言されているか？
   */
   pub override fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      return true;
   }

   /** シンプルな型名 */
   pub override fn get_rawTxt(): str {
      return self.txt;
   }
   /** 型の種別 */
   pub override fn get_kind(): TypeInfoKind {
      return .Alternate;
   }
   /** nilable かどうか */
   pub override fn get_nilable(): bool {
      return false;
   }
   /** mutable かどうか */
   pub override fn get_mutMode(): MutMode {
      return .Mut;
   }

   /** 親の完全限定名を取得する */
   pub override fn getParentFullName(
      typeNameCtrl:&TypeNameCtrl, 
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "";
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, txt = %q, '
         ( SerializeKind.Alternate, parentId, self.typeId, self.txt ) ..
         'accessMode = %d, baseId = %d, ' ( self.accessMode, self.$baseId ) ..
         'belongClassFlag = %s, altIndex = %d, ' (self.belongClassFlag, self.altIndex ));

      stream.write( self.serializeTypeInfoList( "ifList = {", self.interfaceList## ) );
      stream.write( "}\n" );
   }

   pub override fn applyGeneric(
      alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ): &TypeInfo!
   {
      return AlternateTypeInfo.getAssign( self, alt2typeMap );
   }
}

let boxRootAltType = new AlternateTypeInfo( true, 1, "_T", .Pub, headTypeInfo ## );
let mut boxRootScope = new Scope( rootScope, true, nil## );

pub class BoxTypeInfo extend TypeInfo {
   pri let boxingType: &TypeInfo {pub};
   pri let typeId: int { pub };
   pri let itemTypeInfoList: &List<&TypeInfo> {pub};
   pri let accessMode: AccessMode {pub};
   pri let nilableTypeInfo: NilableTypeInfo {pub:&TypeInfo};

   pub fn __init( typeId: int, accessMode:AccessMode, boxingType: &TypeInfo ) {
      super( boxRootScope );
      self.boxingType = boxingType;
      self.typeId = typeId;
      self.itemTypeInfoList = [ boxingType ];
      self.accessMode = accessMode;

      idProv.increment();
      self.nilableTypeInfo = new NilableTypeInfo( self, idProv.$id );
   }

   pub override fn get_scope(): Scope! {
      return super();
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Box;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_nonnilableType(): &TypeInfo {
      return self;
   }
   pub override fn get_nilable(): bool {
      return false;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "Nilable<" .. self.boxingType.getTxtWithRaw(
         raw, typeNameCtrl, importInfo, localFlag ) .. ">";
   }

   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return "Nilable<%s>" (self.boxingType.get_display_stirng_with( raw ) );
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, accessMode = %d, boxingType = %d }\n' (
            SerializeKind.Box, parentId, self.typeId,
            self.accessMode, self.boxingType.$typeId ) );
   }

   pub override fn equals( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      if! let boxType = typeInfo@@@BoxTypeInfo {
         return self.boxingType.equals( boxType.boxingType, alt2type , checkModifer );
      }
      return false;
   }

   pub override fn createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      let mut map:Map<&TypeInfo,&TypeInfo> =
         CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( detectFlag );
      if self.boxingType ~= boxRootAltType {
         map[ boxRootAltType ] = self.boxingType;
      }
      return map;
   }

   advertise boxingType;
}


/**
Generic クラスの型確定後の型情報。

Set<T> の Set<int> を表わす型情報。
*/
pub class GenericTypeInfo extend TypeInfo {
   pri let typeId:int {pub};
   pri let itemTypeInfoList:&List<&TypeInfo> {pub};
   pri let nilableTypeInfo: NilableTypeInfo {pub:&TypeInfo};
   pri let genSrcTypeInfo:&TypeInfo {pub};
   pri let moduleTypeInfo:&TypeInfo;
   pri let alt2typeMap:&Map<&TypeInfo,&TypeInfo>;
   pri let hasAlter:bool;



   pub fn __init( genSrcTypeInfo:&TypeInfo,
                  itemTypeInfoList:&List<&TypeInfo>, moduleTypeInfo:&TypeInfo )
   {
      super( TypeInfo.createScope( (unwrap genSrcTypeInfo.$scope).$parent,
                                   true, genSrcTypeInfo, nil ) );

      idProv.increment();
      self.typeId = idProv.$id;
      self.moduleTypeInfo = moduleTypeInfo;

      self.itemTypeInfoList = itemTypeInfoList;
      self.genSrcTypeInfo = genSrcTypeInfo;

      if #genSrcTypeInfo.$itemTypeInfoList ~= #itemTypeInfoList {
         Util.err( "unmatch generic type number -- %d, %d"
                   (#genSrcTypeInfo.$itemTypeInfoList, #itemTypeInfoList) );
      }
      let mut alt2typeMap:Map<&TypeInfo,&TypeInfo> = {};
      let mut workAlt2typeMap = CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
      let mut hasAlter = false;
      foreach altTypeInfo, index in genSrcTypeInfo.$itemTypeInfoList {
         let itemType = itemTypeInfoList[ index ];
         alt2typeMap[ altTypeInfo ] = itemType;
         if itemType.applyGeneric( workAlt2typeMap, moduleTypeInfo ) ~= itemType
         {
            hasAlter = true;
         }
      }
      self.hasAlter = hasAlter;
      self.alt2typeMap = alt2typeMap;

      idProv.increment();
      self.nilableTypeInfo = new NilableTypeInfo( self, idProv.$id );
   }

   pub override fn getModule(): &TypeInfo {
      return self.moduleTypeInfo;
   }

   /** この型が other を継承しているかどうか */
   pub override fn isInheritFrom(
      other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool
   {
      let otherSrc = other.$genSrcTypeInfo;

      if not self.genSrcTypeInfo.isInheritFrom( otherSrc, alt2type ) {
         // Generic 元が継承していない場合は、この Generic クラスも継承していない
         return false;
      }
      // Generic 元が継承している

      // other は Generic
      let! genOther = other@@@GenericTypeInfo {
         // other は Generic でないので、この時点で確定
         return true;
      };
      let! mut workAlt2type = alt2type {
         workAlt2type = CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
      };
      foreach altType in otherSrc.$itemTypeInfoList {
         // otherSrc の altType に対応する Generic の型を取得し、
         // それの派生状態を確認。
         let! genType = self.alt2typeMap[ altType ] {
            return false;
         };
         let otherGenType = unwrap genOther.alt2typeMap[ altType ];
         // if not genType.isInheritFrom( otherGenType, alt2type ) {
         //    return false;
         // }


         // ここの .SetOp と .SetEq を制御する
         if not otherGenType.canEvalWith( genType, .SetEq, workAlt2type ) {
            return false;
         }
      }
      return true;
   }

   /** Modifier の元となる型情報 */
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }

   /** other 型からこの型への canEvalType の評価が可能かどうか */
   pub override fn canEvalWith(
      other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      if other.$nilable {
         return false, nil;
      }
      
      if TypeInfo.isMut( self ) and not TypeInfo.isMut( other ) {
         return false, nil;
      }

      let otherSrc = other.$srcTypeInfo;
      if self == otherSrc {
         return true, nil;
      }

      // other のスーパークラスを辿って、一致するか調べる
      let mut work = otherSrc;
      while true {
         if work == headTypeInfo {
            return false, nil;
         }
         foreach genType, altType in work.createAlt2typeMap( false ) {
            alt2type[ altType ] = genType;
         }
         if self.genSrcTypeInfo.equals( work.$genSrcTypeInfo, alt2type ## ) {
            break;
         }
         foreach ifType in work.$interfaceList {
            if self.canEvalWith( ifType, canEvalType, alt2type ) {
               return true, nil;
            }
         }
         work = work.$baseTypeInfo;
      }

      // 一致する場合、汎化の型も同じか調べる
      if! let otherGen = work@@@GenericTypeInfo {

         let evalType;
         if canEvalType == .SetOp {
            evalType = CanEvalType.SetEq;
         }
         else {
            evalType = canEvalType;
         }
         
         foreach val, key in self.alt2typeMap {
            let otherType = AlternateTypeInfo.getAssign(
               unwrap otherGen.alt2typeMap[ key ], alt2type );
            let ret, mess = val.canEvalWith( otherType, evalType, alt2type );
            if not ret {
               return false, mess;
            }
         }
      }
      return true, nil;
   }

   /** この型と typeInfo が等しいかどうか */
   pub override fn equals( other: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      if self == other {
         return true;
      }
      if self.$kind ~= self.$kind or
         #self.itemTypeInfoList ~= #other.$itemTypeInfoList
      {
         return false;
      }
      if not (other@@@GenericTypeInfo) {
         return false;
      }
      // if not isGenericType( other ) {
      //    return false;
      // }

      if not self.genSrcTypeInfo.equals( other.$genSrcTypeInfo, alt2type, checkModifer ) {
         return false;
      }

      foreach otherItem, index in other.$itemTypeInfoList {
         let typeInfo = self.itemTypeInfoList[ index ];
         if not typeInfo.equals( otherItem, alt2type, checkModifer ) {
            return false;
         }
      }
      return true;
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, genSrcTypeId = %d, genTypeList = {' (
            SerializeKind.Generic, parentId, self.typeId, self.genSrcTypeInfo.$typeId ) );
      let count = 0;
      foreach genType in self.alt2typeMap {
         if count > 0 {
            stream.write( "," );
         }
         stream.write( "%d" (genType.$typeId) );
      }
      stream.write( '} }\n' );
   }

   pub override fn createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      let mut map = self.genSrcTypeInfo.createAlt2typeMap( detectFlag );
      foreach typeInfo, genType in self.alt2typeMap {
         map[ genType ] = typeInfo;
      }
      return map;
   }

   advertise genSrcTypeInfo;
}


pub fn isGenericType( typeInfo: &TypeInfo ) : bool {
   if typeInfo@@@GenericTypeInfo {
      return true;
   }
   return false;
}

pub class ModifierTypeInfo extend TypeInfo {
   pri let srcTypeInfo: &TypeInfo { pub };
   pri let typeId: int { pub };
   pri let mutMode: MutMode { pub };

   // pub fn __init( srcTypeInfo: &TypeInfo, typeId: int, mutMode: MutMode ) {
   //    super( nil );
   //    self.srcTypeInfo = srcTypeInfo;
   //    self.typeId = typeId;
   //    self.mutMode = mutMode;
   // }
   _lune_control default__init_old;

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str,  typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      let mut txt = self.srcTypeInfo.getTxtWithRaw(
         raw, typeNameCtrl, importInfo, localFlag );
      if not isMutable( self.mutMode ) {
         txt = "&" .. txt;
      }
      return txt;
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      let mut txt = self.srcTypeInfo.get_display_stirng_with( raw );
      if isMutable( self.mutMode ) {
         txt = "mut " .. txt;
      }
      return txt;
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, srcTypeId = %d, mutMode = %d }\n' (
            SerializeKind.Modifier, parentId, self.typeId, self.srcTypeInfo.$typeId,
            self.mutMode ) );
   }

   pub override fn canEvalWith(
      other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      // if isGenericType( self.srcTypeInfo ) {
      //    return self.srcTypeInfo.canEvalWith( other, canEvalType, alt2type );
      // }

      let evalType;
      if #self.srcTypeInfo.$itemTypeInfoList >= 1 {
         switch canEvalType {
            case .SetEq, .SetOp {
               // &List<Super> <-- List<Sub> などで、 型パラメータの継承を代入可能にする
               evalType = CanEvalType.SetOpIMut;
            }
            default {
               evalType = canEvalType;
            }
         }
      }
      else {
         evalType = canEvalType;
      }


      return TypeInfo.canEvalWithBase(
         self.srcTypeInfo, TypeInfo.isMut( self ),
         other.$srcTypeInfo, evalType, alt2type )**;
   }

   pub override fn equals(
      typeInfo: TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!, checkModifer:bool! ): bool
   {
      if checkModifer {
         if TypeInfo.isMut( self ) ~= TypeInfo.isMut( typeInfo ) {
            return false;
         }
      }
      return self.srcTypeInfo.equals( typeInfo.$srcTypeInfo, alt2type, checkModifer );
   }

   advertise srcTypeInfo;
}



pub class ModuleTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   //
   pri let mutable: bool {pub};

   pub fn __init( scope: Scope, externalFlag: bool,
                  txt: str, mut parentInfo: &TypeInfo!, typeId: int, mutable:bool )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = typeId;
      self.mutable = mutable;

      if! parentInfo {
         _exp.addChildren( self );
      }

      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;


      scope.set_ownerTypeInfo( self );
   }

   pub override fn isModule(): bool {
      return true;
   }

   pub override fn get_accessMode(): AccessMode {
      return AccessMode.Pub;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Module;
   }

   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return rawTxt;
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }
   pub override fn canEvalWith(
      other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return false, nil;
   }

   pub override fn serialize(
      stream: oStream, validChildrenSet: Map<int,&TypeInfo>! )
   {
      let txt = "{ skind = %d, parentId = %d, typeId = %d, txt = '%s', kind = %d, "
          ( SerializeKind.Module,
            self.getParentId(), self.typeId, self.rawTxt, TypeInfoKind.Module );
      stream.write( txt .. '\n' );

      stream.write( "children = {" );

      let! set = validChildrenSet {
         set = {};
      };
      if! validChildrenSet {
         foreach child in self.$children {
            if set[ child.$typeId ] and
               ( child.$accessMode == .Pub or child.$accessMode == .Global ) {
               stream.write( "%d, " ( child.$typeId ) );
            }
         }
      }
      stream.write( "} }\n" );
   }
}

pub alge EnumLiteral {
   Int( val:int ),
   Real( val:real ),
   Str( val:str ),
}
pub fn getEnumLiteralVal( obj:EnumLiteral ) : stem {
   match obj {
      case .Int( val ) {
         return val;
      }
      case .Real( val ) {
         return val;
      }
      case .Str( val ) {
         return val;
      }
   }
   Util.err( "illegal enum " .. obj.$_txt );
}


pub class EnumValInfo {
   pri let name: str {pub};
   pri let val:EnumLiteral {pub};
}

pub class EnumTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   pri let nilableTypeInfo: &TypeInfo { pub };

   // この enum で格納している値の型
   pri let valTypeInfo: &TypeInfo {pub};


   // enum 値名 -> EnumValInfo
   pri let mut name2EnumValInfo: Map<str,&EnumValInfo> { pub& };
   pri let mut val2EnumValInfo: Map<&stem,&EnumValInfo> { pub& };

   pub fn __init( scope: Scope, externalFlag: bool, accessMode: AccessMode,
                  txt: str, parentInfo: &TypeInfo!, typeId: int, valTypeInfo:&TypeInfo )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = typeId;
      self.name2EnumValInfo = {};
      self.valTypeInfo = valTypeInfo;

      self.val2EnumValInfo = {};


      if! parentInfo {
         _exp.addChildren( self );
      }

      self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;

      scope.set_ownerTypeInfo( self );
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Enum;
   }

   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return rawTxt;
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn canEvalWith(
      other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return self == other.$srcTypeInfo, nil;
   }

   pub fn addEnumValInfo( valInfo:&EnumValInfo ) mut {
      self.name2EnumValInfo[ valInfo.$name ] = valInfo;
      self.val2EnumValInfo[ getEnumLiteralVal( valInfo.$val ) ] = valInfo;
   }

   pub fn getEnumValInfo( name:str ): &EnumValInfo! {
      return self.name2EnumValInfo[ name ];
   }

   pub override fn get_mutMode(): MutMode {
      return .Mut;
   };
}



pub class AlgeValInfo {
   pri let name: str {pub};
   pri let typeList:&List<&TypeInfo> {pub};

   pub fn serialize( stream: oStream ) {
      stream.write( "{ name = '%s', typeList = {" (self.name) );
      foreach typeInfo, index in self.typeList {
         if index > 1 {
            stream.write( ", " );
         }
         stream.write( "%d" ( typeInfo.$typeId ) );
      }
      stream.write( "} }" );
   }
}

pub class AlgeTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   pri let nilableTypeInfo: &TypeInfo { pub };

   pri let mut valInfoMap:Map<str,&AlgeValInfo> {pub};


   pub fn __init( scope: Scope, externalFlag: bool, accessMode: AccessMode,
                  txt: str, parentInfo: &TypeInfo!, typeId: int )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = typeId;
      self.valInfoMap = {};

      if! parentInfo {
         _exp.addChildren( self );
      }

      self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;


      scope.set_ownerTypeInfo( self );
   }

   pub fn addValInfo( valInfo:&AlgeValInfo ) mut {
      self.valInfoMap[ valInfo.$name ] = valInfo;
   }

   pub fn getValInfo( name:str ) : &AlgeValInfo! {
      return self.valInfoMap[ name ];
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Alge;
   }

   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return rawTxt;
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn canEvalWith(
      other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return self == other.$srcTypeInfo, nil;
   }

   pub override fn get_mutMode(): MutMode {
      return .Mut;
   };
}



pub class NormalTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // generic のタイプ
   pri let itemTypeInfoList: List<&TypeInfo> { pub };
   // 引数のタイプ
   pri let argTypeInfoList: List<&TypeInfo> { pub };
   // 戻り値のタイプ
   pri let retTypeInfoList: List<&TypeInfo> { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // タイプの種別
   pri let kind: TypeInfoKind { pub };
   // static かどうか
   pri let staticFlag: bool { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   // コンパイラで自動生成された型情報の場合 true。 accessor 等。
   pri let autoFlag: bool { pub };
   /** */
   pri let abstractFlag: bool { pub };

   // 基底クラス。 無効な場合は headTypeInfo。
   pri let baseTypeInfo: &TypeInfo { pub };
   // インタフェースのリスト。
   pri let interfaceList: List<&TypeInfo> { pub };

   // この型の nilable 版の TypeInfo。 無効な場合は headTypeInfo。
   pri let mut nilableTypeInfo: &TypeInfo { pub };
   // このメソッドの mutMode。
   pri let mut mutMode: MutMode {pub,pub};

   pri let alt2typeMap:Map<&TypeInfo,&TypeInfo>;

   fn __init( abstractFlag:bool, scope: Scope!, baseTypeInfo: &TypeInfo!,
              interfaceList: &List<&TypeInfo>!,
              autoFlag: bool, externalFlag: bool, staticFlag: bool,
              accessMode: AccessMode,
              txt: str, parentInfo: &TypeInfo!, typeId: int, kind: TypeInfoKind,
              itemTypeInfoList: &List<&TypeInfo>!, argTypeInfoList:&List<&TypeInfo>!,
              retTypeInfoList: &List<&TypeInfo>!, mutMode: MutMode! )
   {
      super( scope );

      if type(kind) ~= "number" {
         Util.printStackTrace();
      }

      self.abstractFlag = abstractFlag;
      self.baseTypeInfo = unwrap baseTypeInfo default headTypeInfo;
      self.interfaceList = unwrap interfaceList default [];
      self.autoFlag = autoFlag;
      self.externalFlag = externalFlag;
      self.staticFlag = staticFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.kind = kind;
      self.itemTypeInfoList = unwrap itemTypeInfoList default [];
      self.argTypeInfoList = unwrap argTypeInfoList default [];
      self.retTypeInfoList = unwrap retTypeInfoList default [];
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.mutMode = unwrap mutMode default MutMode.IMut;


      fn setupAlt2typeMap(): Map<&TypeInfo,&TypeInfo> {

         if self.baseTypeInfo == headTypeInfo and #self.interfaceList == 0 {
            return {};
         }
         let mut alt2typeMap:Map<&TypeInfo,&TypeInfo> = {};
         switch kind {
            case .Set, .Map, .List, .Array, .Box {
               if #self.itemTypeInfoList ~= #self.baseTypeInfo.$itemTypeInfoList {
                  Util.err( "unmatch generic type number -- %d, %d"
                            (#self.itemTypeInfoList,
                              #self.baseTypeInfo.$itemTypeInfoList ) );
               }
               foreach appyType, index in self.itemTypeInfoList {
                  let genType = self.baseTypeInfo.$itemTypeInfoList[ index ];
                  alt2typeMap[ genType ] = appyType;
               }
            }
            case .Class, .IF {
               // if! let genericType = self.baseTypeInfo@@@GenericTypeInfo {
               //    foreach genType, altType in genericType.createAlt2typeMap( false ) {
               //       alt2typeMap[ altType ] = genType;
               //    }
               // }
               foreach ifType in self.interfaceList {
                  if! let genericType = ifType@@@GenericTypeInfo {
                     foreach genType, altType in genericType.createAlt2typeMap( false ) {
                        alt2typeMap[ altType ] = genType;
                     }
                  }
               }
            }
         }
         return alt2typeMap;
      }

      self.alt2typeMap = setupAlt2typeMap();


      // if dummyRootTypeInfo and not parentInfo {
      //     Util.debugLog();
      //     error( "" );
      // }

      self.typeId = typeId;
      if kind == .Root {
         // dummyRootTypeInfo = self;
      }
      else {
         when! parentInfo {
            parentInfo.addChildren( self );
         }

         let mut hasNilable = false;

         switch ( kind ) {
            case .Prim, .List, .Array, .Set,
                 .Map, .Class, .Stem,
                 .Module, .IF
            {
               hasNilable = true;
            }
            case .Func, .Method, .Form, .FormFunc {
               hasNilable = true;
            }
         }
         if hasNilable {
            self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
            idProv.increment();
         }
         else {
            self.nilableTypeInfo = headTypeInfo;
         }
         idProv.increment();
      }
   }

   pub override fn createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      let mut map:Map<&TypeInfo,&TypeInfo> =
         self.baseTypeInfo.createAlt2typeMap( detectFlag );
      foreach typeInfo, genType in self.alt2typeMap {
         map[ genType ] = typeInfo;
      }
      return map;
   }

   // この型が nilable を表わす型かどうか。
   pub override fn get_nilable(): bool {
      return false;
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   pub override fn get_baseId(): int {
      return self.baseTypeInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!, 
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      mut raw:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      let mut parentTxt = "";
      when! typeNameCtrl {
         parentTxt = self.getParentFullName( typeNameCtrl, importInfo, localFlag );
      }
      // if self.kind == .Array {
      //    let! _exp = self.itemTypeInfoList[1] {
      //       return "[@]";
      //    };
      //    return _exp.getTxt() .. "[@]";
      // }
      // if self.kind == .List {
      //    let! _exp = self.itemTypeInfoList[1] {
      //       return "[]";
      //    };
      //    return _exp.getTxt() .. "[]";
      // }
      if #self.itemTypeInfoList > 0 {
         let mut txt = raw .. "<";
         foreach typeInfo, index in self.itemTypeInfoList {
            if index ~= 1 {
               txt = txt .. ",";
            }
            txt = txt .. typeInfo.getTxt( typeNameCtrl, importInfo, localFlag );
         }

         return parentTxt .. txt .. ">";
      }
      return parentTxt .. raw;
   }


   pub override fn get_display_stirng_with( raw:str ): str {
      switch self.kind {
         case .Func, .Form, .FormFunc, .Method, .Macro {
            let mut txt = raw .. "(";
            foreach argType, index in self.argTypeInfoList {
               if index ~= 1 {
                  txt = txt .. ", ";
               }
               txt = txt .. argType.get_display_stirng();
            }
            txt = txt .. ")";
            foreach retType, index in self.retTypeInfoList {
               if index == 1 {
                  txt = txt .. ": ";
               }
               else {
                  txt = txt .. ", ";
               }
               txt = txt .. retType.get_display_stirng();
            }
            return txt;
         }
      }
      return self.getTxtWithRaw( raw ##);
   }

   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }


   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      if self.typeId == rootTypeId {
         return;
      }

      let parentId = self.getParentId();

      let txt = ```{ skind=%d, parentId = %d, typeId = %d, baseId = %d, txt = '%s',
        abstractFlag = %s, staticFlag = %s, accessMode = %d, kind = %d, mutMode = %d, ```
          ( SerializeKind.Normal, parentId, self.typeId, self.get_baseId(), self.rawTxt,
            self.abstractFlag, self.staticFlag, self.accessMode, self.kind, self.mutMode );

      let mut children:List<&TypeInfo> = [];
      let! set = validChildrenSet {
         set = {};
      };
      foreach child in self.$children {
         if set[ child.$typeId ] {
            children.insert( child );
         }
      }

      stream.write(
         txt .. self.serializeTypeInfoList( "itemTypeId = {",
                                            self.itemTypeInfoList## ) ..
         self.serializeTypeInfoList( "ifList = {", self.interfaceList## ) ..
         self.serializeTypeInfoList( "argTypeId = {", self.argTypeInfoList## ) ..
         self.serializeTypeInfoList( "retTypeId = {", self.retTypeInfoList## ) ..
         self.serializeTypeInfoList( "children = {", children, true ) .. "}\n" );
   }

   pub fn equalsSub( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                     checkModifer:bool! ): bool
   {
      if self.typeId == typeInfo.$typeId {
         return true;
      }

      if typeInfo.$kind == .Alternate {
         return typeInfo.equals( self, alt2type, checkModifer );
      }

      // プリミティブな設定のチェック
      if self.kind ~= typeInfo.$kind or
         self.staticFlag ~= typeInfo.$staticFlag or
         self.autoFlag ~= typeInfo.$autoFlag or
         self.$nilable ~= typeInfo.$nilable or
         self.rawTxt ~= typeInfo.$rawTxt or
         self.parentInfo ~= typeInfo.$parentInfo or
         self.baseTypeInfo ~= typeInfo.$baseTypeInfo
         //  or
         // self ~= typeInfo.$srcTypeInfo
      {
         // errorLog( "%s, %s" ( self.externalFlag, typeInfo.externalFlag ) );
         // errorLog( "%s, %s" ( self.kind, typeInfo.kind ) );
         // errorLog( "%s, %s" ( self.staticFlag, typeInfo.staticFlag ) );
         // errorLog( "%s, %s" ( self.accessMode, typeInfo.accessMode ) );
         // errorLog( "%s, %s" ( self.autoFlag, typeInfo.autoFlag ) );
         // errorLog( "%s, %s" ( self.nilable, typeInfo.nilable ) );
         return false;
      }

      if self.accessMode ~= typeInfo.$accessMode {
         switch self.kind {
            case .List, .Map, .Array, .Set {
               // これらの型情報は、 accessMode に意味はあまりないので無視
            }
            default {
               return false;
            }
         }
      }


      // if ( self ~= typeInfo.$nonnilableType )
      // {
      //    Util.log( "%s, %s" ( self, typeInfo.$nonnilableType ) );
      //    //          error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
      //    //                                     typeInfo.getTxt(), typeInfo.typeId ) );
      //    return false;
      // }

      {
         if #self.itemTypeInfoList ~= #typeInfo.$itemTypeInfoList {
            return false;
         }
         foreach item, index in self.itemTypeInfoList {
            if not item.equals(
               typeInfo.$itemTypeInfoList[ index ], alt2type, checkModifer )
            {
               // error( "illegal %s:%d %s:%d"
               //    ( self.getTxt(), self.typeId,
               //      typeInfo.getTxt(), typeInfo.$typeId ) );
               return false;
            }
         }
      }

      {
         if #self.retTypeInfoList ~= #typeInfo.$retTypeInfoList {
            // error( "illegal %s:%d %s:%d"
            //    ( self.getTxt(), self.typeId,
            //      typeInfo.getTxt(), typeInfo.$typeId ) );
            return false;
         }
         foreach item, index in self.retTypeInfoList {
            if not item.equals(
               typeInfo.$retTypeInfoList[ index ], alt2type, checkModifer )
            {
               // error( "illegal %s:%d %s:%d"
               //    ( self.getTxt(), self.typeId,
               //      typeInfo.getTxt(), typeInfo.$typeId ) );
               return false;
            }
         }
      }

      // if not self.equals( typeInfo.$nonnilableType )
      // {
      //    error( "illegal %s:%d %s:%d" ( self.getTxt(##), self.typeId,
      //                                   typeInfo.getTxt(##), typeInfo.$typeId ) );
      // }
      return true;
   }

   pub override fn equals( typeInfo: TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      return self.equalsSub( typeInfo, alt2type, checkModifer );
   }


   // pub static fn cloneToPublic( typeInfo: TypeInfo ): NormalTypeInfo {
   //    typeIdSeed = typeIdSeed + 1;
   //    return new NormalTypeInfo(
   //       typeInfo.$scope, typeInfo.$baseTypeInfo, nil, typeInfo.$autoFlag,
   //       typeInfo.$externalFlag, typeInfo.$staticFlag,
   //       "pub", typeInfo.$rawTxt, typeInfo.$parentInfo, typeIdSeed, typeInfo.$kind,
   //       typeInfo.$itemTypeInfoList, typeInfo.$argTypeInfoList,
   //       typeInfo.$retTypeInfoList );
   // }



   pub static fn create(
      accessMode:AccessMode, abstractFlag: bool, scope: Scope!, baseInfo: &TypeInfo,
      interfaceList: List<&TypeInfo>, parentInfo: &TypeInfo, staticFlag: bool,
      kind: TypeInfoKind, txt: str, itemTypeInfo: List<&TypeInfo>,
      argTypeInfoList: List<&TypeInfo>, retTypeInfoList: List<&TypeInfo>,
      mutMode: MutMode! ): &TypeInfo
   {
      if kind == .Prim {
         if! sym2builtInTypeMap[ txt ] {
            return _exp.$typeInfo;
         }
         Util.err( "not found symbol -- %s" (txt ) );
      }
      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;
      let mut info = new NormalTypeInfo(
         abstractFlag, scope, baseInfo, interfaceList, false, true,
         staticFlag, accessMode, txt, parentInfo, idProv.$id, kind,
         itemTypeInfo, argTypeInfoList, retTypeInfoList, mutMode );
      return info;
   }

}


pub static fn NormalTypeInfo.createAlternate(
   belongClassFlag:bool, altIndex:int,
   txt:str, accessMode:AccessMode, moduleTypeInfo:&TypeInfo,
   baseTypeInfo: &TypeInfo!, interfaceList: &List<&TypeInfo>! ) : &AlternateTypeInfo
{
   return new AlternateTypeInfo(
      belongClassFlag, altIndex, txt,
      accessMode, moduleTypeInfo, baseTypeInfo, interfaceList );
}

pub proto class DDDTypeInfo extend TypeInfo;

pub class TypeInfo2Map {
   pub let mut ImutModifierMap:Map<&TypeInfo,&TypeInfo> {pub};
   pub let mut MutModifierMap:Map<&TypeInfo,&TypeInfo> {pub};
   pub let mut BoxMap:Map<&TypeInfo,&TypeInfo> {pub};
   pub let mut DDDMap:Map<&TypeInfo,&DDDTypeInfo> {pub};

   pub fn __init() {
      self.ImutModifierMap = {};
      self.MutModifierMap = {};
      self.BoxMap = {};
      self.DDDMap = {};
   }

   pub fn clone(): TypeInfo2Map {
      let mut obj = new TypeInfo2Map();
      foreach val, key in self.ImutModifierMap {
         obj.ImutModifierMap[ key ] = val;
      }
      foreach val, key in self.MutModifierMap {
         obj.MutModifierMap[ key ] = val;
      }
      foreach val, key in self.BoxMap {
         obj.BoxMap[ key ] = val;
      }
      foreach val, key in self.DDDMap {
         obj.DDDMap[ key ] = val;
      }
      return obj;
   }
}

let mut typeInfo2Map = new TypeInfo2Map();


pub static fn NormalTypeInfo.createModifier(
   mut srcTypeInfo: &TypeInfo, mutMode:MutMode): &TypeInfo
{
   srcTypeInfo = srcTypeInfo.$srcTypeInfo;
   switch mutMode {
      case .IMut, .IMutRe {
         if! typeInfo2Map.ImutModifierMap[ srcTypeInfo ] {
            if _exp.$typeId < userStartId and srcTypeInfo.$typeId >= userStartId {
               Util.err( "on cache" );
            }
            return _exp;
         }
      }
      case .AllMut {
         if! typeInfo2Map.MutModifierMap[ srcTypeInfo ] {
            if _exp.$typeId < userStartId and srcTypeInfo.$typeId >= userStartId {
               Util.err( "on cache" );
            }
            return _exp;
         }
      }
   }

   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let modifier = new ModifierTypeInfo( srcTypeInfo, idProv.$id, mutMode );
   switch mutMode {
      case .IMut, .IMutRe {
         typeInfo2Map.ImutModifierMap[ srcTypeInfo ] = modifier;
      }
      case .AllMut {
         typeInfo2Map.MutModifierMap[ srcTypeInfo ] = modifier;
      }
   }

   if modifier.$typeId < userStartId and srcTypeInfo.$typeId >= userStartId {
      Util.printStackTrace();
      Util.err( "off cache: %s %s %s"
                (srcTypeInfo.getTxt(##), modifier.$typeId, srcTypeInfo.$typeId));
   }
   return modifier;
}


//pub let typeInfoRoot = rootTypeInfo;

idProv.increment();
//typeIdSeed = typeIdSeed + 1;

fn addBuiltin( typeInfo:&TypeInfo ) {
   builtInTypeIdSet[ typeInfo.$typeId ] = typeInfo;
}

fn registBuiltin( idName: str, typeTxt: str, kind: TypeInfoKind,
                  typeInfo:&TypeInfo, nilableTypeInfo:&TypeInfo, registScope:bool )
{
   //typeInfoKind[ idName ] = typeInfo;
   sym2builtInTypeMap[ typeTxt ] = new NormalSymbolInfo(
      SymbolKind.Typ, false, false,
      rootScope, AccessMode.Pub, false, typeTxt, nil, typeInfo, .IMut, true );
   if nilableTypeInfo ~= headTypeInfo {
      sym2builtInTypeMap[ typeTxt .. "!" ] = new NormalSymbolInfo(
         SymbolKind.Typ, false, kind == .Func, rootScope,
         AccessMode.Pub, false, typeTxt, nil, nilableTypeInfo, .IMut, true );
   }
   addBuiltin( typeInfo );
   // builtIn は modifier も作成しておく
   addBuiltin( NormalTypeInfo.createModifier( typeInfo, .IMut ) );

   if typeInfo.$nilableTypeInfo ~= headTypeInfo {
      addBuiltin( typeInfo.$nilableTypeInfo );
      // builtIn は modifier も作成しておく
      addBuiltin( NormalTypeInfo.createModifier( typeInfo.$nilableTypeInfo, .IMut ) );
   }


   if registScope {
      rootScope.addClass( typeTxt, nil, typeInfo );
   }
}

pub static fn NormalTypeInfo.createBuiltin(
   idName: str, typeTxt: str,
   kind: TypeInfoKind, typeDDD: &TypeInfo!, ifList:&List<&TypeInfo>! ): &TypeInfo
{
   //let mut typeId = typeIdSeed + 1;
   let mut typeId = idProv.$id + 1;
   if kind == .Root {
      typeId = rootTypeId;
   }
   else {
      //typeIdSeed = typeIdSeed + 1;
      idProv.increment();
   }
   let mut argTypeList:List<&TypeInfo> = [];
   let mut retTypeList:List<&TypeInfo> = [];
   if typeTxt == "form" {
      if! typeDDD {
         argTypeList = [ _exp ];
         retTypeList = [ _exp ];
      }
   }

   let mut scope:Scope! = nil;
   switch kind {
      case .Array, .List, .Set, .Class, .Module,
           .IF, .Form, .FormFunc, .Func, .Method, .Macro
      {
         scope = new Scope(
            rootScope,
            kind == .Class or kind == .Module or kind == .IF or kind == .List or
            kind == .Array or kind == .Set, nil## );
      }
   }

   let mut genTypeList:List<&TypeInfo> = [];
   switch kind {
      case .Array, .List, .Set {
         genTypeList.insert(
            NormalTypeInfo.createAlternate( true, 1, "T", .Pri, headTypeInfo ## ) );
      }
      case .Map {
         genTypeList.insert(
            NormalTypeInfo.createAlternate( true, 1, "K", .Pri, headTypeInfo ## ) );
         genTypeList.insert(
            NormalTypeInfo.createAlternate( true, 2, "V", .Pri, headTypeInfo ## ) );
      }
   }
   let mut info = new NormalTypeInfo(
      false, scope, nil, ifList, false, false, false, AccessMode.Pub,
      typeTxt, headTypeInfo, typeId,
      kind, genTypeList, argTypeList, retTypeList, .Mut );

   registBuiltin( idName, typeTxt, kind, info, headTypeInfo, scope ~= nil );
   return info;
}

pub let builtinTypeNone:TypeInfo =
   NormalTypeInfo.createBuiltin( "__None", "", .Prim## );
// 型が確定していない変数の型は、 builtinTypeEmpty とする
pub let builtinTypeEmpty:TypeInfo =
   NormalTypeInfo.createBuiltin( "__Empty", "::", .Prim## );
pub let builtinTypeNeverRet:TypeInfo =
   NormalTypeInfo.createBuiltin( "__NRet", "__", .Prim## );
pub let builtinTypeStem:TypeInfo =
   NormalTypeInfo.createBuiltin( "Stem", "stem" , .Stem## );
pub let builtinTypeStem_ = builtinTypeStem.$nilableTypeInfo;

pub let builtinTypeBool:TypeInfo =
   NormalTypeInfo.createBuiltin( "Bool", "bool" , .Prim## );
pub let builtinTypeInt:TypeInfo =
   NormalTypeInfo.createBuiltin( "Int", "int" , .Prim## );
pub let builtinTypeReal:TypeInfo =
   NormalTypeInfo.createBuiltin( "Real", "real" , .Prim## );
pub let builtinTypeChar:TypeInfo =
   NormalTypeInfo.createBuiltin( "char", "__char" , .Prim## );
pub let builtinTypeMapping:TypeInfo =
   NormalTypeInfo.createBuiltin( "Mapping", "Mapping" , .IF## );
pub let builtinTypeString:TypeInfo =
   NormalTypeInfo.createBuiltin( "String", "str" , .Class, nil, [ builtinTypeMapping ] );
pub let builtinTypeMap:TypeInfo =
   NormalTypeInfo.createBuiltin( "Map", "Map" , .Map## );
pub let builtinTypeSet:TypeInfo =
   NormalTypeInfo.createBuiltin( "Set", "Set" , .Set## );
pub let builtinTypeList:TypeInfo =
   NormalTypeInfo.createBuiltin( "List", "List" , .List## );
pub let builtinTypeArray:TypeInfo =
   NormalTypeInfo.createBuiltin( "Array", "Array" , .Array## );


pub static fn AlternateTypeInfo.getAssign(
   typeInfo:&TypeInfo, alt2type:&Map<&TypeInfo,&TypeInfo> ) : &TypeInfo
{
   if typeInfo.$kind ~= .Alternate {
      return typeInfo;
   }
   let mut otherWork = typeInfo;
   while true {
      if! alt2type[ otherWork ] {
         if _exp ~= otherWork {
            otherWork = _exp;
         }
         else {
            return otherWork;
         }
      }
      else {
         return otherWork;
      }
   }
}




pub fn isStruct( typeInfo:&TypeInfo ): bool {
   switch typeInfo.$kind {
      case .Class {
         if typeInfo == builtinTypeString {
            return false;
         }
         if typeInfo.$baseTypeInfo ~= headTypeInfo or
            #typeInfo.$interfaceList ~= 0 or
            #typeInfo.$children ~= 1 // children は __init の分
         {
            return false;
         }
         return true;
      }
   }
   return false;
}

idProv.increment();
pub let builtinTypeBox = new BoxTypeInfo( idProv.$id, .Pub, boxRootAltType );
registBuiltin( "Nilable", "Nilable", .Box, builtinTypeBox, headTypeInfo, true );


pub fn isConditionalbe( typeInfo:&TypeInfo ) : bool {
   if typeInfo.$nilable or typeInfo.equals( builtinTypeBool, nil ## ) {
      return true;
   }
   return false;
}


pub static fn NormalTypeInfo.createBox(
   accessMode:AccessMode, nonnilableType: &TypeInfo ): &TypeInfo
{
   if! let boxType = typeInfo2Map.BoxMap[ nonnilableType ] {
      return boxType;
   }

   idProv.increment();
   let boxType = new BoxTypeInfo( idProv.$id, accessMode, nonnilableType );
   typeInfo2Map.BoxMap[ nonnilableType ] = boxType;
   return boxType;
}

pub override fn BoxTypeInfo.applyGeneric(
   alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ): &TypeInfo!
{
   let typeInfo = self.boxingType.applyGeneric( alt2typeMap, moduleTypeInfo );
   if typeInfo == self.boxingType {
      return self;
   }
   when! typeInfo {
      return NormalTypeInfo.createBox( self.accessMode, typeInfo );
   }
   return nil;
}



pub static fn NormalTypeInfo.createSet(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   itemTypeInfo: &List<&TypeInfo>, mutMode:MutMode ): &TypeInfo
{
   if #itemTypeInfo == 0 {
      Util.err( "illegal set type: %s" (itemTypeInfo) );
   }
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, getScope( builtinTypeSet ), builtinTypeSet,
      nil, false, false, false, AccessMode.Pub,
      "Set", headTypeInfo, idProv.$id, .Set, itemTypeInfo, nil, nil, mutMode );
}

pub static fn NormalTypeInfo.createList(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   itemTypeInfo: &List<&TypeInfo>, mutMode:MutMode ): &TypeInfo
{
   if #itemTypeInfo == 0 {
      Util.err( "illegal list type: %s" (itemTypeInfo) );
   }
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, getScope( builtinTypeList ), builtinTypeList,
      nil, false, false, false, AccessMode.Pub,
      "List", headTypeInfo, idProv.$id, .List, itemTypeInfo, nil, nil, mutMode);
}

pub static fn NormalTypeInfo.createArray(
   accessMode: AccessMode,
   parentInfo: &TypeInfo, itemTypeInfo: &List<&TypeInfo>, mutMode:MutMode ): &TypeInfo
{
   //   typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, getScope( builtinTypeArray ), builtinTypeArray,
      nil, false, false, false, AccessMode.Pub,
      "Array", headTypeInfo, idProv.$id, .Array, itemTypeInfo, nil, nil, mutMode );
}

pub static fn NormalTypeInfo.createMap(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   keyTypeInfo: &TypeInfo, valTypeInfo: &TypeInfo, mutMode:MutMode ): &TypeInfo
{
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, getScope( builtinTypeMap ), builtinTypeMap,
      nil, false, false, false, AccessMode.Pub,
      "Map", headTypeInfo, idProv.$id, .Map,
      [ keyTypeInfo, valTypeInfo ], nil, nil, mutMode );
}

pub static fn NormalTypeInfo.createModule(
   scope: Scope, parentInfo: &TypeInfo, externalFlag: bool,
   moduleName: str, mutable:bool ): &TypeInfo
{
   if! sym2builtInTypeMap[ moduleName ] {
      return _exp.$typeInfo;
   }

   if Parser.isLuaKeyword( moduleName ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (moduleName) );
   }

   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new ModuleTypeInfo(
      scope, externalFlag, moduleName, parentInfo, idProv.$id, mutable );
   return info;
}


pub static fn NormalTypeInfo.createClass(
   classFlag: bool, abstractFlag: bool, scope: Scope!,
   baseInfo: &TypeInfo!, interfaceList: &List<&TypeInfo>!,
   genTypeList: &List<&AlternateTypeInfo>, parentInfo: &TypeInfo, externalFlag: bool,
   accessMode: AccessMode, className: str ): &TypeInfo
{
   // if className == "str" {
   //     return sym2builtInTypeMap[ className ]@TypeInfo;
   // }
   if! sym2builtInTypeMap[ className ] {
      return _exp.$typeInfo;
      //return classTypeInfo@TypeInfo;
   }

   if Parser.isLuaKeyword( className ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (className) );
   }

   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new NormalTypeInfo(
      abstractFlag, scope, baseInfo, interfaceList, false,
      externalFlag, false, accessMode,
      className, parentInfo, idProv.$id,
      classFlag and TypeInfoKind.Class or TypeInfoKind.IF, genTypeList, nil, nil, .Mut );
   return info;
}


pub static fn NormalTypeInfo.createFunc(
   abstractFlag: bool, builtinFlag:bool, scope: Scope!, kind: TypeInfoKind,
   parentInfo: &TypeInfo, autoFlag: bool, externalFlag: bool,
   staticFlag: bool, accessMode: AccessMode, funcName: str,
   altTypeList: &List<&TypeInfo>!, argTypeList: &List<&TypeInfo>!,
   retTypeInfoList: &List<&TypeInfo>!, mutable: bool! ): &TypeInfo
{
   if not builtinFlag and Parser.isLuaKeyword( funcName ) {
      Util.err( "This symbol can not use for a function. -- %s" (funcName) );
   }

   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new NormalTypeInfo(
      abstractFlag, scope, nil, nil, autoFlag, externalFlag, staticFlag,
      accessMode, funcName, parentInfo, idProv.$id,
      kind, unwrap altTypeList default [], unwrap argTypeList default [],
      unwrap retTypeInfoList default [],
      mutable and MutMode.Mut or MutMode.IMut );
   return info;
}

pub static fn NormalTypeInfo.createAdvertiseMethodFrom(
   classTypeInfo:&TypeInfo, typeInfo:&TypeInfo ): &TypeInfo
{
   return NormalTypeInfo.createFunc(
      false, false, getScope( typeInfo ), typeInfo.$kind,
      classTypeInfo, true, false, false, typeInfo.$accessMode, typeInfo.$rawTxt,
      typeInfo.$itemTypeInfoList,
      typeInfo.$argTypeInfoList, typeInfo.$retTypeInfoList, TypeInfo.isMut( typeInfo ) );
}


pub override fn ModifierTypeInfo.get_nonnilableType(): &TypeInfo {
   let orgType = self.srcTypeInfo.$nonnilableType;
   if TypeInfo.isMut( self ) or not TypeInfo.isMut( orgType ) {
      return orgType;
   }
   return NormalTypeInfo.createModifier( orgType, .IMut );
}

pub override fn ModifierTypeInfo.get_nilableTypeInfo(): &TypeInfo {
   let orgType = self.srcTypeInfo.$nilableTypeInfo;
   if not TypeInfo.isMut( orgType ) {
      return orgType;
   }
   return NormalTypeInfo.createModifier( orgType, .IMut );
}


pub static fn NormalTypeInfo.createAlias(
   name:str, externalFlag:bool, accessMode:AccessMode,
   parentInfo: &TypeInfo, typeInfo: &TypeInfo ): &AliasTypeInfo
{
   idProv.increment();
   return new AliasTypeInfo(
      name, accessMode, parentInfo, typeInfo.$srcTypeInfo, externalFlag, idProv.$id );
}

pub fn Scope.addAlias(
   name:str, pos:&Parser.Position, externalFlag:bool, accessMode:AccessMode,
   parentInfo: &TypeInfo, symbolInfo:&SymbolInfo ) mut : &SymbolInfo!, &SymbolInfo!
{
   let aliasType = NormalTypeInfo.createAlias(
      name, externalFlag, accessMode, parentInfo, symbolInfo.$typeInfo.$srcTypeInfo );
   return self.add(
      symbolInfo.$kind, false, symbolInfo.$canBeRight,
      name, pos, aliasType, accessMode, true, .IMut, true )**;
}

pub fn Scope.addAliasForType(
   name:str, pos:&Parser.Position!, typeInfo:&TypeInfo ) mut :
   &SymbolInfo!, &SymbolInfo!
{
   let mut skind = SymbolKind.Typ;
   let mut canBeRight = false;
   switch typeInfo.$kind {
      case .Func {
         skind = .Fun;
         canBeRight = true;
      }
      case .Form, .FormFunc {
         canBeRight = true;
      }
      case .Macro {
         skind = .Mac;
      }
   }

   return self.add(
      skind, false, canBeRight, name, pos,
      typeInfo, typeInfo.$accessMode, true, .IMut, true )**;
}



pub class DDDTypeInfo extend TypeInfo {
   pri let typeInfo: &TypeInfo { pub };
   pri let typeId: int { pub };
   pri let externalFlag: bool {pub};
   pri let itemTypeInfoList: &List<&TypeInfo> {pub};

   pub override fn get_scope(): Scope! {
      return nil;
   }

   pub fn __init( typeId:int, typeInfo:&TypeInfo, externalFlag:bool )
   {
      super( nil );
      self.typeId = typeId;
      //self.typeInfo = typeInfo.$nilableTypeInfo;
      self.typeInfo = typeInfo;
      self.externalFlag = externalFlag;
      self.itemTypeInfoList = [ self.typeInfo ];

      typeInfo2Map.DDDMap[ typeInfo ] = self;
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn canEvalWith(
      other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return self.typeInfo.canEvalWith( other, canEvalType, alt2type )**;
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      stream.write(
         '{ skind=%d, typeId = %d, itemTypeId = %d, parentId = %d }\n'
         ( SerializeKind.DDD, self.typeId,
           self.typeInfo.$typeId, headTypeInfo.$typeId ) );
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn getModule(): &TypeInfo {
      return self.$typeInfo.getModule();
   }
   pub override fn get_rawTxt(): str {
      return self.getTxt(##);
   }
   pub override fn get_kind(): TypeInfoKind {
      return .DDD;
   }
   pub override fn get_nilable(): bool {
      //return self.typeInfo.$nilable;
      return true;
   }
   pub override fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_mutMode(): MutMode {
      return self.$typeInfo.$mutMode;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_accessMode(): AccessMode {
      // export 出来るように pub 固定にする。
      // accessMode 毎にインスタンスを作ることも出来るが、
      // ほぼ無駄なので pub 固定とする。
      return .Pub;
   }
}


pub static fn NormalTypeInfo.createDDD(
   typeInfo:&TypeInfo, externalFlag:bool ): &DDDTypeInfo
{
   if! typeInfo2Map.DDDMap[ typeInfo ] {
      if _exp.$typeId < userStartId and typeInfo.$typeId >= userStartId {
         Util.err( "on cache" );
      }
      return _exp;
   }

   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new DDDTypeInfo( idProv.$id, typeInfo, externalFlag );
}



pub let builtinTypeNil:TypeInfo = new NilTypeInfo();
registBuiltin( "Nil", "nil", .Prim, builtinTypeNil, headTypeInfo, false );

pub let builtinTypeDDD:TypeInfo =
   NormalTypeInfo.createDDD( builtinTypeStem_, true );
registBuiltin( "DDD", "...", .DDD, builtinTypeDDD, headTypeInfo, false );


pub let builtinTypeForm:TypeInfo =
   NormalTypeInfo.createBuiltin( "Form", "form" , .Form, builtinTypeDDD ## );
pub let builtinTypeSymbol:TypeInfo =
   NormalTypeInfo.createBuiltin( "Symbol", "sym" , .Prim## );
pub let builtinTypeStat:TypeInfo =
   NormalTypeInfo.createBuiltin( "Stat", "stat" , .Prim## );
pub let builtinTypeExp:TypeInfo =
   NormalTypeInfo.createBuiltin( "Exp", "__exp" , .Prim## );




/**
typeInfo と other 両方の型を受けられる共通の型を返す。

typeInfo と other に互換性がない場合は stem あるいは stem! の型を返す。
*/
pub static fn TypeInfo.getCommonType(
   typeInfo:&TypeInfo, other:&TypeInfo,
   alt2type:Map<&TypeInfo,&TypeInfo> ): &TypeInfo
{
   fn getType( mut workType:&TypeInfo ): &TypeInfo {
      if typeInfo.$nilable or other.$nilable {
         workType = workType.$nilableTypeInfo;
      }
      if TypeInfo.isMut( typeInfo ) or TypeInfo.isMut( other ) {
         // どちらかが mutable なら、結果を mutable とする。
         // いまのところ、 immutable を mutable とするキャストはサポートしていないので、
         // immutable と mutable の共通の型を immutable としてしまうと、
         // 扱い難いので。。
         workType = workType.$srcTypeInfo;
      }
      return workType;
   }

   let type1 = typeInfo.$nonnilableType.$srcTypeInfo;
   let type2 = other.$nonnilableType.$srcTypeInfo;

   if type1 == builtinTypeNone {
      return other;
   }
   if type2 == builtinTypeNone {
      return typeInfo;
   }
   
   if type1 == builtinTypeNil {
      return other.$nilableTypeInfo;
   }
   if type2 == builtinTypeNil {
      return typeInfo.$nilableTypeInfo;
   }
   
   
   if type1.canEvalWith( type2, .SetOp, alt2type ) {
      return getType( type1 );
   }
   if type2.canEvalWith( type1, .SetOp, alt2type ) {
      return getType( type2 );
   }


   let mut mutMode;
   if TypeInfo.isMut( typeInfo ) or TypeInfo.isMut( other ) {
      mutMode = MutMode.Mut;
   }
   else {
      mutMode = MutMode.IMut;
   }
   
   if type1.$kind == type2.$kind {
      
      switch type1.$kind {
         case .List {
            return getType( NormalTypeInfo.createList(
               .Local, headTypeInfo,
               [ TypeInfo.getCommonType(
                  type1.$itemTypeInfoList[ 1 ],
                  type2.$itemTypeInfoList[ 1 ], alt2type ) ], mutMode ) );
         }
         case .Array {
            return getType( NormalTypeInfo.createArray(
               .Local, headTypeInfo,
               [ TypeInfo.getCommonType(
                  type1.$itemTypeInfoList[ 1 ],
                  type2.$itemTypeInfoList[ 1 ], alt2type ) ], mutMode ) );
         }
         case .Set {
            return getType( NormalTypeInfo.createSet(
               .Local, headTypeInfo,
               [ TypeInfo.getCommonType(
                  type1.$itemTypeInfoList[ 1 ],
                  type2.$itemTypeInfoList[ 1 ], alt2type ) ], mutMode ) );
         }
         case .Map {
            return getType( NormalTypeInfo.createMap(
               .Local, headTypeInfo,
               TypeInfo.getCommonType(
                  type1.$itemTypeInfoList[ 1 ],
                  type2.$itemTypeInfoList[ 1 ], alt2type ),
               TypeInfo.getCommonType(
                  type1.$itemTypeInfoList[ 2 ],
                  type2.$itemTypeInfoList[ 2 ], alt2type ), mutMode ) );
         }
      }
   }
   
   let mut work = type1.$baseTypeInfo;

   while work ~= headTypeInfo {
      if work.canEvalWith( type2, .SetOp, alt2type ) {
         return work;
      }
      work = work.$baseTypeInfo;
   }

   if typeInfo.$nilable or other.$nilable {
      work = builtinTypeStem_;
   }
   else {
      work = builtinTypeStem;
   }

   if not isMutable( mutMode ) {
      return NormalTypeInfo.createModifier( work, mutMode );
   }
   
   return work;
}


pub override fn DDDTypeInfo.getTxt(
   typeNameCtrl:&TypeNameCtrl!, importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
{
   return self.getTxtWithRaw( "...", typeNameCtrl, importInfo, localFlag );
}

pro override fn DDDTypeInfo.getTxtWithRaw(
   raw:str, typeNameCtrl:&TypeNameCtrl!,
   importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
{
   if self.typeInfo == builtinTypeStem_ {
      return "...";
   }
   let txt = self.typeInfo.getTxt( typeNameCtrl, importInfo, localFlag );
   return "...<" .. txt .. ">";
}

pub static fn NormalTypeInfo.createGeneric(
   genSrcTypeInfo:&TypeInfo,
   itemTypeInfoList:&List<&TypeInfo>, moduleTypeInfo:&TypeInfo ): GenericTypeInfo
{
   idProv.increment();
   return new GenericTypeInfo( genSrcTypeInfo, itemTypeInfoList, moduleTypeInfo );
}


fn applyGenericList(
   typeList:&List<&TypeInfo>, alt2typeMap:&Map<&TypeInfo,&TypeInfo>,
   moduleTypeInfo:&TypeInfo ) : &List<&TypeInfo>!, bool
{
   let mut typeInfoList:List<&TypeInfo> = [];
   let mut needNew = false;
   foreach srcType in typeList {
      if! let typeInfo = srcType.applyGeneric( alt2typeMap, moduleTypeInfo ) {
         typeInfoList.insert( typeInfo );
         if srcType ~= typeInfo {
            needNew = true;
         }
      }
      else {
         return nil, false;
      }
   }
   return typeInfoList, needNew;
}


pub override fn GenericTypeInfo.applyGeneric(
   alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ): &TypeInfo!
{
   if self.genSrcTypeInfo.$kind == .Class  {
      let itemTypeInfoList, newFlag = applyGenericList(
         self.$itemTypeInfoList, alt2typeMap, moduleTypeInfo );
      when! itemTypeInfoList {
         if newFlag {
            return NormalTypeInfo.createGeneric(
               self.genSrcTypeInfo, itemTypeInfoList, moduleTypeInfo );
         }
      }
   }
   
   let genSrcTypeInfo = self.genSrcTypeInfo.applyGeneric( alt2typeMap, moduleTypeInfo );
   if genSrcTypeInfo == self.genSrcTypeInfo {
      return self;
   }
   if not self.hasAlter {
      return self;
   }
   
                                        
   
   Util.errorLog( "no support nest generic -- %s" (self.getTxt(##) ) );
   return nil;
}



pub class AbbrTypeInfo extend TypeInfo {
   pri let typeId: int { pub };
   pri let rawTxt:str { pub };

   pub override fn get_scope(): Scope! {
      return nil;
   }

   pub fn __init( idProvider:IdProvider, rawTxt:str )
   {
      super( nil );

      let typeId = idProvider.$id + 1;
      idProvider.increment();

      self.typeId = typeId;
      self.rawTxt = rawTxt;
   }

   pub override fn isModule(): bool {
      return false;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return rawTxt;
   }

   pub override fn canEvalWith(
      other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return false, nil;
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      Util.err( "illegal call" );
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn getModule(): &TypeInfo {
      return headTypeInfo;
   }
   pub override fn get_kind(): TypeInfoKind {
      return .Abbr;
   }
   pub override fn get_nilable(): bool {
      return true;
   }
   pub override fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_mutMode(): MutMode {
      return .IMut;
   }
   pub override fn get_accessMode(): AccessMode {
      return .Local;
   }
}

// pub let builtinTypeAbbr:TypeInfo =
//    NormalTypeInfo.createBuiltin( "Abbr", "#" , .Abbr );
// pub let builtinTypeAbbrNone:TypeInfo =
//    NormalTypeInfo.createBuiltin( "AbbrNone", "#_" , .Abbr );

pub let builtinTypeAbbr:TypeInfo = new AbbrTypeInfo( idProv, "##" );
pub let builtinTypeAbbrNone:TypeInfo = new AbbrTypeInfo( idProv, "[##]" );


pub class ExtTypeInfo extend TypeInfo {
   pri let typeId: int { pub };
   pri let extedType: &TypeInfo { pub };
   pri let nilableTypeInfo: &TypeInfo { pub };

   pub fn __init( idProvider:IdProvider, extedType:&TypeInfo )
   {
      super( extedType.$scope );

      let typeId = idProvider.$id + 1;
      idProvider.increment();
      self.typeId = typeId;
      self.extedType = extedType;

      self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
      idProv.increment();
      

   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, typeNameCtrl, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, typeNameCtrl:&TypeNameCtrl!,
      importInfo:&ModuleInfoManager!, localFlag:bool! ) : str
   {
      return "Luaval<%s>" ( self.extedType.getTxtWithRaw( rawTxt, typeNameCtrl,
                                                         importInfo, localFlag ) );
   }

   pub override fn equals( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>!,
                           checkModifer:bool! ): bool
   {
      if! let extTypeInfo = typeInfo@@@ExtTypeInfo {
         return self.extedType.equals( extTypeInfo.extedType, alt2type, checkModifer );
      }
      return self.extedType.equals( typeInfo, alt2type, checkModifer );
   }

   
   pub override fn canEvalWith(
      other:&TypeInfo,
      canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
   {
      return self.extedType.canEvalWith( other, canEvalType, alt2type )**;
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      Util.err( "illegal call" );
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn getModule(): &TypeInfo {
      return headTypeInfo;
   }
   pub override fn get_kind(): TypeInfoKind {
      return .Ext;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_nilable(): bool {
      return false;
   }
   pub override fn applyGeneric(
      alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ): &TypeInfo!
   {
      let typeInfo = self.extedType.applyGeneric( alt2typeMap, moduleTypeInfo );
      if typeInfo ~= self.extedType {
         Util.err( "not support -- %s" (self.extedType.getTxt(##) ) );
      }
      return self;
   }
   

   advertise extedType;
}

pub static fn NormalTypeInfo.createLuaval( luneType:&TypeInfo ) : &TypeInfo
{
   idProv.increment();
   return new ExtTypeInfo( idProv, luneType );
}

pub let builtinTypeLua:TypeInfo =
   NormalTypeInfo.createLuaval( builtinTypeStem );
registBuiltin( "Luaval", "Luaval", .Ext, builtinTypeLua, headTypeInfo, false );
pub let builtinTypeDDDLua:TypeInfo =
   NormalTypeInfo.createDDD( builtinTypeLua, true );
registBuiltin( "__LuaDDD", "__LuaDDD", .Ext, builtinTypeDDDLua, headTypeInfo, false );

pub let builtinTypeLoadedFunc = NormalTypeInfo.createFunc(
   false, true, nil, .Form, headTypeInfo, true, true,
   true, .Pub, "__loadedfunc", nil, nil, [ builtinTypeDDDLua ], false );
registBuiltin( "__loadedfunc", "__loadedfunc", .Ext,
               builtinTypeLoadedFunc, headTypeInfo, false );


/**
and 演算結果の TypeInfo。
hoge and foo or bar の 3 項演算結果の演算結果を得るために使用する。
*/
pub class AndExpTypeInfo extend TypeInfo {
   let exp1:&TypeInfo {pub};
   let exp2:&TypeInfo {pub};
   let result:&TypeInfo {pub};

   pub fn __init( exp1:&TypeInfo, exp2:&TypeInfo, result:&TypeInfo )
   {
      super( result.$scope );
      self.exp1 = exp1;
      self.exp2 = exp2;
      self.result = result;
   }
      
   advertise result;
}


let mut numberTypeSet:Set<&TypeInfo> = (@);
numberTypeSet.add( builtinTypeInt );
numberTypeSet.add( builtinTypeChar );
numberTypeSet.add( builtinTypeReal );

pub fn isNumberType( typeInfo:&TypeInfo ): bool {
   return numberTypeSet.has( typeInfo.$srcTypeInfo );
}


pub static fn NormalTypeInfo.createEnum(
   scope: Scope, parentInfo: &TypeInfo, externalFlag: bool,
   accessMode: AccessMode, enumName: str, valTypeInfo:&TypeInfo ): EnumTypeInfo
{
   if Parser.isLuaKeyword( enumName ) {
      Util.err( "This symbol can not use for a enum. -- %s"
                (enumName) );
   }

   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new EnumTypeInfo(
      scope, externalFlag, accessMode, enumName,
      parentInfo, idProv.$id, valTypeInfo );

   let mut getEnumName = NormalTypeInfo.createFunc(
      false, true, nil, .Method, info,
      true, externalFlag, false, AccessMode.Pub,
      "get__txt", nil, nil, [ builtinTypeString ], false );
   scope.addMethod( nil, getEnumName, AccessMode.Pub, false, false );

   let mut fromVal = NormalTypeInfo.createFunc(
      false, true, nil, .Func, info,
      true, externalFlag, true, AccessMode.Pub,
      "_from", nil, [ NormalTypeInfo.createModifier( valTypeInfo, .IMut ) ],
      [ info.$nilableTypeInfo ], false );
   scope.addMethod( nil, fromVal, AccessMode.Pub, true, false );

   let allListType = NormalTypeInfo.createList( .Pub, info, [ info ], .IMut );
   let mut allList = NormalTypeInfo.createFunc(
      false, true, nil, .Func, info,
      true, externalFlag, true, AccessMode.Pub,
      "get__allList", nil, nil,
      [ NormalTypeInfo.createModifier( allListType, .IMut ) ], false );
   scope.addMethod( nil, allList, AccessMode.Pub, true, false );

   return info;
}

pub override fn EnumTypeInfo.serialize(
   stream: oStream, validChildrenSet: Map<int,&TypeInfo>! )
{
   let txt = ```{ skind = %d, parentId = %d, typeId = %d, txt = '%s',
accessMode = %d, kind = %d, valTypeId = %d, ```
       ( SerializeKind.Enum, self.getParentId(), self.typeId, self.rawTxt,
         self.accessMode, TypeInfoKind.Enum, self.valTypeInfo.$typeId );
   stream.write( txt );

   stream.write( "enumValList = {" );
   forsort enumValInfo in self.name2EnumValInfo {
      stream.write( "%s = " (enumValInfo.$name));
      match enumValInfo.$val {
         case .Int( val ) {
            stream.write( "%d," (val) );
         }
         case .Real( val ) {
            stream.write( "%g," (val) );
         }
         case .Str( val ) {
            stream.write( "%q," (val) );
         }
      }
      // if self.valTypeInfo.equals( builtinTypeString## ) {
      //    stream.write( "%s = '%s'," (enumValInfo.$name, enumValInfo.$val) );
      // }
      // else {
      //    stream.write( "%s = %s," (enumValInfo.$name, enumValInfo.$val) );
      // }
   }
   stream.write( "} }\n" );
}



pub static fn NormalTypeInfo.createAlge(
   scope: Scope, parentInfo: &TypeInfo, externalFlag: bool,
   accessMode: AccessMode, algeName: str ): AlgeTypeInfo
{
   if Parser.isLuaKeyword( algeName ) {
      Util.err( "This symbol can not use for a alge. -- %s"
                (algeName) );
   }

   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new AlgeTypeInfo(
      scope, externalFlag, accessMode, algeName, parentInfo, idProv.$id );

   let mut getAlgeName = NormalTypeInfo.createFunc(
      false, true, nil, .Method, info,
      true, externalFlag, false, AccessMode.Pub,
      "get__txt", nil, nil, [ builtinTypeString ], false );
   scope.addMethod( nil, getAlgeName, AccessMode.Pub, false, false );

   return info;
}

pub override fn AlgeTypeInfo.serialize(
   stream: oStream, validChildrenSet: Map<int,&TypeInfo>! )
{
   let txt = ```{ skind = %d, parentId = %d, typeId = %d, txt = '%s',
accessMode = %d, kind = %d, ```
       ( SerializeKind.Alge, self.getParentId(), self.typeId, self.rawTxt,
         self.accessMode, TypeInfoKind.Alge );
   stream.write( txt );

   stream.write( "algeValList = {" );
   let mut firstFlag = true;
   forsort algeValInfo in self.valInfoMap {
      if not firstFlag {
         stream.write( "," );
      }
      else {
         firstFlag = false;
      }
      algeValInfo.serialize( stream );
   }
   stream.write( "} }\n" );
}


// other 型の値を、この型の変数に設定できるか判定する。
pub override fn BoxTypeInfo.canEvalWith(
   other:&TypeInfo,
   canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
{
   if self == other {
      return true, nil;
   }
   switch canEvalType {
      case .SetOp, .SetOpIMut, .SetEq {
      }
      default {
         return false, nil;
      }
   }

   if other.$nilable {
      CanEvalCtrlTypeInfo.updateNeedAutoBoxing( alt2type );
      return true, nil;
   }

   if! let otherBoxType = other@@@BoxTypeInfo {
      return self.boxingType.canEvalWith(
         otherBoxType.boxingType, canEvalType, alt2type )**;
   }
   

   if self.boxingType.canEvalWith( other, canEvalType, alt2type ) {
      CanEvalCtrlTypeInfo.updateNeedAutoBoxing( alt2type );
      return true, nil;
   }
   return false, nil;
}


// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NilableTypeInfo.canEvalWith(
   other:&TypeInfo,
   canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ): bool, str!
{
   //let otherSrc = other.$srcTypeInfo;
   let otherSrc = other;

   if self == builtinTypeStem_ {
      return true, nil;
   }
   if otherSrc == builtinTypeNil or otherSrc.$kind == .Abbr {
      if self.$nonnilableType.$kind == .Box {
         return self.$nonnilableType.canEvalWith( otherSrc, canEvalType, alt2type )**;
      }
      return true, nil;
   }
   if self.typeId == otherSrc.$typeId {
      return true, nil;
   }
   if otherSrc.$nilable {
      if otherSrc.$kind == .DDD {
         return self.$nonnilableType.canEvalWith(
            otherSrc.$itemTypeInfoList[ 1 ], canEvalType, alt2type )**;
      }
      
      return self.$nonnilableType.canEvalWith(
         otherSrc.$nonnilableType, canEvalType, alt2type )**;
   }
   return self.$nonnilableType.canEvalWith( otherSrc, canEvalType, alt2type )**;
}

macro _checkEqualsItemType(
   type1:sym, type2:sym, index:int, alt2type:sym, destMut:sym, multiFlag:bool )
{
   {
      let retStat:stat;
      if multiFlag {
         retStat = `{ return false, mess };
      }
      else {
         retStat = `{ return false };
      }
   }
   let mut mess:str! = nil;
   if #,,type1.$itemTypeInfoList >= ,,index and
      #,,type2.$itemTypeInfoList >= ,,index
   {
      // ここの .SetEq を制御する
      let ret;
      ret, mess = (,,type1.$itemTypeInfoList[ ,,index ]).canEvalWith(
         ,,type2.$itemTypeInfoList[ ,,index ],
         ,,destMut and CanEvalType.SetEq or CanEvalType.SetOpIMut, ,,alt2type );
      if not ret {
         ,,retStat;
      }
   }
   else {
      ,,retStat;
   }
};

pub static fn NormalTypeInfo.isAvailableMapping(
   mut typeInfo:&TypeInfo, checkedTypeMap:Map<&TypeInfo,bool> ): bool
{
   fn isAvailableMappingSub(): bool {
      switch typeInfo.$kind {
         case .Prim, .Enum {
            return true;
         }
         case .Alge {
            let algeTypeInfo = unwrap (typeInfo@@@AlgeTypeInfo);
            foreach valInfo in algeTypeInfo.$valInfoMap {
               foreach paramType in valInfo.$typeList {
                  if not NormalTypeInfo.isAvailableMapping( paramType, checkedTypeMap ) {
                     return false;
                  }
               }
            }
            return true;
         }
         case .Stem {
            // stem は mapping 不能なデータもあるが、
            // それは実行時エラーとする。
            return true;
         }
         case .Class, .IF {
            if typeInfo.equals( builtinTypeString ##) {
               return true;
            }
            return typeInfo.isInheritFrom( builtinTypeMapping, nil );
         }
         case .Alternate {
            return typeInfo.isInheritFrom( builtinTypeMapping, nil );
         }
         case .List, .Array, .Set {
            return NormalTypeInfo.isAvailableMapping(
               typeInfo.$itemTypeInfoList[1], checkedTypeMap );
         }
         case .Map {
            if NormalTypeInfo.isAvailableMapping(
               typeInfo.$itemTypeInfoList[2], checkedTypeMap )
            {
               let keyType = typeInfo.$itemTypeInfoList[1];
               if keyType.equals( builtinTypeString ## ) or
                  keyType.$kind == .Prim or keyType.$kind == .Enum
               {
                  return true;
               }
            }
            return false;
         }
         case .Nilable {
            return NormalTypeInfo.isAvailableMapping(
               typeInfo.$nonnilableType, checkedTypeMap );
         }
         default {
            return false;
         }
      }
   }

   typeInfo = typeInfo.$srcTypeInfo;
   if! checkedTypeMap[ typeInfo ] {
      return _exp;
   }
   // チェック前は暫定的に true にする
   checkedTypeMap[ typeInfo ] = true;
   let result = isAvailableMappingSub();
   checkedTypeMap[ typeInfo ] = result;
   return result;
}

// other のクラスが、この型のクラスの継承関係にあるか調べる
pub override fn NormalTypeInfo.isInheritFrom(
   other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool
{
   if self.$typeId == other.$typeId {
      return true;
   }
   if ( self.$kind ~= .Class and self.$kind ~= .IF ) or
       ( other.$kind ~= .Class and other.$kind ~= .IF )
   {
      if other == builtinTypeMapping {
         return NormalTypeInfo.isAvailableMapping( self, {} );
      }
      return false;
   }
   return TypeInfo.isInherit( self, other, alt2type );
}

pub enum MatchType {
   Match,
   Warn,
   Error,
}

/**
expTypeList の型から、 dstTypeListOrg の型へ互換性があるかどうか確認する。

@param warnForFollowSrcIndex
   このインデックス以降の expTypeList をチェックする際、
   dstTypeListOrg の型が省略可能な場合 Warn を出す。
@return MatchType 適合結果
@return str メッセージ
*/
pub static fn TypeInfo.checkMatchType(
   dstTypeList: &List<&TypeInfo>, expTypeList: &List<&TypeInfo>,
   allowDstShort:bool, warnForFollowSrcIndex:int!, alt2type:Map<&TypeInfo,&TypeInfo> ) :
   MatchType, str
{
   macro _checkWarnForFollow( index:sym, dstType:sym, expType:sym ) {
      when! warnForFollowSrcIndex {
         //if warnForFollowSrcIndex <= ,,index and ,,dstType.$nilable {
         if warnForFollowSrcIndex <= ,,index {
            let workMess = "use '**' at arg(%d). %s <- %s"
                ( ,,index, ,,dstType.getTxt( defaultTypeNameCtrl## ),
                  ,,expType.getTxt( defaultTypeNameCtrl## ) );
            return .Warn, workMess;
         }
      }
   }

   // index 番以降の dstTypeList の要素が srcType, srcType2nd と等しいか調べる。
   // index 番目と srcType, index + 1 以降と srcType2nd を調べる。
   // dstTypeList[ index ] == srcType
   // dstTypeList[ index + ? ] == srcType2nd
   fn checkDstTypeFrom(
      index:int, srcType:&TypeInfo, srcType2nd:&TypeInfo ): MatchType, str
   {
      let mut workExpType = srcType;
      for dstIndex = index, #dstTypeList {
         let workDstType = dstTypeList[ dstIndex ];
         let mut matchResult = MatchType.Match;
         if not workDstType.canEvalWith( workExpType, .SetOp, alt2type ) {
            let message = "exp(%d) type mismatch %s <- %s: dst %d"
                ( dstIndex, workDstType.getTxt( defaultTypeNameCtrl## ),
                  workExpType.getTxt( defaultTypeNameCtrl## ), dstIndex );
            return .Error, message;
         }
         elseif workExpType == builtinTypeAbbrNone {
            return .Warn, Code.format( .nothing_define_abbr,
                                       "use '##', instate of %s."
                                       (workDstType.getTxt(defaultTypeNameCtrl##)) );
         }

         if matchResult ~= .Match {
         }
         workExpType = srcType2nd;
      }
      return .Match, "";
   }
   // index 番以降の expTypeList の要素が dstType と等しいか調べる。
   fn checkSrcTypeFrom( index:int, dstType:&TypeInfo ) : MatchType, str
   {
      for srcIndex = index, #expTypeList {
         let expType = expTypeList[ srcIndex ];
         let mut checkType = expType;
         if expType.$kind == .DDD {
            if #expType.$itemTypeInfoList > 0 {
               checkType = expType.$itemTypeInfoList[ 1 ];
            }
            else {
               checkType = builtinTypeStem_;
            }
         }
         elseif srcIndex > index and expType.$kind == .Abbr {
            // 
            return .Error, "must not use '##'";
         }
            
         if not dstType.canEvalWith( checkType, .SetOp, alt2type ) {
            return .Error, "exp(%d) type mismatch %s <- %s: src: %d"
            ( srcIndex, dstType.getTxt( defaultTypeNameCtrl## ),
              expType.getTxt( defaultTypeNameCtrl## ), srcIndex );
         }
         // let genDstType = dstType.applyGeneric( alt2type );
         // if not checkType.canEvalWith( dstType, .SetOp, alt2type ) {
         //    return .Error, "exp(%d) type mismatch %s <- %s"
         //    ( srcIndex, dstType.getTxt( true## ), expType.getTxt( true## ) );
         // }

         _checkWarnForFollow( srcIndex, dstType, expType );
      }
      return .Match, "";
   }

   if #expTypeList > 0 {
      foreach expType, index in expTypeList {
         if #dstTypeList == 0 {
            return .Error, "over exp. expect:0, actual:%d" ( #expTypeList);
         }
         let dstType = dstTypeList[ index ];
         if #dstTypeList == index {
            // dst の最終引数
            if dstType.$srcTypeInfo.$kind ~= .DDD {
               let isMatch, msg = dstType.canEvalWith( expType, .SetOp, alt2type );
               if not isMatch {
                  return .Error, "exp(%d) type mismatch %s <- %s: index %d%s"
                  ( index, dstType.getTxt( defaultTypeNameCtrl## ),
                    expType.getTxt(defaultTypeNameCtrl## ), index,
                    msg and "-- %s" (msg) or "");               
               }
               if not allowDstShort and #dstTypeList < #expTypeList {
                  return .Error, "over exp. expect: %d: actual: %d"
                  (#dstTypeList, #expTypeList );
               }
            }
            else {
               // dst の最終引数が ... の場合
               let mut dddItemType = builtinTypeStem_;
               if #dstType.$itemTypeInfoList > 0 {
                  dddItemType = dstType.$itemTypeInfoList[ 1 ];
               }
               let result, mess = checkSrcTypeFrom( index, dddItemType );
               if result ~= .Match {
                  return result, mess;
               }
            }

            _checkWarnForFollow( index, dstType, expType );
            // when! warnForFollowSrcIndex {
            //    if warnForFollowSrcIndex <= index and dstType.$nilable {
            //       let mess = "use '**' at arg(%d). %s <- %s"
            //           ( index, dstType.getTxt(true##), expType.getTxt(true##) );
            //       return .Warn, mess;
            //    }
            // }
            break;
         }
         elseif #expTypeList == index {
            // 最終実引数処理
            let mut srcType = expType;
            let mut srcType2nd = builtinTypeAbbrNone;
            //let mut srcType2nd = builtinTypeNil;
            if expType.$kind == .DDD {
               srcType = builtinTypeStem_;
               srcType2nd = builtinTypeStem_;
               if #expType.$itemTypeInfoList > 0 {
                  srcType = expType.$itemTypeInfoList[ 1 ];
                  srcType2nd = srcType;
               }
            }
            elseif expType == builtinTypeAbbr {
               srcType2nd = builtinTypeAbbr;
            }

            let result, mess = checkDstTypeFrom( index, srcType, srcType2nd );
            if result ~= .Match {
               return result, mess;
            }
            _checkWarnForFollow( index, dstType, expType );
            // when! warnForFollowSrcIndex {
            //    if warnForFollowSrcIndex <= index and dstType.$nilable {
            //       let warnMess = "use '**' at arg(%d). %s <- %s"
            //           ( index, dstType.getTxt(true##), expType.getTxt(true##) );
            //       return .Warn, warnMess;
            //    }
            // }
            break;
         }
         else {
            if not dstType.canEvalWith( expType, .SetOp, alt2type ) {
               return .Error, "exp(%d) type mismatch %s <- %s"
               ( index, dstType.getTxt( defaultTypeNameCtrl## ),
                 expType.getTxt( defaultTypeNameCtrl## ));
            }
            _checkWarnForFollow( index, dstType, expType );
            // when! warnForFollowSrcIndex {
            //    if warnForFollowSrcIndex <= index and dstType.$nilable {
            //       let mess = "use '**' at arg(%d). %s <- %s"
            //           ( index, dstType.getTxt(true##), expType.getTxt(true##) );
            //       return .Warn, mess;
            //    }
            // }
         }
      }
   }
   elseif not allowDstShort {
      foreach dstType, index in dstTypeList {
         // if dstType.$kind == .DDD {
         // }
         // else {
            if not dstType.canEvalWith( builtinTypeNil, .SetOp, alt2type ) {
               return .Error, "exp(%d) type mismatch %s <- nil: short"
               ( index, dstType.getTxt( defaultTypeNameCtrl## ));
            }
            return .Warn, Code.format( .nothing_define_abbr,
                                       "use '##', instate of %s."
                                       (dstType.getTxt( defaultTypeNameCtrl##) ) );
         }
      // }
   }
   return .Match, "";
}

/**
typeInfo の関数が、 form と互換があるかどうかチェックする。

form の引数は ... なので、なんでもありになる。
typeInfo の引数がなんでもありでない場合は、互換がなくなるためチェックする。

@param typeInfo チェックする型
*/
fn isSettableToForm( typeInfo:&TypeInfo ): bool {
   if #typeInfo.$argTypeInfoList > 0 {
      foreach argType in typeInfo.$argTypeInfoList {
         if! let dddType = argType@@@DDDTypeInfo {
            if not dddType.$typeInfo.$nilableTypeInfo.equals( builtinTypeStem_## ) {
               return false;
            }
         }
         else {
            if not argType.$srcTypeInfo.equals( builtinTypeStem_ ## ) {
               return false;
            }
         }
      }
   }
   return true;
}

pub static fn TypeInfo.canEvalWithBase(
   dest:&TypeInfo, destMut:bool, other:&TypeInfo, canEvalType:CanEvalType,
   alt2type:Map<&TypeInfo,&TypeInfo> ) : bool, str!
{
   if dest == builtinTypeExp {
      // とりあえず全て OK とする
      return true, nil;
   }
   
   let otherMut = TypeInfo.isMut( other );
   let mut otherSrc = other.$srcTypeInfo;
   if otherSrc.$kind == .DDD {
      if #otherSrc.$itemTypeInfoList > 0 {
         otherSrc = otherSrc.$itemTypeInfoList[ 1 ].$nilableTypeInfo;
      }
      else {
         otherSrc = builtinTypeStem_;
      }
   }

   if otherSrc.$kind == .Alternate {
      if dest.$kind ~= .Alternate {
         otherSrc = AlternateTypeInfo.getAssign( otherSrc, alt2type ).$srcTypeInfo;
      }
   }
   

   switch canEvalType {
      case .SetEq, .SetOp, .SetOpIMut {
         if dest == builtinTypeEmpty {
            // 代入先の型が確定していない状態
            switch otherSrc {
               case builtinTypeAbbr, builtinTypeAbbrNone {
                  return false, nil;
               }
            }
            if otherSrc.$kind == .Func {
               // 関数の型推定は未サポート。
               // 関数の代入先は FormFunc あるいは Form であり、
               // それを型推定できないため。
               // 代入先の FormFunc を自動生成すれば対応できなくはないが、
               // その場合は C-lang へのトランスコード対応が必要。
               return false, nil;
            }
            return true, nil;
         }
         elseif not otherMut and destMut {
            // imut/mut が一致していないものはエラー
            let nonNilOtherType = otherSrc.$nonnilableType;
            switch nonNilOtherType.$kind {
               case .Set, .Map, .List, .IF {
                  return false, nil;
               }
               case .Class {
                  if builtinTypeString ~= nonNilOtherType {
                     return false, nil;
                  }
               }
               case .Prim {
                  if builtinTypeStem == nonNilOtherType {
                     return false, nil;
                  }
               }
            }
         }

         if otherSrc ~= builtinTypeNil and
            otherSrc ~= builtinTypeString and
            otherSrc.$kind ~= .Prim and
            otherSrc.$kind ~= .Func and
            otherSrc.$kind ~= .Method and
            otherSrc.$kind ~= .Form and
            otherSrc.$kind ~= .FormFunc and
            otherSrc.$kind ~= .Enum and
            otherSrc.$kind ~= .Abbr and
            otherSrc.$kind ~= .Alternate and
            otherSrc.$kind ~= .Box and
            not isGenericType( otherSrc ) and
            destMut and not otherMut
         {
            return false, nil;
         }
      }
   }
   

   if dest == builtinTypeStem_ {
      return true, nil;
   }

   if dest.$srcTypeInfo.$kind == .DDD {
      if #dest.$itemTypeInfoList > 0 {
         return dest.$itemTypeInfoList[ 1 ].canEvalWith( other, canEvalType, alt2type )**;
      }
      return true, nil;
   }
   if not dest.$nilable and otherSrc.$nilable {
      if dest.$kind == .Box {
         return dest.canEvalWith( otherSrc, canEvalType, alt2type )**;
      }
      return false, nil;
   }
   if dest == builtinTypeStem and not otherSrc.$nilable {
      return true, nil;
   }
   if dest == builtinTypeForm and
       ( otherSrc.$kind == .Func or
         otherSrc.$kind == .Form or otherSrc.$kind == .FormFunc )
   {
      return isSettableToForm( otherSrc ), nil;
   }
   if otherSrc == builtinTypeNil or otherSrc.$kind == .Abbr {
      if dest.$kind ~= .Nilable {
         return false, nil;
      }
      return true, nil;
   }
   if dest.$typeId == otherSrc.$typeId {
      return true, nil;
   }

   if dest.$kind == .Ext {
      return dest.canEvalWith( otherSrc, canEvalType, alt2type )**;
   }
   if! let extTypeInfo = otherSrc@@@ExtTypeInfo {
      otherSrc = extTypeInfo.$extedType;
   }

   
   if dest.$kind ~= otherSrc.$kind {
      if dest.$kind == .Nilable {
         let dstNonNil;
         if destMut {
            dstNonNil = dest.$nonnilableType;
         }
         else {
            dstNonNil = NormalTypeInfo.createModifier( dest.$nonnilableType, .IMut );
         }
         
         if otherSrc.$nilable {
            if otherSrc.$kind == .DDD {
               return dstNonNil.canEvalWith(
                  otherSrc.$itemTypeInfoList[ 1 ], canEvalType, alt2type )**;
            }
            return dstNonNil.canEvalWith(
               otherSrc.$nonnilableType, canEvalType, alt2type )**;
         }
         return dstNonNil.canEvalWith( otherSrc, canEvalType, alt2type )**;
      }
      elseif isGenericType( dest ) {
         return dest.canEvalWith( otherSrc, canEvalType, alt2type )**;
      }
      elseif ( dest.$kind == .Class or dest.$kind == .IF ) and
         ( otherSrc.$kind == .Class or otherSrc.$kind == .IF )
      {
         if canEvalType == .SetOp or canEvalType == .SetOpIMut {
            return otherSrc.isInheritFrom( dest, alt2type ), nil;
         }
         return false, nil;
      }
      elseif otherSrc.$kind == .Enum {
         let enumTypeInfo = unwrap (otherSrc@@@EnumTypeInfo);
         return dest.canEvalWith( enumTypeInfo.$valTypeInfo, canEvalType, alt2type )**;
      }
      elseif dest.$kind == .Alternate {
         return dest.canEvalWith( otherSrc, canEvalType, alt2type )**;
      }
      elseif dest.$kind == .Box {
         return dest.canEvalWith( otherSrc, canEvalType, alt2type )**;
      }
      elseif dest.$kind == .Form {
         switch otherSrc.$kind {
            case .Form {
               return true, nil;
            }
            case .FormFunc, .Func  {
               return isSettableToForm( otherSrc ), nil;
            }
         }
      }
      elseif dest.$kind == .FormFunc {
         switch otherSrc.$kind {
            case .FormFunc, .Func {
               if TypeInfo.checkMatchType( dest.$argTypeInfoList,
                                           otherSrc.$argTypeInfoList,
                                           false, nil, alt2type ) == .Error or
                  TypeInfo.checkMatchType( otherSrc.$argTypeInfoList,
                                           dest.$argTypeInfoList,
                                           false, nil, alt2type ) == .Error or
                  TypeInfo.checkMatchType( dest.$retTypeInfoList,
                                           otherSrc.$retTypeInfoList,
                                           false, nil, alt2type ) == .Error or
                  TypeInfo.checkMatchType( otherSrc.$retTypeInfoList,
                                           dest.$retTypeInfoList,
                                           false, nil, alt2type ) == .Error or
                  #dest.$retTypeInfoList ~= #otherSrc.$retTypeInfoList
               {
                  return false, nil;
               }
               return true, nil;
            }
         }
      }
      return false, nil;
   }
   // TypeInfoKind が等しい
   switch dest.$kind {
      case .Prim {
         if dest == builtinTypeInt and otherSrc == builtinTypeChar or
            dest == builtinTypeChar and otherSrc == builtinTypeInt
         {
            return true, nil;
         }
         // int から real の代入を暗黙変換を許可すると
         // [ 1, 1.0 ] の型が List<stem> ではなく List<real> なってしまうので
         // 許可しない。
         // if dest == builtinTypeReal and
         //     ( otherSrc == builtinTypeInt or otherSrc == builtinTypeChar )
         // {
         //    return true;
         // }
         return false, nil;
      }
      case .List, .Array, .Set {
         if otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone {
            // literalMap の [], [@] は互換有りとする
            return true, nil;
         }
         _checkEqualsItemType( dest, otherSrc, 1, alt2type, destMut, true );
         return true, nil;
      }
      case .Map {
         if otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone and
            otherSrc.$itemTypeInfoList[ 2 ] == builtinTypeNone
         {
            // literalMap の {} は互換有りとする
            return true, nil;
         }
         fn check1(): bool! {
            _checkEqualsItemType( dest, otherSrc, 1, alt2type, destMut, false );
            return true;
         }
         fn check2(): bool {
            _checkEqualsItemType( dest, otherSrc, 2, alt2type, destMut, false );
            return true;
         }
         let result1 = check1();
         let result2 = check2();
         if result1 and result2 {
            return true, nil;
         }
         if not result1 and otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone or
            not result2 and otherSrc.$itemTypeInfoList[ 2 ] == builtinTypeNone
         {
            return true, nil;
         }
         return false, nil;
      }
      case .Class, .IF {
         if isGenericType( dest ) {
            return dest.canEvalWith( otherSrc, canEvalType, alt2type )**;
         }
         if canEvalType == .SetOp or canEvalType == .SetOpIMut {
            return otherSrc.isInheritFrom( dest, alt2type ), nil;
         }
         return false, nil;
         // return otherSrc.isInheritFrom( dest, alt2type );
      }
      case .Form {
         return isSettableToForm( otherSrc ), nil;
      }
      case .Func, .FormFunc {
         if TypeInfo.checkMatchType( dest.$argTypeInfoList, otherSrc.$argTypeInfoList,
                                     false, nil, alt2type ) == .Error or
            TypeInfo.checkMatchType( dest.$retTypeInfoList, otherSrc.$retTypeInfoList,
                                     false, nil, alt2type ) == .Error or
            #dest.$retTypeInfoList ~= #otherSrc.$retTypeInfoList
         {
            return false, nil;
         }
         return true, nil;
      }
      case .Method {
         // if TypeInfo.checkMatchType( dest.$argTypeInfoList, otherSrc.$argTypeInfoList,
         //                             false, nil, alt2type ) == .Error or
         //    TypeInfo.checkMatchType( dest.$retTypeInfoList, otherSrc.$retTypeInfoList,
         //                             false, nil, alt2type ) == .Error or
         //    #dest.$retTypeInfoList ~= #otherSrc.$retTypeInfoList
         // {
         //    return false;
         // }
         if #dest.$argTypeInfoList ~= #otherSrc.$argTypeInfoList or
            #dest.$retTypeInfoList ~= #otherSrc.$retTypeInfoList
         {
            return false, nil;
         }
         foreach argType, index in dest.$argTypeInfoList {
            let otherArgType = otherSrc.$argTypeInfoList[ index ];
            if not argType.equals( otherArgType, alt2type ## ) {
               let mess = "unmatch arg(%d) type -- %s, %s"
                   ( index, argType.getTxt(##), otherArgType.getTxt(##) );
               return false, mess;
            }
         }
         foreach retType, index in dest.$retTypeInfoList {
            let otherRetType = otherSrc.$retTypeInfoList[ index ];
            if not retType.equals( otherRetType, alt2type ## ) {
               let mess = "unmatch ret(%d) type -- %s, %s, %s"
                   (index, retType.getTxt(##), otherRetType.getTxt(##), dest.getTxt(##) );
               return false, mess;
            }
         }
         if dest.$mutMode ~= otherSrc.$mutMode {
            let mess = "unmatch mutable mode -- %s, %s"
                (dest.$mutMode.$_txt, otherSrc.$mutMode.$_txt );
            return false, mess;
         }
         return true, nil;
      }
      case .Nilable {
         let dstNonNil;
         if destMut {
            dstNonNil = dest.$nonnilableType;
         }
         else {
            dstNonNil = NormalTypeInfo.createModifier( dest.$nonnilableType, .IMut );
         }
         return dstNonNil.canEvalWith(
            otherSrc.$nonnilableType, canEvalType, alt2type )**;
      }
      case .Alternate {
         return dest.canEvalWith( otherSrc, canEvalType, alt2type )**;
      }
      case .Box {
         return dest.canEvalWith( otherSrc, canEvalType, alt2type )**;
      }
      default {
         return false, nil;
      }
   }
}


// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NormalTypeInfo.canEvalWith(
   other:&TypeInfo,
   canEvalType:CanEvalType, alt2type:Map<&TypeInfo,&TypeInfo> ) : bool, str!
{
   return TypeInfo.canEvalWithBase(
      self, TypeInfo.isMut( self ), other, canEvalType, alt2type )**;
}



pub override fn ModifierTypeInfo.applyGeneric(
   alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ): &TypeInfo!
{
   let typeInfo = self.srcTypeInfo.applyGeneric( alt2typeMap, moduleTypeInfo );
   if typeInfo == self.srcTypeInfo {
      return self;
   }
   when! typeInfo {
      return NormalTypeInfo.createModifier( typeInfo, .IMut );
   }
   return nil;
}


pub override fn NormalTypeInfo.applyGeneric(
   alt2typeMap:&Map<&TypeInfo,&TypeInfo>, moduleTypeInfo:&TypeInfo ): &TypeInfo!
{
   let! itemTypeInfoList, needNew = applyGenericList(
      self.itemTypeInfoList, alt2typeMap, moduleTypeInfo )
   {
      return nil;
   };
   switch self.$kind {
      case .Set {
         if not needNew {
            return self;
         }
         return NormalTypeInfo.createSet(
            self.accessMode, self.parentInfo, itemTypeInfoList, self.mutMode );
      }
      case .List {
         if not needNew {
            return self;
         }
         return NormalTypeInfo.createList(
            self.accessMode, self.parentInfo, itemTypeInfoList, self.mutMode );
      }
      case .Array {
         if not needNew {
            return self;
         }
         return NormalTypeInfo.createArray(
            self.accessMode, self.parentInfo, itemTypeInfoList, self.mutMode );
      }
      case .Map {
         if not needNew {
            return self;
         }
         return NormalTypeInfo.createMap(
            self.accessMode, self.parentInfo,
            itemTypeInfoList[ 1 ], itemTypeInfoList[ 2 ], self.mutMode );
      }
      case .Func, .Form, .FormFunc {
         let! argTypeInfoList, workArg = applyGenericList(
            self.argTypeInfoList, alt2typeMap, moduleTypeInfo )
         {
            return nil;
         };
         let! retTypeInfoList, workRet = applyGenericList(
            self.retTypeInfoList, alt2typeMap, moduleTypeInfo )
         {
            return nil;
         };
         if needNew or workArg or workRet {
            return NormalTypeInfo.createFunc(
               self.abstractFlag, false, getScope( self ), self.kind,
               self.parentInfo, self.autoFlag, self.externalFlag,
               self.staticFlag, self.accessMode, self.rawTxt,
               itemTypeInfoList, argTypeInfoList, retTypeInfoList, 
               TypeInfo.isMut( self ) );
         }
         return self;
      }
      default {
         if #self.itemTypeInfoList == 0 {
            return self;
         }
         return nil;
      }
   }
}


pub fn TypeInfo.getFullName(
   typeNameCtrl:&TypeNameCtrl, importInfo:&ModuleInfoManager, localFlag:bool! ) : str
{
   if localFlag and self.isModule() {
      return typeNameCtrl.getModuleName( self, "", importInfo );
   }
   return self.getParentFullName( typeNameCtrl, importInfo, localFlag ) .. self.$rawTxt;
}

pub class ProcessInfo {
   let mut idProvier:IdProvider {pub};
   let mut idProvierExt:IdProvider {pub};
   let mut typeInfo2Map:TypeInfo2Map {pub};
}

let mut processInfoQueue:List<ProcessInfo> = [];

pub enum IdType {
   Base,
   Ext,
}
pub fn switchIdProvier( idType:IdType ) {
   if idType == .Base {
      idProv = idProvBase;
   }
   else {
      idProv = idProvExt;
   }
}

let builtinTypeInfo2Map = typeInfo2Map.clone();

pub fn pushProcessInfo( processInfo:ProcessInfo! ): ProcessInfo {

   if #processInfoQueue == 0 {
      if idProv.$id >= userStartId {
         Util.err( "builtinId is over" );
      }
   }


   processInfoQueue.insert(
      new ProcessInfo( idProvBase, idProvExt, typeInfo2Map ) );
   when! processInfo {
      idProvBase = processInfo.$idProvier;
      idProvExt = processInfo.$idProvierExt;
      typeInfo2Map = processInfo.$typeInfo2Map;
   }
   else {
      idProvBase = new IdProvider( userStartId, extStartId );
      idProvExt = new IdProvider( extStartId, extMaxId );
      typeInfo2Map = builtinTypeInfo2Map.clone();
   }
   idProv = idProvBase;
   return new ProcessInfo( idProvBase, idProvExt, typeInfo2Map );
}

pub fn popProcessInfo() {
   let mut info = processInfoQueue[ #processInfoQueue ];
   idProvBase = info.$idProvier;
   idProvExt = info.$idProvierExt;
   idProv = idProvBase;
   typeInfo2Map = info.$typeInfo2Map;
}

pub enum BitOpKind {
   And,
   Or,
   Xor,
   LShift,
   RShift,
}

pub let bitBinOpMap = {
   "&": BitOpKind.And,
   "|": BitOpKind.Or,
   "~": BitOpKind.Xor,
   "|>>": BitOpKind.RShift,
   "|<<": BitOpKind.LShift,
};

pub let compOpSet = (@ "==", "~=" );
pub let mathCompOpSet = (@ "<", "<=", ">", ">=" );

pub class RefTypeInfo {
   let pos:Parser.Position {pub};
   let mut itemRefTypeList: List<&RefTypeInfo> {pub};
   let typeInfo:&TypeInfo {pub};
}

class TypeAnalyzer {
   let mut parser:Parser.PushbackParser;
   let parentInfo:&TypeInfo;
   let moduleType:&TypeInfo;
   let moduleScope:&Scope;
   let mut scope:&Scope;
   let scopeAccess:ScopeAccess;
   let mut accessMode: AccessMode;
   let mut parentPub:bool;
   let validMutControl:bool;

   pub fn __init( parentInfo:&TypeInfo, moduleType:&TypeInfo, moduleScope:&Scope,
                  scopeAccess:ScopeAccess, validMutControl:bool )
   {
      self.parentInfo = parentInfo;
      self.moduleType = moduleType;
      self.moduleScope = moduleScope;
      self.scopeAccess = scopeAccess;
      self.validMutControl = validMutControl;

      self.scope = rootScope;
      self.accessMode = .Local;
      self.parentPub = false;
      self.parser = new Parser.DefaultPushbackParser( new Parser.DummyParser() );
   }
   
   pub fn analyzeTypeItemList(
      allowDDD:bool, refFlag: bool, mutFlag: bool,
      typeInfo:&TypeInfo, pos:&Parser.Position ) mut:
      &RefTypeInfo!, &Parser.Position!, str!;

   fn analyzeTypeSub( allowDDD:bool ) mut :
      &RefTypeInfo!, &Parser.Position!, str!;

   pub fn analyzeType(
      scope:&Scope, parser:Parser.PushbackParser, accessMode: AccessMode,
      allowDDD:bool, parentPub:bool ) mut : &RefTypeInfo!, &Parser.Position!, str!
   {
      self.scope = scope;
      self.parser = parser;
      self.accessMode = accessMode;
      self.parentPub = parentPub;
      return self.analyzeTypeSub( allowDDD )**;
   }

   pub fn analyzeTypeFromTxt(
      txt:str, scope:&Scope, accessMode: AccessMode, parentPub:bool ) mut :
      &RefTypeInfo!, &Parser.Position!, str!
   {
      let mut stream = new Parser.TxtStream( txt );
      let mut parser =
         new Parser.DefaultPushbackParser( new Parser.StreamParser( stream, "test" ## ) );
      return self.analyzeType( scope, parser, accessMode, true, parentPub )**;
   }
}

pub fn TypeAnalyzer.analyzeTypeSub( allowDDD:bool ) mut :
   &RefTypeInfo!, &Parser.Position!, str!
{
   let firstToken = self.parser.getTokenNoErr();
   let mut token = firstToken;
   let mut refFlag = false;
   if token.txt == "&" {
      refFlag = true;
      token = self.parser.getTokenNoErr();
   }
   let mut mutFlag = false;
   if token.txt == "mut" {
      mutFlag = true;
      token = self.parser.getTokenNoErr();
   }
   // builtin の型名などは _ で始まることもあるので、シンボル名チェックしない
   // self.checkSymbol( token, .MustNot_ );

   let typeInfo:TypeInfo;
   if token.txt == "..." {
      // ... は変数シンボルとしても使用するので
      // analyzeExpSymbol で解析すると意図しないシンボルを取ってくる可能性があるため、
      // ここで特別に処理する。
      typeInfo = builtinTypeDDD;
   }
   else {
      let! symbol = self.scope.getSymbolTypeInfo(
         token.txt, self.scope, self.moduleScope, self.scopeAccess )
      {
         return nil, token.pos, "not found type -- " .. token.txt;
      };
      if symbol.$kind ~= .Typ {
         return nil, token.pos, "illegal type -- %s" ( symbol.$name );
      }
      typeInfo = symbol.$typeInfo;
   }
   return self.analyzeTypeItemList(
      allowDDD, refFlag, mutFlag, typeInfo, token.pos )**;
}

pub fn TypeAnalyzer.analyzeTypeItemList(
   allowDDD:bool, refFlag: bool, mutFlag: bool,
   mut typeInfo:&TypeInfo, pos:&Parser.Position ) mut:
   &RefTypeInfo!, &Parser.Position!, str!
{
   if self.parentPub and
      isPubToExternal( self.accessMode ) and
      not isPubToExternal( typeInfo.$accessMode )
   {
      // 公開する型の中で非公開な型を利用するのは NG
      return nil, pos, "This type must be public. -- %s" (typeInfo.getTxt(##) );
   }
   

   let mut token = self.parser.getTokenNoErr();
   
   if token.consecutive and token.txt == "!" {
      typeInfo = typeInfo.$nilableTypeInfo;
      token = self.parser.getTokenNoErr();
   }

   macro _checkToken( workToken:sym, oneChar:str ) {
      {}
      if ,,workToken.txt ~= ,,oneChar {
         return nil, ,,workToken.pos, "not found -- ']'";
      }
   }
   
   let mut arrayMode = "no";
   let mut genericRefList: List<&RefTypeInfo> = [];
   while true {
      if token.txt == '[' or token.txt == '[@' {
         if token.txt == '[' {
            arrayMode = "list";
            typeInfo = NormalTypeInfo.createList(
               self.accessMode, self.parentInfo, [ typeInfo ], .Mut );
         }
         else {
            arrayMode = "array";
            typeInfo = NormalTypeInfo.createArray(
               self.accessMode, self.parentInfo, [ typeInfo ], .Mut );
         }
         token = self.parser.getTokenNoErr();
         _checkToken( token, ']' );
      }
      elseif token.txt == "<" {
         let mut genericList: List<&TypeInfo> = [];
         let mut nextToken: &Parser.Token = Parser.getEofToken();
         repeat {
            let refType, refPos, mess = self.analyzeTypeSub( false );
            when! refType {
               genericRefList.insert( refType );
               genericList.insert( refType.$typeInfo );
            }
            nextToken = self.parser.getTokenNoErr();
         } nextToken.txt ~= ",";
         _checkToken( nextToken, '>' );

         macro _checkAlternateTypeCount( count:__exp ) {
            if #genericList ~= ,,count {
               return nil, pos, "generic type count is unmatch. -- %d" (#genericList);
            }
         }

         switch typeInfo.$kind {
            case .Map {
               if #genericList ~= 2 {
                  return nil, pos, "Key or value type is unknown";
               }
               else {
                  typeInfo = NormalTypeInfo.createMap(
                     self.accessMode, self.parentInfo,
                     genericList[ 1 ], genericList[ 2 ], .Mut );
               }
            }
            case .List {
               _checkAlternateTypeCount( 1 );
               typeInfo = NormalTypeInfo.createList(
                  self.accessMode, self.parentInfo, genericList, .Mut );
            }
            case .Array {
               _checkAlternateTypeCount( 1 );
               typeInfo = NormalTypeInfo.createArray(
                  self.accessMode, self.parentInfo, genericList, .Mut );
            }
            case .Set {
               _checkAlternateTypeCount( 1 );
               typeInfo = NormalTypeInfo.createSet(
                  self.accessMode, self.parentInfo, genericList, .Mut );
            }
            case .DDD {
               _checkAlternateTypeCount( 1 );
               typeInfo = NormalTypeInfo.createDDD( genericList[1], false );
            }
            case .Class, .IF {
               _checkAlternateTypeCount( #typeInfo.$itemTypeInfoList );
               foreach itemType, index in genericList {
                  let altType =
                     unwrap typeInfo.$itemTypeInfoList[ index ]@@@AlternateTypeInfo;
                  if itemType.$nilable {
                     let mess = "can't use nilable type -- %s" (itemType.getTxt(##));
                     return nil, pos, mess;
                  }
               }
               typeInfo = NormalTypeInfo.createGeneric(
                  typeInfo, genericList, self.moduleType );
            }
            case .Box {
               _checkAlternateTypeCount( 1 );
               typeInfo = NormalTypeInfo.createBox( self.accessMode, genericList[1] );
            }
            case .Ext {
               _checkAlternateTypeCount( 1 );
               typeInfo = NormalTypeInfo.createLuaval( genericList[1] );
            }
            default {
               return nil , pos, "not support generic: %s" (typeInfo.getTxt(##));
            }
         }
      }
      else {
         self.parser.pushback();
         break;
      }
      token = self.parser.getTokenNoErr();
   }
   if token.txt == "!" {
      typeInfo = typeInfo.get_nilableTypeInfo();
      token = self.parser.getTokenNoErr();
   }

   if not allowDDD {
      if typeInfo.$kind == .DDD {
         return nil, pos, "invalid type. -- '%s'" (typeInfo.getTxt(##));
      }
   }

   if refFlag {
      if self.validMutControl {
         typeInfo = NormalTypeInfo.createModifier( typeInfo, .IMut );
      }
   }

   return new RefTypeInfo( pos, genericRefList, typeInfo ), nil, nil;
}




__test case1 {
   import lune.base.Testing;

   let mut ctrl = new Testing.Ctrl();
   let builtinMap = {
      "$$": headTypeInfo,
      "Array": builtinTypeArray,
      "List": builtinTypeList,
      "Mapping": builtinTypeMapping,
      "Nilable": builtinTypeBox,
      "Set": builtinTypeSet,
      "form": builtinTypeForm,
      "str": builtinTypeString
   };
   forsort typeInfo, name in builtinMap {
      if not Testing._eq( ctrl, typeInfo, rootScope.getTypeInfoChild( name ) ) {
         print( "NG:", name );
      }
   }
   let mut alt2typeMap = CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );

   let mut testScope = new Scope( rootScope, false## );

   

   macro _checkTypeAnalyzer(typeTxt:str,typeInfo:__exp ) {
      {}
      {
         let mut analyzer = new TypeAnalyzer(
            headTypeInfo, headTypeInfo, testScope, .Normal, true );
         let refType, pos, msg =
            analyzer.analyzeTypeFromTxt( ,,typeTxt, testScope, .Local, false );
         when! refType {
            if not Testing._isTM( ctrl, ,,typeTxt,
                                  refType.$typeInfo.equals( ,,typeInfo ## ) )
            {
               print( refType.$typeInfo.getTxt(##) );
            }
         }
         else {
            Testing._err( ctrl, "refType is nil -- " .. ,,typeTxt );
         }
      }
   }
   _checkTypeAnalyzer( "int", builtinTypeInt );
   _checkTypeAnalyzer( "int!", builtinTypeInt.$nilableTypeInfo );
   _checkTypeAnalyzer( "&int", NormalTypeInfo.createModifier( builtinTypeInt, .IMut ) );
   _checkTypeAnalyzer( "...", builtinTypeDDD );
   _checkTypeAnalyzer( "...<int>", NormalTypeInfo.createDDD( builtinTypeInt, true ) );
   _checkTypeAnalyzer( "Luaval<form>", NormalTypeInfo.createLuaval( builtinTypeForm ) );

   let intListType =
      NormalTypeInfo.createList( .Local, headTypeInfo, [ builtinTypeInt ], .Mut );
   _checkTypeAnalyzer( "List<int>", intListType );
   _checkTypeAnalyzer( "List<int>!", intListType.$nilableTypeInfo );

   fn getType( typeTxt:str ):&TypeInfo! {
      let mut analyzer = new TypeAnalyzer(
         headTypeInfo, headTypeInfo, testScope, .Normal, true );
      let refType, pos, msg =
         analyzer.analyzeTypeFromTxt( typeTxt, testScope, .Local, false );
      return refType$.$typeInfo;
   }

   // type2 から type1 の型への canEvalWith() の結果が ok になるか ng になるか。
   // 別の表現をすると type2 から type1 への代入が出来るかどうか。出来る場合は OK
   macro _checkCanEvalWith(type1:str,type2:str,exp:str) {
      {
         let opSym:str;
         if exp == "OK" {
            opSym = "_isTM";
         }
         else {
            opSym = "_isNotTM";
         }
      }
      {
         if! let typeInfo1, typeInfo2 = getType( ,,type1 ), getType( ,,type2 ) {
            Testing.,,,opSym(
               ctrl, "%s <- %s" (,,type1, ,,type2),
               (typeInfo1.canEvalWith( typeInfo2, .SetOp, alt2typeMap )));
         }
         else {
            Testing._err( ctrl, "not found type -- %s, %s" (,,type1, ,,type2) );
         }
      }
   }

   // int 同士の canEvalWith
   _checkCanEvalWith( "int", "int", "OK" );
   _checkCanEvalWith( "int!", "int", "OK" );
   _checkCanEvalWith( "int", "int!", "NG" );
   _checkCanEvalWith( "&int", "int", "OK" );
   _checkCanEvalWith( "&int!", "int", "OK" );
   _checkCanEvalWith( "int", "&int", "OK" ); // int は int <- &int が可能
   _checkCanEvalWith( "int", "&int!", "NG" );


   // int と str の canEvalWith
   _checkCanEvalWith( "int", "str", "NG" );
   _checkCanEvalWith( "int!", "str", "NG" );
   _checkCanEvalWith( "int", "str!", "NG" );
   _checkCanEvalWith( "&int", "str", "NG" );
   _checkCanEvalWith( "&int!", "str", "NG" );
   _checkCanEvalWith( "int", "&str", "NG" );
   _checkCanEvalWith( "int", "&str!", "NG" );


   // Super と Sub の canEvalWith
   let superType = NormalTypeInfo.createClass(
      true, false, new Scope( rootScope, true ## ),
      nil, nil, [], headTypeInfo, false, .Local, "Super" );
   testScope.addClass( "Super", nil, superType );   
   let subType = NormalTypeInfo.createClass(
      true, false, new Scope( rootScope, true ## ),
      superType, nil, [], headTypeInfo, false, .Local, "Sub" );
   testScope.addClass( "Sub", nil, subType );   

   _checkCanEvalWith( "Super", "Sub", "OK" );
   _checkCanEvalWith( "Super", "Sub!", "NG" );
   _checkCanEvalWith( "Super!", "Sub", "OK" );
   _checkCanEvalWith( "Super!", "Sub!", "OK" );
   _checkCanEvalWith( "&Super", "Sub", "OK" );
   _checkCanEvalWith( "&Super", "Sub!", "NG" );
   _checkCanEvalWith( "&Super!", "Sub", "OK" );
   _checkCanEvalWith( "&Super!", "Sub!", "OK" );
   _checkCanEvalWith( "Super", "&Sub", "NG" );
   _checkCanEvalWith( "Super", "&Sub!", "NG" );
   _checkCanEvalWith( "&Super", "&Sub", "OK" );
   _checkCanEvalWith( "&Super", "&Sub!", "NG" );
   _checkCanEvalWith( "&Super!", "&Sub", "OK" );
   _checkCanEvalWith( "&Super!", "&Sub!", "OK" );
   

   // List<int> 同士の canEvalWith
   _checkCanEvalWith( "List<int>", "List<int>", "OK" );
   _checkCanEvalWith( "List<int>!", "List<int>", "OK" );
   _checkCanEvalWith( "List<int>", "List<int>!", "NG" );
   _checkCanEvalWith( "&List<int>", "List<int>", "OK" );
   _checkCanEvalWith( "&List<int>!", "List<int>", "OK" );
   _checkCanEvalWith( "List<int>", "&List<int>", "NG" );
   _checkCanEvalWith( "List<int>", "&List<int>!", "NG" );

   // List<int> と List<str> の canEvalWith
   _checkCanEvalWith( "List<int>", "List<str>", "NG" );
   _checkCanEvalWith( "List<int>!", "List<str>", "NG" );
   _checkCanEvalWith( "List<int>", "List<str>!", "NG" );
   _checkCanEvalWith( "&List<int>", "List<str>", "NG" );
   _checkCanEvalWith( "&List<int>!", "List<str>", "NG" );
   _checkCanEvalWith( "List<int>", "&List<str>", "NG" );
   _checkCanEvalWith( "List<int>", "&List<str>!", "NG" );

   // List<Super> と List<Sub> の canEvalWith

   // Mutable な generics は、継承関係のある型パラメータでもエラー
   _checkCanEvalWith( "List<Super>", "List<Sub>", "NG" );
   _checkCanEvalWith( "List<Super>", "List<Sub>!", "NG" );
   _checkCanEvalWith( "List<Super>!", "List<Sub>", "NG" );
   _checkCanEvalWith( "List<Super>!", "List<Sub>!", "NG" );
   _checkCanEvalWith( "List<&Super>", "List<Sub>", "NG" );
   _checkCanEvalWith( "List<&Super>", "List<Sub>!", "NG" );
   _checkCanEvalWith( "List<&Super>!", "List<Sub>", "NG" );
   _checkCanEvalWith( "List<&Super>!", "List<Sub>!", "NG" );
   _checkCanEvalWith( "List<Super>", "List<&Sub>", "NG" );
   _checkCanEvalWith( "List<Super>", "List<&Sub>!", "NG" );
   _checkCanEvalWith( "List<&Super>", "List<&Sub>", "NG" );
   _checkCanEvalWith( "List<&Super>", "List<&Sub>!", "NG" );
   _checkCanEvalWith( "List<&Super>!", "List<&Sub>", "NG" );
   _checkCanEvalWith( "List<&Super>!", "List<&Sub>!", "NG" );

   // Imutable な generics は、継承関係のある型パラメータで OK
   _checkCanEvalWith( "&List<Super>", "List<Sub>", "OK" );
   _checkCanEvalWith( "&List<Super>", "List<Sub>!", "NG" );
   _checkCanEvalWith( "&List<Super>!", "List<Sub>", "OK" );
   _checkCanEvalWith( "&List<Super>!", "List<Sub>!", "OK" );
   _checkCanEvalWith( "&List<&Super>", "List<Sub>", "OK" );
   _checkCanEvalWith( "&List<&Super>", "List<Sub>!", "NG" );
   _checkCanEvalWith( "&List<&Super>!", "List<Sub>", "OK" );
   _checkCanEvalWith( "&List<&Super>!", "List<Sub>!", "OK" );
   _checkCanEvalWith( "&List<Super>", "List<&Sub>", "NG" );
   _checkCanEvalWith( "&List<Super>", "List<&Sub>!", "NG" );
   _checkCanEvalWith( "&List<&Super>", "List<&Sub>", "OK" );
   _checkCanEvalWith( "&List<&Super>", "List<&Sub>!", "NG" );
   _checkCanEvalWith( "&List<&Super>!", "List<&Sub>", "OK" );
   _checkCanEvalWith( "&List<&Super>!", "List<&Sub>!", "OK" );


   // Hoge<int> と Hoge<int> の canEvalWith
   let mut genTypeList:List<&AlternateTypeInfo> = [];
   let alter = NormalTypeInfo.createAlternate( true, 1, "T", .Pri, headTypeInfo ## );
   genTypeList.insert( alter );
   let hogeType = NormalTypeInfo.createClass(
      true, false, new Scope( rootScope, true ## ),
      nil, nil, genTypeList, headTypeInfo, false, .Local, "Hoge" );
   testScope.addClass( "Hoge", nil, hogeType );

   _checkCanEvalWith( "Hoge<int>", "Hoge<int>", "OK" );
   _checkCanEvalWith( "Hoge<int>!", "Hoge<int>", "OK" );
   _checkCanEvalWith( "Hoge<int>", "Hoge<int>!", "NG" );
   _checkCanEvalWith( "&Hoge<int>", "Hoge<int>", "OK" );
   _checkCanEvalWith( "&Hoge<int>!", "Hoge<int>", "OK" );
   _checkCanEvalWith( "Hoge<int>", "&Hoge<int>", "NG" );
   _checkCanEvalWith( "Hoge<int>", "&Hoge<int>!", "NG" );

   // // // Hoge<Super> と Hoge<Super> の canEvalWith
   _checkCanEvalWith( "Hoge<Super>", "Hoge<Super>", "OK" );
   _checkCanEvalWith( "Hoge<Super>!", "Hoge<Super>", "OK" );
   _checkCanEvalWith( "Hoge<Super>", "Hoge<Super>!", "NG" );
   _checkCanEvalWith( "&Hoge<Super>", "Hoge<Super>", "OK" );
   _checkCanEvalWith( "&Hoge<Super>!", "Hoge<Super>", "OK" );
   _checkCanEvalWith( "Hoge<Super>", "&Hoge<Super>", "NG" );
   _checkCanEvalWith( "Hoge<Super>", "&Hoge<Super>!", "NG" );

   // // Hoge<Super> と Hoge<Sub> の canEvalWith

   // Mutable な generics は、継承関係のある型パラメータでもエラー
   _checkCanEvalWith( "Hoge<Super>", "Hoge<Sub>", "NG" );
   _checkCanEvalWith( "Hoge<Super>", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<Super>!", "Hoge<Sub>", "NG" );
   _checkCanEvalWith( "Hoge<Super>!", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<&Super>", "Hoge<Sub>", "NG" );
   _checkCanEvalWith( "Hoge<&Super>", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<&Super>!", "Hoge<Sub>", "NG" );
   _checkCanEvalWith( "Hoge<&Super>!", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<Super>", "Hoge<&Sub>", "NG" );
   _checkCanEvalWith( "Hoge<Super>", "Hoge<&Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<&Super>", "Hoge<&Sub>", "NG" );
   _checkCanEvalWith( "Hoge<&Super>", "Hoge<&Sub>!", "NG" );
   _checkCanEvalWith( "Hoge<&Super>!", "Hoge<&Sub>", "NG" );
   _checkCanEvalWith( "Hoge<&Super>!", "Hoge<&Sub>!", "NG" );
   
   // Imutable な generics は、継承関係のある型パラメータで OK
   _checkCanEvalWith( "&Hoge<Super>", "Hoge<Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<Super>", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "&Hoge<Super>!", "Hoge<Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<Super>!", "Hoge<Sub>!", "OK" );
   _checkCanEvalWith( "&Hoge<&Super>", "Hoge<Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<&Super>", "Hoge<Sub>!", "NG" );
   _checkCanEvalWith( "&Hoge<&Super>!", "Hoge<Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<&Super>!", "Hoge<Sub>!", "OK" );
   _checkCanEvalWith( "&Hoge<Super>", "Hoge<&Sub>", "NG" );
   _checkCanEvalWith( "&Hoge<Super>", "Hoge<&Sub>!", "NG" );
   _checkCanEvalWith( "&Hoge<&Super>", "Hoge<&Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<&Super>", "Hoge<&Sub>!", "NG" );
   _checkCanEvalWith( "&Hoge<&Super>!", "Hoge<&Sub>", "OK" );
   _checkCanEvalWith( "&Hoge<&Super>!", "Hoge<&Sub>!", "OK" );
}
