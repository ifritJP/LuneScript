/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Parser;
import lune.base.Util;
import lune.base.frontInterface;
import lune.base.Code;

pub class IdProvider {
   let mut id:int {pub};
   let maxId:int;

   pub fn increment() mut {
      self.id = self.id + 1;
      if self.id >= self.maxId {
         Util.err( "id is over" );
      }
   }
   
   pub fn getNewId() mut : int {
      let newId = self.id;
      self.id = self.id + 1;
      if self.id >= self.maxId {
         Util.err( "id is over" );
      }
      return newId;
   }
}

let extStartId = 100000;
let extMaxId = 10000000;

/** 解析対象モジュールの ID 管理 */
let mut idProvBase = new IdProvider( 1, extStartId );
/** import する外部モジュールの ID 管理 */
let mut idProvExt = new IdProvider( extStartId, extMaxId );
let mut idProv = idProvBase;

/**
ビルトインでないユーザが定義した型情報の ID 開始番号。

import 等で、別モジュールを解析する際に、モジュール毎の開始番号として使用する。
*/
let userStartId = 1000;

pub let rootTypeId = idProv.getNewId();
//let mut typeIdSeed = rootTypeId + 1;



pub proto class TypeInfo;
pub proto abstract class SymbolInfo;

pub let mut typeInfoKind:Map<str,TypeInfo> = {};
pub let mut sym2builtInTypeMap:Map<str,SymbolInfo> = {};
pub let mut builtInTypeIdSet:Map<int,&TypeInfo> = {};

pub enum SerializeKind {
   Nilable,
   Modifier,
   Module,
   Normal,
   Enum,
   Alge,
   DDD,
   Alias,
   Alternate,
   Generic,
}

pub enum TypeInfoKind {
   Root,
   Macro,
   Prim,
   List,
   Array,
   Map,
   Class,
   IF,
   Func,    
   Method,  
   Nilable, 
   Enum,    
   Module,
   Stem,
   Alge,
   /** ... */
   DDD,
   /** 省略 ## */
   Abbr,
   Set,
   Alternate,
}

pub fn isBuiltin( typeId: int ) : bool {
   return builtInTypeIdSet[ typeId ] ~= nil;
}

pub proto class Scope;

pub enum SymbolKind {
   /** 型 */
   Typ,
   /** メンバ */
   Mbr,
   /** メソッド */
   Mtd,
   /** 関数 */
   Fun,
   /** 変数 */
   Var,
   /** 引数 */
   Arg,
   /** マクロ */
   Mac,
}

pub enum AccessMode {
   None,
   Pub,
   Pro,
   Pri,
   Local,
   Global,
}

pub fn isPubToExternal( mode:AccessMode ): bool {
   switch mode {
      case .Pub, .Pro, .Global {
         return true;
      }
   }
   return false;
}

let mut txt2AccessModeMap:Map<str,AccessMode> = {};
txt2AccessModeMap[ "none" ] = .None;
txt2AccessModeMap[ "pub" ] = .Pub;
txt2AccessModeMap[ "pro" ] = .Pro;
txt2AccessModeMap[ "pri" ] = .Pri;
txt2AccessModeMap[ "local" ] = .Local;
txt2AccessModeMap[ "global" ] = .Global;
pub fn txt2AccessMode( accessMode:str ) : AccessMode! {
   return txt2AccessModeMap[ accessMode ];
}


/** シンボル情報 */
pub abstract class SymbolInfo {
   /** 左辺値になれる場合 true */
   pub abstract fn get_canBeLeft(): bool;
   /** 右辺値になれる場合 true */
   pub abstract fn get_canBeRight(): bool;
   /** このシンボルの ID */
   pub abstract fn get_symbolId(): int;
   /** このシンボルが属するスコープ */
   pub abstract fn get_scope(): Scope;
   /** シンボルのアクセス */
   pub abstract fn get_accessMode(): AccessMode;
   /** */
   pub abstract fn get_staticFlag(): bool;
   /** シンボルの名前 */
   pub abstract fn get_name(): str;
   /** シンボルの型 */
   pub abstract fn get_typeInfo(): TypeInfo;
   /** このシンボルが mut かどうか */
   pub abstract fn get_mutable(): bool;
   /** このシンボルの種類 SymbolKind */
   pub abstract fn get_kind(): SymbolKind;
   /** このシンボルがデータを保持しているかどうか */
   pub abstract fn get_hasValueFlag(): bool;
   pub abstract fn set_hasValueFlag( arg:bool );

   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub abstract fn canAccess( fromScope:&Scope ): &SymbolInfo!;

   pub abstract fn getOrg(): &SymbolInfo;
}


pub class NormalSymbolInfo extend SymbolInfo {
   pri static let mut symbolIdSeed:int;

   __init {
      NormalSymbolInfo.symbolIdSeed = 0;
   }

   /** 左辺値になれる場合 true */
   pri let canBeLeft: bool { pub };
   /** 右辺値になれる場合 true */
   pri let canBeRight: bool { pub };
   
   /** このシンボルの ID */
   pri let symbolId: int { pub };
   /** このシンボルが属するスコープ */
   pri let scope: Scope { pub };
   /** シンボルのアクセス */
   pri let accessMode: AccessMode { pub };
   /** */
   pri let staticFlag: bool { pub };
   /** シンボルの名前 */
   pri let name: str { pub };
   /** シンボルの型 */
   pri let typeInfo: &TypeInfo { pub };
   /** このシンボルが mut かどうか */
   pri let mutable: bool { pub };
   /** このシンボルの種類 SymbolKind */
   pri let kind: SymbolKind { pub };
   /** このシンボルがデータを保持しているかどうか */
   pri let hasValueFlag: bool { pub, pub };

   pub override fn getOrg(): &SymbolInfo {
      return self;
   }


   pub fn __init(
      kind:SymbolKind, canBeLeft:bool, canBeRight:bool, scope: Scope,
      accessMode: AccessMode, staticFlag: bool, name: str, 
      typeInfo: &TypeInfo, mutable: bool!, hasValueFlag: bool )
   {
      super();
      NormalSymbolInfo.symbolIdSeed = NormalSymbolInfo.symbolIdSeed + 1;
      self.kind = kind;
      self.canBeLeft = canBeLeft;
      self.canBeRight = canBeRight;
      self.symbolId = NormalSymbolInfo.symbolIdSeed;
      self.scope = scope;
      self.accessMode = accessMode;
      self.staticFlag = staticFlag;
      self.name = name;
      self.typeInfo = typeInfo;
      self.mutable = mutable and true or false;
      self.hasValueFlag = hasValueFlag;
   }

   /**
このシンボルにアクセス可能かどうか調べる。

@param fromScope このシンボルにアクセスしようとしているスコープ。
*/
   pub override fn canAccess( fromScope:&Scope ): &SymbolInfo!;
}


pub class DataOwnerInfo {
   pub let hasData:bool;
   pub let symbolInfo: &SymbolInfo;
}

pub class Scope {
   // このスコープのオーナーの TypeInfo。
   // 名前空間に関連する class, function の TypeInfo。
   pri let mut ownerTypeInfo: &TypeInfo! { pub, pub };
   // 親のスコープ。 これが self と等しい場合は root。
   pri let mut parent: Scope { pub };
   // このスコープに登録されているシンボル情報。
   // シンボル名 → SymbolInfo のマップ。
   pri let mut symbol2SymbolInfoMap: Map<str,&SymbolInfo> { pub };
   // このスコープがクラスのスコープかどうか。
   pri let classFlag: bool;
   // 継承しているスコープ。
   pri let inherit: &Scope!;
   // 継承しているスコープ。
   pri let ifScopeList: List<&Scope>;
   /** 所有権情報 */
   pri let mut symbolId2DataOwnerInfo: Map<int,DataOwnerInfo>;
      
      
   pub fn __init( parent: Scope!, classFlag: bool,
                  inherit: &Scope!, ifScopeList:List<&Scope>! )
   {  
      self.parent = unwrap parent default self;
      self.symbol2SymbolInfoMap = {};
      self.inherit = inherit;
      self.classFlag = classFlag;
      self.symbolId2DataOwnerInfo = {};
      self.ifScopeList = unwrap ifScopeList default [];
   }

   pub fn isRoot(): bool {
      return self.parent == self;
   }

   pub fn set_ownerTypeInfo( owner: &TypeInfo! ) mut {
      self.ownerTypeInfo = owner;
   }
   
   pub fn getTypeInfoChild( name: str ) : &TypeInfo! {
      if! self.symbol2SymbolInfoMap[ name ] {
         return _exp.$typeInfo;
      } 
      return nil;
   }

   pub fn getSymbolInfoChild( name: str ) : &SymbolInfo! {
      return self.symbol2SymbolInfoMap[ name ];
   }
   
   pub fn setData( symbolInfo:&SymbolInfo ) mut {
      self.symbolId2DataOwnerInfo[ symbolInfo.$symbolId ] =
      new DataOwnerInfo( true, symbolInfo );
   }

   pub fn remove( name: str ) mut {
      self.symbol2SymbolInfoMap[ name ] = nil;
   }

   pub fn addSymbol( symbolInfo: SymbolInfo ) mut {
      self.symbol2SymbolInfoMap[ symbolInfo.$name ] = symbolInfo;
   }
   
   pub fn getNSTypeInfo(): TypeInfo;
}

// 最上位のスコープ
pub let mut rootScope = new Scope( nil, false, nil## );

/**
このスコープが scope の同じか内部のスコープか調べる。

@return bool: 同じか内部のスコープの場合 true。
*/
pub fn Scope.isInnerOf( scope:&Scope ): bool {
   let mut workScope = self;
   while workScope ~= rootScope {
      if workScope == scope {
         return true;
      }
      workScope = workScope.parent;
   }
   return false;
}



let dummyList:List<&TypeInfo> = [];
let mut rootChildren:List<&TypeInfo> = [];

/**
TypeInfo の付随した情報で、かつ mutable な情報。

ある TypeInfo の子は、親宣言時には確定しない。
子を宣言時に親の子リストに追加が必要だが、
TypeInfo は基本的に &TypeInfo で扱うため TypeInfo のメンバに直接子リストを持たせられない。
*/
pub class TypeData {
   pri let mut children:List<&TypeInfo> {pub};
   pub fn addChildren( child:&TypeInfo ) mut {
      self.children.insert( child );
   }
}

/** TypeInfo と TypeData の紐付け管理 */
class TypeManager {
   pri static let mut info2Data:Map<&TypeInfo,TypeData>;

   __init {
      TypeManager.info2Data = {};
   }
   pub static fn add( typeInfo:&TypeInfo ) {
      TypeManager.info2Data[ typeInfo ] = new TypeData( [] );
   }
   pub static fn getData( typeInfo:&TypeInfo ) : TypeData! {
      return TypeManager.info2Data[ typeInfo ];
   }
}


let mut typeInfo2ScopeMap:Map<&TypeInfo,Scope> = {};

pub fn getScope( typeInfo:&TypeInfo ): Scope! {
   return typeInfo2ScopeMap[ typeInfo ];
}

pub interface ModuleInfoIF {
   pub fn get_assignName():str;
   pub fn get_modulePath():str;
}

pub class TypeInfo {

   // この TypeInfo のスコープ。
   // class, func など名前空間を持つ TypeInfo は有効。
   //pri let scope: &Scope!;

   pub fn get_scope(): Scope! {
      return typeInfo2ScopeMap[ self ];
   }

   pub fn __init( scope: Scope! ) {
      typeInfo2ScopeMap[ self ] = scope;
      //self.scope = scope;
      if! scope {
         _exp.set_ownerTypeInfo( self );
      }
      TypeManager.add( self );
   }

   /** この型がモジュールを示す型の場合 true  */
   pub fn isModule(): bool {
      return true;
   }

   /** 親の typeId  */
   pub fn getParentId(): int {
      return rootTypeId;
   }

   /** スーパークラスの typeId */
   pub fn get_baseId(): int {
      return rootTypeId;
   }

   /** この型が other を継承しているかどうか */
   pub fn isInheritFrom( other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool {
      return false;
   }

   /** シンプルな型名 */
   pub fn get_rawTxt(): str {
      return "";
   }
   
   /** この型の名前を取得する。 */
   pro fn getTxtWithRaw(
      raw:str, fullName:bool!,
      importInfo:&Map<&TypeInfo, &ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      return "";
   }

   /** この型の名前を取得する。 */
   pub fn getTxt(
      fullName:bool!, importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, fullName, importInfo, localFlag );
   }
  
   /** other 型から dest 型への opTxt の評価が可能かどうか */
   pro static fn canEvalWithBase(
      dest:&TypeInfo, destMut: bool, other:&TypeInfo,
      opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool;

   /** other 型からこの型への opTxt の評価が可能かどうか */
   pub fn canEvalWith( other:&TypeInfo, opTxt:str,
                       alt2type:Map<&TypeInfo,&TypeInfo> ): bool
   {  
      return false;
   }

   /** この型が abstract かどうか */
   pub fn get_abstractFlag(): bool {
      return false;
   }

   /** この型情報を oStream にシリアライズする */
   pub fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      return;
   }


   /** 表示用文字列取得 */
   pub fn get_display_stirng_with( raw:str ): str {
      return "";
   }

   /** 表示用文字列取得 */
   pub fn get_display_stirng(): str {
      return self.get_display_stirng_with( "" );
   }


   /** Modifier の元となる型情報 */
   pub fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }

   /** この型と typeInfo が等しいかどうか */
   pub fn equals( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ): bool {
      return self == typeInfo;
   }

   /** この型が外部モジュールで定義した型かどうか */
   pub fn get_externalFlag(): bool {
      return false;
   }

   /** この型が実装しているインタフェースリスト */
   pub fn get_interfaceList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** generics の型リスト */
   pub fn get_itemTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** 引数の型リスト */
   pub fn get_argTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** 戻り値の型リスト */
   pub fn get_retTypeInfoList(): &List<&TypeInfo> {
      return dummyList;
   }
   /** 名前空間の親 */
   pub fn get_parentInfo(): &TypeInfo {
      return self;
   }

   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報が宣言されているか？
   */
   pub fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      while true {
         if other == self {
            return true;
         }
         if other.$parentInfo == other {
            break;
         }
         other = other.$parentInfo;
      }
      return false;
   }
   /** この型が属しているモジュールを取得 */
   pub fn getModule(): &TypeInfo {
      if self.isModule() {
         return self;
      }
      return self.$parentInfo.getModule();
   }
   /** typeId を取得 */
   pub fn get_typeId(): int {
      return rootTypeId;
   }
   /** 型の種別 */
   pub fn get_kind(): TypeInfoKind {
      return .Root;
   }
   /**
static な型か。

メソッドでない関数は全て static となる。
   */ 
   pub fn get_staticFlag(): bool {
      return false;
   }
   /** アクセスモード */
   pub fn get_accessMode(): AccessMode {
      return AccessMode.Pri;
   }
   /** ユーザ定義でなく自動的に生成したかどうか */
   pub fn get_autoFlag(): bool {
      return false;
   }
   /** 非 nilable の型情報 */
   pub fn get_nonnilableType(): &TypeInfo {
      return self;
   }
   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub fn get_baseTypeInfo(): &TypeInfo {
      return self;
   }
   /** nilable かどうか */
   pub fn get_nilable(): bool {
      return false;
   }
   /** nilable な型情報 */
   pub fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   /** TypeData の取得 */
   pub fn get_typeData(): TypeData {
      return unwrap TypeManager.getData( self ); 
   }
   /** 子リスト取得 */
   pub fn get_children() : &List<&TypeInfo> {
      return self.$typeData.$children;
   }
   /** 子の追加 */
   pub fn addChildren( child:TypeInfo ) {
      (unwrap TypeManager.getData( self )).addChildren( child );
   }
   /** mutable かどうか */
   pub fn get_mutable(): bool {
      return true;
   }

   /** 親の完全限定名を取得する */
   pub fn getParentFullName(
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      let mut typeInfo:&TypeInfo = self;
      let mut name = "";
      let! mut infoMap = importInfo {
         infoMap = {};
      };
      while not infoMap[ typeInfo ] {
         typeInfo = typeInfo.$parentInfo;
         if typeInfo == typeInfo.$parentInfo {
            break;
         }
         let mut txt = typeInfo.$rawTxt;
         if localFlag {
            if! let moduleInfo = infoMap[ typeInfo ] {
               txt = moduleInfo.$assignName;
            }  
            else {
               if typeInfo.isModule() {
                  break;
               }
            }
         }
         name = txt .. "." .. name;
      }
      return name;
   }

   pub fn applyGeneric( alt2typeMap:&Map<&TypeInfo,&TypeInfo> ): &TypeInfo! {
      return self;
   }

   pub fn get_genSrcTypeInfo(): &TypeInfo {
      return self;
   }
}

pub fn isGenericType( typeInfo: &TypeInfo ) : bool {
   return typeInfo ~= typeInfo.$genSrcTypeInfo;
}


pub class AliasTypeInfo extend TypeInfo {
   pri let rawTxt: str { pub };
   pri let accessMode: AccessMode { pub };
   pri let parentInfo: &TypeInfo { pub };
   pri let aliasSrcTypeInfo: &TypeInfo { pub };
   pri let externalFlag:bool { pub };
   pri let typeId: int { pub };

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      fullName:bool!, importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.rawTxt, fullName, importInfo, localFlag );
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, rawTxt = %q, srcTypeId = %d }\n' (
            SerializeKind.Alias, parentId, self.typeId, self.rawTxt,
            self.aliasSrcTypeInfo.$typeId ) );
   }

   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.rawTxt );
   }

   /** 親の typeId  */
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   pub override fn applyGeneric( alt2typeMap:&Map<&TypeInfo,&TypeInfo> ): &TypeInfo! {
      let typeInfo = self.aliasSrcTypeInfo.applyGeneric( alt2typeMap );
      if typeInfo == self.aliasSrcTypeInfo {
         return self;
      }
      return nil;
   }

   advertise aliasSrcTypeInfo;
}


/**
列挙したシンボル情報を処理するコールバック。

@return 列挙を続ける場合は true 
*/
pub form filterForm( symbolInfo:&SymbolInfo ): bool;

/**
このスコープからアクセス可能なフィールドを列挙し callback を実行する。

@param includeSelfFlag true の場合、
自分自身のスコープに登録されているシンボルを列挙対象にする。
@param fromScope アクセスを開始しているスコープ。
@param callback コールバック。
@return bool 列挙を続ける場合 true
*/
pub fn Scope.filterTypeInfoField(
   includeSelfFlag: bool!, fromScope:&Scope, callback:filterForm ):bool
{
   if self.classFlag {
      if includeSelfFlag {
         foreach symbolInfo in self.symbol2SymbolInfoMap {
            if symbolInfo.canAccess( fromScope ) {
               if not callback( symbolInfo ) {
                  return false;
               }        
            }  
         }  
      }
      if! let scope = self.inherit {
         if not scope.filterTypeInfoField( true, fromScope, callback ) {
            return false;
         }
      } 
   }

   return true;
}

/**
このスコープからアクセス可能な name のフィールドを取得する。

インタフェースは含めない。
*/
pub fn Scope.getSymbolInfoField(
   name: str, includeSelfFlag: bool!, fromScope:&Scope ) : &SymbolInfo!
{
   if self.classFlag {
      if includeSelfFlag {
         if! self.symbol2SymbolInfoMap$[ name ] {
            let! symbolInfo = _exp.canAccess( fromScope ) {
               return nil;
            };
            return symbolInfo;
         }  
      } 
      if! let scope = self.inherit {
         let symbolInfo = scope.getSymbolInfoField( name, true, fromScope );
         if symbolInfo {
            return symbolInfo;
         }   
      } 
   }

   return nil;
}

/**
このスコープからアクセス可能な name のフィールドを取得する。

インタフェースを含む。
*/
pub fn Scope.getSymbolInfoIfField( name: str, fromScope:&Scope ) : &SymbolInfo!
{
   if self.classFlag {
      foreach scope in self.ifScopeList {
         if! let symbolInfo = scope.getSymbolInfoField( name, true, fromScope ) {
            return symbolInfo;
         }
      } 
   }

   if! let scope = self.inherit {
      if! let symbolInfo = scope.getSymbolInfoIfField( name, fromScope ) {
         return symbolInfo;
      }
   } 

   return nil;
}

/**
このスコープからアクセス可能なフィールドを列挙し callback を実行する。

インタフェースを含む。
*/
pub fn Scope.filterSymbolInfoIfField( fromScope:&Scope, callback:filterForm ) : bool
{
   foreach scope in self.ifScopeList {
      if not scope.filterTypeInfoField( true, fromScope, callback ) {
         return false;
      }
   }

   if! let scope = self.inherit {
      if not scope.filterSymbolInfoIfField( fromScope, callback ) {
         return false;
      }
   } 
   
   return true;
}



pub fn Scope.getTypeInfoField(
   name: str, includeSelfFlag: bool!, fromScope:&Scope ) : TypeInfo!
{
   let symbolInfo = self.getSymbolInfoField( name, includeSelfFlag, fromScope );
   if! symbolInfo {
      return _exp.$typeInfo;
   }
   return nil;
}


/**
このスコープからシンボル name の型情報を取得する。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
@param onlySameNsFlag true の場合、検索対象を同一名前空間内に限定する。
*/
pub fn Scope.getSymbolInfo(
   name: str, fromScope:&Scope, onlySameNsFlag:bool ) : &SymbolInfo!
{
   if! self.symbol2SymbolInfoMap[ name ] {
      let! symbolInfo = _exp.canAccess( fromScope ) {
         return nil;
      };
      return symbolInfo;
   }
   if not onlySameNsFlag {
      if! let scope = self.inherit {
         let symbolInfo = scope.getSymbolInfoField( name, true, fromScope );
         if symbolInfo {
            return symbolInfo;
         }   
      } 
   }
   if not onlySameNsFlag or not self.ownerTypeInfo {
      if self.parent ~= self {
         return self.parent.getSymbolInfo( name, fromScope, onlySameNsFlag );
      } 
   }
   if onlySameNsFlag {
      return nil;
   }
   if! sym2builtInTypeMap[ name ] {
      return _exp;
   }
   return nil;
}

pub fn Scope.getTypeInfo(
   name: str, fromScope:&Scope, onlySameNsFlag:bool ) : TypeInfo!
{
   let! symbolInfo = self.getSymbolInfo(name, fromScope, onlySameNsFlag ) {
      return nil;
   };
   return symbolInfo.$typeInfo;
}


/**
このスコープからシンボル name の型情報を取得する。
フィールドを除く name。

@param name シンボル名
@param fromScope シンボルを参照する位置のスコープ
*/
pub fn Scope.getSymbolTypeInfo(
   name: str, fromScope:&Scope, moduleScope:&Scope ) : &SymbolInfo!
{
   let mut typeInfo:TypeInfo! = nil;
   let mut validThisScope = false;
   let mut limitSymbol = false;

   if! self.ownerTypeInfo {
      if _exp.$kind == .Func or _exp.$kind == .Method or
         self == moduleScope or self == rootScope
      { 
         validThisScope = true;
      } 
      elseif _exp.$kind == .IF or _exp.$kind == .Class or _exp.$kind == .Module 
      {
         // class 系の場合、アクセスできるシンボルは self と Alternate に限定する
         limitSymbol = true;
         validThisScope = true;
      }
      elseif _exp.$kind == .Enum or _exp.$kind == .Alge {
         validThisScope = true;
      }
   } 
   else {
      validThisScope = true;
   }
   if validThisScope {
      if! let symbolInfo = self.symbol2SymbolInfoMap[ name ] {
         if not limitSymbol or name == "self" or
            ( symbolInfo.$typeInfo.$kind == .Alternate and
              symbolInfo.$kind == .Typ )
         {
            return symbolInfo.canAccess( fromScope );
         }
      }
   }
   if self.parent ~= self {
      return self.parent.getSymbolTypeInfo( name, fromScope, moduleScope );
   }
   return sym2builtInTypeMap[ name ];
}


pub fn Scope.filterSymbolTypeInfo(
   fromScope:&Scope, moduleScope:&Scope, callback:filterForm )
{
   if self.classFlag {
      if! self.symbol2SymbolInfoMap[ "self" ] {
         callback( _exp );
      }
   }
   if moduleScope == fromScope or not self.classFlag {
      foreach symbolInfo in self.symbol2SymbolInfoMap {
         if not callback( symbolInfo ) {
            return;
         }  
      }
   }

   if self.parent ~= self {
      self.parent.filterSymbolTypeInfo( fromScope, moduleScope, callback );
   }
}


pub fn Scope.add( kind: SymbolKind, canBeLeft:bool, canBeRight:bool,
                  name:str, typeInfo: &TypeInfo, accessMode:AccessMode,
                  staticFlag:bool, mutable:bool, hasValueFlag:bool ) mut : &SymbolInfo
{
   let mut symbolInfo = new NormalSymbolInfo(
      kind, canBeLeft, canBeRight,
      self, accessMode, staticFlag, name, typeInfo, mutable, hasValueFlag );
   self.symbol2SymbolInfoMap[ name ] = symbolInfo;
   return symbolInfo;
}

pub fn Scope.addLocalVar(
   argFlag:bool, canBeLeft:bool, name:str, typeInfo: &TypeInfo, mutable:bool ) mut
{
   self.add( argFlag and SymbolKind.Arg or SymbolKind.Var,
             canBeLeft, true, name, typeInfo,
             .Local, false, mutable, true );
}

pub fn Scope.addStaticVar(
   argFlag:bool, canBeLeft:bool, name:str, typeInfo: &TypeInfo, mutable:bool ) mut
{
   self.add( argFlag and SymbolKind.Arg or SymbolKind.Var,
             canBeLeft, true, name, typeInfo,
             .Local, true, mutable, true );
}

pub fn Scope.addVar(
   accessMode:AccessMode, name:str,
   typeInfo: &TypeInfo, mutable:bool, hasValueFlag:bool ) mut
{
   self.add( SymbolKind.Var, true, true, name, typeInfo,
             accessMode, false, mutable, hasValueFlag );
}


pub fn Scope.addEnumVal( name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Mbr, false, true,
             name, typeInfo, .Pub, true, true, true );
}

pub fn Scope.addEnum( accessMode:AccessMode, name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Typ, false, false,
             name, typeInfo, accessMode, true, true, true );
}

pub fn Scope.addAlgeVal( name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Mbr, false, true,
             name, typeInfo, .Pub, true, true, true );
}

pub fn Scope.addAlge( accessMode:AccessMode, name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Typ, false, false,
             name, typeInfo, accessMode, true, true, true );
}

pub fn Scope.addAlternate( accessMode:AccessMode, name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Typ, false, false,
             name, typeInfo, accessMode, true, true, true );
}

pub fn Scope.addMember( name:str, typeInfo: &TypeInfo, accessMode:AccessMode,
                        staticFlag:bool, mutable:bool ) mut : &SymbolInfo
{
   return self.add( SymbolKind.Mbr, true, true,
                    name, typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addMethod(
   typeInfo: &TypeInfo, accessMode:AccessMode, staticFlag:bool, mutable:bool ) mut
{
   self.add( SymbolKind.Mtd, true, true, typeInfo.$rawTxt,
             typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addFunc(
   typeInfo: &TypeInfo, accessMode:AccessMode, staticFlag:bool, mutable:bool ) mut
{
   self.add( SymbolKind.Fun, true, true, typeInfo.$rawTxt,
             typeInfo, accessMode, staticFlag, mutable, true );
}

pub fn Scope.addMacro(
   typeInfo: &TypeInfo, accessMode:AccessMode ) mut
{
   self.add( SymbolKind.Mac, false, false, typeInfo.$rawTxt,
             typeInfo, accessMode, true, false, true );
}


pub fn Scope.addClass( name:str, typeInfo: &TypeInfo ) mut
{
   self.add( SymbolKind.Typ, false, false, name, typeInfo,
             typeInfo.$accessMode, true, true, true );
}

/**
デバッグ用。 scope 内のシンボル情報を出力する。
*/
fn dumpScopeSub( scope: Scope!, prefix:str, readyIdSet:Set<Scope> ) {
   if! scope {
      if readyIdSet.has( _exp ) {
         return;
      } 
      readyIdSet.add( _exp );
      if #prefix > 20 {
         Util.err("illegal");
      }   
      
      forsort symbolInfo, symbol in _exp.$symbol2SymbolInfoMap {
         Util.log( "scope: %s, %s, %s" ( prefix, _exp, symbol ) );
         if! let subScope = symbolInfo.$typeInfo.$scope {
            dumpScopeSub( subScope, prefix .. "  ", readyIdSet );
         }
      } 
   };
}

/**
デバッグ用。 scope 内のシンボル情報を出力する。
*/
fn dumpScope( scope: Scope!, prefix:str ) {
   dumpScopeSub( scope, prefix, (@) );
}



pub let headTypeInfo:TypeInfo = new TypeInfo( rootScope );
//let rootTypeInfo:TypeInfo = new TypeInfo( rootScope );

/**

*/
pub fn TypeInfo.createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
   if not detectFlag {
      return {};
   }
   return { headTypeInfo: headTypeInfo };
}


pub class NilTypeInfo extend TypeInfo {
   pri let typeId:int {pub};

   pub fn __init() {
      super( nil );

      idProv.increment();
      self.typeId = idProv.$id;
   }
   
   /** この型がモジュールを示す型の場合 true  */
   pub override fn isModule(): bool {
      return false;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt( fullName:bool!,
                  importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, fullName, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, fullName:bool!,
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      return "nil";
   }
   

   /** other 型からこの型への opTxt の評価が可能かどうか */
   pub override fn canEvalWith(
      other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool
   {  
      return other.$nilable;
   }

   /** 表示用文字列取得 */
   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( "nil" );
   }
   

   /** この型と typeInfo が等しいかどうか */
   pub override fn equals( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ): bool {
      return self == typeInfo;
   }

   /** 名前空間の親 */
   pub override fn get_parentInfo(): &TypeInfo {
      return headTypeInfo;
   }

   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報が宣言されているか？
   */
   pub override fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      return true;
   }
   
   /** シンプルな型名 */
   pub override fn get_rawTxt(): str {
      return "nil";
   }
   /** 型の種別 */
   pub override fn get_kind(): TypeInfoKind {
      return .Prim;
   }
   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }
   /** nilable かどうか */
   pub override fn get_nilable(): bool {
      return true;
   }
   /** mutable かどうか */
   pub override fn get_mutable(): bool {
      return false;
   }

   /** 親の完全限定名を取得する */
   pub override fn getParentFullName(
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return "nil";
   }
}


pub fn Scope.getNSTypeInfo(): &TypeInfo {
   let mut scope = self;
   while true {
      if! let owner = scope.ownerTypeInfo {
         if owner.$kind == .Root {
            return owner;
         }
      }
      if scope.parent == scope {
         break;
      }
      scope = scope.parent;
   }
   return headTypeInfo;
}

pub fn Scope.getClassTypeInfo(): &TypeInfo {
   let mut scope = self;
   while true {
      if! let owner = scope.ownerTypeInfo {
         switch owner.$kind {
            case .Class, .IF, .Module {
               return owner;
            }
         }
      }
      if scope.parent == scope {
         break;
      }
      scope = scope.parent;
   }
   return headTypeInfo;
}


/**
このシンボルが、fromScope のスコープからアクセスできるか調べる。
 */
pub override fn NormalSymbolInfo.canAccess( fromScope:&Scope ): &SymbolInfo!
{
   let typeInfo = self.$typeInfo;
   if self.scope == fromScope {
      return self;
   }
   switch self.$accessMode {
      case .Pub, .Global {
         return self;
      }           
      case .Pro {
         let nsClass = self.scope.getClassTypeInfo();
         let fromClass = fromScope.getClassTypeInfo();
         if fromClass.isInheritFrom( nsClass, nil ) {
            return self;
         }  
         return nil;
      } 
      case .Local {
         return self;
      } 
      case .Pri {
         // let nsClass = self.scope.getClassTypeInfo();
         // let fromClass = fromScope.getClassTypeInfo();
         // if nsClass == fromClass {
         //    return self;
         // }  
         // return nil;
         if fromScope.isInnerOf( self.scope ) {
            return self;
         }
         return nil;
      } 
   }
   Util.err( "illegl accessmode -- %s, %s"
             (self.$accessMode, self.$name) );
}


pub class AccessSymbolInfo extend SymbolInfo {
   pri let symbolInfo: SymbolInfo {pub};
   pri let prefixTypeInfo: TypeInfo! {pub};
   pri let overrideCanBeLeft: bool;

   pub override fn getOrg(): &SymbolInfo {
      return self.symbolInfo.getOrg();
   }

   pub override fn get_mutable(): bool {
      if! self.prefixTypeInfo {
         return _exp.$mutable and self.symbolInfo.$mutable;
      }
      return self.symbolInfo.$mutable;
   };

   pub override fn get_canBeLeft(): bool {
      if not self.overrideCanBeLeft {
         return false;
      }
      if! self.prefixTypeInfo {
         if not _exp.$mutable {
            return false;
         }
      }
      return self.symbolInfo.$canBeLeft;
   }

   advertise symbolInfo;
}


pub proto class Node;
pub proto class DeclClassNode extend Node;

pub class NilableTypeInfo extend TypeInfo {
   pri let nonnilableType: &TypeInfo { pub };
   pri let typeId: int { pub };

   pub override fn get_kind(): TypeInfoKind {
      return .Nilable;
   }
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_nilable(): bool {
      return true;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      fullName:bool!, importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, fullName, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, fullName:bool!,
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      return self.nonnilableType.getTxtWithRaw(
         raw, fullName, importInfo, localFlag ) .. "!";
   }


   pub override fn get_display_stirng_with( raw:str ): str {
      return self.nonnilableType.get_display_stirng_with( raw ) .. "!";
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, nilable = true, orgTypeId = %d }\n' (
            SerializeKind.Nilable, parentId, self.typeId, self.nonnilableType.$typeId ) );
   }

   pub override fn equals( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ): bool {
      if not typeInfo.$nilable {
         return false;
      }
      return self.nonnilableType.equals( typeInfo.$nonnilableType, alt2type );
   }

   pub override fn applyGeneric( alt2typeMap:&Map<&TypeInfo,&TypeInfo> ): &TypeInfo! {
      let typeInfo = self.nonnilableType.applyGeneric( alt2typeMap );
      if typeInfo == self.nonnilableType {
         return self;
      }
      when! typeInfo {
         return typeInfo.$nilableTypeInfo;
      }
      return nil;
   }

   advertise nonnilableType;
}

/**
Generic クラスや関数で利用する代用型。

Set<T> の T を表わす型情報。
*/
pub class AlternateTypeInfo extend TypeInfo {
   pri let typeId:int {pub};
   pri let txt:str {pub};
   pri let moduleTypeInfo:&TypeInfo;
   pri let nilableTypeInfo: NilableTypeInfo {pub};
   pri let accessMode: AccessMode {pub};
   
   pub fn __init( txt:str, accessMode:AccessMode, moduleTypeInfo:&TypeInfo ) {
      super( nil );

      idProv.increment();
      self.typeId = idProv.$id;

      self.txt = txt;
      self.accessMode = accessMode;
      self.moduleTypeInfo = moduleTypeInfo;

      idProv.increment();      
      self.nilableTypeInfo = new NilableTypeInfo( self, idProv.$id );
   }

   pub static fn createDefaultAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      if detectFlag {
         return { headTypeInfo: headTypeInfo };
      }
      return {};
   }
   
   pub static fn isValidApply( alt2type:Map<&TypeInfo,&TypeInfo> ) : bool {
      return alt2type[ headTypeInfo ] ~= nil;
   }

   /** この型がモジュールを示す型の場合 true  */
   pub override fn isModule(): bool {
      return false;
   }

   /** 親の typeId  */
   pub override fn getParentId(): int {
      return self.moduleTypeInfo.$typeId;
   }

   pub override fn get_parentInfo(): &TypeInfo {
      return self.moduleTypeInfo;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt( fullName:bool!,
                  importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, fullName, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, fullName:bool!,
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      return self.txt;
   }

   pub static fn getAssign(
      typeInfo:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo> ) : &TypeInfo
   {
      if typeInfo.$kind ~= .Alternate {
         return typeInfo;
      }
      let mut otherWork = typeInfo;
      while true {
         if! alt2type[ otherWork ] {
            otherWork = _exp;
         }
         else {
            return otherWork;
         }
      }
   }
   
   /** other 型からこの型への opTxt の評価が可能かどうか */
   pub override fn canEvalWith(
      other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool
   {
      if self == other.$srcTypeInfo {
         return true;
      }
      if other.$nilable {
         return false;
      }
      //let mut otherWork = unwrap other.applyGeneric( alt2type ) default other;
      let otherWork = AlternateTypeInfo.getAssign( other, alt2type );
      if! let genType = alt2type[ self ] {
         return genType.canEvalWith( otherWork, opTxt, alt2type );
      }
      if not AlternateTypeInfo.isValidApply( alt2type ) {
         return false;
      }
      alt2type[ self ] = otherWork;
      return true;
   }

   /** 表示用文字列取得 */
   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.txt );
   }
   

   /** この型と typeInfo が等しいかどうか */
   pub override fn equals(
      typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ): bool
   {  
      if self == typeInfo {
         return true;
      }
      when! alt2type {
         let mut otherWork = AlternateTypeInfo.getAssign( typeInfo, alt2type );
         if! let genType = alt2type[ self ] {
            return genType.equals( otherWork, alt2type );
         }  
         if not AlternateTypeInfo.isValidApply( alt2type ) {
            return false;
         }
         alt2type[ self ] = otherWork;
         return true;
      }
      return false;
   }

   /**
   この型情報に、 other から辿ることができるか？
   具体的には other の名前空間の上位に、この型情報が宣言されているか？
   */
   pub override fn hasRouteNamespaceFrom( mut other: &TypeInfo ): bool {
      return true;
   }
   
   /** シンプルな型名 */
   pub override fn get_rawTxt(): str {
      return self.txt;
   }
   /** 型の種別 */
   pub override fn get_kind(): TypeInfoKind {
      return .Alternate;
   }
   /** super クラス。 継承していない場合は headTypeInfo。 */
   pub override fn get_baseTypeInfo(): &TypeInfo {
      return headTypeInfo;
   }
   /** nilable かどうか */
   pub override fn get_nilable(): bool {
      return false;
   }
   /** mutable かどうか */
   pub override fn get_mutable(): bool {
      return false;
   }

   /** 親の完全限定名を取得する */
   pub override fn getParentFullName(
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return "";
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, txt = %q, accessMode = %d }\n' (
            SerializeKind.Alternate, parentId, self.typeId, self.txt, self.accessMode ) );
   }

   pub override fn applyGeneric( alt2typeMap:&Map<&TypeInfo,&TypeInfo> ): &TypeInfo! {
      return alt2typeMap[ self ];
   }
}


/**
Generic クラスの型確定後の型情報。

Set<T> の Set<int> を表わす型情報。
*/
pub class GenericTypeInfo extend TypeInfo {
   pri let typeId:int {pub};
   pri let itemTypeInfoList:&List<&TypeInfo> {pub};
   pri let nilableTypeInfo: NilableTypeInfo {pub};
   pri let genSrcTypeInfo:&TypeInfo {pub};
   pri let moduleTypeInfo:&TypeInfo;
   pri let alt2typeMap:&Map<&TypeInfo,&TypeInfo>;
   pri let hasAlter:bool;

   pub fn __init( genSrcTypeInfo:&TypeInfo,
                  itemTypeInfoList:&List<&TypeInfo>, moduleTypeInfo:&TypeInfo )
   {  
      super( nil );

      idProv.increment();
      self.typeId = idProv.$id;
      self.moduleTypeInfo = moduleTypeInfo;

      self.itemTypeInfoList = itemTypeInfoList;
      self.genSrcTypeInfo = genSrcTypeInfo;

      if #genSrcTypeInfo.$itemTypeInfoList ~= #itemTypeInfoList {
         Util.err( "unmatch generic type number -- %d, %d"
                   (#genSrcTypeInfo.$itemTypeInfoList, #itemTypeInfoList) );
      }
      let mut alt2typeMap:Map<&TypeInfo,&TypeInfo> = {};
      let mut workAlt2typeMap = AlternateTypeInfo.createDefaultAlt2typeMap( false );
      let mut hasAlter = false;
      foreach altTypeInfo, index in genSrcTypeInfo.$itemTypeInfoList {
         let itemType = itemTypeInfoList[ index ];
         alt2typeMap[ altTypeInfo ] = itemType;
         if itemType.applyGeneric( workAlt2typeMap ) ~= itemType {
            hasAlter = true;
         }
      }
      self.hasAlter = hasAlter;
      self.alt2typeMap = alt2typeMap;
      
      idProv.increment();      
      self.nilableTypeInfo = new NilableTypeInfo( self, idProv.$id );
   }

   pub override fn getModule(): &TypeInfo {
      return self.moduleTypeInfo;
   }

   /** この型が other を継承しているかどうか */
   pub override fn isInheritFrom(
      other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool
   {
      let otherSrc = other.$genSrcTypeInfo;
      
      if not self.genSrcTypeInfo.isInheritFrom( otherSrc, alt2type ) {
         // Generic 元が継承していない場合は、この Generic クラスも継承していない
         return false;
      }
      // Generic 元が継承している
      if otherSrc == other {
         // otherSrc == other なら、 other は Generic でないので、この時点で確定
         when! alt2type {
            if self.genSrcTypeInfo == other {
               return true;
            }
         }
         return false;
      }
      // other は Generic
      let genOther = other@@GenericTypeInfo;
      let! mut workAlt2type = alt2type {
         workAlt2type = AlternateTypeInfo.createDefaultAlt2typeMap( false );
      };
      foreach altType in otherSrc.$itemTypeInfoList {
         // otherSrc の altType に対応する Generic の型を取得し、
         // それの派生状態を確認。
         let! genType = self.alt2typeMap[ altType ] {
            return false;
         };
         let otherGenType = unwrap genOther.alt2typeMap[ altType ];
         // if not genType.isInheritFrom( otherGenType, alt2type ) {
         //    return false;
         // }
         if not otherGenType.canEvalWith( genType, "=", workAlt2type ) {
            return false;
         }
      }
      return true;
   }
   
   /** Modifier の元となる型情報 */
   pub override fn get_srcTypeInfo(): &TypeInfo {
      return self;
   }
   
   /** other 型からこの型への opTxt の評価が可能かどうか */
   pub override fn canEvalWith(
      other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool
   {
      if self.$mutable and not other.$mutable {
         return false;
      }

      let otherSrc = other.$srcTypeInfo;
      if self == otherSrc {
         return true;
      }

      // other のスーパークラスを辿って、一致するか調べる
      let mut work = otherSrc;
      while true {
         if work == headTypeInfo {
            return false;
         }
         foreach genType, altType in work.createAlt2typeMap( false ) {
            alt2type[ altType ] = genType;
         }  
         if self.genSrcTypeInfo.equals( work.$genSrcTypeInfo, alt2type ) {
            break;
         }
         foreach ifType in work.$interfaceList {
            if self.canEvalWith( ifType, opTxt, alt2type ) {
               return true;
            }
         }
         work = work.$baseTypeInfo;
      }

      // 一致する場合、汎化の型も同じか調べる
      let otherGen = work@@GenericTypeInfo;
      foreach val, key in self.alt2typeMap {
         let otherType = AlternateTypeInfo.getAssign(
            unwrap otherGen.alt2typeMap[ key ], alt2type );
         if not val.canEvalWith( otherType, opTxt, alt2type ) {
            return false;
         }
      }
      return true;
   }

   /** この型と typeInfo が等しいかどうか */
   pub override fn equals( other: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ): bool {
      if self == other {
         return true;
      }
      if self.$kind ~= self.$kind or
         #self.itemTypeInfoList ~= #other.$itemTypeInfoList
      {
         return false;
      }
      if not isGenericType( other ) {
         return false;
      }
      
      if not self.genSrcTypeInfo.equals( other.$genSrcTypeInfo, alt2type ) {
         return false;
      }
      
      foreach otherItem, index in other.$itemTypeInfoList {
         let typeInfo = self.itemTypeInfoList[ index ];
         if not typeInfo.equals( otherItem, alt2type ) {
            return false;
         }
      }
      return true;
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, genSrcTypeId = %d, genTypeList = {' (
            SerializeKind.Generic, parentId, self.typeId, self.genSrcTypeInfo.$typeId ) );
      let count = 0;
      foreach genType in self.alt2typeMap {
         if count > 0 {
            stream.write( "," );
         }
         stream.write( "%d" (genType.$typeId) );
      }
      stream.write( '} }\n' );
   }

   pub override fn createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      let mut map:Map<&TypeInfo,&TypeInfo> = {};
      foreach typeInfo, genType in self.alt2typeMap {
         map[ genType ] = typeInfo;
      }
      return map;
   }

   pub override fn applyGeneric( alt2typeMap:&Map<&TypeInfo,&TypeInfo> ): &TypeInfo! {
      if not self.hasAlter {
         return self;         
      }
      let genSrcTypeInfo = self.genSrcTypeInfo.applyGeneric( alt2typeMap );
      if genSrcTypeInfo == self.genSrcTypeInfo {
         return self;
      }
      Util.errorLog( "no support nest generic -- %s" (self.getTxt(##) ) );
      return nil;
   }

   advertise genSrcTypeInfo;
}




pub class ModifierTypeInfo extend TypeInfo {
   pri let srcTypeInfo: &TypeInfo { pub };
   pri let typeId: int { pub };
   pri let mutable: bool { pub };

   /** この型の名前を取得する。 */
   pub override fn getTxt(
      fullName:bool!, importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, fullName, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str,  fullName:bool!,
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      let mut txt = self.srcTypeInfo.getTxtWithRaw(
         raw, fullName, importInfo, localFlag );
      if not self.mutable {
         txt = "&" .. txt;
      }
      return txt;
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      let mut txt = self.srcTypeInfo.get_display_stirng_with( raw );
      if self.mutable {
         txt = "mut " .. txt;
      }
      return txt;
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      let parentId = self.getParentId();
      stream.write(
         '{ skind = %d, parentId = %d, typeId = %d, srcTypeId = %d, mutable = %s }\n' (
            SerializeKind.Modifier, parentId, self.typeId, self.srcTypeInfo.$typeId,
            self.mutable and true or false ) );
   }

   pub override fn canEvalWith(
      other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool {
         // if isGenericType( self.srcTypeInfo ) {
         //    return self.srcTypeInfo.canEvalWith( other, opTxt, alt2type );
         // }
         return TypeInfo.canEvalWithBase(
            self.srcTypeInfo, self.mutable, other, opTxt, alt2type );
   }

   advertise srcTypeInfo;
}



pub class ModuleTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   //
   pri let mutable: bool {pub};

   pub fn __init( scope: Scope, externalFlag: bool,
                  txt: str, mut parentInfo: &TypeInfo!, typeId: int, mutable:bool )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = typeId;
      self.mutable = mutable;

      if! parentInfo {
         _exp.addChildren( self );
      }

      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;
      

      scope.set_ownerTypeInfo( self );
   }

   pub override fn isModule(): bool {
      return true;
   }

   pub override fn get_accessMode(): AccessMode {
      return AccessMode.Pub;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Module;
   } 
   
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt( fullName:bool!,
                  importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, fullName, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, fullName:bool!,
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      return rawTxt;
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }
   pub override fn canEvalWith(
      other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool {
      return false;
   }

   pub override fn serialize(
      stream: oStream, validChildrenSet: Map<int,&TypeInfo>! )
   {  
      let txt = "{ skind = %d, parentId = %d, typeId = %d, txt = '%s', kind = %d, "
          ( SerializeKind.Module,
            self.getParentId(), self.typeId, self.rawTxt, TypeInfoKind.Module );
      stream.write( txt .. '\n' );

      stream.write( "children = {" );

      let! set = validChildrenSet {
         set = {};
      };
      if! validChildrenSet {
         foreach child in self.$children {
            if set[ child.$typeId ] and
               ( child.$accessMode == .Pub or child.$accessMode == .Global ) {
               stream.write( "%d, " ( child.$typeId ) );
            }  
         }  
      }
      stream.write( "} }\n" );
   }
}

pub class EnumValInfo {
   pri let name: str {pub};
   pri let val:stem {pub};
}

pub class EnumTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   pri let nilableTypeInfo: &TypeInfo { pub };

   // この enum で格納している値の型
   pri let valTypeInfo: &TypeInfo {pub};
   

   // enum 値名 -> EnumValInfo
   pri let name2EnumValInfo: Map<str,EnumValInfo> { pub };
   
   pub fn __init( scope: Scope, externalFlag: bool, accessMode: AccessMode,
                  txt: str, parentInfo: &TypeInfo!, typeId: int, valTypeInfo:&TypeInfo,
                  name2EnumValInfo: Map<str,EnumValInfo> )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = typeId;
      self.name2EnumValInfo = name2EnumValInfo;
      self.valTypeInfo = valTypeInfo;

      if! parentInfo {
         _exp.addChildren( self );
      }

      self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;

      scope.set_ownerTypeInfo( self );
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Enum;
   } 
   
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt( fullName:bool!,
                  importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, fullName, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, fullName:bool!,
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   { 
      return rawTxt;
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }
   
   pub override fn canEvalWith(
      other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool {
      return self == other.$srcTypeInfo;
   }

   pub fn getEnumValInfo( name:str ): EnumValInfo! {
      return self.name2EnumValInfo[ name ];
   }

   pub override fn get_mutable(): bool {
      return true;
   };
}



pub class AlgeValInfo {
   pri let name: str {pub};
   pri let typeList:&List<&TypeInfo> {pub};

   pub fn serialize( stream: oStream ) {
      stream.write( "{ name = '%s', typeList = {" (self.name) );
      foreach typeInfo, index in self.typeList {
         if index > 1 {
            stream.write( ", " );
         }
         stream.write( "%d" ( typeInfo.$typeId ) );
      }
      stream.write( "} }" );
   }
}

pub class AlgeTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   pri let nilableTypeInfo: &TypeInfo { pub };

   pri let mut valInfoMap:Map<str,&AlgeValInfo> {pub};
   

   pub fn __init( scope: Scope, externalFlag: bool, accessMode: AccessMode,
                  txt: str, parentInfo: &TypeInfo!, typeId: int )
   {
      super( scope );

      self.externalFlag = externalFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.typeId = typeId;
      self.valInfoMap = {};

      if! parentInfo {
         _exp.addChildren( self );
      }

      self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;
      

      scope.set_ownerTypeInfo( self );
   }

   pub fn addValInfo( valInfo:&AlgeValInfo ) mut {
      self.valInfoMap[ valInfo.$name ] = valInfo;
   }

   pub fn getValInfo( name:str ) : &AlgeValInfo! {
      return self.valInfoMap[ name ];
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn get_kind(): TypeInfoKind {
      return .Alge;
   } 
   
   pub override fn getParentId(): int {
      return self.parentInfo.$typeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt( fullName:bool!,
                  importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, fullName, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, fullName:bool!,
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   { 
      return rawTxt;
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }
   
   pub override fn canEvalWith(
      other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool {
      return self == other.$srcTypeInfo;
   }

   pub override fn get_mutable(): bool {
      return true;
   };
}





pub class NormalTypeInfo extend TypeInfo {
   // 外部モジュールで定義した TypeInfo かどうか
   pri let externalFlag: bool { pub };
   // generic のタイプ
   pri let itemTypeInfoList: List<&TypeInfo> { pub };
   // 引数のタイプ
   pri let argTypeInfoList: List<&TypeInfo> { pub };
   // 戻り値のタイプ
   pri let retTypeInfoList: List<&TypeInfo> { pub };
   // 親のタイプ。メソッドの親はクラスとなる。
   pri let mut parentInfo: &TypeInfo { pub };
   // タイプ ID
   pri let typeId: int { pub };
   // タイプ名の文字列。配列などの [] は含まない。
   pri let rawTxt: str { pub };
   // タイプの種別
   pri let kind: TypeInfoKind { pub };
   // static かどうか
   pri let staticFlag: bool { pub };
   // アクセスモード "pub", "pro", "pri"
   pri let accessMode: AccessMode { pub };
   // コンパイラで自動生成された型情報の場合 true。 accessor 等。
   pri let autoFlag: bool { pub };
   /** */
   pri let abstractFlag: bool { pub };

   // 基底クラス。 無効な場合は headTypeInfo。
   pri let baseTypeInfo: &TypeInfo { pub };
   // インタフェースのリスト。
   pri let interfaceList: List<&TypeInfo> { pub };

   // この型の nilable 版の TypeInfo。 無効な場合は headTypeInfo。
   pri let mut nilableTypeInfo: &TypeInfo { pub };
   // このメソッドが mutable かどうか。
   pri let mutable: bool {pub};

   pri let alt2typeMap:Map<&TypeInfo,&TypeInfo>;

   fn __init( abstractFlag:bool, scope: Scope!, baseTypeInfo: TypeInfo!,
              interfaceList: List<&TypeInfo>!,
              autoFlag: bool, externalFlag: bool, staticFlag: bool,
              accessMode: AccessMode,
              txt: str, parentInfo: &TypeInfo!, typeId: int, kind: TypeInfoKind,
              itemTypeInfoList: List<&TypeInfo>!, argTypeInfoList:List<&TypeInfo>!,
              retTypeInfoList: List<&TypeInfo>!, mutable: bool! )
   {
      super( scope );

      if type(kind) ~= "number" {
         Util.printStackTrace();
      }

      self.abstractFlag = abstractFlag;
      self.baseTypeInfo = unwrap baseTypeInfo default headTypeInfo;
      self.interfaceList = unwrap interfaceList default [];
      self.autoFlag = autoFlag;
      self.externalFlag = externalFlag;
      self.staticFlag = staticFlag;
      self.accessMode = accessMode;
      self.rawTxt = txt;
      self.kind = kind;
      self.itemTypeInfoList = unwrap itemTypeInfoList default [];
      self.argTypeInfoList = unwrap argTypeInfoList default [];
      self.retTypeInfoList = unwrap retTypeInfoList default [];
      self.parentInfo = unwrap parentInfo default headTypeInfo;
      self.mutable = mutable and true or false;


      fn setupAlt2typeMap(): Map<&TypeInfo,&TypeInfo> {

         if self.baseTypeInfo == headTypeInfo and #self.interfaceList == 0 {
            return {};
         }
         let mut alt2typeMap:Map<&TypeInfo,&TypeInfo> = {};
         switch kind {
            case .Set, .Map, .List, .Array {
               if #self.itemTypeInfoList ~= #self.baseTypeInfo.$itemTypeInfoList {
                  Util.err( "unmatch generic type number -- %d, %d"
                            (#self.itemTypeInfoList,
                              #self.baseTypeInfo.$itemTypeInfoList ) );
               }
               foreach appyType, index in self.itemTypeInfoList {
                  let genType = self.baseTypeInfo.$itemTypeInfoList[ index ];
                  alt2typeMap[ genType ] = appyType;
               }
            }
            case .Class, .IF {
               if isGenericType( self.baseTypeInfo ) {
                  let genericType = self.baseTypeInfo@@GenericTypeInfo;
                  foreach genType, altType in genericType.createAlt2typeMap( false ) {
                     alt2typeMap[ altType ] = genType;
                  }
               }
               foreach ifType in self.interfaceList {
                  if isGenericType( ifType ) {
                     let genericType = ifType@@GenericTypeInfo;
                     foreach genType, altType in genericType.createAlt2typeMap( false ) {
                        alt2typeMap[ altType ] = genType;
                     }
                  }
               }
            }
         }
         return alt2typeMap;
      }
      
      self.alt2typeMap = setupAlt2typeMap();
      

      // if dummyRootTypeInfo and not parentInfo {
      //     Util.debugLog();
      //     error( "" );
      // }

      self.typeId = typeId;
      if kind == .Root {
         // dummyRootTypeInfo = self;
      }
      else {
         when! parentInfo {
            parentInfo.addChildren( self );
         }  

         let mut hasNilable = false;

         switch ( kind ) {
            case .Prim, .List, .Array, .Set,
                 .Map, .Class, .Stem, 
                 .Module, .IF   
            {
               hasNilable = true;
            }   
            case .Func, .Method {
               hasNilable = true;
            }
         }  
         if hasNilable {
            self.nilableTypeInfo = new NilableTypeInfo( self, typeId + 1 );
            idProv.increment();
         }
         else {
            self.nilableTypeInfo = headTypeInfo;
         }
         idProv.increment();
      } 
   }

   pub override fn createAlt2typeMap( detectFlag:bool ): Map<&TypeInfo,&TypeInfo> {
      let mut map:Map<&TypeInfo,&TypeInfo> = {};
      if detectFlag {
         map[ headTypeInfo ] = headTypeInfo;
      }
      foreach typeInfo, genType in self.alt2typeMap {
         map[ genType ] = typeInfo;
      }
      return map;
   }

   // この型が nilable を表わす型かどうか。
   pub override fn get_nilable(): bool {
      return false;
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn getParentId(): int {
      return self.parentInfo.$typeId or rootTypeId;
   }

   pub override fn get_baseId(): int {
      return self.baseTypeInfo.$typeId or rootTypeId;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt( fullName:bool!,
                  importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, fullName, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      raw:str, fullName:bool!,
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      let mut parentTxt = "";
      if fullName {
         parentTxt = self.getParentFullName( importInfo, localFlag );
      }
      // if self.kind == .Array {
      //    let! _exp = self.itemTypeInfoList[1] {
      //       return "[@]";
      //    }; 
      //    return _exp.getTxt() .. "[@]";
      // } 
      // if self.kind == .List {
      //    let! _exp = self.itemTypeInfoList[1] {
      //       return "[]";
      //    }; 
      //    return _exp.getTxt() .. "[]";
      // } 
      if #self.itemTypeInfoList > 0 {
         let mut txt = raw .. "<";
         foreach typeInfo, index in self.itemTypeInfoList {
            if index ~= 1 {
               txt = txt .. ",";
            }   
            txt = txt .. typeInfo.getTxt( fullName, importInfo, localFlag );
         }  

         return parentTxt .. txt .. ">";
      } 
      return parentTxt .. raw;
   }


   pub override fn get_display_stirng_with( raw:str ): str {
      if self.kind == .Func or self.kind == .Method
      {
         let mut txt = raw .. "(";
         foreach argType, index in self.argTypeInfoList {
            if index ~= 1 {
               txt = txt .. ", ";
            }
            txt = txt .. argType.get_display_stirng();
         }
         txt = txt .. ")";
         foreach retType, index in self.retTypeInfoList {
            if index == 1 {
               txt = txt .. ": ";
            }
            else {
               txt = txt .. ", ";
            }
            txt = txt .. retType.get_display_stirng();
         }
         return txt;
      }
      return self.getTxtWithRaw( raw ##);
   }

   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }
   
   
   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      if self.typeId == rootTypeId {
         return;
      }

      let parentId = self.getParentId();

      fn serializeTypeInfoList( name: str, list: &List<&TypeInfo>, onlyPub: bool! ): str {
         let mut work = name;
         foreach typeInfo in list {
            if not onlyPub or typeInfo.$accessMode == .Pub  {
               if #work ~=  #name {
                  work = work .. ", ";
               }    
               work = "%s%d" (work, typeInfo.$typeId );
            }   
         }  
         return work .. "}, ";
      } 

      let txt = ```{ skind=%d, parentId = %d, typeId = %d, baseId = %d, txt = '%s',
        abstractFlag = %s, staticFlag = %s, accessMode = %d, kind = %d, mutable = %s, ```
          ( SerializeKind.Normal, parentId, self.typeId, self.get_baseId(), self.rawTxt,
            self.abstractFlag, self.staticFlag, self.accessMode, self.kind, self.mutable );

      let mut children:List<&TypeInfo> = [];
      let! set = validChildrenSet {
         set = {};
      };
      foreach child in self.$children {
         if set[ child.$typeId ] {
            children.insert( child );
         }
      }
 
      stream.write(
         txt .. serializeTypeInfoList( "itemTypeId = {",
                                       self.itemTypeInfoList## ) ..
         serializeTypeInfoList( "ifList = {", self.interfaceList## ) ..
         serializeTypeInfoList( "argTypeId = {", self.argTypeInfoList## ) ..
         serializeTypeInfoList( "retTypeId = {", self.retTypeInfoList## ) ..
         serializeTypeInfoList( "children = {", children, true ) .. "}\n" );
   }

   pub fn equalsSub( typeInfo: &TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ): bool {
      if self.typeId == typeInfo.$typeId {
         return true;
      }

      // プリミティブな設定のチェック
      if self.kind ~= typeInfo.$kind or
         self.staticFlag ~= typeInfo.$staticFlag or
         self.accessMode ~= typeInfo.$accessMode or
         self.autoFlag ~= typeInfo.$autoFlag or
         self.$nilable ~= typeInfo.$nilable or
         self.rawTxt ~= typeInfo.$rawTxt or
         self.parentInfo ~= typeInfo.$parentInfo or
         self.baseTypeInfo ~= typeInfo.$baseTypeInfo
         //  or        
         // self ~= typeInfo.$srcTypeInfo
      { 
         // errorLog( "%s, %s" ( self.externalFlag, typeInfo.externalFlag ) );
         // errorLog( "%s, %s" ( self.kind, typeInfo.kind ) );
         // errorLog( "%s, %s" ( self.staticFlag, typeInfo.staticFlag ) );
         // errorLog( "%s, %s" ( self.accessMode, typeInfo.accessMode ) );
         // errorLog( "%s, %s" ( self.autoFlag, typeInfo.autoFlag ) );
         // errorLog( "%s, %s" ( self.nilable, typeInfo.nilable ) );
         return false;
      }

      // if ( self ~= typeInfo.$nonnilableType )
      // { 
      //    Util.log( "%s, %s" ( self, typeInfo.$nonnilableType ) );
      //    //          error( "illegal %s:%d %s:%d" ( self.getTxt(), self.typeId,
      //    //                                     typeInfo.getTxt(), typeInfo.typeId ) );
      //    return false;
      // }

      {
         if #self.itemTypeInfoList ~= #typeInfo.$itemTypeInfoList {
            return false;
         }  
         foreach item, index in self.itemTypeInfoList {
            if not item.equals( typeInfo.$itemTypeInfoList[ index ], alt2type ) {
               // error( "illegal %s:%d %s:%d"
               //    ( self.getTxt(), self.typeId,
               //      typeInfo.getTxt(), typeInfo.$typeId ) );
               return false;
            }   
         }
      }

      {
         if #self.retTypeInfoList ~= #typeInfo.$retTypeInfoList {
            // error( "illegal %s:%d %s:%d"
            //    ( self.getTxt(), self.typeId,
            //      typeInfo.getTxt(), typeInfo.$typeId ) );
            return false;
         }  
         foreach item, index in self.retTypeInfoList {
            if not item.equals( typeInfo.$retTypeInfoList[ index ], alt2type ) {
               // error( "illegal %s:%d %s:%d"
               //    ( self.getTxt(), self.typeId,
               //      typeInfo.getTxt(), typeInfo.$typeId ) );
               return false;
            }   
         }
      }

      // if not self.equals( typeInfo.$nonnilableType )
      // {     
      //    error( "illegal %s:%d %s:%d" ( self.getTxt(##), self.typeId,
      //                                   typeInfo.getTxt(##), typeInfo.$typeId ) );
      // }
      return true;
   }

   pub override fn equals( typeInfo: TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ): bool {
      return self.equalsSub( typeInfo, alt2type );
   }


   // pub static fn cloneToPublic( typeInfo: TypeInfo ): NormalTypeInfo {
   //    typeIdSeed = typeIdSeed + 1;
   //    return new NormalTypeInfo(
   //       typeInfo.$scope, typeInfo.$baseTypeInfo, nil, typeInfo.$autoFlag,
   //       typeInfo.$externalFlag, typeInfo.$staticFlag,
   //       "pub", typeInfo.$rawTxt, typeInfo.$parentInfo, typeIdSeed, typeInfo.$kind,
   //       typeInfo.$itemTypeInfoList, typeInfo.$argTypeInfoList,
   //       typeInfo.$retTypeInfoList );
   // }



   pub static fn create(
      accessMode:AccessMode, abstractFlag: bool, scope: Scope!, baseInfo: &TypeInfo,
      interfaceList: List<&TypeInfo>, parentInfo: &TypeInfo, staticFlag: bool,
      kind: TypeInfoKind, txt: str, itemTypeInfo: List<&TypeInfo>,
      argTypeInfoList: List<&TypeInfo>, retTypeInfoList: List<&TypeInfo>,
      mutable: bool! ): &TypeInfo
   {  
      if kind == .Prim {
         if! sym2builtInTypeMap[ txt ] {
            return _exp.$typeInfo;
         }
         Util.err( "not found symbol -- %s" (txt ) );
      }
      idProv.increment();
      //typeIdSeed = typeIdSeed + 1;
      let mut info = new NormalTypeInfo(
         abstractFlag, scope, baseInfo, interfaceList, false, true,
         staticFlag, accessMode, txt, parentInfo, idProv.$id, kind,
         itemTypeInfo, argTypeInfoList, retTypeInfoList, mutable ); 
      return info;
   }

}


pub static fn NormalTypeInfo.createAlternate(
   txt:str, accessMode:AccessMode, moduleTypeInfo:&TypeInfo ) : &AlternateTypeInfo
{
   return new AlternateTypeInfo( txt, accessMode, moduleTypeInfo );
}

//pub let typeInfoRoot = rootTypeInfo;

idProv.increment();
//typeIdSeed = typeIdSeed + 1;

fn registBuiltin( idName: str, typeTxt: str, kind: TypeInfoKind,
                  typeInfo:&TypeInfo, nilableTypeInfo:&TypeInfo )
{
   typeInfoKind[ idName ] = typeInfo;
   sym2builtInTypeMap[ typeTxt ] = new NormalSymbolInfo(
      SymbolKind.Typ, false, false,
      rootScope, AccessMode.Pub, false, typeTxt, typeInfo, false, true );
   if nilableTypeInfo ~= headTypeInfo {
      sym2builtInTypeMap[ typeTxt .. "!" ] = new NormalSymbolInfo(
         SymbolKind.Typ, false, kind == .Func, rootScope,
         AccessMode.Pub, false, typeTxt, nilableTypeInfo, false, true );
      builtInTypeIdSet[ nilableTypeInfo.$typeId ] = nilableTypeInfo;
   } 
   builtInTypeIdSet[ typeInfo.$typeId ] = typeInfo;
}

pub static fn NormalTypeInfo.createBuiltin(
   idName: str, typeTxt: str,
   kind: TypeInfoKind, typeDDD: TypeInfo! ): &TypeInfo
{
   //let mut typeId = typeIdSeed + 1;
   let mut typeId = idProv.$id + 1;
   if kind == .Root {
      typeId = rootTypeId;
   } 
   else {
      //typeIdSeed = typeIdSeed + 1;
      idProv.increment();
   } 
   let mut argTypeList:List<&TypeInfo> = [];
   let mut retTypeList:List<&TypeInfo> = [];
   if typeTxt == "form" {
      if! typeDDD {
         argTypeList = [ _exp ];
         retTypeList = [ _exp ];
      }  
   } 

   let mut scope:Scope! = nil;
   switch kind {
      case .Array, .List, .Set, .Class, .Module,
           .IF, .Func, .Method,
           .Macro
      {  
         scope = new Scope(
            rootScope,
            kind == .Class or kind == .Module or
            kind == .IF or kind == .List or kind == .Array or kind == .Set, nil## );
      }  
   }

   let mut genTypeList:List<&TypeInfo> = [];
   switch kind {
      case .Array, .List, .Set {
         genTypeList.insert( NormalTypeInfo.createAlternate( "T", .Pri, headTypeInfo ) );
      }
      case .Map {
         genTypeList.insert( NormalTypeInfo.createAlternate( "K", .Pri, headTypeInfo ) );
         genTypeList.insert( NormalTypeInfo.createAlternate( "V", .Pri, headTypeInfo ) );
      }
   }
   let mut info = new NormalTypeInfo(
      false, scope, nil, nil, false, false, false, AccessMode.Pub,
      typeTxt, headTypeInfo, typeId,
      kind, genTypeList, argTypeList, retTypeList, true );
   if scope {
      rootScope.addClass( typeTxt, info );
   } 

   registBuiltin( idName, typeTxt, kind, info, headTypeInfo );
   return info;
}

pub let builtinTypeNone:TypeInfo = 
   NormalTypeInfo.createBuiltin( "None", "", .Prim## );
pub let builtinTypeNeverRet:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Error", "__", .Prim## );
pub let builtinTypeStem:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Stem", "stem" , .Stem## );
pub let builtinTypeStem_ = unwrap builtinTypeStem.$nilableTypeInfo;

pub let builtinTypeBool:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Bool", "bool" , .Prim## );
pub let builtinTypeInt:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Int", "int" , .Prim## );
pub let builtinTypeReal:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Real", "real" , .Prim## );
pub let builtinTypeChar:TypeInfo = 
   NormalTypeInfo.createBuiltin( "char", "char" , .Prim## );
pub let builtinTypeString:TypeInfo = 
   NormalTypeInfo.createBuiltin( "String", "str" , .Class## );
pub let builtinTypeMap:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Map", "Map" , .Map## );
pub let builtinTypeSet:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Set", "Set" , .Set## );
pub let builtinTypeList:TypeInfo = 
   NormalTypeInfo.createBuiltin( "List", "List" , .List## );
pub let builtinTypeArray:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Array", "Array" , .Array## );

pub static fn NormalTypeInfo.createSet(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   itemTypeInfo: &List<&TypeInfo> ): &TypeInfo
{
   if #itemTypeInfo == 0 {
      Util.err( "illegal set type: %s" (itemTypeInfo) );
   } 
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, getScope( builtinTypeSet ), builtinTypeSet,
      nil, false, false, false, accessMode,
      "Set", headTypeInfo, idProv.$id, .Set, itemTypeInfo, nil, nil, true );
}

pub static fn NormalTypeInfo.createList(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   itemTypeInfo: &List<&TypeInfo> ): &TypeInfo
{
   if #itemTypeInfo == 0 {
      Util.err( "illegal list type: %s" (itemTypeInfo) );
   } 
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, getScope( builtinTypeList ), builtinTypeList,
      nil, false, false, false, accessMode,
      "List", headTypeInfo, idProv.$id, .List, itemTypeInfo, nil, nil, true );
}

pub static fn NormalTypeInfo.createArray(
   accessMode: AccessMode,
   parentInfo: &TypeInfo, itemTypeInfo: &List<&TypeInfo> ): &TypeInfo
{
   //   typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, getScope( builtinTypeArray ), builtinTypeArray,
      nil, false, false, false, accessMode,
      "Array", headTypeInfo, idProv.$id, .Array, itemTypeInfo, nil, nil, true );
}

pub static fn NormalTypeInfo.createMap(
   accessMode: AccessMode, parentInfo: &TypeInfo,
   keyTypeInfo: &TypeInfo, valTypeInfo: &TypeInfo ): &TypeInfo
{
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new NormalTypeInfo(
      false, getScope( builtinTypeMap ), builtinTypeMap,
      nil, false, false, false, accessMode,
      "Map", headTypeInfo, idProv.$id, .Map,
      [ keyTypeInfo, valTypeInfo ], nil, nil, true );
}


pub static fn NormalTypeInfo.createModule(
   scope: Scope, parentInfo: &TypeInfo, externalFlag: bool,
   moduleName: str, mutable:bool ): &TypeInfo
{
   if! sym2builtInTypeMap[ moduleName ] {
      return _exp.$typeInfo;
   }

   if Parser.isLuaKeyword( moduleName ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (moduleName) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new ModuleTypeInfo(
      scope, externalFlag, moduleName, parentInfo, idProv.$id, mutable );
   return info;
}


pub static fn NormalTypeInfo.createClass(
   classFlag: bool, abstractFlag: bool, scope: Scope!,
   baseInfo: TypeInfo!, interfaceList: List<&TypeInfo>!,
   genTypeList: &List<&AlternateTypeInfo>, parentInfo: &TypeInfo, externalFlag: bool,
   accessMode: AccessMode, className: str ): &TypeInfo
{
   // if className == "str" {
   //     return sym2builtInTypeMap[ className ]@TypeInfo;
   // }
   if! sym2builtInTypeMap[ className ] {
      return _exp.$typeInfo;
      //return classTypeInfo@TypeInfo;
   }

   if Parser.isLuaKeyword( className ) {
      Util.err( "This symbol can not use for a class or script file. -- %s"
                  (className) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new NormalTypeInfo(
      abstractFlag, scope, baseInfo, interfaceList, false,
      externalFlag, false, accessMode,
      className, parentInfo, idProv.$id,
      classFlag and TypeInfoKind.Class or TypeInfoKind.IF, genTypeList, nil, nil, true );
   return info;
}


pub static fn NormalTypeInfo.createFunc(
   abstractFlag: bool, builtinFlag:bool, scope: Scope!, kind: TypeInfoKind,
   parentInfo: &TypeInfo, autoFlag: bool, externalFlag: bool,
   staticFlag: bool, accessMode: AccessMode, funcName: str,
   altTypeList: &List<&TypeInfo>!, argTypeList: &List<&TypeInfo>!,
   retTypeInfoList: &List<&TypeInfo>!, mutable: bool! ): &TypeInfo
{
   if not builtinFlag and Parser.isLuaKeyword( funcName ) {
      Util.err( "This symbol can not use for a function. -- %s" (funcName) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new NormalTypeInfo(
      abstractFlag, scope, nil, nil, autoFlag, externalFlag, staticFlag,
      accessMode, funcName, parentInfo, idProv.$id,
      kind, unwrap altTypeList default [], unwrap argTypeList default [],
      unwrap retTypeInfoList default [], mutable );
   return info;
}

pub static fn NormalTypeInfo.createAdvertiseMethodFrom(
   classTypeInfo:&TypeInfo, typeInfo:&TypeInfo ): &TypeInfo
{
   return NormalTypeInfo.createFunc(
      false, false, typeInfo.$scope, typeInfo.$kind,
      classTypeInfo, true, false, false, typeInfo.$accessMode, typeInfo.$rawTxt,
      typeInfo.$itemTypeInfoList,
      typeInfo.$argTypeInfoList, typeInfo.$retTypeInfoList, typeInfo.$mutable );
}


let mut typeInfo2ModifierMap:Map<&TypeInfo,&TypeInfo> = {};

pub static fn NormalTypeInfo.createModifier(
   mut srcTypeInfo: &TypeInfo, mutable: bool ): &TypeInfo
{
   srcTypeInfo = srcTypeInfo.$srcTypeInfo;
   if! typeInfo2ModifierMap[ srcTypeInfo ] {
      if _exp.$typeId < userStartId and srcTypeInfo.$typeId >= userStartId {
         Util.err( "on cache" );
      }  
      return _exp;
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let modifier = new ModifierTypeInfo( srcTypeInfo, idProv.$id, mutable ); 
   typeInfo2ModifierMap[ srcTypeInfo ] = modifier;
   if modifier.$typeId < userStartId and srcTypeInfo.$typeId >= userStartId {
      Util.printStackTrace();
      Util.err( "off cache: %s %s %s"
                (srcTypeInfo.getTxt(##), modifier.$typeId, srcTypeInfo.$typeId));
   }
   return modifier;
}

pub override fn ModifierTypeInfo.get_nonnilableType(): &TypeInfo {
   let orgType = self.srcTypeInfo.$nonnilableType;
   if self.mutable or not orgType.$mutable {
      return orgType;
   }
   return NormalTypeInfo.createModifier( orgType, false );
}

pub static fn NormalTypeInfo.createAlias(
   name:str, externalFlag:bool, accessMode:AccessMode,
   parentInfo: &TypeInfo, typeInfo: &TypeInfo ): &AliasTypeInfo
{
   idProv.increment();
   return new AliasTypeInfo(
      name, accessMode, parentInfo, typeInfo.$srcTypeInfo, externalFlag, idProv.$id );
}

pub fn Scope.addAlias( name:str, externalFlag:bool, accessMode:AccessMode,
                       parentInfo: &TypeInfo, symbolInfo:&SymbolInfo ) mut : &SymbolInfo
{
   let aliasType = NormalTypeInfo.createAlias(
      name, externalFlag, accessMode, parentInfo, symbolInfo.$typeInfo.$srcTypeInfo );
   return self.add(
      symbolInfo.$kind, false, symbolInfo.$canBeRight,
      name, aliasType, accessMode, true, false, true );
}

pub fn Scope.addAliasForType( name:str, typeInfo:&TypeInfo ) mut : &SymbolInfo
{
   let mut skind = SymbolKind.Typ;
   let mut canBeRight = false;
   switch typeInfo.$kind {
      case .Func {
         skind = .Fun;
         canBeRight = true;
      }
      case .Macro {
         skind = .Mac;
      }
   }
   
   return self.add(
      skind, false, canBeRight, name, typeInfo, typeInfo.$accessMode, true, false, true );
}


pub proto class DDDTypeInfo extend TypeInfo;

let mut typeInfo2DDDMap:Map<&TypeInfo,&DDDTypeInfo> = {};

pub class DDDTypeInfo extend TypeInfo {
   pri let typeInfo: &TypeInfo { pub };
   pri let typeId: int { pub };
   pri let externalFlag: bool {pub};
   pri let itemTypeInfoList: &List<&TypeInfo> {pub};
   
   pub override fn get_scope(): Scope! {
      return nil;
   }

   pub fn __init( typeId:int, typeInfo:&TypeInfo, externalFlag:bool )
   {
      super( nil );
      self.typeId = typeId;
      //self.typeInfo = typeInfo.$nilableTypeInfo;
      self.typeInfo = typeInfo;
      self.externalFlag = externalFlag;
      self.itemTypeInfoList = [ self.typeInfo ];

      typeInfo2DDDMap[ typeInfo ] = self;
   }

   pub override fn isModule(): bool {
      return false;
   }

   pub override fn canEvalWith(
      other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool {
      return self.typeInfo.canEvalWith( other, opTxt, alt2type );
   }
   
   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      stream.write(
         '{ skind=%d, typeId = %d, itemTypeId = %d, parentId = %d }\n'
         ( SerializeKind.DDD, self.typeId,
           self.typeInfo.$typeId, headTypeInfo.$typeId ) );
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn getModule(): &TypeInfo {
      return self.$typeInfo.getModule();
   }
   pub override fn get_rawTxt(): str {
      return self.getTxt(##);
   }  
   pub override fn get_kind(): TypeInfoKind {
      return .DDD;
   } 
   pub override fn get_nilable(): bool {
      return self.typeInfo.$nilable;
   }
   pub override fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_mutable(): bool {
      return self.$typeInfo.$mutable;
   }
   pub override fn get_accessMode(): AccessMode {
      // export 出来るように pub 固定にする。
      // accessMode 毎にインスタンスを作ることも出来るが、
      // ほぼ無駄なので pub 固定とする。
      return .Pub;
   }
}


pub static fn NormalTypeInfo.createDDD(
   typeInfo:&TypeInfo, externalFlag:bool ): DDDTypeInfo
{
   if! typeInfo2DDDMap[ typeInfo ] {
      if _exp.$typeId < userStartId and typeInfo.$typeId >= userStartId {
         Util.err( "on cache" );
      }  
      return _exp;
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   return new DDDTypeInfo( idProv.$id, typeInfo, externalFlag );
}



pub let builtinTypeNil:TypeInfo = new NilTypeInfo();
registBuiltin( "Nil", "nil", .Prim, builtinTypeNil, headTypeInfo );

pub let builtinTypeDDD:TypeInfo =
   NormalTypeInfo.createDDD( builtinTypeStem_, true );
registBuiltin( "DDD", "...", .DDD, builtinTypeDDD, headTypeInfo );


pub let builtinTypeForm:TypeInfo =
   NormalTypeInfo.createBuiltin( "Form", "form" , .Func, builtinTypeDDD );
pub let builtinTypeSymbol:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Symbol", "sym" , .Prim## );
pub let builtinTypeStat:TypeInfo = 
   NormalTypeInfo.createBuiltin( "Stat", "stat" , .Prim## );

pub override fn DDDTypeInfo.getTxt(
   fullName:bool!, importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
{
   return self.getTxtWithRaw( "...", fullName, importInfo, localFlag );
}

pro override fn DDDTypeInfo.getTxtWithRaw(
   raw:str, fullName:bool!,
   importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
{
   if self.typeInfo == builtinTypeStem_ {
      return "...";
   }
   let txt = self.typeInfo.getTxtWithRaw( raw, fullName, importInfo, localFlag );
   return "...<" .. txt .. ">";
}

pub static fn NormalTypeInfo.createGeneric(
   genSrcTypeInfo:&TypeInfo,
   itemTypeInfoList:&List<&TypeInfo>, moduleTypeInfo:&TypeInfo ): GenericTypeInfo
{
   idProv.increment();
   return new GenericTypeInfo( genSrcTypeInfo, itemTypeInfoList, moduleTypeInfo );
}

pub class AbbrTypeInfo extend TypeInfo {
   pri let typeId: int { pub };
   pri let rawTxt:str { pub };
   
   pub override fn get_scope(): Scope! {
      return nil;
   }

   pub fn __init( idProvider:IdProvider, rawTxt:str )
   {
      super( nil );

      let typeId = idProvider.$id + 1;
      idProvider.increment();
      
      self.typeId = typeId;
      self.rawTxt = rawTxt;
   }

   pub override fn isModule(): bool {
      return false;
   }

   /** この型の名前を取得する。 */
   pub override fn getTxt( fullName:bool!,
                  importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {
      return self.getTxtWithRaw( self.$rawTxt, fullName, importInfo, localFlag );
   }
   pro override fn getTxtWithRaw(
      rawTxt:str, fullName:bool!,
      importInfo:&Map<&TypeInfo,&ModuleInfoIF>!, localFlag:bool! ) : str
   {  
      return rawTxt;
   }

   pub override fn canEvalWith(
      other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool {
      return false;
   }
   
   pub override fn serialize( stream: oStream, validChildrenSet: Map<int,&TypeInfo>! ) {
      Util.err( "illegal call" );
   }

   pub override fn get_display_stirng_with( raw:str ): str {
      return self.getTxtWithRaw( raw ##);
   }
   pub override fn get_display_stirng(): str {
      return self.get_display_stirng_with( self.$rawTxt );
   }

   pub override fn getModule(): &TypeInfo {
      return headTypeInfo;
   }
   pub override fn get_kind(): TypeInfoKind {
      return .Abbr;
   } 
   pub override fn get_nilable(): bool {
      return true;
   }
   pub override fn get_nilableTypeInfo(): &TypeInfo {
      return self;
   }
   pub override fn get_mutable(): bool {
      return false;
   }
   pub override fn get_accessMode(): AccessMode {
      return .Local;
   }
}

// pub let builtinTypeAbbr:TypeInfo = 
//    NormalTypeInfo.createBuiltin( "Abbr", "#" , .Abbr );
// pub let builtinTypeAbbrNone:TypeInfo = 
//    NormalTypeInfo.createBuiltin( "AbbrNone", "#_" , .Abbr );

pub let builtinTypeAbbr:TypeInfo = new AbbrTypeInfo( idProv, "##" );
pub let builtinTypeAbbrNone:TypeInfo = new AbbrTypeInfo( idProv, "[##]" );




let mut numberTypeSet:Set<&TypeInfo> = (@);
numberTypeSet.add( builtinTypeInt );
numberTypeSet.add( builtinTypeChar );
numberTypeSet.add( builtinTypeReal );

pub fn isNumberType( typeInfo:&TypeInfo ): bool {
   return numberTypeSet.has( typeInfo.$srcTypeInfo );
}


pub static fn NormalTypeInfo.createEnum(
   scope: Scope, parentInfo: &TypeInfo, externalFlag: bool,
   accessMode: AccessMode, enumName: str, valTypeInfo:&TypeInfo, 
   name2EnumValInfo:Map<str,EnumValInfo> ): &TypeInfo
{
   if Parser.isLuaKeyword( enumName ) {
      Util.err( "This symbol can not use for a enum. -- %s"
                (enumName) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new EnumTypeInfo(
      scope, externalFlag, accessMode, enumName,
      parentInfo, idProv.$id, valTypeInfo, name2EnumValInfo );

   let mut getEnumName = NormalTypeInfo.createFunc(
      false, true, nil, .Method, info,
      true, true, false, AccessMode.Pub,
      "get__txt", nil, nil, [ builtinTypeString ], false );
   scope.addMethod( getEnumName, AccessMode.Pub, false, false );

   let mut fromVal = NormalTypeInfo.createFunc(
      false, true, nil, .Func, info,
      true, true, true, AccessMode.Pub,
      "_from", nil, [ NormalTypeInfo.createModifier( valTypeInfo,false ) ],
      [ info.$nilableTypeInfo ], false );
   scope.addFunc( fromVal, AccessMode.Pub, true, false );

   let allListType = NormalTypeInfo.createList( .Pub, info, [ info ] );
   let mut allList = NormalTypeInfo.createFunc(
      false, true, nil, .Func, info,
      true, true, true, AccessMode.Pub,
      "get__allList", nil, nil,
      [ NormalTypeInfo.createModifier( allListType, false ) ], false );
   scope.addFunc( allList, AccessMode.Pub, true, false );
   
   return info;
}

pub override fn EnumTypeInfo.serialize(
   stream: oStream, validChildrenSet: Map<int,&TypeInfo>! )
{
   let txt = ```{ skind = %d, parentId = %d, typeId = %d, txt = '%s',
accessMode = %d, kind = %d, valTypeId = %d, ```
       ( SerializeKind.Enum, self.getParentId(), self.typeId, self.rawTxt,
         self.accessMode, TypeInfoKind.Enum, self.valTypeInfo.$typeId );
   stream.write( txt );

   stream.write( "enumValList = {" );
   forsort enumValInfo in self.name2EnumValInfo {
      if self.valTypeInfo.equals( builtinTypeString## ) {
         stream.write( "%s = '%s'," (enumValInfo.$name, enumValInfo.$val) );
      }
      else {
         stream.write( "%s = %s," (enumValInfo.$name, enumValInfo.$val) );
      }
   }
   stream.write( "} }\n" );
}



pub static fn NormalTypeInfo.createAlge(
   scope: Scope, parentInfo: &TypeInfo, externalFlag: bool,
   accessMode: AccessMode, algeName: str ): AlgeTypeInfo
{
   if Parser.isLuaKeyword( algeName ) {
      Util.err( "This symbol can not use for a alge. -- %s"
                (algeName) );
   }
   
   //typeIdSeed = typeIdSeed + 1;
   idProv.increment();
   let mut info = new AlgeTypeInfo(
      scope, externalFlag, accessMode, algeName, parentInfo, idProv.$id );

   let mut getAlgeName = NormalTypeInfo.createFunc(
      false, true, nil, .Method, info,
      true, true, false, AccessMode.Pub,
      "get__txt", nil, nil, [ builtinTypeString ], false );
   scope.addMethod( getAlgeName, AccessMode.Pub, false, false );

   return info;
}

pub override fn AlgeTypeInfo.serialize(
   stream: oStream, validChildrenSet: Map<int,&TypeInfo>! )
{
   let txt = ```{ skind = %d, parentId = %d, typeId = %d, txt = '%s',
accessMode = %d, kind = %d, ```
       ( SerializeKind.Alge, self.getParentId(), self.typeId, self.rawTxt,
         self.accessMode, TypeInfoKind.Alge );
   stream.write( txt );

   stream.write( "algeValList = {" );
   let mut firstFlag = true;
   forsort algeValInfo in self.valInfoMap {
      if not firstFlag {
         stream.write( "," );
      }
      else {
         firstFlag = false;
      }
      algeValInfo.serialize( stream );
   }
   stream.write( "} }\n" );
}




// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NilableTypeInfo.canEvalWith(
   other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ): bool {
   let otherSrc = other.$srcTypeInfo;

   if self == builtinTypeStem_ {
      return true;
   }  
   if otherSrc == builtinTypeNil or otherSrc.$kind == .Abbr {
      return true;
   }  
   if self.typeId == otherSrc.$typeId {
      return true;
   }
   if otherSrc.$nilable {
      return self.$nonnilableType.canEvalWith(
         otherSrc.$nonnilableType, opTxt, alt2type );
   }
   return self.$nonnilableType.canEvalWith( otherSrc, opTxt, alt2type );
}
   
macro _checkEqualsItemType( type1:sym, type2:sym, index:int, alt2type:sym ) {
   if not (unwrap ,,type1.$itemTypeInfoList[ ,,index ]).canEvalWith(
      unwrap ,,type2.$itemTypeInfoList[ ,,index ], "=", ,,alt2type )
   {
      return false;
   }
};

// other のクラスが、この型のクラスの継承関係にあるか調べる
pub override fn NormalTypeInfo.isInheritFrom(
   other:&TypeInfo, alt2type:Map<&TypeInfo,&TypeInfo>! ) : bool
{
   let otherTypeId = other.$typeId;
   if self.$typeId == otherTypeId {
      return true;
   }
   if ( self.$kind ~= .Class and self.$kind ~= .IF ) or
      ( other.$kind ~= .Class and other.$kind ~= .IF )
   {  
      return false;
   }
   let mut baseTypeInfo = self.$baseTypeInfo;
   if baseTypeInfo ~= headTypeInfo {
      if baseTypeInfo.isInheritFrom( other, alt2type ) {
         return true;
      }
   };
   foreach ifType in self.$interfaceList {
      if ifType.isInheritFrom( other, alt2type ) {
         return true;
      }
   }
   return false;
}

pub enum MatchType {
   Match,
   Warn,
   Error,
}

/**
expTypeList の型から、 dstTypeListOrg の型へ互換性があるかどうか確認する。

@param warnForFollowSrcIndex
   このインデックス以降の expTypeList をチェックする際、
   dstTypeListOrg の型が省略可能な場合 Warn を出す。
@return MatchType 適合結果
@return str メッセージ
*/
pub static fn TypeInfo.checkMatchType(
   dstTypeList: &List<&TypeInfo>, expTypeList: &List<&TypeInfo>,
   allowDstShort:bool, warnForFollowSrcIndex:int!, alt2type:Map<&TypeInfo,&TypeInfo> ) :
   MatchType, str
{
   macro _checkWarnForFollow( index:sym, dstType:sym, expType:sym ) {
      when! warnForFollowSrcIndex {
         if warnForFollowSrcIndex <= ,,index and ,,dstType.$nilable {
            let mess = "use '**' at arg(%d). %s <- %s"
                ( ,,index, ,,dstType.getTxt(true##), ,,expType.getTxt(true##) );
            return .Warn, mess;
         }
      }
   }
   
   // index 番以降の dstTypeList の要素が srcType, srcType2nd と等しいか調べる。
   // index 番目と srcType, index + 1 以降と srcType2nd を調べる。 
   // dstTypeList[ index ] == srcType
   // dstTypeList[ index + ? ] == srcType2nd 
   fn checkDstTypeFrom(
      index:int, srcType:&TypeInfo, srcType2nd:&TypeInfo ): MatchType, str
   {  
      let mut workExpType = srcType;
      for dstIndex = index, #dstTypeList {
         let workDstType = dstTypeList[ dstIndex ];
         let mut matchResult = MatchType.Match;
         if not workDstType.canEvalWith( workExpType, "=", alt2type ) {
            let message = "exp(%d) type mismatch %s <- %s"
                ( dstIndex, workDstType.getTxt( true## ), workExpType.getTxt( true## ) );
            return .Error, message;
         }
         elseif workExpType == builtinTypeAbbrNone {
            return .Warn, Code.format( .nothing_define_abbr,
                                       "use '##', instate of %s."
                                       (workDstType.getTxt(true##)) );
         }

         if matchResult ~= .Match {
         }
         workExpType = srcType2nd;
      }
      return .Match, "";
   }
   fn checkSrcTypeFrom( index:int, dstType:&TypeInfo ) : MatchType, str
   {  
      for srcIndex = index, #expTypeList {
         let expType = expTypeList[ srcIndex ];
         let mut checkType = expType;
         if expType.$kind == .DDD {
            if #expType.$itemTypeInfoList > 0 {
               checkType = expType.$itemTypeInfoList[ 1 ];
            }
            else {
               checkType = builtinTypeStem_;
            }
         }
         if not dstType.canEvalWith( checkType, "=", alt2type ) {
            return .Error, "exp(%d) type mismatch %s <- %s"
            ( srcIndex, dstType.getTxt( true## ), expType.getTxt( true## ) );
         }

         _checkWarnForFollow( srcIndex, dstType, expType );
      }
      return .Match, "";
   }
   
   if #expTypeList > 0 {
      foreach expType, index in expTypeList {
         if #dstTypeList == 0 {
            return .Error, "over exp. expect:0, actual:%d" ( #expTypeList);
         }
         let dstType = dstTypeList[ index ];
         if #dstTypeList == index {
            // dst の最終引数
            if dstType.$srcTypeInfo.$kind ~= .DDD {
               if not dstType.canEvalWith( expType, "=", alt2type ) {
                  return .Error, "exp(%d) type mismatch %s <- %s"
                  ( index, dstType.getTxt( true## ),
                    expType.getTxt(true## ));
               }
               if not allowDstShort and #dstTypeList < #expTypeList {
                  return .Error, "over exp. expect: %d: actual: %d"
                  (#dstTypeList, #expTypeList );
               }
            }
            else {
               let mut dddItemType = builtinTypeStem_;
               if #dstType.$itemTypeInfoList > 0 {
                  dddItemType = dstType.$itemTypeInfoList[ 1 ];
               }
               let result, mess = checkSrcTypeFrom( index, dddItemType );
               if result ~= .Match {
                  return result, mess;
               }
            }
            when! warnForFollowSrcIndex {
               if warnForFollowSrcIndex <= index and dstType.$nilable {
                  let mess = "use '**' at arg(%d). %s <- %s"
                      ( index, dstType.getTxt(true##), expType.getTxt(true##) );
                  return .Warn, mess;
               }
            }
            break;
         }
         elseif #expTypeList == index {
            // 最終実引数処理
            let mut srcType = expType;
            let mut srcType2nd = builtinTypeAbbrNone;
            //let mut srcType2nd = builtinTypeNil;
            if expType.$kind == .DDD {
               srcType = builtinTypeStem_;
               srcType2nd = builtinTypeStem_;
               if #expType.$itemTypeInfoList > 0 {
                  srcType = expType.$itemTypeInfoList[ 1 ];
                  srcType2nd = srcType;
               }
            }
            elseif expType == builtinTypeAbbr {
               srcType2nd = builtinTypeAbbr;
            }
            
            let result, mess = checkDstTypeFrom( index, srcType, srcType2nd );
            if result ~= .Match {
               return result, mess;
            }
            when! warnForFollowSrcIndex {
               if warnForFollowSrcIndex <= index and dstType.$nilable {
                  let warnMess = "use '**' at arg(%d). %s <- %s"
                      ( index, dstType.getTxt(true##), expType.getTxt(true##) );
                  return .Warn, warnMess;
               }
            }
            break;
         }
         else {
            if not dstType.canEvalWith( expType, "=", alt2type ) {
               return .Error, "exp(%d) type mismatch %s <- %s"
               ( index, dstType.getTxt( true## ),
                 expType.getTxt( true## ));
            }  
            when! warnForFollowSrcIndex {
               if warnForFollowSrcIndex <= index and dstType.$nilable {
                  let mess = "use '**' at arg(%d). %s <- %s"
                      ( index, dstType.getTxt(true##), expType.getTxt(true##) );
                  return .Warn, mess;
               }
            }
         }  
      }
   }
   elseif not allowDstShort {
      foreach dstType, index in dstTypeList {
         if not dstType.canEvalWith( builtinTypeNil, "=", alt2type ) {
            return .Error, "exp(%d) type mismatch %s <- nil"
            ( index, dstType.getTxt( true## ));
         }
         return .Warn, Code.format( .nothing_define_abbr,
                                    "use '##', instate of %s."
                                    (dstType.getTxt(true##) ) );
      }
   }
   return .Match, "";
}

pub static fn TypeInfo.canEvalWithBase(
   dest:&TypeInfo, destMut:bool, other:&TypeInfo, opTxt:str,
   alt2type:Map<&TypeInfo,&TypeInfo> ) : bool
{
   let otherMut = other.$mutable;
   let mut otherSrc = other.$srcTypeInfo;
   if otherSrc.$kind == .DDD {
      if #otherSrc.$itemTypeInfoList > 0 {
         otherSrc = otherSrc.$itemTypeInfoList[ 1 ];
      }
   }

   if opTxt == "=" and
      otherSrc ~= builtinTypeNil and
      otherSrc ~= builtinTypeString and
      otherSrc.$kind ~= .Prim and
      otherSrc.$kind ~= .Func and
      otherSrc.$kind ~= .Enum and
      otherSrc.$kind ~= .Abbr and
      otherSrc.$kind ~= .Alternate and
      not isGenericType( otherSrc ) and
      destMut and not otherMut
   {
      return false;
   }

   if dest == builtinTypeStem_ {
      return true;
   }
   if dest.$srcTypeInfo.$kind == .DDD {
      if #dest.$itemTypeInfoList > 0 {
         return dest.$itemTypeInfoList[ 1 ].canEvalWith( other, opTxt, alt2type );
      }
      return true;
   }
   if not dest.$nilable and otherSrc.$nilable {
      return false;
   }
   if dest == builtinTypeStem and not otherSrc.$nilable {
      return true;
   }
   if dest == builtinTypeForm and otherSrc.$kind == .Func {
      return true;
   }
   if otherSrc == builtinTypeNil or otherSrc.$kind == .Abbr {
      if dest.$kind ~= .Nilable {
         return false;
      } 
      return true;
   }
   if dest.$typeId == otherSrc.$typeId {
      return true;
   }
   if dest.$kind ~= otherSrc.$kind {
      if dest.$kind == .Nilable {
         if otherSrc.$nilable {
            return dest.$nonnilableType.canEvalWith(
               otherSrc.$nonnilableType, opTxt, alt2type );
         }
         return dest.$nonnilableType.canEvalWith( otherSrc, opTxt, alt2type );
      }
      elseif isGenericType( dest ) {
         return dest.canEvalWith( otherSrc, opTxt, alt2type );
      }
      elseif ( dest.$kind == .Class or dest.$kind == .IF ) and
         ( otherSrc.$kind == .Class or otherSrc.$kind == .IF )
      {
         return otherSrc.isInheritFrom( dest, alt2type );
      }
      elseif otherSrc.$kind == .Enum {
         let enumTypeInfo = otherSrc@@EnumTypeInfo;
         return dest.canEvalWith( enumTypeInfo.$valTypeInfo, opTxt, alt2type );
      }
      elseif dest.$kind == .Alternate {
         return dest.canEvalWith( otherSrc, opTxt, alt2type );
      }
      return false;
   }
   // TypeInfoKind が等しい
   switch dest.$kind {
      case .Prim {
         if dest == builtinTypeInt and otherSrc == builtinTypeChar or
            dest == builtinTypeChar and otherSrc == builtinTypeInt
         {  
            return true;
         }
         // int から real の代入を暗黙変換を許可すると
         // [ 1, 1.0 ] の型が List<stem> ではなく List<real> なってしまうので
         // 許可しない。
         // if dest == builtinTypeReal and
         //     ( otherSrc == builtinTypeInt or otherSrc == builtinTypeChar )
         // {
         //    return true;
         // }
         return false;
      }       
      case .List, .Array, .Set {
         if otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone {
            // literalMap の [], [@] は互換有りとする
            return true;
         }  
         _checkEqualsItemType( dest, otherSrc, 1, alt2type );
         return true;
      }       
      case .Map {
         if otherSrc.$itemTypeInfoList[ 1 ] == builtinTypeNone and
            otherSrc.$itemTypeInfoList[ 2 ] == builtinTypeNone
         {  
            // literalMap の {} は互換有りとする
            return true;
         }
         _checkEqualsItemType( dest, otherSrc, 1, alt2type );
         _checkEqualsItemType( dest, otherSrc, 2, alt2type );
         return true;
      }       
      case .Class, .IF {
         return otherSrc.isInheritFrom( dest, alt2type );
      }       
      case .Func {
         if dest == builtinTypeForm {
            return true;
         }  
         if TypeInfo.checkMatchType( dest.$argTypeInfoList, otherSrc.$argTypeInfoList,
                                     false, nil, alt2type ) == .Error or
            TypeInfo.checkMatchType( dest.$retTypeInfoList, otherSrc.$retTypeInfoList,
                                     false, nil, alt2type ) == .Error or
            #dest.$retTypeInfoList ~= #otherSrc.$retTypeInfoList
         {
            return false;
         }
         return true;
      }       
      case .Method {
         // if TypeInfo.checkMatchType( dest.$argTypeInfoList, otherSrc.$argTypeInfoList,
         //                             false, nil, alt2type ) == .Error or
         //    TypeInfo.checkMatchType( dest.$retTypeInfoList, otherSrc.$retTypeInfoList,
         //                             false, nil, alt2type ) == .Error or
         //    #dest.$retTypeInfoList ~= #otherSrc.$retTypeInfoList
         // {
         //    return false;
         // }
         if #dest.$argTypeInfoList ~= #otherSrc.$argTypeInfoList or
            #dest.$retTypeInfoList ~= #otherSrc.$retTypeInfoList
         {        
            return false;
         }
         foreach argType, index in dest.$argTypeInfoList {
            let otherArgType = otherSrc.$argTypeInfoList[ index ];
            if not argType.equals( otherArgType, alt2type ) {
               Util.errorLog( "unmatch arg(%d) type -- %s(%d), %s(%d)"
                              ( index, argType.getTxt(##), argType.$typeId, 
                                otherArgType.getTxt(##), otherArgType.$typeId ));
               return false;
            }
         }
         foreach retType, index in dest.$retTypeInfoList {
            let otherRetType = otherSrc.$retTypeInfoList[ index ];
            if not retType.equals( otherRetType, alt2type ) {
               Util.errorLog( "unmatch ret(%d) type -- %s(%d), %s(%d)"
                              (index, retType.getTxt(##), retType.$typeId,
                                otherRetType.getTxt(##), otherRetType.$typeId ));
               return false;
            }
         }
         return true;
      }
      case .Nilable {
         return dest.$nonnilableType.canEvalWith(
            otherSrc.$nonnilableType, opTxt, alt2type );
      }
      case .Alternate {
         return dest.canEvalWith( otherSrc, opTxt, alt2type );
      }
      default {
         return false;
      } 
   }
}


// other 型の値を、この型の変数に設定できるか判定する。
pub override fn NormalTypeInfo.canEvalWith(
   other:&TypeInfo, opTxt:str, alt2type:Map<&TypeInfo,&TypeInfo> ) : bool {
   return TypeInfo.canEvalWithBase( self, self.$mutable, other, opTxt, alt2type );
}



pub override fn ModifierTypeInfo.applyGeneric(
   alt2typeMap:&Map<&TypeInfo,&TypeInfo> ): &TypeInfo!
{
   let typeInfo = self.srcTypeInfo.applyGeneric( alt2typeMap );
   if typeInfo == self.srcTypeInfo {
      return self;
   }
   when! typeInfo {
      return NormalTypeInfo.createModifier( typeInfo, false );
   }
   return nil;
}


pub override fn NormalTypeInfo.applyGeneric(
   alt2typeMap:&Map<&TypeInfo,&TypeInfo> ): &TypeInfo!
{
   let mut needNew = false;
   let mut fail = false;
   fn createGen( typeList:&List<&TypeInfo> ): &List<&TypeInfo> {
      let mut typeInfoList:List<&TypeInfo> = [];
      foreach srcType in typeList {
         if! let typeInfo = srcType.applyGeneric( alt2typeMap ) {
            typeInfoList.insert( typeInfo );
            if srcType ~= typeInfo {
               needNew = true;
            }  
         }
         else {
            fail = true;
            break;
         }     
      }  
      return typeInfoList;
   }
   
   let itemTypeInfoList = createGen( self.itemTypeInfoList );
   let argTypeInfoList = createGen( self.argTypeInfoList );
   let retTypeInfoList = createGen( self.retTypeInfoList );
   if fail {
      return nil;
   }
   if not needNew {
      return self;
   }
   switch self.$kind {
      case .Set {
         return NormalTypeInfo.createSet(
            self.accessMode, self.parentInfo, itemTypeInfoList );
      }
      case .List {
         return NormalTypeInfo.createList(
            self.accessMode, self.parentInfo, itemTypeInfoList );
      }
      case .List {
         return NormalTypeInfo.createArray(
            self.accessMode, self.parentInfo, itemTypeInfoList );
      }
      case .Map {
         return NormalTypeInfo.createMap(
            self.accessMode, self.parentInfo,
            itemTypeInfoList[ 1 ], itemTypeInfoList[ 2 ] );
      }
      case .Func {
         return NormalTypeInfo.createFunc(
            self.abstractFlag, false, self.$scope, self.kind,
            self.parentInfo, self.autoFlag, self.externalFlag,
            self.staticFlag, self.accessMode, self.rawTxt,
            itemTypeInfoList, argTypeInfoList, retTypeInfoList, self.mutable );
      }
      default {
         return nil;
      }
   }
}



pub class Filter<T> {
}


/**
制御中断要因。

優先度の高い順に宣言する。
*/
pub enum BreakKind {
   None,
   Break,
   Return,
   NeverRet,
}

pub enum CheckBreakMode {
   /** フローを解析する */
   Normal,
   /** フローを解析する (return 有無の解析)  */
   Return,
   /** フローを解析しない */
   IgnoreFlow,
   /** フローを解析しない (return 有無の解析) */
   IgnoreFlowReturn,
}

pub class Node {
   pri let kind: int { pub };
   pri let pos: &Parser.Position { pub };
   pri let expTypeList: &List<&TypeInfo> { pub };

   pub fn get_expType(): &TypeInfo {
      if #self.expTypeList == 0 {
         return builtinTypeNone;
      }
      return self.expTypeList[ 1 ];
   }; 
   
   pub fn getLiteral(): stem![], List<&TypeInfo> {
      return [nil], [builtinTypeNil];
   }
   pub fn processFilter<OPT>( filter: Filter<OPT>, opt:OPT ) {
   }
   /** 代入式の左辺になれるかどうか */
   pub fn canBeLeft(): bool {
      return false;
   };     
   /** 代入式の右辺になれるかどうか */
   pub fn canBeRight(): bool {
      return false;
   }
   /** 単体で文になれるかどうか */
   pub fn canBeStatement(): bool {
      return false;
   }
   /**
制御の中断種別を得る。

全てのケースで return で終っている場合や、 error() などをコールしている場合など。

@param checkMode モード
*/
   pub fn getBreakKind( checkMode:CheckBreakMode ): BreakKind {
      return .None;
   }
}



pub class NamespaceInfo {
   pub let name: str;
   pub let scope: Scope;
   pub let typeInfo: &TypeInfo;
}


pub proto abstract class MacroEval;
pub proto class ExpListNode extend Node;
pub proto class DeclArgNode extend Node;
pub proto class BlockNode extend Node;

pub class DeclMacroInfo {
   pri let pubFlag: bool {pub};
   pri let name: &Parser.Token { pub };
   pri let argList: List<&DeclArgNode> { pub };
   /** macro-statment の BlockNode */
   pri let stmtBlock: &BlockNode! { pub };
   /** expand-statemnt の token リスト */
   pri let tokenList: List<&Parser.Token> { pub };
}

let mut nodeKind2NameMap: Map<int,str> = {};
let mut nodeKindSeed = 1;
pub let mut nodeKind: Map<str,int> = {};

fn regKind( name:str ): int {
   let kind = nodeKindSeed;
   nodeKindSeed = nodeKindSeed + 1;
   nodeKind2NameMap[ kind ] = name;
   nodeKind[ name ] = kind;
   return kind;
}

pub fn getNodeKindName( kind: int ): str {
   return unwrap nodeKind2NameMap[ kind ];
}

// let nodeKindNone = regKind( 'None' );
// let nodeKindImport = regKind( 'Import' );
// let nodeKindRoot = regKind( 'Root' );
// let nodeKindRefType = regKind( 'RefType' );
// let nodeKindIf = regKind( 'If' );
// let nodeKindSwitch = regKind( 'Switch' );
// let nodeKindWhile = regKind( 'While' );
// let nodeKindRepeat = regKind( 'Repeat' );
// let nodeKindFor = regKind( 'For' );
// let nodeKindApply = regKind( 'Apply' );
// let nodeKindForeach = regKind( 'Foreach' );
// let nodeKindForsort = regKind( 'Forsort' );
// let nodeKindReturn = regKind( 'Return' );
// let nodeKindBreak = regKind( 'Break' );
// let nodeKindExpNew = regKind( 'ExpNew' );
// let nodeKindExpList = regKind( 'ExpList' );
// let nodeKindExpRef = regKind( 'ExpRef' );
// let nodeKindExpOp2 = regKind( 'ExpOp2' );
// let nodeKindExpCast = regKind( 'ExpCast' );
// let nodeKindExpOp1 = regKind( 'ExpOp1' );
// let nodeKindExpRefItem = regKind( 'ExpRefItem' );
// let nodeKindExpCall = regKind( 'ExpCall' );
// let nodeKindExpCallSuper = regKind( 'ExpCallSuper' );
// let nodeKindExpDDD = regKind( 'ExpDDD' );
// let nodeKindExpParen = regKind( 'ExpParen' );
// let nodeKindExpMacroExp = regKind( 'ExpMacroExp' ); // macro expand
// let nodeKindExpMacroStat = regKind( 'ExpMacroStat' ); // `{}
// let nodeKindBlock = regKind( 'Block' );
// let nodeKindStmtExp = regKind( 'StmtExp' );
// let nodeKindRefField = regKind( 'RefField' );
// let nodeKindDeclVar = regKind( 'DeclVar' );
// let nodeKindDeclFunc = regKind( 'DeclFunc' );
// let nodeKindDeclMethod = regKind( 'DeclMethod' );
// let nodeKindDeclConstr = regKind( 'DeclConstr' );
// let nodeKindDeclMember = regKind( 'DeclMember' );
// let nodeKindDeclArg = regKind( 'DeclArg' );
// let nodeKindDeclArgDDD = regKind( 'DeclArgDDD' );
// let nodeKindDeclClass = regKind( 'DeclClass' );
// let nodeKindDeclMacro = regKind( 'DeclMacro' );
// let nodeKindLiteralNil = regKind( 'LiteralNil' );
// let nodeKindLiteralChar = regKind( 'LiteralChar' );
// let nodeKindLiteralInt = regKind( 'LiteralInt' );
// let nodeKindLiteralReal = regKind( 'LiteralReal' );
// let nodeKindLiteralArray = regKind( 'LiteralArray' );
// let nodeKindLiteralList = regKind( 'LiteralList' );
// let nodeKindLiteralMap = regKind( 'LiteralMap' );
// let nodeKindLiteralString = regKind( 'LiteralString' );
// let nodeKindLiteralBool = regKind( 'LiteralBool' );
// let nodeKindLiteralSymbol = regKind( 'LiteralSymbol' );

pub class NodeManager {
   let mut nodeKind2NodeList:Map<int,List<&Node>>;

   pub fn __init() {
      self.nodeKind2NodeList = {};
   }

   pub fn getList(kind:int) : &List<&Node>! {
      return self.nodeKind2NodeList[ kind ];
   }
   pub fn addNode(node:&Node) mut {
      let! mut list = self.nodeKind2NodeList[ node.$kind ] {
         list = [];
         self.nodeKind2NodeList[ node.$kind ] = list;
      };
      list.insert( node );
   }
}

pub class NodeKind {
}


macro _declNodeClass(
   baseName:str, super:sym, canBeLeftFlag:bool!, canBeRightFlag:bool!,
   canBeStatementFlag:bool!, fieldInfoList:Map<str,str>[] )
{
   {
      let className = ,,,"%sNode" (baseName);
      let nodeKindSym = ,,,"%s" (baseName);
      let nodeKindGetter = ,,,"get_%s" (baseName);

      let mut fieldStatList:stat[] = [];
      let mut argList:stat[] = [];
      let mut argSymList:stat[] = [];
      let mut initStatList:stat[] = [];
      let mut relateStat:stat[] = [];
      
      foreach fieldInfo in fieldInfoList {
         foreach typeName, varName in fieldInfo {
            fieldStatList.insert( `{
               pri let mut ,,,varName : ,,,typeName { pub };
            });  
            argList.insert( `{ ,,,varName: ,,,typeName, } );
            argSymList.insert( `{, ,,,varName } );
            initStatList.insert( `{ self.,,,varName = ,,,varName; } );
         }   
      }  

      fieldStatList.insert( `{
         pub override fn processFilter<OPT>( filter: Filter<OPT>, opt:OPT ) {
            filter.,,,"process%s" (baseName) (self, opt );
         } } );

      if! canBeRightFlag {
         fieldStatList.insert( `{
            pub override fn canBeRight():bool {
               return ,,, canBeRightFlag;
            } } );
      }
      if! canBeLeftFlag {
         fieldStatList.insert( `{
            pub override fn canBeLeft():bool {
               return ,,, canBeLeftFlag;
            } } );
      }
      if! canBeStatementFlag {
         fieldStatList.insert( `{
            pub override fn canBeStatement():bool {
               return ,,, canBeStatementFlag;
            } } );
      }
      
      let superStat = `{
         super( unwrap nodeKind. ,,nodeKindSym, pos, typeList );
      };

      relateStat.insert( `{
         pub fn Filter. ,,,"process%s" (baseName) ( node: &,,className, opt:T ) mut {
         };
         pub fn NodeManager. ,,,"get%sList" (,,,,className) () : &List<&,,className>! {
            return self.getList( unwrap nodeKind. ,,nodeKindSym )@@List<&,,className> !;
         }
      } );
      
   }

   pub static fn NodeKind.,,nodeKindGetter (): int {
      return unwrap nodeKind. ,,nodeKindSym;
   }
   
   pub proto class ,,className extend ,,super;
   regKind( ,,baseName );
   ,,relateStat;
   pub class ,,className extend ,,super {
      ,,fieldStatList;
      pro fn __init( pos: &Parser.Position, typeList: &List<&TypeInfo>, ,,argList ) {
         ,,superStat;
         ,,initStatList;
      }
      pub static fn create( nodeMan:NodeManager, pos: &Parser.Position,
                            typeList: &List<&TypeInfo>, ,,argList ) : ,,className
      {
         let mut node = new ,,className( pos, typeList ,,argSymList );
         nodeMan.addNode( node );
         return node;
      }
   }
}

_declNodeClass( "None", Node, false, false, true, []);
_declNodeClass( "Subfile", Node, false, false, true,
                [ { "usePath": "str!" } ]);
_declNodeClass( "Import", Node, false, false, true,
                [ { "modulePath": "str" },
                  { "assignName": "str" },
                  { "moduleTypeInfo": "&TypeInfo" } ]
);


pub proto class ProvideNode extend Node;

pub class LuneHelperInfo {
   pub let mut useNilAccess:bool;
   pub let mut useUnwrapExp:bool;
   pub let mut hasMappingClassDef:bool;
   pub let mut useLoad:bool;
   pub let mut useUnpack:bool;
   pub let mut useAlge:bool;
   pub let mut useSet:bool;
}

pub class ModuleInfo extend (ModuleInfoIF) {
   pri let fullName:str{ pub };
   pri let localTypeInfo2importIdMap:Map<&TypeInfo,int> { pub };
   pri let mut importId2localTypeInfoMap:Map<int,&TypeInfo> { pub& };
   pri let assignName:str{ pub };
   pri let moduleId:&frontInterface.ModuleId {pub};

   pub fn __init( fullName:str, assignName:str, idMap:&Map<&TypeInfo,int>,
                  moduleId:&frontInterface.ModuleId )
   {
      self.moduleId = moduleId;
      self.fullName = fullName;
      self.assignName = assignName;
      self.localTypeInfo2importIdMap = idMap;
      self.importId2localTypeInfoMap = {};
      foreach importId, typeInfo in idMap {
         self.importId2localTypeInfoMap[ importId ] = typeInfo;
      }
   }

   pub fn get_modulePath(): str {
      return self.fullName;
   }

   pub fn assign( assignName: str ): ModuleInfo {
      return new ModuleInfo(
         self.fullName, assignName, self.localTypeInfo2importIdMap, self.moduleId );
   }
}

pub fn TypeInfo.getFullName( importInfo:&Map<&TypeInfo,&ModuleInfoIF>, localFlag:bool! ) : str {
   return self.getParentFullName( importInfo, localFlag ) .. self.$rawTxt;
}


pub class ProcessInfo {
   let mut idProvier:IdProvider {pub};
   let mut idProvierExt:IdProvider {pub};
   let mut typeInfo2ModifierMap:Map<&TypeInfo,&TypeInfo> {pub};
   let mut typeInfo2DDDMap:Map<&TypeInfo,&DDDTypeInfo> {pub};
}

pub class MacroValInfo {
   pub let val: stem!;
   pub let typeInfo: TypeInfo;
}

pub class MacroArgInfo {
   pri let name:str {pub};
   pri let typeInfo: &TypeInfo {pub};
}

pub abstract class MacroInfo {
   pub let func: form;
   pub let symbol2MacroValInfoMap: Map<str,MacroValInfo>;
   pub abstract fn getArgList():&List<&MacroArgInfo>;
   pub abstract fn getTokenList():&List<&Parser.Token>;
   pub abstract fn get_name():str;
}

_declNodeClass( "Root", Node, false, false, false,
                [ { "children": "List<&Node>" },
                  { "useModuleMacroSet": "&Set<&TypeInfo>" },
                  { "moduleId": "&frontInterface.ModuleId" },
                  { "processInfo": "ProcessInfo" },
                  { "moduleTypeInfo": "&TypeInfo" },
                  { "provideNode": "&ProvideNode!" },
                  { "luneHelperInfo": "LuneHelperInfo" },
                  { "nodeManager": "NodeManager" },
                  { "importModule2moduleInfo": "Map<&TypeInfo,ModuleInfo>" },
                  { "typeId2MacroInfo": "Map<int,&MacroInfo>" },
                  { "typeId2ClassMap": "Map<int,&NamespaceInfo>" } ]
);

pub fn RootNode.set_provide( node: ProvideNode ) mut {
   self.provideNode = node;
}

_declNodeClass( "RefType", Node, false, false, false,
                [ { "name": "&Node" },
                  { "refFlag": "bool" },
                  { "mutFlag": "bool" },
                  { "array": "str" } ]
);

pub enum BlockKind {
   If,
   Elseif,
   Else,
   While,
   Switch,
   Match,
   Repeat,
   For,
   Apply,
   Foreach,
   Macro,
   Func,
   Default,
   Block,
   Macro,
   LetUnwrap,
   IfUnwrap,
   When,
}

_declNodeClass( "Block", Node, false, false, true,
                [ { "blockKind": "BlockKind" },
                  { "stmtList": "List<&Node>" } ]
);


macro _setBreakKind(work:sym, kind:sym, returnNoneStat:bool, checkMode:sym ) {
   {
      let mut noneStat:stat[] = [];
      if returnNoneStat {
         noneStat.insert( `{ return .None } );
      }
   }

   if ,,checkMode == .IgnoreFlowReturn {
      if ,, work == .Return {
         return .Return;
      }
      if ,, work == .NeverRet {
         return .NeverRet;
      }
   }
   else {
      switch ,,work {
         case .None {
            if ,,checkMode == .Normal or ,,checkMode == .Return {
               ,,noneStat;
            }
         }
         default {
            if ,,kind == .None or ,,kind > work {
               kind = work;               
            }
         }
      }
   }
}


pub override fn BlockNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in self.stmtList {
         let work = stmt.getBreakKind( checkMode );
         _setBreakKind(work, kind, false, checkMode );
      }
      return kind;
   }
   else {
      if #self.stmtList > 0 {
         let node = self.stmtList[ #self.stmtList ];
         return node.getBreakKind( checkMode );
      }
   }
   return .None;
}

pub enum IfKind {
   If,
   ElseIf,
   Else,
}

pub class IfStmtInfo {
   pri let kind: IfKind { pub };
   pri let exp: Node { pub };
   pri let block: BlockNode { pub };
}
_declNodeClass( "If", Node, false, false, true,
                [{ "stmtList": "IfStmtInfo[]" } ]
);


pub override fn IfNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut hasElseFlag = false;
   let mut kind = BreakKind.None;
   foreach stmtInfo in self.stmtList {
      let work = stmtInfo.$block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      if stmtInfo.$kind == .Else {
         hasElseFlag = true;
      }
   }
   if hasElseFlag or ( checkMode ~= .Normal and checkMode ~= .Return ) {
      return kind;
   }
   
   return .None;
}


_declNodeClass( "ExpList", Node, nil, nil, false,
                [ { "expList": "List<&Node>" },
                  { "followOn": "bool" } ]
);
pub override fn ExpListNode.canBeLeft():bool {
   foreach expNode in self.$expList {
      if not expNode.canBeLeft() {
         return false;
      }
   }
   return true;
}
pub override fn ExpListNode.canBeRight():bool {
   foreach expNode in self.$expList {
      if not expNode.canBeRight() {
         return false;
      }
   }
   return true;
}


pub class CaseInfo {
   pri let expList: ExpListNode { pub };
   pri let block: BlockNode { pub };
}
_declNodeClass( "Switch", Node, false, false, true,
                [ { "exp": "&Node" },
                  { "caseList": "CaseInfo[]" },
                  { "default": "&BlockNode!" } ]
);

pub override fn SwitchNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   let mut kind = BreakKind.None;
   foreach caseInfo in self.caseList {
      let work = caseInfo.$block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
   }
   if! let block = self.default {
      let work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }

   return .None;
}


macro _declLoopGetBreakKind( node:sym, blockMem:sym ) {

   pub override fn ,,node.getBreakKind( checkMode:CheckBreakMode ): BreakKind
   {  
      let mut kind = BreakKind.None;
      if checkMode ~= .Normal and checkMode ~= .Return {
         return self. ,,blockMem .getBreakKind( checkMode );
      }
      return .None;
   }  
}

_declNodeClass( "While", Node, false, false, true,
                [ { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declNodeClass( "Repeat", Node, false, false, true,
                [ { "block": "&BlockNode" },
                  { "exp": "&Node" } ]
);

_declLoopGetBreakKind( RepeatNode, block );

_declNodeClass( "For", Node, false, false, true,
                [ { "block": "&BlockNode" },
                  { "val": "&Parser.Token" },
                  { "init": "&Node" },
                  { "to": "&Node" },
                  { "delta": "&Node!" }] 
);

_declLoopGetBreakKind( ForNode, block );


_declNodeClass( "Apply", Node, false, false, true,
                [ { "varList": "List<&Parser.Token>" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declLoopGetBreakKind( ApplyNode, block );


_declNodeClass( "Foreach", Node, false, false, true,
                [ { "val": "&Parser.Token!" },
                  { "key": "&Parser.Token!" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" } ]
);

_declLoopGetBreakKind( ForeachNode, block );


_declNodeClass( "Forsort", Node, false, false, true,
                [ { "val": "&Parser.Token" },
                  { "key": "&Parser.Token!" },
                  { "exp": "&Node" },
                  { "block": "&BlockNode" },
                  { "sort": "bool" } ]
);

_declLoopGetBreakKind( ForsortNode, block );


_declNodeClass( "Return", Node, false, false, true,
                [ { "expList": "&ExpListNode!" } ]
);
pub override fn ReturnNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   return .Return;
}

_declNodeClass( "Break", Node, false, false, true, [] );

pub override fn BreakNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   return .Break;
}

_declNodeClass( "Provide", Node, false, false, true,
                [ { "symbol": "&SymbolInfo" } ]
);

_declNodeClass( "ExpNew", Node, false, true, true,
                [ { "symbol": "&Node" },
                  { "argList": "&ExpListNode!" } ]
);

_declNodeClass( "ExpUnwrap", Node, false, true, false,
                [ { "exp": "&Node" },
                  { "default": "&Node!" } ]
);

_declNodeClass( "ExpRef", Node, nil, nil, false,
                [ { "token": "&Parser.Token" },
                  { "symbolInfo": "&AccessSymbolInfo" } ]
);

pub override fn ExpRefNode.canBeLeft():bool {
   return self.$symbolInfo.$canBeLeft;
}

pub override fn ExpRefNode.canBeRight():bool {
   return self.$symbolInfo.$canBeRight;
}

_declNodeClass( "ExpOp2", Node, false, true, nil,
                [ { "op": "&Parser.Token" },
                  { "exp1": "&Node" },
                  { "exp2": "&Node" } ]
);

pub override fn ExpOp2Node.canBeStatement():bool {
   return self.$op.txt == '=';
}


_declNodeClass( "UnwrapSet", Node, false, false, true,
                [ { "dstExpList": "&ExpListNode" },
                  { "srcExpList": "&ExpListNode" },
                  { "unwrapBlock": "&BlockNode!" } ]              
);

_declNodeClass( "IfUnwrap", Node, false, false, true,
                [ { "varNameList": "List<str>" },
                  { "expNodeList": "List<&Node>" },
                  { "block": "&BlockNode" },
                  { "nilBlock": "&BlockNode!" } ]
);

pub override fn IfUnwrapNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut kind = self.block.getBreakKind( checkMode );
   let mut work = kind;
   _setBreakKind( work, kind, true, checkMode );
   if! let block = self.nilBlock {
      work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }
   return .None;
}


_declNodeClass( "When", Node, false, false, true,
                [ { "varNameList": "List<&str>" },
                  { "expNodeList": "List<&Node>" },
                  { "block": "&BlockNode" },
                  { "elseBlock": "&BlockNode!" } ]
);

pub override fn WhenNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   let mut kind = self.block.getBreakKind( checkMode );
   let mut work = kind;
   _setBreakKind( work, kind, true, checkMode );
   if! let block = self.elseBlock {
      work = block.getBreakKind( checkMode );
      _setBreakKind( work, kind, true, checkMode );
      return kind;
   }
   return .None;
}


_declNodeClass( "ExpCast", Node, false, true, false,
                [ { "exp": "&Node" } ]
);

pub enum MacroMode {
   None,
   Expand,
   Analyze,
}

_declNodeClass( "ExpOp1", Node, false, true, false,
                [ { "op": "&Parser.Token" },
                  { "macroMode": "MacroMode" },
                  { "exp": "&Node" } ]
);

_declNodeClass( "ExpRefItem", Node, nil, true, false,
                [ { "val": "&Node" },
                  { "nilAccess": "bool" },
                  { "symbol": "str!" },
                  { "index": "&Node!" } ]
);
pub override fn ExpRefItemNode.canBeLeft(): bool {
   if self.val.$expType == builtinTypeStem {
      return false;
   }
   //return self.$expType.$mutable;
   return self.$val.$expType.$mutable and not self.nilAccess;
}

_declNodeClass( "ExpCall", Node, false, nil, true,
                [ { "func": "&Node" },
                  { "errorFunc": "bool" },
                  { "nilAccess": "bool" },
                  { "argList": "&ExpListNode!" } ]
);
pub override fn ExpCallNode.canBeRight():bool {
   let expType = self.$expType;
   if expType.equals( builtinTypeNone## ) or
      expType.equals( builtinTypeNeverRet## )
   {
      return false;
   }
   return true;
}


pub override fn ExpCallNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   if self.errorFunc {
      return .NeverRet;
   }
   return .None;
}


_declNodeClass( "ExpDDD", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

_declNodeClass( "ExpParen", Node, false, true, false,
                [ { "exp": "&Node" } ]
);

_declNodeClass( "ExpMacroExp", Node, false, false, true,
                [ { "stmtList": "List<&Node>" } ]
);

pub override fn ExpMacroExpNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind {
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in self.stmtList {
         let work = stmt.getBreakKind( checkMode );
         _setBreakKind(work, kind, false, checkMode );
      }
      return kind;
   }
   else {
      if #self.stmtList > 0 {
         return self.stmtList[ #self.stmtList ].getBreakKind( checkMode );
      }
   }
   return .None;
}


_declNodeClass( "ExpMacroStat", Node, false, true, false,
                [ { "expStrList": "List<&Node>" } ]
);

_declNodeClass( "StmtExp", Node, false, true, nil,
                [ { "exp": "&Node" } ]
);
pub override fn StmtExpNode.canBeStatement():bool {
   return self.$exp.canBeStatement();
}

pub override fn StmtExpNode.getBreakKind( checkMode:CheckBreakMode ):BreakKind {
   return self.$exp.getBreakKind( checkMode );
}

_declNodeClass( "ExpOmitEnum", Node, true, true, false,
                [ { "valToken": "&Parser.Token" },
                  { "valInfo": "&EnumValInfo" },
                  { "enumTypeInfo": "&EnumTypeInfo" }]
);

_declNodeClass( "RefField", Node, nil, nil, false,
                [ { "field": "&Parser.Token" },
                  //{ "overrideCanBeLeft": "bool!" },
                  { "symbolInfo": "&AccessSymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "&Node" }] 
);
pub override fn RefFieldNode.canBeLeft():bool {
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return false;
}
pub override fn RefFieldNode.canBeRight():bool {
   if! self.$symbolInfo {
      return _exp.$canBeRight;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return true;
}

_declNodeClass( "GetField", Node, nil, true, false,
                [ { "field": "&Parser.Token" },
                  //{ "overrideCanBeLeft": "bool!" },
                  { "symbolInfo": "&AccessSymbolInfo!" },
                  { "nilAccess": "bool" },
                  { "prefix": "&Node" },
                  { "getterTypeInfo": "&TypeInfo" } ]               
);
pub override fn GetFieldNode.canBeLeft():bool {
   if! self.$symbolInfo {
      return _exp.$canBeLeft;
   }
   // if! self.overrideCanBeLeft {
   //    return _exp;
   // }
   return false;
}


_declNodeClass( "Alias", Node, false, false, true,
                [ {"newName": "str" },
                  {"srcNode": "&Node" },
                  {"typeInfo": "&TypeInfo" } ] );

pub class VarInfo {
   pri let name: &Parser.Token { pub };
   // 宣言している型。 宣言していない場合は nil
   pri let refType: RefTypeNode! { pub };
   // 実際の型。
   pri let actualType: TypeInfo { pub };
}

pub enum DeclVarMode {
   Let,
   Sync,
   Unwrap,
}

_declNodeClass( "DeclVar", Node, false, false, true,
                [ { "mode": "DeclVarMode" },
                  { "accessMode": "AccessMode" },
                  { "staticFlag": "bool" },
                  { "varList": "List<&VarInfo>" },
                  { "expList": "&ExpListNode!" },
                  { "symbolInfoList": "List<&SymbolInfo>"},
                  { "typeInfoList": "List<&TypeInfo>" },
                  { "unwrapFlag": "bool" },
                  { "unwrapBlock": "&BlockNode!" },
                  { "thenBlock": "&BlockNode!" },
                  { "syncVarList": "List<&VarInfo>" },
                  { "syncBlock": "&BlockNode!" } ]
);

pub override fn DeclVarNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   if checkMode ~= .Normal and checkMode ~= .Return {
      if! let block = self.unwrapBlock {
         let kind = block.getBreakKind( checkMode );
         switch kind {
            case .Return, .NeverRet {
               return kind;
            }
         }
      }
      if! let block = self.thenBlock {
         let kind = block.getBreakKind( checkMode );
         switch kind {
            case .Return, .NeverRet {
               return kind;
            }
         }
      }
      if! let block = self.syncBlock {
         let kind = block.getBreakKind( checkMode );
         switch kind {
            case .Return, .NeverRet {
               return kind;
            }
         }
      }
      return .None;
   }
   else {
      let mut kind = BreakKind.None;
      let mut work = BreakKind.None;
      if! let block = self.unwrapBlock {
         work = block.getBreakKind( checkMode );
         _setBreakKind( work, kind, true, checkMode );
         if! let thenBlock = self.thenBlock {
            work = thenBlock.getBreakKind( checkMode );
            _setBreakKind( work, kind, true, checkMode );
            if! let syncBlock = self.syncBlock {
               work = syncBlock.getBreakKind( checkMode );
               _setBreakKind( work, kind, true, checkMode );
               return kind;
            }     
         }  
      }
      return .None;
   }
}



pub class DeclFuncInfo {
   pri let classTypeInfo: &TypeInfo! { pub };
   pri let name: &Parser.Token! { pub };
   pri let argList: List<&Node> { pub };
   pri let staticFlag: bool { pub };
   pri let accessMode: AccessMode { pub };
   pri let body: &BlockNode! { pub };
   pri let retTypeInfoList: List<&TypeInfo> { pub };
   pri let has__func__Symbol:bool { pub };
}
_declNodeClass( "DeclFunc", Node, false, true, true,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclMethod", Node, false, false, true,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclConstr", Node, false, false, true,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "DeclDestr", Node, false, false, true,
                [ { "declInfo": "DeclFuncInfo" } ]
);

_declNodeClass( "ExpCallSuper", Node, false, false, true,
                [ { "superType": "&TypeInfo" },
                  { "methodType": "&TypeInfo" },
                  { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "DeclMember", Node, false, false, true,
                [ { "name": "&Parser.Token" },
                  { "refType": "&RefTypeNode" },
                  { "symbolInfo": "&SymbolInfo" },
                  { "staticFlag": "bool" },
                  { "accessMode": "AccessMode" },
                  { "getterMutable": "bool" },
                  { "getterMode": "AccessMode" },
                  { "setterMode": "AccessMode" } ]
);

_declNodeClass( "DeclArg", Node, false, false, false,
                [ { "name": "&Parser.Token" },
                  { "argType": "&RefTypeNode" } ]
);

_declNodeClass( "DeclArgDDD", Node, false, false, false, [] );

pub class AdvertiseInfo {
   pri let mut member: &DeclMemberNode { pub };
   pri let prefix: str {pub};
};
_declNodeClass( "DeclClass", Node, false, false, true,
                [ { "accessMode": "AccessMode" },
                  { "name": "&Parser.Token" },
                  { "gluePrefix": "str!" },
                  { "declStmtList": "List<&Node>" },
                  { "fieldList": "List<&Node>" },
                  { "moduleName": "&Parser.Token!" },
                  { "memberList": "List<&DeclMemberNode>" },
                  { "scope": "&Scope" },
                  { "initStmtList": "List<&Node>" },
                  { "advertiseList": "AdvertiseInfo[]" },
                  { "trustList": "List<&TypeInfo>" },
                  { "outerMethodSet": "Set<str>" } ]
);

_declNodeClass( "DeclEnum", Node, false, false, true,
                [ { "accessMode": "AccessMode" },
                  { "name": "&Parser.Token" },
                  { "valueNameList": "List<&Parser.Token>" },
                  { "scope": "&Scope" } ]
);

_declNodeClass( "DeclAlge", Node, false, false, true,
                [ { "accessMode": "AccessMode" },
                  { "algeType": "&AlgeTypeInfo"},
                  { "scope": "&Scope" } ]
);


_declNodeClass( "NewAlgeVal", Node, false, true, false,
                [ { "name": "&Parser.Token" },
                  { "prefix": "&Node!" },
                  { "algeTypeInfo": "&AlgeTypeInfo" },
                  { "valInfo": "&AlgeValInfo" },
                  { "paramList": "&List<&Node>" } ]
);

pub class MatchCase {
   pri let valInfo: &AlgeValInfo {pub};
   pri let valParamNameList: &List<str> {pub};
   pri let block: &BlockNode {pub};
}

_declNodeClass( "Match", Node, false, false, true,
                [ { "val": "&Node" },
                  { "algeTypeInfo": "&AlgeTypeInfo" },
                  { "caseList": "&List<&MatchCase>" },
                  { "defaultBlock": "&Node!" }
                ]              
);

_declNodeClass( "DeclMacro", Node, false, false, true,
                [ { "declInfo": "DeclMacroInfo" } ]
);

pub abstract class MacroEval {
   pub abstract fn evalFromCode( name:str, argNameList:&List<str>, code:str! ): form;
   pub abstract fn eval( macroNode: DeclMacroNode ): form;
}

_declNodeClass( "Abbr", Node, false, false, false,
                [ {} ]
);


_declNodeClass( "LiteralNil", Node, false, true, false, [] );

_declNodeClass( "LiteralChar", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralInt", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "int" } ]
);

_declNodeClass( "LiteralReal", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "num": "real" } ]
);

_declNodeClass( "LiteralArray", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "LiteralList", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

_declNodeClass( "LiteralSet", Node, false, true, false,
                [ { "expList": "&ExpListNode!" } ]
);

pub class PairItem {
   pri let key: Node { pub };
   pri let val: Node { pub };
}
_declNodeClass( "LiteralMap", Node, false, true, false,
                [ { "map": "Map<&Node,&Node>" },
                  { "pairList": "PairItem[]" } ]
);

_declNodeClass( "LiteralString", Node, false, true, false,
                [ { "token": "&Parser.Token" },
                  { "argList": "&List<&Node>" } ]
);

_declNodeClass( "LiteralBool", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

_declNodeClass( "LiteralSymbol", Node, false, true, false,
                [ { "token": "&Parser.Token" } ]
);

pub fn Node.getSymbolInfo(): List<&AccessSymbolInfo> {
   fn processExpNode( node: &Node ): List<&AccessSymbolInfo> {
      switch ( node.$kind ) {
         case NodeKind.$ExpRef {
            return [(node@@ExpRefNode).$symbolInfo];
         }
         case NodeKind.$RefField {
            let refFieldNode = node@@RefFieldNode;
            if! refFieldNode.$symbolInfo {
               return [_exp];
            }
            return [];
         }
         case NodeKind.$GetField {
            let getFieldNode = node@@GetFieldNode;
            if! getFieldNode.$symbolInfo {
               return [_exp];
            }
            return [];
         }
         case NodeKind.$ExpList {
            let expListNode = node@@ExpListNode;
            let mut list: List<&AccessSymbolInfo> = [];
            foreach expNode, index in expListNode.$expList {
               if index == #expListNode.$expList {
                  foreach symbolInfo in processExpNode( expNode ) {
                     list.insert( symbolInfo );
                  }
               }
               else {
                  foreach symbolInfo in processExpNode( expNode ) {
                     list.insert( symbolInfo );
                     break;
                  }
               }
            }
            return list;
         }
      }
      return [];
   }
   return processExpNode( self );
}


pub override fn WhileNode.getBreakKind( checkMode:CheckBreakMode ): BreakKind
{
   if checkMode ~= .Normal and checkMode ~= .Return {
      let mut kind = BreakKind.None;
      foreach stmt in self.block.$stmtList {
         let work = stmt.getBreakKind( checkMode );
         _setBreakKind(work, kind, false, checkMode );
      }
      if kind == .Break {
         return .None;
      }
      return kind;
   }
   else {
      if self.exp.$expType.$nilable {
         return .None;
      }
      if self.exp.$expType.equals( builtinTypeBool ## ) {
         if self.exp.$kind == NodeKind.$LiteralBool {
            let boolNode = self.exp@@LiteralBoolNode;
            if boolNode.$token.txt == "false" {
               return .None;
            }  
         }
         else {
            return .None;
         }        
      }
      // 条件式が次のもの以外は無条件ループ。
      //  - nilable でない
      //  - bool 型の式でない
      //  - false でもない
      

      // 無条件ループ用のフロー解析に変更する。
      let mut mode = CheckBreakMode.IgnoreFlow;
      // if checkMode == .Return {
      //    mode = .IgnoreFlowReturn;
      // }
      let mut kind = BreakKind.None;
      foreach stmt in self.block.$stmtList {
         let work = stmt.getBreakKind( mode );
         
         _setBreakKind(work, kind, false, mode );
      }
      if kind == .Break {
         return .None;
      }
      if kind == .Return {
         return .Return;
      }
      return .NeverRet;
   }
}


pub override fn LiteralNilNode.getLiteral(): stem![], List<&TypeInfo> {
   return [nil], [builtinTypeNil];
}

pub override fn LiteralCharNode.getLiteral(): stem![], List<&TypeInfo> {
   return [self.num], [builtinTypeChar];
}

pub override fn LiteralIntNode.getLiteral(): stem![], List<&TypeInfo> {
   return [self.num], [builtinTypeInt];
}

pub override fn LiteralRealNode.getLiteral(): stem![], List<&TypeInfo> {
   return [self.num], [builtinTypeReal];
}

pub override fn LiteralArrayNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut array:stem![] = [];
   if! self.expList {
      foreach val in _exp.get_expList() {
         let! txt = val.getLiteral()[1] {
            // nil は処理できない。。。
            return [], [];
         };
         array.insert( txt );
      } 
   }
   return [array], [self.get_expType()];
}

pub override fn LiteralListNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut list:stem![] = [];
   if! self.expList {
      foreach val in _exp.get_expList() {
         let! item = val.getLiteral()[1] {
            // nil は処理できない。。。
            return [], [];
         };
         list.insert( item );
      } 
   }
   return [list], [self.get_expType()];
}

pub override fn LiteralSetNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut list:stem![] = [];
   if! self.expList {
      foreach val in _exp.get_expList() {
         let! item = val.getLiteral()[1] {
            // nil は処理できない。。。
            return [], [];
         };
         list.insert( item );
      } 
   }
   return [list], [self.get_expType()];
}

pub override fn LiteralMapNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut map:Map<stem,stem!> = {};
   foreach val, key in self.map {
      map[ unwrap key.getLiteral()[1] ] = val.getLiteral()[1];
   }
   return [map], [self.get_expType()];
}

pub override fn LiteralStringNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut txt = self.token.txt;
   if string.find( txt, '^```' ##) {
      txt = txt.sub( 4, -4 );
   }
   else {
      txt = txt.sub( 2, -2 );
   }
   let argList = self.$argList;

   if #argList > 0 {
      let mut argTbl:stem![] = [];
      foreach argNode in argList {
         let arg = argNode.getLiteral();
         if #arg > 1 {
            let! argTxt = arg[1] {
               // nil は処理できない。。。
               return [], [];
            };
            argTbl.insert( argTxt );
         }
      }   
      return [ string.format( txt, argTbl.unpack() )], [builtinTypeString];
   }
   return [txt], [builtinTypeString];
}

pub override fn LiteralBoolNode.getLiteral(): stem![], List<&TypeInfo> {
   return [ self.token.txt == "true"], [builtinTypeBool];
}

pub override fn LiteralSymbolNode.getLiteral(): stem![], List<&TypeInfo> {
   return [[ self.token.txt ]], [ builtinTypeSymbol ];
}

pub override fn RefFieldNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut prefix = (unwrap self.prefix.getLiteral()[1])@@str[];
   if self.nilAccess {
      prefix.insert( "$." );
   }
   else {
      prefix.insert( "." );
   }
   prefix.insert( self.field.txt );
   return [ prefix ], [ builtinTypeSymbol ];
}

pub override fn ExpMacroStatNode.getLiteral(): stem![], List<&TypeInfo> {
   let mut txt = "";
   foreach token in self.expStrList {
      txt = "%s%s" (txt, token.getLiteral()[1]);
   }
   return [txt ], [ self.get_expType() ];
}

pub override fn ExpRefNode.getLiteral(): stem![], List<&TypeInfo> {
   let typeInfo = self.symbolInfo.$typeInfo;
   if typeInfo.$kind ~= .Enum {
      return [], [];
   }
   let enumTypeInfo = typeInfo@@EnumTypeInfo;

   let val = unwrap enumTypeInfo.getEnumValInfo( self.symbolInfo.$name );
   return [ val.$name ], [ enumTypeInfo ];
}

pub override fn ExpOmitEnumNode.getLiteral(): stem![], List<&TypeInfo> {
   let enumTypeInfo = self.enumTypeInfo;

   let val = self.valInfo;
   return [ val.$name ], [ enumTypeInfo ];
}

pub override fn ExpOp2Node.getLiteral(): stem![], List<&TypeInfo> {

   fn getValType( valList:&List<stem!>, typeList:&List<&TypeInfo> ): &stem, &TypeInfo {
      let typeInfo = typeList[ 1 ].$srcTypeInfo;
      let val = unwrap valList[ 1 ];
      if typeInfo.$kind ~= .Enum {
         return val, typeInfo;
      }
      let enumTypeInfo = typeInfo@@EnumTypeInfo;
      let valInfo = unwrap enumTypeInfo.getEnumValInfo( val@@str );
      return valInfo.$val, enumTypeInfo.$valTypeInfo;
   }
   
   let val1List, mut type1List = self.$exp1.getLiteral();
   let val2List, mut type2List = self.$exp2.getLiteral();

   if #val1List ~= 1 or #type1List ~= 1 or #val2List ~= 1 or #type2List ~= 1 {
      return [], [];
   }

   let val1, type1 = getValType( val1List, type1List );
   let val2, type2 = getValType( val2List, type2List );
   

   if ( type1 == builtinTypeInt or type1 == builtinTypeReal ) and
      ( type2 == builtinTypeInt or type2 == builtinTypeReal )
   {
      let mut retType = builtinTypeInt;
      if type1 == builtinTypeReal or type2 == builtinTypeReal {
         retType = builtinTypeReal;
      }
      let mut int1, mut int2 = 0, 0;
      let mut real1, mut real2 = 0.0, 0.0;
      if type1 == builtinTypeInt {
         int1 = val1@@int;
         real1 = int1@@real;
      }
      else {
         real1 = val1@@real;
      }
      if type2 == builtinTypeInt {
         int2 = val2@@int;
         real2 = int2@@real;
      }
      else {
         real2 = val2@@real;
      }

      switch ( self.op.txt ) {
         case "+" {
            if retType == builtinTypeInt {
               return [ int1 + int2 ], [ retType ];
            }
            return [ real1 + real2 ], [ retType ];
         }
         case "-" {
            if retType == builtinTypeInt {
               return [ int1 - int2 ], [ retType ];
            }
            return [ real1 - real2 ], [ retType ];
         }
         case "*" {
            if retType == builtinTypeInt {
               return [ int1 * int2 ], [ retType ];
            }
            return [ real1 * real2 ], [ retType ];
         }
         case "/" {
            if retType == builtinTypeInt {
               return [ int1 / int2 ], [ retType ];
            }
            return [ real1 / real2 ], [ retType ];
         }
      }
   }
   elseif type1 == builtinTypeString and type2 == builtinTypeString {
      if self.op.txt == ".." {
         return [ val1@@str .. val2@@str ], [ builtinTypeString ];
      }
   }

   return [],[];
}

pub class DefMacroInfo extend MacroInfo {
   pub let declInfo: DeclMacroInfo;
   pri let mut argList:List<&MacroArgInfo>;

   pub override fn get_name():str {
      return self.declInfo.$name.txt;
   }
   
   pub override fn getArgList():&List<&MacroArgInfo> {
      return self.argList;
   }
   pub override fn getTokenList():&List<&Parser.Token>{
      return self.declInfo.$tokenList;
   }
   
   pub fn __init( func: form, declInfo: DeclMacroInfo, 
                  symbol2MacroValInfoMap: Map<str,MacroValInfo> )
   {
      super( func, symbol2MacroValInfoMap );
      self.declInfo = declInfo;
      self.argList = [];
      foreach argNode in declInfo.$argList {
         if argNode.get_kind() == NodeKind.$DeclArg {
            let argType = argNode.$argType.$expType;
            let argName = argNode.$name.txt;
            self.argList.insert( new MacroArgInfo( argName, argType ) );
         }
      }
   }
}


let mut processInfoQueue:List<ProcessInfo> = [];

pub enum IdType {
   Base,
   Ext,
}
pub fn switchIdProvier( idType:IdType ) {
   if idType == .Base {
      idProv = idProvBase;
   }
   else {
      idProv = idProvExt;
   }  
}

pub fn pushProcessInfo( processInfo:ProcessInfo! ): ProcessInfo {

   if #processInfoQueue == 0 {
      if idProv.$id >= userStartId {
         Util.err( "builtinId is over" );
      }
   }

   
   processInfoQueue.insert(
      new ProcessInfo( idProvBase, idProvExt, typeInfo2ModifierMap, typeInfo2DDDMap ) );   
   when! processInfo {
      idProvBase = processInfo.$idProvier;
      idProvExt = processInfo.$idProvierExt;
      typeInfo2ModifierMap = processInfo.$typeInfo2ModifierMap;
      typeInfo2DDDMap = processInfo.$typeInfo2DDDMap;
   }
   else {
      idProvBase = new IdProvider( userStartId, extStartId );
      idProvExt = new IdProvider( extStartId, extMaxId );
      typeInfo2ModifierMap = {};
      typeInfo2DDDMap = {};
   }
   idProv = idProvBase;
   return new ProcessInfo( idProvBase, idProvExt, typeInfo2ModifierMap, typeInfo2DDDMap );       
}

pub fn popProcessInfo() {
   let mut info = processInfoQueue[ #processInfoQueue ];
   idProvBase = info.$idProvier;
   idProvExt = info.$idProvierExt;
   idProv = idProvBase;
   typeInfo2ModifierMap = info.$typeInfo2ModifierMap;
   processInfoQueue.remove(##);
}

pub enum BitOpKind {
   And,
   Or,
   Xor,
   LShift,
   RShift,
}

pub let bitBinOpMap = {
   "&": BitOpKind.And,
   "|": BitOpKind.Or,
   "~": BitOpKind.Xor,
   "|>>": BitOpKind.RShift,
   "|<<": BitOpKind.LShift,
};
