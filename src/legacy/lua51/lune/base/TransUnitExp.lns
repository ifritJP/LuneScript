/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

/**
一つの値を持つ expression を期待する。

多値の expression の場合、 ExpMultiTo1 ノードでラッピングする。
*/
fn TransUnit.analyzeExpOne(
   allowNoneType:bool, skipOp2Flag: bool, opLevel: int!,        
   expectType:&Ast.TypeInfo! ) mut : Nodes.Node
{
   let mut exp = self.analyzeExp( allowNoneType, skipOp2Flag, opLevel, expectType );
   if #exp.$expTypeList == 1 {
      return exp;
   }
   return Nodes.ExpMultiTo1Node.create(
      self.nodeManager, exp.$pos, exp.$macroArgFlag, [ exp.$expType ], exp );
}

/**
ExpNode のリスト expList を、 expTypeList 


*/
fn TransUnit.createExpList(
   pos:&Parser.Position,
   expTypeList:List<&Ast.TypeInfo>, expList:&List<&Nodes.Node>,
   followOn:bool, abbrNode:&Nodes.AbbrNode! ) mut: Nodes.ExpListNode
{
   let mut workList:List<&Nodes.Node> = [];
   let mut mRetExp:Nodes.MRetExp! = nil;
   if #expList > 0 {
      foreach exp, index in expList {
         if Nodes.hasMultiValNode( exp ) {
            // 複数の結果を持つ場合
            if index ~= #expList {
               // 最終ノード以外
               workList.insert(
                  Nodes.ExpMultiTo1Node.create(
                     self.nodeManager, exp.$pos,
                     exp.$macroArgFlag, [ exp.$expType ], exp ) );
            }
            else {
               workList.insert( exp );
               if Nodes.hasMultiValNode( exp ) {
                  // 最終ノードが複数の値を持つ場合は、その複数の型を追加する。
                  mRetExp = new Nodes.MRetExp( exp, index );
                  foreach expType, listIndex in exp.$expTypeList {
                     if listIndex ~= 1 {
                        expTypeList.insert( expType );
                     }
                  }
                  // 多値返却の場合、 ExpAccessMRet を追加する。
                  foreach retType, retIndex in exp.$expTypeList {
                     if retIndex ~= 1 {
                        workList.insert( 
                           Nodes.ExpAccessMRetNode.create(
                              self.nodeManager, exp.$pos,
                              exp.$macroArgFlag, [ retType ], exp, retIndex ) );
                     }
                  }
               }
            }
         }
         else {
            workList.insert( exp );
         }
      }
   }

   // if not allowNoneType {
   //    foreach expType, expIndex in expTypeList {
   //       if expType == Ast.builtinTypeNone {
   //          self.addErrMess( unwrap pos default new Parser.Position( 0, 0 ),
   //                           "The type of exp(%d) is None!!" (expIndex) );
   //       }
   //    }
   // }

   // when! abbrNode {
   //    expList.insert( abbrNode );
   // }

   when! abbrNode {
      workList.insert( abbrNode );
   }

   return Nodes.ExpListNode.create(
      self.nodeManager, pos, self.macroCtrl.isInAnalyzeArgMode(),
      expTypeList, workList, mRetExp, followOn );
}

/**
式のリスト exp, exp, exp ... を解析する。

@param allowNoneType true の場合、exp の評価結果が TypeInfoNone となるようなケースを許可する
@param skipOp2Flag true の場合、2項演算の解析は行なわない。
@param expNode 式のリストの先頭に加える式。 nil の場合は、リストに追加しない。
@param expectTypeList。 各式に期待する型。
  期待する型がない場合は、リストの要素に TypeInfoNone を指定する。
@param contExpect true の場合、 解析する式が、 expectTypeList の要素数を越えた時に、
    expectTypeList の最終要素の型を使用する。

*/
fn TransUnit.analyzeExpList(
   allowNoneType:bool, skipOp2Flag: bool, expNode: &Nodes.Node!,
   expectTypeList: &List<&Ast.TypeInfo>!, contExpect:bool! ) mut: Nodes.ExpListNode
{
   let mut expList:List<&Nodes.Node> = [];
   let mut pos:&Parser.Position! = nil;
   let mut expTypeList:List<&Ast.TypeInfo> = [];
   when! expNode {
      pos = expNode.$pos;
      expList.insert( expNode );
      expTypeList.insert( expNode.$expType );
   }

   let mut index = 1;
   let mut abbrNode:&Nodes.AbbrNode! = nil;
   let mut mRetExp:Nodes.MRetExp! = nil;
   let mut followOn = false;
   repeat {
      let mut expectType:&Ast.TypeInfo! = nil;
      when! expectTypeList {
         if #expectTypeList > 0 {
            let mut checkIndex = index;
            if index > #expectTypeList and contExpect {
               checkIndex = #expectTypeList;
            }
            if checkIndex <= #expectTypeList and
               expectTypeList[ checkIndex ] ~= Ast.builtinTypeNone
            {           
               expectType = expectTypeList[ checkIndex ];
            }
         }
      }

      let mut exp;
      
      if self.macroCtrl.$macroMode == .AnalyzeArg and expectType == Ast.builtinTypeExp {
         self.macroCtrl.switchMacroMode();
         exp = self.analyzeExp( allowNoneType, skipOp2Flag, 0, expectType );
         self.macroCtrl.restoreMacroMode();
      }
      else {
         exp = self.analyzeExp( allowNoneType, skipOp2Flag, 0, expectType );
      }

      
      if not allowNoneType and not exp.canBeRight() {
         self.addErrMess(
            exp.$pos,
            "This arg can't be r-value. -- %s" ( Nodes.getNodeKindName( exp.$kind) ) );
      }
      if not pos {
         pos = exp.$pos;
      }
      if expectType == Ast.builtinTypeExp {
         exp = Nodes.ExpMacroArgExpNode.create(
            self.nodeManager, exp.$pos,
            self.macroCtrl.isInAnalyzeArgMode(), exp.$expTypeList,
            Macro.nodeToCodeTxt( exp, self.moduleType ) );
      }
      
      expList.insert( exp );
      expTypeList.insert( exp.$expType );
      let mut token = self.getToken( true );

      if token.txt == "**" {
         //if #exp.$expTypeList <= 1 {
         if not Nodes.hasMultiValNode( exp ) {
            self.addErrMess(
               exp.$pos,
               "This arg(%d) doesn't have multiple value. It must not use '**'" (index) );
         }
         followOn = true;
         
         token = self.getToken( true );
      }
      
      if token.txt == "##" {
         if exp.$expType.$kind == .DDD {
            self.addErrMess( token.pos, "'##' can't use with '...'" );
         }
         abbrNode = Nodes.AbbrNode.create(
            self.nodeManager, token.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeAbbr ] );
                                         
         self.getToken(##);
         break;
      }

      index = index + 1;
      
      
   } token.txt ~= ",";

   let mut expListNode = self.createExpList(
      unwrap pos default new Parser.Position( 0, 0 ),
      expTypeList, expList, followOn, abbrNode );

   if not allowNoneType {
      foreach expType, expIndex in expTypeList {
         if expType == Ast.builtinTypeNone {
            self.addErrMess( unwrap pos default new Parser.Position( 0, 0 ),
                             "The type of exp(%d) is None!!" (expIndex) );
         }
      }
   }

   self.pushback();

   // return Nodes.ExpListNode.create(
   //    self.nodeManager, unwrap pos default new Parser.Position( 0, 0 ),
   //    expTypeList, expList, mRetExp, followOn );
   return expListNode;
}

fn TransUnit.analyzeListConst( token: &Parser.Token ) mut : Nodes.Node {
   let nextToken = self.getToken(##);
   let mut expList:Nodes.ExpListNode! = nil;
   let mut itemCommonType = Ast.CommonType.Normal( Ast.builtinTypeNone );

   if nextToken.txt ~= "]" {
      self.pushback();
      expList = self.analyzeExpList( false, false ## );
      self.checkNextToken( "]" );
      let nodeList: List<&Nodes.Node> = (unwrap expList).$expList;
      foreach exp in nodeList {
         itemCommonType = Ast.TypeInfo.getCommonTypeCombo(
            itemCommonType, Ast.CommonType.Normal( exp.$expType ),
            Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
      }
   }

   let mut itemTypeInfo;
   match itemCommonType {
      case .Normal( info ) {
         itemTypeInfo = info;
      }
      case .Combine( info ) {
         itemTypeInfo = info.$typeInfo;
      }
   }

   if itemTypeInfo.$kind == .DDD {
      if #itemTypeInfo.$itemTypeInfoList > 0 {
         itemTypeInfo = itemTypeInfo.$itemTypeInfoList[ 1 ];
      }
      else {
         itemTypeInfo = Ast.builtinTypeStem_;
      }
   }
   let mut typeInfoList = [ Ast.builtinTypeNone ];
   if token.txt == '[' {
      typeInfoList = [ Ast.NormalTypeInfo.createList( .Local, self.getCurrentClass(),
                                                      [ itemTypeInfo ], .Mut ) ];
      return Nodes.LiteralListNode.create(
         self.nodeManager, token.pos,
         self.macroCtrl.isInAnalyzeArgMode(), typeInfoList, expList );
   }
   else {
      typeInfoList = [ Ast.NormalTypeInfo.createArray( .Local, self.getCurrentClass(),
                                                       [ itemTypeInfo ], .Mut ) ];
      return Nodes.LiteralArrayNode.create(
         self.nodeManager, token.pos,
         self.macroCtrl.isInAnalyzeArgMode(), typeInfoList, expList );
   }
}

fn TransUnit.analyzeSetConst( token: &Parser.Token ) mut : Nodes.Node {

   self.helperInfo.useSet = true;

   
   let nextToken = self.getToken(##);
   let mut expList:Nodes.ExpListNode! = nil;
   let mut itemCommonType = Ast.CommonType.Normal( Ast.builtinTypeNone );
   if nextToken.txt ~= ")" {
      self.pushback();
      expList = self.analyzeExpList( false, false ## );
      self.checkNextToken( ")" );
      let nodeList: List<&Nodes.Node> = (unwrap expList).$expList;
      foreach exp in nodeList {
         let expType = exp.$expType;
         if expType.$nilable {
            self.addErrMess(
               exp.$pos,
               "'Set' object can't store nilable. -- %s" (expType.getTxt(##)));
         }
         else {
            itemCommonType = Ast.TypeInfo.getCommonTypeCombo(
               itemCommonType, Ast.CommonType.Normal( exp.$expType ),
               Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
         }
      }
   }

   let itemTypeInfo;
   match itemCommonType {
      case .Normal( info ) {
         itemTypeInfo = info;
      }
      case .Combine( info ) {
         itemTypeInfo = info.$typeInfo;
      }
   }
   
   let mut typeInfoList = [ Ast.builtinTypeNone ];
   typeInfoList = [ Ast.NormalTypeInfo.createSet( .Local, self.getCurrentClass(),
                                                  [ itemTypeInfo ], .Mut ) ];
   return Nodes.LiteralSetNode.create(
      self.nodeManager, token.pos,
      self.macroCtrl.isInAnalyzeArgMode(), typeInfoList, expList );
}

fn TransUnit.analyzeMapConst( token: &Parser.Token ) mut : Nodes.LiteralMapNode {
   let mut nextToken = self.getToken(##);
   let mut map:Map<&Nodes.Node,&Nodes.Node> = {};
   let mut pairList:Nodes.PairItem[] = [];
   let mut keyTypeInfo = Ast.builtinTypeNone;
   let mut valTypeInfo = Ast.builtinTypeNone;


   fn getMapKeyValType(
      pos: &Parser.Position, keyFlag: bool,
      mut typeInfo:&Ast.TypeInfo, mut expType:&Ast.TypeInfo ): &Ast.TypeInfo
   {
      if expType.$nilable {
         if keyFlag {
            self.addErrMess(
               pos, "map key can't set a nilable -- %s" (expType.getTxt(##)) );
         }
         if expType.equals( Ast.builtinTypeNil ## ) {
            return typeInfo;
         }
         expType = expType.$nonnilableType;
      }
      return Ast.TypeInfo.getCommonType(
         typeInfo, expType,
         Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false ) );
   }

   while true {
      if nextToken.txt == "}" {
         break;
      }
      self.pushback();

      let key = self.analyzeExpOne( false, false ## );
      keyTypeInfo = getMapKeyValType( key.$pos, true, keyTypeInfo, key.$expType );

      self.checkNextToken( ":" );

      let val = self.analyzeExpOne( false, false ## );
      valTypeInfo = getMapKeyValType( val.$pos, false, valTypeInfo, val.$expType );

      //pairList.insert( { "key": key, "val": val } );
      pairList.insert( new Nodes.PairItem( key, val ) );
      map[ key ] = val;
      nextToken = self.getToken(##);
      if nextToken.txt ~= "," {
         break;
      }
      nextToken = self.getToken(##);
   }

   let typeInfo = Ast.NormalTypeInfo.createMap(
      .Local, self.getCurrentClass(), keyTypeInfo, valTypeInfo, .Mut );

   self.checkToken( nextToken, "}" );
   // return self.createNode( nodeKindLiteralMap, token.pos,[ typeInfo ],
   //                      { "map": map, "pairList": pairList } );
   return Nodes.LiteralMapNode.create(
      self.nodeManager, token.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], map, pairList );
}

fn TransUnit.checkSymbolHavingValue(
   pos:&Parser.Position, symbolInfoList:&List<&Ast.SymbolInfo> ) mut
{
   foreach symbolInfo in symbolInfoList {
      if symbolInfo.$kind == .Var {
         if not symbolInfo.$hasValueFlag {
            self.addErrMess(
               pos, "this variable have no value. -- %s" (symbolInfo.$name) );
         }
      }
   }
}


fn TransUnit.analyzeExpRefItem(
   token: &Parser.Token, exp: &Nodes.Node, mut nilAccess:bool ) mut : Nodes.Node
{
   self.checkSymbolHavingValue( exp.$pos, exp.getSymbolInfo() );
      
   let mut expType = exp.$expType;

   if nilAccess {
      if not expType.$nilable {
         self.addWarnMess( token.pos, "This is not nilable. -- %s" (expType.getTxt(##)) );
         nilAccess = false;
      }
      else {
         expType = expType.$nonnilableType;
      }
   }

   let mut expectItemType:&Ast.TypeInfo! = nil;
   // 参照したアイテムの型情報
   let mut typeInfo = Ast.builtinTypeStem_;
   // 指定すべき index の型
   let mut indexTypeInfo = Ast.builtinTypeInt;
   if expType.$kind == .Map {
      let itemTypeList = expType.get_itemTypeInfoList();
      typeInfo = itemTypeList[2];
      indexTypeInfo = itemTypeList[1];
      expectItemType = itemTypeList[1];
      if not typeInfo.equals( Ast.builtinTypeStem_ ##) and not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
   }
   elseif expType.$kind == .Array or expType.$kind == .List
   {
      typeInfo = expType.get_itemTypeInfoList()[1];
   }
   elseif expType.equals( Ast.builtinTypeString ##) {
      typeInfo = Ast.builtinTypeInt;
   }
   elseif expType.equals( Ast.builtinTypeStem ##) {
      indexTypeInfo = Ast.builtinTypeStem;
      typeInfo = Ast.builtinTypeStem_;
   }
   else {
      self.addErrMess( exp.$pos,
                       "could not access with []. -- %s" (expType.getTxt(##)) );
   }

   if nilAccess {
      self.helperInfo.useNilAccess = true;
      if not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
   }

   if Ast.TypeInfo.isMut( typeInfo ) {
      if expType.$mutMode == .IMutRe {
         typeInfo = self.createModifier( typeInfo, .IMutRe );
      }
      // let list:&List<Val> の list[1] を &Val として扱う場合は、ここを有効にする。
      // ただ、 list[1] を &Val とするならば、 &List<&Val> とすべき。
      // &List<Val> ならば list[1] は Val であるべき。
      // elseif not Ast.TypeInfo.isMut( expType ) {
      //    typeInfo = self.createModifier( typeInfo, .IMut );
      // }
   }

   let indexExp = self.analyzeExpOne( false, false, nil, expectItemType );
   if not indexExp.canBeRight() {
      self.addErrMess( indexExp.$pos, "This node can't use index" );
   }
   if not indexTypeInfo.canEvalWith( indexExp.$expType, .SetOp, {} ) {
      self.addErrMess( indexExp.$pos,
                       "unmatch index type -- %s, %s"
                       ( indexTypeInfo.getTxt(##), indexExp.$expType.getTxt(##) ) );
   }
   
   self.checkNextToken( "]" );
   
   
   return Nodes.ExpRefItemNode.create(
      self.nodeManager, token.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ typeInfo ], exp, nilAccess, nil, indexExp );
}


/**
expNode から dstType に代入する際に、
暗黙型キャストが必要かどうかをチェックする。

必要な場合は、 変換を行なう ExpCastNode を返す。

*/
form checkImplicitCastCallback( dstType:&Ast.TypeInfo, expNode:&Nodes.Node ): &Nodes.Node!;


/**
expListNode の値を dstTypeList へ代入する際に、
暗黙キャストされるかどうかをチェックし、
暗黙キャストされる場合、そのノードを ExpCastNode に変換した
ノードリストを返す。

@param alt2typeMap generics 情報
@param dstTypeList 代入先型リスト
@param expListNode 代入元ノードリスト
@param callback 暗黙キャストをするかどうかの判定コールバック

*/
fn TransUnit.checkImplicitCast(
   alt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo>,
   dstTypeList:&List<&Ast.TypeInfo>, expListNode:&Nodes.ExpListNode,
   callback:checkImplicitCastCallback ) mut : Nodes.ExpListNode!
{
   let expNodeList = expListNode.$expList;
   let mut newExpNodeList:List<&Nodes.Node> = [];
   let mut expTypeList:List<&Ast.TypeInfo> = [];


   // 暗黙キャストを行なった場合 true にセットする
   let mut hasModNode = false;
   

   // 代入元の値から、代入先の型に暗黙キャストしているかどうか確認し、
   // 暗黙キャストしている場合は ExpCastNode を生成する。
   fn process( index:int, dstType:&Ast.TypeInfo,
               expNode:&Nodes.Node, mut workNode:&Nodes.Node ) : &Nodes.Node, bool
   {
      //if dstType.$kind == .Box and expNode.$expType.$kind ~= .Box {
      if! let repNode = callback( dstType, expNode ) {
         if not hasModNode {
            hasModNode = true;
         }
         workNode = repNode;
      }
      else {
         if dstType ~= Ast.builtinTypeEmpty and
            not dstType.equals( expNode.$expType ## ) and
            not dstType.$nonnilableType.equals( expNode.$expType ## )
         {
            if expNode.$kind ~= Nodes.NodeKind.$Abbr {
               if not hasModNode {
                  hasModNode = true;
               }
               if dstType.$kind == .DDD {
                  let mut argList:List<&Nodes.Node> = [];
                  let mut argTypeList:List<&Ast.TypeInfo> = [];
                  for workIndex = index, #expNodeList {
                     let appNode = expNodeList[ workIndex ];
                     argList.insert( appNode );
                  }

                  let mRetExp:Nodes.MRetExp!;
                  if! let workMRetExp = expListNode.$mRetExp {
                     mRetExp = new Nodes.MRetExp(
                        workMRetExp.$exp, workMRetExp.$index - index + 1 );

                     if #argList == 0 {
                        return Nodes.ExpSubDDDNode.create(
                           self.nodeManager, expNode.$pos,
                           self.macroCtrl.isInAnalyzeArgMode(),
                           workMRetExp.$exp.$expTypeList,
                           workMRetExp.$exp, index - workMRetExp.$index ), true;
                     }
                  }
                  else {
                     mRetExp = nil;
                  }
                  let newExpListNode = Nodes.ExpListNode.create(
                     self.nodeManager, expNode.$pos,
                     self.macroCtrl.isInAnalyzeArgMode(), argTypeList, argList,
                     mRetExp, expListNode.$followOn );
                  
                  workNode = Nodes.ExpToDDDNode.create(
                     self.nodeManager, expNode.$pos,
                     self.macroCtrl.isInAnalyzeArgMode(),
                     [ dstType ], newExpListNode );
                  return workNode, true;
               }
               else {
                  let! castType = alt2typeMap[ dstType ] {
                     castType = dstType;
                  };
                  workNode = Nodes.ExpCastNode.create(
                     self.nodeManager, expNode.$pos,
                     self.macroCtrl.isInAnalyzeArgMode(), [ expNode.$expType ],
                     expNode, castType, .Implicit );   
               }
            }
         }
      }
      return workNode, false;
   }
   
   foreach expNode, index in expNodeList {
      // 代入元の値から、代入先の型に暗黙キャストしているかどうか確認し、
      // 暗黙キャストしている場合は ExpCastNode を生成する。
      let mut workNode = expNode;
      let mut stopFlag = false;
      if #dstTypeList >= index {
         if index == #expNodeList and expNode.$expType.$kind == .DDD {
            // 最終ノードが DDD の場合、
            // 残りの代入先に対して調べる
            for dstIndex = index, #dstTypeList {
               workNode = expNode;
               workNode, stopFlag = process(
                  dstIndex, dstTypeList[ dstIndex ], expNode, workNode );
               newExpNodeList.insert( workNode );
               expTypeList.insert( workNode.$expType );
            }
            break;
         }
         else {
            workNode, stopFlag = process( index, dstTypeList[ index ],
                                          expNode, workNode );
         }
      }

      newExpNodeList.insert( workNode );
      expTypeList.insert( workNode.$expType );
      if stopFlag {
         break;
      }
   }

   if not hasModNode {
      return nil;
   }

   let mut newMRetExp:&Nodes.MRetExp! = nil;
   if! let mRetExp = expListNode.$mRetExp {
      if mRetExp.$index <= #dstTypeList and dstTypeList[ mRetExp.$index ].$kind ~= .DDD
      {
         // 代入元の多値の先頭位置と、代入先の ... の位置が異なる場合、
         // 代入元の多値位置情報を記録する。
         // 位置が同じ場合は、そのまま代入するだけなので記録しない。
         newMRetExp = mRetExp;
      }
   }
   
   return Nodes.ExpListNode.create(
      self.nodeManager, expListNode.$pos, self.macroCtrl.isInAnalyzeArgMode(),
      expTypeList, newExpNodeList, newMRetExp, expListNode.$followOn );
}


/**
型の一致性を確認する。

@param message 不一致時に出力するメッセージ
@param pos 不一致時に出力するコードの場所
@param dstTypeList 設定先の型のリスト
@param expListNode 設定する値の型リスト
@param allowDstShort dstTypeList の要素数が expNodeList よりも少ないことを許容する場合 true
@param warnForFollow true の場合、値を省略している時に警告を出力する
@param
@return Map<&Ast.TypeInfo,&Ast.TypeInfo>  AlternateTypeInfo → 実型パラメータのマップ
@return 
*/
fn TransUnit.checkMatchType(
   mut message:str, pos: &Parser.Position, dstTypeList: &List<&Ast.TypeInfo>,
   expListNode: &Nodes.ExpListNode!, allowDstShort:bool, warnForFollow:bool,
   genericsClassType:&Ast.TypeInfo! ) mut :
Ast.MatchType, Map<&Ast.TypeInfo,&Ast.TypeInfo>, &Nodes.ExpListNode!, &List<&Ast.TypeInfo>
{
   let! expNodeList:&List<&Nodes.Node> = expListNode$.$expList {
      expNodeList = [];
   };
   let mut warnForFollowSrcIndex:int! = nil;
   let mut expTypeList:List<&Ast.TypeInfo> = [];

   // expNodeList から、評価後の型リスト expTypeList を取得する。
   // ## で省略を明示した場合、expNodeList の末尾には AbbrNode が入っている。
   // 多値使用警告を正常に判定するため、一旦 AbbrNode を抜く。
   let mut workExpNodeList = expNodeList;
   let mut hasAbbr = false;
   if #expNodeList > 0 {
      if expNodeList[ #expNodeList ].$kind == Nodes.NodeKind.$Abbr {
         hasAbbr = true;
         let mut workList:List<&Nodes.Node> = [];
         foreach node, index in expNodeList {
            workList.insert( node );
         }
         workList.remove(##);
         workExpNodeList = workList;
      }
   }

   // 実際にコード上で指定されている exp の数。
   // 多値返却があると、workExpNodeList の要素数と実際のコード上の exp の数が異なるので、
   // ExpAccessMRet を除外した数を取得する。
   let mut realExpNum = -1;
   
   foreach expNode, index in workExpNodeList {
      if realExpNum == -1 and expNode.$kind == Nodes.NodeKind.$ExpAccessMRet {
         realExpNum = index - 1;
      }
      if index == #workExpNodeList {
         foreach expType in expNode.$expTypeList {
            expTypeList.insert( expType );
         }
      }
      else {
         expTypeList.insert( expNode.$expType );
      }
   }
   if realExpNum == -1 {
      realExpNum = #workExpNodeList;
   }
   
   if warnForFollow and #expTypeList > realExpNum {
      warnForFollowSrcIndex = realExpNum + 1;
   }
   if hasAbbr {
      expTypeList.insert( Ast.builtinTypeAbbr );
   }

   let mut alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
   when! genericsClassType {
      alt2typeMap = genericsClassType.createAlt2typeMap( true );
   }

   Ast.CanEvalCtrlTypeInfo.setupNeedAutoBoxing( alt2typeMap );
   
   let result, mess = Ast.TypeInfo.checkMatchType(
      dstTypeList, expTypeList, allowDstShort, warnForFollowSrcIndex, alt2typeMap );
   //Ast.AlternateTypeInfo.createAlt2typeMap( applyGeneric ) ); 
   switch result {
      case .Error {
         self.addErrMess( pos, "%s: %s" (message, mess ) );
      }
      case .Warn {
         if not self.ctrl_info.checkingDefineAbbr and
            Code.isMessageOf( .nothing_define_abbr, mess )
         {
         }
         else {
            self.addWarnMess( pos, "%s: %s" (message, mess ) );
         }
      }
   }


   when! expListNode {
      let mut autoBoxingCount = 0;
      let mut hasImplictCast = false;
      let newExpListNode:&Nodes.ExpListNode!;

      if! let mut workList = self.checkImplicitCast(
         alt2typeMap, dstTypeList, expListNode,
         fn ( dstType:&Ast.TypeInfo, expNode:&Nodes.Node ): &Nodes.Node! {
            if Ast.CanEvalCtrlTypeInfo.canAutoBoxing( dstType, expNode.$expType ) {
               autoBoxingCount = autoBoxingCount + 1;

               return Nodes.BoxingNode.create(
                  self.nodeManager, expNode.$pos,
                  self.macroCtrl.isInAnalyzeArgMode(), [ dstType ], expNode );
            }
            return nil;
         } )
      {
         newExpListNode = workList;
         hasImplictCast = true;
      }
      else {
         newExpListNode = nil;
      }
      

      if autoBoxingCount > 0 {
         if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap,
                                                              autoBoxingCount )
         {
            self.addErrMess( pos, "illegal auto boxing error -- %d" (autoBoxingCount) );
         }
         
         return result, alt2typeMap, newExpListNode, expTypeList;
      }
      elseif Ast.CanEvalCtrlTypeInfo.hasNeedAutoBoxing( alt2typeMap ) {
         self.addErrMess( pos, "not support auto boxing" );
      }

      
      if hasImplictCast {
         return result, alt2typeMap, newExpListNode, expTypeList;
      }
   }
   if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 0 ) {
      self.addErrMess( pos, "can't auto boxing error" );
   }
   
   
   return result, alt2typeMap, nil, expTypeList;
}



/**
関数 funcTypeInfo の引数に expList を指定している時の、引数型チェックを行なう。

@param pos この引数チェックを行なっているソース位置
@param funcTypeInfo 関数型
@param expList 引数情報
@param genericTypeList generics に与えられている型
@param genericsClass funcTypeInfo がメソッドだったときの、
    そのメソッドが定義されているクラス
@return Ast.MatchType マッチ結果
@return Map<&Ast.TypeInfo,&Ast.TypeInfo> AlternateTypeInfo → 実型パラメータのマップ
@return &Nodes.ExpListNode! 暗黙キャストなどを解決した引数 
*/
fn TransUnit.checkMatchValType(
   pos: &Parser.Position, funcTypeInfo:&Ast.TypeInfo, expList:&Nodes.ExpListNode!,
   genericTypeList: &List<&Ast.TypeInfo>, genericsClass:&Ast.TypeInfo! ) mut :
Ast.MatchType, Map<&Ast.TypeInfo,&Ast.TypeInfo>, &Nodes.ExpListNode!
{
   let mut argTypeList = funcTypeInfo.$argTypeInfoList;
   switch funcTypeInfo {
      case builtinFunc.list_insert, builtinFunc.set_add, builtinFunc.set_del {
         argTypeList = genericTypeList;
      }
      case builtinFunc.list_sort {
         let alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
         let callback = Ast.NormalTypeInfo.createFunc(
            false, false, nil, Ast.TypeInfoKind.Func,
            Ast.headTypeInfo, false, false, true, .Pri, "sort", nil,
            [ genericTypeList[ 1 ], genericTypeList[ 1 ] ],
            [ Ast.builtinTypeBool ], false );
         argTypeList = [ callback.$nilableTypeInfo ];
      }
      case builtinFunc.list_remove {
      }
   }

   let mut warnForFollow = true;

   when! expList {
      if expList.$followOn {
         warnForFollow = false;
      }
   }

   let matchResult, mut alt2typeMap, newExpNodeList = self.checkMatchType(
      funcTypeInfo.getTxt(##), pos,
      argTypeList, expList, false, warnForFollow, genericsClass );
   
   when! expList, newExpNodeList {
      return matchResult, alt2typeMap, newExpNodeList;
   }
   return matchResult, alt2typeMap, expList;
}


/**
マクロ展開処理。

この関数は、所定のマクロの macro-statment を評価し、
macro-expand を展開したトークンを getToken() で取れるようにセットする。

getToken() で取得したトークンを実際に処理するのは evalMacroCallback で与える。

@param firstToken マクロ展開開始トークン。メッセージ表示用
@param macroTypeInfo マクロの型
@param expList マクロの引数
@param evalMacroCallback マクロ展開したコードを処理するコールバック関数。
*/
fn TransUnit.evalMacroOp(
   firstToken: &Parser.Token, macroTypeInfo: &Ast.TypeInfo,
   expList: &Nodes.ExpListNode!, evalMacroCallback:Macro.EvalMacroCallback ) mut
{
   let mut parser, mess = self.macroCtrl.evalMacroOp(
      self.parser.getStreamName(), firstToken, macroTypeInfo, expList );

   let mut bakParser = self.parser;

   when! parser {
      self.parser = new Parser.DefaultPushbackParser( parser );
   }
   else {
      self.error( unwrap mess );
   }
   
   self.macroCtrl.startExpandMode( firstToken.pos.lineNo, evalMacroCallback );

   // evalMacroCallback();

   // self.macroCtrl.finishMacroMode();

   let nextToken = self.getTokenNoErr();

   self.parser = bakParser;
   
   if nextToken ~= Parser.getEofToken() {
      self.addErrMess( firstToken.pos,
                       "remain macro expand-statement token -- '%s'(%d:%d)"
                       (nextToken.txt, nextToken.pos.lineNo, nextToken.pos.column) );
      if not macroTypeInfo.$externalFlag {
         self.addErrMess( nextToken.pos,
                          "remain macro expand-statement token -- '%s'" (nextToken.txt) );
      }
   }
}


fn TransUnit.evalMacro(
   firstToken: &Parser.Token,
   macroTypeInfo: &Ast.TypeInfo, expList: &Nodes.ExpListNode! ) mut : Nodes.ExpMacroExpNode
{
   let mut stmtList:List<&Nodes.Node> = [];
   
   self.evalMacroOp( firstToken, macroTypeInfo, expList,
                     fn () {
                        if #macroTypeInfo.$retTypeInfoList == 0 {
                           self.analyzeStatementList( stmtList, "}" );
                        }
                        else {
                           stmtList.insert( self.analyzeExp( false, false ## ) );
                        }
                     } );

   // return self.createNode(
   //     nodeKindExpMacroExp, firstToken.pos, builtinTypeNone, stmtList );

   let expTypeList;
   if #macroTypeInfo.$retTypeInfoList ~= 0 {
      expTypeList = macroTypeInfo.$retTypeInfoList;
      if #stmtList == 1 {
         let node = stmtList[ 1 ];
         if #node.$expTypeList == 1 {
            if not expTypeList[ 1 ].equals( node.$expType ## ) {
               self.addErrMess( firstToken.pos,
                                "mismatch type -- %s != %s"
                                (expTypeList[ 1 ].getTxt(##),
                                  node.$expType.getTxt(##)) );
            }
         }
         else {
            self.addErrMess( firstToken.pos,
                             "macro can't return multipul values." );
         }
      }
      else {
         self.addErrMess( firstToken.pos, "nothing exp" );
      }
   }
   else {
      expTypeList = [ Ast.builtinTypeNone ];
   }
   
   return Nodes.ExpMacroExpNode.create(
      self.nodeManager, firstToken.pos,
      self.macroCtrl.isInAnalyzeArgMode(), expTypeList, stmtList );
}

/**
format の書式から %? を検索して、リストを返す。
*/
pub fn findForm( format:str ): List<str> {
   let mut remain = format;
   let mut opList:List<str> = [];

   while true {
      let mut pos:int!, mut endPos:int! = nil, nil;
      if! let index, endIndex = remain.find( "^%%[%d]*%a" ## ) {
         pos, endPos = index, endIndex;
      }  
      else {
         if! let index, endIndex = remain.find( "[^%%]%%[%d]*%a" ## ) {
            pos, endPos = index + 1, endIndex;
         }      
      }  

      when! pos, endPos {
         let op = remain.sub( pos, endPos );
         opList.insert( op );
         remain = remain.sub( endPos + 1 ## );
      }
      else {
         break;
      }
   }
   return opList;
}

pub enum FormType {
   Match,
   NeedConv,
   Unmatch,
}
pub fn isMatchStringFormatType(
   opKind:str, mut argType:&Ast.TypeInfo, luaVer:&LuaVer.LuaVerInfo ):
   FormType, &Ast.TypeInfo
{
   if! let enumType = argType.$srcTypeInfo@@@Ast.EnumTypeInfo {
      argType = enumType.$valTypeInfo;
   }
   switch opKind[ #opKind ] {
      case ?s {
         if not argType.equals( Ast.builtinTypeString ##) {
            if not luaVer.$canFormStem2Str {
               return .NeedConv, Ast.builtinTypeString;
            }
         }
      }
      case ?q {
         if not argType.equals( Ast.builtinTypeString ##) {
            // 文字列以外に %q を使うのは不具合の可能性があるので unmatch にする。
            return .Unmatch, Ast.builtinTypeString;
         }
      }
      case ?A, ?a, ?E, ?e, ?f, ?G, ?g {
         if not argType.equals( Ast.builtinTypeReal ##) {
            return .Unmatch, Ast.builtinTypeReal;
         }
      }
      default {
         if not argType.equals( Ast.builtinTypeInt ##) and
            not argType.equals( Ast.builtinTypeChar ##)
         {
            return .Unmatch, Ast.builtinTypeInt;
         }
      }
   }
   return .Match, Ast.builtinTypeNone;
}


fn TransUnit.checkStringFormat(
   pos:&Parser.Position, formatTxt:str, argTypeList:&List<&Ast.TypeInfo> ) mut
{
   let opList = findForm( formatTxt );
   let mut dstTypeList:List<&Ast.TypeInfo> = [];

   if #opList ~= #argTypeList {
      self.addErrMess( pos,
                       "argument number is mismatch -- %d != %d"
                       ( #opList, #argTypeList ) );   
      return;
   }
   
   foreach op, index in opList {
      let argType = argTypeList[ index ];
      let match, reqType = isMatchStringFormatType( op, argType, self.targetLuaVer );
      if match == .Unmatch {
         let mut mess = "type must be %s -- %s"
             ( reqType.getTxt(##), argType.getTxt(##) );
         self.addErrMess( pos, "argument(%d) %s" (index, mess ) );
      }
   }
}

/**
関数呼び出し Node の前処理。

引数の型チェックを行なう。

"(" を読み済みの状態。次のトークンは引数のトークンになっている状態にする。
この関数を抜けると、 ")" を読み込み済みの状態。


@param position 関数の定義位置
@param funcTypeInfo 関数の型情報
@param genericTypeList Genericsの実型パラメータ
@param genericsClass funcTypeInfo が属するクラス Generics クラス。
         funcTypeInfo がメソッドでなければ headTypeInfo.
*/
fn TransUnit.prepareExpCall(
   position:&Parser.Position, funcTypeInfo:&Ast.TypeInfo,
   genericTypeList:&List<&Ast.TypeInfo>, genericsClass:&Ast.TypeInfo ) mut :
   Map<&Ast.TypeInfo,&Ast.TypeInfo>, &Nodes.ExpListNode!
{

   if funcTypeInfo.$kind == .Macro {
      self.macroCtrl.startAnalyzeArgMode();
   }

   let work = self.getToken(##);
   let mut argList: &Nodes.ExpListNode! = nil;
   if work.txt ~= ")" {
      self.pushback();
      argList = self.analyzeExpList(
         false, false, nil, funcTypeInfo.$argTypeInfoList ## );
      self.checkNextToken( ")" );

      when! argList {
         foreach argNode in argList.$expList {
            if not argNode.canBeRight() and argNode.$kind ~= Nodes.NodeKind.$Abbr {
               self.addErrMess( argNode.$pos, "this node can't be r-value. -- %s"
                                (Nodes.getNodeKindName( argNode.$kind )));
            }
         }
      }
   }

   // 引数の型チェック
   let matchResult, mut alt2typeMap, workArgList = self.checkMatchValType(
      position, funcTypeInfo, argList, genericTypeList, genericsClass );

   if funcTypeInfo.$kind == .Macro and matchResult == .Error {
      // マクロの場合、引数が一致していない時はエラーで止める。
      self.error( "unmatch macro arguments. -- %s" (funcTypeInfo.getTxt(##) ) );
   }


   if funcTypeInfo.$kind == .Macro {
      self.macroCtrl.finishMacroMode();
   }
   

   return alt2typeMap, workArgList;
}

/**
関数コール処理。

関数コールの "(" を読み込み済みの状態。

@param firstToken 関数コールの最初のトークン
@param exp 関数

*/
fn TransUnit.analyzeExpCall(
   firstToken:&Parser.Token, funcExp: Nodes.Node, nextToken:&Parser.Token ) mut :
   Nodes.Node, &Parser.Token
{
   self.checkSymbolHavingValue( funcExp.$pos, funcExp.getSymbolInfo() );
   
   // string.format() の引数チェック
   fn checkArgForStringForm( argList:&Nodes.ExpListNode ) {
      let mut formArgTypeList:List<&Ast.TypeInfo> = [];
      let mut formatTxt = "";
      if #argList.$expList > 0 {
         let argNode = argList.$expList[ 1 ];
         if argNode.$kind ~= Nodes.NodeKind.$LiteralString {
            // literal 文字列でない場合は無視
            return;
         }
         if! let literal = argNode.getLiteral() {
            match literal {
               case .Str( val ) {
                  formatTxt = val;
               }
            }
         }
      }
      if #argList.$expList > 1 {
         if! let toDDDNode = argList.$expList[ 2 ]@@@Nodes.ExpToDDDNode {
            foreach workNode, index in toDDDNode.$expList.$expList {
               formArgTypeList.insert( workNode.$expType );
            }
         }
      }
      // foreach argType, index in argList.$expTypeList {
      //    if index ~= 1 {
      //       formArgTypeList.insert( argType );
      //    }
      // }
      self.checkStringFormat( firstToken.pos, formatTxt, formArgTypeList );
   }

   // List.sort() の引数チェック 
   fn checkArgForSort(
      genericTypeList:&List<&Ast.TypeInfo>, argList:&Nodes.ExpListNode )
   {  
      if #argList.$expTypeList > 0 {
         let callback = argList.$expTypeList[ 1 ];
         if callback == Ast.builtinTypeAbbr {
            return;
         }
         if #callback.$retTypeInfoList ~= 1 {
            self.addErrMess(
               firstToken.$pos,
               "The callback's to return value of sort() must have a value. -- %d"
               (#callback.$retTypeInfoList) );
            return;
         }
         if not Ast.builtinTypeBool.equals( callback.$retTypeInfoList[ 1 ] ##) {
            self.addErrMess(
               firstToken.$pos,
               "The callback's return type of sort() must be bool. -- '%s'"
               ( callback.$retTypeInfoList[ 1 ].getTxt(##) ) );
         }
         if #callback.$argTypeInfoList ~= 2 {
            self.addErrMess(
               firstToken.$pos,
               "The callback's argument must have 2 arguments. -- '%s'"
               (callback.$display_stirng) );
         }
         if #genericTypeList == 1 {
            foreach argType, index in callback.$argTypeInfoList {
               if not genericTypeList[ 1 ].equals( argType ##) {
                  self.addErrMess(
                     firstToken.$pos,
                     "The callback's argument(%d) type must be -- '%s'"
                     ( index, genericTypeList[ 1 ].getTxt(##)) );
               }
            }
         }
         else {
            self.addErrMess(
               firstToken.$pos, "The generics of the list is illegal" );
         }
      }
   }

   let funcSymbol:&Ast.SymbolInfo!;
   let symbolInfoList = funcExp.getSymbolInfo();
   if #symbolInfoList > 0 {
      let symbol = symbolInfoList[ 1 ];
      if symbol.$kind == .Typ {
         self.addErrMess( funcExp.$pos, "can't call any Type. -- %s" (symbol.$name) );
      }
      funcSymbol = symbol;
   }
   else {
      funcSymbol = nil;
   }

   let mut funcTypeInfo = funcExp.$expType;
   let nilAccess;

   if nextToken.txt == "$(" {
      if funcTypeInfo.$nilable {
         funcTypeInfo = funcTypeInfo.$nonnilableType;
         nilAccess = true;
      }
      else {
         self.addWarnMess( funcExp.$pos,
                           "This is not nilable. -- %s" (funcTypeInfo.getTxt(##) ) );
         nilAccess = false;
      }
   }
   else {
      nilAccess = false;
   }

   // let work = self.getToken(##);
   // let mut argList: &Nodes.ExpListNode! = nil;
   // if work.txt ~= ")" {
   //    self.pushback();
   //    argList = self.analyzeExpList(
   //       false, false, nil, funcTypeInfo.$argTypeInfoList ## );
   //    self.checkNextToken( ")" );

   //    when! argList {
   //       foreach argNode in argList.$expList {
   //          if not argNode.canBeRight() and argNode.$kind ~= Nodes.NodeKind.$Abbr {
   //             self.addErrMess( argNode.$pos, "this node can't be r-value. -- %s"
   //                              (Nodes.getNodeKindName( argNode.$kind )));
   //          }
   //       }
   //    }
   // }

   // 引数の型チェック
   let mut genericTypeList = funcTypeInfo.$itemTypeInfoList;
   let mut refFieldNode:&Nodes.RefFieldNode! = nil;
   let mut genericsClass = Ast.headTypeInfo;
   if! let refField = funcExp@@@Nodes.RefFieldNode {
      refFieldNode = refField;
      let classType = refField.$prefix.$expType;
      genericsClass = classType;

      if funcTypeInfo.$kind == .Method {
         genericTypeList = classType.$itemTypeInfoList;
      }
   }

   // let mut alt2typeMap, workArgList = self.checkMatchValType(
   //    exp.$pos, funcTypeInfo, argList, genericTypeList, genericsClass );
   // argList = workArgList;


   let mut alt2typeMap, argList = self.prepareExpCall(
      funcExp.$pos, funcTypeInfo, genericTypeList, genericsClass );

   if funcTypeInfo.equals( builtinFunc.list_insert ##) {
      when! argList {
         if argList.$expType.$nilable {
            self.addErrMess( argList.$pos, "list can't insert nilable" );
         }
      }
   }
   if funcTypeInfo.equals( builtinFunc.set_add ##) {
      when! argList {
         if argList.$expType.$nilable {
            self.addErrMess( argList.$pos, "set can't add nilable" );
         }
      }
   }
   elseif funcTypeInfo.equals( builtinFunc.list_remove ##) {
      if #genericTypeList > 0 {
         if genericTypeList[ 1 ].$nilable {
            self.addWarnMess( funcExp.$pos, "remove() is dangerous for nilable's list." );
         }
      }
   }


   fn processFunc(): Nodes.Node {
      switch( funcTypeInfo.$kind ) {
         case .Method, .Func, .Form, .FormFunc {
         }
         default {
            self.error( "can't call the type -- %s, %s"
                        ( funcTypeInfo.getTxt(##),
                          funcTypeInfo.$kind.$_txt ) );
         }
      }
      let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
      foreach retType, index in funcTypeInfo.$retTypeInfoList {
         retTypeInfoList.insert( retType );
         if! let applyType = retType.applyGeneric( alt2typeMap, self.moduleType ) {
            retTypeInfoList[ index ] = applyType;
         }
         else {
            if funcTypeInfo == builtinFunc.list_remove {
               // pending: List.remove の戻り値設定を暫定対応
               retTypeInfoList[ index ] = genericTypeList[ 1 ].$nilableTypeInfo;
            }
            elseif funcTypeInfo.$kind == .Func and
                ( funcTypeInfo.$rawTxt == "_fromMap" or
                  funcTypeInfo.$rawTxt == "_fromStem" ) and
               genericsClass.isInheritFrom( Ast.builtinTypeMapping, alt2typeMap )
            {
               retTypeInfoList[ index ] = genericsClass.$nilableTypeInfo;
            }
            else {
               self.addErrMess(
                  firstToken.pos,
                  "not support generics yet. -- %s" (retType.getTxt(##)) );
            }
         }
      }
      
      when! refFieldNode {
         if funcTypeInfo.equals( builtinFunc.list_unpack ##) or
            funcTypeInfo.equals( builtinFunc.array_unpack ##)
         {
            // unpack の型を list の要素の DDD 型にする
            let prefixType = refFieldNode.$prefix.$expType;
            if #prefixType.$itemTypeInfoList > 0 {
               let dddType = Ast.NormalTypeInfo.createDDD(
                  prefixType.$itemTypeInfoList[ 1 ], false );
               retTypeInfoList = [];
               retTypeInfoList.insert( dddType );
            }
         }
      }
         
      
      if nilAccess {
         let mut retList:List<&Ast.TypeInfo> = [];
         foreach retType in retTypeInfoList {
            if retType.$nilable {
               retList.insert( retType );
            }
            else {
               retList.insert( retType.$nilableTypeInfo );
            }
         }
         retTypeInfoList = retList;
         self.helperInfo.useNilAccess = true;
      }

      let mut errorFuncFlag = false;
      if #retTypeInfoList > 0 {
         let retType = retTypeInfoList[1];
         if retType == Ast.builtinTypeNeverRet {
            errorFuncFlag = true;
         }
      }

      when! argList {
         switch funcTypeInfo {
            case builtinFunc.string_format {
               checkArgForStringForm( argList );
            }
            case builtinFunc.list_sort, builtinFunc.array_sort {
               checkArgForSort( genericTypeList, argList );
            }
         }
      }

      if funcTypeInfo.equals( builtinFunc.lns__kind ##) {
         if! let expList = argList$.$expList {
            if #expList > 0 {
               return Nodes.LuneKindNode.create(
                  self.nodeManager, firstToken.pos,
                  self.macroCtrl.isInAnalyzeArgMode(),
                  [ Ast.builtinTypeInt ], expList[ 1 ] );
            }
         }
         return Nodes.LuneKindNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeInt ],
            self.createNoneNode( firstToken.pos ) );               
      }

      when! funcSymbol {
         if funcSymbol.$name == "super" {
            return Nodes.ExpCallSuperNode.create(
               self.nodeManager, firstToken.pos,
               self.macroCtrl.isInAnalyzeArgMode(), retTypeInfoList,
               funcSymbol.$typeInfo.$parentInfo, funcSymbol.$typeInfo, argList );
         }
      }
      return Nodes.ExpCallNode.create(
         self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
         retTypeInfoList, funcExp, errorFuncFlag, nilAccess, argList );
   }

   if funcTypeInfo.$rawTxt == "" {
      self.addErrMess( funcExp.$pos, "can't directly call the declared function." );
   }

   let mut exp:Nodes.Node;
   if funcTypeInfo.get_kind() == .Macro {
      //self.macroCtrl.finishMacroMode();
      exp = self.evalMacro( firstToken, funcTypeInfo, argList );
   }
   else {
      exp = processFunc();
   }

   return exp, self.getTokenNoErr();
}

fn TransUnit.analyzeExpCast(
   firstToken:&Parser.Token, opTxt:str, exp:Nodes.Node ) mut : Nodes.Node
{
   let castTypeNode = self.analyzeRefType( .Local, false, false );
   let mut castType = castTypeNode.$expType;

   if castType.$kind == .Form and
      exp.$expType.$nonnilableType.$kind == .Stem
   {
      // Stem から form へのキャストは、C のトランスコンパイルではサポートしない
      self.addWarnMess(
         castTypeNode.$pos,
         "not support cast from stem to form for transcompiling to c-lang." );
   }

   let expType = exp.$expType;

   if opTxt == "@@@" or opTxt == "@@=" {
      if #castType.$itemTypeInfoList > 0 {
         self.addErrMess( castTypeNode.$pos,
                          "not support cast for generics class yet -- %s"
                          (castType.getTxt(##)));
      }
      switch castType.$kind {
         case .IF, .Class, .Prim {
         }
         default {
            self.addErrMess( castTypeNode.$pos,
                             "not support cast -- %s" (castType.getTxt(##)));
         }
      }

      if opTxt == "@@=" {
         if castType.$kind ~= .IF and castType.$kind ~= .Class {
            self.addErrMess( castTypeNode.$pos,
                             "'@@=' cast must be class or interface. -- %s"
                             (castType.getTxt(##)) );
         }
         if expType.$srcTypeInfo ~= Ast.builtinTypeStem and
            expType.$kind ~= .IF and expType.$kind ~= .Class
         {           
            self.addErrMess( castTypeNode.$pos,
                             "'@@=' cast must be class or interface. -- %s"
                             (castType.getTxt(##)) );
         }  
         if not Ast.isStruct( castType ) {
            self.addErrMess( castTypeNode.$pos,
                             "'@@=' cast type can't use class has method -- %s"
                             (castType.getTxt(##)));
         }
      }
   }
   else {
      if castType ~= Ast.builtinTypeString and
          ( castType.$kind == .IF or castType.$kind == .Class )
      {           
         self.addWarnMess( castTypeNode.$pos,
                           "use '@@@' cast for class or interface. -- %s"
                           (castType.getTxt(##)) );
      }
   }
   
   
   if opTxt ~= "@@@" and expType.$nilable and not castType.$nilable {
      self.addErrMess( firstToken.pos,
                       "can't cast from nilable to not nilable  -- %s->%s"
                       (expType.getTxt(##), castType.getTxt(##)) );
   }
   if not Ast.TypeInfo.isMut( expType ) and Ast.TypeInfo.isMut( castType ) {
      castType = self.createModifier( castType, .IMut );
   }

   if castType.canEvalWith( expType, .SetOp, {} ) {
      // "str"@@str のように、意味のないキャストはエラー
      self.addWarnMess( castTypeNode.$pos,
                        "This cast isn't need. (%s <- %s)"
                        ( castType.getTxt( self.typeNameCtrl ## ),
                          expType.getTxt( self.typeNameCtrl ## ) ) );          
   }
   elseif not expType.canEvalWith( castType, .SetOp, {} ) {
      if not Ast.isNumberType( expType ) or not Ast.isNumberType( castType ) {
         // キャスト先の型からキャスト元の型へ互換性がない場合はエラー
         self.addErrMess( castTypeNode.$pos,
                          "This type can't cast. (%s <- %s)"
                          ( castType.getTxt( self.typeNameCtrl ## ),
                            expType.getTxt( self.typeNameCtrl ## ) ) );            
      }
   }

   if opTxt == "@@@" {
      castType = castType.$nilableTypeInfo;
   }

   return Nodes.ExpCastNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ castType ], self.nodeManager.MultiTo1( exp ), castType,
      opTxt ~= "@@@" and Nodes.CastKind.Force or Nodes.CastKind.Normal);
}


fn TransUnit.analyzeExpCont(
   firstToken: &Parser.Token, mut exp: Nodes.Node, skipFlag: bool ) mut : Nodes.Node
{
   let mut nextToken = self.getToken( true );
   if nextToken.kind == .Eof {
      return exp;
   }

   if not skipFlag {
      repeat {
         let mut matchFlag = false;
         if nextToken.txt == "[" or nextToken.txt == "$[" {
            matchFlag = true;
            exp = self.analyzeExpRefItem( nextToken, exp, nextToken.txt == "$[" );
            nextToken = self.getToken(##);
         }
         if nextToken.txt == "(" or nextToken.txt == "$(" {
            matchFlag = true;

            exp, nextToken = self.analyzeExpCall( firstToken, exp, nextToken );
         }
      } not matchFlag;

      switch nextToken.txt {
         case "@@", "@@@", "@@=" {
            exp = self.analyzeExpCast( firstToken, nextToken.txt, exp );
            nextToken = self.getToken( ## );
         }
      }
   }

   switch nextToken.txt {
      case "." {
         return self.analyzeExpSymbol(
            firstToken, self.getToken(##), .Field, exp, skipFlag );
      }
      case "$." {
         return self.analyzeExpSymbol(
            firstToken, self.getToken(##), .FieldNil, exp, skipFlag );
      }
      case ".$" {
         return self.analyzeExpSymbol(
            firstToken, self.getToken(##), .Get, exp, skipFlag );
      }
      case "$.$" {
         return self.analyzeExpSymbol(
            firstToken, self.getToken(##), .GetNil, exp, skipFlag );
      }
   }

   self.pushback();
   return exp;

}


fn TransUnit.analyzeAccessClassField(
   mut classTypeInfo: &Ast.TypeInfo, mode:ExpSymbolMode, token:&Parser.Token ) mut :
   &Ast.TypeInfo, &Ast.SymbolInfo!, bool
{
   switch classTypeInfo.get_kind() {
      case .List {
         classTypeInfo = Ast.builtinTypeList;
      }
      case .Array {
         classTypeInfo = Ast.builtinTypeArray;
      }
      case .Set {
         classTypeInfo = Ast.builtinTypeSet;
      }
   }
   let className = classTypeInfo.getTxt(##);
   let! classScope = classTypeInfo.$scope {
      self.error( "not found field: %s, %s"
                  ( className, classTypeInfo ) );
   };
   
   let mut symbolInfo:&Ast.SymbolInfo! = nil;
   let mut fieldTypeInfo:&Ast.TypeInfo! = nil;
   let mut getterFlag = false;
   if mode == .Get or mode == .GetNil {
      let fieldSymbolInfo = classScope.getSymbolInfo(
         "get_%s" (token.txt), self.scope, false, self.scopeAccess );
      when! fieldSymbolInfo {
         if ( fieldSymbolInfo.get_kind() == .Mtd or fieldSymbolInfo.get_kind() == .Fun )
         {
            let retTypeList = fieldSymbolInfo.$typeInfo.get_retTypeInfoList();
            symbolInfo = fieldSymbolInfo;
            if #retTypeList > 0 {
               fieldTypeInfo = retTypeList[ 1 ];
               when! fieldTypeInfo {
                  if! fieldTypeInfo.applyGeneric(
                     classTypeInfo.createAlt2typeMap(false), self.moduleType )
                  {                 
                     fieldTypeInfo = _exp;
                  }
               }
            }
            getterFlag = true;
         }
      }
   }
   if not symbolInfo {
      // fieldSymbolInfo = classScope.getTypeInfo(
      //     token.txt, self.scope, false );
      // fieldTypeInfo = classScope.getTypeInfoField(
      //    token.txt, true, self.scope );
      symbolInfo = classScope.getSymbolInfoField(
         token.txt, true, self.scope, self.scopeAccess );
      if not symbolInfo {
         symbolInfo = classScope.getSymbolInfoIfField(
            token.txt, self.scope, self.scopeAccess );
      }
      when! symbolInfo {
         fieldTypeInfo = symbolInfo.$typeInfo;
      }
   }
   if not fieldTypeInfo {
      foreach val, name in classScope.$symbol2SymbolInfoMap {
         Util.log( "debug: %s, %s" ( name, val ) );
      }
      self.error( "not found field typeInfo: %s.%s" ( className, token.txt ) );
   }
   let typeInfo = unwrap fieldTypeInfo default Ast.builtinTypeNone;

   when! symbolInfo {
      if self.inAnalyzingState( .InitBlock ) or self.inAnalyzingState( .ClassMethod ) 
      {     
         let mut errorMess:str! = nil;
         if self.protoFuncMap[ symbolInfo.$typeInfo ] {

            // __init ブロックの制御
            errorMess = "It can't call prototype function from static -- %s" (symbolInfo.$name);
         }
         // elseif symbolInfo.$scope == classTypeInfo.$scope and symbolInfo.$kind == .Mtd {
         //    errorMess = "It can't call the method from __init.-- %s" (symbolInfo.$name);
         // }
         when! errorMess {
            self.addErrMess( token.pos, errorMess );
         }
      }
      elseif self.inAnalyzingState( .Constructor ) {
         let mut errorMess:str! = nil;
         if self.protoFuncMap[ symbolInfo.$typeInfo ] {
            errorMess = "It can't call prototype function from '__init'";
         }
         else {
            if symbolInfo.$typeInfo.$kind == .Method and symbolInfo.$scope == classScope
            {           
               foreach val, name in classScope.$symbol2SymbolInfoMap {
                  if val.$kind == .Mbr and not val.$staticFlag {
                     if not val.$hasValueFlag and not val.$typeInfo.$nilable {
                        errorMess = "Set member(%s) before to access the method-- %s"
                        ( val.$name, symbolInfo.$name );
                        break;
                     }
                  }
               }
            }
         }
         when! errorMess {
            self.addErrMess( token.pos, errorMess );
         }
      }
   }
   
   return typeInfo, symbolInfo, getterFlag;
}

fn TransUnit.dumpComp(
   writer: Writer.Writer, pattern: str,
   symbolInfo: &Ast.SymbolInfo, getterFlag:bool ): bool
{
   let symbol = symbolInfo.$name;
   if pattern == "" or symbol.find( pattern ## ) {
      if getterFlag {
         writer.startParent( "candidate", false );
         let typeInfo = symbolInfo.$typeInfo;
         writer.write( "type", "%s" ( symbolInfo.$kind.$_txt ) );
         switch ( symbolInfo.$kind ) {
            case .Mtd, .Fun, .Mac {
               writer.write( "displayTxt", "$%s"
                             ( (typeInfo.$rawTxt.gsub( "^get_", "")) ) );
            }  
            case .Mbr {
               writer.write( "displayTxt", "$%s: %s"
                             ( symbolInfo.$name, typeInfo.getTxt(##) ) );
            }
         }
      }
      else {
         writer.startParent( "candidate", false );
         let typeInfo = symbolInfo.$typeInfo;
         writer.write( "type", "%s" ( symbolInfo.$kind.$_txt ) );
         switch ( symbolInfo.$kind ) {
            case .Fun, .Mtd, .Mac {
               writer.write( "displayTxt", "%s"
                             ( typeInfo.get_display_stirng_with(symbolInfo.$name) ) );
            }  
            case .Mbr, .Var, .Arg {
               let mut name = symbolInfo.$name;
               if! let algeTypeInfo = typeInfo@@@Ast.AlgeTypeInfo {
                  if! let valInfo = algeTypeInfo.getValInfo( name ) {
                     if #valInfo.$typeList > 0 {
                        name = "%s(" (name);
                        foreach itemType, index in valInfo.$typeList {
                           if index > 1 {
                              name = name .. ",";
                           }
                           name = name .. itemType.$display_stirng;
                        }
                        name = name .. ")";
                     }
                  }
               }
               writer.write( "displayTxt", "%s: %s"
                             ( name, typeInfo.$display_stirng ) );
            }  
            case .Typ {
               writer.write( "displayTxt",
                             "%s" ( (typeInfo.$display_stirng.gsub( "@", "" ) )) );
            }  
         }
      }
      writer.endElement();
   }
   return true;
}

fn TransUnit.dumpFieldComp(
   writer: Writer.Writer, isPrefixType: bool,
   prefixTypeInfo: &Ast.TypeInfo, pattern: str, getterPattern: str! )
{
   let typeInfo = prefixTypeInfo;
   let! scope = typeInfo.$scope {
      return;
   };

   scope.filterTypeInfoField(
      true, self.scope, self.scopeAccess,
      fn ( symbolInfo: &Ast.SymbolInfo ) : bool {
         if ( isPrefixType ) {
            if not symbolInfo.$staticFlag and
               not symbolInfo.$typeInfo.$staticFlag and
               symbolInfo.$kind ~= .Typ
            {
               // 型のフィールド補完は 非 static を除外
               return true;
            }
         }
         elseif symbolInfo.$staticFlag {
            // インスタンスのフィールド補完は static を除外
            return true;
         }
         let symbol = symbolInfo.$name;
         if symbol ~= "__init" and symbol ~= "__free" and
            symbol ~= "self"
         {
            when! getterPattern {
               if symbolInfo.$kind == .Mtd or symbolInfo.$kind == .Fun {
                  let retList = symbolInfo.$typeInfo.$retTypeInfoList;
                  if #retList == 1 {
                     return self.dumpComp( writer, getterPattern, symbolInfo, true );
                  }
               }
               return true;
            }
            return self.dumpComp(writer, pattern, symbolInfo, false );
         }
         return true;
      });
}

fn TransUnit.dumpSymbolComp( writer: Writer.Writer, scope: &Ast.Scope, pattern: str ) {
   scope.filterSymbolTypeInfo(
      scope, self.moduleScope, self.scopeAccess,
      fn ( symbolInfo: &Ast.SymbolInfo ) : bool {
         return self.dumpComp(writer, pattern, symbolInfo, false );
      });    
}

form checkCompForm( jsonWriter: Writer.JSON, prefix:str  );

fn TransUnit.checkComp( token:&Parser.Token, callback:checkCompForm ) 
{
   if self.analyzeMode == .Complete and
      self.analyzePos.lineNo == token.pos.lineNo and
      self.analyzePos.column >= token.pos.column and
      self.analyzePos.column <= token.pos.column + #token.txt 
   {
      let mut currentModule = self.parser.getStreamName().gsub( "%.lns", "" );
      currentModule = currentModule.gsub( ".*/", "" );
      let target = self.analyzeModule.gsub( "[^%.]+%.", "" );
      if currentModule == target {
         let mut jsonWriter = new Writer.JSON( io.stdout );
         jsonWriter.startParent( "lunescript", false );
         let prefix = token.txt.gsub( "lune$", "" );
         jsonWriter.write( "prefix", prefix );
         jsonWriter.startParent( "candidateList", true );

         callback( jsonWriter, prefix );

         jsonWriter.endElement();
         jsonWriter.endElement();
         jsonWriter.fin();
         os.exit( 0 );
      }
   }
}


fn TransUnit.checkFieldComp(
   getterFlag:bool, token:&Parser.Token, prefixExp: &Nodes.Node ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   let prefixSymbolInfoList = prefixExp.getSymbolInfo();
   let mut prefixSymbolInfo:&Ast.SymbolInfo! = nil;
   if #prefixSymbolInfoList == 1 {
      prefixSymbolInfo = prefixSymbolInfoList[ 1 ];
   }
   
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         let mut getterPattern:str! = nil;
         if getterFlag {
            getterPattern = "^get_" .. prefix;
         }
         let mut isPrefixType = false;
         if! prefixSymbolInfo {
            isPrefixType = _exp.$kind == .Typ;
         }     
         self.dumpFieldComp(
            jsonWriter, isPrefixType, prefixExp.$expType,
            prefix == "" and "" or "^" .. prefix, getterPattern );
      }
   );
}

fn TransUnit.checkEnumComp(
   token:&Parser.Token, enumTypeInfo: &Ast.EnumTypeInfo ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         let! scope = enumTypeInfo.$scope {
            return;
         };

         let pattern = prefix == "" and "" or "^" .. prefix;
         scope.filterTypeInfoField(
            true, self.scope, self.scopeAccess,
            fn ( symbolInfo: &Ast.SymbolInfo ) : bool {
               if symbolInfo.$kind == .Mbr {
                  return self.dumpComp( jsonWriter, pattern, symbolInfo, false );
               }
               return true;
            } );
      }
   );
}

fn TransUnit.checkAlgeComp(
   token:&Parser.Token, algeTypeInfo: &Ast.AlgeTypeInfo ) 
{
   if self.analyzeMode ~= .Complete {
      return;
   }
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         self.dumpFieldComp(
            jsonWriter, true, algeTypeInfo,
            prefix == "" and "" or "^" .. prefix, nil );
      }
   );
}


fn TransUnit.checkSymbolComp( token:&Parser.Token ) 
{
   self.checkComp(
      token,
      fn ( jsonWriter: Writer.JSON, prefix:str ) {
         self.dumpSymbolComp( jsonWriter, self.scope,
                              prefix == "" and "" or "^" .. prefix );
      }
   );
}

fn TransUnit.analyzeExpField(
   firstToken: &Parser.Token, token: &Parser.Token,
   mode: ExpSymbolMode, prefixExp: &Nodes.Node ) mut : Nodes.Node
{
   let mut accessNil = false;
   if mode == .FieldNil or mode == .GetNil {
      accessNil = true;
      if not prefixExp.$expType.$nilable {
         self.addWarnMess(
            prefixExp.$pos,
            "This is not nilable. -- %s" (prefixExp.$expType.getTxt(##)) ); 
      }
   }
   if self.macroCtrl.$macroMode == .AnalyzeArg {
      if accessNil {
         self.helperInfo.useNilAccess = true;
      }

      // self.checkFieldComp(
      //    mode == .Get or mode == .GetNil, token, prefixExp );
      
      return Nodes.RefFieldNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeSymbol ],
         token, nil, accessNil, prefixExp );
         //token, accessNil, unwrap prefixExp );
   }

   let mut typeInfo:&Ast.TypeInfo = Ast.builtinTypeStem_;
   let mut prefixExpType = prefixExp.$expType;

   self.checkFieldComp(
      mode == .Get or mode == .GetNil, token, prefixExp );
   
   if accessNil {
      if prefixExpType.$nilable {
         // nil 条件演算で、 prefixExpType が nilable ならば、
         // prefixExpType を非 nilable にセットする
         prefixExpType = prefixExpType.$nonnilableType;

         if prefixExpType.$srcTypeInfo.$kind == .Box {
            self.addErrMess( prefixExp.$pos, "Nilable can't support '$.' access yet" );
         }
      }
      else {
         // prefixExpType が nilable でなければ、
         // nil 判定は不要なので accessNil をクリアする
         accessNil = false;
      }
   }
   if accessNil {
      self.helperInfo.useNilAccess = true;
      switch prefixExpType.get_kind() {
         case .Set, .Enum, .Alge {
         // 現状は set, enum, alge の accessNil はサポートしていない。
            self.addErrMess( firstToken.pos,
                             "%s does not support $." (prefixExpType.getTxt( nil ##) ) );
         }
      }
   }

   let prefixSymbolInfoList = prefixExp.getSymbolInfo();
   self.checkSymbolHavingValue( prefixExp.$pos, prefixSymbolInfoList );

   let mut getterTypeInfo:&Ast.TypeInfo! = nil;
   let mut symbolInfo:&Ast.SymbolInfo! = nil;
   switch prefixExpType.$kind {
      case .Class, .Module, .IF, .List, .Array, .Set, .Box, .Alternate {
         let mut getterFlag = false;
         typeInfo, symbolInfo, getterFlag =
            self.analyzeAccessClassField( prefixExpType, mode, token );
         if getterFlag {
            if! symbolInfo {
               getterTypeInfo = _exp.$typeInfo;
            }
         }
      }
      case .Enum, .Alge {
         let scope = unwrap prefixExpType.$scope;
         let mut fieldName = token.txt;
         let symbolInfoList = prefixExp.getSymbolInfo();
         let mut isTypeSymbol = false;
         if #symbolInfoList > 0 {
            if symbolInfoList[1].$kind == .Typ {
               isTypeSymbol = true;
            }  
         }
         if mode == .Get {
            let moduleType = prefixExpType.getModule();
            if not moduleType.equals( self.moduleType ##) and
               not self.scope.getModuleInfo( moduleType ) {
                  // enum の名前を取得するには、そのモジュールのインポートが必要
                  self.addErrMess( token.pos, "need to import module -- %s"
                                   ( prefixExpType.getModule().getTxt(##) ) );
               }
            fieldName = "get_" .. fieldName;
            if! let funcType = scope.getTypeInfoChild( fieldName ) {

               if funcType.$staticFlag ~= isTypeSymbol {
                  self.addErrMess(
                     prefixExp.$pos, "Can't access -- %s, %s" ( fieldName, isTypeSymbol) );
               }
               
               
               let retTypeList = funcType.$retTypeInfoList;
               if #retTypeList == 0 {
                  self.addErrMess(
                     token.$pos,
                     "The func (%s) doesn't return value." (funcType.getTxt(##)) );
               }
               else {
                  typeInfo = retTypeList[ 1 ];
               }
            }
            else {
               self.addErrMess( token.$pos, "not found -- %s." ( fieldName ) );
               typeInfo = Ast.builtinTypeNone;
            }

            getterTypeInfo = Ast.headTypeInfo;
         }
         else {
            if! scope.getTypeInfoChild( fieldName ) {
               typeInfo = _exp;
               if typeInfo.$kind == .Enum or typeInfo.$kind == .Alge {
                  if not isTypeSymbol {
                     self.addErrMess( token.pos, "can't access field -- %s" (token.txt));
                  }
               }
            }
            else {
               self.addErrMess( token.pos,
                                "not found field -- %s" (token.txt));
               typeInfo = Ast.builtinTypeInt;
            }
         }
      }
      case .Map {
         let work = prefixExpType.$itemTypeInfoList[1];
         if not work.equals( Ast.builtinTypeString ##) {
            self.addErrMess(
               token.pos,
               "map key type is not str. (%s)" (work.getTxt(##)) );
         }
         typeInfo = prefixExpType.$itemTypeInfoList[2];
         if not typeInfo.$nilable {
            typeInfo = typeInfo.$nilableTypeInfo;
         }
         return Nodes.ExpRefItemNode.create(
            self.nodeManager, token.pos, self.macroCtrl.isInAnalyzeArgMode(),
            [ typeInfo ], prefixExp, accessNil, token.txt, nil );
      }
      default {
         if prefixExpType.equals( Ast.builtinTypeStem ##) {
            return Nodes.ExpRefItemNode.create(
               self.nodeManager, token.pos, self.macroCtrl.isInAnalyzeArgMode(),
               [ Ast.builtinTypeStem_ ], prefixExp, accessNil, token.txt, nil );
         }
         else {
            self.error( "illegal type -- %s, %s"
                        ( prefixExpType.getTxt(##),
                          prefixExpType.get_kind().$_txt ) );
         }
      }
   }

   if not symbolInfo {
      let prefixScope = prefixExpType.$scope;
      if! prefixScope {
         symbolInfo = _exp.getSymbolInfoField(
            token.txt, true, self.scope, self.scopeAccess );
      }
   }
   
   when! symbolInfo {
      if #prefixSymbolInfoList == 1 {
         let prefixSymbolInfo = prefixSymbolInfoList[1];
         if prefixSymbolInfo.$kind == .Typ {
            if not symbolInfo.$staticFlag and symbolInfo.$kind ~= .Typ
            {
               // クラスシンボルから、 static でないメンバにアクセスした場合エラー
               self.addErrMess(
                  token.pos, "Type can't access this symbol. -- %s" (symbolInfo.$name) );
            }
         }
         elseif symbolInfo.$staticFlag and symbolInfo.$typeInfo.$kind ~= .Method {
            // インスタンスから、 static メンバにアクセスした場合エラー
            self.addErrMess(
               token.pos, "can't access this symbol. -- %s" (token.txt) );
         }
      };

      if not Ast.TypeInfo.isMut( prefixExpType ) and not symbolInfo.$staticFlag and
         symbolInfo.$kind == .Mtd and symbolInfo.$mutable
      {  
         // オブジェクトが immutable で、
         // mutable な method へのアクセスはエラー
         self.addErrMess(
            token.pos,
            "can't access mutable method. -- %s.%s"
            (prefixExpType.getTxt(##), token.txt) );
      }  
   }

   if accessNil {
      if not typeInfo.$nilable {
         typeInfo = typeInfo.$nilableTypeInfo;
      }
      self.helperInfo.useNilAccess = true;
   }

   let mut accessSymbolInfo:Ast.AccessSymbolInfo! = nil;
   //let mut canBeLeft:bool! = nil;
   let mut symbolMutMode = typeInfo.$mutMode;
   when! symbolInfo {
      //canBeLeft = _exp.canBeLeft();
      accessSymbolInfo = new Ast.AccessSymbolInfo(
         symbolInfo, prefixExpType, not accessNil );
      switch mode {
         case .Field, .FieldNil {
            symbolMutMode = symbolInfo.$mutMode;
         }
      }
   }

   if not Ast.TypeInfo.isMut( prefixExpType ) and symbolMutMode == .Mut {           
      typeInfo = self.createModifier( typeInfo, .IMut );
   }

   if typeInfo.equals( builtinFunc.list_unpack ##) or
      typeInfo.equals( builtinFunc.array_unpack ##)
   {
      self.helperInfo.useUnpack = true;
   }

   
   if! getterTypeInfo {
      return Nodes.GetFieldNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ],
         token, accessSymbolInfo, accessNil, prefixExp, _exp );
         //token, canBeLeft, accessNil, prefixExp, _exp );
   }
   else {
      return Nodes.RefFieldNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ],
         token, accessSymbolInfo, accessNil, prefixExp );
         //token, canBeLeft, accessNil, prefixExp );
   }
}

fn TransUnit.analyzeNewAlge(
   firstToken:&Parser.Token,
   algeTypeInfo:&Ast.AlgeTypeInfo, prefix:&Nodes.Node! ) mut : Nodes.NewAlgeValNode
{
   let symbolToken = self.getSymbolToken( .MustNot_ );

   self.checkAlgeComp( symbolToken, algeTypeInfo );   

   if! let valInfo = algeTypeInfo.getValInfo( symbolToken.txt ) {
      let mut argList:&List<&Nodes.Node> = [];
      let argListNode:&Nodes.ExpListNode!;
      if #valInfo.$typeList > 0 {
         self.checkNextToken( "(" );
         argListNode = self.analyzeExpList(
            false, false, nil, valInfo.$typeList, nil );
         argList = (unwrap argListNode).$expList;
         self.checkNextToken( ")" );
      }
      else {
         argListNode = nil;
      }

      if! let matchResult, alt2typeMap, mut newExpNodeList = self.checkMatchType(
         "call", symbolToken.pos, valInfo.$typeList, argListNode, false, true, nil )
      {
         argList = newExpNodeList.$expList;
      }

      if algeTypeInfo.$externalFlag and
         not self.scope.getModuleInfo( algeTypeInfo.getModule().$srcTypeInfo )
      {  
         let fullname = algeTypeInfo.getFullName( self.typeNameCtrl, self.scope, true );
         self.addErrMess( firstToken.pos, "This module not import -- %s"
                          ( fullname ) );
      }

      
      return Nodes.NewAlgeValNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ algeTypeInfo ],
         symbolToken, prefix, algeTypeInfo, valInfo, argList );
   }
   else {
      self.addErrMess( symbolToken.pos, "not found Alge -- %s" (symbolToken.txt) );
      return Nodes.NewAlgeValNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ algeTypeInfo ],
         symbolToken, prefix, algeTypeInfo, new Ast.AlgeValInfo("", []), [] );
   }
}

fn TransUnit.accessSymbol( symbolInfo:&Ast.SymbolInfo ) mut {
   if symbolInfo.$kind == .Fun {
      if self.scope.isClosureAccess( self.moduleScope, symbolInfo ) {
         // 関数の場合、AST 解析中の時点ではクロージャ処理が必要かどうかが
         // 判定できないので、リストに保持して AST 解析後に別途処理する。
         self.closureFunList.insert( new ClosureFun( symbolInfo, self.scope ) );
      }
   }
   else {
      self.scope.accessSymbol( self.moduleScope, symbolInfo );
   }
}


fn TransUnit.analyzeExpSymbol(
   firstToken: &Parser.Token, token: &Parser.Token,
   mode: ExpSymbolMode, prefixExp: &Nodes.Node!, mut skipFlag: bool ) mut : Nodes.Node
{
   let mut exp:Nodes.Node;
   
   if mode == .Field or mode == .Get or
      mode == .FieldNil or mode == .GetNil
   {
      when! prefixExp {
         exp = self.analyzeExpField( firstToken, token, mode, prefixExp );

         let expType = exp.$expType;
         if prefixExp.$expType.isModule() {
            if! let algeType = expType@@@Ast.AlgeTypeInfo {
               let nextToken = self.getToken(##);
               if nextToken.txt == "." {
                  return self.analyzeNewAlge( firstToken, algeType, exp );
               }  
               self.pushback();
            }
         }
      }
      else {
         Util.err( "prefixExp is nil" );
      }
   }
   elseif mode == .Symbol {
      if self.macroCtrl.$macroMode == .AnalyzeArg {
         exp = Nodes.LiteralSymbolNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeSymbol ], token );
      }
      else {
         self.checkSymbolComp( token );

         let! symbolInfo = self.scope.getSymbolTypeInfo(
            token.txt, self.scope, self.moduleScope, self.scopeAccess )
         {
            if self.analyzeMode ~= .Diag {
               let mut work = self.scope;
               while true {
                  print( work, self.globalScope, Ast.rootScope );
                  if work == work.$parent {
                     break;
                  }
                  work = work.$parent;
               }

               self.scope.filterSymbolTypeInfo(
                  self.scope, self.moduleScope, self.scopeAccess,
                  fn ( workSymbolInfo:&Ast.SymbolInfo ): bool {
                     print( "sym", workSymbolInfo.$name );
                     return true;
                  } );
            }
            self.error( "not found type -- " .. token.txt );
         };

         self.accessSymbol( symbolInfo );
         
         let typeInfo = symbolInfo.$typeInfo;

         switch symbolInfo.$kind {
            case .Typ {  
               if! let algeType = typeInfo@@@Ast.AlgeTypeInfo {
                  let nextToken = self.getToken(##);
                  if nextToken.txt == "." {
                     return self.analyzeNewAlge( firstToken, algeType, nil );
                  }  
                  self.pushback();
               }
            }
            case .Var {
               if not symbolInfo.$hasValueFlag {
                  let nsTypeInfo = self.getCurrentNamespaceTypeInfo();
                  if not symbolInfo.$scope.isInnerOf( unwrap nsTypeInfo.$scope ) {
                     self.tentativeSymbol.addAccessSym(
                        new AccessSymPos( symbolInfo, firstToken.pos ) );
                     // self.addErrMess(
                     //    firstToken.pos,         
                     //    "This can't access variable have no value -- %s"
                     //    (symbolInfo.$name) );
                  }
               }
            }           
         }
         
         if typeInfo.equals( Ast.builtinTypeSymbol ##) {
            skipFlag = true;
         }
         if typeInfo.equals( builtinFunc.lns__load ##) {
            self.helperInfo.useLoad = true;
         }

         switch token.txt {
            case "__func__" {
               let funcTypeInfo = self.getCurrentNamespaceTypeInfo();
               self.has__func__Symbol.add( funcTypeInfo );
            }
         }
         
         exp = Nodes.ExpRefNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], 
            new Ast.AccessSymbolInfo( symbolInfo, nil, true ) );
      }
   }
   elseif mode == .Fn {
      exp = self.analyzeDeclFunc(
         .Func, false, false, .Local, false, nil, token, nil );
   }
   else {
      self.error( "illegal mode -- %s" ( mode ) );
   }

   return self.analyzeExpCont( firstToken, exp, skipFlag );
}

/**
代入演算。

@param exp 左辺
@param opeToken 演算子のトークン
@param expTypeList 右辺に期待される型のリスト。
*      左辺の変数の数だけ要素がある。
*/
fn TransUnit.analyzeExpOpSet(
   exp: Nodes.Node, opeToken: &Parser.Token,
   expectTypeList:&List<&Ast.TypeInfo> ) mut : Nodes.ExpSetValNode
{
   exp.setLValue();

   if not exp.canBeLeft() {
      self.addErrMess( exp.$pos,
                       "this node can not be l-value. -- %s"
                       (Nodes.getNodeKindName( exp.$kind ) ) );
   }

   let expList = self.analyzeExpList( false, false, nil, expectTypeList## );

   if not expList.canBeRight() {
      self.addErrMess( expList.$pos,
                       "this node can not be r-value. -- %s"
                       (Nodes.getNodeKindName( expList.$kind ) ) );
   }

   let matchResult, alt2typeMap, newExpListNode, expTypeList =
      self.checkMatchType( "= operator", opeToken.pos, exp.$expTypeList,
                           expList, true, false, nil );

   let mut initSymSet:Set<&Ast.SymbolInfo> = (@);
   
   foreach symbolInfo, index in exp.getSymbolInfo() {
      if not symbolInfo.$mutable and symbolInfo.$hasValueFlag
      {
         if self.validMutControl {
            self.addErrMess( opeToken.$pos,
                             "this is not mutable variable. -- %s"
                             ( symbolInfo.$name ) );
         }
      }

      if index <= #expTypeList and not symbolInfo.$hasValueFlag {
         switch symbolInfo.$kind {
            case .Var {
               if symbolInfo.$typeInfo == Ast.builtinTypeEmpty {
                  // 未初期化変数に型が指定されていないので型推論を行なう
                  
                  let mut expType = expTypeList[ index ];
                  switch expType.$kind {
                     case .DDD {
                        if #expType.$itemTypeInfoList > 0 {
                           expType = expType.$itemTypeInfoList[ 1 ].$nilableTypeInfo;
                        }
                     }
                     case .List, .Array, .Set, .Map {
                        let workPos;
                        if index <= #expList.$expList {
                           workPos = expList.$expList[ index ].$pos;
                        }
                        else {
                           workPos = opeToken.$pos;
                        }
                        self.checkLiteralEmptyCollection(
                           opeToken.pos, symbolInfo.$name, expType );
                     }
                  }
                  symbolInfo.set_typeInfo( expType );
               }
               if not self.tentativeSymbol.regist( symbolInfo ) {
                  self.addErrMess( opeToken.pos,
                                   "can't access in this scope. -- %s"
                                   ( symbolInfo.$name ) );
               }
               initSymSet.add( symbolInfo );
            }
            case .Mbr {
               initSymSet.add( symbolInfo );
            }
         }
      }
      symbolInfo.set_hasValueFlag( true );
   }

   return Nodes.ExpSetValNode.create(
      self.nodeManager, exp.$pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeNone ], exp, expList, initSymSet );
}


fn TransUnit.analyzeExpOp2(
   firstToken: &Parser.Token, mut exp: Nodes.Node, prevOpLevel: int! ) mut : Nodes.Node
{
   while true {
      let nextToken = self.getTokenNoErr();
      let opTxt = nextToken.txt;

      if nextToken.txt == "@@" or nextToken.txt == "@@@" or nextToken.txt ==  "@@=" {
         exp = self.analyzeExpCast( firstToken, opTxt, exp );
      }
      elseif nextToken.kind == Parser.TokenKind.Ope {
         if Parser.isOp2( opTxt ) {
            if opTxt ~= "=" and not exp.canBeRight() {
               self.addErrMess(
                  exp.$pos, "This can't evaluate for '%s' -- %s"
                  ( opTxt, Nodes.getNodeKindName( exp.$kind ) ) );
            }
            let! opLevel = op2levelMap[ opTxt ] {
               self.error( "unknown op -- %s %s" (opTxt, prevOpLevel ) );
            };
            if! prevOpLevel {
               if opLevel <= _exp {
                  self.pushback();
                  return exp;
               }
            }

            let mut expectTypeList:List<&Ast.TypeInfo> = [];
            foreach exp1Type in exp.$expTypeList {
               let mut prefixExpType = exp1Type;
               if prefixExpType.$nilable {
                  prefixExpType = prefixExpType.$nonnilableType;
               }

               let mut expectType = Ast.builtinTypeNone;
               if! prefixExpType.$srcTypeInfo@@@Ast.EnumTypeInfo {
                  expectType = _exp;
               }
               if! prefixExpType.$srcTypeInfo@@@Ast.AlgeTypeInfo {
                  expectType = _exp;
               }
               expectTypeList.insert( expectType );
            }
            
            let mut exp2:&Nodes.Node;

            if opTxt == "=" {
               return self.analyzeExpOpSet( exp, nextToken, expectTypeList );
            }

            exp2 = self.analyzeExp( false, false, opLevel, expectTypeList[ 1 ] );
            if not exp2.canBeRight() {
               self.addErrMess(
                  exp2.$pos, "This can't evaluate for '%s' -- %s"
                  ( opTxt, Nodes.getNodeKindName( exp2.$kind ) ) );
            }
            
            let mut retType = Ast.builtinTypeNone;

            if not exp2.canBeRight() {
               self.addErrMess( exp2.$pos,
                                "this node can not be r-value. -- %s"
                                (Nodes.getNodeKindName( exp2.$kind ) ) );
            }
            
            let mut exp1Type = exp.$expType;
            let exp2Type = exp2.$expType;

            if exp1Type.$kind == .DDD {
               if! let dddType = exp1Type@@@Ast.DDDTypeInfo {
                  exp = Nodes.ExpMultiTo1Node.create(
                     self.nodeManager, exp.$pos,
                     self.macroCtrl.isInAnalyzeArgMode(),
                     [ dddType.$typeInfo.$nilableTypeInfo ], exp );
               }
            }
            if exp2Type.$kind == .DDD {
               if! let dddType = exp2Type@@@Ast.DDDTypeInfo {
                  exp2 = Nodes.ExpMultiTo1Node.create(
                     self.nodeManager, exp2.$pos,
                     self.macroCtrl.isInAnalyzeArgMode(),
                     [ dddType.$typeInfo.$nilableTypeInfo ], exp2 );
               }
            }
            
            switch opTxt {
               case "or" {
                  let is3op;
                  if! let opExpType = exp1Type@@@Ast.AndExpTypeInfo {
                     // exp1Type が AndExpTypeInfo なら and or の 3 項演算なので、
                     // 演算処理を変更する。
                     exp1Type = opExpType.$exp2;
                     is3op = true;
                  }
                  else {
                     is3op = false;
                  }

                  if not exp1Type.equals( Ast.builtinTypeBool ##) and
                     not exp1Type.equals( Ast.builtinTypeStem ##) and
                     not exp1Type.$nilable
                  {
                     if (exp@@@Nodes.ExpOp2Node)$.$op$.txt == "and" {
                        // 本来はこの判定は不要で warning を出すべき。
                        // 現在 ( flag and 1 or 0 ) という式を書いた場合、
                        // flag and 1 の評価結果を暫定的に int としている。
                        // これは and or を使った 3 項演算子で、
                        // 無理矢理に型情報を保持させているための暫定動作。
                        // 本来 flag and 1 の型は stem 等になるはず。
                        // しかし、 stem にすると全体の演算結果の型も stem になってしまい
                        // 意図した型にならない。
                        // このため、ここで warning を出するは誤認識の可能性が高いので
                        // warning は出さない。
                     }
                     else {
                        self.addWarnMess(
                           exp.$pos,
                           "this value never be 'false' -- %s"
                           (exp1Type.getTxt(##)) );
                     }
                  }
                  
                  if exp1Type.equals( exp2Type ##) {
                     retType = exp1Type;
                  }
                  elseif exp1Type.canEvalWith( exp2Type, .SetOp, {}) {
                     // 暗黙キャストの関係にある場合
                     retType = exp1Type;
                  }
                  elseif exp2Type.canEvalWith( exp1Type, .SetOp, {}) {
                     // 暗黙キャストの関係にある場合
                     retType = exp2Type;
                  }
                  elseif exp2Type.equals( Ast.builtinTypeNil ##) {
                     // 片方が nil の場合
                     if is3op or exp1Type.equals( Ast.builtinTypeBool ## ) {
                        retType = exp1Type.$nilableTypeInfo;
                     }
                     else {
                        retType = exp1Type;
                     }
                  }
                  elseif exp1Type.equals( Ast.builtinTypeNil ##) {
                     // 片方が nil の場合
                     retType = exp2Type;
                  }
                  else {
                     // 型に互換性がない場合
                     if exp1Type.$nilable and exp2Type.$nilable {
                        // exp1: nilable, exp2: nilable
                        retType = Ast.builtinTypeStem_;
                     }
                     elseif exp2Type.$nilable {
                        // exp1: not nilable, exp2: nilable
                        retType = Ast.builtinTypeStem_;
                     }
                     elseif exp1Type.$nilable {
                        // exp1: nilable, exp2: not nilable
                        retType = Ast.builtinTypeStem;
                     }
                     else {
                        // exp1: not nilable, exp2: not nilable
                        retType = Ast.builtinTypeStem;
                     }
                  }
                  if retType.$nilable and not exp2Type.$nilable {
                     // exp2 が nilable でなければ、必ず結果は not nilable になる
                     retType = retType.$nonnilableType;
                  }
               }
               case "and" {
                  let workToken = self.getToken(##);
                  self.pushback();

                  if not exp1Type.equals( Ast.builtinTypeBool ##) and
                     not exp1Type.equals( Ast.builtinTypeStem ##) and
                     not exp1Type.$nilable
                  {  
                     self.addWarnMess( exp.$pos, "this value never be 'false'" );
                  }
                  elseif exp2.$kind == Nodes.NodeKind.$LiteralBool {
                     if! let literal = exp2.getLiteral() {
                        if not Nodes.getLiteralObj( literal ) {
                           self.addErrMess(
                              exp2.$pos, "this value never be 'true'" );
                        }
                     }
                  }
                  
                  // if workToken.txt == "or" {
                  //    // A and B or C の場合、 A and B の演算結果は B の型とし、
                  //    // B or C の演算結果に処理を廻す。
                  //    retType = exp2Type;
                  // }
                  // else {
                     if exp1Type.$nilable {
                        if exp2Type.$nilable {
                           retType = exp2Type;
                        }  
                        else {
                           retType = exp2Type.$nilableTypeInfo;
                        }
                     }
                     elseif exp1Type.equals( Ast.builtinTypeBool ##) or
                        exp2Type.equals( Ast.builtinTypeBool ##)
                     {
                        if exp1Type.canEvalWith( exp2Type, .SetOp, {} ) {
                           retType = exp1Type;
                        }
                        elseif exp2Type.canEvalWith( exp1Type, .SetOp, {} ) {
                           retType = exp2Type;
                        }  
                        else {
                           if exp2Type.$nilable {
                              retType = Ast.builtinTypeStem_;
                           }  
                           else {
                              retType = Ast.builtinTypeStem;
                           }  
                        }  
                     }
                     elseif exp1Type.equals( Ast.builtinTypeStem ## ) {
                        retType = Ast.builtinTypeStem;
                     }
                     else {
                        retType = exp2Type;
                     }
                  // }
                  retType = new Ast.AndExpTypeInfo( exp1Type, exp2Type, retType );
               }
               case "<", ">", "<=", ">=" {
                  if Ast.builtinTypeString.canEvalWith( exp1Type, .SetOp, {} ) and
                     Ast.builtinTypeString.canEvalWith( exp2Type, .SetOp, {} ) or
                      ( Ast.builtinTypeInt.canEvalWith( exp1Type, .Comp, {} ) or
                        Ast.builtinTypeReal.canEvalWith( exp1Type, .Comp, {} ) ) and
                     ( Ast.builtinTypeInt.canEvalWith( exp2Type, .Comp, {} ) or
                        Ast.builtinTypeReal.canEvalWith( exp2Type, .Comp, {} ) )
                  {
                     ;
                  }
                  else {
                     self.addErrMess(
                        nextToken.pos,
                        "no numeric type '%s' or '%s'"
                        ( exp1Type.getTxt(self.typeNameCtrl## ),
                          exp2Type.getTxt(self.typeNameCtrl## ) ) );   
                  }
                  retType = Ast.builtinTypeBool;
               }
               case "~=", "==" {
                  if ( not exp1Type.canEvalWith( exp2Type, .SetOp, {} ) and
                       not exp2Type.canEvalWith( exp1Type, .SetOp, {} ) )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "not compatible type '%s' or '%s'"
                        ( exp1Type.getTxt(self.typeNameCtrl## ),
                          exp2Type.getTxt(self.typeNameCtrl## ) ) );
                  }
                  if! exp@@@Nodes.NewAlgeValNode {
                     if #_exp.$paramList > 0 {
                        self.addErrMess( exp.$pos, "can't compare alge." );
                     }
                  }
                  if! exp2@@@Nodes.NewAlgeValNode {
                     if #_exp.$paramList > 0 {
                        self.addErrMess( exp2.$pos, "can't compare alge." );
                     }
                  }
                  if exp1Type.equals( Ast.builtinTypeBool ##) and
                     exp2Type.equals( Ast.builtinTypeBool ##) and
                     ( exp.$kind == Nodes.NodeKind.$LiteralBool or
                       exp2.$kind == Nodes.NodeKind.$LiteralBool )
                  {
                     self.addWarnMess( exp.$pos, "this operation is deprecated." );
                  }
                  
                  retType = Ast.builtinTypeBool;
               }
               case "^", "|", "~", "&", "|<<", "|>>" {
                  if self.targetLuaVer.$hasBitOp == .Cant {
                     self.addErrMess( nextToken.pos,
                                      "this lua version can't use bit operand." );
                  }
                  
                  if not Ast.builtinTypeInt.canEvalWith( exp1Type, .Logical, {} ) or
                     not Ast.builtinTypeInt.canEvalWith( exp2Type, .Logical, {} )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no int type '%s' or '%s'"
                        ( exp1Type.getTxt(##), exp2Type.getTxt(##) ) );
                  }
                  retType = Ast.builtinTypeInt;
               }
               case ".." {
                  if not exp1Type.equals( Ast.builtinTypeString ##) or
                     not exp1Type.equals( Ast.builtinTypeString ##)
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no string type '%s' or '%s'"
                        ( exp1Type.getTxt(##), exp2Type.getTxt(##) ) );
                  }
                  retType = Ast.builtinTypeString;
               }
               case "+", "-", "*", "/", "%" {
                  if ( not Ast.builtinTypeInt.canEvalWith( exp1Type, .Math, {} ) and
                       not Ast.builtinTypeReal.canEvalWith( exp1Type, .Math, {} ) ) or
                      ( not Ast.builtinTypeInt.canEvalWith( exp2Type, .Math, {} ) and
                        not Ast.builtinTypeReal.canEvalWith( exp2Type, .Math, {} ) )
                  {
                     self.addErrMess(
                        nextToken.pos,
                        "no numeric type '%s' or '%s'"
                        ( exp1Type.getTxt(##), exp2Type.getTxt(##) ) );
                  }

                  if exp1Type.equals( Ast.builtinTypeReal ##) or
                     exp2Type.equals( Ast.builtinTypeReal ##)
                  {
                     retType = Ast.builtinTypeReal;
                  }
                  else {
                     retType = Ast.builtinTypeInt;
                  }
               }
               default {
                  self.error( "unknown op " .. opTxt );
               }
            }


            exp = Nodes.ExpOp2Node.create(
               self.nodeManager, firstToken.pos,
               self.macroCtrl.isInAnalyzeArgMode(), [ retType ], nextToken,
               self.nodeManager.MultiTo1( exp ), self.nodeManager.MultiTo1( exp2 ) );
         }
         else {
            self.error( "illegal op" );
         }
      }
      else {
         self.pushback();
         return exp;
      }
   }
}

fn TransUnit.analyzeExpMacroStat( firstToken: &Parser.Token ) mut : Nodes.ExpMacroStatNode {
   let mut expStrList: List<&Nodes.Node> = [];

   self.checkNextToken( "{" );

   let mut braceCount = 0;
   let mut prevToken = firstToken;

   let mut errMessList:List<&Macro.ErrorMess> = [];
   
   while true {
      let token = self.getToken(##);

      if token.txt == ",," or token.txt == ",,," or token.txt == ",,,," {
         let exp = self.analyzeExp( false, true, unwrap op1levelMap[ token.txt ] ## );

         let literalStr = self.macroCtrl.expandSymbol(
            self, token, exp, self.nodeManager, errMessList );
         foreach errMess in errMessList {
            self.addErrMess( errMess.pos, errMess.mess );
         }
         
         expStrList.insert( literalStr );
      }
      else {
         if token.txt == "{" {
            braceCount = braceCount + 1;
         }
         elseif token.txt == "}" {
            if braceCount == 0 {
               break;
            }
            braceCount = braceCount - 1;
         }

         let mut format = "' %s'";
         let mut consecutive;
         if prevToken == firstToken or token.consecutive {
            format = "'%s'";
            consecutive = true;
         }
         else {
            consecutive = false;
         }
         let newToken = new Parser.Token(
            token.kind, string.format( format, token.txt ), token.pos, consecutive ## );
         let literalStr = Nodes.LiteralStringNode.create(
            self.nodeManager, token.pos, self.macroCtrl.isInAnalyzeArgMode(),
            [ Ast.builtinTypeString ], newToken, nil );
         expStrList.insert( literalStr );
      }
      prevToken = token;
   }

   return Nodes.ExpMacroStatNode.create(
      self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
      [ Ast.builtinTypeStat ], expStrList );
}


fn TransUnit.analyzeSuper( firstToken:&Parser.Token ) mut : Nodes.Node {

   self.checkNextToken( "(" );

   let nextToken = self.getToken(##);
   let mut expList:Nodes.ExpListNode! = nil;
   if nextToken.txt ~= ")" {
      self.pushback();
      expList = self.analyzeExpList( false, false ## );
      self.checkNextToken( ")" );
   }

   self.checkNextToken( ";" );


   let classType = self.getCurrentClass();
   
   let currentFunc = self.getCurrentNamespaceTypeInfo();
   if currentFunc.$kind == .Method {
      let superType = classType.get_baseTypeInfo();
      if superType.equals( Ast.headTypeInfo ##) {
         self.addErrMess( firstToken.pos, "This class doesn't have super-class." );
      }     
      else {
         if currentFunc.$rawTxt == "__init" {
            let! superScope = superType.$scope {
               self.error( "not found super scope" );
            };    
            let! superCtorType = superScope.getTypeInfoChild( "__init" ) {
               self.error( "not found super '__init'" );
            }; 
            self.checkMatchValType(
               firstToken.$pos, superCtorType, expList, [], classType );
            return Nodes.ExpCallSuperNode.create(
               self.nodeManager, firstToken.pos,
               self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
               superType, superCtorType, expList );
         }
         else {
            if! let superFunc = (unwrap superType.$scope).getTypeInfoField(
               currentFunc.$rawTxt, true, self.scope, self.scopeAccess )
            {
               if superFunc.$abstractFlag {
                  self.addErrMess( firstToken.pos, "super is abstract." );
               }
               self.checkMatchValType(
                  firstToken.$pos, superFunc, expList, [], classType );
               return Nodes.ExpCallSuperNode.create(
                  self.nodeManager, firstToken.pos,
                  self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ],
                  superType, superFunc, expList );
            }
            self.addErrMess( firstToken.pos, "this is not override method." );
            return self.createNoneNode( firstToken.pos );
         }
      }
   }

   self.addErrMess( firstToken.pos, "super can't call here." );
   return self.createNoneNode( firstToken.pos );
}

fn TransUnit.analyzeUnwrap( firstToken: &Parser.Token ) mut : Nodes.Node {
   let nextToken, continueFlag = self.getContinueToken();

   if not continueFlag or nextToken.txt ~= "!" {
      self.pushback();
      self.pushbackToken( firstToken );
      let exp = self.analyzeExp( false, false ## );
      self.checkNextToken( ";" );
      if not exp.$expType.$nilable {
         self.addErrMess( exp.$pos, "this value is not nilable." );
      }
      return Nodes.StmtExpNode.create(
         self.nodeManager, nextToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], exp );
   }

   self.pushback();
   return self.analyzeDeclVar( .Unwrap, .Local, firstToken );
}

fn TransUnit.analyzeExpUnwrap( firstToken: &Parser.Token ) mut : Nodes.Node {
   //   let expNode = self.analyzeExp( false, opTopLevel ## );
   let expNode = self.analyzeExpOne( false, true ## );
   let nextToken = self.getToken(##);
   let mut insNode: Nodes.Node! = nil;
   if nextToken.txt == "default" {
      insNode = self.analyzeExpOne( false, false ## );
   }
   else {
      self.pushback();
   }

   let mut unwrapType = Ast.builtinTypeStem_;

   let expType = expNode.$expType;
   if not expType.$nilable {
      unwrapType = expType;
      self.addErrMess( expNode.$pos,
                       "this exp is not nilable -- %s" (expType.getTxt(##)) );
   }
   elseif expType.$kind == .DDD {
      if #expType.$itemTypeInfoList > 0 {
         unwrapType = expType.$itemTypeInfoList[ 1 ];
      }
      else {
         unwrapType = Ast.builtinTypeStem;
      }
   }
   else {
      unwrapType = expType.$nonnilableType;
   }

   when! insNode {
      let insType = insNode.$expType;

      if insType.$nilable {
         self.addErrMess( insNode.$pos,
                          "default can't use nilable -- %s" (insType.getTxt(##)) );
      }
      
      let mut alt2type = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
      if not unwrapType.canEvalWith( insType, .SetOp, alt2type )
      {
         if not insType.canEvalWith( unwrapType, .SetOp, alt2type ) {
            unwrapType = Ast.builtinTypeStem;
            // self.addErrMess(
            //    insNode.$pos,
            //    "unmatch type: %s <- %s"
            //    ( unwrapType.getTxt(true##), insType.getTxt(true ## ) ) );
         }
         else {
            unwrapType = insType;
         }
      }
      //unwrapType = insType;
   }

   self.helperInfo.useUnwrapExp = true;

   return Nodes.ExpUnwrapNode.create(
      self.nodeManager, firstToken.pos,
      self.macroCtrl.isInAnalyzeArgMode(), [ unwrapType ], expNode, insNode );
}


fn TransUnit.analyzeExp(
   allowNoneType: bool, skipOp2Flag: bool,
   prevOpLevel: int!, expectType:&Ast.TypeInfo! ) mut : Nodes.Node
{
   let firstToken = self.getToken(##);
   
   fn processsExpectExp( token:&Parser.Token, orgExpectType:&Ast.TypeInfo ): Nodes.Node {
      if! let enumTyepInfo = orgExpectType.$srcTypeInfo@@@Ast.EnumTypeInfo {
         let nextToken = self.getToken(##);
         self.checkEnumComp( nextToken, enumTyepInfo );
         
         if! let valInfo = enumTyepInfo.getEnumValInfo( nextToken.txt ) {
            if orgExpectType.$externalFlag and
               not self.scope.getModuleInfo( orgExpectType.getModule().$srcTypeInfo )
            {  
               let fullname = orgExpectType.getFullName(
                  self.typeNameCtrl, self.scope, true );
               self.addErrMess( token.pos, "This module not import -- %s"
                                ( fullname ) );
            }  
            let mut exp:Nodes.Node = Nodes.ExpOmitEnumNode.create(
               self.nodeManager, token.pos,
               self.macroCtrl.isInAnalyzeArgMode(), [ enumTyepInfo ],
               nextToken, valInfo, enumTyepInfo );
            return self.analyzeExpCont( firstToken, exp, false );
         }

         self.error( "illegal enum val -- %s.%s"
                     (orgExpectType.getTxt(##), nextToken.txt) );
      }
      if! let algeTyepInfo = orgExpectType.$srcTypeInfo@@@Ast.AlgeTypeInfo {
         return self.analyzeNewAlge( firstToken, algeTyepInfo, nil );
      }

      self.error( "illegal type for '.' -- %s" (orgExpectType.getTxt(##) ) );
   }

   fn processsNewExp( token:&Parser.Token ): Nodes.Node {
      let mut exp:Nodes.Node = self.analyzeRefType( .Local, false, false );

      let mut classTypeInfo = exp.$expType;
      switch classTypeInfo.$kind {
         case .Class, .IF {
            if classTypeInfo.equals( Ast.builtinTypeString## ) {
               self.error( "'new' can't use this type -- %s" (classTypeInfo.getTxt(##)));
            }
         }
         default {
            self.error( "'new' can't use this type -- %s" (classTypeInfo.getTxt(##)));
         }
      }
      
      if classTypeInfo.$externalFlag {
         switch classTypeInfo.$accessMode {
            case .Pri, .Local {
               self.addErrMess( token.pos, "Can't access -- %s"
                                (classTypeInfo.$accessMode.$_txt ) );
            }
         }
      }
      if classTypeInfo.$abstractFlag {
         self.addErrMess( token.pos, "abstract class can't new" );
      }
      
      let classScope = classTypeInfo.get_scope();
      let! initTypeInfo = (unwrap classScope).getTypeInfoChild( "__init" ) {
         self.error( "not found __init" );
      }; 
      
      self.checkNextToken( "(" );
      let nextToken = self.getToken(##);
      let mut argList: Nodes.ExpListNode! = nil;
      
      if nextToken.txt ~= ")" {
         self.pushback();
         argList = self.analyzeExpList(
            false, false, nil, initTypeInfo.$argTypeInfoList ## );
         self.checkNextToken( ")" );
      }

      if initTypeInfo.$accessMode == .Pub or
          ( initTypeInfo.$accessMode == .Pro and
            self.scope.getClassTypeInfo().isInheritFrom( classTypeInfo, nil ) ) or
          ( self.scope.getClassTypeInfo() == classTypeInfo ) or
          ( initTypeInfo.$accessMode == .Local and
            initTypeInfo.getModule() == self.moduleType )
      {
         // 次の条件でアクセス可能
         // - pub
         // - pro でサブクラス内
         // - pri で同じクラス内
         // - local で同じモジュール内
      }
      else {
         self.addErrMess(
            token.pos,
            "can't access to __init of %s" (classTypeInfo.getTxt(##)));
      }

      let matchResult, alt2type, newArgList = self.checkMatchValType(
         exp.$pos, initTypeInfo, argList,
         classTypeInfo.$itemTypeInfoList, classTypeInfo );

      if #classTypeInfo.$itemTypeInfoList > 0 {
         if classTypeInfo.$itemTypeInfoList[1].$kind == .Alternate {
            let mut genTypeList:List<&Ast.TypeInfo> = [];
            let mut detect = true;
            foreach altType in classTypeInfo.$itemTypeInfoList {
               if! alt2type[ altType ] {
                  genTypeList.insert( _exp );
               }
               else {
                  self.addErrMess( token.pos, "Can't new generic class. -- %s"
                                   (classTypeInfo.getTxt(##) ));
                  detect = false;
                  break;
               }
            }

            if detect {
               classTypeInfo = Ast.NormalTypeInfo.createGeneric(
                  classTypeInfo, genTypeList, self.moduleType );
            }
         }
      }
      
      exp = Nodes.ExpNewNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ classTypeInfo ],
         exp, initTypeInfo, newArgList );
      exp = self.analyzeExpCont( firstToken, exp, false );

      return exp;
   }

   fn processOp1( token:&Parser.Token ): Nodes.Node, bool {
      // 単項演算
      if token.txt == "`" {
         return self.analyzeExpMacroStat( token ), false;
      }  

      let mut exp = self.analyzeExpOne( false, true, unwrap op1levelMap[ token.txt] ##);
      let mut typeInfo = Ast.builtinTypeNone;
      let mut macroExpFlag = false;
      let expType = exp.$expType;

      if expType.$kind == .DDD {
         self.addErrMess( exp.$pos, "... can't evaluate for '%s'." (token.txt) );
      }

      switch ( token.txt ) {
         case "-" {
            if not expType.equals( Ast.builtinTypeInt ##) and
               not expType.equals( Ast.builtinTypeReal ##)
            {
               self.addErrMess(
                  token.pos,
                  'unmatch type for "-" -- %s' ( expType.getTxt(##) ) );
            }
            typeInfo = expType;
         }
         case "#" {
            if expType.$kind ~= .List and
               expType.$kind ~= .Array and
               not Ast.builtinTypeString.canEvalWith( expType, .SetOp, {} )
            {  
               self.addErrMess(
                  token.pos,
                  'unmatch type for "#" -- %s' ( expType.getTxt(##) ) );
            }  
            typeInfo = Ast.builtinTypeInt;
         }  
         case "not" {
            typeInfo = Ast.builtinTypeBool;
            
            if not expType.$nilable and
               not expType.equals( Ast.builtinTypeBool ##) and
               not expType.equals( Ast.builtinTypeStem ##) and
               expType.$kind ~= .DDD
            {
               self.addErrMess( token.pos, "this 'not' operand never be false" );
            }
         }
         case ",," {
            macroExpFlag = true;
            typeInfo = expType;
         }  
         case ",,," {
            macroExpFlag = true;
            if not expType.equals( Ast.builtinTypeString ##) {
               self.error( "unmatch ,,, type, need string type" );
            }  
            typeInfo = Ast.builtinTypeSymbol;
         }
         case ",,,," {
            macroExpFlag = true;
            if not expType.equals( Ast.builtinTypeSymbol ##) {
               self.error( "unmatch ,,, type, need symbol type" );
            }  
            typeInfo = Ast.builtinTypeString;
         }  
         case "`" {
            typeInfo = Ast.builtinTypeNone;
         }  
         case "~" {
            if not expType.equals( Ast.builtinTypeInt ##) {
               self.addErrMess(
                  token.pos,
                  'unmatch type for "~" -- %s' ( expType.getTxt(##) ) );
            }  
            typeInfo = Ast.builtinTypeInt;
         }
         default {
            self.error( "unknown op1" );
         }
      }  

      if macroExpFlag {
         let nextToken = self.getToken( true );
         if nextToken.txt ~= "~~" {
            self.pushback();
         }  
      }  

      exp = Nodes.ExpOp1Node.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ typeInfo ], token,
         self.macroCtrl.$macroMode, self.nodeManager.MultiTo1( exp ) );   
      return self.analyzeExpOp2( firstToken, exp, prevOpLevel ), true;
   }

   
   let mut token = firstToken;
   let mut exp:Nodes.Node = self.createNoneNode( firstToken.pos );

   if token.txt == "##" {
      if allowNoneType {
         self.addErrMess( token.pos, "illeal syntax -- ##" );
      }
      return Nodes.AbbrNode.create(
         self.nodeManager, token.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeAbbr ] );
   }
   
   if token.kind == Parser.TokenKind.Dlmt {
      if token.txt == "." {
         when! expectType {
            let mut orgExpectType = expectType;
            if orgExpectType.$nilable {
               orgExpectType = orgExpectType.$nonnilableType;
            }
            exp = processsExpectExp( token, orgExpectType );
         }
         else {
            self.error( "illegal '.'" );
         }
      }
      elseif token.txt == "..." {
         return Nodes.ExpDDDNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], token );
      }
      elseif token.txt == '[' or token.txt == '[@' {
         exp = self.analyzeListConst( token );
      }
      elseif token.txt == '(@' {
         exp = self.analyzeSetConst( token );
      }  
      elseif token.txt == '{' {
         exp = self.analyzeMapConst( token );
      }  
      elseif token.txt == "(" {
         exp = self.analyzeExp( false, false ## );
         self.checkNextToken( ")" );
         if not exp.canBeRight() {
            self.addErrMess( exp.$pos,
                             "can't be r-value in paren. -- %s"
                             (Nodes.getNodeKindName( exp.$kind) ) );
         }
         exp = Nodes.ExpParenNode.create(
            self.nodeManager, firstToken.pos,
            self.macroCtrl.isInAnalyzeArgMode(), [ exp.$expType ], exp );
         exp = self.analyzeExpCont( firstToken, exp, false );
      }
   }  

   if token.txt == "new" {
      exp = processsNewExp( token );
   }  

   if token.kind == Parser.TokenKind.Ope and Parser.isOp1( token.txt ) {
      let mut workExp, fin = processOp1( token );
      if fin {
         return workExp;
      }
      exp = workExp;
   }

   if token.kind == Parser.TokenKind.Int {
      exp = Nodes.LiteralIntNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeInt ],
         token, (unwrap tonumber( token.txt ## ) default 0)@@int );
   }  
   elseif token.kind == Parser.TokenKind.Real {
      exp = Nodes.LiteralRealNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeReal ],
         token, (unwrap tonumber( token.txt ## ) default 0.0));
   }  
   elseif token.kind == Parser.TokenKind.Char {
      let num;
      if #token.txt == 1 {
         num = unwrap string.byte( token.txt, 1 ## );
      }  
      else {
         num = unwrap quotedChar2Code[ token.txt.sub( 2, 2 ) ];
      }  
      exp = Nodes.LiteralCharNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeChar ], token, num );
   }  
   elseif token.kind == Parser.TokenKind.Str {
      let mut nextToken = self.getToken(##);
      let expList:&Nodes.ExpListNode!;
      if nextToken.txt == "(" {
         let argNodeList = self.analyzeExpList( false, false, nil ## );
         expList = argNodeList;
         self.checkNextToken( ")" );
         nextToken = self.getToken(##);

         self.checkStringFormat( token.pos, token.txt, argNodeList.$expTypeList );
      }
      else {
         expList = nil;
      }

      exp = Nodes.LiteralStringNode.create(
         self.nodeManager, firstToken.pos, self.macroCtrl.isInAnalyzeArgMode(),
         [ Ast.builtinTypeString ], token, expList );
      token = nextToken;
      if token.txt == "[" or token.txt == "$[" {
         exp = self.analyzeExpRefItem( token, exp, token.txt == "$[" );
      }  
      else {
         self.pushback();
      }  
   }  
   elseif token.kind == Parser.TokenKind.Symb and token.txt == "__line__" {
      let mut lineNo = token.pos.lineNo;
      if self.macroCtrl.$macroMode ~= .None {
         lineNo = self.macroCtrl.$macroCallLineNo;
      }
      exp = Nodes.LiteralIntNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeInt ],
         new Parser.Token( .Int, "%d" (lineNo),
                           token.pos, false, nil ), token.pos.lineNo );
   }  
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "fn" {
      exp = self.analyzeExpSymbol( firstToken, token, .Fn, nil, false );
   }  
   elseif token.kind == Parser.TokenKind.Kywd and token.txt == "unwrap" {
      exp = self.analyzeExpUnwrap( token );
   }  
   elseif token.kind == Parser.TokenKind.Symb {
      exp = self.analyzeExpSymbol(
         firstToken, token, .Symbol, nil, false );
      let symbolInfoList = exp.getSymbolInfo();
      if #symbolInfoList == 1 {
         let symbolInfo = symbolInfoList[ 1 ];
         if symbolInfo.$kind == .Typ {
            exp = self.analyzeRefTypeWithSymbol(
               .Local, false, false, false, exp, false );
            let workToken = self.getToken(##);
            if workToken.txt == "." {
               exp = self.analyzeExpSymbol(
                  firstToken, self.getToken(##), .Field, exp, false );
            }
            else {
               self.pushback();
            }
         }
         // else {
         //    self.scope.accessSymbol( self.moduleScope, symbolInfo );
         //    // self.scope.accessSymbol( self.moduleScope, symbolInfo, .Read );
         //    // self.scope.accessSymbol( self.moduleScope, symbolInfo,
         //    //                          self.getCurrentNamespaceScope() );
         // }
      }
   }  
   elseif token.kind == Parser.TokenKind.Type {
      let! symbolTypeInfo = Ast.sym2builtInTypeMap[ token.txt ] {
         self.error( "unknown type -- %s" ( token.txt ) );
      }; 
      exp = Nodes.ExpRefNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNone ], 
         new Ast.AccessSymbolInfo( symbolTypeInfo, nil, false ) );
   }  
   elseif token.kind == Parser.TokenKind.Kywd and
       ( token.txt == "true" or token.txt == "false" )
   {  
      exp = Nodes.LiteralBoolNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeBool ], token );
   }  
   elseif token.kind == Parser.TokenKind.Kywd and
       ( token.txt == "nil" or token.txt == "null" )
   {  
      exp = Nodes.LiteralNilNode.create(
         self.nodeManager, firstToken.pos,
         self.macroCtrl.isInAnalyzeArgMode(), [ Ast.builtinTypeNil ] );
   }

   if exp.$kind == Nodes.NodeKind.$None {
      self.error( "illegal exp" );
   }

   if skipOp2Flag {
      return exp;
   }

   return self.analyzeExpOp2( firstToken, exp, prevOpLevel );
}
