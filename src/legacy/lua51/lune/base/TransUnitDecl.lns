/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

subfile owner lune.base.TransUnit;

fn TransUnit.analyzeRefType( accessMode: Ast.AccessMode, allowDDD:bool ) mut:
   Nodes.RefTypeNode
{
   let firstToken = self.getToken(##);
   let mut token = firstToken;
   let mut refFlag = false;
   if token.txt == "&" {
      refFlag = true;
      token = self.getToken(##);
   }
   let mut mutFlag = false;
   if token.txt == "mut" {
      mutFlag = true;
      token = self.getToken(##);
   }
   self.checkSymbol( token, .MustNot_ );

   let name = self.analyzeExpSymbol( firstToken, token, .Symbol, nil, true );
   return self.analyzeRefTypeWithSymbol( accessMode, allowDDD, refFlag, mutFlag, name );
}

fn TransUnit.analyzeRefTypeWithSymbol(
   accessMode: Ast.AccessMode, allowDDD:bool,
   refFlag: bool, mutFlag: bool, symbolNode:&Nodes.Node ) mut:
   Nodes.RefTypeNode
{
   let mut typeInfo = symbolNode.$expType;

   let continueToken, continueFlag = self.getContinueToken();
   let mut token = continueToken;
   if continueFlag and token.txt == "!" {
      typeInfo = typeInfo.get_nilableTypeInfo();
      token = self.getToken(##);
   }

   let mut arrayMode = "no";
   while true {
      if token.txt == '[' or token.txt == '[@' {
         if token.txt == '[' {
            arrayMode = "list";
            typeInfo = Ast.NormalTypeInfo.createList(
               accessMode, self.getCurrentClass(), [ typeInfo ], .Mut );
         }   
         else {
            arrayMode = "array";
            typeInfo = Ast.NormalTypeInfo.createArray(
               accessMode, self.getCurrentClass(), [ typeInfo ], .Mut );
         }   
         token = self.getToken(##);
         if token.txt ~= ']' {
            self.pushback();
            self.checkNextToken( ']' );
         }
      }
      elseif token.txt == "<" {
         let mut genericList: List<&Ast.TypeInfo> = [];
         let mut nextToken: &Parser.Token = Parser.getEofToken();
         repeat {
            let typeExp = self.analyzeRefType( accessMode, false );

            genericList.insert( typeExp.$expType );
            nextToken = self.getToken(##);
         } nextToken.txt ~= ",";
         self.checkToken( nextToken, '>' );

         fn checkAlternateTypeCount( count:int ): bool {
            if #genericList ~= count {
               self.addErrMess(
                  symbolNode.$pos,     
                  "generic type count is unmatch. -- %d" (#genericList) );
               return false;
            }
            return true;
         }
         
         switch typeInfo.$kind {
            case .Map {
               if #genericList < 2 {
                  self.addErrMess( symbolNode.$pos, "Key or value type is unknown" );
                  typeInfo = Ast.NormalTypeInfo.createMap(
                     accessMode, self.getCurrentClass(),
                     Ast.builtinTypeStem, Ast.builtinTypeStem, .Mut );
               }
               else {
                  typeInfo = Ast.NormalTypeInfo.createMap(
                     accessMode, self.getCurrentClass(),
                     genericList[ 1 ], genericList[ 2 ], .Mut );
               }
            }
            case .List {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createList(
                     accessMode, self.getCurrentClass(),
                     [ genericList[1] or Ast.builtinTypeStem ], .Mut );
               }
            }
            case .Array {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createArray(
                     accessMode, self.getCurrentClass(),
                     [ genericList[1] or Ast.builtinTypeStem ], .Mut );
               }
            }
            case .Set {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createSet(
                     accessMode, self.getCurrentClass(),
                     [ genericList[1] or Ast.builtinTypeStem ], .Mut );
               }
            }
            case .DDD {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createDDD( genericList[1], false );
               }
            }
            case .Class, .IF {
               if checkAlternateTypeCount( #typeInfo.$itemTypeInfoList ) {
                  foreach itemType, index in genericList {
                     let altType = unwrap typeInfo.$itemTypeInfoList[ index ]@@@Ast.AlternateTypeInfo;
                     if itemType.$nilable {
                        self.addErrMess(
                           symbolNode.$pos,
                           "can't use nilable type -- %s" (itemType.getTxt(##)) );
                     }
                  }
                  typeInfo = Ast.NormalTypeInfo.createGeneric(
                     typeInfo, genericList, self.moduleType );
               }
            }
            case .Box {
               if checkAlternateTypeCount( 1 ) {
                  typeInfo = Ast.NormalTypeInfo.createBox( accessMode, genericList[1] );
               }
            }
            default {
               self.error( string.format( "not support generic: %s",
                                          typeInfo.getTxt(##) ) );
            }
         }
      }   
      else {
         self.pushback();
         break;
      }
      token = self.getToken(##);
   }
   if token.txt == "!" {
      typeInfo = typeInfo.get_nilableTypeInfo();
      token = self.getToken(##);
   }

   if not allowDDD {
      if typeInfo.$kind == .DDD {
         self.addErrMess( symbolNode.$pos,
                          "invalid type. -- '%s'" (typeInfo.getTxt(##) ) );
      }
   }

   if refFlag {
      typeInfo = self.createModifier( typeInfo, .IMut );
   }

   return Nodes.RefTypeNode.create(
      self.nodeManager, symbolNode.$pos, [ typeInfo ],
      symbolNode, refFlag, mutFlag, arrayMode );
}

fn TransUnit.analyzeDeclArgList(
   accessMode:Ast.AccessMode, argList: List<&Nodes.Node> ) mut : &Parser.Token
{
   let mut nextToken: &Parser.Token = Parser.noneToken;
   let mut hasDDDFlag = false;
   repeat {
      nextToken = self.getToken(##);
      if nextToken.txt == ")" {
         break;
      }

      if hasDDDFlag {
         self.addErrMess( nextToken.pos, "Argument exists after '...'." );
      }
      
      let mut mutable = false;
      if nextToken.txt == "mut" {
         mutable = true;
         nextToken = self.getToken(##);
      }
      let mut argName = nextToken;
      if argName.txt == "..." {
         hasDDDFlag = true;
         let workToken, flag = self.getContinueToken();
         self.pushback();

         let mut dddTypeInfo = Ast.builtinTypeDDD;
         if flag and workToken.txt == "<" {
            self.pushbackToken( nextToken );
            let refTypeNode = self.analyzeRefType( accessMode, true );
            dddTypeInfo = refTypeNode.$expType;
         }
         
         argList.insert( 
            Nodes.DeclArgDDDNode.create(
               self.nodeManager, argName.pos, [ dddTypeInfo ] ) );
         self.scope.addLocalVar( false, true, argName.txt, dddTypeInfo, false );
      }
      else {
         argName = self.checkSymbol( argName, .MustNot_ );

         if self.scope.getSymbolTypeInfo( argName.txt, self.scope, self.moduleScope ) {
            self.addErrMess( argName.pos,
                             "shadowing variable -- %s" (argName.txt) );
         }

         self.checkNextToken( ":" );
         let refType = self.analyzeRefType( accessMode, false );
         let arg = Nodes.DeclArgNode.create(
            self.nodeManager, argName.pos, refType.$expTypeList,
            argName, refType );    
         
         self.scope.addLocalVar( false, true, argName.txt, refType.$expType, mutable );
         argList.insert( arg );
      }
      nextToken = self.getToken(##);
   } nextToken.txt ~= ",";

   self.checkToken( nextToken, ")" );

   return nextToken;
}

fn TransUnit.checkOverriededMethod() mut
{
   fn checkOverrideMethodSub(
      pos:&Parser.Position, classScope:&Ast.Scope, scope:&Ast.Scope )
   {  
      scope.filterTypeInfoField(
         true, classScope,
         fn ( symbolInfo:&Ast.SymbolInfo ): bool {
            if symbolInfo.$kind == .Mtd {
               let mut noImp = false;
               if! let impMethodType = classScope.getTypeInfoField(
                  symbolInfo.$name, true, classScope )
               {              
                  if impMethodType.$abstractFlag {
                     noImp = true;
                  }
               }
               else {
                  noImp = true;
               }
               if noImp {
                  self.addErrMess( pos, "not implements method -- " .. symbolInfo.$name );
               }
            }
            return true;
         } );
   }

   foreach classNode, classTypeInfo in self.typeInfo2ClassNode {
      if not classTypeInfo.$abstractFlag {
         // extend のメソッドがオーバーライドされているか確認
         let mut workTypeInfo = classTypeInfo;
         repeat {
            if workTypeInfo ~= Ast.headTypeInfo {
               checkOverrideMethodSub(
                  classNode.$pos,
                  unwrap classTypeInfo.$scope, unwrap workTypeInfo.$scope );
            }  
            foreach ifType in workTypeInfo.$interfaceList {
               checkOverrideMethodSub(
                  classNode.$pos,
                  unwrap classTypeInfo.$scope, unwrap ifType.$scope );
            }  
            workTypeInfo = workTypeInfo.$baseTypeInfo;
         } workTypeInfo == Ast.headTypeInfo;
      }
   }
}

pub class ASTInfo {
   pri let node: Nodes.Node { pub };
   pri let moduleTypeInfo: Ast.TypeInfo { pub };
   pri let moduleSymbolKind: Ast.SymbolKind { pub };
}

pub fn TransUnit.createAST(
   parser: Parser.Parser, macroFlag: bool, moduleName: str! )
   mut : ASTInfo
{
   self.moduleName = unwrap moduleName default "";

   self.registBuiltInScope();

   let mut processInfo = Ast.pushProcessInfo(##);

   let mut moduleTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   let mut moduleSymbolKind = Ast.SymbolKind.Typ;

   when! moduleName {
      apply txt of string.gmatch( moduleName, '[^%.]+' ) {
         // moduleTypeInfo = unwrap self.pushClass(
         //    true, false, nil, nil, false, txt@@str, "pub" );
         moduleTypeInfo = self.pushModule( false, txt, true );
      }
   }
   self.moduleScope = self.scope;
   self.moduleType = moduleTypeInfo;

   
   self.parser = parser;

   let ast:Nodes.Node;

   let mut lastStatement:&Nodes.Node! = nil;
   if macroFlag {
      ast = self.analyzeBlock( .Macro, .Ignore ##);
   }
   else {
      let mut children:List<&Nodes.Node> = [];
      lastStatement = self.analyzeStatementList( children ## );

      let mut token = self.getTokenNoErr();
      if token ~= Parser.getEofToken() {
         self.error( "%s:%d:%d:(%s) not eof -- %s"
                     ( self.parser.getStreamName(),
                       token.pos.lineNo, token.pos.column,
                       token.kind.$_txt, token.txt ) );
      }

      foreach subModule in self.subfileList {
         let! file = frontInterface.searchModule( subModule ) {
            self.error( "not found subfile -- %s" ( subModule ) );
         };

         if self.scope ~= self.moduleScope {
            self.error( "scope does not close" );
         }

         let! mut subParser = Parser.StreamParser.create( file, false, subModule ) {
            self.error( "open error -- %s" (file) );
         };

         self.parser = subParser;

         lastStatement = self.analyzeStatementListSubfile( children );

         token = self.getTokenNoErr();
         if token ~= Parser.getEofToken() {
            Util.err( "unknown:%d:%d:(%s) %s"
                      ( token.pos.lineNo, token.pos.column,
                        token.kind.$_txt, token.txt ) );
         }  
      }

      self.checkOverriededMethod();


      let mut rootNode = Nodes.RootNode.create(
         self.nodeManager, new Parser.Position( 0, 0 ),
         [ Ast.builtinTypeNone ], children, self.useModuleMacroSet,
         self.moduleId, processInfo,
         moduleTypeInfo, nil, self.helperInfo, self.nodeManager,
         self.importModule2ModuleInfo, self.typeId2MacroInfo, self.typeId2ClassMap );
      ast = rootNode;
      if! self.provideNode {
         if lastStatement ~= _exp {
            self.addErrMess( _exp.$pos, "'provide' must be last." );
         }
         rootNode.set_provide( _exp );
         moduleSymbolKind = _exp.$symbol.$kind;
      }
   }

   when! moduleName {
      apply txt of string.gmatch( moduleName, '[^%.]+' ) {
         //self.popClass();
         self.popModule();
      }
   }

   Ast.popProcessInfo();
   

   foreach pos, protoType in self.protoFuncMap {
      self.addErrMess(
         pos, "This function doesn't have body. -- %s" ( protoType.getTxt(##) ) );
   }
   

   foreach mess in self.warnMessList {
      Util.errorLog( mess );
   }
   if #self.errMessList > 0 {
      foreach mess in self.errMessList {
         Util.errorLog( mess );
      }
      Util.err( "has error" );
   }
   if self.ctrl_info.stopByWarning and #self.warnMessList > 0 {
      Util.err( "has error" );
   }
   
   if self.analyzeMode == .Diag or self.analyzeMode == .Complete {
      os.exit( 0 );
   }

   return new ASTInfo( ast, moduleTypeInfo, moduleSymbolKind );
}


fn TransUnit.analyzeDeclMacro(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut pubFlag = false;
   switch accessMode {
      case .Pub {
         pubFlag = true;
      }
      case .Local, .None {
      }
      default {
         self.addErrMess( firstToken.pos,
                          "macro not support this access mode. -- %s"
                          ( accessMode.$_txt ) );
      }
   }
   
   let nameToken = self.getSymbolToken( .Must_ );
   self.checkNextToken( "(" );

   let mut scope = self.pushScope( false ## );

   let mut workArgList: List<&Nodes.Node> = [];
   let mut argList: List<&Nodes.DeclArgNode> = [];
   let mut nextToken = self.analyzeDeclArgList( accessMode, workArgList );
   let mut argTypeList: List<&Ast.TypeInfo> = [];
   foreach argNode, index in workArgList {
      if! argNode@@@Nodes.DeclArgNode {
         argList.insert( _exp );
      }
      else {
         self.error( "macro argument can not use '...'." );
      }
      let argType = argNode.$expType;
      argTypeList.insert( argType );
   }


   self.checkNextToken( "{" );

   nextToken = self.getToken(##);

   let mut stmtBlock : Nodes.BlockNode! = nil;
   if nextToken.txt == "{" {
      let mut parser = new Parser.WrapParser(
         self.parser, "decl macro %s" (nameToken.txt) );

      // foreach symbolInfo, symbol in scope.$symbol2SymbolInfoMap {
      //    scope.add( symbol, symbolInfo.$typeInfo, "local", false );
      // }

      self.macroScope = scope;

      let funcType = Ast.NormalTypeInfo.createFunc(
         false, true, nil, .Func, Ast.headTypeInfo, false, true,
         true, .Global, "_lnsLoad",
         nil, [ Ast.builtinTypeString, Ast.builtinTypeString ],
         [ Ast.builtinTypeStem ], false );
      scope.addLocalVar( false, false, "_lnsLoad", funcType, false );
      
      
      let mut bakParser = self.parser;
      self.parser = parser;
      
      let mut stmtList:List<&Nodes.Node> = [];
      self.prepareTentativeSymbol( self.scope, false );
      self.analyzeStatementList( stmtList, "}" );
      self.checkNextToken( "}" );
      self.finishTentativeSymbol( false );


      self.parser = bakParser;


      self.macroScope = nil;
      stmtBlock = Nodes.BlockNode.create(
         self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], .Macro, stmtList );
   }
   else {
      self.pushback();
   }

   self.popScope();

   
   let mut tokenList: List<&Parser.Token> = [];
   let mut braceCount = 0;

   while true {
      nextToken = self.getToken(##);
      if nextToken.txt == "{" {
         braceCount = braceCount + 1;
      }
      elseif nextToken.txt == "}" {
         if braceCount == 0 {
            break;
         }
         braceCount = braceCount - 1;
      }
      tokenList.insert( nextToken );
   }

   let typeInfo = Ast.NormalTypeInfo.createFunc(
      false, false, scope, .Macro, self.getCurrentNamespaceTypeInfo(),
      false, false, true, accessMode, nameToken.txt, nil, argTypeList ## );
   //self.scope.addLocalVar( false, false, nameToken.txt, typeInfo, false );
   self.scope.addMacro( typeInfo, accessMode );


   let mut declMacroInfo = new Nodes.DeclMacroInfo(
      pubFlag, nameToken, argList, stmtBlock, tokenList ) ;
   let mut node = Nodes.DeclMacroNode.create(
      self.nodeManager, firstToken.pos, [ typeInfo ], declMacroInfo );

   let macroObj = self.macroEval.eval( node );

   self.typeId2MacroInfo[ typeInfo.get_typeId() ] =
      new Nodes.DefMacroInfo( macroObj, declMacroInfo, self.symbol2ValueMapForMacro );
   self.symbol2ValueMapForMacro = {};

   return node;
}

fn TransUnit.analyzeExtend( accessMode:Ast.AccessMode, firstPos: &Parser.Position ) mut :
   &Parser.Token, &Ast.TypeInfo!, &List<&Ast.TypeInfo>, Map<&Ast.TypeInfo,&Ast.TypeInfo>
{
   let mut baseRef:&Nodes.Node! = nil;
   let mut interfaceList:List<&Ast.TypeInfo> = [];
   let mut ifAlt2typeMap:Map<&Ast.TypeInfo,&Ast.TypeInfo> = {};
   
   let mut nextToken = self.getToken(##);
   if nextToken.txt ~= "(" {
      self.pushback();
      let workBaseRefType = self.analyzeRefType( accessMode, false );
      baseRef = workBaseRefType;
      let baseType = workBaseRefType.$expType;
      if baseType.$kind ~= .Class {
         self.addErrMess( workBaseRefType.$pos,
                          "%s is not class." ( baseType.getTxt(##) ) );
      }
      if Ast.isPubToExternal( accessMode ) and 
         not Ast.isPubToExternal( baseType.$accessMode )
      {
         self.addErrMess(
            workBaseRefType.$pos,
            "%s can't be external symbol." ( baseType.getTxt(##) ) );
      }
      nextToken = self.getToken(##);
   }
   if nextToken.txt == "(" {
      while true {
         nextToken = self.getToken(##);
         if nextToken.txt == ")" {
            break;
         }
         self.pushback();
         let ifTypeNode = self.analyzeRefType( accessMode, false );
         let ifType = ifTypeNode.$expType;
         if ifType.$kind ~= .IF {
            self.error( "%s is not interface -- %d"
                        (ifType.getTxt(##), ifType.$kind ) );
         }

         if Ast.isGenericType( ifType ) {
            foreach genType, altType in ifType.createAlt2typeMap(false) {
               ifAlt2typeMap[ altType ] = genType;
            }
         }
         
         
         interfaceList.insert( ifType );
         if Ast.isPubToExternal( accessMode ) and 
            not Ast.isPubToExternal( ifType.$accessMode )
         {
            self.addErrMess( ifTypeNode.$pos,
                             "%s can't be external symbol." ( ifType.getTxt(##) ) );
         }
         
         nextToken = self.getToken(##);
         if nextToken.txt ~= "," {
            if nextToken.txt == ")" {
               break;
            }
            self.error( "illegal token" );
         }
      }
      nextToken = self.getToken(##);
   }

   // interface 間の、メソッドのミスマッチをチェックする
   let mut symbol2TypeInfo:Map<str,&Ast.TypeInfo> = {};
   foreach ifType in interfaceList {
      ifType.$scope$.filterTypeInfoField$(
         true, self.scope,
         fn ( symbolInfo:&Ast.SymbolInfo ): bool {
            if! let ifFuncType = symbol2TypeInfo[ symbolInfo.$name ] {
               if not ifFuncType.canEvalWith( symbolInfo.$typeInfo, "=", ifAlt2typeMap ) {
                  self.addErrMess(
                     firstPos,
                     "mismatch method type -- %s.%s, %s.%s"
                     (symbolInfo.$typeInfo.$parentInfo.getTxt(##), symbolInfo.$name,
                       ifFuncType.$parentInfo.getTxt(##), ifFuncType.getTxt(##)));
               }
            }
            else {
               symbol2TypeInfo[ symbolInfo.$name ] = symbolInfo.$typeInfo;
            }
            return true;
         } );
   }
   


   let mut baseTypeInfo:&Ast.TypeInfo! = nil;
   when! baseRef {
      baseTypeInfo = baseRef.$expType;
   }
   return nextToken, baseTypeInfo, interfaceList, ifAlt2typeMap;
}

fn TransUnit.analyzePushClass(
   classFlag: bool, abstractFlag: bool, firstToken:&Parser.Token, name:&Parser.Token,
   accessMode:Ast.AccessMode, altTypeList:&List<&Ast.AlternateTypeInfo> ) mut :
   &Parser.Token, &Ast.TypeInfo
{
   // altTypeList のシンボルにアクセスできるように、一時的にスコープを掘る
   let mut tempScope = self.pushScope( false## );
   foreach altType in altTypeList {
      tempScope.addAlternate( accessMode, altType.$rawTxt, altType );
   }

   
   let mut nextToken = self.getToken(##);
   let mut baseTypeInfo:&Ast.TypeInfo! = nil;
   let mut interfaceList:&List<&Ast.TypeInfo> = [];
   if nextToken.txt == "extend" {
      nextToken, baseTypeInfo, interfaceList = self.analyzeExtend(
         accessMode, firstToken.pos );

      when! baseTypeInfo {
         if! let initTypeInfo = baseTypeInfo.$scope$.getTypeInfoChild$("__init") {
            if initTypeInfo.$accessMode == .Pri {
               self.addErrMess(
                  firstToken.pos, "The access mode of '__init' is 'pri'." );
            }  
         }; 
      }  
   }


   // 一時的に掘ったスコープを戻す
   self.popScope();
   
   
   let classTypeInfo = self.pushClass(
      classFlag, abstractFlag, baseTypeInfo, interfaceList,
      altTypeList, false, name.txt, accessMode ## );
   
   return nextToken, classTypeInfo;
}

fn TransUnit.analyzeDeclAlternateType(
   token:&Parser.Token, accessMode: Ast.AccessMode ) mut :
   &Parser.Token, List<&Ast.AlternateTypeInfo>
{
   let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
   let mut nextToken = token;
   let mut altNameSet:Set<str> = (@);
   while true {
      let genericSymToken = self.getSymbolToken( .MustNot_ );
      if self.scope.getTypeInfo( genericSymToken.txt, self.scope, true) {
         self.addErrMess( genericSymToken.pos,
                          "shadowing Type -- %s" (genericSymToken.txt) );
      }
      else {
         if altNameSet.has( genericSymToken.txt ) {
            self.addErrMess( genericSymToken.pos,
                             "multiple Type -- %s" (genericSymToken.txt) );
         }
         else {
            altNameSet.add( genericSymToken.txt );
         }
      }
      let mut workToken = self.getToken(##);
      if workToken.txt == "!" {
         self.addErrMess( workToken.pos, "not support nilable" );
         workToken = self.getToken(##);
      }
      let mut baseTypeInfo:&Ast.TypeInfo! = nil;
      let mut interfaceList:&List<&Ast.TypeInfo> = [];
      if workToken.txt == ":" {
         workToken, baseTypeInfo, interfaceList = self.analyzeExtend(
            accessMode, token.pos );
      }
      
      let altType = Ast.NormalTypeInfo.createAlternate(
         genericSymToken.txt, accessMode, self.moduleType, baseTypeInfo, interfaceList );
      altTypeList.insert( altType );

      if workToken.txt == ">" {
         nextToken = self.getToken(##);
         break;
      }
      self.checkToken( workToken, "," );
   }
   return nextToken, altTypeList;
}

fn TransUnit.analyzeDeclProto(
   mut accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut nextToken = self.getToken(##);
   let mut abstractFlag = false;
   if nextToken.txt == "abstract" {
      abstractFlag = true;
      nextToken = self.getToken(##);
   }

   
   if nextToken.txt == "class" or nextToken.txt == "interface" {
      let name = self.getSymbolToken( .MustNot_ );

      // generic の型宣言解析
      let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
      {  
         let mut workToken = self.getToken(##);
         if workToken.txt == "<" {
            workToken, altTypeList = self.analyzeDeclAlternateType(
               workToken, accessMode );
         }  
         self.pushbackToken( workToken );
      }  

      if accessMode == .Local {
         accessMode = .Pri;
      }
      
      nextToken = self.analyzePushClass( nextToken.txt ~= "interface", abstractFlag,
                                         firstToken, name, accessMode, altTypeList );
      self.popClass();
      self.checkToken( nextToken, ";" );
   }
   else {
      self.error( "illegal proto" );
   }
   return self.createNoneNode( firstToken.pos );
}

fn TransUnit.analyzeDeclEnum(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclEnumNode
{
   let name = self.getSymbolToken( .MustNot_ );

   self.checkNextToken( "{" );

   let mut valueList:List<&Parser.Token> = [];
   let mut valueName2Info:Map<str,Ast.EnumValInfo> = {};


   let mut scope = self.pushScope( true ## );

   let mut enumTypeInfo:Ast.EnumTypeInfo! = nil;
   
   let mut nextToken = self.getToken(##);
   let mut number = 0.0;
   let mut prevValTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   let mut valTypeInfo:&Ast.TypeInfo = Ast.headTypeInfo;
   while nextToken.txt ~= "}" {
      let valName = self.checkSymbol(nextToken, .MustNot_ );
      
      nextToken = self.getToken(##);

      let mut enumVal = Ast.EnumLiteral.Real( number );
      switch ( prevValTypeInfo ) {
         case Ast.builtinTypeReal {
         }
         case Ast.builtinTypeInt, Ast.headTypeInfo {
            enumVal = .Int( number@@int );
         }
      }
      
      if nextToken.txt == "=" {
         let exp = self.analyzeExp( false, false ## );
         let! literal = exp.getLiteral() {
            self.error( "illegal enum val" );
         };
         match literal {
            case .Int( val ) {
               enumVal = .Int( val );
               number = val@@real;
               valTypeInfo = Ast.builtinTypeInt;
            }
            case .Real( val ) {
               enumVal = .Real( val );
               number = val;
               valTypeInfo = Ast.builtinTypeReal;
            }
            case .Str( val ) {
               enumVal = .Str( val );
               valTypeInfo = Ast.builtinTypeString;
            }
            default {
               self.error( "illegal enum val -- %s" ( literal.$_txt ) );
            }
         }
         
         nextToken = self.getToken(##);
      }
      else {
         switch ( prevValTypeInfo ) {
            case Ast.headTypeInfo {
               valTypeInfo = Ast.builtinTypeInt;
            }
            case Ast.builtinTypeInt, Ast.builtinTypeReal {
               valTypeInfo = prevValTypeInfo;
            }
            default {
               self.addErrMess( valName.pos,
                                "illegal enum val type -- %s" (valTypeInfo.getTxt(##)) );
            }
         }
      }
      if prevValTypeInfo ~= Ast.headTypeInfo and prevValTypeInfo ~= valTypeInfo
      {        
         self.addErrMess( valName.$pos,
                          "multiple enum val type. %s, %s"
                          (valTypeInfo.getTxt(##), prevValTypeInfo.getTxt(##)) );
      }
      prevValTypeInfo = valTypeInfo;

      if not enumTypeInfo {
         enumTypeInfo = Ast.NormalTypeInfo.createEnum(
            scope, self.getCurrentNamespaceTypeInfo(),
            false, accessMode, name.txt, valTypeInfo );
      }

      when! enumTypeInfo {
         scope.addEnumVal( valName.txt, enumTypeInfo );
         let enumValInfo = new Ast.EnumValInfo( valName.txt, enumVal );
         valueList.insert( valName );

         enumTypeInfo.addEnumValInfo( enumValInfo );
      }

      if nextToken.txt == "}" {
         break;
      }
      self.checkToken( nextToken, "," );
      nextToken = self.getToken(##);
      number = number + 1;
   }

   if not enumTypeInfo {
      enumTypeInfo = Ast.NormalTypeInfo.createEnum(
         scope, self.getCurrentNamespaceTypeInfo(),
         false, accessMode, name.txt, Ast.builtinTypeNone );
   }

   self.popScope();

   self.scope.addEnum( accessMode, name.txt, unwrap enumTypeInfo );

   
   return Nodes.DeclEnumNode.create(
      self.nodeManager, firstToken.pos,
      [ unwrap enumTypeInfo ], accessMode, name, valueList, scope );
}



fn TransUnit.analyzeDeclAlge(
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.DeclAlgeNode
{
   self.helperInfo.useAlge = true;
   
   let name = self.getSymbolToken( .MustNot_ );

   self.checkNextToken( "{" );

   let mut scope = self.scope;
   let mut algeScope = self.pushScope( true ## );

   let mut algeTypeInfo = Ast.NormalTypeInfo.createAlge(
      algeScope, self.getCurrentNamespaceTypeInfo(), false, accessMode, name.txt );
   scope.addAlge( accessMode, name.txt, algeTypeInfo );
   
   let mut nextToken = self.getToken(##);
   while nextToken.txt ~= "}" {
      let valName = self.checkSymbol( nextToken, .MustNot_ );
      if algeTypeInfo.getValInfo( valName.txt ) {
         self.addErrMess( valName.pos, "multiple symbole -- %s" (valName.txt) );
      }
      
      nextToken = self.getToken(##);

      let mut typeInfoList:List<&Ast.TypeInfo> = [];
      if nextToken.txt == "(" {
         while true {
            let typeNode = self.analyzeRefType( .Pub, false );
            typeInfoList.insert( typeNode.$expType );
            nextToken = self.getToken(##);
            if nextToken.txt ~= "," {
               self.checkToken( nextToken, ")" );
               nextToken = self.getToken(##);
               break;
            }
         }
      }
      
      algeScope.addAlgeVal( valName.txt, algeTypeInfo );
      let algeValInfo = new Ast.AlgeValInfo( valName.txt, typeInfoList );
      algeTypeInfo.addValInfo( algeValInfo );

      if nextToken.txt == "}" {
         break;
      }
      self.checkToken( nextToken, "," );
      nextToken = self.getToken(##);
   }

   self.popScope();

   
   return Nodes.DeclAlgeNode.create(
      self.nodeManager, firstToken.pos,
      [ algeTypeInfo ], accessMode, algeTypeInfo, algeScope );
}

fn TransUnit.analyzeAlias(
   accessMode: Ast.AccessMode, firstToken:&Parser.Token ) mut : Nodes.AliasNode
{
   if self.scope ~= self.moduleScope {
      self.addErrMess( firstToken.pos, "alias must use at top scope." );
   }

   let newToken = self.getToken(##);
   self.checkNextToken( "=" );

   let srcToken = self.getToken(##);
   
   let symbolNode = self.analyzeExpSymbol(
      firstToken, srcToken, .Symbol, nil, true );
      
   
   let mut newTypeInfo = Ast.builtinTypeNone;
   let symbolInfoList = symbolNode.getSymbolInfo();
   
   if #symbolInfoList >= 1 {
      let symbolInfo = symbolInfoList[ 1 ];
      if newToken.txt.find( "^_" ##) and not srcToken.txt.find( "^_" ##) or
         not newToken.txt.find( "^_" ##) and srcToken.txt.find( "^_" ## )
      {
         self.addErrMess( firstToken.pos,
                          "alias symbol unmatch. %s %s" (newToken.txt, newToken.txt) );
      }
      else {
         switch symbolInfo.$kind {
            case .Typ, .Fun {
               let aliasSymbolInfo = self.scope.addAlias(
                  newToken.txt, false, accessMode, self.moduleType, symbolInfo );
               newTypeInfo = aliasSymbolInfo.$typeInfo;
            }
            default {
               self.addErrMess(
                  firstToken.pos,
                  "can alias symbol -- %s. (%s)"
                  (srcToken.txt, symbolInfo.$kind.$_txt ) );
            }
         }
      }
   }
   else {
      self.addErrMess( firstToken.pos, "not found symbold -- %s" (srcToken.txt ) );
   }
   self.checkNextToken( ";" );
   
   return Nodes.AliasNode.create(
      self.nodeManager, firstToken.pos,
      [ newTypeInfo ], newToken.txt, symbolNode, newTypeInfo );
}


fn TransUnit.analyzeRetTypeList(
   pubToExtFlag:bool, accessMode:Ast.AccessMode, mut token:&Parser.Token ) mut :
   List<&Ast.TypeInfo>, &Parser.Token
{
   let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
   if token.txt == ":" {
      let mut hasDDDFlag = false;
      while true {
         let refTypeNode = self.analyzeRefType( accessMode, true );
         if hasDDDFlag {
            self.addErrMess( refTypeNode.$pos, "Type exists after '...'." );
         }
         let retType = refTypeNode.$expType;
         if retType.$kind == .DDD {
            hasDDDFlag = true;
         }
         if pubToExtFlag and not Ast.isPubToExternal( retType.$accessMode )
         {  
            self.addErrMess( refTypeNode.$pos,
                             "this is not public type -- %s" (retType.getTxt(##)) );
         }  
         retTypeInfoList.insert( retType );
         token = self.getToken(##);
         if token.txt ~= "," {
            break;
         }  
      }
   }
   return retTypeInfoList, token;
}


fn TransUnit.analyzeDeclForm( accessMode:Ast.AccessMode, firstToken:&Parser.Token ) mut {
   let name = self.getSymbolToken( .MustNot_ );
   self.checkNextToken( "(" );
   let mut argList:List<&Nodes.Node> = [];

   let mut funcBodyScope = self.pushScope( false ## );
   
   let mut nextToken = self.analyzeDeclArgList( accessMode, argList );

   self.checkToken( nextToken, ")" );

   let mut retTypeList:List<&Ast.TypeInfo> = [];
   nextToken = self.getToken(##);
   retTypeList, nextToken = self.analyzeRetTypeList(
      Ast.isPubToExternal( accessMode ), accessMode, nextToken );

   self.checkToken( nextToken, ";" );

   self.popScope();

   let mut argTypeInfoList:List<&Ast.TypeInfo> = [];
   foreach argNode in argList {
      argTypeInfoList.insert( argNode.$expType );
   }

   let formType = Ast.NormalTypeInfo.createFunc(
      false, false, nil, .Func,
      self.getCurrentNamespaceTypeInfo(), false, false,
      true, accessMode, name.txt, nil, argTypeInfoList, retTypeList, false );

   self.scope.add(
      .Fun, false, false, name.txt, formType, accessMode, true, .IMut, false );
}

fn TransUnit.analyzeDecl(
   accessMode: Ast.AccessMode, mut staticFlag: bool,
   firstToken: &Parser.Token, mut token: &Parser.Token ) mut : Nodes.Node!
{
   if not staticFlag {
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken(##);
      }
   }
   let mut overrideFlag = false;
   if token.txt == "override" {
      overrideFlag = true;
      token = self.getToken(##);
   }

   let mut abstractFlag = false;
   if token.txt == "abstract" {
      abstractFlag = true;
      token = self.getToken(##);
   }

   if token.txt == "let" {
      return self.analyzeDeclVar( .Let, accessMode, firstToken );
   }
   elseif token.txt == "fn" {
      return self.analyzeDeclFunc(
         .Func, abstractFlag, overrideFlag,
         accessMode, staticFlag, nil, firstToken, nil );
   }
   elseif token.txt == "class" {
      return self.analyzeDeclClass( abstractFlag, accessMode, firstToken, .Class );
   }
   elseif token.txt == "interface" {
      return self.analyzeDeclClass( true, accessMode, firstToken, .Interface );
   }
   elseif token.txt == "module" {
      return self.analyzeDeclClass( false, accessMode, firstToken, .Module );
   }
   elseif token.txt == "proto" {
      return self.analyzeDeclProto( accessMode, firstToken );
   }
   elseif token.txt == "macro" {
      return self.analyzeDeclMacro( accessMode, firstToken );
   }
   elseif token.txt == "enum" {
      return self.analyzeDeclEnum( accessMode, firstToken );
   }
   elseif token.txt == "alge" {
      return self.analyzeDeclAlge( accessMode, firstToken );
   }
   elseif token.txt == "form" {
      self.analyzeDeclForm( accessMode, firstToken );
      return self.createNoneNode( firstToken.pos );
   }
   elseif token.txt == "alias" {
      return self.analyzeAlias( accessMode, firstToken );
   }

   return nil;
}


fn TransUnit.checkPublic( pos:&Parser.Position, typeInfo:&Ast.TypeInfo ) mut {
   let mut checkedTypeSet:Set<&Ast.TypeInfo> = (@);
   fn checkPub( workType:&Ast.TypeInfo ) {
      if checkedTypeSet.has( workType ) {
         return;
      }
      checkedTypeSet.add( workType );
      if workType.$kind ~= .Array and workType.$kind ~= .List
         and workType.$kind ~= .Set
         and workType.$kind ~= .Map and not Ast.isPubToExternal( workType.$accessMode )
      {     
         self.addErrMess( pos, "not public this type -- %s" ( workType.getTxt(##)) );
      }
      else {
         foreach itemType in workType.$itemTypeInfoList {
            checkPub( itemType );
         }
      }
   }
   checkPub( typeInfo );
}

fn TransUnit.analyzeDeclMember(
   classTypeInfo: &Ast.TypeInfo, accessMode: Ast.AccessMode,
   staticFlag: bool, firstToken: &Parser.Token ) mut: Nodes.DeclMemberNode
{
      let mut nextToken = self.getToken(##);
      let mut mutMode = Ast.MutMode.IMut;
      switch nextToken.txt {
         case "mut" {
            mutMode = .Mut;
            nextToken = self.getToken(##);
         }
         case "allmut" {
            mutMode = .AllMut;
            nextToken = self.getToken(##);
         }
      }
      let varName = self.checkSymbol( nextToken, .MustNot_ );
      let mut token = self.getToken(##);
      let refType = self.analyzeRefType( accessMode, false );
      token = self.getToken(##);

      // accessor
      let mut getterMode = Ast.AccessMode.None;
      let mut getterMutable = true;
      let mut setterMode = Ast.AccessMode.None;
      if token.txt == "{" {

         fn analyzeAccessorMode(): Ast.AccessMode, &Parser.Token
         {        
            let mut mode = Ast.AccessMode.None;
            let mut workToken = self.getToken(##);
            switch workToken.txt {
               case "pub", "pri", "pro" {
                  mode = unwrap Ast.txt2AccessMode( workToken.txt );
                  workToken = self.getToken(##);
                  if workToken.txt == "&" {
                     getterMutable = false;
                     workToken = self.getToken(##);
                  }
               }
               case "non" {
                  workToken = self.getToken(##);
               }
               default {
                  self.addErrMess( workToken.pos,
                                   "access mode is invalid -- %s" (workToken.txt) );
               }
            }
            return mode, workToken;
         }

         getterMode, nextToken = analyzeAccessorMode();
         if nextToken.txt == "," {
            setterMode, nextToken = analyzeAccessorMode();
            if setterMode ~= .None and mutMode == .IMut {
               // immutable なメンバに setter 宣言は出来ない
               self.addErrMess(
                  varName.pos,      
                  "This member can't have setter, this member is immutable. -- %s"
                  (varName.txt) );
            }
         }
         self.checkToken( nextToken, "}" );
         token = self.getToken(##);
      }

      self.checkToken( token, ";" );

      let mut typeInfo = refType.$expType;
      // if Ast.TypeInfo.isMut( typeInfo ) and mutMode == .IMut {
      //    typeInfo = self.createModifier( typeInfo, .IMut );
      // }
      if Ast.TypeInfo.isMut( typeInfo ) and typeInfo.$mutMode ~= mutMode {
         typeInfo = self.createModifier( typeInfo, mutMode );
      }

      if Ast.isPubToExternal( classTypeInfo.$accessMode ) {
         if Ast.isPubToExternal( accessMode ) or
            Ast.isPubToExternal( getterMode ) or
            Ast.isPubToExternal( setterMode )
         {  
            self.checkPublic( refType.$pos, typeInfo );
         }
      }
         
      let symbolInfo = self.scope.addMember(
         varName.txt, typeInfo, accessMode, staticFlag, mutMode );

      return Nodes.DeclMemberNode.create(
         self.nodeManager, firstToken.pos, [ typeInfo ], varName, refType, symbolInfo,
         staticFlag, accessMode, getterMutable, getterMode, setterMode );
   }

fn TransUnit.analyzeDeclMethod(
   classTypeInfo: &Ast.TypeInfo, declFuncMode: DeclFuncMode,
   abstractFlag: bool, overrideFlag: bool, accessMode: Ast.AccessMode,
   staticFlag: bool, firstToken: &Parser.Token, name: &Parser.Token ) mut : Nodes.Node
{
   let mut node = self.analyzeDeclFunc(
      declFuncMode, abstractFlag,
      overrideFlag, accessMode, staticFlag, classTypeInfo, name, name );
   return node;
}


/**
デフォルトコンストラクタの追加処理

@param pos クラスの定義位置
@param classTypeInfo クラス情報
@param classScope クラスのスコープ
@param memberNodeList メンバーノードリスト
@param methodNameSet メソッド名の集合
*/
fn TransUnit.addDefaultConstructor(
   pos:&Parser.Position, classTypeInfo:&Ast.TypeInfo, classScope:Ast.Scope,
   memberNodeList:&List<&Nodes.DeclMemberNode>, methodNameSet:Set<str> ) mut
{
   if classScope.getTypeInfoChild( "__init" ) {
      self.addErrMess( pos, "already declare __init()." );
   }
   
   if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
      let superScope = unwrap classTypeInfo.$baseTypeInfo.$scope;
      let superTypeInfo = unwrap superScope.getTypeInfoChild( "__init" );
      foreach argType in superTypeInfo.$argTypeInfoList {
         if not argType.$nilable {
            self.addErrMess( pos, "not found '__init' decl." );
         }
      }
   }

   let mut memberTypeList:List<&Ast.TypeInfo> = [];
   foreach memberNode in memberNodeList {
      if not memberNode.$staticFlag {
         memberTypeList.insert( memberNode.$expType );
      }
   }
   
   // デフォルトコンストラクタの登録
   let initTypeInfo = Ast.NormalTypeInfo.createFunc(
      false, false, self.pushScope( false ## ),
      .Method, classTypeInfo, true, false, false, .Pub,
      "__init", nil, memberTypeList, [] ## );
   self.popScope();
   classScope.addMethod( initTypeInfo, .Pub, false, false );
   methodNameSet.add( "__init" );

   // メンバーをセット済みにする
   foreach memberNode in memberNodeList {
      if not memberNode.$staticFlag {
         memberNode.$symbolInfo.set_hasValueFlag( true );
      }
   }
}


fn TransUnit.analyzeClassBody(
   classAccessMode: Ast.AccessMode, firstToken: &Parser.Token,
   mode:DeclClassMode, gluePrefix:str!, classTypeInfo: &Ast.TypeInfo,
   name:&Parser.Token, moduleName: &Parser.Token!, mut nextToken:&Parser.Token ) mut :
   Nodes.DeclClassNode, &Parser.Token, Set<str>
{
   let mut memberName2Node: Map<str,&Nodes.DeclMemberNode> = {};
   let mut declStmtList: List<&Nodes.Node> = [];
   let mut fieldList:List<&Nodes.Node> = [];
   let mut memberList:List<&Nodes.DeclMemberNode> = [];
   let mut methodNameSet: Set<str> = (@);
   let mut ptoroStaticMethodFuncTypeList:List<&Ast.TypeInfo> = [];
   let mut initStmtList:List<&Nodes.Node> = [];
   let mut advertiseList:Nodes.AdvertiseInfo[] = [];
   let mut trustList:List<&Ast.TypeInfo> = [];
   let mut node = Nodes.DeclClassNode.create(
      self.nodeManager, firstToken.pos, [ classTypeInfo ],
      classAccessMode, name, gluePrefix, declStmtList, fieldList, moduleName,
      memberList, self.scope, initStmtList, advertiseList, trustList, (@) );
   self.typeInfo2ClassNode[ classTypeInfo ] = node;
   let mut declCtorNode:&Nodes.Node! = nil;
   let mut hasInitBlock = false;
   let mut hasStaticMember = false;

   fn processLet( token:&Parser.Token, staticFlag:bool, accessMode:Ast.AccessMode ) {
      if staticFlag {
         hasStaticMember = true;
      }
      if mode == .Interface {
         self.addErrMess( token.pos, "interface can not have member" );
      }
      if not staticFlag and declCtorNode {
         self.addErrMess(
            token.pos, "member can't declare after '__init' method." );
      }
      elseif staticFlag and hasInitBlock {
         self.addErrMess(
            token.pos, "static member can't declare after '__init' block." );
      }
      let memberNode = self.analyzeDeclMember(
         classTypeInfo, accessMode, staticFlag, token );
      fieldList.insert( memberNode );
      memberList.insert( memberNode );
      memberName2Node[ memberNode.$name.txt ] = memberNode;
   }

   fn processFn( token:&Parser.Token, staticFlag:bool, accessMode:Ast.AccessMode,
                 abstractFlag:bool, overrideFlag:bool ) {
      let nameToken = self.getSymbolToken( .MustNot_ );
      let mut declFuncMode = DeclFuncMode.Class;
      if mode == .Module {
         if gluePrefix {
            declFuncMode = .Glue;
         }
         else {
            declFuncMode = .Module;
         }
      }

      let methodNode = self.analyzeDeclMethod(
         classTypeInfo, declFuncMode, abstractFlag, overrideFlag,
         accessMode, staticFlag, token, nameToken );
      fieldList.insert( methodNode );
      methodNameSet.add( nameToken.txt );
      if nameToken.txt == "__init" {
         declCtorNode = methodNode;
      }
      if staticFlag and methodNode.$kind == Nodes.NodeKind.$None {
         // メソッドのプロトタイプ宣言の場合 none になる。
         if! let funcType = self.scope.getTypeInfoChild( nameToken.txt ) {
            ptoroStaticMethodFuncTypeList.insert( funcType );
         }
      }
   }

   fn processInitBlock() {
      if mode ~= .Class {
         self.error( "%s can not have __init block." (mode) );
      }
      hasInitBlock = true;
      foreach symbolInfo, symbolName in self.scope.$symbol2SymbolInfoMap {
         if symbolInfo.$staticFlag {
            // 一旦全てのメンバを値なし状態にセットする
            symbolInfo.set_hasValueFlag( false );
         }
      }

      self.pushScope( false## );
      self.prepareTentativeSymbol( self.scope, false );
      
      self.checkNextToken( "{" );
      self.analyzeStatementList( initStmtList, "}" );
      self.checkNextToken( "}" );

      self.popScope();
      self.finishTentativeSymbol( false );
   }

   fn processAdvertise() {
      let memberToken = self.getSymbolToken( .MustNot_ );
      nextToken = self.getToken(##);
      let mut prefix = "";
      if nextToken.txt ~= ";" and nextToken.txt ~= "{" {
         prefix = nextToken.txt;
         nextToken = self.getToken(##);
      }
      self.checkToken( nextToken, ";" );
      let! memberNode = memberName2Node[ memberToken.txt ] {
         self.error( "not found member -- %s" (memberToken.txt) );
      };
      advertiseList.insert( new Nodes.AdvertiseInfo( memberNode, prefix ) );
   }

   fn processEnum( token:&Parser.Token, accessMode:Ast.AccessMode ) {
      if accessMode ~= .Pri and
          ( classAccessMode == .Pri or classAccessMode == .Local )
      {
         self.addErrMess( token.pos,
                          "unmatch access mode, class('%s') and enum('%s')"
                          (classAccessMode.$_txt, accessMode.$_txt ) );
      }
      declStmtList.insert( self.analyzeDeclEnum( accessMode, token ) );
   }

   fn processLuneControl() {
      nextToken = self.getToken(##);
      if nextToken.txt == "default__init" {
         declCtorNode = self.createNoneNode( nextToken.pos );
         self.addDefaultConstructor(
            nextToken.pos, classTypeInfo, self.scope, memberList, methodNameSet );
      }
      else {
         self.error( "unknown option -- %s" (nextToken.txt) );
      }
      self.checkNextToken( ";" );
   }
   
   while true {
      let mut token = self.getToken(##);
      if token.txt == "}" {
         break;
      }   
      let! mut accessMode = Ast.txt2AccessMode( token.txt ) {
         accessMode = .Pri;
      }
      then {
         token = self.getToken(##);
      };
      if mode == .Interface and accessMode ~= .Pub {
         self.addErrMess( token.pos, "interface's fields must be 'pub'." );
      }
      
      let mut staticFlag = false;
      if token.txt == "static" {
         staticFlag = true;
         token = self.getToken(##);
      }   
      let mut overrideFlag = false;
      if token.txt == "override" {
         overrideFlag = true;
         token = self.getToken(##);
      }   
      let mut abstractFlag = false;
      if token.txt == "abstract" {
         abstractFlag = true;
         token = self.getToken(##);
      }
      elseif mode == .Interface {
         // 現状 interface にデフォルト処理を書けない。
         abstractFlag = true;
      }
          

      if token.txt == "let" {
         processLet( token, staticFlag, accessMode );
      }
      elseif token.txt == "fn" {
         processFn( token, staticFlag, accessMode, abstractFlag, overrideFlag );
      }
      elseif token.txt == "__init" {
         // __init ブロックからプロトタイプ宣言しかない static メソッドを
         // コールできないので、スコープから外す。
         foreach funcType in ptoroStaticMethodFuncTypeList {
            self.scope.remove( funcType.$rawTxt );
         }
         
         processInitBlock();

         //スコープから外したメソッド情報を戻す。
         foreach funcType in ptoroStaticMethodFuncTypeList {
            self.scope.addFunc(
               funcType, funcType.$accessMode, funcType.$staticFlag, false );
         }
      }
      elseif token.txt == "advertise" {
         processAdvertise();
      }
      elseif token.txt == ";" {
      }
      elseif token.txt == "enum" {
         processEnum( token, accessMode );
      }
      elseif token.txt == "_lune_control" {
         processLuneControl();
      }  
      else {
         self.error( "illegal field" );
      }
   }

   if mode ~= .Module {
      when! declCtorNode {
         foreach memberNode, memberName in memberName2Node {
            if not memberNode.$staticFlag {
               let symbolInfo = unwrap self.scope.getSymbolInfoChild( memberName );
               let typeInfo = symbolInfo.$typeInfo;
               if not symbolInfo.$hasValueFlag and not typeInfo.$nilable {
                  self.addErrMess( declCtorNode.$pos,
                                   "does not set member -- %s.%s"
                                   ( name.txt, memberName ) );
               }  
            }  
         }  
      }

      if hasStaticMember and not hasInitBlock {
         self.addErrMess(
            node.$pos,
            "This class (%s) need __init block for initialize static members." ( name.txt ) );   
      }  

      foreach memberNode, memberName in memberName2Node {
         if memberNode.$staticFlag {
            let symbolInfo = unwrap self.scope.getSymbolInfoChild( memberName );
            let typeInfo = symbolInfo.$typeInfo;
            if not symbolInfo.$hasValueFlag and not typeInfo.$nilable {
               self.addErrMess( memberNode.$pos,
                                "does not set member -- %s" ( memberName ) );
            }  
         }  
      }
   }

   return node, nextToken, methodNameSet;
}

fn TransUnit.analyzeDeclClass(
   classAbstructFlag: bool,  mut classAccessMode: Ast.AccessMode,
   firstToken: &Parser.Token, mode:DeclClassMode ) mut : Nodes.DeclClassNode
{
   let name = self.getSymbolToken( .MustNot_ );

   // generic の型宣言解析
   let mut altTypeList:List<&Ast.AlternateTypeInfo> = [];
   {
      let mut nextToken = self.getToken(##);
      if nextToken.txt == "<" {
         nextToken, altTypeList = self.analyzeDeclAlternateType(
            nextToken, classAccessMode );
      }
      self.pushbackToken( nextToken );
   }

   if classAccessMode == .Local {
      classAccessMode = .Pri;
   }

   let mut moduleName: &Parser.Token! = nil;
   let mut gluePrefix:str! = nil;
   if mode == .Module {
      self.checkNextToken( "require" );
      moduleName = self.getToken(##);
      let nextToken = self.getToken(##);
      if nextToken.txt == "glue" {
         gluePrefix = self.getToken(##).getExcludedDelimitTxt();
      }
      else {
         self.pushback();
      }
   }

   let mut nextToken, classTypeInfo = self.analyzePushClass(
      mode ~= .Interface, classAbstructFlag,
      firstToken, name, classAccessMode, altTypeList );

   let mut classScope = self.scope;

   self.checkToken( nextToken, "{" );


   let mapType = Ast.NormalTypeInfo.createMap(
      .Pub, classTypeInfo, Ast.builtinTypeString,
      self.createModifier( Ast.builtinTypeStem, .IMut ), .IMut );
   if classTypeInfo.isInheritFrom( Ast.builtinTypeMapping, nil ) {
      self.helperInfo.hasMappingClassDef = true;
      
      if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo and
         not classTypeInfo.$baseTypeInfo.isInheritFrom( Ast.builtinTypeMapping, nil ) {
         self.addErrMess(
            firstToken.pos,
            "must extend Mapping at %s" (classTypeInfo.$baseTypeInfo.getTxt(##) ) );
      }
      // _toMap の追加
      let toMapFuncTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, nil, .Method, classTypeInfo,
         true, false, false, .Pub, "_toMap", nil, [], [ mapType ], false );
      classScope.addMethod( toMapFuncTypeInfo, .Pub, false, false );
   }

   
   

   let mut node, workNextToken, mut methodNameSet = self.analyzeClassBody(
      classAccessMode, firstToken, mode, gluePrefix,
      classTypeInfo, name, moduleName, nextToken );
   nextToken = workNextToken;
   

   let parentInfo = classTypeInfo;

   // accessor の生成
   foreach memberNode in node.$memberList {
      let memberType = memberNode.$expType;
      let memberName = memberNode.$name;
      // getter
      let getterName = "get_" .. memberName.txt;
      let mut accessMode = memberNode.$getterMode;
      if accessMode ~= .None and not classScope.getTypeInfoChild( getterName )
      {
         let mutable = memberNode.$getterMutable;
         let mut getterMemberType = memberType;
         if Ast.TypeInfo.isMut( memberType ) and not mutable {
            getterMemberType = self.createModifier( memberType, .IMut );
         }
         let retTypeInfo = Ast.NormalTypeInfo.createFunc(
            false, false, self.pushScope( false ## ),
            .Method, parentInfo, true, false,
            memberNode.$staticFlag, accessMode,
            getterName, nil, [], [ getterMemberType ] ## );
         self.popScope();
         
         classScope.addMethod(
            retTypeInfo, accessMode, memberNode.$staticFlag, false );
         methodNameSet.add( getterName );
      }
      // setter
      let setterName = "set_" .. memberName.txt;
      accessMode = memberNode.$setterMode;
      if memberNode.$setterMode ~= .None and
         not classScope.getTypeInfoChild( setterName )
      {   
         classScope.addMethod(
            Ast.NormalTypeInfo.createFunc(
               false, false, self.pushScope( false ## ),
               .Method, parentInfo, true, false,
               memberNode.$staticFlag, accessMode,
               setterName, nil, [ memberType ], nil, true 
            ), accessMode, memberNode.$staticFlag, true );
         self.popScope();
         methodNameSet.add( setterName );
      }   
   }

   // デフォルトコンストタクタ設定
   let mut ctorAccessMode = Ast.AccessMode.Pub;
   if! let ctorTypeInfo = classScope.getTypeInfoChild( "__init" ) {
      ctorAccessMode = ctorTypeInfo.$accessMode;
   }
   else {
      self.addDefaultConstructor(
         firstToken.pos, classTypeInfo, classScope, node.$memberList, methodNameSet );
   }


   // advertise の処理
   foreach advertiseInfo in node.$advertiseList {
      let mut memberType = advertiseInfo.$member.$expType;
      switch memberType.$kind {
         case .Class, .IF {
            foreach child in memberType.$children {
               if child.$kind == .Method and
                  child.$accessMode ~= .Pri and
                  not child.$staticFlag
               {
                  let childName = advertiseInfo.$prefix .. child.getTxt(##);
                  if not methodNameSet.has( childName ) {
                     let impMtdType = Ast.NormalTypeInfo.createAdvertiseMethodFrom(
                        classTypeInfo, child );
                     classScope.addMethod(
                        impMtdType, child.$accessMode, child.$staticFlag, false );
                  }
               }
            }
         }
         default {
            self.error( "advertise member type is illegal -- %s"
                        (advertiseInfo.$member.$name) );
         }
      }
   }


   if classTypeInfo.isInheritFrom( Ast.builtinTypeMapping, nil ) {
      // Mapping の制限チェック
      let mut checkedTypeMap:Map<&Ast.TypeInfo,bool> = {};
      foreach memberNode in node.$memberList {
         let memberType = memberNode.$expType;
         //if not isAvailableMapping( memberType, checkedTypeMap ) {
         if not Ast.NormalTypeInfo.isAvailableMapping( memberType, checkedTypeMap ) {
            self.addErrMess(
               memberNode.$pos,
               "member type is not Mapping -- %s" ( memberType.getTxt(##)) );
         }
      }

      // _fromMap の追加
      let fromMapFuncTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, nil, .Func, classTypeInfo,
         true, false, true, .Pub, "_fromMap",
         nil, [ mapType.$nilableTypeInfo ],
         [ classTypeInfo.$nilableTypeInfo, Ast.builtinTypeString.$nilableTypeInfo ],
         true );
      classScope.addMethod( fromMapFuncTypeInfo, ctorAccessMode, true, false );

      // _fromStem の追加
      let fromStemFuncTypeInfo = Ast.NormalTypeInfo.createFunc(
         false, false, nil, .Func, classTypeInfo,
         true, false, true, .Pub, "_fromStem",
         nil, [ Ast.builtinTypeStem_ ],
         [ classTypeInfo.$nilableTypeInfo, Ast.builtinTypeString.$nilableTypeInfo ],
         true );  
      classScope.addMethod( fromStemFuncTypeInfo, ctorAccessMode, true, false );
   }
   
   // fn checkOverrideMethodSub( scope:&Ast.Scope ) {
   //    scope.filterTypeInfoField(
   //       true, classScope,
   //       fn ( symbolInfo:&Ast.SymbolInfo ): bool {
   //          if symbolInfo.$kind == .Mtd {
   //             let mut noImp = false;
   //             if! let impMethodType = classScope.getTypeInfoField(
   //                symbolInfo.$name, true, classScope )
   //             {              
   //                if impMethodType.$abstractFlag {
   //                   noImp = true;
   //                }
   //             }
   //             else {
   //                noImp = true;
   //             }
   //             if noImp {
   //                self.addErrMess( firstToken.pos,
   //                                 "not implements method -- " .. symbolInfo.$name );
   //             }
   //          }
   //          return true;
   //       } );
   // }

   // if not classAbstructFlag {
   //    // extend のメソッドがオーバーライドされているか確認
   //    let mut workTypeInfo = classTypeInfo;
   //    repeat {
   //       if workTypeInfo ~= Ast.headTypeInfo {
   //          checkOverrideMethodSub( unwrap workTypeInfo.$scope );
   //       }  
   //       foreach ifType in workTypeInfo.$interfaceList {
   //          checkOverrideMethodSub( unwrap ifType.$scope );
   //       }
   //       workTypeInfo = workTypeInfo.$baseTypeInfo;
   //    } workTypeInfo == Ast.headTypeInfo;
   // }

   self.popClass();

   return node;
}



pri fn TransUnit.addMethod(
   classTypeInfo: &Ast.TypeInfo, methodNode: Nodes.Node, name: str ) mut
{
   let mut classNodeInfo = unwrap self.typeInfo2ClassNode[ classTypeInfo ];

   classNodeInfo.$outerMethodSet.add( name );
   classNodeInfo.$fieldList.insert( methodNode );
}



fn TransUnit.analyzeDeclFunc(
   declFuncMode: DeclFuncMode, abstractFlag: bool, overrideFlag: bool,
   mut accessMode: Ast.AccessMode,
   mut staticFlag: bool, mut classTypeInfo: &Ast.TypeInfo!,
   firstToken: &Parser.Token, mut name: &Parser.Token! ) mut : Nodes.Node
{
   let mut token = self.getToken(##);
   if! name {
      name = self.checkSymbol( _exp, .MustNot_ );
   }
   else {
      if token.txt ~= "(" {
         name = self.checkSymbol( token, .MustNot_ );
         token = self.getToken(##);
      }
   }
   let mut needPopFlag = false;
   if token.txt == "." {
      needPopFlag = true;

      let className = (unwrap name).txt;
      
      classTypeInfo = self.scope.getTypeInfoChild( className );

      when! classTypeInfo {
         self.pushClass(
            classTypeInfo.$kind == .Class,
            classTypeInfo.$abstractFlag, nil, nil, [], false, className,
            classTypeInfo.$accessMode ## );
      }
      else {
         self.error( "not found class -- %s" (className) );
      }

      name = self.getSymbolToken( .MustNot_ );
      token = self.getToken(##);

      if accessMode == .Local {
         accessMode = .Pri;
      }
   }


   let mut isCtorFlag = false;
   let mut kind = Nodes.NodeKind.$DeclConstr;
   let mut typeKind = Ast.TypeInfoKind.Func;
   if classTypeInfo {
      if not staticFlag {
         typeKind = .Method;
      }
      switch (unwrap name).txt {
         case "__init" {
            isCtorFlag = true;
            kind = Nodes.NodeKind.$DeclConstr;
            foreach symbolInfo, symbolName in self.scope.$symbol2SymbolInfoMap {
               if not symbolInfo.$staticFlag {
                  // 一旦全てのメンバを値なし状態にセットする
                  symbolInfo.set_hasValueFlag( false );
               }  
            }
         }
         case "__free" {
            kind = Nodes.NodeKind.$DeclDestr;
            if not self.targetLuaVer.$canUseMetaGc {
               self.addErrMess(
                  firstToken.pos, "this lua version is not support __free." );
            }
         }
         default {
            kind = Nodes.NodeKind.$DeclMethod;
         }
      }
   }
   else {
      kind = Nodes.NodeKind.$DeclFunc;
      if not staticFlag {
         staticFlag = true;
      }
   }

   let orgStaticFlag = staticFlag;
   if declFuncMode == .Module {
      // module で Lua の外部モジュールを宣言した場合、
      // モジュール名でメンバにアクセスできるように、
      // 強制的に static にする。
      staticFlag = true;
   }

   let mut funcName = "";
   when! name {
      funcName = name.txt;

      if kind == Nodes.NodeKind.$DeclFunc {
         switch accessMode {
            case .Pub, .Global {
               if self.scope ~= self.moduleScope {
                  self.addErrMess(
                     firstToken.pos,      
                     "'global' or 'pub' function must exist top scope." );
               }
            }
         }
      }
   }
   
  
   let mut funcBodyScope = self.pushScope( false ## );
   let mut altTypeList:List<&Ast.TypeInfo> = [];
   // generic 宣言
   if token.txt == "<" {
      token, altTypeList = self.analyzeDeclAlternateType( token, accessMode );
      foreach altType in altTypeList {
         funcBodyScope.addAlternate( accessMode, altType.$rawTxt, altType );
      }

   }

   self.checkToken( token, "(" );

   
   let mut argList:List<&Nodes.Node> = [];
   token = self.analyzeDeclArgList( accessMode, argList );
   let mut argTypeList:List<&Ast.TypeInfo> = [];
   foreach argNode in argList {
      argTypeList.insert( argNode.$expType );
   }

   self.checkToken( token, ")" );
   token = self.getToken(##);

   let mut mutable = false;
   if token.txt == "mut" {
      token = self.getToken(##);
      mutable = true;
   }

   let mut pubToExtFlag = Ast.isPubToExternal( accessMode );

   let mut alt2typeMap = Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap( false );
   when! classTypeInfo {
      alt2typeMap = classTypeInfo.createAlt2typeMap( false );
      
      if kind == Nodes.NodeKind.$DeclMethod or
         kind == Nodes.NodeKind.$DeclConstr or
         kind == Nodes.NodeKind.$DeclDestr
      {
         let mut workClass = classTypeInfo;
         if kind == Nodes.NodeKind.$DeclConstr or kind == Nodes.NodeKind.$DeclDestr {
            mutable = true;
         }  
         // self シンボルを登録

         if not Ast.isPubToExternal( workClass.$accessMode ) {
            pubToExtFlag = false;
         }

         
         if Ast.TypeInfo.isMut( workClass ) and not mutable {
            workClass = self.createModifier( workClass, .IMut );
         }
         if not staticFlag {
            self.scope.add(
               .Var, false, true, "self",
               workClass, .Pri, false,
               mutable and Ast.MutMode.Mut or Ast.MutMode.IMut, true );
         }

         if not workClass.$abstractFlag and abstractFlag {
            self.addErrMess( firstToken.pos,
                             "no abstract class does not have abstract method" );
         }
      }
   }


   let mut retTypeInfoList:List<&Ast.TypeInfo> = [];
   retTypeInfoList, token = self.analyzeRetTypeList( pubToExtFlag, accessMode, token );

   let namespaceInfo = self.getCurrentNamespaceTypeInfo();
   
   let typeInfo = Ast.NormalTypeInfo.createFunc(
      abstractFlag, false, funcBodyScope,
      typeKind, namespaceInfo,
      false, false, staticFlag, accessMode,
      funcName, altTypeList, argTypeList, retTypeInfoList, mutable );

   when! name {
      let mut parentScope = funcBodyScope.get_parent();
      if accessMode == .Global {
         //parentScope = Ast.rootScope;
         parentScope = self.globalScope;
      }

      if! let prottype = parentScope.getTypeInfoChild( typeInfo.$rawTxt ) {
         let matchFlag, err = Ast.TypeInfo.checkMatchType(
            prottype.$argTypeInfoList, argTypeList, false, nil, alt2typeMap );
         if matchFlag ~= .Match {
            self.addErrMess( name.pos, "mismatch functype: " .. err );
         }

         if self.protoFuncMap[ prottype ] {
            self.protoFuncMap[ prottype ] = nil;     
         }
         else {
            if not prottype.$autoFlag {
               self.addErrMess( token.pos, "multiple define -- %s" (name.txt) );
            }
         }
      }
      

      if kind == Nodes.NodeKind.$DeclFunc {
         parentScope.addFunc( typeInfo, accessMode, staticFlag, mutable );
      }
      else {
         parentScope.addMethod( typeInfo, accessMode, staticFlag, mutable );
      }
   }

   if overrideFlag {
      // オーバーライドの型チェック
      if not name {
         self.addErrMess( firstToken.pos, "can't override anonymous func" );
      };
      if! let overrideType =
         self.scope.$parent.getTypeInfoField( funcName, false, funcBodyScope )
      {
         if overrideType.get_accessMode() ~= accessMode {
            self.addErrMess( firstToken.pos, "mismatch override accessMode -- %s,%s,%s"
                             ( funcName, overrideType.get_accessMode().$_txt,
                               accessMode.$_txt ) );
         }  
         if overrideType.get_staticFlag() ~= staticFlag {
            self.addErrMess( firstToken.pos,
                             "mismatch override staticFlag -- " .. funcName );
         }  
         if overrideType.get_kind() ~= .Method {
            self.addErrMess( firstToken.pos, "mismatch override kind -- %s, %d"
                             ( funcName, overrideType.get_kind() ) );
         }
         if overrideType.$mutMode ~= typeInfo.$mutMode {
            self.addErrMess( firstToken.pos, "mismatch mutable -- %s" ( funcName ) );
         }

         if #overrideType.$itemTypeInfoList ~= #altTypeList {
            self.addErrMess( firstToken.pos,
                             "mismatch altTypeList -- %d, %d"
                             (#overrideType.$itemTypeInfoList, #altTypeList) );
         }
         else {
            foreach alterType, index in overrideType.$itemTypeInfoList {
               alt2typeMap[ alterType ] = altTypeList[ index ];
            }
         }
         
         if not overrideType.canEvalWith( typeInfo, "=", alt2typeMap ) {
            self.addErrMess( firstToken.pos, "mismatch method type -- %s" (funcName));
         }
      }
      else {
         //Ast.dumpScope( self.scope.$parent, "" );
         self.addErrMess( firstToken.pos, "not found override -- " .. funcName );
      }
   }
   else {
      when! name {
         if name.txt ~= "__init" {
            if self.scope.$parent.getTypeInfoField( name.txt, false, funcBodyScope ) {
               // override 宣言していないのに、オーバーライドしている場合エラー
               self.addErrMess( firstToken.pos, "mismatch override --" .. funcName );
            }  
            else {
               if! let ifFunc =
                  self.scope.$parent.getSymbolInfoIfField( name.txt, funcBodyScope )
               {  
                  if not ifFunc.$typeInfo.canEvalWith( typeInfo, "=", alt2typeMap ) {
                     self.addErrMess( firstToken.pos,
                                      "mismatch method type -- %s" (funcName));
                  }
               }  
            }  
         }
      }
   }

   let mut node = self.createNoneNode( firstToken.pos );
   let mut needNode = false;

   // 関数 Body の解析
   let mut body:Nodes.BlockNode! = nil;
   if token.txt == ";" {
      // プロトタイプ宣言
      if declFuncMode == .Module or declFuncMode == .Glue {
         needNode = true;
      }
      else {
         if not abstractFlag {
            self.protoFuncMap[ typeInfo ] = firstToken.pos;
         }
      }
   }
   else {
      needNode = true;
      if abstractFlag {
         self.addErrMess( token.pos, "abstract method can't have body." );
      }

      funcBodyScope.addLocalVar(
         false, false, "__func__", Ast.builtinTypeString, false );
      //self.has__func__Symbol = false;


      when! classTypeInfo {
         if! let overrideType =
            self.scope.$parent.getTypeInfoField( funcName, false, funcBodyScope )
         {
            if not overrideType.$abstractFlag {
               funcBodyScope.addLocalVar( false, false, "super", overrideType, false );
            }
         }
      }
      
      
      self.pushback();
      body = self.analyzeBlock( .Func, .Ignore, funcBodyScope );
      when! body {
         if #retTypeInfoList ~= 0
         {
            let breakKind = body.getBreakKind( .Return );
            if retTypeInfoList[ 1 ] ~= Ast.builtinTypeNeverRet {        
               switch breakKind {
                  case .Return, .NeverRet {
                  }  
                  default {
                     self.addErrMess( firstToken.pos,
                                      "This funcion doesn't have return." );
                  }  
               }  
            }
            else {
               if breakKind ~= .NeverRet {
                  self.addErrMess( firstToken.pos,
                                   "This funcion must be never return. -- %s"
                                   (breakKind.$_txt ));
               }              
            }
         }
         if isCtorFlag {
            when! classTypeInfo {
               if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
                  // Super クラスを持っている場合
                  if #body.$stmtList == 0 or
                     body.$stmtList[ 1 ].$kind ~= Nodes.nodeKind.ExpCallSuper
                  {                 
                     self.addErrMess( body.$pos, "__init must call super() with first." );
                  }
               }
            }
         }
      }
   }

   if needNode {
      let mut info = new Nodes.DeclFuncInfo(
         classTypeInfo, name, argList, orgStaticFlag, accessMode,
         body, retTypeInfoList, self.has__func__Symbol.has( typeInfo ) );
      // node = self.createNode( kind, firstToken.pos, [ typeInfo ], info );

      switch ( kind ) {
         case Nodes.NodeKind.$DeclConstr {
            node = Nodes.DeclConstrNode.create(
               self.nodeManager, firstToken.pos, [ typeInfo ], info );
         }
         case Nodes.NodeKind.$DeclDestr {
            node = Nodes.DeclDestrNode.create(
               self.nodeManager, firstToken.pos, [ typeInfo ], info );
         }
         case Nodes.NodeKind.$DeclMethod {
            node = Nodes.DeclMethodNode.create(
               self.nodeManager, firstToken.pos, [ typeInfo ], info );
         }
         case Nodes.NodeKind.$DeclFunc {
            node = Nodes.DeclFuncNode.create(
               self.nodeManager, firstToken.pos, [ typeInfo ], info );
         }
         default {
            self.error( "illegal kind -- %d" (kind) );
         }
      }
   }
   self.has__func__Symbol.del( typeInfo );

   self.popScope();

   if needPopFlag {
      self.addMethod( unwrap classTypeInfo, node, funcName );
      self.popClass();
   }

   return node;
}

fn TransUnit.createExpListNode(
   pos:&Parser.Position, followOn:bool, newExpList:&List<&Nodes.Node> ) mut:
   Nodes.ExpListNode
{
   // 引数リストを更新する
   let mut newExpTypeList:List<&Ast.TypeInfo> = [];
   foreach expNode, listIndex in newExpList {
      newExpTypeList.insert( expNode.$expType );
   }     
   // 最終ノードが複数の値を持つ場合は、その型を追加する
   foreach expType, listIndex in newExpList[ #newExpList ].$expTypeList {
      if listIndex ~= 1 {
         newExpTypeList.insert( expType );
      }     
   }
   return Nodes.ExpListNode.create(
      self.nodeManager, pos, newExpTypeList, newExpList, followOn );
}


class LetVarInfo {
   pub let mutable:bool;
   pub let varName: &Parser.Token;
   pub let varType:Nodes.RefTypeNode!;
}


/*
let で宣言している変数シンボル、型、初期値の型情報を解析して返す。

スコープへの変数シンボルの登録は行なわない。

@param firstPos エラー発生時に使用する位置情報
@param initMutable 変数の mutable 初期値。
   true を指定した場合、 mut を明示しなくても mutable として扱う。
@param accessMode アクセスモード
@param unwrapFlag unwrap して変数に初期値を格納するかどうか。
@return List<&Ast.TypeInfo> 型推論解決後の変数の型情報リスト
@return LetVarInfo[] 変数のシンボル等の情報リスト
@return List<&Ast.TypeInfo> unwrap 前の初期値のリスト
@return Nodes.ExpListNode! 初期値の ExpListNode。初期値が与えられていない場合は nil。
*/
fn TransUnit.analyzeLetAndInitExp(
   firstPos:&Parser.Position, initMutable:bool,
   accessMode:Ast.AccessMode, unwrapFlag:bool ) mut :
   List<&Ast.TypeInfo>, &List<&LetVarInfo>, &List<&Ast.TypeInfo>, Nodes.ExpListNode!
{
   /** 宣言している変数の型リスト */
   let mut typeInfoList : List<&Ast.TypeInfo> = [];
   let mut letVarList:List<&LetVarInfo> = [];

   let mut nextToken = Parser.getEofToken();
   
   repeat {
      // 変数名と : で明示している型情報を取得。
      let mut mutable = initMutable;
      nextToken = self.getToken(##);
      if nextToken.txt == "mut" {
         mutable = true;
         nextToken = self.getToken(##);
      }
      let varName = self.checkSymbol( nextToken, .MustNot_ );
      nextToken = self.getToken(##);
      let mut typeInfo = Ast.builtinTypeEmpty;
      if nextToken.txt == ":" {
         let refType = self.analyzeRefType( accessMode, false );
         letVarList.insert( new LetVarInfo( mutable, varName, refType ) );
         typeInfo = refType.$expType;
         nextToken = self.getToken(##);
      }
      else {
         letVarList.insert( new LetVarInfo( mutable, varName, nil ) );
      }
      if not typeInfo.equals( Ast.builtinTypeEmpty ## ) and
         Ast.TypeInfo.isMut( typeInfo ) and not mutable
      {     
         typeInfo = self.createModifier( typeInfo, .IMut );
      }
      typeInfoList.insert( typeInfo );
   } nextToken.txt ~= ",";

   // 初期値の式を取得
   let mut expList:Nodes.ExpListNode! = nil;
   if nextToken.txt == "=" {
      expList = self.analyzeExpList( false, false ## );
      if not expList {
         self.error( "expList is nil" );
      }
   }
   else {
      self.pushback();
   }

   // unwrap 前の型
   let mut orgExpTypeList: List<&Ast.TypeInfo> = [];
   
   // 型推論の解決と、宣言されている型と初期値との整合性を確認
   when! expList {
      let mut updateExpList = false;
      let mut newExpList:List<&Nodes.Node> = [];
      foreach exp, index in expList.$expList {
         newExpList.insert( exp ) ;
         if not exp.canBeRight() {
            self.addErrMess( exp.$pos,
                             "this node(%d) can not be r-value. -- %s"
                             (index, Nodes.getNodeKindName( exp.$kind ) ) );
         }
      }

      //  初期化値の型を反映する
      let mut expTypeList: List<&Ast.TypeInfo> = [];
      foreach expType, index in expList.$expTypeList {
         let processedFlag = false;
         if index == #expList.$expTypeList and expType.$kind == .DDD
         {
            // 最終要素が ... の場合、残りの変数宣言の分 stem をセットする
            let mut dddItemType = Ast.builtinTypeStem_;
            if #expType.$itemTypeInfoList > 0 {
               dddItemType = expType.$itemTypeInfoList[ 1 ];
            }
            for subIndex = index, #letVarList {
               let argType = typeInfoList[ subIndex ];
               let mut checkType = dddItemType;
               if unwrapFlag {
                  checkType = dddItemType.$nonnilableType;
               }
               if not argType.equals( Ast.builtinTypeEmpty ## ) and
                  not argType.canEvalWith( checkType, "=", {} )
               {
                  self.addErrMess(
                     firstPos,
                     "unmatch value type (index = %d) %s) <- %s"
                     ( subIndex, argType.getTxt( true ## ), dddItemType.getTxt(##) ));
               }
               expTypeList.insert( checkType );
               orgExpTypeList.insert( dddItemType );
            }
         }
         else {
            // 最終要素でない場合
            let mut expTypeInfo: &Ast.TypeInfo = expType;
            if expType.$kind == .DDD {
               let itemList = expType.$itemTypeInfoList;
               if #itemList > 0 {
                  expTypeInfo = itemList[ 1 ];
               }
               else {
                  expTypeInfo = Ast.builtinTypeStem_;
               }
            }
            orgExpTypeList.insert( expTypeInfo );
            if expTypeInfo == Ast.builtinTypeNil and index <= #typeInfoList {
               // 初期値が nil の場合、 orgExpTypeList は代入先の nilable 型とする
               orgExpTypeList[ index ] = typeInfoList[ index ].$nilableTypeInfo;
            }
            if unwrapFlag and expTypeInfo.$nilable {
               expTypeInfo = expTypeInfo.$nonnilableType;
            }

            if index <= #typeInfoList {
               let varType = typeInfoList[ index ];
               let mut alt2typeMap =
                  Ast.CanEvalCtrlTypeInfo.createDefaultAlt2typeMap(false);
               if varType.$kind == .Box {
                  alt2typeMap = varType.createAlt2typeMap( true );
               }
               Ast.CanEvalCtrlTypeInfo.setupNeedAutoBoxing( alt2typeMap );

               if not varType.equals( Ast.builtinTypeEmpty ## ) and
                  not varType.canEvalWith( expTypeInfo, "=", alt2typeMap ) and
                  not (unwrapFlag and expTypeInfo.equals( Ast.builtinTypeNil ## ))
               {               
                  self.addErrMess(
                     firstPos,
                     "unmatch value type (index:%d) %s <- %s"
                     (index,
                       varType.getTxt( true ## ),
                       expTypeInfo.getTxt( true ## )));
               }
               if varType == Ast.builtinTypeBox {
                  typeInfoList[ index ] = Ast.NormalTypeInfo.createBox(
                     accessMode, expTypeInfo );
               }
               //if varType.$kind == .Box and expTypeInfo.$srcTypeInfo.$kind ~= .Box {
               if Ast.CanEvalCtrlTypeInfo.canAutoBoxing( varType, expTypeInfo ) {
                  // auto boxing
                  updateExpList = true;
                  let exp = newExpList[ index ];
                  newExpList[ index ] = Nodes.BoxingNode.create(
                     self.nodeManager, exp.$pos, [ varType ], exp );
                  if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 1 ) {
                     self.addErrMess( exp.$pos,
                                      "auto boxing error %s <- %s"
                                      ( varType.getTxt(##), expTypeInfo.getTxt(##)) );  
                  }
               }
               else {
                  if not Ast.CanEvalCtrlTypeInfo.finishNeedAutoBoxing( alt2typeMap, 0 ) {
                     self.addErrMess(
                        newExpList[ index ].$pos,
                        "illegal auto boxing error %s <- %s"
                        ( varType.getTxt(##), expTypeInfo.getTxt(##)) );  
                  }
               }
            }
            expTypeList.insert( expTypeInfo );
         }
      }
      if updateExpList {
         // 引数リストを更新する
         expList = self.createExpListNode( expList.$pos, expList.$followOn, newExpList );
      }
      // 宣言する変数の数より初期値が少ない場合、
      // nil で初期化されるため変数が nilable かどうか判定
      foreach varType, index in typeInfoList {
         if index > #expTypeList {
            if not varType.$nilable {
               self.addErrMess(
                  firstPos,
                  "unmatch value type (index:%d) %s <- nil"
                  (index, varType.getTxt( true ## )));
            }
         }
      }
      // 変数の型を、型推論で初期値から設定
      foreach typeInfo, index in expTypeList {
         if #typeInfoList < index or
            typeInfoList[ index ].equals( Ast.builtinTypeEmpty ## )
         {
            if Ast.TypeInfo.isMut( typeInfo ) and
               index <= #letVarList and not letVarList[ index ].mutable
            {
               typeInfoList[ index ] = self.createModifier( typeInfo, .IMut );
            }
            else {
               typeInfoList[ index ] = typeInfo;
            }
         }
      }
   }

   return typeInfoList, letVarList, orgExpTypeList, expList;
}

fn TransUnit.analyzeDeclVar(
   mode:Nodes.DeclVarMode,
   accessMode: Ast.AccessMode, firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut unwrapFlag = false;
   let mut token, continueFlag = self.getContinueToken();
   if continueFlag and token.txt == "!" {
      unwrapFlag = true;
   }
   else {
      self.pushback();
      if mode ~= .Let {
         Util.log( "need '!'" );
      }
   }

   if accessMode == .Pub {
      if self.scope ~= self.moduleScope {
         self.addErrMess( firstToken.pos, "'pub' variable must exist top scope." );
      }
   }

   let mut typeInfoList, mut letVarList, mut orgExpTypeList, mut expList =
      self.analyzeLetAndInitExp( firstToken.pos, mode == .Sync, accessMode, unwrapFlag );
   

   if mode ~= .Sync and self.macroScope {
      foreach letVarInfo, index in letVarList {
         let typeInfo = typeInfoList[ index ];
         
         self.symbol2ValueMapForMacro[ letVarInfo.varName.txt ] =
            new Nodes.MacroValInfo( nil, typeInfo);
      }
   }

   let mut syncScope:Ast.Scope = self.scope;
   if mode == .Sync {
      syncScope = self.pushScope( false ## );
   }


   let mut symbolInfoList: List<&Ast.SymbolInfo> = [];
   
   let mut varList:List<&Nodes.VarInfo> = [];
   let mut syncSymbolList:List<&Nodes.VarInfo> = [];
   foreach letVarInfo, index in letVarList {
      let varName = letVarInfo.varName;
      let typeInfo = typeInfoList[ index ];
      let varInfo = new Nodes.VarInfo(
         varName, letVarInfo.varType, typeInfo );
      varList.insert( varInfo );

      if Ast.isPubToExternal( accessMode ) {
         self.checkPublic( varName.pos, typeInfo );
      }
      
      if not letVarInfo.varType and typeInfo.equals( Ast.builtinTypeNil ## ) {
         self.addErrMess(
            varName.pos, 'need type -- %s' ( varName.txt ) ); 
      }
      if mode == .Sync {
         // スコープに登録する前に、シンボルを検索
         if self.scope.getTypeInfo( varName.txt, self.scope, true ) {
            syncSymbolList.insert( varInfo );
         }
      }
      // スコープに変数を登録
      if mode == .Let or mode == .Sync {
         if mode == .Let {
            if self.scope.getTypeInfo( varName.txt, self.scope, true ) {
               self.addErrMess( varName.pos,
                                "shadowing variable -- %s" (varName.txt) );
            }
         }
         let mut orgExpType = Ast.builtinTypeStem_;
         if not unwrapFlag {
            orgExpType = Ast.builtinTypeEmpty;
         }
         if index <= #orgExpTypeList {
            orgExpType = orgExpTypeList[ index ];
         }
         
         let mut hasValue = false;
         if not unwrapFlag and orgExpType ~= Ast.builtinTypeEmpty or
            unwrapFlag and not orgExpType.$nilable
         {        
            hasValue = true;
         }
         self.scope.addVar( accessMode, varName.txt, typeInfo,
                            letVarInfo.mutable, hasValue );
      }
      symbolInfoList.insert(
         unwrap self.scope.getSymbolInfo( varName.txt, self.scope, true ) );
   }

   let mut unwrapBlock: Nodes.BlockNode! = nil;
   let mut thenBlock: Nodes.BlockNode! = nil;
   if unwrapFlag {
      let mut scope = self.pushScope( false ## );

      // unwrap ブロックに変数を登録
      foreach letVarInfo, index in letVarList {
         self.addLocalVar(
            letVarInfo.varName.pos, false, true, "_" .. letVarInfo.varName.txt,
            orgExpTypeList[ index ], false ## );
      }
      
      unwrapBlock = self.analyzeBlock( .LetUnwrap, .Start, scope );
      self.popScope();

      // unwrap ブロック後には変数にデータがセットされているものとする。
      if mode == .Let or mode == .Sync {
         when! unwrapBlock {
            let breakKind = unwrapBlock.getBreakKind( .Normal );
            foreach letVarInfo in letVarList {
               let symbolInfo =
                  unwrap self.scope.getSymbolInfoChild( letVarInfo.varName.txt );
               if breakKind ~= .None {
                  self.tentativeSymbol.checkAndExclude( symbolInfo );
                  symbolInfo.set_hasValueFlag( true );
               }
               else {
                  if not self.tentativeSymbol.checkAndExclude( symbolInfo ) {
                     if not symbolInfo.$hasValueFlag {
                        self.addErrMess(
                           unwrapBlock.$pos,       
                           "This variable isn't set -- " .. (symbolInfo.$name) );
                     }
                  }
               }
            }
         }
      }

      token = self.getToken( true );
      if token.txt == "then" {
         thenBlock = self.analyzeBlock( .LetUnwrap, .Finish, scope );
      }
      else {
         self.pushback();
         self.finishTentativeSymbol( true );
      }
   }

   let mut syncBlock: Nodes.BlockNode! = nil;
   if mode == .Sync {
      self.checkNextToken( "do" );
      syncBlock = self.analyzeBlock( .LetUnwrap, .Simple, syncScope );
      self.popScope();
   }

   self.checkNextToken( ";" );

   let mut node = Nodes.DeclVarNode.create(
      self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ], mode, accessMode, false,
      varList, expList, symbolInfoList, typeInfoList, unwrapFlag, unwrapBlock,
      thenBlock, syncSymbolList, syncBlock );

   return node;
}

/**
if! の解析。

@param firstToken if 部分のトークン
@return if! のノード
*/
fn TransUnit.analyzeIfUnwrap( firstToken: &Parser.Token ) mut : Nodes.IfUnwrapNode
{
   let mut nextToken = self.getToken(##);
   let mut typeInfoList:List<&Ast.TypeInfo> = [];
   let mut varNameList:str[] = [];

   let mut expNodeList:List<&Nodes.Node> = [];
   
   if nextToken.txt == "let" {  
      let mut workTypeInfoList, mut letVarList, mut orgExpTypeList, expList =
         self.analyzeLetAndInitExp( firstToken.pos, false, .Local, true );
      typeInfoList = workTypeInfoList;
      foreach exp in (unwrap expList).$expList {
         expNodeList.insert( exp );
      }
      foreach varInfo in letVarList {
         varNameList.insert( varInfo.varName.txt );
      }
   }
   else {
      self.pushback();
      let exp = self.analyzeExp( false, false ## );
      expNodeList.insert( exp );
      if exp.$expType.$nilable {
         typeInfoList.insert( exp.$expType.$nonnilableType );
      }
      else {
         typeInfoList.insert( exp.$expType );
      }
      varNameList.insert( "_exp" );
   }

   let mut scope = self.pushScope( false ## );

   foreach expType, index in typeInfoList {
      if index > #varNameList {
         break;
      }
      let varName = varNameList[ index ];
      self.addLocalVar( firstToken.pos, false, true, varName, expType, false ## );
   }
   
   let block = self.analyzeBlock( .IfUnwrap, .Start, scope );

   self.popScope();

   let mut elseBlock:Nodes.BlockNode! = nil;
   nextToken = self.getToken( true );
   if nextToken.txt == "else" {
      elseBlock = self.analyzeBlock( .IfUnwrap, .Finish ## );
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   let mut hasCond = false;
   foreach expNode, index in expNodeList {
      if index ~= #expNodeList {
         if Ast.isConditionalbe( expNode.$expType ) {
            hasCond = true;
            break;
         }
      }
      else {
         foreach expType in expNode.$expTypeList {
            if Ast.isConditionalbe( expType ) {
               hasCond = true;
               break;
            }
         }
      }
   }
   if not hasCond {
      self.addErrMess( firstToken.pos, "This condition never be false" );
   }
   
   return Nodes.IfUnwrapNode.create(
      self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ],
      varNameList, expNodeList, block, elseBlock );
}

fn TransUnit.analyzeWhen( firstToken: &Parser.Token ) mut : Nodes.Node
{
   let mut nextToken, continueFlag = self.getContinueToken();
   let mut varNameList:str[] = [];

   if not ( continueFlag and nextToken.txt == "!" ) {
      self.pushback();
      self.addErrMess( nextToken.pos, "'when' need '!'" );
   }

   let symListNode = self.analyzeExpList( false, false ## );

   let mut scope = self.pushScope( false ## );

   let mut expNodeList:List<&Nodes.Node> = [];
   
   foreach expNode in symListNode.$expList {
      expNodeList.insert( expNode );
      if! let refNode = expNode@@@Nodes.ExpRefNode {
         if expNode.$expType.$nilable {
            let symbolInfo = refNode.$symbolInfo;
            varNameList.insert( refNode.$token.txt );
            self.addLocalVar(
               firstToken.pos, false, expNode.canBeLeft(), refNode.$token.txt,
               expNode.$expType.$nonnilableType, symbolInfo.$mutable, true );
         }
         else {
            self.addErrMess( expNode.$pos,
                             "This type isn't nilable. -- %s"
                             ( expNode.$expType.getTxt(##) ) );
         }
      }
      else {
         self.addErrMess( expNode.$pos,
                          "'when' support only local variables or arguments." );
      }
   }

   let block = self.analyzeBlock( .IfUnwrap, .Start, scope );

   self.popScope();

   let mut elseBlock:Nodes.BlockNode! = nil;
   nextToken = self.getToken( true );
   if nextToken.txt == "else" {
      elseBlock = self.analyzeBlock( .When, .Finish ## );
   }
   else {
      self.finishTentativeSymbol( false );
      self.pushback();
   }

   return Nodes.WhenNode.create(
      self.nodeManager, firstToken.pos, [ Ast.builtinTypeNone ],
      varNameList, expNodeList, block, elseBlock );
}
