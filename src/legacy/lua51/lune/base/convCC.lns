/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Ver;
import lune.base.Ast;
import lune.base.Nodes;
import lune.base.Util;
import lune.base.TransUnit;
import lune.base.frontInterface;
import lune.base.LuaMod;
import lune.base.LuaVer;
import lune.base.Parser;

let cTypeInt = "lune_int_t";
let cTypeStem = "lune_stem_t";
let cTypeStemP = "lune_stem_t *";
let cTypeEnvP = "lune_env_t *";
let cTypeVarP = "lune_var_t *";

class SymbolParam {
   pub let index:int;
}

class PubVerInfo {
   pub let staticFlag: bool;
   pub let accessMode: Ast.AccessMode;
   pub let mutable:bool;
   pub let typeInfo: &Ast.TypeInfo;
};

class PubFuncInfo {
   pub let accessMode: Ast.AccessMode;
   pub let typeInfo: &Ast.TypeInfo;
}

pub enum ConvMode {
   /** lns ソースを実行する */
   Exec,
   /** lua への変換を行なう */
   Convert,
   /** lua への変換と、 Meta 情報生成を行なう */
   ConvMeta,
}

class ModuleInfo extend (Ast.ModuleInfoIF){
   let assignName:str {pub};
   let modulePath:str {pub};
}

pub class Opt {
   pub let node:&Nodes.Node;
}

class RoutineInfo {
   let funcInfo:&Ast.TypeInfo {pub};
   let mut blockDepth:int {pub};

   pub fn __init( funcInfo:&Ast.TypeInfo ) {
      self.funcInfo = funcInfo;
      self.blockDepth = 1;
   }
   pub fn pushDepth() mut {
      self.blockDepth = self.blockDepth + 1;
   }
   pub fn popDepth() mut {
      self.blockDepth = self.blockDepth - 1;
   }
}


fn isStemType( valType:&Ast.TypeInfo ) : bool {
   let expType = valType.$srcTypeInfo;
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return false;
      }
      case Ast.builtinTypeReal {
         return false;
      }
      // case Ast.builtinTypeBool {
      //    return false;
      // }
      default {
         if! let enumType = expType@@@Ast.EnumTypeInfo {
            return isStemType( enumType.$valTypeInfo );
         }
         return true;
      }
   }
}

fn isStemRet( retTypeList:&List<&Ast.TypeInfo> ) : bool {
   switch #retTypeList {
      case 0 {
         return false;
      }
      case 1 {
         return isStemType( retTypeList[ 1 ] );
      }
   }
   return true;
}


fn getCType( valType:&Ast.TypeInfo, varFlag:bool ) : str {
   let expType = valType.$srcTypeInfo;
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return cTypeInt;
      }
      case Ast.builtinTypeReal {
         return "lune_real_t";
      }
      // case Ast.builtinTypeBool {
      //    return "lune_bool_t";
      // }
      default {
         if! let enumType = expType@@@Ast.EnumTypeInfo {
            return getCType( enumType.$valTypeInfo, varFlag );
         }
         if varFlag {
            return cTypeVarP;
         }
         return cTypeStemP;
      }
   }
}

fn getCRetType( retTypeList:&List<&Ast.TypeInfo> ) : str {
   switch #retTypeList {
      case 0 {
         return "void";
      }
      case 1 {
         return getCType( retTypeList[ 1 ], false );
      }
   }
   return cTypeStemP;
}


fn getCTypeForSym( symbol:&Ast.SymbolInfo ) : str, bool {
   let typeTxt;
   if symbol.$isSetFromClosuer {
      typeTxt = cTypeVarP;
   }
   else {
      typeTxt = getCType( symbol.$typeInfo, symbol.$kind == .Var );
   }
   return typeTxt, typeTxt == cTypeVarP;
}


fn isStemSym( symbolInfo:&Ast.SymbolInfo ): bool {
   if symbolInfo.$isSetFromClosuer {
      return true;
   }
   let typeTxt, isStem = getCTypeForSym( symbolInfo );
   return isStem;
}

/** 変換プロセス */
enum ProcessMode {
   /** プロトタイプ宣言 */
   Prototype,
   /** 大域変数 */
   WideScopeVer,
   /** モジュール初期化 */
   InitModule,
   /** 内部関数 */
   Form,
   /** 即値 */
   Immediate,
   /** メイン */
   Main,   
}

class ModuleCtrl {
   pri let mut typeInfo2ModuleName: Map<&Ast.TypeInfo,ModuleInfo>;

   pub fn __init() {
      self.typeInfo2ModuleName = {};
   }
   pub fn add( moduleTypeInfo:&Ast.TypeInfo, moduleInfo:ModuleInfo ) mut {
      self.typeInfo2ModuleName[ moduleTypeInfo ] = moduleInfo;
   }

   pub fn getFullName( typeInfo:&Ast.TypeInfo ): str {
      let mut enumName = typeInfo.getFullName( self.typeInfo2ModuleName, true );
      return "%s" ( (enumName.gsub( "[&@]", "" ).gsub( "%.", "_" ) ) );
   }


   pub fn getClassCName( classType:&Ast.TypeInfo ) : str
   {
      return self.getFullName( classType );
   }

   pub fn getMethodCName( methodTypeInfo:&Ast.TypeInfo ) : str
   {
      return "u_mtd_%s_%s" ( self.getClassCName( methodTypeInfo.$parentInfo ),
                             methodTypeInfo.$rawTxt );
   }

   pub fn getCallMethodCName( methodTypeInfo:&Ast.TypeInfo ) : str
   {
      return "u_call_mtd_%s_%s" ( self.getClassCName( methodTypeInfo.$parentInfo ),
                                  methodTypeInfo.$rawTxt );
   }
}

class convFilter extend Nodes.Filter<Opt> (Util.SourceStream) {
   pri let streamName: str;
   pri let mut stream: oStream;
   pri let mut streamQueue: List<oStream>;

   pri let mut moduleCtrl:ModuleCtrl;
   
   pri let mut indentQueue: List<int>;
   pri let mut curLineNo: int;
   // クラス TypeId → TypeInfo
   pri let mut classId2TypeInfo: Map<int,&Ast.TypeInfo>;
   // クラス TypeId → Member Node List
   pri let mut classId2MemberList: Map<int,List<&Nodes.DeclMemberNode>>;
   // enum TypeId -> EnumTypeInfo
   pri let mut pubEnumId2EnumTypeInfo: Map<int,&Ast.EnumTypeInfo>;
   // enum TypeId -> AlgeTypeInfo
   pri let mut pubAlgeId2AlgeTypeInfo: Map<int,&Ast.AlgeTypeInfo>;
   // public 変数名 → 変数情報
   pri let mut pubVarName2InfoMap: Map<str,PubVerInfo>;
   // public 関数名 → 関数情報
   pri let mut pubFuncName2InfoMap: Map<str,PubFuncInfo>;
   pri let mut needIndent: bool;
   pri let mut macroDepth: int;
   pri let moduleTypeInfo: &Ast.TypeInfo;
   pri let moduleSymbolKind: Ast.SymbolKind;
   pri let mut needModuleObj: bool;
   pri let ast:Nodes.RootNode;
   pri let mut routineInfoQueue:List<RoutineInfo>;
   pri let mut currentRoutineInfo:RoutineInfo;
   pri let mut processMode:ProcessMode;
   pri let mut duringDeclFunc:bool;

   
   pri let mut processingNode: &Nodes.Node!;
   pri let mut processedNodeSet: Set<&Nodes.Node>;
   pri let mut accessSymbolSet: Util.OrderedSet<&Ast.SymbolInfo>;
   pri let mut literalNode2AccessSymbolSet:Map<&Nodes.Node,&Util.OrderedSet<&Ast.SymbolInfo>>;

   fn pushRoutine( funcType:&Ast.TypeInfo ) mut {
      self.currentRoutineInfo = new RoutineInfo( funcType );
      self.routineInfoQueue.insert( self.currentRoutineInfo );
   }

   fn popRoutine() mut {
      self.currentRoutineInfo = self.routineInfoQueue[ #self.routineInfoQueue - 1 ];
      self.routineInfoQueue.remove( ## );
   }

   pub fn __init( streamName: str, stream: oStream, ast:&TransUnit.ASTInfo )
   {
      super();
      self.processingNode = nil;
      self.processedNodeSet = (@);
      self.accessSymbolSet = new Util.OrderedSet<&Ast.SymbolInfo>();
      self.literalNode2AccessSymbolSet = {};

      self.duringDeclFunc = false;

      self.processMode = .Prototype;

      self.routineInfoQueue = [];
      self.currentRoutineInfo = new RoutineInfo( Ast.builtinTypeNone );

      self.moduleTypeInfo = ast.$moduleTypeInfo;
      self.moduleSymbolKind = ast.$moduleSymbolKind;
      
      //Util.errorLog( "__init: %s" (mode) );
      self.ast = unwrap ast.$node@@@Nodes.RootNode;
      self.needModuleObj = true;
      self.indentQueue = [ 0 ];
      self.macroDepth = 0;
      self.streamName = streamName;
      self.stream = stream;
      self.streamQueue = [];
      self.curLineNo = 1;
      self.classId2TypeInfo = {};
      self.classId2MemberList = {};
      self.pubVarName2InfoMap = {};
      self.pubFuncName2InfoMap = {};
      self.pubEnumId2EnumTypeInfo = {};
      self.pubAlgeId2AlgeTypeInfo = {};
      self.needIndent = false;

      self.moduleCtrl = new ModuleCtrl();

      self.pushRoutine( ast.$moduleTypeInfo );
   }

   fn pushStream() mut : Util.memStream {
      self.streamQueue.insert( self.stream );
      let mut stream = new Util.memStream();
      self.stream = stream;
      return stream;
   }

   fn popStream() mut {
      if #self.streamQueue == 0 {
         Util.err( "streamQueue is empty." );
      }
      self.stream = self.streamQueue[ #self.streamQueue ];
      self.streamQueue.remove(##);
   }


   
   fn get_indent(): int {
      if #self.indentQueue > 0 {
         return self.indentQueue[ #self.indentQueue ];
      }
      return 0;
   }

   fn getFullName( typeInfo:&Ast.TypeInfo ): str {
      return self.moduleCtrl.getFullName( typeInfo );
      // let mut enumName = typeInfo.getFullName( self.typeInfo2ModuleName, true );
      // return "%s" ( (enumName.gsub( "[&@]", "" ).gsub( "%.", "_" ) ) );
   }

   // fn getCanonicalName( typeInfo:&Ast.TypeInfo ): str {
   //    return self.getFullName( typeInfo );
   // }

   pub fn close() mut {
   }
   
   pub fn flush() mut {
   }
   
   pub fn writeRaw( txt: str ) mut {
      let mut stream = self.stream;

      if self.needIndent {
         stream.write( string.rep( " ", self.$indent ) );
         self.needIndent = false;
      }

      apply cr of string.gmatch( txt, "\n" ) {
         self.curLineNo = self.curLineNo + 1;
      }
      stream.write( txt );
   }

   pub fn write( mut txt: str ) mut {
      while true {
         if! let index = string.find( txt, "\n"## ) {
            self.writeRaw( txt.sub( 1, index ) );
            txt = txt.sub( index + 1 ##);
         }
         else {
            break;
         }
      }
      if #txt > 0 {
         self.writeRaw( txt );
      }
   }

   fn outputAlter2MapFunc( stream:oStream, alt2Map:&Map<&Ast.TypeInfo,&Ast.TypeInfo>);
}

fn filter( node: &Nodes.Node, filter: convFilter,
           parent: &Nodes.Node )
{
   node.processFilter( filter, new Opt( parent ) );
}

let stepIndent = 3;

// let mut builtInModuleSet:Set<str> = (@);
// builtInModuleSet.add( "io" );
// builtInModuleSet.add( "string" );
// builtInModuleSet.add( "table" );
// builtInModuleSet.add( "math" );
// builtInModuleSet.add( "debug" );


fn convFilter.pushIndent( newIndent:int! ) mut {
   let indent = unwrap newIndent default self.$indent + stepIndent;
   self.indentQueue.insert( indent );
}

fn convFilter.popIndent() mut {
   if #self.indentQueue == 0 {
      Util.err( "self.indentQueue == 0" );
   }
   self.indentQueue.remove(##);
}


fn convFilter.writeln( txt: str ) mut {
   self.write( txt );
   self.write( "\n" );
   self.needIndent = true;
}

pub override fn convFilter.processNone(
   node: Nodes.NoneNode, opt: Opt ) mut
{
   //self.writeln( "-- none" );
};

pub override fn convFilter.processImport(
   node: Nodes.ImportNode, opt: Opt ) mut
{
   let module = node.get_modulePath();
   let mut moduleName = module.gsub( ".*%.", "" );
   moduleName = node.$assignName;
   self.moduleCtrl.add( node.$moduleTypeInfo, new ModuleInfo( moduleName, module ) );
   // self.typeInfo2ModuleName[ node.$moduleTypeInfo ] =
   //    new ModuleInfo( moduleName, module );
   self.write( "local %s = _lune.loadModule( '%s' )" ( moduleName, module ) );
   //if self.convMode == "exe" or self.convMode == "ast" {
   // if self.convMode == .Exec {
   //    self.write( "local %s = _lune.loadModule( '%s' )" ( moduleName, module ) );
   // }
   // else {
   //    self.write( "local %s = require( '%s' )" ( moduleName, module ) );
   // }
};


fn setupScopeParam( scope:&Ast.Scope ): int {
   // ローカル変数のうち、 stem として扱う変数を決定し、インデックスを紐付ける。
   let mut stemNum = 0;
   foreach symbol in scope.$symbol2SymbolInfoMap {
      if symbol.$name ~= "__func__" {
         if symbol.$kind == .Var and isStemSym( symbol ) {
            let param = new SymbolParam( stemNum );
            symbol.set_convModuleParam( param );
            stemNum = stemNum + 1;
         }
      }
   }
   return stemNum;
}
fn getSymbolIndex( symbol:&Ast.SymbolInfo ) : int {
   let! param = symbol.$convModuleParam {
      return 0;
   };
   return (param@@=SymbolParam).index;
}

pub override fn convFilter.processRoot(
   node: Nodes.RootNode, opt: Opt ) mut
{
   Ast.pushProcessInfo( node.$processInfo );

   node.visit(
      fn ( target:&Nodes.Node, parent:&Nodes.Node,
           releation:str, depth:int ): Nodes.NodeVisitMode
      {
         print( string.rep( "  ", depth ) .. Nodes.getNodeKindName( target.$kind ),
                releation );
         return .Child;
      }, 0 );
   
   self.writeln( "// %s" ( self.streamName ) );

   self.writeln( "#include <lunescript.h>" );

   let children = node.get_children();

   self.processMode = .Prototype;
   foreach declEnumNode in node.$nodeManager.getDeclEnumNodeList() {
      filter( declEnumNode, self, node );
   }
   foreach declFuncNode in node.$nodeManager.getDeclFuncNodeList() {
      filter( declFuncNode, self, node );
   }
   foreach declClassNode in node.$nodeManager.getDeclClassNodeList() {
      filter( declClassNode, self, node );
   }
   foreach declConstrNode in node.$nodeManager.getDeclConstrNodeList() {
      filter( declConstrNode, self, node );
   }
   foreach declMethodNode in node.$nodeManager.getDeclMethodNodeList() {
      filter( declMethodNode, self, node );
   }

   self.processMode = .WideScopeVer;
   foreach child in children {
      if child.$kind == Nodes.NodeKind.$DeclVar {
         filter( child, self, node );
      }
   }
   foreach declClassNode in node.$nodeManager.getDeclClassNodeList() {
      filter( declClassNode, self, node );
   }

   self.processMode = .Immediate;
   self.processedNodeSet = (@);

   fn procssLiteralCtor( literalNodeList:&List<&Nodes.Node> ) {
      foreach literalNode in literalNodeList {
         self.processingNode = literalNode;
         if not self.processedNodeSet.has( literalNode ) {
            self.accessSymbolSet = new Util.OrderedSet<&Ast.SymbolInfo>();
            filter( literalNode, self, node );
            self.processedNodeSet.add( node );
         }
      }
   }
   procssLiteralCtor( node.$nodeManager.getLiteralListNodeList() );
   procssLiteralCtor( node.$nodeManager.getLiteralArrayNodeList() );
   procssLiteralCtor( node.$nodeManager.getLiteralSetNodeList() );
   procssLiteralCtor( node.$nodeManager.getLiteralMapNodeList() );
   self.processingNode = nil;
   

   self.processMode = .Form;
   foreach declFuncNode in node.$nodeManager.getDeclFuncNodeList() {
      self.duringDeclFunc = false;
      filter( declFuncNode, self, node );
   }
   foreach declEnumNode in node.$nodeManager.getDeclEnumNodeList() {
      filter( declEnumNode, self, node );
   }
   foreach declClassNode in node.$nodeManager.getDeclClassNodeList() {
      filter( declClassNode, self, node );
   }
   foreach declConstrNode in node.$nodeManager.getDeclConstrNodeList() {
      filter( declConstrNode, self, node );
   }
   foreach declMethodNode in node.$nodeManager.getDeclMethodNodeList() {
      filter( declMethodNode, self, node );
   }

   
   
   self.processMode = .InitModule;
   self.writeln( ```void lune_init_test( %s _pEnv )
{
``` (cTypeEnvP) );

   self.pushIndent(##);

   let stemNum = setupScopeParam( self.ast.$moduleScope );
   
   self.writeln( "lune_block_t * pBlock_%X = lune_enter_module( %d );"
                 (self.ast.$moduleScope.$scopeId, stemNum ) );

   foreach child in children {
      switch child.$kind {
         case Nodes.NodeKind.$DeclAlge,
              Nodes.NodeKind.$DeclClass,
              Nodes.NodeKind.$DeclFunc,
              Nodes.NodeKind.$DeclMacro
         {
            //filter( child, self, node );
            //self.writeln( "" );
         }
         default {
            filter( child, self, node );
            self.writeln( "" );
         }
      }
   }

   self.popIndent();
   
   self.writeln( "}" );

   Ast.popProcessInfo();
};

pub override fn convFilter.processSubfile(
   node: Nodes.SubfileNode, opt: Opt ) mut
{
}

pub override fn convFilter.processBlock(
   node: Nodes.BlockNode, opt: Opt ) mut
{
   // ローカル変数のうち、 stem として扱う変数を決定し、インデックスを紐付ける。
   let stemNum = setupScopeParam( node.$scope );

   // クロージャでアクセスする外部変数を宣言
   let scope = node.$scope;
   forsort symbol in scope.$closureSymMap {
      self.writeln(
         "%s %s = lune_form_closure( _pForm, %d );"
         ( cTypeVarP, symbol.$name, unwrap scope.$closureSym2NumMap[ symbol ]  ) );
   }

   let mut loopFlag = false;
   
   let mut word = "";
   switch node.get_blockKind() {
      case .If, .Elseif {
         word = "{";
      }
      case .Else {
         word = "";
      }
      case .While {
         word = "{";
         loopFlag = true;
      }
      case .Repeat {
         word = "";
         loopFlag = true;
      }
      case .For {
         word = "";
         loopFlag = true;
      }
      case .Apply {
         word = "{";
         loopFlag = true;
      }
      case .Foreach {
         word = "";
         loopFlag = true;
      }
      case .Macro {
         word = "";
      }
      case .Func {
         word = "";
      }
      case .Default {
         word = "";
      }
      case .Block {
         word = "{";
      }
      case .Macro {
         word = "";
      }
      case .LetUnwrap {
         word = "";
      }
      case .IfUnwrap {
         word = "";
      }
   }
   self.writeln( word );
   self.pushIndent(##);

   if not loopFlag {
      self.writeln( "lune_block_t * pBlock_%X = lune_enter_block( _pEnv, %d );"
                    ( node.$scope.$scopeId, stemNum ) );
   }
   else {
      self.writeln( "lune_reset_block( _pEnv );" );
   }
   
   let stmtList = node.get_stmtList();
   foreach statement in stmtList {
      filter( statement, self, node );
      self.writeln( "" );
   }

   if not loopFlag {
      self.writeln( "lune_leave_block( _pEnv );" );
   }
   
   self.popIndent();
   if node.get_blockKind() == .Block {
      self.writeln( "}" );
   }
};

pub override fn convFilter.processStmtExp(
   node: Nodes.StmtExpNode, opt: Opt ) mut
{
   filter( node.get_exp(),  self, node );
   self.write( ";" );
};

fn convFilter.getEnumTypeName( typeInfo: &Ast.TypeInfo ): str {
   let srcType = typeInfo.$srcTypeInfo;
   let fullName = self.getFullName( srcType );

   if Ast.isPubToExternal( typeInfo.$accessMode ) {
      return fullName;
   }
   return "%s_%d" (fullName, srcType.$typeId );
}

fn getLiteral2Stem( valTxt:str, typeInfo:&Ast.TypeInfo ) : str {
   switch typeInfo.$srcTypeInfo {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return "lune_int2stem( _pEnv, %s )" (valTxt);
      }
      case Ast.builtinTypeReal {
         return "lune_real2stem( _pEnv, %s )" (valTxt);
      }
      default {
         return "NULL";
      }
   }
}

pub override fn convFilter.processDeclEnum(
   node: Nodes.DeclEnumNode, opt: Opt ) mut
{
   let enumType = unwrap node.$expType@@@Ast.EnumTypeInfo;

   let enumFullName = self.getEnumTypeName( enumType );
   let fullName = self.getFullName( enumType );

   let isStrEnum = enumType.$valTypeInfo.equals( Ast.builtinTypeString ##);
   
   switch self.processMode {
      case .Prototype {
         foreach valName, index in node.$valueNameList {
            let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
            if isStrEnum {
               self.writeln( "%s %s__%s;" (cTypeStemP,enumFullName, valName.txt));
            }
            else {
               let valTxt = "%s" (Ast.getEnumLiteralVal(valInfo.$val));
               self.writeln( "#define %s__%s %s" (enumFullName, valName.txt, valTxt ) );
            }
         }
         
         self.writeln( "%s %s_val2NameMap;" (cTypeStemP, enumFullName) );
         self.writeln( "%s %s_allList;" (cTypeStemP, enumFullName) );
      }
      case .Form {
         self.writeln(
            "%s %s_get__allList( lune_env_t * _pEnv, lune_stem_t * _pForm )"
            (cTypeStemP, enumFullName) );
         self.writeln( "{" );
         self.writeln( "    return %s_allList;" (enumFullName) );
         self.writeln( "}" );

         if isStrEnum {
            self.writeln( "lune_decl_enum_get__text_stem( %s );" ( enumFullName ) );
         }
         else {
            let typeTxt;
            if enumType.$valTypeInfo.$srcTypeInfo == Ast.builtinTypeReal {
               typeTxt = "real";
            }
            else {
               typeTxt = "int";
            }
            self.writeln( "lune_decl_enum_get__text( %s, %s );"
                          ( enumFullName, typeTxt ) );
         }
         
         
         self.writeln( "void init_%s( lune_env_t * _pEnv )" ( enumFullName ) );
         self.writeln( "{" );
         self.pushIndent(##);



         let mut stemVarList:List<str> = [];
         // enum 値のセット
         if isStrEnum {
            foreach valName, index in node.$valueNameList {
               let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
               // pending: C の文字列リテラル表現できないものを対応できていない
               let valTxt = '"%s"' (Ast.getEnumLiteralVal(valInfo.$val));
               let stemVar = "%s__%s" (enumFullName, valName.txt);
               stemVarList.insert( stemVar );
               self.write( stemVar );
               self.writeln( "= lune_litStr2stem( _pEnv, %s );" (valTxt) );
            }
         }
         else {
            foreach valName, index in node.$valueNameList {
               let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
               let valTxt = '%s' (Ast.getEnumLiteralVal(valInfo.$val));
               let stemVar = "_%s" (valName.txt);
               stemVarList.insert( stemVar );
               self.write( "%s %s = " (cTypeStemP, stemVar));
               self.write( getLiteral2Stem( valTxt, enumType.$valTypeInfo ) );
               self.writeln( ";" );
            }
         }

         // _allList のセット
         self.writeln( "lune_imdList(" );
         self.pushIndent( ## );
         self.write( "list" );
         foreach stemVar in stemVarList {
            self.writeln( "," );
            self.write( "lune_imdStem( %s )" (stemVar));
         }
         self.popIndent();
         self.writeln( ");" );
         self.write( "%s_allList = " (enumFullName) );
         self.writeln( "lune_createList( _pEnv, list );" );

         // _val2NameMap のセット
         self.writeln( "lune_imdMap(" );
         self.pushIndent( ## );
         self.write( "map" );
         foreach stemVar, index in stemVarList {
            self.writeln( "," );
            self.writeln( "{ lune_imdStem( %s )," ( stemVar ) );
            self.write(
               '  lune_imdStem( lune_litStr2stem( _pEnv, "%s.%s" ) ) }'
               (fullName, node.$valueNameList[ index ].txt));
         }
         self.popIndent();
         self.writeln( ");" );
         self.write( "%s_val2NameMap = " (enumFullName) );
         self.writeln( "lune_createMap( _pEnv, map );" );
         

         self.popIndent();
         self.writeln( "}" );
      }
      case .InitModule {
         self.writeln( "init_%s( _pEnv );" ( enumFullName ) );
      }
   }
   
   

   
//    let mut access = node.$accessMode == .Global and "" or "local ";
//    let mut enumFullName = node.$name.txt;
//    let enumType = unwrap node.$expType@@@Ast.EnumTypeInfo;
//    let parentInfo = enumType.$parentInfo;
//    let mut isTopNS = true;
//    if parentInfo ~= Ast.headTypeInfo and parentInfo.$kind == .Class {
//       enumFullName = "%s.%s" (self.getFullName( parentInfo ), enumFullName );
//       access = "";
//       isTopNS = false;
//    }


//    self.writeln( "%s%s = {}" (access, enumFullName) );
//    if isTopNS and node.$accessMode == .Pub {
//       if self.needModuleObj {
//          self.writeln( "_moduleObj.%s = %s" ( enumFullName, enumFullName ) );
//       }
//    }


//    if enumType.$accessMode == .Pub {
//       self.pubEnumId2EnumTypeInfo[ enumType.$typeId ] = enumType;
//    }

//    self.writeln( "%s._val2NameMap = {}" (enumFullName) );
//    self.writeln( ```function %s:_getTxt( val )
//    local name = self._val2NameMap[ val ]
//    if name then
//       return string.format( "%s.%%s", name )
//    end
//    return string.format( "illegal val -- %%s", val )
// end
// function %s._from( val )
//    if %s._val2NameMap[ val ] then
//       return val
//    end
//    return nil
// end
//     ``` (enumFullName, enumFullName,
//           enumFullName, enumFullName ) );
//    self.writeln(
// ```
// %s.__allList = {}
// function %s.get__allList()
//    return %s.__allList
// end
// ``` (enumFullName, enumFullName, enumFullName ) );

//    foreach valName, index in node.$valueNameList {
//       let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
//       let mut valTxt = "%s" (Ast.getEnumLiteralVal(valInfo.$val));
//       if enumType.$valTypeInfo.equals( Ast.builtinTypeString ##) {
//          valTxt = "'%s'" (Ast.getEnumLiteralVal(valInfo.$val));
//       }
//       self.writeln( "%s.%s = %s" (enumFullName, valName.txt, valTxt ) );

//       self.writeln( "%s._val2NameMap[%s] = '%s'"
//          (enumFullName, valTxt, valName.txt ) );
//       self.writeln( "%s.__allList[%d] = %s.%s"
//          (enumFullName, index, enumFullName, valName.txt ) );
//    }
}

fn isGenericType( typeInfo:&Ast.TypeInfo ): bool {
   if Ast.isGenericType( typeInfo ) {
      return true;
   }
   switch typeInfo.$kind {
      case .Class, .IF {
         if #typeInfo.$itemTypeInfoList > 0 {
            return true;
         }
      }
   }
   return false;
}



// fn convFilter.getMapInfo( typeInfo:&Ast.TypeInfo ): str, bool, str
// {
   // let mut nonnilableType = typeInfo.$srcTypeInfo;
   // if typeInfo.$nilable {
   //    nonnilableType = typeInfo.$nonnilableType;
   // }

   // let mut child = "{}";
   // let mut funcTxt = "";
   // switch nonnilableType.$kind {
   //    case .Stem {
   //       funcTxt = '_lune._toStem';
   //    }
   //    case .Class, .IF {
   //       if not nonnilableType.equals( Ast.builtinTypeString ##) {
   //          funcTxt = '%s._fromMap' (self.getFullName(nonnilableType));
   //          if isGenericType( nonnilableType ) {
   //             let mut memStream = new Util.memStream();
   //             self.outputAlter2MapFunc(
   //                memStream, nonnilableType.createAlt2typeMap(false) );
   //             child = memStream.$txt;
   //          }
   //       }
   //       else {
   //          funcTxt = '_lune._toStr';
   //       }
   //    }
   //    case .Enum, .Alge {
   //       funcTxt = '%s._from' (self.getFullName(nonnilableType));
   //    }
   //    case .Prim {
   //       switch nonnilableType {
   //          case Ast.builtinTypeInt {
   //             funcTxt = '_lune._toInt';
   //          }
   //          case Ast.builtinTypeReal {
   //             funcTxt = '_lune._toReal';
   //          }
   //          case Ast.builtinTypeBool {
   //             funcTxt = '_lune._toBool';
   //          }
   //          default {
   //             Util.err( "unknown type -- %s" (nonnilableType.getTxt(##)) );
   //          }
   //       }
   //    }
   //    case .Map {
   //       funcTxt = '_lune._toMap';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let keyFuncTxt, keyNilable, keyChild = self.getMapInfo( itemList[1] );
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[2] );

   //       child = "{ { func = %s, nilable = %s, child = %s }, \n"
   //           (keyFuncTxt, keyNilable, keyChild) ..
   //          "{ func = %s, nilable = %s, child = %s } }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .Set {
   //       funcTxt = '_lune._toSet';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[1] );

   //       child = "{ func = %s, nilable = %s, child = %s }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .List, .Array {
   //       funcTxt = '_lune._toList';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[1] );

   //       child = "{ { func = %s, nilable = %s, child = %s } }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .Alternate {
   //       let prefix = "obj.__alt2mapFunc.%s" ( nonnilableType.$rawTxt );
   //       funcTxt = "%s.func" ( prefix );
   //       child = "%s.child" ( prefix );
   //    }
   // }
   // return funcTxt, typeInfo.$nilable, child;
// }


pub override fn convFilter.processDeclAlge(
   node: Nodes.DeclAlgeNode, opt: Opt ) mut
{
//    let mut access = node.$accessMode == .Global and "" or "local ";
//    let mut algeFullName = node.$algeType.$rawTxt;
//    let typeInfo = unwrap node.$expType@@@Ast.AlgeTypeInfo;
//    let parentInfo = typeInfo.$parentInfo;
//    let mut isTopNS = true;
//    if parentInfo ~= Ast.headTypeInfo and parentInfo.$kind == .Class {
//       algeFullName = "%s.%s" (self.getFullName( parentInfo ), algeFullName );
//       access = "";
//       isTopNS = false;
//    }


//    self.writeln( "%s%s = {}" (access, algeFullName) );
//    self.writeln( "%s._name2Val = {}" (algeFullName) );
//    if isTopNS and node.$accessMode == .Pub {
//       if self.needModuleObj {
//          self.writeln( "_moduleObj.%s = %s" ( algeFullName, algeFullName ) );
//       }
//    }


//    if typeInfo.$accessMode == .Pub {
//       self.pubAlgeId2AlgeTypeInfo[ typeInfo.$typeId ] = typeInfo;
//    }

//    self.writeln( ```function %s:_getTxt( val )
//    local name = val[ 1 ]
//    if name then
//       return string.format( "%s.%%s", name )
//    end
//    return string.format( "illegal val -- %%s", val )
// end
// ``` (algeFullName, algeFullName ) );
//    self.writeln( ```
// function %s._from( val )
//    return _lune._AlgeFrom( %s, val )
// end
// ``` (algeFullName, algeFullName) );
//    forsort valInfo in node.$algeType.$valInfoMap {
//       self.write( '%s.%s = { "%s"' (algeFullName, valInfo.$name, valInfo.$name ) );
//       let mut memInfoTxt = "";
//       if #valInfo.$typeList > 0 {
//          self.write( ", {" );
//          foreach paramType, index in valInfo.$typeList {
//             if index > 1 {
//                self.write( "," );
//             }
//             let funcTxt, nilable, child = self.getMapInfo( paramType );
//             self.write( "{ func=%s, nilable=%s, child=%s }" (funcTxt, nilable, child) );
//          }
//          self.write( "}" );
//       }
//       self.writeln( "}" );
//       self.writeln( '%s._name2Val["%s"] = %s.%s'
//                     ( algeFullName, valInfo.$name, algeFullName, valInfo.$name ) );
//    }
}

pub override fn convFilter.processNewAlgeVal(
   node: Nodes.NewAlgeValNode, opt: Opt ) mut
{
   // let valInfo = node.$valInfo;
   // self.write( '_lune.newAlge( %s.%s'
   //             (self.getFullName( node.$algeTypeInfo ), valInfo.$name ) );
   // if #valInfo.$typeList > 0 {
   //    self.write( ", {" );
   //    foreach exp, index in node.$paramList {
   //       if index > 1 {
   //          self.write( "," );
   //       }
   //       filter( exp, self, node );
   //    }
   //    self.write( "}" );
   // }
   // self.write( ")" );
}



// fn convFilter.getDestrClass( classTypeInfo:&Ast.TypeInfo ) : &Ast.TypeInfo!
// {
   // let mut typeInfo = classTypeInfo;
   // while not typeInfo.equals( Ast.headTypeInfo ##) {
   //    let scope = unwrap typeInfo.$scope;
   //    if! scope.getTypeInfoChild( "__free" ) {
   //       return typeInfo;
   //    }
   //    typeInfo = typeInfo.$baseTypeInfo;
   // }
   // return nil;
// }

fn convFilter.outputAlter2MapFunc(
   stream:oStream, alt2Map:&Map<&Ast.TypeInfo,&Ast.TypeInfo>)
{
   // stream.write( "{" );

   // foreach assinType, altType in alt2Map {
   //    if altType.$kind == .Alternate {
   //       if assinType.$kind == .Alternate {
   //          stream.write(
   //             "%s = self.__alt2mapFunc[ %q ],"
   //             (assinType.$rawTxt, assinType.$rawTxt ) );
   //       }
   //       else {
   //          let funcTxt, nilable, child = self.getMapInfo( assinType );
   //          stream.write(
   //             "%s = { func=%s, nilable=%s, child=%s },"
   //             (altType.$rawTxt, funcTxt, nilable, child) );
   //       }
   //    }
   // }

   // stream.write( "}" );
}

fn getMethodTypeTxt( retTypeList:&List<&Ast.TypeInfo> ) : str {
   if #retTypeList == 1 {
      switch retTypeList[ 1 ] {
         case Ast.builtinTypeInt, Ast.builtinTypeChar {
            return "lune_method_int_t";
         }
         case Ast.builtinTypeReal {
            return "lune_method_real_t";
         }
      }
   }
   return "lune_method_t";
}

fn processNewConstrProto(
   stream:Util.SourceStream, node:&Nodes.DeclClassNode ) mut
{
   let className = node.$name.txt;
   
   stream.write( "%s lune_class_%s_new( %s _pEnv"
      (cTypeStemP, className, cTypeEnvP ) );


   let scope = unwrap node.$expType.$scope;
   let initFuncType = unwrap scope.getTypeInfoField( "__init", true, scope );
   foreach argType, index in initFuncType.$argTypeInfoList {
      stream.write( ", %s arg%d" ( getCType( argType, false ), index ) );
   }
   stream.write( ")" );
}

fn processMethodDeclTxt(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   callFlag:bool, methodTypeInfo:&Ast.TypeInfo, argList:&List<&Nodes.Node>! )
{
   if methodTypeInfo.$rawTxt ~= "__init" and not callFlag {
      stream.write( "static " );
   }
   stream.write(
      "%s %s( lune_env_t * _pEnv, lune_stem_t * pObj"
      ( getCRetType( methodTypeInfo.$retTypeInfoList ),
        callFlag and moduleCtrl.getCallMethodCName( methodTypeInfo ) or
        moduleCtrl.getMethodCName( methodTypeInfo ) ) );

   when! argList {
      foreach argNode, index in argList {
         if! let declArgNode = argNode@@@Nodes.DeclArgNode {
            stream.write( ", %s %s" ( getCType( declArgNode.$expType, false ),
                                      declArgNode.$name.txt ) );
         }
      }
   }
   else {
      foreach arg, index in methodTypeInfo.$argTypeInfoList {
         stream.write( ", %s arg%d" ( getCType( arg, false ), index ) );
      }
   }
   stream.write( ")" );
}


fn processDeclMethodTable( stream:Util.SourceStream, classTypeInfo:&Ast.TypeInfo )
{
   fn outputField( name:str, retTypeList: &List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "%s * %s;" (methodType, name ) );
   }

   fn outputVal( scope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mtd {
               if symbolInfo.$name ~= "__init" {
                  outputField( symbolInfo.$name,
                               symbolInfo.$typeInfo.$retTypeInfoList );
               }
            }
         }
      }
   }
   outputVal( unwrap classTypeInfo.$scope );
}


fn processDeclMemberTable( stream:Util.SourceStream, classTypeInfo:&Ast.TypeInfo )
{
   fn outputVal( scope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mbr {
               stream.writeln( "%s %s;" ( getCType( symbolInfo.$typeInfo, false ),
                                          symbolInfo.$name ) );
            }
         }
      }
   }
   outputVal( unwrap classTypeInfo.$scope );
}

fn processDeclClassPrototype(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl, node:&Nodes.DeclClassNode )
{
   let className = node.$name.txt;
   
   // _gc, _del のプロトタイプ
   stream.writeln(
      "void u_mtd_%s__del( lune_env_t * _pEnv, lune_stem_t * pObj );" (className) );
   stream.writeln( "static void u_mtd_%s__gc( lune_env_t * _pEnv, lune_stem_t * pObj );" (className) );
   
   // アクセッサのプロトタイプ
   foreach member in node.$memberList {
      let memberName = member.$name.txt;
      if member.$getterMode ~= .None {
         let getterType = unwrap node.$scope.getTypeInfoField(
            "get_%s" (memberName), true, node.$scope );
         processMethodDeclTxt( stream, moduleCtrl, false, getterType## );
         stream.writeln( ";" );
      }
      if member.$setterMode ~= .None {
         let setterType = unwrap node.$scope.getTypeInfoField(
            "set_%s" (memberName), true, node.$scope );
         processMethodDeclTxt( stream, moduleCtrl, false, setterType## );
         stream.writeln( ";" );
      }
   }

   // コンストラクタのプロトタイプ
   processNewConstrProto( stream, node );
   stream.writeln( ";" );

   if not node.hasUserInit() {
      // デフォルトコンストラクタの処理
      let ctorType = unwrap node.$scope.getTypeInfoField(
         "__init", true, node.$scope );
      stream.write(
         "void u_mtd_%s___init( lune_env_t * _pEnv, %s pStem"
         (className, cTypeStemP ) );
      foreach argType, index in ctorType.$argTypeInfoList {
         stream.write(
            ", %s _arg%d"
            (getCType( argType, false ), index ) );
      }
      stream.writeln( ") {" );

      if! let baseScope = node.$scope.$inherit {
         let superInitType =
            unwrap baseScope.getTypeInfoField( "__init", true, baseScope );
         stream.write( "u_mtd_%s___init( _pEnv, pStem"
            (moduleCtrl.getClassCName( node.$expType.$baseTypeInfo ) ) );
         foreach argType, index in superInitType.$argTypeInfoList {
            stream.write( ", _arg%d" (index) );
         }
         stream.writeln( ");" );
      }

      
      stream.writeln( "%s * pObj = lune_obj_%s( pStem );" (className, className) );
      foreach member, index in node.$memberList {
         if isStemType( member.$expType ) {
            stream.writeln(
               "lune_setQ( (&pObj->%s), _arg%d );" (member.$name.txt, index ));
         }
         else {
            stream.writeln( "pObj->%s = _arg%d;" (member.$name.txt, index));
         }
      }
      stream.writeln( "}" );
   }
}

fn processIFObjDecl(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl, classType:&Ast.TypeInfo )
{
   if classType.hasBase() {
      processIFObjDecl( stream, moduleCtrl, classType.$baseTypeInfo );
   }

   foreach ifType in classType.$interfaceList {
      stream.writeln( "lune_stem_t %s;" (moduleCtrl.getClassCName( ifType ) ) );
   }
}

fn processIFObjInit(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   classType:&Ast.TypeInfo, impClassType:&Ast.TypeInfo )
{
   if classType.hasBase() {
      processIFObjInit( stream, moduleCtrl, classType.$baseTypeInfo, impClassType );
   }

   let className = moduleCtrl.getClassCName( impClassType );
   foreach ifType in classType.$interfaceList {
      let ifName = moduleCtrl.getClassCName( ifType );
      stream.writeln( "lune_init_if( &pObj->imp.%s, _pEnv, pStem, &lune_if_%s_imp_%s );"
                      (ifName, className, ifName) );
   }
}


fn convFilter.processDeclClassNodePrototype( node:&Nodes.DeclClassNode ) mut
{
   let className = node.$name.txt;
   
   // メソッド構造体の宣言
   self.writeln( "typedef struct lune_mtd_%s_t {" (className) );

   let kind = node.$expType.$kind;
   if kind == .Class {
      self.writeln( "lune_del_t * _del;" );
      self.writeln( "lune_gc_t * _gc;" );
   }

   processDeclMethodTable( self, node.$expType );
   
   self.writeln( "} lune_mtd_%s_t;" (className) );

   if kind == .Class {
      self.writeln( "typedef struct u_if_imp_%s_t {" (className) );

      processIFObjDecl( self, self.moduleCtrl, node.$expType );
      
      self.writeln( "} u_if_imp_%s_t;" (className) );
   }
   

   // クラス構造体の宣言
   self.writeln( "typedef struct %s {" (className) );
   switch kind {
      case .Class {
         self.writeln( "u_if_imp_%s_t * pImp;" (className) );
         self.writeln( "lune_mtd_%s_t * pMtd;" (className) );
         processDeclMemberTable( self, node.$expType );
         self.writeln( "u_if_imp_%s_t imp;" (className) );
      }
      case .IF {
         self.writeln( "lune_stem_t * pObj;" );
         self.writeln( "lune_mtd_%s_t * pMtd;" (className) );
      }      
   }
   self.writeln( "} %s;" (className) );

   self.writeln( ```#define lune_mtd_%s( OBJ )                     \
    (((%s*)OBJ->val.classVal)->pMtd )``` (className,className) );


   if kind == .Class {
      self.writeln( ```#define lune_obj_%s( OBJ )                     \
          ((%s*)OBJ->val.classVal)``` (className,className) );
      
      processDeclClassPrototype( self, self.moduleCtrl, node );
   }
}

fn convFilter.processDeclClassForm( node:&Nodes.DeclClassNode ) mut
{
   let className = self.moduleCtrl.getClassCName( node.$expType );

   self.writeln( "void u_mtd_%s__del( lune_env_t * _pEnv, lune_stem_t * pObj ) {" (className) );

   if node.$expType.hasBase() {
      self.writeln( "u_mtd_%s__del( _pEnv, pObj );"
                    (self.moduleCtrl.getClassCName( node.$expType.$baseTypeInfo) ) );
   }

   foreach member in node.$memberList {
      if isStemType( member.$expType ) {
         self.writeln( "lune_decre_ref( _pEnv, lune_obj_%s( pObj )->%s );"
                       (className, member.$name.txt ) );
      }
   }
   
   self.writeln( "}" );
   
   // デフォルトコンストラクタの定義
   processNewConstrProto( self, node );
   self.writeln( "{" );
   
   self.writeln( "lune_class_new_( _pEnv, %s, pStem, pObj );" (className) );

   self.write( "u_mtd_%s___init( _pEnv, pStem" ( className ) );

   let scope = unwrap node.$expType.$scope;
   let initFuncType = unwrap scope.getTypeInfoField( "__init", true, scope );
   foreach argType, index in initFuncType.$argTypeInfoList {
      self.write( ", arg%d" ( index ) );
   }
   self.writeln( ");" );

   self.writeln( "pObj->pImp = &pObj->imp;" );
   processIFObjInit( self, self.moduleCtrl, node.$expType, node.$expType );

   self.writeln( "return pStem;" );
   self.writeln( "}" );

   foreach member in node.$memberList {
      let memberName = member.$name.txt;
      if member.$getterMode ~= .None {
         let getterType = unwrap node.$scope.getTypeInfoField(
            "get_%s" (memberName), true, node.$scope );
         if getterType.$autoFlag {
            processMethodDeclTxt( self, self.moduleCtrl, false, getterType## );
            self.writeln( "{" );
            self.writeln(
               "return lune_obj_%s(pObj)->%s;" (className, memberName) );
            self.writeln( "}" );

            processMethodDeclTxt( self, self.moduleCtrl, true, getterType## );
            self.writeln( "{" );
            self.writeln(
               "return lune_mtd_%s( pObj )->get_%s( _pEnv, pObj );"
               (className, memberName) );
            self.writeln( "}" );
         }
      }
      if member.$setterMode ~= .None {
         let setterType = unwrap node.$scope.getTypeInfoField(
            "set_%s" (memberName), true, node.$scope );
         if setterType.$autoFlag {
            // self.writeln(
            //    "static void u_mtd_%s_set_%s( lune_env_t * _pEnv, lune_stem_t * pObj, %s arg );"
            //    ( className, memberName, getCType( member.$expType, false ) ) );
            processMethodDeclTxt( self, self.moduleCtrl, false, setterType## );
            self.writeln( "{" );
            if isStemType( member.$expType ) {
               self.writeln(
                  'lune_setq( _pEnv, &(lune_obj_%s(pObj)->%s), arg1 );'
                  (className, memberName) );
            }
            else {
               self.writeln( "lune_obj_%s(pObj)->%s = arg1;"
                  (className, memberName) );
            }
            self.writeln( "}" );

            processMethodDeclTxt( self, self.moduleCtrl, true, setterType## );
            self.writeln( "{" );
            self.writeln(
               "lune_mtd_%s( pObj )->set_%s( _pEnv, pObj, arg1 );"
               (className, memberName) );
            self.writeln( "}" );
         }
      }
   }
}


fn processInitMethodTable(
   stream:Util.SourceStream, moduleCtrl:&ModuleCtrl, classTypeInfo:&Ast.TypeInfo)
{
   fn outputField( name:str, retTypeList:&List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "(%s *)%s," (methodType, name ) );
   }

   fn outputVal( scope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mtd {
               if symbolInfo.$name ~= "__init" {
                  outputField(
                     moduleCtrl.getMethodCName( symbolInfo.$typeInfo ),
                     symbolInfo.$typeInfo.$retTypeInfoList );
               }
            }
         }
      }
   }
   outputVal( unwrap classTypeInfo.$scope );
}

fn processInitIFMethodTable(
   stream:Util.SourceStream,
   moduleCtrl:&ModuleCtrl, ifType:&Ast.TypeInfo, classTypeInfo:&Ast.TypeInfo)
{
   fn outputField( name:str, retTypeList:&List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "(%s *)%s," (methodType, name ) );
   }

   fn outputVal( scope:&Ast.Scope, impScope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit, impScope );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mtd {
               if symbolInfo.$name ~= "__init" {
                  let impMethodType =
                     unwrap impScope.getTypeInfoField( symbolInfo.$name, true, impScope );
                  outputField(
                     moduleCtrl.getMethodCName( impMethodType ),
                     impMethodType.$retTypeInfoList );
               }
            }
         }
      }
   }
   outputVal( unwrap ifType.$scope, unwrap classTypeInfo.$scope );
}


fn processIFMethodDataInit(
   stream:Util.SourceStream,
   moduleCtrl:&ModuleCtrl, classType:&Ast.TypeInfo, orgClassType:&Ast.TypeInfo )
{
   let className = moduleCtrl.getClassCName( orgClassType );
   foreach ifType in classType.$interfaceList {
      let ifName = moduleCtrl.getClassCName( ifType );
      stream.writeln(
         "lune_mtd_%s_t lune_if_%s_imp_%s = {" ( ifName, className, ifName ) );

      processInitIFMethodTable( stream, moduleCtrl, ifType, orgClassType );

      stream.writeln( "};" );
   }
}

fn processClassDataInit(
   stream:Util.SourceStream, moduleCtrl:&ModuleCtrl, classTypeInfo:&Ast.TypeInfo )
{
   processIFMethodDataInit( stream, moduleCtrl, classTypeInfo, classTypeInfo );

   
   let className = moduleCtrl.getClassCName( classTypeInfo );
   
   stream.writeln(
      "lune_mtd_%s_t lune_mtd_%s = {" ( className, className ) );
   
   stream.writeln( "u_mtd_%s__del," ( className ) );

   fn hasGC( baseInfo:&Ast.TypeInfo ): bool {
      if! let scope = baseInfo.$scope {
         if scope.getSymbolInfoField( "_gc", true, scope ) {
            return true;
         }
      }
      let mut workInfo = baseInfo;
      while workInfo.hasBase() {
         workInfo = workInfo.$baseTypeInfo;
         if! let scope = baseInfo.$scope {
            if scope.getSymbolInfoField( "_gc", true, scope ) {
               return true;
            }
         }
      }
      return false;
   }
   
   if hasGC( classTypeInfo ) {
      stream.writeln( "u_mtd_%s__gc," ( className ) );
   }
   else {
      stream.writeln( "NULL," );
   }

   processInitMethodTable( stream, moduleCtrl, classTypeInfo );
   stream.writeln( "};" );
}

pub override fn convFilter.processDeclClass(
   node: Nodes.DeclClassNode, opt: Opt ) mut
{
   let className = node.$name.txt;

   switch self.processMode {
      case .Prototype {
         self.processDeclClassNodePrototype( node );
      }
      case .WideScopeVer {
         if node.$expType.$kind == .Class {
            processClassDataInit( self, self.moduleCtrl, node.$expType );
         }
      }
      case .Form {
         if node.$expType.$kind == .Class {
            self.processDeclClassForm( node );
         }
      }
   }
   

   
   

   
   
//    let nodeInfo = node;
//    let classNameToken = nodeInfo.get_name();
//    let className = classNameToken.txt;
//    let classTypeInfo = node.get_expType();
//    let classTypeId = classTypeInfo.$typeId;
//    let isGenericClass = isGenericType( classTypeInfo );


//    if nodeInfo.get_accessMode() == .Pub {
//       self.classId2TypeInfo[ classTypeId ] = classTypeInfo;
//    }
//    self.classId2MemberList[ classTypeId ] = nodeInfo.get_memberList();

//    if! node.$moduleName {
//       self.write(
//          string.format( "local %s = require( %s )", className, _exp.txt ) );
//       switch node.$accessMode {
//          case .Pub, .Pro {
//             if self.needModuleObj {
//                self.writeln( "" );
//                self.write( "_moduleObj.%s = %s" (className, className ) );
//             }
//          }
//       }
//       return;
//    }
//    self.writeln( string.format( "local %s = {}", className ) );

//    let mut ifTxt = "";
//    if #classTypeInfo.$interfaceList > 0 {
//       foreach ifType in classTypeInfo.$interfaceList {
//          ifTxt = ifTxt .. self.getFullName( ifType ) .. ",";
//       }
//       ifTxt = "ifList = {%s}" (ifTxt);
//    }

//    let baseInfo = classTypeInfo.get_baseTypeInfo();
//    let mut baseTxt = "";
//    if baseInfo.get_typeId() ~= Ast.rootTypeId {
//       baseTxt = "__index = %s" ( self.getFullName( baseInfo ) );
//    }

//    if #ifTxt > 0 or #baseTxt > 0 {
//       let mut metaTxt = baseTxt;
//       if #baseTxt > 0 and #ifTxt > 0 {
//          metaTxt = "%s,%s" (baseTxt,ifTxt);
//       }
//       elseif #ifTxt > 0 {
//          metaTxt = ifTxt;
//       }
//       self.writeln( "setmetatable( %s, { %s } )" ( className, metaTxt ) );
//    }

//    if nodeInfo.get_accessMode() == .Pub {
//       if self.needModuleObj {
//          self.writeln( string.format( "_moduleObj.%s = %s", className, className ) );
//       }
//    }

//    foreach declNode in node.$declStmtList {
//       filter( declNode, self, node );
//    }


//    let mut hasConstrFlag = false;
//    let mut hasDestrFlag = false;
//    let mut memberList: List<&Nodes.DeclMemberNode> = [];
//    let fieldList: List<&Nodes.Node> = nodeInfo.get_fieldList();
//    let outerMethodSet: Set<str> = nodeInfo.get_outerMethodSet();
//    let mut methodNameSet: Set<str> = (@);
//    foreach field in fieldList {
//       let mut ignoreFlag = false;
//       if field.$kind == Nodes.NodeKind.$DeclConstr {
//          hasConstrFlag = true;
//          methodNameSet.add( "__init" );
//       }
//       if field.$kind == Nodes.NodeKind.$DeclDestr {
//          hasDestrFlag = true;
//          methodNameSet.add( "__free" );
//       }
//       if! let declMemberNode = field@@@Nodes.DeclMemberNode {
//          if not declMemberNode.$staticFlag {
//             memberList.insert( declMemberNode );
//          }
//       }
//       if! let methodNode = field@@@Nodes.DeclMethodNode {
//          let declInfo = methodNode.get_declInfo();
//          let methodNameToken = unwrap declInfo.get_name();
//          if outerMethodSet.has( methodNameToken.txt ) {
//             ignoreFlag = true;
//          }
//          methodNameSet.add( methodNameToken.txt );
//       }

//       if ( not ignoreFlag ) {
//          filter( field, self, node );
//       }
//    }

//    let mut destTxt = "";
//    if! self.getDestrClass( node.get_expType() ) {
//       destTxt = ", __gc = %s.__free" (_exp.getTxt(##));
//    }

//    self.writeln(```
// function %s.setmeta( obj )
//   setmetatable( obj, { __index = %s %s } )
// end```
//       ( className, className, destTxt ) );

//    if not hasConstrFlag {
//       // デフォルトコンストラクタ生成
//       methodNameSet.add( "__init" );

//       let oldFlag;
//       {
//          let initSymbol =
//             unwrap (unwrap classTypeInfo.$scope).getSymbolInfoChild( "__init" );
//          oldFlag = (unwrap initSymbol.$typeInfo.$scope).getSymbolInfoChild( "" ) ~= nil;
//       }

//       let mut superArgTxt = "";
//       let mut thisArgTxt = "";

//       if not oldFlag and baseInfo ~= Ast.headTypeInfo {
//          if! let superInit = (unwrap baseInfo.$scope).getSymbolInfoChild( "__init" ) {
//             foreach argType, index in superInit.$typeInfo.$argTypeInfoList {
//                if #superArgTxt > 0 {
//                   superArgTxt = superArgTxt .. ", ";
//                }
//                superArgTxt = "%s__superarg%d" (superArgTxt, index);
//             }
//          }
//       }

//       foreach member in memberList {
//          if #thisArgTxt > 0 {
//             thisArgTxt = thisArgTxt .. ", ";
//          }
//          thisArgTxt = thisArgTxt .. member.$name.txt;
//       }

//       let mut argTxt = superArgTxt;
//       if #argTxt > 0 {
//          argTxt = argTxt .. ",";
//       }
//       argTxt = argTxt .. thisArgTxt;

//       self.writeln( ```
// function %s.new( %s )
//    local obj = {}
//    %s.setmeta( obj )
//    if obj.__init then
//       obj:__init( %s )
//    end
//    return obj
// end
// function %s:__init( %s )
// ```
//             ( className, argTxt, className,
//               argTxt, className, argTxt ) );
//       self.pushIndent(##);

//       if baseInfo ~= Ast.headTypeInfo {
//          // Super クラスを持つ場合、その Super クラスの __init をコールする。
//          if! let superInit = (unwrap baseInfo.$scope).getSymbolInfoChild( "__init" ) {
//             self.write( "%s.__init( self" ( self.getFullName( baseInfo ) ) );
//             if #superArgTxt > 0 {
//                self.writeln( ", %s )" ( superArgTxt ) );
//             }
//             else {
//                self.writeln( ")" );
//             }
//          }
//       }

//       foreach member in memberList {
//          let memberName = member.$name.txt;
//          self.writeln( string.format( "self.%s = %s", memberName, memberName ));
//       }
//       self.popIndent();
//       self.writeln( 'end' );
//    }

//    // accessor
//    let scope = nodeInfo.get_scope();
//    foreach memberNode in nodeInfo.$memberList {
//       let memberNameToken = memberNode.get_name();
//       let memberName = memberNameToken.txt;
//       let getterName = "get_" .. memberName;
//       // let typeInfo = scope.getTypeInfo( getterName, scope, false );
//       // let autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
//       let mut autoFlag = not methodNameSet.has( getterName );
//       let prefix = memberNode.$staticFlag and className or "self";
//       if memberNode.get_getterMode() ~= .None and autoFlag
//       {
//          self.writeln( ```
// function %s:%s()
//    return %s.%s
// end``` ( className, getterName, prefix, memberName ) );
//          methodNameSet.add( getterName );
//       }
//       let setterName = "set_" .. memberName;
//       //typeInfo = scope.getTypeInfo( setterName, scope, false );
//       //autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
//       autoFlag = not methodNameSet.has( setterName );
//       if memberNode.get_setterMode() ~= .None and autoFlag
//       {
//          self.writeln( ```
// function %s:%s( %s )
//    %s.%s = %s
// end``` ( className, setterName, memberName, prefix, memberName, memberName ) );
//          methodNameSet.add( setterName );
//       }
//    }

//    // advertise
//    foreach advertiseInfo in node.$advertiseList {
//       let memberName = advertiseInfo.$member.$name.txt;
//       let mut memberType = advertiseInfo.$member.$expType;
//       foreach child in memberType.$children {
//          if child.$kind == Ast.TypeInfoKind.Method and
//             child.$accessMode ~= .Pri and
//             not child.$staticFlag
//          {
//             let childName = advertiseInfo.$prefix .. child.getTxt(##);
//             if not methodNameSet.has( childName ) {
//                self.writeln( ```
// function %s:%s( ... )
//    return self.%s:%s( ... )
// end
// ``` (className, childName, memberName, childName) );
//             }
//          }
//       }
//    }

//    // init block
//    if #nodeInfo.$initStmtList > 0 {
//       self.writeln( "do" );
//       self.pushIndent(##);
//       foreach initStmt in nodeInfo.$initStmtList {
//          filter( initStmt, self, node );
//          self.writeln( "" );
//       }
//       self.popIndent();
//       self.writeln( "end" );
//    }

//    // Mapping
//    if classTypeInfo.isInheritFrom( Ast.builtinTypeMapping, nil ) {
//       let mut declArgTxt = "val";
//       let mut argTxt = "{}, val";
//       if isGenericType( classTypeInfo ) {
//          declArgTxt = "val, __alt2mapFunc";
//          argTxt = "{ __alt2mapFunc = __alt2mapFunc }, val";
//       }

//       self.writeln( ```
// function %s:_toMap()
//   return self
// end
// function %s._fromMap( %s )
//   local obj, mes = %s._fromMapSub( %s )
//   if obj then
//      %s.setmeta( obj )
//   end
//   return obj, mes
// end
// function %s._fromStem( %s )
//   return %s._fromMap( %s )
// end
// ``` (className, className, declArgTxt,
//       className, argTxt, className,
//       className, declArgTxt, className, declArgTxt ));

//       self.writeln( 'function %s._fromMapSub( obj, val )' (className ));

//       if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
//          self.writeln( ```
//    local result, mes = %s._fromMapSub( obj, val )
//    if not result then
//       return nil, mes
//    end
// ``` (self.getFullName( classTypeInfo.$baseTypeInfo )) );
//       }

//       self.writeln( '   local memInfo = {}' );

//       foreach memberNode in node.$memberList {
//          let funcTxt, nilable, child = self.getMapInfo( memberNode.$expType );
//          self.writeln(
//             '   table.insert( memInfo, { name = "%s", func = %s, nilable = %s, child = %s } )'
//             ( memberNode.$name.txt, funcTxt, nilable, child ) );
//       }

//       self.writeln( ```
//    local result, mess = _lune._fromMap( obj, val, memInfo )
//    if not result then
//       return nil, mess
//    end
//    return obj
// end```);
//    }
};

pub override fn convFilter.processDeclMember(
   node: Nodes.DeclMemberNode, opt: Opt ) mut
{
   // dump( baseIndent, node, node.info.name.txt )
   // node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};

pub override fn convFilter.processExpMacroExp(
   node: Nodes.ExpMacroExpNode, opt: Opt ) mut
{
   // foreach stmt in node.$stmtList {
   //    filter( stmt, self, node );
   //    self.writeln( "" );
   // }
};


form outputMacroStmtBlock();

pub fn convFilter.outputDeclMacro(
   name:str, argNameList:&List<str>, callback:outputMacroStmtBlock ) mut
{
   // self.write( "local function %s(" ( name ) );

   // // let argTxt = "";
   // // foreach arg, index in macroInfo.get_argList() {
   // //    if index > 1 {
   // //       self.write( ", " );
   // //       argTxt = argTxt .. ", ";
   // //    }
   // //    filter( arg, self, node, baseIndent );
   // //    if arg.get_kind() == Nodes.NodeKind.$DeclArg {
   // //       argTxt = argTxt .. (arg@@Nodes.DeclArgNode).$name.txt;
   // //    }
   // //    else {
   // //       error( "not support ... in macro %s" ( node.get_declInfo().$name.txt ) );
   // //    }
   // // }

   // // self.writeln( ")", baseIndent );

   // self.writeln( "__macroArgs )" );
   // self.pushIndent(##);
   // foreach argName in argNameList {
   //    self.writeln( "local %s = __macroArgs.%s" (argName, argName ) );
   // }

   // self.writeln( "local macroVar = {}" );
   // self.writeln( "macroVar.__names = {}" );

   // self.macroDepth = self.macroDepth + 1;

   // callback();

   // self.macroDepth = self.macroDepth - 1;

   // self.writeln( "" );
   // self.writeln( "return macroVar" );
   // self.popIndent();
   // self.writeln( "end" );
   // self.writeln( "return %s" ( name ) );
}

pub override fn convFilter.processDeclMacro(
   node: Nodes.DeclMacroNode, opt: Opt ) mut
{
   // if self.inMacro {
   //    let macroInfo = node.get_declInfo();
   //    let mut argNameList:List<str> = [];
   //    foreach arg in macroInfo.$argList {
   //       argNameList.insert( arg.$name.txt );
   //    }
   //    self.outputDeclMacro(
   //       macroInfo.$name.txt, argNameList,
   //       fn () {
   //          if! let stmtBlock = macroInfo.$stmtBlock {
   //             filter( stmtBlock, self, node );
   //          }
   //       });
   // }
};

pub override fn convFilter.processExpMacroStat(
   node: Nodes.ExpMacroStatNode, opt: Opt ) mut
{
   // if #node.$expStrList == 0 {
   //    self.write( "''" );
   // }
   // else {
   //    foreach token, index in node.$expStrList {
   //       if index ~= 1 {
   //          self.write( '..' );
   //       }

   //       filter( token, self, node );
   //    }
   // }
};


pub override fn convFilter.processExpNew(
   node: Nodes.ExpNewNode, opt: Opt ) mut
{
   let classFullName = self.getFullName( node.get_symbol().$expType );
   self.write( "lune_class_%s_new( _pEnv" ( classFullName ) );
   if! node.get_argList() {
      self.write( ", " );
      filter( _exp,  self, node );
   }
   self.write( ")" );
   
   
   // filter( node.get_symbol(), self, node );
   // self.write( ".new(" );
   // if! node.get_argList() {
   //    filter( _exp,  self, node );
   // }
   // self.write( ")" );
};

fn convFilter.process__func__symbol(
   has__func__Symbol:bool, classType:&Ast.TypeInfo, mut funcName:str ) mut
{
   // if has__func__Symbol {
   //    let mut nameSpace = "";
   //    if classType ~= Ast.headTypeInfo {
   //       nameSpace = self.getFullName( classType );
   //    }
   //    if funcName == "" {
   //       funcName = "<anonymous>";
   //    }
   //    self.pushIndent(##);
   //    self.writeln( "local __func__ = '%s.%s'" (nameSpace, funcName) );
   //    self.popIndent();
   // }
}

fn convFilter.processDeclMethodInfo(
   declInfo:&Nodes.DeclFuncInfo, funcTypeInfo:&Ast.TypeInfo, parent:Nodes.Node ) mut
{
   switch self.processMode {
      case .Prototype {
         processMethodDeclTxt( self, self.moduleCtrl, false,
                               funcTypeInfo, declInfo.$argList );
         self.writeln( ";" );
         if funcTypeInfo.$rawTxt ~= "__init" {
            processMethodDeclTxt( self, self.moduleCtrl, true,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( ";" );
         }
      }
      case .Form {
         let className = self.moduleCtrl.getClassCName( unwrap declInfo.$classTypeInfo );
         if! let body = declInfo.$body {
            let methodNodeToken = unwrap declInfo.get_name();
            let methodName = methodNodeToken.txt;
            processMethodDeclTxt( self, self.moduleCtrl, false,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( "{" );

            self.pushIndent(##);
            self.writeln( "%s self = pObj;" (cTypeStemP) );

            self.pushRoutine( funcTypeInfo );
            
            filter( body, self, parent );

            self.popRoutine();

            self.popIndent();
            self.writeln( "}" );
         }
         if funcTypeInfo.$rawTxt ~= "__init" {
            processMethodDeclTxt( self, self.moduleCtrl, true,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( "{" );

            if #funcTypeInfo.$retTypeInfoList ~= 0 {
               self.write( "return " );
            }

            self.write( "lune_mtd_%s( pObj )->%s( _pEnv, "
                        ( className, funcTypeInfo.$rawTxt ) );
            if declInfo.$classTypeInfo$.$kind == .IF {
               self.write( "lune_getImpObj( pObj ) " );
            }
            else {
               self.write( "pObj " );
            }
            foreach argNode in declInfo.$argList {
               if! let declArgNode = argNode@@@Nodes.DeclArgNode {
                  self.write( ", %s" ( declArgNode.$name.txt ) );
               }
            }
            self.writeln( ");" );
            
            self.writeln( "}" );
         }
      }
   }
}


pub override fn convFilter.processDeclConstr(
   node: Nodes.DeclConstrNode, opt: Opt ) mut
{
   self.processDeclMethodInfo( node.$declInfo, node.$expType, node );
   
      // self.write(
      //    "void u_mtd_%s___init( lune_env_t * _pEnv, %s * pObj"
      //    (className, className ) );
      // foreach argType, index in ctorType.$argTypeInfoList {
      //    self.write(
      //       ", %s _arg%d"
      //       (getCType( argType, false ), index ) );
      // }
      // self.writeln( ") {" );
      // // デフォルトコンストラクタの処理
      // foreach member, index in node.$memberList {
      //    if isStemType( member.$expType ) {
      //       self.writeln(
      //          "lune_setQ( (&pObj->%s), _arg%d );" (member.$name.txt, index ));
      //    }
      //    else {
      //       self.writeln( "pObj->%s = _arg%d;" (member.$name.txt, index));
      //    }
      // }
      // self.writeln( "}" );
   
   
   // let declInfo = node.get_declInfo();
   // let classTypeInfo = unwrap declInfo.$classTypeInfo;
   // let className = self.getFullName( classTypeInfo );
   // self.write( string.format( "function %s.new( ", className ) );

   // let isGenericClass = isGenericType( classTypeInfo );

   // let mut argTxt = "";

   // self.write( argTxt );
   // let argList = declInfo.get_argList();
   // foreach arg, index in argList {
   //    if #argTxt > 0 {
   //       self.write( ", " );
   //       argTxt = argTxt .. ", ";
   //    }
   //    filter( arg, self, node );

   //    if! arg@@@Nodes.DeclArgNode {
   //       argTxt = argTxt .. _exp.$name.txt;
   //    }
   //    else {
   //       let name = unwrap node.get_declInfo().$name;
   //       Util.err( "not support ... in macro -- %s" (name.txt) );
   //    }
   // }
   // self.writeln( " )" );
   // self.pushIndent(##);
   // self.writeln( "local obj = {}" );
   // self.writeln( "%s.setmeta( obj )" ( className ) );
   // self.writeln( string.format( "if obj.__init then obj:__init( %s ); end", argTxt ) );
   // self.writeln( "return obj" );
   // self.popIndent();
   // self.writeln( "end" );


   // // foreach refType, index in declInfo.retTypeList {
   // //    if index > 1 {
   // //   self.write( ", " )
   // //    }
   // //filter( //    refType,  self, node, baseIndent )
   // // }
   // self.write( string.format( "function %s:__init(%s) ", className, argTxt ) );
   // if! declInfo.$body {
   //    self.process__func__symbol(
   //       declInfo.$has__func__Symbol, node.$expType.$parentInfo, "__init" );

   //    filter( _exp,  self, node );
   // }
   // self.writeln( "end" );
};

pub override fn convFilter.processDeclDestr(
   node: Nodes.DeclDestrNode, opt: Opt ) mut
{
   // self.writeln( "function %s.__free( self )"
   //    ( node.$declInfo.$classTypeInfo$.getTxt$(##) ) );

   // self.process__func__symbol(
   //    node.$declInfo.$has__func__Symbol, node.$expType.$parentInfo, "__free" );

   // filter( unwrap node.$declInfo.$body, self, node );

   // let classTypeInfo = node.$expType.$parentInfo;
   // if! self.getDestrClass( classTypeInfo.$baseTypeInfo ) {
   //    self.writeln( "%s.__free( self )" (_exp.getTxt(##) ) );
   // }

   // self.writeln( "end" );
}


pub override fn convFilter.processExpCallSuper(
   node: Nodes.ExpCallSuperNode, opt: Opt ) mut
{
   // let typeInfo:Ast.TypeInfo = node.$superType;
   // if node.$methodType.$rawTxt == "__init" {
   //    self.write( "%s.%s( self"
   //                ( self.getFullName( typeInfo ), node.$methodType.$rawTxt ) );
   // }
   // else {
   //    self.write( "%s.%s( self"
   //                ( self.getFullName( typeInfo ), node.$methodType.$rawTxt ) );
   // }

   // if! node.$expList {
   //    self.write( "," );
   //    filter( _exp, self, node );
   // }
   // self.writeln( ")" );
};

pub override fn convFilter.processDeclMethod(
   node: Nodes.DeclMethodNode, opt: Opt ) mut
{
   self.processDeclMethodInfo( node.get_declInfo(), node.$expType, node );
   
   // let declInfo = node.get_declInfo();
   // let mut delimit = ":";
   // if declInfo.get_staticFlag() {
   //    delimit = ".";
   // }
   // let methodNodeToken = unwrap declInfo.get_name();
   // let methodName = methodNodeToken.txt;
   // let classTypeInfo = unwrap declInfo.$classTypeInfo;
   // self.write( "function %s%s%s( "
   //             ( self.getFullName( classTypeInfo ), delimit, methodName ) );

   // let argList = declInfo.get_argList();
   // foreach arg, index in argList {
   //    if index > 1 {
   //       self.write( ", " );
   //    }
   //    filter( arg, self, node );
   // }
   // self.writeln( " )" );
   // if! declInfo.$body {
   //    self.process__func__symbol(
   //       declInfo.$has__func__Symbol, node.$expType.$parentInfo, methodName );
   //    filter( _exp, self, node );
   // }
   // self.writeln( "end" );
};


pub override fn convFilter.processUnwrapSet(
   node: Nodes.UnwrapSetNode, opt: Opt ) mut
{
   // let dstExpList = node.$dstExpList;
   // filter( dstExpList, self, node );
   // self.write( " = " );
   // filter( node.$srcExpList, self, node );
   // self.writeln( "" );

   // self.write( "if " );
   // foreach expNode, index in dstExpList.$expList {
   //    if index > 1 {
   //       self.write( " or " );
   //    }
   //    self.write( "nil == " );
   //    filter( expNode, self, node );
   // }
   // self.writeln( " then" );
   // self.pushIndent(##);

   // foreach expNode, index in dstExpList.$expList {
   //    self.write( "local _exp%d = " (index));
   //    filter( expNode, self, node );
   //    self.writeln( "" );
   // }

   // if node.$unwrapBlock {
   //    filter( unwrap node.$unwrapBlock, self, node );
   // }
   // self.popIndent();
   // self.writeln( "end" );
}

pub override fn convFilter.processIfUnwrap(
   node: Nodes.IfUnwrapNode, opt: Opt ) mut
{
   // self.writeln( "do" );
   // self.pushIndent(##);
   // self.write( "local " );
   // foreach varName, index in node.$varNameList {
   //    self.write( varName );
   //    if index ~= #node.$varNameList {
   //       self.write( ", " );
   //    }
   // }
   // self.write( " = " );

   // foreach expNode, index in node.$expNodeList {
   //    filter( expNode, self, node );
   //    if index ~= #node.$expNodeList {
   //       self.write( ", " );
   //    }
   // }
   // self.writeln( "" );

   // self.write( "if " );
   // foreach varName, index in node.$varNameList {
   //    self.write( "%s ~= nil" (varName) );
   //    if index ~= #node.$varNameList {
   //       self.write( " and " );
   //    }
   // }
   // self.write( " then" );

   // filter( node.$block, self, node );


   // if! node.$nilBlock {
   //    self.write( "else" );
   //    filter( _exp, self, node );
   // }
   // self.writeln( "end" );
   // self.popIndent();
   // self.writeln( "end" );
}


pub override fn convFilter.processWhen(
   node: Nodes.WhenNode, opt: Opt ) mut
{
   // self.write( "if " );
   // foreach varName, index in node.$varNameList {
   //    self.write( "%s ~= nil" (varName) );
   //    if index ~= #node.$varNameList {
   //       self.write( " and " );
   //    }
   // }
   // self.write( " then" );

   // filter( node.$block, self, node );

   // if! node.$elseBlock {
   //    self.write( "else" );
   //    filter( _exp, self, node );
   // }
   // self.writeln( "end" );
}



fn getAccessPrimValFromStem( dddFlag:bool, typeInfo:&Ast.TypeInfo, index:int ) :str
{
   let mut txt = "";
   if dddFlag {
      txt = "->val.ddd.pStemList[ %d ]" (index);
   }

   let expType;

   if! let enumType = typeInfo.$srcTypeInfo@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }
   else {
      expType = typeInfo.$srcTypeInfo;
   }
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         txt = txt .. "->val.intVal";
      }
      case Ast.builtinTypeReal {
         txt = txt .. "->val.realVal";
      }
      case Ast.builtinTypeBool {
         txt = txt .. "->val.boolVal";
      }
   }
   return txt;
}

fn convFilter.accessPrimValFromStem(
   dddFlag:bool, typeInfo:&Ast.TypeInfo, index:int ) mut
{
   self.write( getAccessPrimValFromStem( dddFlag, typeInfo, index ) );
}

fn isStemVal( node:&Nodes.Node ): bool {
   switch node.$kind {
      case Nodes.NodeKind.$ExpCall
      {
         if! let callNode = node@@@Nodes.ExpCallNode {
            return isStemRet( callNode.$func.$expType.$retTypeInfoList );
         }
         Util.err( "" );
      }
      case Nodes.NodeKind.$ExpParen {
         if! node@@@Nodes.ExpParenNode {
            return isStemVal( _exp.$exp );
         }
      }
      case Nodes.NodeKind.$ExpRef {
         if! let expRefNode = node@@@Nodes.ExpRefNode {
            return isStemSym( expRefNode.$symbolInfo );
         }
      }
      case Nodes.NodeKind.$ExpOp2 {
         if! let op2Node = node@@@Nodes.ExpOp2Node {
            switch op2Node.$op.txt {
               case "and", "or" {
                  return true;
               }
            }
         }
         return isStemType( node.$expType );
      }
      case Nodes.NodeKind.$ExpOp1 {
         if! let op1Node = node@@@Nodes.ExpOp1Node {
            switch op1Node.$op.txt {
               case "not" {
                  return true;
               }
            }
         }
         return isStemType( node.$expType );
      }
   }
   return false;
}

pub fn convFilter.accessPrimVal( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   // if exp@@@Nodes.LiteralIntNode or exp@@@Nodes.LiteralCharNode
   //    or exp@@@Nodes.LiteralRealNode
   if not isStemVal( exp ) {
      filter( exp, self, parent );
   }
   else {
      filter( exp, self, parent );
      self.accessPrimValFromStem( #exp.$expTypeList > 1, exp.$expType, 0 );
      // if #exp.$expTypeList > 1 {
      //    self.write( "->val.ddd.pStemList[ 0 ]" );
      // }

      // let expType = exp.$expType.$srcTypeInfo;
      // switch expType {
      //    case Ast.builtinTypeInt, Ast.builtinTypeChar {
      //       self.write( "->val.intVal" );
      //    }
      //    case Ast.builtinTypeReal {
      //       self.write( "->val.realVal" );
      //    }
      //    case Ast.builtinTypeBool {
      //       self.write( "->val.boolVal" );
      //    }
      // }
   }
}

fn hasMultiVal( exp:&Nodes.Node ): bool {
   return exp.$expType.$kind == .DDD or #exp.$expTypeList > 1;
}

/**
値をシンボルに代入する処理。

val1, val2, val3 = exp1, exp2, exp3


*/
fn convFilter.processSetValToSym(
   parent: Nodes.Node, varSymList:&List<&Ast.SymbolInfo>,
   expList:&List<&Nodes.Node>!, varNode:&Nodes.Node! ) mut
{
   // 変数に値を代入する
   fn initVar(): int {
      /**
変数 var に exp の式の結果を代入する。

@param var 変数シンボル
@param exp 代入する値の式
@param index exp が ... の場合の index
      */
      fn setVal( node:&Nodes.Node!, var:&Ast.SymbolInfo, exp:&Nodes.Node, index:int ) {
         let work, isStem = getCTypeForSym( var );

         let mut setValTxt = "";
         if hasMultiVal( exp ) {
            setValTxt = "lune_fromDDD( _work, %d )" (index);
         }
         else {
            setValTxt = "_work";
         }
         if not isStem and isStemVal( exp ) {
            // 値が stem でなく、変数が stem 型の場合
            setValTxt = setValTxt .. getAccessPrimValFromStem( false, var.$typeInfo, 0 );
         }

         if! let fieldNode = node@@@Nodes.RefFieldNode {
            let prefixNode = fieldNode.$prefix;
            let className = self.moduleCtrl.getClassCName( prefixNode.$expType );
            self.write( "lune_obj_%s( " (className) );
            filter( prefixNode, self, fieldNode );
            self.write( ")->" );
         }
         
         if isStem {
            if isStemType( var.$typeInfo ) {
               self.writeln( "lune_setq( _pEnv, &%s->pStem, %s );"
                             ( var.$name, setValTxt ) );
            }
            else {
               self.write( "%s->pStem" (var.$name) );
               self.accessPrimValFromStem( false, var.$typeInfo, 0 );
               self.writeln( " = %s;" (setValTxt) );
            }
         }
         else {
            self.writeln( "%s = %s;" (var.$name, setValTxt) );
         }
      }
      
      when! expList {
         let varNodeList:List<&Nodes.Node>;
         if! let expListNode = varNode@@@Nodes.ExpListNode {
            varNodeList = expListNode.$expList;
         }
         else {
            when! varNode {
               varNodeList = [ varNode ];
            }
            else {
               varNodeList = [];
            }
         }
         
         for index = 1, #expList {
            let mut workNode:&Nodes.Node! = nil;
            if #varNodeList >= index {
               workNode = varNodeList[ index ];
            }
            
            if index > #varSymList {
               return index;
            }
            // 一旦 _work に代入してから、変数にセットする。
            self.writeln( "{" );
            let exp = expList[ index ];
            if hasMultiVal( exp ) {
               self.write( cTypeStemP );
            }
            else {
               if isStemVal( exp ) {
                  self.write( cTypeStemP );
               }
               else {
                  self.write( getCType( exp.$expType, false ) );
               }
            }
            self.write( " _work = " );
            filter( exp, self, parent );
            
            self.writeln( ";" );

            if index == #expList {
               for varIndex = index, #varSymList {
                  if varIndex > #varSymList {
                     self.writeln( "}" );
                     return varIndex;
                  }
                  if #varNodeList >= varIndex {
                     workNode = varNodeList[ varIndex ];
                  }
                  setVal( workNode, varSymList[ varIndex ], exp, varIndex - index );
               }
               self.writeln( "}" );
               return #varSymList + 1;
            }
            else {
               setVal( workNode, varSymList[ index ], exp, 0 );
            }
            self.writeln( "}" );
         }
         
         return #expList + 1;
         
      }
      return 1;
   }
   initVar();
   // for index = initVar(), #varSymList {
   //    self.write( varSymList[ index ].$name );
   //    self.writeln( " = _pEnv->pNilStem;" );
   // }
}


pub override fn convFilter.processDeclVar(
   node: Nodes.DeclVarNode, opt: Opt ) mut
{
   switch self.processMode {
      case .WideScopeVer {
         let varSymList = node.$symbolInfoList;
         foreach var, index in varSymList  {
            let typeTxt, isStem = getCTypeForSym( var );
            switch var.$accessMode {
               case .Pub, .Global {
               }
               default {
                  self.write( "static " );
               }
            }
            self.writeln( "%s %s;" ( typeTxt, var.$name ) );
         }
         return;
      }
      case .Main, .InitModule, .Form {
      }
      default {
         return;
      }
   }
   
   if node.$syncBlock {
      self.writeln( "{" );
      self.pushIndent(##);
      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s" (varInfo.$name.txt) );
      }
      self.writeln( "{" );
      self.pushIndent(##);
   }

   if node.$mode ~= .Unwrap and node.get_accessMode() ~= .Global {
      //self.write( "local " );
   }

   let varSymList = node.$symbolInfoList;

   // 変数宣言
   foreach var, index in varSymList  {
      let typeTxt, isStem = getCTypeForSym( var );
      if isStem {
         if varSymList[ 1 ].$scope ~= self.ast.$moduleScope {
            // ローカル変数の場合、変数を宣言する
            self.writeln( "%s %s; " ( typeTxt, var.$name ) );
         }

         fn getDefInitVal( typeInfo:&Ast.TypeInfo ): str {
            if isStemType( var.$typeInfo ) {
               return "NULL";
            }
            return getLiteral2Stem( "0", var.$typeInfo );
            // switch var.$typeInfo.$srcTypeInfo {
            //    // case Ast.builtinTypeBool {
            //    //    return "lune_bool2stem( _pEnv, true )";
            //    // }
            //    case Ast.builtinTypeInt, Ast.builtinTypeChar {
            //       return "lune_int2stem( _pEnv, 0 )";
            //    }
            //    case Ast.builtinTypeReal {
            //       return "lune_real2stem( _pEnv, 0.0 )";
            //    }
            //    default {
            //       return "NULL";
            //    }
            // }
         }
         let initVal = getDefInitVal( var.$typeInfo );

         if initVal == "NULL" {
            self.writeln( "lune_set_block_stem( pBlock_%X, %d, %s );"
                          ( var.$scope.$scopeId, getSymbolIndex(var), var.$name ) );
         }
         else {
            self.writeln( "lune_initVal( %s, pBlock_%X, %d, %s );"
                          (var.$name, var.$scope.$scopeId,
                            getSymbolIndex(var), initVal ) );
         }
      }
      else {
         if varSymList[ 1 ].$scope ~= self.ast.$moduleScope {
            self.writeln( "%s %s;" ( typeTxt, var.$name ) );
         }
      }
   }

   // 初期値代入
   self.processSetValToSym( node, varSymList, node.get_expList()$.$expList ## );
   

   if! node.$unwrapBlock {
      self.writeln( "" );
      self.write( "if " );
      foreach var, index in varSymList {
         if index > 1 {
            self.write( " || " );
         }
         self.write( " _pEnv->pNilStem == " .. var.$name );
      }
      self.writeln( " {" );
      self.pushIndent(##);

      foreach var, index in varSymList  {
         self.writeln( "local _%s = %s" (var.$name, var.$name ) );
      }
      self.popIndent();

      filter( _exp, self, node );

      if! let thenBlock = node.$thenBlock {
         self.writeln( "else {" );
         self.pushIndent(##);
         filter( thenBlock, self, node );
         self.popIndent();
      };

      self.writeln( "}" );
   }

   if! node.$syncBlock {
      filter( _exp, self, node);

      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s = %s" (varInfo.$name.txt, varInfo.$name.txt) );
      }
      self.popIndent();
      self.writeln( "}" );

      foreach varInfo in node.$syncVarList {
         self.writeln( "%s = _sync_%s" (varInfo.$name.txt, varInfo.$name.txt) );
      }
      self.popIndent();
      self.writeln( "}" );
   }


   if node.get_accessMode() == .Pub {
      self.writeln( "" );
      foreach var, index in varSymList {
         let name: str = var.$name;
         self.pubVarName2InfoMap[ name ] = new PubVerInfo(
            node.$staticFlag, node.$accessMode,
            node.$symbolInfoList[ index ].$mutable, node.$typeInfoList[ index ] );
      }
   }
};

pub override fn convFilter.processDeclArg(
   node: Nodes.DeclArgNode, opt: Opt ) mut
{
   self.write( getCType( node.$expType, false ) .. " " );
   self.write( node.get_name().txt );
   
   //self.write( string.format( "lune_stem_t * %s", node.get_name().txt ) );

   // // filter( // node.info.argType,  self, node, baseIndent )
};

pub override fn convFilter.processDeclArgDDD(
   node: Nodes.DeclArgDDDNode, opt: Opt ) mut
{
   self.write( "%s _pDDD" (cTypeStemP) );
};

pub override fn convFilter.processExpDDD(
   node: Nodes.ExpDDDNode, opt: Opt ) mut
{
   // self.write( "..." );
};


fn getFuncName( typeInfo:&Ast.TypeInfo ): str {
   if typeInfo.$rawTxt == "" {
      return "_anonymous_%d" (typeInfo.$typeId);
   }
   switch typeInfo.$accessMode {
      case .Pub, .Global {
         return typeInfo.$rawTxt;
      }
   }
   return "lune_f_%d_%s" (typeInfo.$typeId, typeInfo.$rawTxt);
}


/**
node が示す値を stem 型に変換する処理を出力する

@param node Node
@param parent このノードの親
*/
pub fn convFilter.processVal2Stem( node:&Nodes.Node, parent: &Nodes.Node ) mut
{
   if isStemVal( node ) {
      filter( node, self, parent );
   }
   else {
      let mut expType = node.$expType.$srcTypeInfo;
      if! let enumType = expType@@@Ast.EnumTypeInfo {
         expType = enumType.$valTypeInfo;
      }
      
      switch expType {
         // case Ast.builtinTypeBool {
         //    self.write( "lune_bool2stem( _pEnv, " );
         //    filter( node, self, parent );
         //    self.write( ")" );
         // }
         case Ast.builtinTypeInt, Ast.builtinTypeChar {
            self.write( "lune_int2stem( _pEnv, " );
            filter( node, self, parent );
            self.write( ")" );
         }
         case Ast.builtinTypeReal {
            self.write( "lune_real2stem( _pEnv, " );
            filter( node, self, parent );
            self.write( ")" );
         }
         default {
            switch expType.$kind {
               case .DDD {
                  self.write( "_pDDD" );
               }
               case .Func {    
                  if! let scope = expType.$scope {
                     let argList = expType.$argTypeInfoList;
                     let hasDDD =
                        #argList > 0 and argList[ #argList ].$kind == .DDD or false;
                     
                     self.write( "lune_func2stem( _pEnv, (lune_func_t *)" );
                     self.write( getFuncName( expType ) );
                     self.write( ", %d, %s, %d"
                                 ( #node.$expType.$argTypeInfoList, hasDDD,
                                   #scope$.$closureSymList) );     
                     
                     foreach symbolInfo in scope.$closureSymList {
                        self.write( ", %s" (symbolInfo.$name) );
                     }
                     self.write( ")" );
                  }
                  else {   
                     Util.err( "illegal func" );
                  }
               }
               default {
                  filter( node, self, parent );
               }
            }
         }
      }
   }
   // filter( node, self, parent );
}

pub override fn convFilter.processDeclFunc(
   node: Nodes.DeclFuncNode, opt: Opt ) mut
{
   switch self.processMode {
      case .Form {
      }
      case .Prototype {
         return;
      }
      default {
         if opt.node.$kind ~= Nodes.NodeKind.$Block {
            self.processVal2Stem( node, opt.node );
         }

         return;
      }
   }
   if self.duringDeclFunc {
      if opt.node.$kind == Nodes.NodeKind.$Block {
         return;
      }
      self.write( getFuncName( node.$expType ) );
      return;
   }

   self.duringDeclFunc = true;
   
   
   let declInfo = node.get_declInfo();
   let mut name = getFuncName( node.$expType );
   let mut letTxt = "";
   if declInfo.get_accessMode() ~= .Global and #name ~= 0 {
      letTxt = "static ";
   }
   self.write( string.format(
      "%s%s %s( %s _pEnv, %s _pForm",
      letTxt, getCRetType( node.$expType.$retTypeInfoList ),
      name, cTypeEnvP, cTypeStemP ) );

   let argList = declInfo.get_argList();
   foreach arg, index in argList {
      self.write( ", " );
      filter( arg, self, node );
   }
   self.writeln( " )" );
   self.writeln( "{" );

   // let localVerNum = 0;
   // self.writeln( "lune_enter_block( _pEnv, %d );" (localVerNum) );

   // // クロージャでアクセスする外部変数を宣言
   // let scope = unwrap node.$expType.$scope;
   // forsort symbol in scope.$closureSymMap {
   //    self.writeln( "lune_stem_t * %s = lune_form_closure( _pForm, %d );"
   //                  ( symbol.$name, unwrap scope.$closureSym2NumMap[ symbol ]  ) );
   // }
   

   // foreach refType, index in declInfo.get_retTypeList() {
   //    if index > 1 {
   //   self.write( ", " )
   //    }
   //filter( //    refType,  self, node, baseIndent )
   // }

   let mut breakKind = Nodes.BreakKind.None;
   if! let body = declInfo.$body {
      self.process__func__symbol(
         declInfo.$has__func__Symbol, node.$expType.$parentInfo, name );

      self.pushRoutine( node.$expType );
      
      filter( body,  self, node );

      self.popRoutine();
      
      breakKind = body.getBreakKind( .Normal );
   }

   switch breakKind {
      case .Return, .NeverRet {
         // body 終了位置は処理されない
      }
      default {
         //self.writeln( "return _pEnv->pNoneStem;" );
      }
   }

   self.writeln( "}" );

   //if declInfo.get_accessMode() == .Pub {
   let expType: Ast.TypeInfo = node.get_expType();
   if expType.get_accessMode() == .Pub {
      if self.needModuleObj {
         self.write( "_moduleObj.%s = %s" ( name, name ) );
      }

      self.pubFuncName2InfoMap[ name ] = new PubFuncInfo(
         declInfo.get_accessMode(), node.get_expType() );
   }
};

pub override fn convFilter.processRefType(
   node: Nodes.RefTypeNode, opt: Opt ) mut
{
   // self.write( (node.get_refFlag() and "&" or "") ..
   //             (node.get_mutFlag() and "mut " or "") );
   // filter( node.get_name(),  self, node );
   // if node.get_array() == "array" {
   //    self.write( "[@]" );
   // }
   // elseif node.get_array() == "list" {
   //    self.write( "[]" );
   // }
};

pub override fn convFilter.processIf(
   node: Nodes.IfNode, opt: Opt ) mut
{
   let valList = node.get_stmtList();
   foreach val, index in valList {
      if index == 1 {
         self.write( "if ( lune_isCondTrue( " );
         self.processVal2Stem( val.$exp, node );
         self.write( ") )" );
      }
      elseif val.$kind == .ElseIf {
         self.write( "else if ( lune_isCondTrue( " );
         self.processVal2Stem( val.$exp, node );
         self.write( ") )" );
      }
      else {
         self.writeln( "else {" );
      }
      self.write( " " );
      filter( val.$block, self, node );
      self.write( "}" );
   }
};

pub override fn convFilter.processSwitch(
   node: Nodes.SwitchNode, opt: Opt ) mut
{
   // self.writeln( "do" );
   // self.pushIndent(##);
   // self.write( "local _switchExp = " );
   // filter( node.get_exp(),  self, node );
   // self.writeln( "" );

   // foreach caseInfo, index in node.get_caseList() {
   //    if index == 1 {
   //       self.write( "if " );
   //    }
   //    else {
   //       self.write( "elseif " );
   //    }
   //    let expList = caseInfo.get_expList();
   //    foreach expNode, listIndex in expList.get_expList() {
   //       if listIndex ~= 1 {
   //          self.write( " or " );
   //       }

   //       self.write( "_switchExp == " );
   //       filter( expNode, self, node );
   //    }
   //    self.write( " then" );
   //    filter( caseInfo.$block, self, node );
   // }
   // if! node.get_default() {
   //    self.writeln( "else " );
   //    self.pushIndent(##);
   //    filter( _exp, self, node );
   //    self.popIndent();
   // }
   // self.writeln( "end" );
   // self.popIndent();

   // self.writeln( "end" );
};


pub override fn convFilter.processMatch(
   node: Nodes.MatchNode, opt: Opt ) mut
{
   // self.writeln( "do" );
   // self.pushIndent(##);
   // self.write( "local _matchExp = " );
   // filter( node.$val,  self, node );
   // self.writeln( "" );

   // let fullName = self.getFullName( node.$algeTypeInfo );
   // foreach caseInfo, index in node.$caseList {
   //    if index == 1 {
   //       self.write( "if " );
   //    }
   //    else {
   //       self.write( "elseif " );
   //    }
   //    self.writeln( "_matchExp[1] == %s.%s[1] then"
   //                  (fullName, caseInfo.$valInfo.$name ) );
   //    foreach paramName, paramNum in caseInfo.$valParamNameList {
   //       self.writeln( "   local %s = _matchExp[2][%d]" (paramName, paramNum ) );
   //    }
   //    filter( caseInfo.$block, self, node );
   // }
   // if! node.$defaultBlock {
   //    self.writeln( "else " );
   //    filter( _exp, self, node );
   // }
   // self.writeln( "end" );
   // self.popIndent();

   // self.writeln( "end" );
};


pub override fn convFilter.processWhile(
   node: Nodes.WhileNode, opt: Opt ) mut
{
   // self.write( "while " );

   // filter( node.get_exp(), self, node );
   // self.write( " " );
   // filter( node.get_block(), self, node );
   // self.writeln( "end" );
};

pub override fn convFilter.processRepeat(
   node: Nodes.RepeatNode, opt: Opt ) mut
{
   // self.write( "repeat " );
   // filter( node.get_block(),  self, node );
   // self.write( "until " );
   // filter( node.get_exp(),  self, node );
};

fn convFilter.processLoopPreProcess( blockNode:&Nodes.BlockNode ) mut {
   let stemNum = setupScopeParam( blockNode.$scope );
   self.writeln( "lune_block_t * pBlock_%X = lune_enter_block( _pEnv, %d );"
                 ( blockNode.$scope.$scopeId, stemNum ) );
}

fn convFilter.processLoopPostProcess() mut {
   self.writeln( "lune_leave_block( _pEnv );" );
}

pub override fn convFilter.processFor(
   node: Nodes.ForNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   self.writeln( "%s _to;" (cTypeInt ) );
   self.writeln( "%s _inc;" (cTypeInt ) );
   self.writeln( "%s %s;" (cTypeInt, node.$val.$name ) );

   // node.get_block().$scope.

   self.processSetValToSym( node, [ node.$val ], [ node.get_to() ] ## );
   self.writeln( "_to = %s;" (node.$val.$name) );
   if! node.get_delta() {
      self.processSetValToSym( node, [ node.$val ], [ _exp ] ## );
      self.writeln( "_inc = %s;" (node.$val.$name) );
   }
   else {
      self.writeln( "_inc = 1;" );
   }
   self.processSetValToSym( node, [ node.$val ], [ node.get_init() ] ## );

   self.processLoopPreProcess( node.$block );
   
   self.writeln( "for (; %s <= _to; %s += _inc )" (node.$val.$name, node.$val.$name) );
   filter( node.$block,  self, node );
   self.writeln( "}" );

   self.processLoopPostProcess();

   self.popIndent();
   self.writeln( "}" );
};

pub override fn convFilter.processApply(
   node: Nodes.ApplyNode, opt: Opt ) mut
{
   // self.write( "for " );
   // let varList = node.get_varList();
   // foreach var, index in varList {
   //    if index > 1 {
   //       self.write( ", " );
   //    }
   //    self.write( var.txt );
   // }
   // self.write( " in " );
   // filter( node.$exp,  self, node );
   // self.write( " " );
   // filter( node.$block,  self, node );
   // self.writeln( "end" );
};

pub override fn convFilter.processForeach(
   node: Nodes.ForeachNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   
   self.write( "%s _obj = " ( cTypeStemP ) );
   filter( node.$exp, self, node );
   self.writeln( ";" );

   let validIndexFlag;
   let loopType = node.$exp.$expType;
   switch loopType.$kind {
      case .List, .Array {
         self.writeln( "%s _itStem = lune_itList_new( _pEnv, _obj );" (cTypeStemP) );
         if! node.$key {
            self.writeln( "int %s = 0;" (_exp.txt) );
            validIndexFlag = true;
         }
         self.writeln( "%s _val;" ( cTypeStemP ) );
      }
      case .Set {
         self.writeln( "%s _itStem = lune_itSet_new( _pEnv, _obj );" (cTypeStemP) );
         validIndexFlag = false;
         self.writeln( "%s _val;" ( cTypeStemP ) );
      }
      case .Map {
         self.writeln( "%s _itStem = lune_itMap_new( _pEnv, _obj );" (cTypeStemP) );
         validIndexFlag = false;
         self.writeln( "lune_Map_entry_t _entry;" );
      }
      default {
         Util.err( "illegal kind -- %s" (loopType.$kind.$_txt ) );
      }
   }

   self.processLoopPreProcess( node.$block );

   switch loopType.$kind {
      case .List, .Array {
         self.writeln( "for ( ; lune_itList_hasNext( _pEnv, _itStem, &_val );" );
         self.writeln( "      lune_itList_inc( _pEnv, _itStem ) )" );
      }
      case .Set {
         self.writeln( "for ( ; lune_itSet_hasNext( _pEnv, _itStem, &_val );" );
         self.writeln( "      lune_itSet_inc( _pEnv, _itStem ) )" );
      }
      case .Map {
         self.writeln( "for ( ; lune_itMap_hasNext( _pEnv, _itStem, &_entry );" );
         self.writeln( "      lune_itMap_inc( _pEnv, _itStem ) )" );
      }
   }
   self.writeln( "{" );
   if validIndexFlag {
      if! node.$key {
         self.writeln( "   %s++;" (_exp.txt) );
      }
   }

   switch loopType.$kind {
      case .List, .Set, .Array {
         let valType = loopType.$itemTypeInfoList[ 1 ];
         let valSymTxt;
         if loopType.$kind == .Set {
            if! node.$key {
               valSymTxt = _exp.txt;
            }
            else {   
               valSymTxt = "__val";
            }
         }
         else {
            if! node.$val {
               valSymTxt = _exp.txt;
            }
            else {   
               valSymTxt = "__val";
            }
         }
         
         self.writeln(
            "   %s %s = _val%s;"
            ( getCType( valType, false), valSymTxt,
              getAccessPrimValFromStem( false, valType, 0 ) ) );
      }
      case .Map {
         if! node.$key {
            let keyType = loopType.$itemTypeInfoList[ 1 ];
            self.writeln(
               "   %s %s = _entry.pKey%s;"
               ( getCType( keyType, false), _exp.txt,
                 getAccessPrimValFromStem( false, keyType, 0 ) ) );
         }
         if! node.$val {
            let valType = loopType.$itemTypeInfoList[ 2 ];
            self.writeln(
               "   %s %s = _entry.pVal%s;"
               ( getCType( valType, false), _exp.txt,
                 getAccessPrimValFromStem( false, valType, 0 ) ) );
         }
      }
      default {
      }
   }
   
   filter( node.$block, self, node );
   self.writeln( "}" );

   self.processLoopPostProcess();
   self.writeln( "}" );
   self.popIndent();
};

pub override fn convFilter.processForsort(
   node: Nodes.ForsortNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   
   self.write( "%s _obj = " ( cTypeStemP ) );
   filter( node.$exp, self, node );
   self.writeln( ";" );

   let loopType = node.$exp.$expType;
   switch loopType.$kind {
      case .Set {
         self.writeln(
            "lune_stem_t * _pList = lune_mtd_Map_createKeyList( _pEnv, _obj );" );
         self.writeln(
            "lune_mtd_List( _pList )->sort( _pEnv, _pList, _pEnv->pNilStem );" );
         self.writeln( "%s _itStem = lune_itList_new( _pEnv, _pList );" (cTypeStemP) );
         self.writeln( "%s _val;" ( cTypeStemP ) );
      }
      case .Map {
         self.writeln(
            "lune_stem_t * _pKeyList = lune_mtd_Map_createKeyList( _pEnv, _obj );" );
         self.writeln(
            "lune_mtd_List( _pKeyList )->sort( _pEnv, _pKeyList, _pEnv->pNilStem );" );
         self.writeln( "%s _itStem = lune_itList_new( _pEnv, _pKeyList );" (cTypeStemP) );
         self.writeln( "%s _key;" ( cTypeStemP ) );
      }
      default {
         Util.err( "illegal kind -- %s" (loopType.$kind.$_txt ) );
      }
   }

   self.processLoopPreProcess( node.$block );

   switch loopType.$kind {
      case .Set {
         self.writeln( "for ( ; lune_itList_hasNext( _pEnv, _itStem, &_val );" );
         self.writeln( "      lune_itList_inc( _pEnv, _itStem ) )" );
      }
      case .Map {
         self.writeln( "for ( ; lune_itList_hasNext( _pEnv, _itStem, &_key );" );
         self.writeln( "      lune_itList_inc( _pEnv, _itStem ) )" );
      }
   }
   self.writeln( "{" );

   switch loopType.$kind {
      case .Set {
         let valType = loopType.$itemTypeInfoList[ 1 ];
         let valSymTxt;
         if! node.$key {
            valSymTxt = _exp.txt;
         }
         else {   
            valSymTxt = "__val";
         }
         self.writeln(
            "   %s %s = _val%s;"
            ( getCType( valType, false), valSymTxt,
              getAccessPrimValFromStem( false, valType, 0 ) ) );
      }
      case .Map {
         if! node.$key {
            let keyType = loopType.$itemTypeInfoList[ 1 ];
            self.writeln(
               "   %s %s = _key%s;"
               ( getCType( keyType, false), _exp.txt,
                 getAccessPrimValFromStem( false, keyType, 0 ) ) );
         }
         let valType = loopType.$itemTypeInfoList[ 2 ];
         self.writeln(
            "   %s %s = lune_mtd_Map( _obj )->get( _pEnv, _obj, _key )%s;"
            ( getCType( valType, false), node.$val.txt,
              getAccessPrimValFromStem( false, valType, 0 ) ) );
      }
      default {
      }
   }
   
   filter( node.$block, self, node );
   self.writeln( "}" );

   self.processLoopPostProcess();
   self.writeln( "}" );
   self.popIndent();
};


pub override fn convFilter.processExpUnwrap(
   node: Nodes.ExpUnwrapNode, opt: Opt ) mut
{
   fn processUnwrap( typeTxt:str ) {
      if! let defVal = node.$default {
         self.write( "lune_unwrap_%sDefault( " (typeTxt) );
         self.processVal2Stem( node.$exp, node );
         self.write( "," );
         self.accessPrimVal( defVal, node );
         self.write( ")" );
      }
      else {
         self.write( "lune_unwrap_%s( " (typeTxt) );
         self.processVal2Stem( node.$exp, node );
         self.write( ")" );
      }
   }
   
   switch node.$expType.$srcTypeInfo {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         processUnwrap( "int" );
      }
      case Ast.builtinTypeReal {
         processUnwrap( "real" );
      }
      default {
         self.write( "lune_unwrap_stem( " );
         self.processVal2Stem( node.$exp, node );
         if! let defVal = node.$default {
            self.write( "," );
            self.processVal2Stem( defVal, node );
            self.write( ")" );
         }
         else {
            self.write( ", NULL )" );
         }
      }
   }
   
   // if! node.$default {
   //    self.write( '_lune.unwrapDefault( ' );
   //    filter( node.$exp, self, node );
   //    self.write( ', ' );
   //    filter( _exp, self, node );
   //    self.write( ')');
   // }
   // else {
   //    self.write( '_lune.unwrap( ' );
   //    filter( node.$exp, self, node );
   //    self.write( ')');
   // }
}


fn convFilter.processCreateMRet(
   expList:&List<&Nodes.Node>, parent:&Nodes.Node ) mut
{
   if expList[ 1 ].$expType.$kind == .DDD and #expList == 1 {
      self.write( "_pDDD" );
      return;
   }
   
   self.write( "lune_createMRet" );

   let lastExp = expList[ #expList ];
   self.write( "( _pEnv, %s, %d" ( hasMultiVal( lastExp ), #expList ) );
   
   for expIndex = 1, #expList {
      self.write( ", " );
      self.processVal2Stem( expList[ expIndex ], parent );
   }
   self.write( ")" );
}


pub override fn convFilter.processExpToDDD( node: Nodes.ExpToDDDNode, opt: Opt ) mut
{
   self.write( "lune_createDDD" );
   let expList = node.$expList;
   let lastExp = expList[ #expList ];
      self.write( "( _pEnv, %s, %d" ( hasMultiVal( lastExp ), #expList ) );
      
   foreach exp in expList {
      self.write( ", " );
      self.processVal2Stem( exp, node );
   }
   self.write( ")" );
}

/**
関数呼び出しの引数処理。

コールする関数の引数に合せて、引数を調整する。

例えばコールする関数の引数が ... の場合、 lune_createDDD() する等。

@param funcType コールする関数のタイプ
@param expListNode 引数リストノード
@param parent 関数コールノード
*/
pub fn convFilter.processCallArgList(
   funcType:&Ast.TypeInfo, expListNode: &Nodes.ExpListNode!, parent: &Nodes.ExpCallNode ) mut
{
   when! expListNode {
      let expList = expListNode.$expList;
      foreach funcArgType, index in funcType.$argTypeInfoList {
         if index ~= 1 {
            self.write( ", " );
         }
         if #expList >= index {
            if funcArgType.$kind == .DDD {
               filter( expList[ index ], self, parent );
               // self.processCreateDDD( true, expList, index, parent );
               // for expIndex = index, #expList {
               //    self.write( ", " );
               //    self.processVal2Stem( expList[ expIndex ], parent );
               // }
               // self.write( ")" );
               return;
            }
            else {
               // if funcArgType.$kind == .Form {
               if isStemType( funcArgType ) {
                  self.processVal2Stem( expList[ index ], parent );
               }
               else {
                  filter( expList[ index ], self, parent );
               }
            }
         }
         else {
            self.write( "_pEnv->pNilStem" );
         }
      }
   }
}


pub override fn convFilter.processExpCall(
   node: Nodes.ExpCallNode, opt: Opt ) mut
{
   if node.$func.$expType.$kind == .Form {
      self.write( 'lune_call_form( _pEnv, ' );
      filter( node.$func, self, node );
      if! let argList = node.$argList {
         self.write( ', %d' ( #argList.$expList ) );

         if #argList.$expList > 0 {
            self.write( ', ' );
            self.processCallArgList(
               node.$func.$expType, node.$argList, node );
         }
      }
      else {
         self.write( ', 0' );
      }
      self.write( ' )' );
      return;
   }

   
   let mut wroteFuncFlag = false;
   let mut setArgFlag = false;

   // fn setArg() {
   //    self.write( "_pEnv" );
   // }
   
   // fn fieldCall():bool {

   //    let! fieldNode = node.$func@@@Nodes.RefFieldNode {
   //       return true;
   //    };
   //    let prefixNode = fieldNode.$prefix;

   //    fn processSet(): bool {
   //       setArgFlag = true;
   //       wroteFuncFlag = true;

   //       switch fieldNode.$field.txt {
   //          case "add", "del" {
   //             filter( prefixNode, self, fieldNode );
   //             self.write( "[" );
   //             if! let argList = node.$argList {
   //                filter( argList, self, fieldNode );
   //             }
   //             self.write( "]" );
   //             switch fieldNode.$field.txt {
   //                case "add" {
   //                   self.write( "= true" );
   //                }
   //                case "del" {
   //                   self.write( "= nil" );
   //                }
   //             }
   //             return false;
   //          }
   //       }

   //       self.write( "_lune._Set_%s(" ( fieldNode.$field.txt ) );
   //       filter( prefixNode, self, fieldNode );
   //       return true;
   //    }

   //    let prefixType = prefixNode.$expType;

   //    fn processEnumAlge() {
   //       wroteFuncFlag = true;
   //       let fieldExpType = fieldNode.$expType;
   //       let canonicalName = self.getCanonicalName( prefixType );
   //       let mut methodName = fieldNode.$field.txt;
   //       let mut delimit = ":";
   //       if methodName == "get__txt" {
   //          methodName = "_getTxt";
   //       }
   //       if fieldExpType.$kind == .Func {
   //          delimit = ".";
   //       }
   //       self.write( "%s%s%s( " (canonicalName, delimit, methodName ) );
   //       if fieldExpType.$staticFlag {
   //          setArgFlag = false;
   //       }
   //       else {
   //          filter( prefixNode, self, fieldNode );
   //          setArgFlag = true;
   //       }
   //    }

   //    if node.$nilAccess {
   //       wroteFuncFlag = true;
   //       setArgFlag = true;
   //       switch prefixType.$kind {
   //          case .List, .Array {
   //             self.write( "_lune.nilacc( table.%s, nil, 'list', "
   //                         (fieldNode.$field.txt ) );
   //             filter( prefixNode, self, fieldNode );
   //          }
   //          default {
   //             self.write( "_lune.nilacc( " );
   //             filter( prefixNode, self, fieldNode );
   //             self.write( ", '%s', 'callmtd' " (fieldNode.$field.txt ) );
   //          }
   //       }
   //    }
   //    else {
   //       switch prefixType.$kind {
   //          case .List, .Array {
   //             setArgFlag = true;
   //             wroteFuncFlag = true;
   //             self.write( "table.%s( " (fieldNode.$field.txt ) );
   //             filter( prefixNode, self, fieldNode );
   //          }
   //          case .Set {
   //             if not processSet() {
   //                return false;
   //             }
   //          }
   //          case .Enum, .Alge {
   //             processEnumAlge();
   //          }
   //          case .Box {
   //             filter( prefixNode, self, fieldNode );
   //             self.write( "[1]" );
   //             return false;
   //          }
   //          case .Class {
   //             if prefixType.isInheritFrom( Ast.builtinTypeMapping, nil ) and
   //                isGenericType( prefixType ) and
   //                ( fieldNode.$field.txt == "_fromMap" or
   //                  fieldNode.$field.txt == "_fromStem" )
   //             {
   //                wroteFuncFlag = true;
   //                setArgFlag = true;
   //                filter( node.$func, self, node );
   //                self.write( "( " );
   //                if! let argList = node.$argList {
   //                   filter( argList,  self, node );
   //                   self.write( ", " );
   //                }
   //                self.outputAlter2MapFunc( self, prefixType.createAlt2typeMap(false) );
   //                self.write( ")" );
   //                return false;
   //             }
   //          }
   //       }
   //    }
   //    return true;
   // }

   // if not fieldCall() {
   //    return;
   // }

   if! let refNode = node.$func@@@Nodes.ExpRefNode {
      let builtinFunc = TransUnit.getBuiltinFunc();
      
      if refNode.$expType == builtinFunc.lune_print {
         wroteFuncFlag = true;
         self.write( "lune_print(" );
      }
      // elseif refNode.$token.txt == "super" {
      //    wroteFuncFlag = true;
      //    setArgFlag = true;
      //    let funcType = refNode.$expType;
      //    self.write( "%s.%s( self " ( self.getFullName( funcType.$parentInfo ),
      //                                 funcType.$rawTxt ) );
      // }
   }
   
   if not wroteFuncFlag {
      if node.$func.$expType.$kind == .Method {
         if! let fieldNode = node.$func@@@Nodes.RefFieldNode {
            //self.write( "lune_call_method_0( _pEnv, " );
            self.write( "%s( _pEnv, "
                        ( self.moduleCtrl.getCallMethodCName( node.$func.$expType )));
            filter( fieldNode.$prefix, self, node );
            // self.write(
            //    ",offsetof( lune_mtd_%s_t, %s )"
            //    (self.getFullName( fieldNode.$prefix.$expType ), fieldNode.$field.txt ) );
         }
         wroteFuncFlag = true;
         setArgFlag = true;
      }

   }
   
   if not wroteFuncFlag {
      // if node.$nilAccess {
      //    self.write( "_lune.nilacc( " );
      //    filter( node.$func, self, node );
      //    self.write( ", nil, 'call'" );
      //    wroteFuncFlag = true;
      // }
      // else {
         filter( node.$func, self, node );

         if node.$func.$expType.$kind == .Form {
            self.write( "->val.form.pFunc" );
         }

         
         self.write( "( " );
      // }
   }

   if not setArgFlag {
      self.write( "_pEnv, " );


      if! let scope = node.$func.$expType.$scope {
         if #scope$.$closureSymList > 0 {
            // クロージャの場合
            self.write( "lune_func2stem( _pEnv, (lune_func_t *)NULL, 0, false, %d"
                        (#scope$.$closureSymList) );
            foreach symbolInfo in scope.$closureSymList {
               self.write( ", %s" (symbolInfo.$name) );
            }
            self.write( ")" );
         }
         else {
            self.write( "NULL" );
         }
      }
      else {
         self.write( "NULL" );
      }
   }

   if! let argList = node.$argList {
      let mut expList:List<&Nodes.Node> = [];
      foreach expNode in argList.$expList {
         if expNode.$expType.$kind ~= .Abbr {
            expList.insert( expNode );
         }
      }

      if #expList > 0 {
         self.write( ", " );
         self.processCallArgList( node.$func.$expType, node.$argList, node );
      }
   }
   self.write( " )" );
};


pub override fn convFilter.processExpList(
   node: Nodes.ExpListNode, opt: Opt ) mut
{
   let expList = node.get_expList();
   //let expList = node.$expList;
   foreach exp, index in expList {
      if exp.$expType.$kind == .Abbr {
         break;
      }
      if index > 1 {
         self.write( ", " );
      }
      filter( exp, self, node );
   }
};

pub override fn convFilter.processExpOp1(
   node: Nodes.ExpOp1Node, opt: Opt ) mut
{
   let mut op = node.$op.txt;
   // if op == ",,," or op == ",,,," {
   //     filter( node.$exp,  self, node );
   // }
   if op == "~" {
      self.write( op );
      self.accessPrimVal( node.$exp, node );
   }
   elseif op == "not" {
      self.write( "lune_op_not( _pEnv, " );
      self.processVal2Stem( node.$exp, node );
      self.write( ")" );
   }
   else {
      Util.err( "not support op -- %s" (op) );
   }
};

pub override fn convFilter.processExpCast(
   node: Nodes.ExpCastNode, opt: Opt ) mut
{
   // if node.$force {
   //    if node.$expType.equals( Ast.builtinTypeInt ##) {
   //       self.write( "math.floor(" );
   //       filter( node.$exp,  self, node );
   //       self.write( ")" );
   //    }
   //    else {
   //       filter( node.$exp,  self, node );
   //    }
   // }
   // else {
   //    self.write( "_lune.__Cast( " );
   //    filter( node.$exp,  self, node );
   //    let castKind;
   //    let mut classObj = "nil";
   //    switch node.$expType.$nonnilableType {
   //       case Ast.builtinTypeInt {
   //          castKind = LuaMod.CastKind.Int;
   //       }
   //       case Ast.builtinTypeReal {
   //          castKind = LuaMod.CastKind.Real;
   //       }
   //       case Ast.builtinTypeString {
   //          castKind = LuaMod.CastKind.Str;
   //       }
   //       default {
   //          castKind = LuaMod.CastKind.Class;
   //          classObj = self.getFullName( node.$expType.$nonnilableType );
   //       }
   //    }
   //    self.write( ", %d, %s )" ( castKind, classObj) );
   // }
};


pub override fn convFilter.processExpParen(
   node: Nodes.ExpParenNode, opt: Opt ) mut
{
   self.write( "(" );
   filter( node.$exp,  self, node );
   if #node.$exp.$expTypeList > 1 {
      self.write( "->val.ddd.pStemList[ 0 ]" );
   }
   self.write( " )" );
};



/**
form から 関数をコールする wrapper を作成。
*/
fn convFilter.processWrapForm2Func( funcType:&Ast.TypeInfo ) mut
{
   self.write( "static %s _wrap_%s_%d( %s _pEnv, %s _pForm, "
               ( cTypeStemP, funcType.$rawTxt, funcType.$typeId,
                 cTypeEnvP, cTypeStemP ) );  
   foreach argType, index in funcType.$argTypeInfoList {
      self.write( ", %s arg%d" (getCType( argType, false ), index ) );
   }
   self.writeln( ")" );
   self.writeln( "{" );
   self.writeln( 'return %s( _pEnv, pForm' );
   foreach argType, index in funcType.$argTypeInfoList {
      
   }
   self.writeln( "}" );
}

fn convFilter.processAndOr( node: Nodes.ExpOp2Node,
                            opTxt: str, parent: &Nodes.Node ) mut
{
   fn isAndOr( exp:&Nodes.Node ) : bool {
      if! let parentNode = exp@@@Nodes.ExpOp2Node {
         switch parentNode.$op.txt {
            case "and", "or" {
               return true;
            }
         }
      }
      return false;
   }
   
   let mut firstFlag = not isAndOr( parent );
   if firstFlag {
      self.writeln( "lune_popVal( _pEnv, lune_incStack( _pEnv ) ||" );
      self.pushIndent( ## );
   }

   let opCC;
   if opTxt == "and" {
      opCC = "&&";
   }
   else {
      opCC = "||";
   }
   
   if isAndOr( node.$exp1 ) {
      filter( node.$exp1, self, node );
   }
   else {
      self.writeln( "lune_setStackVal( _pEnv, " );
      self.processVal2Stem( node.$exp1, node );
      self.write( ") " );
      //self.writeln( opCC );
   }
   if isAndOr( node.$exp2 ) {
      filter( node.$exp2, self, node );
   }
   else {
      self.writeln( opCC );
      self.writeln( "lune_setStackVal( _pEnv, " );
      self.processVal2Stem( node.$exp2, node );
      self.write( ") " );
   }

   if firstFlag {
      self.write( ")" );
      self.popIndent();
   }
}

pub override fn convFilter.processExpOp2(
   node: Nodes.ExpOp2Node, opt: Opt ) mut
{
   let mut opTxt = node.$op.txt;

   switch opTxt {
      case "=" {
         let symbolList = node.$exp1.getSymbolInfo();
         let expList;
         if! let expListNode = node.$exp2@@@Nodes.ExpListNode {
            expList = expListNode.$expList;
         }
         else {
            expList = [ node.$exp2 ];
         }
         self.processSetValToSym( node, symbolList, expList, node.$exp1 );
      }
      case "and", "or" {
         self.processAndOr( node, opTxt, opt.node );
      }
      default {
         if! Ast.bitBinOpMap[ opTxt ] {
            // ビット演算の処理
            switch _exp {
               case .LShift {
                  opTxt = "<<";
               }
               case .RShift {
                  opTxt = ">>";
               }
            }
            self.accessPrimVal( node.$exp1, node );
            self.write( " " .. opTxt .. " " );
            self.accessPrimVal( node.$exp2, node );
         }
         else {
            if Ast.compOpSet.has( opTxt ) {
               self.write( "lune_bool2stem( _pEnv, " );
               self.accessPrimVal( node.$exp1, node );
               self.write( " " .. opTxt .. " " );
               self.accessPrimVal( node.$exp2, node );
               self.write( ")" );
            }
            else {
               self.accessPrimVal( node.$exp1, node );
               self.write( " " .. opTxt .. " " );
               self.accessPrimVal( node.$exp2, node );
            }
         }
      }
   }
};

pub override fn convFilter.processExpRef(
   node: Nodes.ExpRefNode, opt: Opt ) mut
{
   if self.processMode == .Immediate {
      self.accessSymbolSet.add( node.$symbolInfo );
   }
   
   if node.$token.txt == "super" {
      let funcType = node.$expType;
      self.write( "%s.%s" ( self.getFullName( funcType.$parentInfo ),
                            funcType.$rawTxt ) );
   }
   elseif node.$expType.equals( TransUnit.getBuiltinFunc().lune__load ##) {
      //self.write( "_lune." .. self.targetLuaVer.$loadStrFuncName );
   }
   else {
      let symbolInfo = node.$symbolInfo;
      if isStemSym( symbolInfo ) {
         self.write( "%s->pStem" (symbolInfo.$name) );
      }
      else {
         if symbolInfo.$accessMode == .Pub and
            symbolInfo.$kind == Ast.SymbolKind.Var
         {
            if self.needModuleObj {
               self.write( "_moduleObj." );
            }
         }
         if symbolInfo.$kind == .Fun {
            self.write( getFuncName( symbolInfo.$typeInfo ) );
         }
         else {
            self.write( node.$token.txt );
         }
      }
   }
};

pub override fn convFilter.processExpRefItem(
   node: Nodes.ExpRefItemNode, opt: Opt ) mut
{
   // if node.$nilAccess {
   //    self.write( "_lune.nilacc( " );
   //    filter( node.$val, self, node );
   //    self.write( ", nil, 'item', " );
   //    if! node.$index {
   //       filter( _exp, self, node );
   //    }
   //    else {
   //       self.write( "'%s'" ( unwrap node.$symbol ) );
   //    }
   //    self.write( ")" );
   // }
   // else {
   //    if node.$val.$expType.equals( Ast.builtinTypeString ##) {
   //       self.write( "string.byte( " );
   //       filter( node.$val, self, node );
   //       self.write( ", " );
   //       if! node.$index {
   //          filter( _exp, self, node );
   //       }
   //       else {
   //          error( "index is nil" );
   //       }
   //       self.write( " )" );
   //    }
   //    else {
   //       filter( node.$val, self, node );
   //       self.write( "[" );
   //       if! node.$index {
   //          filter( _exp, self, node );
   //       }
   //       else {
   //          self.write( "'%s'" ( unwrap node.$symbol ) );
   //       }
   //       self.write( "]" );
   //    }
   // }
};

pub override fn convFilter.processRefField(
   node: Nodes.RefFieldNode, opt: Opt ) mut
{
   if! let symbolInfo = node.$symbolInfo {
      if symbolInfo.$typeInfo.$kind == .Enum {
         if symbolInfo.$kind == .Mbr {
            // enum 値の場合
            self.write( self.getEnumTypeName( symbolInfo.$typeInfo ) );
            self.write( "__%s" (symbolInfo.$name) );
            return;
         }
         Util.err( "illegal access" );
      }

      if symbolInfo.$kind == .Mbr {
         if node.$prefix.$expType.$kind == .Class {
            if symbolInfo.$staticFlag {
            }
            else {
               let className = self.moduleCtrl.getClassCName( node.$prefix.$expType );
               self.write( "lune_obj_%s( " (className) );
               if! let expRefNode = node.$prefix@@@Nodes.ExpRefNode {
                  self.write( expRefNode.$token.txt );
               }
               else {
                  filter( node.$prefix, self, node );
               }
               self.write( ")->%s" (node.$field.txt) );
            }
         }
      }
   }
   
   // let parent = opt.node;

   // if node.$nilAccess {
   //    self.write( '_lune.nilacc( ' );
   //    filter( prefix,  self, node );
   //    self.write( ', "%s" )' (node.$field.txt) );
   // }
   // else {
   //    filter( prefix,  self, node );

   //    let mut delimit = ".";
   //    if parent.$kind == Nodes.NodeKind.$ExpCall {
   //       if node.get_expType().get_kind() == Ast.TypeInfoKind.Method {
   //          delimit = ":";
   //       }
   //       else {
   //          delimit = ".";
   //       }
   //    }
   //    let fieldToken = node.get_field();
   //    self.write( delimit .. fieldToken.txt );
   // }
};

pub override fn convFilter.processExpOmitEnum(
   node: &Nodes.ExpOmitEnumNode, opt: Opt ) mut
{
   // self.write( "%s.%s" ( self.getFullName( node.$expType ), node.$valToken.txt ) );
};

pub override fn convFilter.processGetField(
   node: Nodes.GetFieldNode, opt: Opt ) mut
{
   let prefixNode = node.get_prefix();
   let prefixType = prefixNode.$expType;
   let fieldTxt = node.get_field().txt;

   if prefixType.$kind == .Enum {
      let mut enumFullName = self.getEnumTypeName( prefixType );
      switch fieldTxt {
         case "_allList" {
            self.write( "%s_get__allList( _pEnv, NULL )" (enumFullName) );
         }
         case "_txt" {
            self.write( "%s_get__txt( _pEnv, NULL, " (enumFullName) );
            filter( prefixNode, self, node );
            self.write( ")" );
         }
      }
   }
   elseif prefixType.$kind == .Class or prefixType.$kind == .IF {
      let getterType = unwrap prefixType.$scope$.getTypeInfoField$(
         "get_%s" (fieldTxt), true, unwrap prefixType.$scope );
      
      self.write( "%s( _pEnv, " ( self.moduleCtrl.getCallMethodCName( getterType ) ) );
      filter( prefixNode, self, node );
      self.write( ")" );
   }

   
   // let mut fieldTxt = node.get_field().txt;
   // if fieldTxt == "_txt" and
   //     ( prefixType.$kind == .Enum or prefixType.$kind == .Alge )
   // {
   //    self.write( "%s:_getTxt( " (self.getFullName( prefixType ) ) );
   //    filter( prefixNode, self, node );
   //    self.writeln( ")" );
   // }
   // else {
   //    filter( prefixNode,  self, node );
   //    let mut delimit = ".";
   //    if node.get_getterTypeInfo().get_kind() == Ast.TypeInfoKind.Method {
   //       delimit = ":";
   //    }
   //    else {
   //       delimit = ".";
   //    }

   //    fieldTxt = "get_%s()" ( fieldTxt );
   //    self.write( delimit .. fieldTxt );
   // }
};


pub override fn convFilter.processReturn(
   node: Nodes.ReturnNode, opt: Opt ) mut
{
   if! let expListNode = node.$expList {
      let expList = expListNode.$expList;
      let retTypeInfoList = self.currentRoutineInfo.$funcInfo.$retTypeInfoList;
      let isStem = isStemRet( retTypeInfoList );
      let mut needSetRet = true;
      self.writeln( "{" );
      self.write( "%s _ret = " (getCRetType(retTypeInfoList)) );
      if #retTypeInfoList >= 2 {
         self.processCreateMRet( expList, node );
      }
      elseif #retTypeInfoList == 1 {
         if isStem {
            self.processVal2Stem( expList[ 1 ], node );
            if Ast.builtinTypeBool.equals( retTypeInfoList[ 1 ] ## ) {
               // bool は、同じ stem を使い廻すので SetRet しない
               needSetRet = false;
            }
         }
         else {
            filter( expList[ 1 ], self, node );
         }
      }
      else {
         //self.write( "_pEnv->pNilStem" );
      }
      self.writeln( ";" );
      if isStem and needSetRet {
         self.writeln( "lune_setRet( _pEnv, _ret );" );
      }
   }

   if self.currentRoutineInfo.$blockDepth == 1 {
      self.writeln( "lune_leave_block( _pEnv );" );
   }
   else {
      self.writeln( "lune_leave_blockMulti( _pEnv, %d );"
                    ( self.currentRoutineInfo.$blockDepth ) );
   }
   
   self.writeln( "return _ret;" );
   self.writeln( "}" );

};

pub override fn convFilter.processProvide(
   node: Nodes.ProvideNode, opt: Opt ) mut
{
}

pub override fn convFilter.processAlias(
   node: &Nodes.AliasNode, opt: Opt ) mut
{
   // self.write( "local %s = " (node.$newName) );
   // filter( node.$srcNode, self, node );
   // if Ast.isPubToExternal( node.$expType.$accessMode ) {
   //    self.write( "\n_moduleObj.%s = %s" (node.$newName, node.$newName) );
   // }
}

pub override fn convFilter.processBoxing(
   node: Nodes.BoxingNode, opt: Opt ) mut
{
   // self.write( "{" );

   // filter( node.$src, self, node );

   // self.write( "}" );
}

pub override fn convFilter.processUnboxing(
   node: Nodes.UnboxingNode, opt: Opt ) mut
{
   // filter( node.$src, self, node );
   // self.write( "[1]" );
}


fn convFilter.processLiteralVal( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   let symbolList = exp.getSymbolInfo();
   if #symbolList > 0 {
      let work, varFlag = getCTypeForSym( symbolList[ 1 ] );
      if varFlag {
         self.write( "lune_imdStem( " );
         filter( exp, self, parent );
         self.write( ")" );
         return;
      }
   }
   let mut valType = exp.$expType.$srcTypeInfo;
   if! let enumType = valType@@@Ast.EnumTypeInfo {
      valType = enumType.$valTypeInfo;
   }
   
   switch valType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         self.write( "lune_imdInt( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeReal {
         self.write( "lune_imdReal( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeBool {
         self.write( "lune_imdBool( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeString {
         if! let strNode = exp@@@Nodes.LiteralStringNode { 
            if #strNode.$argList == 0 {
               self.write( "lune_imdStr( %s )" (strNode.$token.txt ) );
               return;
            }
         }
         self.write( "lune_imdStem( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      default {
         switch valType.$kind {
            case .List, .Set, .Map, .Array {
               self.write( "lune_imdStem( " );
               filter( exp, self, parent );
               self.write( ")" );
            }
            default {
               Util.err( "illegal type -- %s" (valType.getTxt(##)) );
            }
         }
      }
   }
}

fn getLiteralListFuncName( node: &Nodes.LiteralListNode ): str {
   return "lune_list_%X" (node.$id);
}

fn convFilter.processLiteralNode( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   switch exp.$kind {
      case Nodes.NodeKind.$LiteralList,
           Nodes.NodeKind.$LiteralMap,
           Nodes.NodeKind.$LiteralArray,
           Nodes.NodeKind.$LiteralSet
      {
         self.processingNode = exp;
         filter( exp, self, parent );
      }
      default {
         self.pushStream();
         filter( exp, self, parent );
         self.popStream();
      }
   }
}

fn convFilter.processLiteralListSub(
   collectionType:str, node:&Nodes.Node,
   expListNodeOrg:&Nodes.ExpListNode!, literalFuncName:str ) mut
{
   if self.processedNodeSet.has( node ) {
      if! let set = self.literalNode2AccessSymbolSet[ node ] { 
         foreach symbol in set.$list {
            self.accessSymbolSet.add( symbol );
         }
      }
      return;
   }
   self.processedNodeSet.add( node );
   let! expListNode = expListNodeOrg {
      return;
   };
   if #expListNode.$expList == 0 {
      return;
   }

   foreach exp in expListNode.$expList {
      self.processLiteralNode( exp, node );
   }
   self.processingNode = node;
   
   self.write(
      "static %s %s( %s _pEnv" (cTypeStemP, literalFuncName, cTypeEnvP ) );
   foreach symbol in self.accessSymbolSet.$list {
      self.write( ", %s %s" (getCTypeForSym( symbol ), symbol.$name ) );
   }
   self.writeln( ")" );
   self.writeln( "{" );
   
   self.pushIndent(##);
   self.write( "lune_imd%s( list" ( collectionType ) );
   self.pushIndent( ## );
   foreach exp in expListNode.$expList {
      self.write( ", " );
      self.processLiteralVal( exp, node );
   }
   self.popIndent();
   self.writeln( ");" );
   self.writeln( "return lune_create%s( _pEnv, list );" ( collectionType ) );
   self.popIndent();
   self.writeln( "}" );

   self.literalNode2AccessSymbolSet[ node ] = self.accessSymbolSet.clone();
}

pub override fn convFilter.processLiteralList(
   node: Nodes.LiteralListNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralListSub(
         "List", node, node.$expList, getLiteralListFuncName( node ) );
   }
   else {
      self.write( "%s( _pEnv" ( getLiteralListFuncName( node ) ) );
      let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
         return;
      };
      foreach symbol in symbolSet.$list {
         self.write( ", %s" ( symbol.$name ) );
      }
      self.write( ")" );
   }
};


fn getLiteralSetFuncName( node: &Nodes.LiteralSetNode ): str {
   return "lune_set_%X" (node.$id);
}

pub override fn convFilter.processLiteralSet(
   node: Nodes.LiteralSetNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralListSub(
         "Set", node, node.$expList, getLiteralSetFuncName( node ) );
   }
   else {
      self.write( "%s( _pEnv" ( getLiteralSetFuncName( node ) ) );
      let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
         return;
      };
      foreach symbol in symbolSet.$list {
         self.write( ", %s" ( symbol.$name ) );
      }
      self.write( ")" );
   }
};


fn getLiteralMapFuncName( node: &Nodes.LiteralMapNode ): str {
   return "lune_map_%X" (node.$id);
}

fn convFilter.processLiteralMapSub( node:&Nodes.LiteralMapNode ) mut
{
   if self.processedNodeSet.has( node ) {
      if! let set = self.literalNode2AccessSymbolSet[ node ] { 
         foreach symbol in set.$list {
            self.accessSymbolSet.add( symbol );
         }
      }
      return;
   }
   self.processedNodeSet.add( node );
   let pairList = node.$pairList;
   if #pairList == 0 {
      return;
   }

   foreach pair in pairList {
      self.processLiteralNode( pair.$key, node );
      self.processLiteralNode( pair.$val, node );
   }
   self.processingNode = node;
   
   self.write(
      "static %s %s( %s _pEnv" (cTypeStemP, getLiteralMapFuncName( node ), cTypeEnvP ) );
   foreach symbol in self.accessSymbolSet.$list {
      self.write( ", %s %s" (getCTypeForSym( symbol ), symbol.$name ) );
   }
   self.writeln( ")" );
   self.writeln( "{" );
   
   self.pushIndent(##);
   self.write( "lune_imdMap( list" );
   self.pushIndent( ## );
   foreach pair in pairList {
      self.writeln( ", " );
      self.write( "{ " );
      self.processLiteralVal( pair.$key, node );
      self.write( ", " );
      self.processLiteralVal( pair.$val, node );
      self.write( "} " );
   }
   self.popIndent();
   self.writeln( ");" );
   self.writeln( "return lune_createMap( _pEnv, list );" );
   self.popIndent();
   self.writeln( "}" );

   self.literalNode2AccessSymbolSet[ node ] = self.accessSymbolSet.clone();
}


pub override fn convFilter.processLiteralMap(
   node: Nodes.LiteralMapNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralMapSub( node );
   }
   else {
      self.write( "%s( _pEnv" ( getLiteralMapFuncName( node ) ) );
      let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
         return;
      };
      foreach symbol in symbolSet.$list {
         self.write( ", %s" ( symbol.$name ) );
      }
      self.write( ")" );
   }
};

pub override fn convFilter.processLiteralArray(
   node: Nodes.LiteralArrayNode, opt: Opt ) mut
{
   // self.write( "{" );

   // if! node.$expList {
   //    filter( _exp, self, node );
   // }

   // self.write( "}" );
};


pub override fn convFilter.processLiteralChar(
   node: Nodes.LiteralCharNode, opt: Opt ) mut
{
   // self.write( "lune_int2stem( _pEnv, " );
   self.write( string.format( "%d", node.$num ) );
   // self.write( ")" );
};

pub override fn convFilter.processLiteralInt(
   node: Nodes.LiteralIntNode, opt: Opt ) mut
{
   // //self.write( string.format( "%d", node.$num ) );
   // self.write( "lune_int2stem( _pEnv, " );
   self.write( node.$token.txt );
   // self.write( ")" );
};

pub override fn convFilter.processLiteralReal(
   node: Nodes.LiteralRealNode, opt: Opt ) mut
{
   //self.write( string.format( "%s", node.$num ) );
   // self.write( "lune_real2stem( _pEnv, " );
   self.write( node.$token.txt );
   // self.write( ")" );
};

pub override fn convFilter.processLiteralString(
   node: Nodes.LiteralStringNode, opt: Opt ) mut
{
   
   let mut txt = node.get_token().txt;
   if string.find( txt, '^```' ## ) {
      txt = '[==[' .. txt.sub( 4, -4 ) .. ']==]';
   }
   let opList = TransUnit.findForm( txt );

   self.write( "lune_litStr2stem( _pEnv, " );
   
   let argList = node.get_argList();
   if #argList > 0 {
      self.write( string.format( 'string.format( %s, ', txt ) );
      foreach val, index in argList {
         if index > 1 {
            self.write( ", " );
         }

         filter( val, self, node );
      }
      self.write( ")" );
   }
   else {
      self.write( txt );
   }

   self.write( ")" );
};

pub override fn convFilter.processLiteralBool(
   node: Nodes.LiteralBoolNode, opt: Opt ) mut
{
   //self.write( "lune_bool2stem( _pEnv, " );
   ///self.write( node.$token.txt );
   if node.$token.txt == "true" {
      self.write( "_pEnv->pTrueStem" );
   }
   else {
      self.write( "_pEnv->pFalseStem" );
   }
   //self.write( ")" );
};

pub override fn convFilter.processLiteralNil(
   node: Nodes.LiteralNilNode, opt: Opt ) mut
{
   self.write( "_pEnv->pNilStem" );
};

pub override fn convFilter.processBreak(
   node: Nodes.BreakNode, opt: Opt ) mut
{
   self.write( "break" );
};

pub override fn convFilter.processLiteralSymbol(
   node: Nodes.LiteralSymbolNode, opt: Opt ) mut
{
   // self.write( '%s' ( node.$token.txt ) );
};


pub fn createFilter(
   streamName: str, stream: oStream, ast:&TransUnit.ASTInfo ) : Nodes.Filter<Opt>
{
   return new convFilter( streamName, stream, ast );
}
