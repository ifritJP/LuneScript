/*
MIT License

Copyright (c) 2018, 2019 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Ver;
import lune.base.Ast;
import lune.base.Nodes;
import lune.base.Util;
import lune.base.TransUnit;
import lune.base.LuaMod;
import lune.base.LuaVer;
import lune.base.Parser;
import lune.base.LuneControl;

let cTypeInt = "lns_int_t";
let cTypeReal = "lns_real_t";
let cTypeBool = "lns_bool_t";
let cTypeStem = "lns_stem_t";
let cTypeAny = "lns_any_t";
let cTypeAnyP = "lns_any_t *";
let cTypeAnyPP = "lns_any_t **";
let cTypeEnvP = "lns_env_t *";
let cTypeVarP = "lns_closureVar_t *";
let cTypeMod = "lns_module_t";
let cTypeModP = "lns_module_t *";
let cTypeBlockP = "lns_block_t *";
let cValNil = "lns_global.nilStem";
let cValNone = "lns_global.noneStem";
let cValDDD0 = "lns_global.ddd0";

let accessAny = ".val.pAny";

let stepIndent = 4;

/**
構文解析済みで、全シンボルにアクセスしても問題ないので、
ここでは scopeAccess をフルとする。 
*/
let scopeAccess = Ast.ScopeAccess.Full;

let invalidSymbolId = -1;

/**
node の属するクラスの TypeInfo を返す。

@return node の属するクラスの TypeInfo。 クラスに属さない場合は nil。
*/
fn getBelongClassType( node:&Nodes.Node ) : &Ast.TypeInfo! {
   if node.$expType.$kind ~= .Method {
      return nil;
  }
   let! fieldNode = node@@@Nodes.RefFieldNode {
      return nil;
   };
   return fieldNode.$prefix.$expType;
}

/**
funcType で示す関数がクロージャかどうかを返す。
*/
fn isClosure( funcType:&Ast.TypeInfo ): bool {
   if! let scope = funcType.$scope {
      return #scope.$closureSymList > 0;
   }
   return false;
}

/** 公開変数情報 */
class PubVarInfo {
   pub let staticFlag: bool;
   pub let accessMode: Ast.AccessMode;
   pub let mutable:bool;
   pub let typeInfo: &Ast.TypeInfo;
};

/** 公開関数情報 */
class PubFuncInfo {
   pub let accessMode: Ast.AccessMode;
   pub let typeInfo: &Ast.TypeInfo;
}

pub enum ConvMode {
   /** lns ソースを実行する */
   Exec,
   /** lua への変換を行なう */
   Convert,
   /** lua への変換と、 Meta 情報生成を行なう */
   ConvMeta,
}

/** インポートしているモジュールの情報 */
class ModuleInfo extend (Ast.ModuleInfoIF){
   /** import したモジュールに割り当てている名前 */
   let assignName:str {pub};
   /** モジュールのパス */
   let modulePath:str {pub};
}

/** 出力に使用するパラメータ */
pub class Opt {
   pub let node:&Nodes.Node;
}

class DepthInfo {
   /** 解析中のブロックの深さ */
   let mut blockDepth:int {pub};

   pub fn __init() {
      self.blockDepth = 1;
   }
   pub fn pushDepth() mut {
      self.blockDepth = self.blockDepth + 1;
   }
   pub fn popDepth() mut {
      self.blockDepth = self.blockDepth - 1;
   }
}

class DepthStack<T:DepthInfo> {
   let mut stack:List<T>;

   pub fn __init() {
      self.stack = [];
   }
   
   pub fn newInfo(info:T) mut {
      self.stack.insert( info );
   }
   pub fn delInfo() mut {
      self.stack.remove(##);
   }
   pub fn current() mut : T {
      if #self.stack == 0 {
         Util.err( "stack empty" );
      }
      return self.stack[ #self.stack ];
   }
   pub fn currentR() : &T {
      if #self.stack == 0 {
         Util.err( "stack empty" );
      }
      return self.stack[ #self.stack ];
   }
   pub fn pushDepth() mut {
      self.current().pushDepth();
   }
   pub fn popDepth() mut {
      self.current().popDepth();
   }
   pub fn get_blockDepth():int {
      return self.currentR().$blockDepth;
   }
}

/** 解析中の関数情報 */
class RoutineInfo extend DepthInfo {
   /** 解析中の関数の型 */
   let funcInfo:&Ast.TypeInfo {pub};

   pub fn __init( funcInfo:&Ast.TypeInfo ) {
      super();
      self.funcInfo = funcInfo;
   }
}


enum ValKind {
   /** プリミティブ型として扱う */
   Prim,
   // /** any 型として扱う */
   Any,
   /** 作業用に作成した any 型として扱う */
   StemWork,
   /**stem 型として扱う */
   Stem,
   /** var 型として扱う */
   Var,
   /** */
   Other,
}


/**
指定の型を扱う時の ValKind が Stem かどうか。 

変数を扱う場合は ScopeMgr.getSymbolValKind() を使用する必要がある。
*/
fn getValKind( valType:&Ast.TypeInfo ) : ValKind {
   let expType = valType.$srcTypeInfo;
   if expType.$nilable {
      return .Stem;
   }
   switch expType.$kind {
      case .Alternate, .Stem, .DDD, .Alge {
         return .Stem;
      }
   }
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return .Prim;
      }
      case Ast.builtinTypeReal {
         return .Prim;
      }
      case Ast.builtinTypeBool {
         return .Prim;
      }
      default {
         // if expType.$kind == .DDD {
         //    return .Any;
         // }
         if! let enumType = expType@@@Ast.EnumTypeInfo {
            return getValKind( enumType.$valTypeInfo );
         }
         return .Any;
      }
   }
}

/**
指定の型を扱う時の ValKind が Stem かどうか。 

変数を扱う場合は ScopeMgr.getSymbolValKind() を使用する必要がある。
*/
fn isStemType( valType:&Ast.TypeInfo ) : bool {
   return getValKind( valType ) == .Stem;
}


fn getRetKind( retTypeList:&List<&Ast.TypeInfo> ) : ValKind {
   switch #retTypeList {
      case 0 {
         return .Other;
      }
      case 1 {
         return getValKind( retTypeList[ 1 ] );
      }
   }
   return .Stem;
}


/**
戻り値の ValKind が Stem かどうか。
*/
fn isStemRet( retTypeList:&List<&Ast.TypeInfo> ) : bool {
   return getRetKind( retTypeList ) == .Stem;
}

/**
指定の型を C で扱う時の型名を返す。
*/
fn getCType( valType:&Ast.TypeInfo ) : str {
   let expType = valType.$srcTypeInfo;
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return cTypeInt;
      }
      case Ast.builtinTypeReal {
         return cTypeReal;
      }
      case Ast.builtinTypeBool {
         return cTypeBool;
      }
      default {
         if! let enumType = expType@@@Ast.EnumTypeInfo {
            return getCType( enumType.$valTypeInfo );
         }

         if getValKind( valType ) == .Any {
            return cTypeAnyP;
         }
         
         return cTypeStem;
      }
   }
}

/**
指定の戻り値型を C で扱う時の型名を返す。
*/
fn getCRetType( retTypeList:&List<&Ast.TypeInfo> ) : str {
   switch #retTypeList {
      case 0 {
         return "void";
      }
      case 1 {
         return getCType( retTypeList[ 1 ] );
      }
   }
   return cTypeStem;
}

fn getBlockName( scope:&Ast.Scope ): str {
   return "pBlock_%X" ( scope.$scopeId );
}

/** 変換プロセス */
enum ProcessMode {
   /** include */
   Include,
   /** プロトタイプ宣言 */
   Prototype,
   /** 大域変数 */
   WideScopeVer,
   /** モジュール初期化 */
   InitModule,
   /** 中間処理 */
   Intermediate,
   /** string format */
   StringFormat,
   /** クラス定義 */
   DefClass,
   /** 内部関数 */
   Form,
   /** 即値 */
   Immediate,
   /** __func__ の初期化 */
   InitFuncSym,
   /** wrapper 関数定義 */
   DefWrap,
}

fn isClassMember( symbol:&Ast.LowSymbol ) mut : bool
{
   if symbol.$scope.$ownerTypeInfo$.$kind == .Class and
      symbol.$kind == .Mbr and symbol.$staticFlag
   {
      return true;
   }
   return false;
}

/**
区切り記号で囲んでいる文字列を C の文字列に変換する。
*/
fn str2cstr( txt:str ) : str {
   let mut work = txt;
   if string.find( work, '^```' ## ) {
      work = ("%q" ( work.sub( 4, -4 ) )).gsub( "\\\n", "\\n" );
   }
   elseif string.find( work, "^'" ## ) {
      work = '"%s"' ((("%s" ( work.sub( 2, -2 )) ).gsub( '"', '\\"' )));
   }
   work = work.gsub( "\\9", "\\t" );
   return work;
}


class ModuleCtrl {
   pri let moduleInfoManager: &Ast.ModuleInfoManager;
   pri let typeNameCtrl: &Ast.TypeNameCtrl;
   

   /**
ビルトイン関数のシンボル → Cの関数名のマップ
*/
   let builtinSym2CFuncMap:&Map<&Ast.SymbolInfo,str>;
   let builtinType2CFuncMap:&Map<&Ast.TypeInfo,str>;

   static fn setupBuiltinSym():&Map<&Ast.SymbolInfo,str>, &Map<&Ast.TypeInfo,str> {
      let builtinFunc = TransUnit.getBuiltinFunc();

      let mut symMap:Map<&Ast.SymbolInfo,str> = {};
      let mut typeMap:Map<&Ast.TypeInfo,str> = {};
      macro _setBuiltinFnc(func:sym) {
         {
            let symbol = "lns_%s" (,,,,func);
         }
         typeMap[ builtinFunc.,,,symbol ] = "lns_f_" .. ,,,,func;
      }
      macro _setBuiltinMtd(func:sym) {
         {
            let symbol = "%s" (,,,,func);
         }
         typeMap[ builtinFunc.,,,symbol ] = "mtd_lns_" .. ,,,,func;
      }

      _setBuiltinFnc( type );
      _setBuiltinFnc( error );
      _setBuiltinFnc( print );
      _setBuiltinFnc( tonumber );
      _setBuiltinFnc( tostring );
      _setBuiltinFnc( load );
      _setBuiltinFnc( loadfile );
      _setBuiltinFnc( require );
      _setBuiltinFnc( collectgarbage );
      _setBuiltinFnc( _fcall );
      _setBuiltinFnc( _load );
      _setBuiltinFnc( _kind );
      _setBuiltinMtd( io_open );
      _setBuiltinMtd( io_popen );
      _setBuiltinMtd( package_searchpath );
      _setBuiltinMtd( os_clock );
      _setBuiltinMtd( os_date );
      _setBuiltinMtd( os_difftime );
      _setBuiltinMtd( os_exit );
      _setBuiltinMtd( os_remove );
      _setBuiltinMtd( os_rename );
      _setBuiltinMtd( os_time );
      _setBuiltinMtd( string_byte );
      _setBuiltinMtd( string_dump );
      _setBuiltinMtd( string_find );
      _setBuiltinMtd( string_format );
      _setBuiltinMtd( string_gmatch );
      _setBuiltinMtd( string_gsub );
      _setBuiltinMtd( string_lower );
      _setBuiltinMtd( string_rep );
      _setBuiltinMtd( string_reverse );
      _setBuiltinMtd( string_sub );
      _setBuiltinMtd( string_upper );
      _setBuiltinMtd( math_random );
      _setBuiltinMtd( math_randomseed );
      _setBuiltinMtd( debug_getinfo );
      _setBuiltinMtd( debug_getlocal );
      return symMap, typeMap;
   }
   
   pub fn __init( typeNameCtrl:&Ast.TypeNameCtrl,
                  moduleInfoManager: &Ast.ModuleInfoManager)
   {
      self.builtinSym2CFuncMap, self.builtinType2CFuncMap = ModuleCtrl.setupBuiltinSym();
      self.typeNameCtrl = typeNameCtrl;
      self.moduleInfoManager = moduleInfoManager;
   }

   pub fn getBuiltinFuncName( symbol:&Ast.SymbolInfo): str! {
      return self.builtinSym2CFuncMap[ symbol ];
   }

   pub fn getBuiltinFuncNameFromType( typeInfo:&Ast.TypeInfo): str! {
      return self.builtinType2CFuncMap[ typeInfo ];
   }

   /**
   指定のモジュールを定義するファイルパスを取得する。

.c, .h 等の拡張子は付かない。
   */
   pub fn getFilePath( mut moduleTypeInfo:&Ast.TypeInfo ): str {
      let workName = moduleTypeInfo.getFullName(
         self.$typeNameCtrl, self.moduleInfoManager, false );
      let fullName = "%s" ( (workName.gsub( "[&@]", "" ).gsub( "%.", "/" ) ) );
      return fullName;
   }


   pub fn getCanonicalName( typeInfo:&Ast.TypeInfo ): str {
      return typeInfo.getFullName( self.$typeNameCtrl, self.moduleInfoManager, false );
   }

/**
指定の型の関数名を取得する。
*/
   pub fn getFullName( mut typeInfo:&Ast.TypeInfo ): str {
      if! let alterType = typeInfo.$srcTypeInfo@@@Ast.AlternateTypeInfo {
         if alterType.hasBase() {
            typeInfo = alterType.$baseTypeInfo;
         }
      }
      typeInfo = typeInfo.$srcTypeInfo.$genSrcTypeInfo;
      let workName = typeInfo.getFullName(
         self.$typeNameCtrl, self.moduleInfoManager, false );

      let fullName = "%s" ( (workName.gsub( "[&@]", "" ).gsub( "%.", "_" ) ) );
      if Ast.isPubToExternal( typeInfo.$accessMode ) {
         return fullName;
      }
      return "_%d_%s" (typeInfo.$typeId,fullName);
   }


   pub fn getAlgeCName( algeType:&Ast.TypeInfo ): str {
      return self.getFullName( algeType );
   }
   pub fn getAlgeEnumCName( algeType:&Ast.TypeInfo): str {
      return "lns_algeType_%s" (self.getAlgeCName( algeType ) );
   }
   pub fn getAlgeValCName( algeType:&Ast.TypeInfo, valName:str ): str {
      return "lns__alge_%s_%s" (self.getFullName( algeType ), valName);
   }
   pub fn getAlgeValStrCName( algeType:&Ast.TypeInfo, valName:str ): str {
      return "lns__alge_%s_%s_t" (self.getFullName( algeType ), valName );
   }
   pub fn getNewAlgeCName( algeType:&Ast.TypeInfo, valName:str ): str {
      return "lns__new_alge_%s_%s" (self.getFullName( algeType ), valName);
   }
  
   pub fn getAlgeInitCName( algeType:&Ast.TypeInfo ): str {
      return "lns__init_alge_%s" ( self.getAlgeCName( algeType ) );
   }


   pub fn getEnumTypeName( typeInfo: &Ast.TypeInfo ): str {
      let srcType = typeInfo.$srcTypeInfo;
      let fullName = self.getFullName( srcType );

      if Ast.isPubToExternal( typeInfo.$accessMode ) {
         return fullName;
      }
      return "e_%s" (fullName );
   }

   pub fn getEnumValCName( typeInfo:&Ast.TypeInfo, valName:str ): str {
      return "%s__%s" (self.getEnumTypeName( typeInfo ), valName);
   }

   pub fn getEnumVal2NameMapName( enumType:&Ast.TypeInfo ): str {
      return "%s_val2NameMap" (self.getEnumTypeName( enumType ));
   }
   
   pub fn getClassCName( classType:&Ast.TypeInfo ) : str
   {
      return "lns_" .. self.getFullName( classType );
   }

   pub fn getNewName( classType:&Ast.TypeInfo ): str {
      return "lns_class_%s_new" (self.getClassCName( classType ));
   }
   
   pub fn getCtorName( classType:&Ast.TypeInfo ) : str {
      return "mtd_%s___init" ( self.getClassCName( classType ) );
   }

   pub fn getClassMetaName( classType:&Ast.TypeInfo ) : str
   {
      if classType.$srcTypeInfo == Ast.headTypeInfo {
         return "lns_type_meta_lns__root";
      }
      return "lns_type_meta_%s" ( self.getClassCName( classType ) );
   }

   pub fn getMethodCName( methodTypeInfo:&Ast.TypeInfo ) : str
   {
      return "mtd_%s_%s" ( self.getClassCName( methodTypeInfo.$parentInfo ),
                                 methodTypeInfo.$rawTxt );
   }

   pub fn getFuncName( typeInfo:&Ast.TypeInfo ): str {
      if typeInfo.$rawTxt == "" {
         return "lns_anonymous_%d" (typeInfo.$typeId);
      }
      switch typeInfo.$accessMode {
         case .Pub, .Global {
            if! let cFuncName = self.getBuiltinFuncNameFromType( typeInfo ) {
               return cFuncName;
            }
            switch typeInfo.$parentInfo.$kind {
               case .Class, .Enum {   
                  return self.getMethodCName( typeInfo );
               }
            }
            return self.getFullName( typeInfo );
         }
      }

      if typeInfo.$parentInfo.$kind == .Class {
         return self.getMethodCName( typeInfo );
      }
      
      return "lns_f_%d_%s" (typeInfo.$typeId, typeInfo.$rawTxt);
   }

   pub fn getNilMethodCName( methodTypeInfo:&Ast.TypeInfo ) : str
   {
      return "l_nil_mtd_%s_%s" ( self.getClassCName( methodTypeInfo.$parentInfo ),
                                 methodTypeInfo.$rawTxt );
   }
   
   pub fn getCallMethodCName( methodTypeInfo:&Ast.TypeInfo ) : str
   {
      switch methodTypeInfo.$parentInfo.$kind {
         case .List {
            return "lns_mtd_List_%s" (methodTypeInfo.$rawTxt);
         }
         case .Array {
            return "lns_mtd_Array_%s" (methodTypeInfo.$rawTxt);
         }
         case .Set {
            return "lns_mtd_Set_%s" (methodTypeInfo.$rawTxt);
         }
         case .Map {
            return "lns_mtd_Map_%s" (methodTypeInfo.$rawTxt);
         }
      }
      return "l_call_mtd_%s_%s" ( self.getClassCName( methodTypeInfo.$parentInfo ),
                                  methodTypeInfo.$rawTxt );
   }

   pub fn getClassMemberName( symbolInfo:&Ast.LowSymbol ):str {
      let classTypeInfo = symbolInfo.$scope.getClassTypeInfo();
      return "l_var_%s_%s" ( self.getClassCName( classTypeInfo ),
                                symbolInfo.$name );
   }

   /**
シンボルの C 出力名を取得する。
*/
   pub fn getSymbolName( symbolInfo:&Ast.LowSymbol ): str {
      if symbolInfo.$typeInfo.$kind == .DDD {
         return "_pDDD";
      }
      if symbolInfo.$kind == .Mbr {
         if isClassMember( symbolInfo ) {
            return self.getClassMemberName( symbolInfo );
         }
         return symbolInfo.$name;
      }
      if Ast.isPubToExternal( symbolInfo.$accessMode ) {
         if symbolInfo.$accessMode == .Global {
            return "lns_" .. symbolInfo.$name;
         }
         let moduleType = symbolInfo.$scope.getNamespaceTypeInfo().getModule();
         return "lns_%s_%s" ( self.getFullName( moduleType ), symbolInfo.$name );
      }
      switch symbolInfo.$kind {
         case .Var {
            if symbolInfo.$symbolId == invalidSymbolId {
               return symbolInfo.$name;
            }
            return "lns_%s_%d" (symbolInfo.$name, symbolInfo.$symbolId );
         }
      }
      return symbolInfo.$name;
   }

   pub fn getFormName( typeInfo:&Ast.TypeInfo ):str {
      return "l_form_%s" ( self.getFullName( typeInfo ) );
   }
   pub fn getCallFormName( typeInfo:&Ast.TypeInfo ):str {
      return "lns_call_formFunc_%s" ( self.getFullName( typeInfo ) );
   }

   pub fn getFuncCastWrapName( orgFunc:&Ast.TypeInfo, castType:&Ast.TypeInfo ) : str {
      return "wrap_%s_2_%s" ( self.getFuncName( orgFunc ), self.getFuncName( castType ) );
   }

   pub fn getEnumFuncName( enumType:&Ast.EnumTypeInfo, name:str ) : str {
      let scope = unwrap enumType.$scope;
      return self.getFuncName( (unwrap scope.getSymbolInfoChild( name )).$typeInfo );
   }
}

/**
シンボルに紐付けて管理する情報。
*/
class SymbolParam {
   pub let kind:ValKind;
   /** スコープ内の何番目の変数として扱うか */
   pub let index:int;
   /** C で扱う時の変数の型名 */
   pub let typeTxt:str;
}

/**
C へのトランスコンパイル処理で新しく宣言する変数を管理する。

元の変数は Node 内の SymbolInfo を使用できるが、
トランスコンパイル処理で新しく宣言した変数は SymbolInfo が存在しないので、
それの代わり。
*/
class WorkSymbol extend (Ast.LowSymbol) {
   let scope:&Ast.Scope {pub};
   let accessMode:Ast.AccessMode {pub};
   let name:str {pub};
   let typeInfo:&Ast.TypeInfo {pub};
   let kind:Ast.SymbolKind {pub};
   let staticFlag:bool {pub};
   let convModuleParam:&SymbolParam {pub:stem!};

      
   pub fn get_mutable(): bool {
      return false;
   }

   pub fn get_symbolId() : int {
      return invalidSymbolId;
   }
   pub fn get_hasAccessFromClosure(): bool {
      return false;
   }
}


class ScopeInfo {
   /** スコープ内で宣言されている stem 型変数の数 */
   pub let mut anyNum:int;
   /** スコープ内で宣言されている stem 型変数の数 */
   pub let mut stemNum:int;
   /** スコープ内で宣言されている var 型変数の数 */
   pub let mut varNum:int;
}

fn getOrgTypeInfo( typeInfo:&Ast.TypeInfo ) : &Ast.TypeInfo {
   if! let enumType = typeInfo.$srcTypeInfo.$nonnilableType@@@Ast.EnumTypeInfo {
      return enumType.$valTypeInfo;
   }
   return typeInfo.$srcTypeInfo.$nonnilableType;
}

fn getAccessPrimValFromSymbolDirect(
   symName:str, valKind:ValKind, symType:&Ast.TypeInfo ) mut :str
{
   let mut txt = symName;
   switch valKind {
      case .Var {
         txt = txt .. "->stem";
      }
      case .Stem {
      }
      case .Prim {
         return txt;
      }
   }

   switch getOrgTypeInfo( symType ) {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         txt = txt .. ".val.intVal";
      }
      case Ast.builtinTypeReal {
         txt = txt .. ".val.realVal";
      }
      case Ast.builtinTypeBool {
         txt = txt .. ".val.boolVal";
      }
   }
   return txt;
}


fn createSymbolParam( name:str, valKind:ValKind, cTypeTxt:str ) : SymbolParam
{
   switch valKind {
      case .Stem {
         return new SymbolParam( .Stem, 0, cTypeStem );
      }
      case .Any {
         return new SymbolParam( .Any, 0, cTypeAnyP );
      }
      case .Prim {
         return new SymbolParam( .Prim, 0, cTypeTxt );
      }
      case .Other {
         return new SymbolParam( .Other, 0, "void" );
      }
      default {
         Util.err( "not support %s:%s" ( name, valKind.$_txt ) );
      }
   }
}

/**
スコープとシンボルを管理する。
*/
class ScopeMgr {
   pri let mut scope2InfoMap:Map<&Ast.Scope,ScopeInfo>;
   pri let mut moduleCtrl:ModuleCtrl;
   pri let mut numOf__func__:int {pub};
   pri let mut moduleBlockAnyNum:int;

   pri fn __init( moduleCtrl:ModuleCtrl ) {
      self.scope2InfoMap = {};
      self.moduleCtrl = moduleCtrl;
      self.numOf__func__ = 0;
      self.moduleBlockAnyNum = 0;
   }

   static fn setSymbolParam( scopeInfo:ScopeInfo, symbol:&Ast.SymbolInfo ) : SymbolParam
   {
      let param;
      switch getValKind(symbol.$typeInfo) {
         case .Stem {
            param = new SymbolParam( .Stem, scopeInfo.stemNum, cTypeStem );
            scopeInfo.stemNum = scopeInfo.stemNum + 1;
         }
         case .Any {
            if symbol.$name == "self" {
               param = new SymbolParam( .Any, 0, cTypeAnyP );
            }
            else {
               if symbol.$kind == .Var or symbol.$kind == .Mbr {
                  param = new SymbolParam( .Any, scopeInfo.anyNum, cTypeAnyPP );
                  scopeInfo.anyNum = scopeInfo.anyNum + 1;
               }
               else {
                  if symbol.$mutable {
                     param = new SymbolParam(
                        .Any, scopeInfo.anyNum, cTypeAnyPP );
                     scopeInfo.anyNum = scopeInfo.anyNum + 1;
                  }
                  else {
                     param = new SymbolParam( .Any, 0, cTypeAnyP );
                  }
               }
            }
         }
         case .Prim {
            param = new SymbolParam(
               .Prim, 0, getCType( symbol.$typeInfo ) );
         }
         default {
            Util.err( "not support %s" (symbol.$typeInfo.getTxt(##)));
         }
      }
      return param;
   }
   
   fn setupScopeParamSub( scope:&Ast.Scope ) mut : ScopeInfo
   {
      if! let mut scopeInfo = self.scope2InfoMap[ scope ] {
         return scopeInfo;
      }

      let mut scopeInfo;
      //if not scope.$ownerTypeInfo$.$externalFlag {
         // ローカル変数のうち、stem, var として扱う変数を決定し、インデックスを紐付ける。
         scopeInfo = new ScopeInfo( 0, 0, 0 );

         if scope.$ownerTypeInfo$.isModule$() {
            // モジュールの場合、
            // lns_module_globalStemList, lns_module_path の分 + 2 する
            scopeInfo.anyNum = 2;
         }
         
         forsort symbol in scope.$symbol2SymbolInfoMap {
            if not symbol.$convModuleParam {
               let param:&SymbolParam;
               if symbol.$name ~= "__func__" {
                  switch symbol.$kind {
                     case .Var, .Arg {
                        if symbol.$hasAccessFromClosure {
                           // クロージャアクセスされるシンボルは、 Var 型で管理する
                           param = new SymbolParam( .Var, scopeInfo.varNum, cTypeVarP );
                           scopeInfo.varNum = scopeInfo.varNum + 1;
                        }
                        else {
                           param = ScopeMgr.setSymbolParam( scopeInfo, symbol );
                        }
                     }
                     case .Fun {
                        if symbol.$hasAccessFromClosure {
                           // クロージャアクセスされるシンボルは、 Var 型で管理する
                           param = new SymbolParam( .Var, scopeInfo.varNum, cTypeVarP );
                           scopeInfo.varNum = scopeInfo.varNum + 1;
                        }
                        else {
                           param = createSymbolParam(
                              symbol.$name, getValKind( symbol.$typeInfo ),
                              getCType( symbol.$typeInfo ) );
                        }
                     }
                     case .Mtd {
                        let retTypeList = symbol.$typeInfo.$retTypeInfoList;
                        param = createSymbolParam( symbol.$name, getRetKind( retTypeList ),
                                                   getCRetType( retTypeList ) );
                     }
                     case .Mbr {
                        if isClassMember( symbol ) {
                           param = (unwrap symbol.$convModuleParam)@@=SymbolParam;
                        }
                        else {
                           param = createSymbolParam(
                              symbol.$name, getValKind( symbol.$typeInfo ),
                              getCType( symbol.$typeInfo ) );
                        }
                     }
                     default {
                        param = new SymbolParam( .Other, 0, cTypeStem );
                     }
                  }
               }
               else {
                  param = new SymbolParam(
                     .Any, self.numOf__func__ + self.moduleBlockAnyNum, cTypeAnyP );
                  self.numOf__func__ = self.numOf__func__ + 1;
               }
               symbol.set_convModuleParam( param );
            }
         }
      // }
      // else {
      //    scopeInfo = new ScopeInfo( 0, 0, 0 );
      // }
      self.scope2InfoMap[ scope ] = scopeInfo;
      
      return scopeInfo;
   }

   pub fn setup( scope:&Ast.Scope, declMemberList:&List<&Nodes.DeclMemberNode>) mut
   {
      self.setupScopeParamSub( scope );

      foreach declMember in declMemberList {
         let mut scopeInfo = unwrap self.scope2InfoMap[ scope ];
         let symbol = declMember.$symbolInfo;
         if isClassMember( symbol ) {
            symbol.set_convModuleParam( ScopeMgr.setSymbolParam( scopeInfo, symbol ) );
         }
      }
   }

   pub static fn create( moduleCtrl:ModuleCtrl, initBlockScope:&Ast.Scope ):ScopeMgr
   {
      let mut scopeMgr = new ScopeMgr( moduleCtrl );
      let param = scopeMgr.setupScopeParamSub( initBlockScope );
      scopeMgr.moduleBlockAnyNum = param.anyNum;
      return scopeMgr;
   }

   pub fn setupScopeParam( scope:&Ast.Scope ) mut : int, int, int
   {
      let scopeInfo = self.setupScopeParamSub( scope );
      return scopeInfo.anyNum, scopeInfo.stemNum, scopeInfo.varNum;
   }

   pub fn getSymbolParam( symbol:&Ast.LowSymbol ) mut : &SymbolParam
   {
      if! let param = symbol.$convModuleParam {
         return param@@=SymbolParam;
      };
      let scope = symbol.$scope;

      if not self.scope2InfoMap[ scope ] {
         self.setupScopeParam( scope );
         if! let param = symbol.$convModuleParam {
            return param@@=SymbolParam;
         };
      }
      Util.err( "illegal symbol -- %s %s %s %d"
                (symbol.$name, symbol.$kind.$_txt,
                  self.moduleCtrl.getCanonicalName(
                     symbol.$scope.getNamespaceTypeInfo() ), __line__ ) );
   }

   pub fn getSymbolValKind( symbol:&Ast.LowSymbol ) mut : ValKind
   {
      let symbolParam = self.getSymbolParam( symbol );
      return symbolParam.kind;
   }

   pub fn getCTypeForSym( symbol:&Ast.LowSymbol ) mut : str, ValKind
   {
      let param = self.getSymbolParam( symbol );
      return param.typeTxt, param.kind;

      
      // let typeTxt;
      // if symbol.$hasAccessFromClosuer {
      //    return cTypeVarP, .Var;
      // }
      // typeTxt = getCType( symbol.$typeInfo, false );
      // if typeTxt == cTypeStem {
      //    if symbol.$kind == .Mbr {
      //       return typeTxt, .StemMbr;
      //    }
      //    return typeTxt, .Stem;
      // }
      // return typeTxt, .Prim;
   }

   pub fn symbol2Any( symbol:&Ast.LowSymbol ) mut : str;

   pub fn getAccessPrimValFromSymbol( symbolInfo:&Ast.LowSymbol ) mut :str
   {
      return getAccessPrimValFromSymbolDirect(
         self.moduleCtrl.getSymbolName( symbolInfo ),
         self.getSymbolValKind( symbolInfo ), symbolInfo.$typeInfo );
   }

   pub fn getAccessPrimValFromSymbolOnly( symbolInfo:&Ast.LowSymbol ) mut :str
   {
      return getAccessPrimValFromSymbolDirect(
         "", self.getSymbolValKind( symbolInfo ), symbolInfo.$typeInfo );
   }

}


fn getLiteralStrAny(txt:str):str {
   return 'lns_litStr2any( _pEnv, %s )' (txt);
}

fn getLiteralStrStem(txt:str):str {
   return 'LNS_STEM_ANY( %s )' (getLiteralStrAny(txt));
}


enum Out2HMode {
   HeaderPub,
   HeaderPri,
   SourcePub,
   SourcePri,
}

fn getOut2HeaderPrefix( mode:Out2HMode ) : str
{
   switch mode {
      case .HeaderPub {
         return "extern ";
      }
      case .SourcePri {
         return "static ";
      }
   }
   return "";
}

/**
ヘッダとソースにコードを出力する。

@param sourceStream 出力先
@param flag 公開する処理かどうか
@param code コードを出力する処理。
  この code 内では、 out2HMode を参照して処理を替える。

*/
macro _out2Header( sourceStream:sym, flag:__exp, code:stat )
{
   {}
   {
      fn processwork( out2HMode:Out2HMode ) {
         ,,code;
      }
      if ,,flag {
         ,,sourceStream.switchToHeader();
         processwork( .HeaderPub );
         ,,sourceStream.returnToSource();
         
         processwork( .SourcePub );
      }
      else {
         processwork( .SourcePri );
      }
   }
}

class convFilter extend Nodes.Filter<Opt> {
   pri let streamName: str;
   // pri let mut stream: oStream;
   pri let mut stream:Util.SimpleSourceOStream;

   pri let mut streamQueue: List<Util.SimpleSourceOStream>;

   pri let mut moduleCtrl:ModuleCtrl;
   
   // pri let mut indentQueue: List<int>;
   // pri let mut curLineNo: int;
   // pri let mut needIndent: bool;

   
   // // クラス TypeId → TypeInfo
   // pri let mut classId2TypeInfo: Map<int,&Ast.TypeInfo>;
   // // クラス TypeId → Member Node List
   // pri let mut classId2MemberList: Map<int,List<&Nodes.DeclMemberNode>>;
   // // enum TypeId -> EnumTypeInfo
   // pri let mut pubEnumId2EnumTypeInfo: Map<int,&Ast.EnumTypeInfo>;
   // // enum TypeId -> AlgeTypeInfo
   // pri let mut pubAlgeId2AlgeTypeInfo: Map<int,&Ast.AlgeTypeInfo>;
   // public 変数名 → 変数情報
   pri let mut pubVarName2InfoMap: Map<str,PubVarInfo>;
   // public 関数名 → 関数情報
   pri let mut pubFuncName2InfoMap: Map<str,PubFuncInfo>;
   // pri let mut macroDepth: int;
   pri let moduleTypeInfo: &Ast.TypeInfo;
   // pri let moduleSymbolKind: Ast.SymbolKind;
   pri let ast:Nodes.RootNode;
   pri let mut routineInfoStack:DepthStack<RoutineInfo>;
   pri let mut loopInfoStack:DepthStack<DepthInfo>;
   pri let mut processMode:ProcessMode;
   pri let mut duringDeclFunc:bool;

   
   pri let mut processingNode: &Nodes.Node!;
   pri let mut processedNodeSet: Set<&Nodes.Node>;
   pri let mut accessSymbolSet: Util.OrderedSet<&Ast.SymbolInfo>;
   pri let mut literalNode2AccessSymbolSet:Map<&Nodes.Node,&Util.OrderedSet<&Ast.SymbolInfo>>;

   pri let mut scopeMgr:ScopeMgr;

   pri let mut outputBuiltinFlag:bool;
   pri let mut enableTest:bool;
   pri let mut canConv:bool;

   pri let mut dummyNodeManager:Nodes.NodeManager;

   fn createRefNodeFromSym( symbol:&Ast.SymbolInfo ) mut: &Nodes.ExpRefNode {
      return Nodes.ExpRefNode.create(
         self.dummyNodeManager, unwrap symbol.$pos, false, [ symbol.$typeInfo ], symbol );
   }

   pub fn __init( enableTest:bool, outputBuiltin:bool, streamName: str, stream: oStream,
                  headerStream: oStream, ast:&TransUnit.ASTInfo )
   {
      super(ast.$moduleTypeInfo, ast.$moduleTypeInfo.$scope);

      self.dummyNodeManager = new Nodes.NodeManager();
      self.canConv = true;
      self.enableTest = enableTest;
      self.outputBuiltinFlag = outputBuiltin;
      self.processingNode = nil;
      self.processedNodeSet = (@);
      self.accessSymbolSet = new Util.OrderedSet<&Ast.SymbolInfo>();
      self.literalNode2AccessSymbolSet = {};

      self.duringDeclFunc = false;

      self.processMode = .Prototype;

      self.moduleTypeInfo = ast.$moduleTypeInfo;
      // self.moduleSymbolKind = ast.$moduleSymbolKind;

      self.routineInfoStack = new DepthStack<RoutineInfo>();
      self.routineInfoStack.newInfo( new RoutineInfo( Ast.builtinTypeNone ) );
      self.routineInfoStack.newInfo( new RoutineInfo( ast.$moduleTypeInfo ) );

      self.loopInfoStack = new DepthStack<DepthInfo>();
      self.loopInfoStack.newInfo( new DepthInfo() );
      self.loopInfoStack.newInfo( new DepthInfo() );
      
      //Util.errorLog( "__init: %s" (mode) );
      self.ast = unwrap ast.$node@@@Nodes.RootNode;
      //self.indentQueue = [ 0 ];
      // self.macroDepth = 0;
      self.streamName = streamName;
      //self.stream = stream;
      self.streamQueue = [];
      //self.curLineNo = 1;
      // self.classId2TypeInfo = {};
      // self.classId2MemberList = {};
      self.pubVarName2InfoMap = {};
      self.pubFuncName2InfoMap = {};
      // self.pubEnumId2EnumTypeInfo = {};
      // self.pubAlgeId2AlgeTypeInfo = {};
      //self.needIndent = false;

      self.moduleCtrl = new ModuleCtrl( self.$typeNameCtrl, self.$moduleInfoManager );
      self.scopeMgr = ScopeMgr.create(
         self.moduleCtrl, unwrap ast.$moduleTypeInfo.$scope );

      
      self.stream = new Util.SimpleSourceOStream( stream, headerStream, stepIndent );
   }

   /**
ストリームを新しく生成し、
生成したストリームを出力先のストリームに切り替える。

@return - 生成したストリーム
   */
   fn pushStream() mut : Util.memStream {
      self.streamQueue.insert( self.stream );
      let mut stream = new Util.memStream();
      self.stream = new Util.SimpleSourceOStream( stream, nil, stepIndent );
      return stream;
   }

   /**
pushStream() で切り替えた出力ストリームを元に戻す。
   */
   fn popStream() mut {
      if #self.streamQueue == 0 {
         Util.err( "streamQueue is empty." );
      }
      self.stream = self.streamQueue[ #self.streamQueue ];
      self.streamQueue.remove(##);
   }


   

   fn getFullName( typeInfo:&Ast.TypeInfo ): str {
      return self.moduleCtrl.getFullName( typeInfo );
      // let mut enumName = typeInfo.getFullName( self.typeInfo2ModuleName, true );
      // return "%s" ( (enumName.gsub( "[&@]", "" ).gsub( "%.", "_" ) ) );
   }

   fn outputAlter2MapFunc( stream:Util.SourceStream, alt2Map:&Map<&Ast.TypeInfo,&Ast.TypeInfo>);


   fn processDeclVarC(
      declFlag:bool, var:&Ast.LowSymbol, init0:bool, manageScope:&Ast.Scope! ) mut;
   
   advertise stream;
}


fn processAddModuleGlobal( stream:Util.SourceStream, valName:str ) {
   stream.writeln(
      "lns_mtd_List_insert( _pEnv, *lns_module_globalStemList, %s );"
      (valName ) );
}



fn filter( node: &Nodes.Node, filter: convFilter,
           parent: &Nodes.Node )
{
   node.processFilter( filter, new Opt( parent ) );
}

// let mut builtInModuleSet:Set<str> = (@);
// builtInModuleSet.add( "io" );
// builtInModuleSet.add( "string" );
// builtInModuleSet.add( "table" );
// builtInModuleSet.add( "math" );
// builtInModuleSet.add( "debug" );


// fn convFilter.pushIndent( newIndent:int! ) mut {
//    let indent = unwrap newIndent default self.$indent + stepIndent;
//    self.indentQueue.insert( indent );
// }

// fn convFilter.popIndent() mut {
//    if #self.indentQueue == 0 {
//       Util.err( "self.indentQueue == 0" );
//    }
//    self.indentQueue.remove(##);
// }


// fn convFilter.writeln( txt: str ) mut {
//    self.write( txt );
//    self.write( "\n" );
//    self.needIndent = true;
// }

pub override fn convFilter.processNone(
   node: Nodes.NoneNode, opt: Opt ) mut
{
   //self.writeln( "-- none" );
};

pub override fn convFilter.processImport(
   node: Nodes.ImportNode, opt: Opt ) mut
{
   if self.processMode == .Include {
      fn process( out2HMode:Out2HMode ) {
         switch out2HMode {
            case .HeaderPub {
               if node.$symbolInfo.$scope ~= node.$moduleTypeInfo.$scope {
                  return;
               }
            }
            case .SourcePub, .SourcePri {
            }
            default {
               return;
            }
         }
         self.writeln( "#include<%s.h>" ((node.$modulePath.gsub("%.", "/"))) );
      }
      _out2Header(
         self.stream, true,
         `{ process( out2HMode ); } );
   }
   else {
      self.writeln( "lns_init_%s( _pEnv );"
                    (self.moduleCtrl.getFullName( node.$moduleTypeInfo ) ));
   }
};

fn getSymbolIndex( symbol:&Ast.SymbolInfo ) : int {
   let! param = symbol.$convModuleParam {
      return 0;
   };
   return (param@@=SymbolParam).index;
}

fn convFilter.processInitModule( node: Nodes.RootNode ) mut
{
   let anyNum, stemNum, varNum = self.scopeMgr.setupScopeParam( self.ast.$moduleScope );
   
   self.processMode = .InitModule;

   let moduleFullName = self.moduleCtrl.getFullName( node.$moduleTypeInfo );
   let moduleInfoName = "lns_moduleInfo_%s" (moduleFullName);
   
   if self.outputBuiltinFlag {
      self.writeln( "static void lns_init_lns_builtin_Sub( lns_env_t * _pEnv );" );
   }
   elseif not self.canConv {
      self.writeln(
         "extern void lns_init_%s_Sub( lns_env_t * _pEnv );"
         ( moduleFullName ) );
   }


   fn process( out2HMode:Out2HMode ) {
      self.write(
         "%s%s lns_init_%s( %s _pEnv )"
         ( getOut2HeaderPrefix( out2HMode ), cTypeModP, moduleFullName, cTypeEnvP) );
      
      
      switch out2HMode {
         case .HeaderPub {
            self.writeln( ";" );
         }
         case .SourcePub {
            self.writeln( "{" );
         }
      }
   }
   
   _out2Header( self.stream, true, `{ process( out2HMode ); } );


   self.pushIndent(##);

   self.writeln( "if ( %s.readyFlag ) {" ( moduleInfoName ));
   self.pushIndent(##);
   self.writeln( "return &%s;" (moduleInfoName));
   self.popIndent();
   self.writeln( "}" );
   self.writeln( "%s.readyFlag = true;" ( moduleInfoName ) );
   self.writeln( "lns_add2list( &_pEnv->loadModuleTop, &%s);" (moduleInfoName) );
   self.writeln( "" );


   let moduleBlockName = getBlockName( self.ast.$moduleScope );
   self.writeln( "lns_block_t * %s = lns_enter_module( _pEnv, %d, %d, %d );"
                 (moduleBlockName,
                   anyNum + self.scopeMgr.$numOf__func__, stemNum, varNum ) );
   self.writeln( "%s.pBlock = %s;" (moduleInfoName, moduleBlockName));

   self.writeln( "lns_set_block_any( %s, 0, lns_module_globalStemList);"
                 (moduleBlockName) );
   self.writeln(
      "lns_setQ_any( lns_module_globalStemList, lns_class_List_new( _pEnv ));" );

   self.writeln( "lns_set_block_any( %s, 1, lns_module_path);" (moduleBlockName) );
   self.writeln(
      'lns_setQ_any( lns_module_path, lns_litStr2any( _pEnv, "%s"));'
      ( node.$moduleTypeInfo.getFullName(
         self.$typeNameCtrl, self.$moduleInfoManager ##)) );
   

   // init ブロック内の managedStemTop 用ブロック作成

   // ブロックのスコープの ScopeParam をセットアップし、
   // __func__ シンボルの情報を確定させる。
   foreach blockNode in node.$nodeManager.getBlockNodeList() {
      self.scopeMgr.setupScopeParam( blockNode.$scope );
   }
   self.writeln( "lns_enter_block( _pEnv, 0, 0, 0 );" );
   if self.canConv {
      self.writeln( "initFuncSym( _pEnv, %s );" (moduleBlockName) );
   }
   self.writeln( "" );

   if self.outputBuiltinFlag {
      self.writeln( "lns_init_lns_builtin_Sub( _pEnv );" );
   }
   if not self.canConv {
      self.writeln( "lns_init_%s_Sub( _pEnv );" ( moduleFullName) );
   }
   else {
      foreach declAlgeNode in node.$nodeManager.getDeclAlgeNodeList() {
         filter( declAlgeNode, self, node );
      }
      
      foreach child in node.$children {
         switch child.$kind {
            case Nodes.NodeKind.$DeclAlge,
                 //Nodes.NodeKind.$DeclClass,
                 Nodes.NodeKind.$DeclFunc,
                 Nodes.NodeKind.$DeclMacro,
                 Nodes.NodeKind.$TestBlock

            {
               //filter( child, self, node );
               //self.writeln( "" );
            }
            default {
               filter( child, self, node );
               self.writeln( "" );
            }
         }
      }
   }

   // init ブロック内の managedStemTop 用ブロックの開放
   self.writeln( "lns_leave_block( _pEnv );" );

   self.writeln( "return &%s;" (moduleInfoName));
   
   self.popIndent();

   self.writeln( "}" );
}

/**
builtin 関数の引数シンボル情報
*/
class BuiltinArgSymbolInfo extend Ast.SymbolInfo {
   let scope:&Ast.Scope {pub};
   let name:str {pub};
   let mut typeInfo:&Ast.TypeInfo {pub,pub};
   let allmut convModuleParam:stem! {pub,pub};
   let namespaceTypeInfo:&Ast.TypeInfo {pub};
   
   /** 左辺値になれる場合 true */
   pub override fn get_canBeLeft(): bool {
      return false;
   }
   /** 右辺値になれる場合 true */
   pub override fn get_canBeRight(): bool {
      return true;
   }
   /** このシンボルの ID */
   pub override fn get_symbolId(): int {
      return 0;
   }
   /** シンボルのアクセス */
   pub override fn get_accessMode(): Ast.AccessMode {
      return .Pub;
   }
   pub override fn get_staticFlag() :bool {
      return false;
   }
   pub override fn get_kind(): Ast.SymbolKind {
      return .Arg;
   }
   pub override fn get_pos(): &Parser.Position! {
      return nil;
   }
   /** このシンボルが mut かどうか */
   pub override fn get_mutable(): bool {
      return false;
   }
   pub override fn get_mutMode(): Ast.MutMode {
      return .IMut;
   }
   /** このシンボルがデータを保持しているかどうか */
   pub override fn get_hasValueFlag(): bool {
      return true;
   }
   pub override fn set_hasValueFlag( arg:bool ) {
   }
   pub override fn get_hasAccessFromClosure(): bool {
      return false;
   }
   pub override fn set_hasAccessFromClosure(flag:bool) {
   }

   pub override fn canAccess(
      fromScope:&Ast.Scope, access:Ast.ScopeAccess ) : &Ast.SymbolInfo!
   {
      return self;
   }

   pub override fn getOrg(): &Ast.SymbolInfo {
      return self;
   }
}

fn registerBuiltin() {
   let builtin = TransUnit.getBuiltinFunc();
   foreach symbol in builtin.$allSymbol {
      let param;
      switch symbol.$kind {
         case .Mtd, .Fun {
            let retTypeList = symbol.$typeInfo.$retTypeInfoList;
            param = createSymbolParam( symbol.$name, getRetKind( retTypeList ),
                                       getCRetType( retTypeList ) );
         }
         case .Mbr, .Var {
            param = createSymbolParam(
               symbol.$name, getValKind( symbol.$typeInfo ),
               getCType( symbol.$typeInfo ) );
         }
         default {
            Util.err( "illeal symbol -- %s %d" (symbol.$name, __line__) );
         }
      }
      symbol.set_convModuleParam( param );
   }
}

fn convFilter.processBuiltin() : &Nodes.NodeManager
{
   let mut nodeManager = new Nodes.NodeManager();
   let mut dummyPos = new Parser.Position( 0, 0 );

   fn createNodeFromSymbol(
      classInfo:&Ast.TypeInfo!, symbol:&Ast.SymbolInfo ): &Nodes.Node!
   {
      let token = new Parser.Token( .Symb, symbol.$name, dummyPos, false## );
      switch symbol.$kind {
         case .Mtd, .Fun {
            let mut argList:List<&Nodes.Node> = [];
            foreach argType, index in symbol.$typeInfo.$argTypeInfoList {
               let argToken = new Parser.Token(
                  .Symb, "arg%d" (index), dummyPos, false## );
               let dummyScope = new Ast.Scope( nil, false ## );
               let argSym = new BuiltinArgSymbolInfo(
                  dummyScope, argToken.txt, argType, nil, symbol.$typeInfo );
               
               argList.insert(
                  Nodes.DeclArgNode.create(
                     nodeManager, dummyPos, false, [ argType ],
                     argToken, argSym ) );
            }

            when! classInfo {
               let declFuncInfo = new Nodes.DeclFuncInfo(
                  .Mtd, classInfo, nil, token, argList, false, .Pub, nil,
                  symbol.$typeInfo.$retTypeInfoList, false, false );
               return Nodes.DeclMethodNode.create(
                  nodeManager, dummyPos, false, [ symbol.$typeInfo ], declFuncInfo );
            }
            else {
               let declFuncInfo = new Nodes.DeclFuncInfo(
                  .Func, nil, nil, token, argList, false, .Pub, nil,
                  symbol.$typeInfo.$retTypeInfoList, false, false );
               return Nodes.DeclFuncNode.create(
                  nodeManager, dummyPos, false, [ symbol.$typeInfo ], declFuncInfo );
            }
         }
         case .Var {
            let varToken = new Parser.Token(
                  .Symb, symbol.$name, dummyPos, false## );

            return Nodes.DeclVarNode.create(
               nodeManager, dummyPos, false, [ symbol.$typeInfo ], .Let, .Pub,
               true, [ new Nodes.VarInfo( varToken, nil, symbol.$typeInfo ) ],
               nil, [ symbol ], [ symbol.$typeInfo ], false, nil, nil, [], nil);
         }
         case .Mbr {
            return nil;
         }
         default {
            Util.err( "illegal kind -- %s" (symbol.$kind.$_txt) );
         }
      }
   }
   

   let builtin = TransUnit.getBuiltinFunc();
   foreach classInfo in builtin.$allClass {
      switch classInfo.$kind {
         case .List, .Array, .Set, .Map, .Box {
         }
         default {
            if classInfo ~= Ast.builtinTypeString {
               print( classInfo.getTxt( ## ) );

               let classScope = unwrap classInfo.$scope;

               let mut fieldList:List<&Nodes.Node> = [];
               
               let declClassNode = Nodes.DeclClassNode.create(
                  nodeManager, dummyPos, false, [ classInfo ], .Pub,
                  new Parser.Token( .Symb, classInfo.$rawTxt, dummyPos, false## ),
                  classInfo.$rawTxt, nil, fieldList, [], fieldList, [], classScope,
                  new Nodes.ClassInitBlockInfo( nil ), [], [], [], (@));

               forsort field in classScope.$symbol2SymbolInfoMap {
                  if! let node = createNodeFromSymbol( classInfo, field ) {
                     fieldList.insert( node );
                  }
               }
            }
         }
      }
   }
   foreach symbol in builtin.$allSymbol {
      if symbol.$kind == .Var or symbol.$kind == .Fun or
         symbol.$namespaceTypeInfo.$kind == .Root
      {
         createNodeFromSymbol( nil, symbol );
      }
   }
   return nodeManager;
}

pub override fn convFilter.processRoot(
   node: Nodes.RootNode, opt: Opt ) mut
{
   let nodeManager;

   registerBuiltin();
   if self.outputBuiltinFlag {
      nodeManager = self.processBuiltin();
   }
   else {
      nodeManager = node.$nodeManager;
   }

   // 最初にトップスコープのパラメータを確定させる
   self.scopeMgr.setup( self.ast.$moduleScope,
                        node.$nodeManager.getDeclMemberNodeList() );

   
   Ast.pushProcessInfo( node.$processInfo );

   foreach pragma in node.$luneHelperInfo.pragmaSet {
      match pragma {
         case .can_not_conv_code( codeSet ) {
            if codeSet.has( LuneControl.Code.C ) {
               self.canConv = false;
               break;
            }
         }
      }
   }

   self.stream.switchToHeader();
   let ifdefname =
      self.moduleCtrl.getFilePath( self.moduleTypeInfo ).gsub( "/", "_" );
   self.writeln( ```
#ifndef __%s__
#define __%s__
       ``` (ifdefname, ifdefname) );
   self.stream.returnToSource();
   
   
   self.writeln( "// %s" ( self.streamName ) );

   self.writeln( "#include <lunescript.h>" );
   self.writeln(
      "#include <%s.h>"
      ( self.moduleCtrl.getFilePath( node.$moduleTypeInfo ) ) );

   let children = node.get_children();

   self.processMode = .Include;
   foreach importNode in nodeManager.getImportNodeList() {
      filter( importNode, self, node );
   }

   self.processMode = .Prototype;
   foreach workNode in nodeManager.getTestBlockNodeList() {
      filter( workNode, self, node );
   }

   
   let moduleName = self.moduleCtrl.getFullName( node.$moduleTypeInfo );
   self.write(
      'static %s lns_moduleInfo_%s = {NULL,NULL,false, NULL, "%s", {'
      (cTypeMod, moduleName, moduleName) );
   foreach workNode in nodeManager.getTestBlockNodeList() {
      self.write( "%s__test_%s, " ( moduleName, workNode.$name.txt ) );
   }
   self.writeln( "NULL } };" );
   self.writeln( "static %s lns_module_globalStemList;" (cTypeAnyPP) );
   self.writeln( "static %s lns_module_path = NULL;" (cTypeAnyPP));


   fn process( onlyPub:bool ) {
      macro _processOnlyPub( list:__exp ) {
         foreach workNode in ,,list {
            if not workNode.$macroArgFlag {
               if onlyPub {
                  if Ast.isPubToExternal( workNode.$expType.$accessMode ) {
                     filter( workNode, self, node );
                  }
               }
               else {
                  filter( workNode, self, node );
               }
            }
         }
      }
      
      self.processMode = .Prototype;
      
      _processOnlyPub( nodeManager.getDeclEnumNodeList() );
      _processOnlyPub( nodeManager.getDeclFormNodeList() );
      _processOnlyPub( nodeManager.getDeclFuncNodeList() );
      _processOnlyPub( nodeManager.getDeclAlgeNodeList() );
      _processOnlyPub( nodeManager.getDeclClassNodeList() );
      _processOnlyPub( nodeManager.getDeclConstrNodeList() );
      _processOnlyPub( nodeManager.getDeclMethodNodeList() );
      _processOnlyPub( nodeManager.getProtoMethodNodeList() );
      if self.canConv {
         _processOnlyPub( nodeManager.getExpToDDDNodeList() );
         _processOnlyPub( nodeManager.getLiteralStringNodeList() );
         _processOnlyPub( nodeManager.getExpCastNodeList() );
      }

      self.processMode = .WideScopeVer;
      foreach decl in nodeManager.getDeclVarNodeList() {
         filter( decl, self, node );
      }
      // foreach child in children {
      //    if child.$kind == Nodes.NodeKind.$DeclVar {
      //       if! let declVarNode = child@@@Nodes.DeclVarNode {
      //          if not onlyPub or Ast.isPubToExternal( declVarNode.$accessMode ) {
      //             filter( child, self, node );
      //          }
      //       }
      //    }
      // }

      _processOnlyPub( nodeManager.getDeclAlgeNodeList() );
      _processOnlyPub( nodeManager.getDeclClassNodeList() );

      _processOnlyPub( nodeManager.getDeclConstrNodeList() );
      _processOnlyPub( nodeManager.getDeclMethodNodeList() );
      _processOnlyPub( nodeManager.getDeclFuncNodeList() );


      self.processMode = .DefClass;
      _processOnlyPub( nodeManager.getDeclClassNodeList() );
   }

   process( not self.canConv );

   if self.canConv {
      self.processMode = .StringFormat;
      foreach litStr in nodeManager.getLiteralStringNodeList() {
         if not litStr.$macroArgFlag {
            filter( litStr, self, node );
         }
      }
      
      
      self.processMode = .Immediate;
      self.processedNodeSet = (@);

      fn procssLiteralCtor( literalNodeList:&List<&Nodes.Node> ) {
         foreach literalNode in literalNodeList {
            self.processingNode = literalNode;
            if not self.processedNodeSet.has( literalNode ) and
               not literalNode.$macroArgFlag
            {
               self.accessSymbolSet = new Util.OrderedSet<&Ast.SymbolInfo>();
               filter( literalNode, self, node );
               self.processedNodeSet.add( node );
            }
         }
      }
      procssLiteralCtor( nodeManager.getLiteralListNodeList() );
      procssLiteralCtor( nodeManager.getLiteralArrayNodeList() );
      procssLiteralCtor( nodeManager.getLiteralSetNodeList() );
      procssLiteralCtor( nodeManager.getLiteralMapNodeList() );
      self.processingNode = nil;

      
      self.processMode = .Intermediate;
      foreach callNode in nodeManager.getExpCallNodeList() {
         filter( callNode, self, node );
      }
      foreach dddNode in nodeManager.getExpToDDDNodeList() {
         filter( dddNode, self, node );
      }
      foreach castNode in nodeManager.getExpCastNodeList() {
         filter( castNode, self, node );
      }

      self.processMode = .DefWrap;
      foreach callNode in nodeManager.getExpCallNodeList() {
         filter( callNode, self, node );
      }
      


      self.processMode = .InitFuncSym;
      self.writeln( "static void initFuncSym( %s _pEnv, %s pBlock )\n{"
                    (cTypeEnvP, cTypeBlockP) );
      self.pushIndent( ## );
      
      foreach declConstrNode in nodeManager.getDeclConstrNodeList() {
         filter( declConstrNode, self, node );
      }
      foreach declMethodNode in nodeManager.getDeclMethodNodeList() {
         filter( declMethodNode, self, node );
      }
      foreach declFuncNode in nodeManager.getDeclFuncNodeList() {
         filter( declFuncNode, self, node );
      }

      self.popIndent();
      self.writeln( "}" );
      


      
      self.processMode = .Form;
      foreach declEnumNode in nodeManager.getDeclEnumNodeList() {
         filter( declEnumNode, self, node );
      }
      foreach declAlgeNode in nodeManager.getDeclAlgeNodeList() {
         filter( declAlgeNode, self, node );
      }
      foreach declConstrNode in nodeManager.getDeclConstrNodeList() {
         filter( declConstrNode, self, node );
      }
      foreach declMethodNode in nodeManager.getDeclMethodNodeList() {
         filter( declMethodNode, self, node );
      }
      foreach declMethodNode in nodeManager.getProtoMethodNodeList() {
         filter( declMethodNode, self, node );
      }
      foreach declFormNode in nodeManager.getDeclFormNodeList() {
         filter( declFormNode, self, node );
      }
      foreach declFuncNode in nodeManager.getDeclFuncNodeList() {
         self.duringDeclFunc = false;
         filter( declFuncNode, self, node );
      }
   }

   
   

   self.processInitModule( node );

   foreach testBlock in nodeManager.getTestBlockNodeList() {
      filter( testBlock, self, node );
   }

   if self.outputBuiltinFlag {
      self.writeln( '#include "lns_builtinInc.c"' );
   }
   

   self.stream.switchToHeader();
   self.writeln( "#endif" );
   self.stream.returnToSource();
   
   Ast.popProcessInfo();
};

pub override fn convFilter.processSubfile(
   node: Nodes.SubfileNode, opt: Opt ) mut
{
}

fn getAccessPrimValFromStem( dddFlag:bool, typeInfo:&Ast.TypeInfo, index:int ) :str
{
   let mut txt = "";
   if dddFlag {
      txt = ".val.pAny->val.ddd.stemList[ %d ]" (index);
   }

   let expType;

   if! let enumType = typeInfo.$srcTypeInfo@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }
   else {
      expType = typeInfo.$srcTypeInfo;
   }
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         txt = txt .. ".val.intVal";
      }
      case Ast.builtinTypeReal {
         txt = txt .. ".val.realVal";
      }
      case Ast.builtinTypeBool {
         txt = txt .. ".val.boolVal";
      }
      default {
         if getValKind( expType ) == .Any {
            txt = txt .. ".val.pAny";
         }
      }
   }
   return txt;
}

fn getAccessValFromStem( typeInfo:&Ast.TypeInfo ) :str
{
   let txt;

   let expType;

   if! let enumType = typeInfo.$srcTypeInfo@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }
   else {
      expType = typeInfo.$srcTypeInfo;
   }
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         txt = ".val.intVal";
      }
      case Ast.builtinTypeReal {
         txt = ".val.realVal";
      }
      case Ast.builtinTypeBool {
         txt = ".val.boolVal";
      }
      default {
         if getValKind( typeInfo ) == .Any {
            txt = accessAny;
         }
         else {
            txt = "";
         }
      }
   }
   return txt;
}

fn convFilter.processBlockPreProcess( scope:&Ast.Scope ) mut {
   self.pushIndent( ## );
   let anyNum, stemNum, varNum = self.scopeMgr.setupScopeParam( scope );
   self.writeln( "lns_block_t * %s = lns_enter_block( _pEnv, %d, %d, %d );"
                 ( getBlockName( scope ), anyNum, stemNum, varNum ) );
   self.routineInfoStack.pushDepth();
   self.loopInfoStack.pushDepth();
}

fn convFilter.processBlockPostProcess() mut {
   self.loopInfoStack.popDepth();
   self.routineInfoStack.popDepth();
   self.writeln( "lns_leave_block( _pEnv );" );
   self.popIndent();
}

fn convFilter.pushRoutine( funcType:&Ast.TypeInfo, blockNode:&Nodes.BlockNode ) mut {
   self.processBlockPreProcess( blockNode.$scope );
   self.routineInfoStack.newInfo( new RoutineInfo( funcType ) );
}

fn convFilter.popRoutine() mut {
   self.routineInfoStack.delInfo();
   self.processBlockPostProcess();
}

fn convFilter.processLoopPreProcess( blockNode:&Nodes.BlockNode ) mut {
   self.processBlockPreProcess( blockNode.$scope );
   self.loopInfoStack.newInfo( new DepthInfo() );
}

fn convFilter.processLoopPostProcess() mut {
   self.loopInfoStack.delInfo();
   self.processBlockPostProcess();
}

pub override fn convFilter.processBlockSub(
   node: Nodes.BlockNode, opt: Opt ) mut
{
   // ローカル変数のうち、 any として扱う変数を決定し、インデックスを紐付ける。
   self.scopeMgr.setupScopeParam( node.$scope );

   // クロージャでアクセスする外部変数を宣言
   let scope = node.$scope;
   forsort symbol in scope.$closureSymMap {
      // if symbol.$accessFromClosure == .Write {
      //    self.write( cTypeVarP );
      // }
      // else {
      //    self.write( cTypeStem );
      // }
      let typeTxt, valKind = self.scopeMgr.getCTypeForSym( symbol );
      self.write(
         "%s %s = l_form_closure_var( _pForm, %d )"
         ( typeTxt, self.moduleCtrl.getSymbolName( symbol ),
           unwrap scope.$closureSym2NumMap[ symbol ] ) );
      // if valKind == .Stem {
      //    self.write( getAccessPrimValFromStem( false, symbol.$typeInfo, 1 ) );
      // }
      self.writeln( ";" );
   }

   let mut loopFlag = false;
   let mut readyBlock = false;
   
   let mut word = "";
   switch node.get_blockKind() {
      case .If, .Elseif {
         word = "{";
      }
      case .Else {
         word = "";
      }
      case .While {
         loopFlag = true;
      }
      case .Repeat {
         word = "";
         loopFlag = true;
      }
      case .For {
         word = "";
         loopFlag = true;
      }
      case .Apply {
         word = "";
         loopFlag = true;
      }
      case .Foreach {
         word = "";
         loopFlag = true;
      }
      case .Macro {
         word = "";
      }
      case .Func {
         readyBlock = true;
         word = "";
      }
      case .Default {
         word = "";
      }
      case .Block {
         word = "{";
      }
      case .Macro {
         word = "";
      }
      case .LetUnwrap {
         readyBlock = true;
         word = "";
      }
      case .LetUnwrapThenDo {
         word = "";
      }
      case .IfUnwrap {
         readyBlock = true;
         word = "";
      }
      case .When {
         readyBlock = true;
         word = "";
      }
   }
   if loopFlag {
      readyBlock = true;
   }
   
   
   self.writeln( "%s // %d" ( word, node.$pos.lineNo ) );

   if not readyBlock {
      self.processBlockPreProcess( node.$scope );
   }
   // if loopFlag {
   //    self.writeln( "lns_reset_block( _pEnv );" );
   // }
   
   let stmtList = node.get_stmtList();
   foreach statement in stmtList {
      filter( statement, self, node );
      self.writeln( "" );
   }

   if not readyBlock {
      self.processBlockPostProcess();
   }
   
   if node.get_blockKind() == .Block {
      self.writeln( "}" );
   }
};

pub override fn convFilter.processStmtExp(
   node: Nodes.StmtExpNode, opt: Opt ) mut
{
   filter( node.$exp,  self, node );
   self.write( "; // %d" (node.$pos.lineNo) );
};

/** 処理対象の式を出力する */
form processExp();

fn getLiteral2Stem( valTxt:str, typeInfo:&Ast.TypeInfo ) : str {
   switch typeInfo.$srcTypeInfo {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return "LNS_STEM_INT( %s )" (valTxt);
      }
      case Ast.builtinTypeReal {
         return "LNS_STEM_REAL( %s )" (valTxt);
      }
      case Ast.builtinTypeBool {
         return "LNS_STEM_BOOL( %s )" (valTxt);
      }
      default {
         return "NULL";
      }
   }
}


fn getStemTypeId( typeInfo:&Ast.TypeInfo ): str {
   if typeInfo.$nilable {
      return "lns_stem_type_none";
   }
   switch typeInfo {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return "lns_stem_type_int";
      }
      case Ast.builtinTypeInt, Ast.builtinTypeReal {
         return "lns_stem_type_real";
      }
      case Ast.builtinTypeBool {
         return "lns_stem_type_bool";
      }
      default {
         return "lns_stem_type_any";
      }
   }
}

fn getPrepareClosure(
   scopeMgr:ScopeMgr, funcName:str,
   argNum:int, hasDDD:bool, symList:&List<&Ast.SymbolInfo> ) : str
{
   let mut txt;

   txt = "lns_func2any( _pEnv, (lns_closure_t *)%s, %d, %s, %d"
       (funcName, argNum, hasDDD, #symList );
   foreach symbolInfo in symList {
      txt = txt .. ", ";
      txt = txt .. scopeMgr.symbol2Any( symbolInfo );
   }
   txt = txt .. ")";
   return txt;
}


fn getFunc2any(
   moduleCtrl:ModuleCtrl, scopeMgr:ScopeMgr, funcType:&Ast.TypeInfo ) : str
{
   let argList = funcType.$argTypeInfoList;
   let hasDDD =
      #argList > 0 and argList[ #argList ].$kind == .DDD or false;
   
   return getPrepareClosure(
      scopeMgr, moduleCtrl.getFuncName( funcType ),
      #funcType.$argTypeInfoList, hasDDD, (unwrap funcType.$scope).$closureSymList );
}

fn ScopeMgr.symbol2Any( symbol:&Ast.LowSymbol ) mut : str
{
   if symbol.$kind == .Fun {
      return getFunc2any( self.moduleCtrl, self, symbol.$typeInfo );
   }
   let name = self.moduleCtrl.getSymbolName( symbol );
   switch self.getSymbolValKind( symbol ) {
      case .Var {
         return name;
      }
      default {
         Util.err( "not support -- %s" (symbol.$typeInfo.getTxt( ## )) );
      }
   }
}



fn convFilter.processSym2stem( symbolInfo:&Ast.LowSymbol) mut
{
   let valKind = self.scopeMgr.getSymbolValKind( symbolInfo );
   switch valKind {
      case .Any {
         self.write( "LNS_STEM_ANY( " );
         if symbolInfo.$kind == .Var {
            self.write( "*" );
         }
         self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
         self.write( ")" );
         return;
      }
      case .Var {
         self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
         self.write( "->stem" );
         return;
      }
      case .Stem {
         self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
         return;
      }
   }
   
   let mut expType = symbolInfo.$typeInfo.$srcTypeInfo;
   if! let enumType = expType@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }

   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         self.write( "LNS_STEM_INT( " );
         self.write( "" );
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbolInfo ) );
         self.write( ")" );
      }
      case Ast.builtinTypeReal {
         self.write( "LNS_STEM_REAL( " );
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbolInfo ) );
         self.write( ")" );
      }
      case Ast.builtinTypeBool {
         self.write( "LNS_STEM_BOOL( " );
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbolInfo ) );
         self.write( ")" );
      }
      case Ast.builtinTypeStem, Ast.builtinTypeStem_ {
         self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
      }
      default {
         switch expType.$kind {
            case .DDD {
               self.write( "_pDDD" );
            }
            case .Func {    
               if! let scope = expType.$scope {
                  self.write( "LNS_STEM_ANY(" );
                  self.write( getFunc2any( self.moduleCtrl, self.scopeMgr, expType ) );
                  self.write( ")" );
               }
               else {   
                  Util.err( "illegal func" );
               }
            }
            default {
               self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
            }
         }
      }
   }
}

pub override fn convFilter.processDeclEnum(
   node: Nodes.DeclEnumNode, opt: Opt ) mut
{
   let enumType = unwrap node.$expType@@@Ast.EnumTypeInfo;

   let enumFullName = self.moduleCtrl.getEnumTypeName( enumType );
   let fullName = self.getFullName( enumType );

   let isStrEnum = enumType.$valTypeInfo.equals( Ast.builtinTypeString ##);

   switch self.processMode {
      case .Prototype {
         fn process(out2HMode:Out2HMode) {
            let prefix = getOut2HeaderPrefix( out2HMode );
            foreach valName, index in node.$valueNameList {
               let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
               let enumValName =
                  self.moduleCtrl.getEnumValCName( enumType, valName.txt );
               if isStrEnum {
                  self.writeln( "%s%s %s;" (prefix, cTypeAnyP, enumValName ));
               }
               else {
                  switch out2HMode {
                     case .HeaderPub, .SourcePri {
                        let valTxt = "%s" (Ast.getEnumLiteralVal(valInfo.$val));
                        self.writeln( "#define %s %s" ( enumValName, valTxt ) );
                     }
                  }
               }
            }
            switch out2HMode {
               case .HeaderPub, .SourcePri {
                  self.writeln(
                     "%s%s %s_get__allList( lns_env_t * _pEnv );"
                     (prefix, cTypeAnyP, enumFullName) );
                  self.writeln( "%s%s %s_get__txt( %s _pEnv, %s val );"
                                ( prefix, cTypeAnyP, enumFullName, cTypeEnvP,
                                  getCType( enumType.$valTypeInfo ) ) );
                  
                  self.writeln(
                     "%s%s %s( %s _pEnv, %s val );"
                     ( prefix, cTypeStem,
                       self.moduleCtrl.getEnumFuncName( enumType, "_from" ),
                       cTypeEnvP, getCType( enumType.$valTypeInfo ) ) );
               }
            }
         }
         _out2Header(
            self.stream,
            Ast.isPubToExternal( enumType.$accessMode ),
            `{
               process( out2HMode );
            });
         
         self.writeln( "static %s %s_val2NameMap;" (cTypeAnyP, enumFullName) );
         self.writeln( "static %s %s_allList;" (cTypeAnyP, enumFullName) );
      }
      case .Form {
         // _allList() の宣言
         if not Ast.isPubToExternal( enumType.$accessMode ) {
            self.write( "static " );
         }
         self.writeln(
            "%s %s_get__allList( lns_env_t * _pEnv )"
            (cTypeAnyP, enumFullName) );
         self.writeln( "{" );
         self.writeln( "    return %s_allList;" (enumFullName) );
         self.writeln( "}" );

         if not isStrEnum {
            let typeTxt;
            if enumType.$valTypeInfo.$srcTypeInfo == Ast.builtinTypeReal {
               typeTxt = "real";
            }
            else {
               typeTxt = "int";
            }
         }

         {
            // get__txt() の宣言
            if not Ast.isPubToExternal( enumType.$accessMode ) {
               self.write( "static " );
            }
            self.writeln( "%s %s_get__txt( %s _pEnv, %s val ) {"
               ( cTypeAnyP, enumFullName, cTypeEnvP,
                 getCType( enumType.$valTypeInfo ) ) );
            self.pushIndent( ## );

            self.write( "%s _work =  lns_mtd_Map_get( _pEnv, %s, "
                        ( cTypeStem,
                          self.moduleCtrl.getEnumVal2NameMapName( enumType ) ) );
            let workSym = new WorkSymbol(
               unwrap self.moduleTypeInfo.$scope,
               .Local, "val", enumType.$valTypeInfo, .Arg, false,
               new SymbolParam( getValKind( enumType.$valTypeInfo ),
                                0, getCType( enumType.$valTypeInfo ) ) );
            
            self.processSym2stem( workSym );
            self.writeln( ");" );
            self.writeln( "return _work%s;" (accessAny)  );
            
            self.popIndent();
            self.writeln( "}" );
         }


         {
            // __from() の宣言
            if not Ast.isPubToExternal( enumType.$accessMode ) {
               self.write( "static " );
            }
            self.writeln( "%s %s( %s _pEnv, %s val ) {"
               ( cTypeStem, self.moduleCtrl.getEnumFuncName( enumType, "_from" ),
                 cTypeEnvP, getCType( enumType.$valTypeInfo ) ) );
            self.pushIndent( ## );

            self.write( "%s key = " (cTypeStem) );
            let workSym = new WorkSymbol(
               unwrap self.moduleTypeInfo.$scope,
               .Local, "val", enumType.$valTypeInfo, .Arg, false,
               new SymbolParam( getValKind( enumType.$valTypeInfo ),
                                0, getCType( enumType.$valTypeInfo ) ) );
            self.processSym2stem( workSym );
            self.writeln( ";" );

            self.writeln( "%s _work = lns_mtd_Map_get( _pEnv, %s, key );"
                          ( cTypeStem,
                            self.moduleCtrl.getEnumVal2NameMapName( enumType ) ) );
            
            self.writeln( "if ( _work.type == lns_stem_type_nil ) {" );
            self.pushIndent(##);
            self.writeln( "return lns_global.nilStem;" );
            self.popIndent();
            self.writeln( "}" );
            self.writeln( "return key;" );
            
            self.popIndent();
            self.writeln( "}" );
         }


         // enum 情報の初期化関数の宣言
         self.writeln( "static void init_%s( lns_env_t * _pEnv )" ( enumFullName ) );
         self.writeln( "{" );
         self.pushIndent(##);



         let mut anyVarList:List<str> = [];
         // enum 値のセット
         if isStrEnum {
            foreach valName, index in node.$valueNameList {
               let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
               // pending: C の文字列リテラル表現できないものを対応できていない
               let valTxt = '"%s"' (Ast.getEnumLiteralVal(valInfo.$val));
               let anyVar = self.moduleCtrl.getEnumValCName( enumType, valName.txt );
               anyVarList.insert( "LNS_STEM_ANY( %s )" (anyVar) );

               // self.writeln( "lns_setQ( %s, lns_litStr2any( _pEnv, %s ) );"
               //               (anyVar, valTxt));
               self.writeln( "%s = lns_litStr2any( _pEnv, %s );" (anyVar, valTxt));
            }
         }
         else {
            foreach valName, index in node.$valueNameList {
               let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
               let valTxt = '%s' (Ast.getEnumLiteralVal(valInfo.$val));
               let anyVar = "_%s" (valName.txt);
               anyVarList.insert( anyVar );
               self.write( "%s %s = " (cTypeStem, anyVar));
               self.write( getLiteral2Stem( valTxt, enumType.$valTypeInfo ) );
               self.writeln( ";" );
            }
         }

         // _allList のセット
         let allListName = "%s_allList" (enumFullName);
         self.write( allListName );
         self.writeln( " = lns_class_List_new( _pEnv );" );
         processAddModuleGlobal(
            self.stream, "LNS_STEM_ANY( %s )" (allListName) );
         
         foreach anyVar in anyVarList {
            self.writeln(
               "lns_mtd_List_insert( _pEnv, %s_allList, %s );"
               (enumFullName, anyVar ));
         }

         // _val2NameMap のセット
         let val2NameMapName = "%s_val2NameMap" (enumFullName);
         self.write( val2NameMapName );
         self.writeln( " = lns_class_Map_new( _pEnv );"  );
         processAddModuleGlobal(
            self.stream, "LNS_STEM_ANY( %s )" (val2NameMapName) );
         
         foreach anyVar, index in anyVarList {
            self.writeln(
               "lns_mtd_Map_add( _pEnv, %s_val2NameMap, %s, "
               (enumFullName, anyVar ));
            
            self.writeln(
               '  LNS_STEM_ANY( lns_litStr2any( _pEnv, "%s.%s" ) ) );'
               (fullName, node.$valueNameList[ index ].txt));
         }
         

         self.popIndent();
         self.writeln( "}" );
      }
      case .InitModule {
         self.writeln( "init_%s( _pEnv );" ( enumFullName ) );
      }
   }
   
   

   
//    let mut access = node.$accessMode == .Global and "" or "local ";
//    let mut enumFullName = node.$name.txt;
//    let enumType = unwrap node.$expType@@@Ast.EnumTypeInfo;
//    let parentInfo = enumType.$parentInfo;
//    let mut isTopNS = true;
//    if parentInfo ~= Ast.headTypeInfo and parentInfo.$kind == .Class {
//       enumFullName = "%s.%s" (self.getFullName( parentInfo ), enumFullName );
//       access = "";
//       isTopNS = false;
//    }


//    self.writeln( "%s%s = {}" (access, enumFullName) );
//    if isTopNS and node.$accessMode == .Pub {
//       if self.needModuleObj {
//          self.writeln( "_moduleObj.%s = %s" ( enumFullName, enumFullName ) );
//       }
//    }


//    if enumType.$accessMode == .Pub {
//       self.pubEnumId2EnumTypeInfo[ enumType.$typeId ] = enumType;
//    }

//    self.writeln( "%s._val2NameMap = {}" (enumFullName) );
//    self.writeln( ```function %s:_getTxt( val )
//    local name = self._val2NameMap[ val ]
//    if name then
//       return string.format( "%s.%%s", name )
//    end
//    return string.format( "illegal val -- %%s", val )
// end
// function %s._from( val )
//    if %s._val2NameMap[ val ] then
//       return val
//    end
//    return nil
// end
//     ``` (enumFullName, enumFullName,
//           enumFullName, enumFullName ) );
//    self.writeln(
// ```
// %s.__allList = {}
// function %s.get__allList()
//    return %s.__allList
// end
// ``` (enumFullName, enumFullName, enumFullName ) );

//    foreach valName, index in node.$valueNameList {
//       let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
//       let mut valTxt = "%s" (Ast.getEnumLiteralVal(valInfo.$val));
//       if enumType.$valTypeInfo.equals( Ast.builtinTypeString ##) {
//          valTxt = "'%s'" (Ast.getEnumLiteralVal(valInfo.$val));
//       }
//       self.writeln( "%s.%s = %s" (enumFullName, valName.txt, valTxt ) );

//       self.writeln( "%s._val2NameMap[%s] = '%s'"
//          (enumFullName, valTxt, valName.txt ) );
//       self.writeln( "%s.__allList[%d] = %s.%s"
//          (enumFullName, index, enumFullName, valName.txt ) );
//    }
}

fn isGenericType( typeInfo:&Ast.TypeInfo ): bool {
   if Ast.isGenericType( typeInfo ) {
      return true;
   }
   switch typeInfo.$kind {
      case .Class, .IF {
         if #typeInfo.$itemTypeInfoList > 0 {
            return true;
         }
      }
   }
   return false;
}



// fn convFilter.getMapInfo( typeInfo:&Ast.TypeInfo ): str, bool, str
// {
   // let mut nonnilableType = typeInfo.$srcTypeInfo;
   // if typeInfo.$nilable {
   //    nonnilableType = typeInfo.$nonnilableType;
   // }

   // let mut child = "{}";
   // let mut funcTxt = "";
   // switch nonnilableType.$kind {
   //    case .Stem {
   //       funcTxt = '_lune._toStem';
   //    }
   //    case .Class, .IF {
   //       if not nonnilableType.equals( Ast.builtinTypeString ##) {
   //          funcTxt = '%s._fromMap' (self.getFullName(nonnilableType));
   //          if isGenericType( nonnilableType ) {
   //             let mut memStream = new Util.memStream();
   //             self.outputAlter2MapFunc(
   //                memStream, nonnilableType.createAlt2typeMap(false) );
   //             child = memStream.$txt;
   //          }
   //       }
   //       else {
   //          funcTxt = '_lune._toStr';
   //       }
   //    }
   //    case .Enum, .Alge {
   //       funcTxt = '%s._from' (self.getFullName(nonnilableType));
   //    }
   //    case .Prim {
   //       switch nonnilableType {
   //          case Ast.builtinTypeInt {
   //             funcTxt = '_lune._toInt';
   //          }
   //          case Ast.builtinTypeReal {
   //             funcTxt = '_lune._toReal';
   //          }
   //          case Ast.builtinTypeBool {
   //             funcTxt = '_lune._toBool';
   //          }
   //          default {
   //             Util.err( "unknown type -- %s" (nonnilableType.getTxt(##)) );
   //          }
   //       }
   //    }
   //    case .Map {
   //       funcTxt = '_lune._toMap';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let keyFuncTxt, keyNilable, keyChild = self.getMapInfo( itemList[1] );
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[2] );

   //       child = "{ { func = %s, nilable = %s, child = %s }, \n"
   //           (keyFuncTxt, keyNilable, keyChild) ..
   //          "{ func = %s, nilable = %s, child = %s } }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .Set {
   //       funcTxt = '_lune._toSet';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[1] );

   //       child = "{ func = %s, nilable = %s, child = %s }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .List, .Array {
   //       funcTxt = '_lune._toList';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[1] );

   //       child = "{ { func = %s, nilable = %s, child = %s } }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .Alternate {
   //       let prefix = "obj.__alt2mapFunc.%s" ( nonnilableType.$rawTxt );
   //       funcTxt = "%s.func" ( prefix );
   //       child = "%s.child" ( prefix );
   //    }
   // }
   // return funcTxt, typeInfo.$nilable, child;
// }

fn processAlgeNewProto( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                        typeInfo:&Ast.TypeInfo, valInfo:&Ast.AlgeValInfo )
{
   stream.write(
      "%s %s( %s _pEnv"
      ( cTypeStem,
        moduleCtrl.getNewAlgeCName( typeInfo, valInfo.$name ), cTypeEnvP ) );

   foreach typeInfo, index in valInfo.$typeList {
      stream.write( ", %s _val%d" (getCType( typeInfo ), index) );
   }
   stream.write( ")" );
}

fn processAlgePrototype( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                         node:Nodes.DeclAlgeNode )
{
   let algeType = node.$algeType;
   let mut valList:List<&Ast.AlgeValInfo> = [];
   
   forsort valInfo in algeType.$valInfoMap {
      valList.insert( valInfo );
   }

   fn process() {
      // 各値を識別する enum を宣言
      stream.writeln( "typedef enum {" );
      stream.pushIndent( ## );
      let algeTypeName = moduleCtrl.getAlgeCName( node.$expType );
      let enumName = moduleCtrl.getAlgeEnumCName( node.$expType );

      
      foreach valInfo, index in valList {
         if index > 1 {
            stream.writeln( "," );
         }
         stream.write( "%s_%s" (enumName, valInfo.$name) );
      }
      stream.writeln( "" );
      stream.popIndent();
      stream.writeln( "} %s;" ( enumName ) );

      // alge 型の struct を宣言
      foreach valInfo in valList {
         if #valInfo.$typeList > 0 {
            stream.writeln( "typedef struct {" );
            stream.pushIndent(##);
            foreach typeInfo, index in valInfo.$typeList {
               stream.writeln( "%s _val%d;" (getCType( typeInfo ), index) );
            }
            stream.popIndent();
            stream.writeln(
               "} %s;" (moduleCtrl.getAlgeValStrCName( node.$expType, valInfo.$name) ) );
         }
      }

      // alge 型のパラメータ有りの値を生成する関数宣言
      foreach valInfo in valList {
         if #valInfo.$typeList > 0 {
            processAlgeNewProto( stream, moduleCtrl, node.$expType, valInfo );
            stream.writeln( ";" );
         }
      }
   }


   _out2Header(
      stream,
      Ast.isPubToExternal( node.$expType.$accessMode ),
      `{
         switch out2HMode {
            case .HeaderPub, .SourcePri {
               process();
            }
         }
      });


   // alge 型のパラメータ無しの値を初期化する関数宣言
   stream.writeln(
      "static void %s( %s _pEnv );"
      (moduleCtrl.getAlgeInitCName(node.$expType), cTypeEnvP ) );
}

fn processAlgeWideScope( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                         node:Nodes.DeclAlgeNode )
{
   let algeType = node.$algeType;
   let mut valList:List<&Ast.AlgeValInfo> = [];
   
   forsort valInfo in algeType.$valInfoMap {
      valList.insert( valInfo );
   }

   fn process( out2HMode:Out2HMode ) {
      let prefix = getOut2HeaderPrefix( out2HMode );

      foreach valInfo, index in valList {
         if #valInfo.$typeList == 0 {
            let varName = moduleCtrl.getAlgeValCName( node.$expType, valInfo.$name );
            stream.writeln(
               "%s%s %s;" (prefix, cTypeStem, varName ) );
            stream.writeln(
               "%s%s %s_any;" (prefix, cTypeAny, varName ) );
         }
      }
   }
   
   _out2Header(
      stream,
      Ast.isPubToExternal( node.$expType.$accessMode ),
      `{
         switch out2HMode {
            case .HeaderPub, .SourcePri, .SourcePub {
               process( out2HMode );
            }
         }
      });

   let algeTypeName = moduleCtrl.getAlgeCName( node.$expType );
   stream.writeln( "static %s %s_type2NameMap;" (cTypeAnyP, algeTypeName) );
}

fn processAlgeForm( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                    node:Nodes.DeclAlgeNode )
{
   let algeType = node.$algeType;
   let mut valList:List<&Ast.AlgeValInfo> = [];
   
   forsort valInfo in algeType.$valInfoMap {
      valList.insert( valInfo );
   }

   let algeName = moduleCtrl.getAlgeCName( algeType );
   let type2NameMapName = "%s_type2NameMap" ( algeName );
   
   if not Ast.isPubToExternal( algeType.$accessMode ) {
      stream.write( "static " );
   }
   stream.writeln( "%s %s_get__txt( %s _pEnv, %s pAny ) {"
      ( cTypeAnyP, algeName, cTypeEnvP, cTypeAnyP ) );
   stream.pushIndent( ## );
   stream.writeln(
      "return lns_mtd_Map_get( _pEnv, %s, LNS_STEM_INT( pAny->val.alge.type ) )%s;"
      ( type2NameMapName, accessAny) );
   stream.popIndent();
   stream.writeln( "}" );


   stream.writeln(
      "static void %s( %s _pEnv ) {"
      (moduleCtrl.getAlgeInitCName(algeType), cTypeEnvP ) );

   stream.pushIndent(##);

   // 名前のマップを定義
   stream.writeln( type2NameMapName .. " = lns_class_Map_new( _pEnv );"  );
   processAddModuleGlobal( stream, "LNS_STEM_ANY( %s )" (type2NameMapName) );

   let fullName = moduleCtrl.getFullName( algeType );
   let enumName = moduleCtrl.getAlgeEnumCName( algeType );
   
   foreach valInfo, index in valList {
      stream.write(
         "lns_mtd_Map_add( _pEnv, %s, LNS_STEM_INT( %s_%s ), "
         (type2NameMapName, enumName, valInfo.$name ));
      
      stream.writeln(
         'LNS_STEM_ANY( lns_litStr2any( _pEnv, "%s.%s" ) ) );'
         (fullName, valInfo.$name ));
   }

   
   // パラメータの無い値の初期化関数

   foreach valInfo, index in valList {
      if #valInfo.$typeList == 0 {
         let varName = moduleCtrl.getAlgeValCName( algeType, valInfo.$name );
         stream.writeln(
            "lns_init_alge( &%s, &%s_any, %s_%s );"
            ( varName, varName, enumName, valInfo.$name ) );
      }
   }
   
   stream.popIndent();
   stream.writeln( "}" );


   // パラメータを持つ値の生成関数
   foreach valInfo, index in valList {
      if #valInfo.$typeList > 0 {
         let mut hasAnyFlag = false;
         foreach valType, paramIndex in valInfo.$typeList {
            if isStemType( valType ) {
               hasAnyFlag = true;
               break;
            }
         }
         
         let valStruct = moduleCtrl.getAlgeValStrCName( algeType, valInfo.$name );
         let gcTxt;

         if hasAnyFlag {
            gcTxt = "lns_gc_alge_%s_%s" (algeName, valInfo.$name);
            stream.writeln(
               "static void %s( %s _pEnv, void * pVal ) {" (gcTxt, cTypeEnvP) );
            stream.pushIndent( ## );
            stream.writeln( "%s *pWorkVal = (%s *)pVal;" ( valStruct, valStruct ) );
            
            foreach valType, paramIndex in valInfo.$typeList {
               if isStemType( valType ) {
                  stream.writeln(
                     "lns_decre_ref( _pEnv, pWorkVal->_val%d.val.pAny );" ( paramIndex) );
               }
            }
            stream.popIndent();
            stream.writeln( "}" );
         }
         else {
            gcTxt = "NULL";
         }
         
         processAlgeNewProto( stream, moduleCtrl, algeType, valInfo );
         stream.writeln( "{" );
         stream.pushIndent( ## );

         stream.writeln(
            "%s pAny = lns_alge_new( _pEnv, %s_%s, sizeof( %s ), %s );"
            (cTypeAnyP, enumName, valInfo.$name, valStruct, gcTxt ) );
         stream.writeln( "%s *pVal = pAny->val.alge.pVal;" ( valStruct ) );

         foreach valType, paramIndex in valInfo.$typeList {
            if isStemType( valType ) {
               stream.writeln(
                  "lns_setQ( pVal->_val%d, _val%d );"
                  (paramIndex, paramIndex) );
            }
            else {
               stream.writeln( "pVal->_val%d = _val%d;" (paramIndex, paramIndex) );
            }
         }

         stream.writeln( "return LNS_STEM_ANY( pAny );" );
         
         stream.popIndent();
         stream.writeln( "}" );
      }
   }
   
   
}

pub override fn convFilter.processDeclAlge(
   node: Nodes.DeclAlgeNode, opt: Opt ) mut
{
   switch self.processMode {
      case .Prototype {
         processAlgePrototype( self.stream, self.moduleCtrl, node );
      }
      case .WideScopeVer {
         processAlgeWideScope( self.stream, self.moduleCtrl, node );
      }
      case .Form {
         processAlgeForm( self.stream, self.moduleCtrl, node );
      }
      case .InitModule {
         self.writeln( "%s( _pEnv );"
                       (self.moduleCtrl.getAlgeInitCName(node.$expType) ) );
      }
   }
//    let mut access = node.$accessMode == .Global and "" or "local ";
//    let mut algeFullName = node.$algeType.$rawTxt;
//    let typeInfo = unwrap node.$expType@@@Ast.AlgeTypeInfo;
//    let parentInfo = typeInfo.$parentInfo;
//    let mut isTopNS = true;
//    if parentInfo ~= Ast.headTypeInfo and parentInfo.$kind == .Class {
//       algeFullName = "%s.%s" (self.getFullName( parentInfo ), algeFullName );
//       access = "";
//       isTopNS = false;
//    }


//    self.writeln( "%s%s = {}" (access, algeFullName) );
//    self.writeln( "%s._name2Val = {}" (algeFullName) );
//    if isTopNS and node.$accessMode == .Pub {
//       if self.needModuleObj {
//          self.writeln( "_moduleObj.%s = %s" ( algeFullName, algeFullName ) );
//       }
//    }


//    if typeInfo.$accessMode == .Pub {
//       self.pubAlgeId2AlgeTypeInfo[ typeInfo.$typeId ] = typeInfo;
//    }

//    self.writeln( ```function %s:_getTxt( val )
//    local name = val[ 1 ]
//    if name then
//       return string.format( "%s.%%s", name )
//    end
//    return string.format( "illegal val -- %%s", val )
// end
// ``` (algeFullName, algeFullName ) );
//    self.writeln( ```
// function %s._from( val )
//    return _lune._AlgeFrom( %s, val )
// end
// ``` (algeFullName, algeFullName) );
//    forsort valInfo in node.$algeType.$valInfoMap {
//       self.write( '%s.%s = { "%s"' (algeFullName, valInfo.$name, valInfo.$name ) );
//       let mut memInfoTxt = "";
//       if #valInfo.$typeList > 0 {
//          self.write( ", {" );
//          foreach paramType, index in valInfo.$typeList {
//             if index > 1 {
//                self.write( "," );
//             }
//             let funcTxt, nilable, child = self.getMapInfo( paramType );
//             self.write( "{ func=%s, nilable=%s, child=%s }" (funcTxt, nilable, child) );
//          }
//          self.write( "}" );
//       }
//       self.writeln( "}" );
//       self.writeln( '%s._name2Val["%s"] = %s.%s'
//                     ( algeFullName, valInfo.$name, algeFullName, valInfo.$name ) );
//    }
}

pub override fn convFilter.processNewAlgeVal(
   node: Nodes.NewAlgeValNode, opt: Opt ) mut
{
   let valInfo = node.$valInfo;
   if #valInfo.$typeList == 0 {
      let valName = self.moduleCtrl.getAlgeValCName( node.$algeTypeInfo, valInfo.$name );
      self.write( "%s" (valName) );
   }
   else {
      self.write( self.moduleCtrl.getNewAlgeCName( node.$algeTypeInfo, valInfo.$name ) );
      self.write( "( _pEnv" );

      foreach arg in node.$paramList {
         self.write( "," );
         filter( arg, self, node );
      }
      self.write( ")" );
   }

   
   // let valInfo = node.$valInfo;
   // self.write( '_lune.newAlge( %s.%s'
   //             (self.getFullName( node.$algeTypeInfo ), valInfo.$name ) );
   // if #valInfo.$typeList > 0 {
   //    self.write( ", {" );
   //    foreach exp, index in node.$paramList {
   //       if index > 1 {
   //          self.write( "," );
   //       }
   //       filter( exp, self, node );
   //    }
   //    self.write( "}" );
   // }
   // self.write( ")" );
}



// fn convFilter.getDestrClass( classTypeInfo:&Ast.TypeInfo ) : &Ast.TypeInfo!
// {
   // let mut typeInfo = classTypeInfo;
   // while not typeInfo.equals( Ast.headTypeInfo ##) {
   //    let scope = unwrap typeInfo.$scope;
   //    if! scope.getTypeInfoChild( "__free" ) {
   //       return typeInfo;
   //    }
   //    typeInfo = typeInfo.$baseTypeInfo;
   // }
   // return nil;
// }

fn convFilter.outputAlter2MapFunc(
   stream:Util.SourceStream, alt2Map:&Map<&Ast.TypeInfo,&Ast.TypeInfo>)
{
   // stream.write( "{" );

   // foreach assinType, altType in alt2Map {
   //    if altType.$kind == .Alternate {
   //       if assinType.$kind == .Alternate {
   //          stream.write(
   //             "%s = self.__alt2mapFunc[ %q ],"
   //             (assinType.$rawTxt, assinType.$rawTxt ) );
   //       }
   //       else {
   //          let funcTxt, nilable, child = self.getMapInfo( assinType );
   //          stream.write(
   //             "%s = { func=%s, nilable=%s, child=%s },"
   //             (altType.$rawTxt, funcTxt, nilable, child) );
   //       }
   //    }
   // }

   // stream.write( "}" );
}

fn getMethodTypeTxt( retTypeList:&List<&Ast.TypeInfo> ) : str {
   if #retTypeList == 1 {
      let mut retType = retTypeList[ 1 ].$srcTypeInfo;
      if! let enumType = retType@@@Ast.EnumTypeInfo {
         retType = enumType.$valTypeInfo;
      }
      switch retType {
         case Ast.builtinTypeInt, Ast.builtinTypeChar {
            return "lns_method_int_t";
         }
         case Ast.builtinTypeReal {
            return "lns_method_real_t";
         }
         case Ast.builtinTypeBool {
            return "lns_method_bool_t";
         }
      }
      if getValKind( retType ) == .Any {
            return "lns_method_any_t";
      }
   }
   return "lns_method_t";
}

fn processNewConstrProto(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   node:&Nodes.DeclClassNode, out2HMode:Out2HMode, outputBuiltinFlag:bool ) mut
{
   let className = moduleCtrl.getClassCName( node.$expType );

   stream.write( getOut2HeaderPrefix( out2HMode ) );
   stream.write( "%s %s( %s _pEnv"
      (cTypeAnyP, moduleCtrl.getNewName( node.$expType ), cTypeEnvP ) );


   if not outputBuiltinFlag {
      let scope = unwrap node.$expType.$scope;
      let initFuncType = unwrap scope.getTypeInfoField(
         "__init", true, scope, scopeAccess );
      foreach argType, index in initFuncType.$argTypeInfoList {
         stream.write( ", %s arg%d" ( getCType( argType ), index ) );
      }
   }
   stream.write( ")" );
}

fn processDeclAlgeSub( stream:Util.SourceStream, node: &Nodes.DeclArgNode )
{
   stream.write( getCType( node.$expType ) );
   if node.$symbolInfo.$hasAccessFromClosure {
      // 引数がクロージャで使用されている場合、引数を別名で宣言する。
      // 関数の先頭で、クロージャ用の変数を別途宣言する。
      stream.write( ' _' );
   }
   elseif node.$symbolInfo.$mutable {
      // 引数が mutable の場合、
      // 保持する値が変更される可能性があるため、
      // 別途宣言してローカル変数と同じように管理する。
      stream.write( ' _' );
   }
   else {
      stream.write( ' ' );
   }
   stream.write( node.get_name().txt );
}

enum FuncWrap {
   /** 通常の関数定義 */
   Normal,
   /** 呼び出し用のラッパー */
   CallWrap,
   /** nil アクセス用のラッパー */
   NilWrap
}

fn processMethodDeclTxt(
   stream:Util.SourceStream, moduleCtrl:&ModuleCtrl,
   wrapKind:FuncWrap, methodTypeInfo:&Ast.TypeInfo, argList:&List<&Nodes.Node>! )
{
   if methodTypeInfo.$rawTxt ~= "__init" and wrapKind == .Normal {
      if not methodTypeInfo.$staticFlag or
         not Ast.isPubToExternal( methodTypeInfo.$accessMode ) or
         not Ast.isPubToExternal( methodTypeInfo.$parentInfo.$accessMode )
      {
         stream.write( "static " );
      }
   }

   let name;
   let objDecl;
   let retType;
   switch wrapKind {
      case .Normal {
         name = moduleCtrl.getMethodCName( methodTypeInfo );
         objDecl = ", %s pObj" (cTypeAnyP);
         retType = getCRetType( methodTypeInfo.$retTypeInfoList );
      }
      case .CallWrap {
         name = moduleCtrl.getCallMethodCName( methodTypeInfo );
         objDecl = ", %s pObj" (cTypeAnyP);
         retType = getCRetType( methodTypeInfo.$retTypeInfoList );
      }
      case .NilWrap {
         name = moduleCtrl.getNilMethodCName( methodTypeInfo );
         objDecl = ", %s obj" (cTypeStem);
         if #methodTypeInfo.$retTypeInfoList == 0 {
            retType = "void";
         }
         else {
            retType = cTypeStem;
         }
      }
      default {
         Util.err( "not support -- %s" (wrapKind.$_txt) );
      }
   }
   stream.write( "%s %s( %s _pEnv" ( retType, name, cTypeEnvP ) );
   if methodTypeInfo.$staticFlag {
      if isClosure( methodTypeInfo ) {
         stream.write( ", %s _pForm" ( cTypeAnyP ) );
      }
   }
   else {
      stream.write( objDecl );
   }

   if methodTypeInfo.$rawTxt == "___init" and
      methodTypeInfo.$staticFlag
   {
      // __init ブロックの場合
      stream.write( ", %s %s"
                    ( cTypeBlockP,
                      getBlockName( unwrap methodTypeInfo.getModule().$scope ) ) );
   }
   else {
      when! argList {
         foreach argNode, index in argList {
            stream.write( ", " );
            if! let declArgNode = argNode@@@Nodes.DeclArgNode {
               processDeclAlgeSub( stream, declArgNode );
            }
            else {
               stream.write( "%s _pDDD" (cTypeStem) );
            }
         }
      }
      else {
         foreach arg, index in methodTypeInfo.$argTypeInfoList {
            stream.write( ", %s arg%d" ( getCType( arg ), index ) );
         }
      }
   }
   stream.write( ")" );
}


fn processDeclMethodTable( stream:Util.SourceStream, classTypeInfo:&Ast.TypeInfo )
{
   fn outputField( name:str, retTypeList: &List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "%s * %s;" (methodType, name ) );
   }

   // fn outputVal( scope:&Ast.Scope ) {
   //    if! let inherit = scope.$inherit {
   //       outputVal( inherit );
   //    }
   //    forsort symbolInfo in scope.$symbol2SymbolInfoMap {
   //       switch symbolInfo.$kind {
   //          case .Mtd {
   //             if symbolInfo.$name ~= "__init" {
   //                if not scope.getSymbolInfoField(
   //                   symbolInfo.$name, false, scope, .Normal )
   //                {
   //                   outputField( symbolInfo.$name,
   //                                symbolInfo.$typeInfo.$retTypeInfoList );
   //                }
   //             }
   //          }
   //       }
   //    }
   // }

   let nameSet = Ast.getAllMethodName( classTypeInfo, .Object );
   foreach name in nameSet.$list {
      if! let symbolInfo = classTypeInfo.$scope$.getSymbolInfoField$(
         name, true, unwrap classTypeInfo.$scope, .Normal )
      {
         outputField( name, symbolInfo.$typeInfo.$retTypeInfoList );
      }
   }
   // outputVal( unwrap classTypeInfo.$scope );
}


fn processDeclMemberTable(
   normal:bool, stream:Util.SourceStream, classTypeInfo:&Ast.TypeInfo )
{
   fn outputVal( scope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mbr {
               if not symbolInfo.$staticFlag {
                  stream.writeln( "%s %s;" ( getCType( symbolInfo.$typeInfo ),
                                             symbolInfo.$name ) );
               }
            }
         }
      }
   }
   stream.writeln( "// member" );
   if normal {
      outputVal( unwrap classTypeInfo.$scope );
   }
   else {
      stream.writeln( "void * pExt;" );
   }
}

fn hasGC( classTypeInfo:&Ast.TypeInfo ): bool {
   if! let scope = classTypeInfo.$scope {
      if scope.getSymbolInfoField( "_gc", true, scope, scopeAccess ) {
         return true;
      }
   }
   let mut workInfo = classTypeInfo;
   while workInfo.hasBase() {
      workInfo = workInfo.$baseTypeInfo;
      if! let scope = classTypeInfo.$scope {
         if scope.getSymbolInfoField( "_gc", true, scope, scopeAccess ) {
            return true;
         }
      }
   }
   return false;
}
   

fn processPrototypeMethod(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   declArgNodeList:&List<&Nodes.Node>!, funcTypeInfo:&Ast.TypeInfo )
{
   fn processHeader( out2HMode:Out2HMode ) {
      if out2HMode == .HeaderPub {
         stream.write( "extern " );
      }
      if not funcTypeInfo.$staticFlag {
         // メソッドコール用ラッパー
         processMethodDeclTxt( stream, moduleCtrl, .CallWrap,
                               funcTypeInfo, declArgNodeList );
         stream.writeln( ";" );
         processMethodDeclTxt( stream, moduleCtrl, .NilWrap,
                               funcTypeInfo, declArgNodeList );
         stream.writeln( ";" );
      }
      else {
         // static メソッドの関数プロトタイプ
         processMethodDeclTxt( stream, moduleCtrl, .Normal,
                               funcTypeInfo, declArgNodeList );
         stream.writeln( ";" );
      }
   }

   if funcTypeInfo.$parentInfo.$kind == .Class and
      funcTypeInfo.$rawTxt == "__init"
   {
      processMethodDeclTxt( stream, moduleCtrl, .Normal,
                            funcTypeInfo, declArgNodeList );
      stream.writeln( ";" );
   }
   else {
      _out2Header(
         stream,
         Ast.isPubToExternal( funcTypeInfo.$parentInfo.$accessMode ) and
         Ast.isPubToExternal( funcTypeInfo.$accessMode ),
         `{
            switch out2HMode {
               case .SourcePri {
                  if funcTypeInfo.$parentInfo.$kind == .Class {
                     processHeader( out2HMode );
                     processMethodDeclTxt( stream, moduleCtrl, .Normal,
                                           funcTypeInfo, declArgNodeList );
                     stream.writeln( ";" );
                  }
               }
               case .SourcePub {
                  if funcTypeInfo.$parentInfo.$kind == .Class {
                     if not funcTypeInfo.$staticFlag {
                        processMethodDeclTxt( stream, moduleCtrl, .Normal,
                                              funcTypeInfo, declArgNodeList );
                        stream.writeln( ";" );
                     }
                  }
               }
               case .HeaderPub {
                  processHeader( out2HMode );
               }
            }
         });
   }
}


/** stem 型に変換する対象を出力する処理 */
form process2stemCallback();

/**
node が示す値を stem 型に変換する処理を出力する

@param node Node
@param parent このノードの親
*/
fn process2stem(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl, scopeMgr:ScopeMgr,
   valKind:ValKind, typeInfo:&Ast.TypeInfo,
   parent: &Nodes.Node, callback:process2stemCallback )
{
   switch valKind {
      case .Stem {
         callback();
      }
      default {
         let mut expType = typeInfo.$srcTypeInfo;
         if! let enumType = expType@@@Ast.EnumTypeInfo {
            expType = enumType.$valTypeInfo;
         }
         
         switch expType {
            case Ast.builtinTypeInt, Ast.builtinTypeChar {
               stream.write( "LNS_STEM_INT( " );
               callback();
               stream.write( ")" );
            }
            case Ast.builtinTypeReal {
               stream.write( "LNS_STEM_REAL( " );
               callback();
               stream.write( ")" );
            }
            case Ast.builtinTypeBool {
               stream.write( "LNS_STEM_BOOL( " );
               callback();
               stream.write( ")" );
            }
            default {
               switch expType.$kind {
                  case .DDD {
                     stream.write( "_pDDD" );
                  }
                  case .Func {    
                     if! let scope = expType.$scope {
                        stream.write( "LNS_STEM_ANY(" );
                        stream.write( getFunc2any(
                           moduleCtrl, scopeMgr, expType ) );
                        stream.write( ")" );
                     }
                     else {   
                        Util.err( "illegal func" );
                     }
                  }
                  default {
                     if valKind == .Var and getValKind( expType ) == .Stem {
                        callback();
                     }
                     else {
                        stream.write( "LNS_STEM_ANY( " );
                        callback();
                        stream.write( ")" );
                     }
                  }
               }
            }
         }
      }
   }
}


/**
メソッド呼び出しのラッパー (call/nilaccess) を作成。

@param callFlag true の場合 call。 false の場合 nilaccess。
*/
fn processDeclCallMethodWrapper(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl, scopeMgr:ScopeMgr,
   parent:&Nodes.Node, funcTypeInfo:&Ast.TypeInfo, callFlag:bool )
{
   if funcTypeInfo.$rawTxt ~= "__init" and not funcTypeInfo.$staticFlag {

      processMethodDeclTxt(
         stream, moduleCtrl,
         callFlag and FuncWrap.CallWrap or FuncWrap.NilWrap, funcTypeInfo, nil );
      stream.writeln( "{" );

      if not callFlag {
         let retVal;
         switch #funcTypeInfo.$retTypeInfoList {
            case 0 {
               retVal = "";
            }
            case 1 {
               retVal = cValNil;
            }
            default {
               retVal = cValDDD0;
            }
         }
         stream.writeln(
            "if ( obj.type == lns_stem_type_nil ) { return %s; }" (retVal) );
         stream.writeln( "%s pObj = obj.val.pAny;" (cTypeAnyP ) );
      }

      
      if #funcTypeInfo.$retTypeInfoList ~= 0 {
         stream.write( "return " );
      }

      let retList = funcTypeInfo.$retTypeInfoList;
      fn process() {
         let classTypeInfo = funcTypeInfo.$parentInfo;
         let className = moduleCtrl.getClassCName( classTypeInfo );
         stream.write( "lns_mtd_%s( pObj )->%s( _pEnv, "
                       ( className, funcTypeInfo.$rawTxt ) );
         if classTypeInfo.$kind == .IF {
            stream.write( "lns_getImpObj( pObj ) " );
         }
         else {
            stream.write( "pObj " );
         }
         foreach argType, index in funcTypeInfo.$argTypeInfoList {
            stream.write( ", arg%d" ( index ) );
         }
         stream.write( ")" );
      }

      if not callFlag and #retList > 0 {
         process2stem(
            stream, moduleCtrl, scopeMgr,
            getRetKind( retList ), retList[ 1 ], parent, process );
      }
      else {
         process();
      }
      stream.writeln( ";" );
      
      
      stream.writeln( "}" );
   }
   
}

fn getAccessMember(className:str,obj:str,member:str):str {
   return "lns_obj_%s( %s )->%s" (className,obj,member);
}

fn getAccessMethod(className:str,obj:str,method:str):str {
   return "lns_mtd_%s( %s )->%s" (className, obj, method );
}


/**
advertise 宣言の処理。
*/
fn processAdvertise(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl, scopeMgr:ScopeMgr,
   processMode:ProcessMode, node:&Nodes.DeclClassNode )
{
   // このクラスで宣言しているメソッド名の Set を作成
   let mut declMethodNameSet:Set<str> = (@);
   foreach field in node.$fieldList {
      if! let declMethodNode = field@@@Nodes.DeclMethodNode {
         if! let name = declMethodNode.$declInfo.$name {
            declMethodNameSet.add( name.txt );
         }
      }
   }
   // このクラスのアクセッサ名を登録
   foreach member in node.$memberList {
      if member.$getterMode ~= .None {
         declMethodNameSet.add( "get_" .. member.$name.txt );
      }
      if member.$setterMode ~= .None {
         declMethodNameSet.add( "set_" .. member.$name.txt );
      }
   }
   // if node.$expType.hasBase() {
   //    // スーパークラスのメソッド名を登録
   //    let! superScope = node.$expType.$baseTypeInfo.$scope {
   //       return;
   //    };        
   //    foreach methodSym, methodName in superScope.$symbol2SymbolInfoMap {
   //       if methodSym.$kind == .Mtd {
   //          declMethodNameSet.add( methodName );
   //       }
   //    }
   // }

   // advertise 宣言の処理
   foreach advInfo in node.$advertiseList {
      let member = advInfo.$member;
      stream.writeln( "// for advertise %s.%s --->"
                      (node.$name.txt, member.$name.txt) );
      
      // advertise 宣言しているメンバの全 非 static メソッドをリストアップ
      foreach name in Ast.getAllMethodName( member.$expType, .Object ).$list {
         if not declMethodNameSet.has( name ) {
            // このクラスで宣言していないメソッドを、
            // advertise 宣言しているメンバのメソッドコールで宣言
            
            let methodSym = 
               unwrap node.$scope.getSymbolInfoField( name, true, node.$scope, .Normal );

            let methodType = methodSym.$typeInfo;
            if methodType.$accessMode ~= .Pri {
               switch processMode {
                  case .Prototype {
                     processPrototypeMethod( stream, moduleCtrl, nil, methodType );
                  }
                  case .DefClass {
                     processDeclCallMethodWrapper(
                        stream, moduleCtrl, scopeMgr, node, methodType, true );
                     processDeclCallMethodWrapper(
                        stream, moduleCtrl, scopeMgr, node, methodType, false );

                     processMethodDeclTxt( stream, moduleCtrl, .Normal, methodType, nil );
                     stream.writeln( "{" );
                     let className = moduleCtrl.getClassCName( node.$expType );
                     let memberClassName = moduleCtrl.getClassCName( member.$expType );
                     stream.pushIndent( ## );
                     stream.writeln(
                        "%s pVal = %s;"
                        (cTypeAnyP,
                          getAccessMember(className, "pObj", member.$name.txt )) );
                     if #methodType.$retTypeInfoList ~= 0 {
                        stream.write( "return " );
                     }
                     stream.write(
                        "%s( _pEnv, pVal"
                        (getAccessMethod(memberClassName, "pVal", name) ) );
                     foreach argType, index in methodType.$argTypeInfoList {
                        stream.write( ", arg%d" (index ) );
                     }
                     stream.writeln( ");" );
                     
                     stream.popIndent();
                     stream.writeln( "}" );
                  }
               }
            }
         }
      }
      stream.writeln( "// <-- for advertise %s.%s"
                      (node.$name.txt, member.$name.txt) );
   }
}



fn processDeclClassPrototype(
   normal:bool, stream:Util.SourceStream,
   moduleCtrl:ModuleCtrl, node:&Nodes.DeclClassNode )
{
   let className = moduleCtrl.getClassCName( node.$expType );
   
   // _gc, _del のプロトタイプ
   stream.writeln(
      "static void mtd_%s__del( lns_env_t * _pEnv, %s pObj );"
      (className, cTypeAnyP) );
   if not normal {
      stream.writeln( "static void mtd_%s__delExt( lns_env_t * _pEnv, %s pObj );"
                      (className, cTypeAnyP) );
   }
   
   if hasGC( node.$expType ) {
      stream.writeln( "static void mtd_%s__gc( lns_env_t * _pEnv, %s pObj );"
                      (className, cTypeAnyP ) );
   }
   
   // アクセッサのプロトタイプ
   foreach member in node.$memberList {
      let memberName = member.$name.txt;
      if member.$getterMode ~= .None {
         let getterType = unwrap node.$scope.getTypeInfoField(
            "get_%s" (memberName), true, node.$scope, scopeAccess );
         processMethodDeclTxt( stream, moduleCtrl, .Normal, getterType## );
         stream.writeln( ";" );
      }
      if member.$setterMode ~= .None {
         let setterType = unwrap node.$scope.getTypeInfoField(
            "set_%s" (memberName), true, node.$scope, scopeAccess );
         processMethodDeclTxt( stream, moduleCtrl, .Normal, setterType## );
         stream.writeln( ";" );
      }
   }
}

fn processDefaultCtor(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   scopeMgr:ScopeMgr, node:&Nodes.DeclClassNode )
{
   let className = moduleCtrl.getClassCName( node.$expType );

   if not node.hasUserInit() {
      // デフォルトコンストラクタの処理

      stream.write(
         "static void %s( lns_env_t * _pEnv, %s pAny"
         (moduleCtrl.getCtorName( node.$expType ), cTypeAnyP ) );
      
      let ctorType = unwrap node.$scope.getTypeInfoField(
         "__init", true, node.$scope, scopeAccess );
      
      foreach argType, index in ctorType.$argTypeInfoList {
         stream.write(
            ", %s _arg%d"
            (getCType( argType ), index ) );
      }
      stream.writeln( ") {" );
      stream.pushIndent(##);

      let mut memberNum = 0;
      foreach member in node.$memberList {
         if not member.$staticFlag {
            memberNum = memberNum + 1;
         }
      }

      let superArgNum;
      if! let baseScope = node.$scope.$inherit {
         // 親クラスのコンストラクタ呼び出し
         let superInitType =
            unwrap baseScope.getTypeInfoField( "__init", true, baseScope, scopeAccess );
         stream.write( "%s( _pEnv, pAny"
                       (moduleCtrl.getCtorName( node.$expType.$baseTypeInfo ) ) );

         if #ctorType.$argTypeInfoList >= #superInitType.$argTypeInfoList + memberNum
         {
            superArgNum = #superInitType.$argTypeInfoList;         
            foreach argType, index in superInitType.$argTypeInfoList {
               stream.write( ", _arg%d" (index) );
            }
         }
         else {
            // デフォルトコンストラクタで、
            // 「親クラスのコンストラクタの引数 + このクラスのメンバ数」よりも、
            // このコンストラクタの引数が少ない場合は、
            // _lune_control default__init_old が宣言されている。
            superArgNum = 0;
            foreach argType, index in superInitType.$argTypeInfoList {
               stream.write( ", %s" (cValNil) );
            }
         }
         stream.writeln( ");" );
      }
      else {
         superArgNum = 0;
      }

      stream.writeln( "%s * pObj = lns_obj_%s( pAny );" (className, className) );
      let mut argIndex = superArgNum;
      foreach member, index in node.$memberList {
         if not member.$staticFlag {
            argIndex = argIndex + 1;
            let valKind = scopeMgr.getSymbolValKind( member.$symbolInfo );
            switch valKind {
               case .Stem {
                  stream.writeln(
                     "lns_setQ( pObj->%s, _arg%d );" (member.$name.txt, argIndex ));
               }
               case .Any {
                  stream.writeln(
                     "lns_setQ_any( &pObj->%s, _arg%d );" (member.$name.txt, argIndex ));
               }
               case .Prim {
                  stream.writeln( "pObj->%s = _arg%d;" (member.$name.txt, argIndex));
               }
               default {
                  Util.err(
                     "no support -- %s:%s:%d"
                     (member.$name.txt, valKind.$_txt, __line__) );
               }
            }
         }
      }
      stream.popIndent();
      stream.writeln( "}" );
   }
}

fn processIFObjDecl(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl, classType:&Ast.TypeInfo )
{
   if classType.hasBase() {
      processIFObjDecl( stream, moduleCtrl, classType.$baseTypeInfo );
   }

   foreach ifType in classType.$interfaceList {
      stream.writeln( "%s %s;" (cTypeAny, moduleCtrl.getClassCName( ifType ) ) );
   }
}

fn processIFObjInit(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   classType:&Ast.TypeInfo, impClassType:&Ast.TypeInfo )
{
   if classType.hasBase() {
      processIFObjInit( stream, moduleCtrl, classType.$baseTypeInfo, impClassType );
   }

   let className = moduleCtrl.getClassCName( impClassType );
   foreach ifType in classType.$interfaceList {
      let ifName = moduleCtrl.getClassCName( ifType );
      stream.writeln(
         "lns_init_if( &pObj->imp.%s, _pEnv, pAny, &lns_if_%s_imp_%s, %s );"
         (ifName, className, ifName, ifName) );
   }
}

fn convFilter.processNewInsance( classType:&Ast.TypeInfo, callInit:bool ) mut {
   let className = self.moduleCtrl.getClassCName( classType );
   
   self.writeln( "lns_class_new_( _pEnv, %s, pAny, pObj );" (className) );

   if callInit and not self.outputBuiltinFlag {
      self.write( "%s( _pEnv, pAny" ( self.moduleCtrl.getCtorName( classType ) ) );

      let scope = unwrap classType.$scope;
      if not self.outputBuiltinFlag {
         let initFuncType =
            unwrap scope.getTypeInfoField( "__init", true, scope, scopeAccess );
         foreach argType, index in initFuncType.$argTypeInfoList {
            self.write( ", arg%d" ( index ) );
         }
      }
      self.writeln( ");" );
   }

   if ( self.outputBuiltinFlag or not self.canConv ) {
      self.writeln( "pObj->pExt = NULL;" );
   }
   self.writeln( "pObj->pImp = &pObj->imp;" );
   self.writeln( "pObj->imp.sentinel.type = lns_value_type_none;" );
   
   processIFObjInit( self.stream, self.moduleCtrl, classType, classType );
}


fn convFilter.processMapping(
   node:&Nodes.DeclClassNode, classType:&Ast.TypeInfo, out2HMode:Out2HMode ) mut
{
   if not classType.isInheritFrom( Ast.builtinTypeMapping, nil ) {
      return;
   }

   let classScope = unwrap classType.$scope;
   let toMapMtdSym = unwrap classScope.getSymbolInfoChild( "_toMap" );
   let fromMapMtdSym = unwrap classScope.getSymbolInfoChild( "_fromMap" );
   let className = self.moduleCtrl.getClassCName( classType );

   fn processDeclToMap(callFlag:bool) {
      self.write( "%s%s " ( getOut2HeaderPrefix( out2HMode ), cTypeAnyP ));
      if callFlag {
         self.write( self.moduleCtrl.getCallMethodCName( toMapMtdSym.$typeInfo ) );
      }
      else {
         self.write(self.moduleCtrl.getMethodCName( toMapMtdSym.$typeInfo ) );
      }
      self.write( "( %s _pEnv, %s pObj)"
                    ( cTypeEnvP,
                      getCRetType( toMapMtdSym.$typeInfo.$retTypeInfoList ) ) );
   }

   fn processDeclFromMap( sub:bool ) {
      self.write( "%s%s " ( getOut2HeaderPrefix( out2HMode ), cTypeStem ));
      self.write( self.moduleCtrl.getMethodCName( fromMapMtdSym.$typeInfo ) );
      if sub {
         self.write( "Sub" );
      }
      self.write( "( %s _pEnv" ( cTypeEnvP ) );
      if sub {
         self.write( ", const lns_fromVal_info_t * pInfoArray" );
      }
      self.write( ", %s mapStem)"
                  ( getCRetType( fromMapMtdSym.$typeInfo.$retTypeInfoList ) ) );
   }

   fn processToMapBody() {
      // _toMap の定義
      processDeclToMap( false );
      self.writeln( "{" );
      self.pushIndent( ## );

     
      self.writeln( "%s pMap = lns_class_Map_new( _pEnv );" (cTypeAnyP) );
      foreach varName in Ast.getAllNameForKind( classType, .Object, .Mbr ).$list {

         self.write( "lns_mtd_Map_add( _pEnv, pMap, " );
         self.write( 'LNS_STEM_ANY( lns_litStr2any( _pEnv, "%s" ) ), ' (varName) );

         let memberSym = unwrap classScope.getSymbolInfoField(
            varName, true, classScope, .Full );
         let nonNilMemberType = memberSym.$typeInfo.$nonnilableType.$srcTypeInfo;

         let valKind = getValKind( memberSym.$typeInfo );
         let mut valTxt:str! = getAccessMember( className, "pObj", varName );
         switch valKind {
            case .Prim {
            }
            case .Stem {
               self.writeln( "lns_toMapFromStem( _pEnv, %s ) );" ( valTxt ) );
               valTxt = nil;
            }
            case .Any {
               if nonNilMemberType == Ast.builtinTypeString {
               }
               else {
                  self.writeln( "lns_toMapFromStem( _pEnv, LNS_STEM_ANY( %s ) ) );"
                                ( valTxt ) );
                  valTxt = nil;
               }
            }
            default {
               Util.err( "not support -- %s" (valKind.$_txt ) );
            }
         }
         when! valTxt {
            process2stem(
               self.stream, self.moduleCtrl, self.scopeMgr,
               getValKind( memberSym.$typeInfo ), memberSym.$typeInfo, node,
               fn () {     
                  self.write( valTxt );
               } );
            self.writeln( ");" );
         }
      }

      
      self.writeln( "return pMap;" );
      
      self.popIndent();
      self.writeln( "}" );


      processDeclToMap( true );
      self.writeln( "{" );
      self.pushIndent( ## );

      self.write( "return " );
      self.write( getAccessMethod( className, "pObj", "_toMap" ) );
      self.writeln( "( _pEnv, pObj );" );
      
      self.popIndent();
      self.writeln( "}" );
   }

   fn processFromMapBody() {
      // _fromMap の定義
      processDeclFromMap( false );
      self.writeln( "{" );
      self.pushIndent( ## );

      self.writeln( "return %sSub( _pEnv, NULL, mapStem );"
                    (self.moduleCtrl.getMethodCName( fromMapMtdSym.$typeInfo )));
      
      self.popIndent();
      self.writeln( "}" );

      
      processDeclFromMap( true );
      self.writeln( "{" );
      self.pushIndent( ## );

      self.writeln( "if ( mapStem.type == lns_stem_type_nil ) { return %s; }" (cValNil) );
      self.writeln( "lns_any_t * pMap = mapStem%s;" (accessAny ) );
      self.writeln( "lns_any_t * pErr = NULL;" );

      foreach varName in Ast.getAllNameForKind( classType, .Object, .Mbr ).$list {
         let memberSym = unwrap classScope.getSymbolInfoField(
            varName, true, classScope, .Full );
         let nonNilMemberType = memberSym.$typeInfo.$nonnilableType.$srcTypeInfo;

         let fromMapSym:str!;
         switch nonNilMemberType.$kind {
            case .List {
               fromMapSym = "lns_fromMapToList";
            }
            case .Array {
               fromMapSym = "lns_fromMapToArray";
            }
            case .Set {
               fromMapSym = "lns_fromMapToSet";
            }
            case .Map {
               fromMapSym = "lns_fromMapToMap";
            }
            default {
               if! let memberClassScope = nonNilMemberType.$scope {
                  if! let symbol = memberClassScope.getSymbolInfoField(
                     "_fromMap", true, memberClassScope, .Normal )
                  {
                     fromMapSym = self.moduleCtrl.getMethodCName( symbol.$typeInfo );
                  }
                  else {
                     fromMapSym = nil;
                  }
               }
               else {
                  fromMapSym = nil;
               }
            }
         }
         
              

         fn process(nilable:bool) {
            let kind;
            switch nonNilMemberType {
               case Ast.builtinTypeInt, Ast.builtinTypeChar {
                  kind = "lns_stem_type_int";
               }
               case Ast.builtinTypeReal {
                  kind = "lns_stem_type_real";
               }
               case Ast.builtinTypeBool {
                  kind = "lns_stem_type_bool";
               }
               default{
                  Util.err( "not support -- %s" (memberSym.$typeInfo.getTxt(##)) );
               }
            }
            self.writeln(
               "lns_check_err_from_map( pErr, _pEnv, pMap, %s, %s, %s, %s );"
               ( nilable and "true" or "false",
                 memberSym.$name, kind, 
                 getAccessPrimValFromStem( false, memberSym.$typeInfo, 0 )) );
         }

         self.writeln( "%s %s;" (getCType( memberSym.$typeInfo ),
                                  memberSym.$name ) );
         let nilable = memberSym.$typeInfo.$nilable;
         if nilable {
            self.writeln( "%s = lns_global.nilStem;" (memberSym.$name) );
         }

         when! fromMapSym {
            self.write( "lns_check_err_from_map_class" );
            let infoValName;
            if #memberSym.$typeInfo.$itemTypeInfoList > 0 {
               infoValName = "&info_0_1_%s_%s" (className, memberSym.$name);
            }
            else {
               infoValName = "NULL";
            }

            self.writeln(
               "( pErr, _pEnv, pMap, %s, %s, %sSub, %s, %s );"
               ( nilable, memberSym.$name, fromMapSym, infoValName,          
                 getAccessPrimValFromStem( false, memberSym.$typeInfo, 0 ) ) );
         }
         else {
            if nonNilMemberType.equals( Ast.builtinTypeString## )
            {
               self.writeln( 
                  "lns_check_err_from_map_str( pErr, _pEnv, pMap, %s, %s, %s );"
                  ( nilable, memberSym.$name,
                    getAccessPrimValFromStem( false, memberSym.$typeInfo, 0 ) ) );
            }
            elseif nonNilMemberType.$kind == .Alternate {
               self.writeln( 
                  "lns_check_err_from_map_stem( pErr, _pEnv, pMap, %s, %s );"
                  ( nilable, memberSym.$name) );
            }
            else {
               process( nilable );
            }
         }
      }

      self.writeln( "if ( pErr != NULL ) {" );
      self.pushIndent( ## );

      self.write( "return lns_createMRet( _pEnv, false, 2, %s, " (cValNil) );
      self.writeln( "LNS_STEM_ANY( pErr ) );" );
      
      self.popIndent();
      self.writeln( "}" );

      self.processNewInsance( classType, false );

      foreach varName in Ast.getAllNameForKind( classType, .Object, .Mbr ).$list {
         let memberSym = unwrap classScope.getSymbolInfoField(
            varName, true, classScope, .Full );
         
         switch getValKind( memberSym.$typeInfo ) {
            case .Stem {
               self.writeln( "lns_setQ( pObj->%s, %s );" ( varName, varName ) );
            }
            case .Any {
               self.writeln( "lns_setQ_any( &pObj->%s, %s );" ( varName, varName ) );
            }
            case .Prim {
               self.writeln( "pObj->%s = %s;" ( varName, varName ) );
            }
         }
      }
      

      self.writeln( "return lns_createMRet( _pEnv, false, 1, LNS_STEM_ANY( pAny ) );" );
      
      self.popIndent();
      self.writeln( "}" );
   }


   fn processFromMapInfo( memberSym:&Ast.SymbolInfo ) {
      if #memberSym.$typeInfo.$nonnilableType.$itemTypeInfoList == 0 {
         return;
      }

      fn processGenType(genType:&Ast.TypeInfo,name:str, depth:int, index:int )
      {
         self.write( "const lns_fromVal_info_t info_%d_%d_%s = { " (depth, index, name) );
         self.write( "%s, " (genType.$nilable) );
         switch genType.$nonnilableType.$srcTypeInfo {
            case Ast.builtinTypeStem {
               self.write( "lns_fromMapToStemSub" );
            }
            case Ast.builtinTypeInt, Ast.builtinTypeChar {
               self.write( "lns_fromMapToIntSub" );
            }
            case Ast.builtinTypeReal {
               self.write( "lns_fromMapToRealSub" );
            }
            case Ast.builtinTypeBool {
               self.write( "lns_fromMapToBoolSub" );
            }
            case Ast.builtinTypeString {
               self.write( "lns_fromMapToStrSub" );
            }
            default {
               switch genType.$nonnilableType.$kind {
                  case .List, .Array {
                     self.write( "lns_fromMapToListSub" );
                  }
                  case .Set {
                     self.write( "lns_fromMapToSetSub" );
                  }
                  case .Map {
                     self.write( "lns_fromMapToMapSub" );
                  }
                  default {
                     if! let memberClassScope = genType.$scope {
                        if! let symbol = memberClassScope.getSymbolInfoField(
                           "_fromMap", true, memberClassScope, .Normal )
                        {
                           self.write(
                              "%sSub"
                              ( self.moduleCtrl.getMethodCName( symbol.$typeInfo ) ) );
                        }
                     }
                  }
               }
            }
         }
         if #genType.$itemTypeInfoList > 0 {
            self.write( ", { " );
            foreach subGenType, subIndex in genType.$itemTypeInfoList {
               if subIndex > 1 {
                  self.write( ", " );
               }
               self.write( "&info_%d_%d_%s" (depth + 1, subIndex, name) );
            }
            self.write( "}" );
         }
         self.writeln( "};" );
      }

      fn process( typeInfo:&Ast.TypeInfo,  name:str, depth:int, index:int ) {
         foreach genType, genIndex in typeInfo.$itemTypeInfoList {
            if #genType.$itemTypeInfoList > 0 {
               foreach subGenType in genType.$itemTypeInfoList {
                  process( subGenType, name, depth + 2, genIndex );
               }
            }
            processGenType( genType, name, depth + 1, genIndex );
         }
         processGenType( typeInfo, name, depth, index );
      }
      
      process( memberSym.$typeInfo,
               "%s_%s" (className, memberSym.$name), 0, 1 );


   }
   
   switch self.processMode {
      case .Prototype {
         processDeclToMap( true );
         self.writeln( ";" );
         processDeclToMap( false );
         self.writeln( ";" );

         foreach varName in Ast.getAllNameForKind( classType, .Object, .Mbr ).$list {
            let memberSym = unwrap classScope.getSymbolInfoField(
               varName, true, classScope, .Full );
            processFromMapInfo( memberSym );
         }
         
         processDeclFromMap( false );
         self.writeln( ";" );
         processDeclFromMap( true );
         self.writeln( ";" );
      }
      case .DefClass {
         processToMapBody();
         processFromMapBody();
      }
   }
}


fn convFilter.processDeclClassNodePrototype( node:&Nodes.DeclClassNode ) mut
{
   let className = self.moduleCtrl.getClassCName( node.$expType );

   let kind = node.$expType.$kind;

   fn process( out2HMode:Out2HMode ) {
      // メソッド構造体の宣言
      self.writeln( "typedef struct lns_mtd_%s_t {" (className) );
      self.pushIndent(##);

      if kind == .Class {
         self.writeln( "lns_del_t * _del;" );
         self.writeln( "lns_gc_t * _gc;" );
      }

      processDeclMethodTable( self.stream, node.$expType );

      self.popIndent();
      self.writeln( "} lns_mtd_%s_t;" (className) );

      if kind == .Class {
         self.writeln( "typedef struct u_if_imp_%s_t {" (className) );
         self.pushIndent(##);

         processIFObjDecl( self.stream, self.moduleCtrl, node.$expType );

         self.writeln( "%s sentinel;" (cTypeAny) );
         self.popIndent();
         self.writeln( "} u_if_imp_%s_t;" (className) );
      }
      

      // クラス構造体の宣言
      self.writeln( "typedef struct %s {" (className) );
      self.pushIndent( ## );
      
      self.writeln( "lns_type_meta_t * pMeta;" );
      switch kind {
         case .Class {
            self.writeln( "u_if_imp_%s_t * pImp;" (className) );
            self.writeln( "lns_mtd_%s_t * pMtd;" (className) );
            processDeclMemberTable(
               not self.outputBuiltinFlag and self.canConv, self.stream, node.$expType );
            self.writeln( "// interface implements" );
            self.writeln( "u_if_imp_%s_t imp;" (className) );
         }
         case .IF {
            self.writeln( "%s pObj;" (cTypeAnyP) );
            self.writeln( "lns_mtd_%s_t * pMtd;" (className) );
         }      
      }

      self.popIndent();
      self.writeln( "} %s;" (className) );

      switch kind {
         case .Class {
            self.writeln( ```#define lns_mtd_%s( OBJ )                     \
                (((%s*)OBJ->val.classVal)->pMtd )``` (className,className) );
            self.writeln( "#define lns_obj_%s( OBJ ) ((%s*)OBJ->val.classVal)"
                          (className,className) );
            self.writeln( "#define lns_if_%s( OBJ ) ((%s*)OBJ->val.classVal)->pImp"
                          (className,className) );

            if not node.$expType.$abstractFlag {
               processNewConstrProto(
                  self.stream, self.moduleCtrl, node, out2HMode, self.outputBuiltinFlag );
               self.stream.writeln( ";" );
            }


            self.processMapping( node, node.$expType, out2HMode );
         }
         case .IF {
            self.writeln( ```#define lns_mtd_%s( OBJ )                     \
             ((%s*)&OBJ->val.ifVal)->pMtd``` (className,className) );
            if out2HMode == .HeaderPub {
               self.writeln( 'extern lns_type_meta_t %s;'
                (self.moduleCtrl.getClassMetaName(node.$expType)) );
            }
         }
      }
   }
   
   _out2Header(
      self.stream,
      Ast.isPubToExternal( node.$expType.$accessMode ),
      `{
         switch out2HMode {
            case .HeaderPub, .SourcePri {
               process( out2HMode );
            }
         }
      });

   if kind == .Class {
      processDeclClassPrototype(
         not self.outputBuiltinFlag and self.canConv,
         self.stream, self.moduleCtrl, node );
      processAdvertise(
         self.stream, self.moduleCtrl, self.scopeMgr, self.processMode, node );

      if not self.outputBuiltinFlag {
         processDefaultCtor( self.stream, self.moduleCtrl, self.scopeMgr, node );
      }
   }
}

/**
symbol が block で管理する any 型のシンボルか調べる
*/
fn convFilter.isManagedAnySymbol( symbol:&Ast.LowSymbol ) mut :bool
{
   let scope = symbol.$scope;

   if scope.getNamespaceTypeInfo().getModule() ~= self.moduleTypeInfo {
      return false;
   }
   
   let valKind = self.scopeMgr.getSymbolValKind( symbol );

   let mut varName = self.moduleCtrl.getSymbolName( symbol );
   if valKind == .Any and 
       ( symbol.$kind == .Var or       
         symbol.$kind == .Arg and symbol.$mutable or
         isClassMember( symbol ) )
   {
      if varName == "self" {
         return false;
      }
      return true;
   }
   return false;
}


fn convFilter.processDeclClassDef( node:&Nodes.DeclClassNode ) mut
{
   let className = self.moduleCtrl.getClassCName( node.$expType );

   // メンバの開放処理
   self.writeln( "static void mtd_%s__del( lns_env_t * _pEnv, %s pObj ) {"
      (className, cTypeAnyP) );
   self.pushIndent(##);

   if self.outputBuiltinFlag or not self.canConv {
      self.writeln( "mtd_%s__delExt( _pEnv, pObj );" (className ) );
   }
   
   if node.$expType.hasBase() {
      self.writeln( "mtd_%s__del( _pEnv, pObj );"
                    (self.moduleCtrl.getClassCName( node.$expType.$baseTypeInfo) ) );
   }
   foreach member in node.$memberList {
      if not member.$staticFlag {
         let valKind = self.scopeMgr.getSymbolValKind( member.$symbolInfo );
         switch valKind {
            case .Stem {
               let typeInfo = member.$symbolInfo.$typeInfo;
               if typeInfo.$nilable and getValKind( typeInfo.$nonnilableType ) == .Prim {
               }
               else {
                  self.writeln(
                     "lns_decre_ref_stem( _pEnv, %s );"
                     (getAccessMember(className, "pObj", member.$name.txt ) ) );
               }
            }
            case .Any {
               self.writeln( "lns_decre_ref( _pEnv, %s );"
                             (getAccessMember(className, "pObj", member.$name.txt ) ) );
            }
         }
      }
   }
   self.popIndent();
   self.writeln( "}" );
   

   if not node.$expType.$abstractFlag {
      // デフォルトコンストラクタの定義
      processNewConstrProto( self.stream, self.moduleCtrl, node, .SourcePub,
                             self.outputBuiltinFlag );
      self.writeln( "{ // %d" (node.$pos.lineNo) );
      self.pushIndent(##);

      self.processNewInsance( node.$expType, true );

      self.writeln( "return pAny;" );
      self.popIndent();
      self.writeln( "}" );
   }


   // アクセッサの定義
   foreach member in node.$memberList {
      let memberName = member.$name.txt;
      if member.$getterMode ~= .None {
         let getterType = unwrap node.$scope.getTypeInfoField(
            "get_%s" (memberName), true, node.$scope, scopeAccess );
         if getterType.$autoFlag {
            if getterType.$staticFlag {
               processMethodDeclTxt(
                  self.stream, self.moduleCtrl, .CallWrap, getterType## );
               self.writeln( "{" );
               self.pushIndent(##);
               if self.isManagedAnySymbol( member.$symbolInfo ) {
                  self.writeln(
                     "return *%s;"
                     (self.moduleCtrl.getClassMemberName( member.$symbolInfo )) );
               }
               else {
                  self.writeln(
                     "return %s;"
                     (self.moduleCtrl.getClassMemberName( member.$symbolInfo )) );
               }
               self.popIndent();
               self.writeln( "}" );
            }
            else {
               processMethodDeclTxt(
                  self.stream, self.moduleCtrl, .Normal, getterType## );
               self.writeln( "{" );
               self.pushIndent(##);
               self.writeln(
                  "return %s;" (getAccessMember(className, "pObj", memberName) ) );
               self.popIndent();
               self.writeln( "}" );

               processMethodDeclTxt(
                  self.stream, self.moduleCtrl, .CallWrap, getterType## );
               self.writeln( "{" );
               self.pushIndent(##);
               self.writeln(
                  "return lns_mtd_%s( pObj )->get_%s( _pEnv, pObj );"
                  (className, memberName) );
               self.popIndent();
               self.writeln( "}" );
            }
         }
      }
      if member.$setterMode ~= .None {
         let setterType = unwrap node.$scope.getTypeInfoField(
            "set_%s" (memberName), true, node.$scope, scopeAccess );

         fn process( accessMemberTxt:str ) {
            self.writeln( "{" );
            self.pushIndent(##);
            let valKind = self.scopeMgr.getSymbolValKind( member.$symbolInfo );
            switch valKind {
               case .Stem {
                  self.writeln(
                     'lns_setq( _pEnv, %s, arg1 );' (accessMemberTxt) );
               }
               case .Any {
                  self.writeln(
                     'lns_setq_any( _pEnv, &%s, arg1 );' (accessMemberTxt ) );
               }
               case .Prim {
                  self.writeln( "%s = arg1;" (accessMemberTxt ) );
               }
               default {
                  Util.err( "no support -- %s:%s:%d"
                     (member.$symbolInfo.$name,valKind.$_txt,__line__));
               }
            }
            self.popIndent();
            self.writeln( "}" );
         }
         
         if setterType.$autoFlag {
            if setterType.$staticFlag {
               processMethodDeclTxt(
                  self.stream, self.moduleCtrl, .Normal, setterType## );
               let txt;
               if self.isManagedAnySymbol( member.$symbolInfo ) {
                  txt = "(*%s)" ( self.moduleCtrl.getClassMemberName( member.$symbolInfo ) );
               }
               else {
                  txt = self.moduleCtrl.getClassMemberName( member.$symbolInfo );
               }
               
               process( txt );
            }
            else {
               processMethodDeclTxt(
                  self.stream, self.moduleCtrl, .Normal, setterType## );
               process( getAccessMember(className, "pObj", memberName) );
               // self.writeln( "{" );
               // self.pushIndent(##);
               // let valKind = self.scopeMgr.getSymbolValKind( member.$symbolInfo );
               // let accessMemberTxt = getAccessMember(className, "pObj", memberName);
               // switch valKind {
               //    case .Stem {
               //       self.writeln(
               //          'lns_setq( _pEnv, %s, arg1 );' (accessMemberTxt) );
               //    }
               //    case .Any {
               //       self.writeln(
               //          'lns_setq_any( _pEnv, &%s, arg1 );' (accessMemberTxt ) );
               //    }
               //    case .Prim {
               //       self.writeln( "%s = arg1;" (accessMemberTxt ) );
               //    }
               //    default {
               //       Util.err( "no support -- %s:%s:%d"
               //          (member.$symbolInfo.$name,valKind.$_txt,__line__));
               //    }
               // }
               // self.popIndent();
               // self.writeln( "}" );

               processMethodDeclTxt(
                  self.stream, self.moduleCtrl, .CallWrap, setterType## );
               self.writeln( "{" );
               self.pushIndent(##);
               self.writeln(
                  "lns_mtd_%s( pObj )->set_%s( _pEnv, pObj, arg1 );"
                  (className, memberName) );
               self.popIndent();
               self.writeln( "}" );
            }
         }
      }
   }

   processAdvertise( self.stream, self.moduleCtrl, self.scopeMgr,
                     self.processMode, node );
}


fn processInitMethodTable(
   stream:Util.SourceStream, moduleCtrl:&ModuleCtrl, classTypeInfo:&Ast.TypeInfo )
{
   fn outputField( name:str, retTypeList:&List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "(%s *)%s," (methodType, name ) );
   }

   // let mut nameSet = new Util.OrderedSet<str>();
   // fn outputVal( scope:&Ast.Scope ) {
   //    if! let inherit = scope.$inherit {
   //       outputVal( inherit );
   //    }
   //    forsort symbolInfo in scope.$symbol2SymbolInfoMap {
   //       switch symbolInfo.$kind {
   //          case .Mtd {
   //             if symbolInfo.$name ~= "__init" {
   //                nameSet.add( symbolInfo.$name );
   //             }
   //          }
   //       }
   //    }
   // }

   let scope = unwrap classTypeInfo.$scope;
   // outputVal( scope );
   let nameSet = Ast.getAllMethodName( classTypeInfo, .Object );
   
   foreach name in nameSet.$list {
      let symbolInfo = unwrap scope.getSymbolInfoField( name, true, scope, .Normal );
      if not symbolInfo.$typeInfo.$abstractFlag {
         outputField( moduleCtrl.getMethodCName( symbolInfo.$typeInfo ),
                      symbolInfo.$typeInfo.$retTypeInfoList );
      }
      else {
         stream.writeln( "NULL," );
      }
   }
}

fn processInitIFMethodTable(
   stream:Util.SourceStream,
   moduleCtrl:&ModuleCtrl, ifType:&Ast.TypeInfo, classTypeInfo:&Ast.TypeInfo)
{
   fn outputField( name:str, retTypeList:&List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "(%s *)%s," (methodType, name ) );
   }

   fn outputVal( scope:&Ast.Scope, impScope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit, impScope );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mtd {
               if symbolInfo.$name ~= "__init" {
                  let impMethodSym = unwrap impScope.getSymbolInfoField(
                     symbolInfo.$name, true, impScope, scopeAccess );
                  let impMethodType = impMethodSym.$typeInfo;
                  outputField(
                     moduleCtrl.getMethodCName( impMethodType ),
                     impMethodType.$retTypeInfoList );
               }
            }
         }
      }
   }
   outputVal( unwrap ifType.$scope, unwrap classTypeInfo.$scope );
}


fn processIFMethodDataInit(
   stream:Util.SourceStream,
   moduleCtrl:&ModuleCtrl, classType:&Ast.TypeInfo, orgClassType:&Ast.TypeInfo )
{
   if classType.hasBase() {
      processIFMethodDataInit(
         stream, moduleCtrl, classType.$baseTypeInfo, orgClassType );
   }
   if not orgClassType.$abstractFlag {
      let className = moduleCtrl.getClassCName( orgClassType );
      foreach ifType in classType.$interfaceList {
         let ifName = moduleCtrl.getClassCName( ifType );
         stream.writeln(
            "static lns_mtd_%s_t lns_if_%s_imp_%s = {" ( ifName, className, ifName ) );
         stream.pushIndent(##);

         processInitIFMethodTable( stream, moduleCtrl, ifType, orgClassType );

         stream.popIndent();
         stream.writeln( "};" );
      }
   }
}

fn processClassMeta(
   stream:Util.SourceStream, moduleCtrl:&ModuleCtrl, classTypeInfo:&Ast.TypeInfo )
{
   let className = moduleCtrl.getClassCName( classTypeInfo );
   stream.write(
      'lns_type_meta_t %s = { "%s", &%s, {'
      ( moduleCtrl.getClassMetaName( classTypeInfo ), className,
        moduleCtrl.getClassMetaName( classTypeInfo.$baseTypeInfo ) ) );
   foreach ifType, index in classTypeInfo.$interfaceList {
      stream.write( "&%s, " ( moduleCtrl.getClassMetaName( ifType ) ) );
   }
   stream.writeln( "NULL } };" );
}

fn processClassDataInit(
   stream:Util.SourceStream, moduleCtrl:&ModuleCtrl, scopeMgr:ScopeMgr,
   classTypeInfo:&Ast.TypeInfo, fieldList:&List<&Nodes.Node> )
{
   let className = moduleCtrl.getClassCName( classTypeInfo );

   // クラスメタ情報
   if not Ast.isPubToExternal( classTypeInfo.$accessMode ) {
      stream.write( "static " );
   }
   processClassMeta( stream, moduleCtrl, classTypeInfo );

   if not classTypeInfo.$abstractFlag {
      // メソッド情報設定
      if not Ast.isPubToExternal( classTypeInfo.$accessMode ) {
         stream.write( "static " );
      }
      stream.writeln(
         "lns_mtd_%s_t lns_mtd_%s = {" ( className, className ) );
      stream.pushIndent(##);
      
      stream.writeln( "mtd_%s__del," ( className ) );

      if hasGC( classTypeInfo ) {
         stream.writeln( "mtd_%s__gc," ( className ) );
      }
      else {
         stream.writeln( "NULL," );
      }

      processInitMethodTable( stream, moduleCtrl, classTypeInfo );
      stream.popIndent();
      stream.writeln( "};" );
   }

   fn process( out2HMode:Out2HMode, symbolInfo:&Ast.SymbolInfo ) {
      switch out2HMode {
         case .HeaderPub, .SourcePub, .SourcePri {
            stream.writeln( "%s%s %s;"
               ( getOut2HeaderPrefix( out2HMode ),
                 scopeMgr.getCTypeForSym( symbolInfo ),
                 moduleCtrl.getClassMemberName( symbolInfo ) ) );
         }
      }
   }
   
   // static メンバー用変数宣言
   foreach symbolInfo in (unwrap classTypeInfo.$scope).$symbol2SymbolInfoMap {
      if isClassMember( symbolInfo ) {
         _out2Header(
            stream,
            Ast.isPubToExternal( classTypeInfo.$accessMode ) and
            Ast.isPubToExternal( symbolInfo.$accessMode ),
            `{ process( out2HMode, symbolInfo ); } );
      }
   }
   
   
}

pub override fn convFilter.processDeclMember(
   node: Nodes.DeclMemberNode, opt: Opt ) mut
{
   // dump( baseIndent, node, node.info.name.txt )
   // node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};

pub override fn convFilter.processExpMacroExp(
   node: Nodes.ExpMacroExpNode, opt: Opt ) mut
{
   foreach stmt in node.$stmtList {
      filter( stmt, self, node );
      self.writeln( "" );
   }
};


form outputMacroStmtBlock();

pub fn convFilter.outputDeclMacro(
   name:str, argNameList:&List<str>, callback:outputMacroStmtBlock ) mut
{
   // self.write( "local function %s(" ( name ) );

   // // let argTxt = "";
   // // foreach arg, index in macroInfo.get_argList() {
   // //    if index > 1 {
   // //       self.write( ", " );
   // //       argTxt = argTxt .. ", ";
   // //    }
   // //    filter( arg, self, node, baseIndent );
   // //    if arg.get_kind() == Nodes.NodeKind.$DeclArg {
   // //       argTxt = argTxt .. (arg@@Nodes.DeclArgNode).$name.txt;
   // //    }
   // //    else {
   // //       error( "not support ... in macro %s" ( node.get_declInfo().$name.txt ) );
   // //    }
   // // }

   // // self.writeln( ")", baseIndent );

   // self.writeln( "__macroArgs )" );
   // self.pushIndent(##);
   // foreach argName in argNameList {
   //    self.writeln( "local %s = __macroArgs.%s" (argName, argName ) );
   // }

   // self.writeln( "local macroVar = {}" );
   // self.writeln( "macroVar.__names = {}" );

   // self.macroDepth = self.macroDepth + 1;

   // callback();

   // self.macroDepth = self.macroDepth - 1;

   // self.writeln( "" );
   // self.writeln( "return macroVar" );
   // self.popIndent();
   // self.writeln( "end" );
   // self.writeln( "return %s" ( name ) );
}

pub override fn convFilter.processDeclMacro(
   node: Nodes.DeclMacroNode, opt: Opt ) mut
{
   // if self.inMacro {
   //    let macroInfo = node.get_declInfo();
   //    let mut argNameList:List<str> = [];
   //    foreach arg in macroInfo.$argList {
   //       argNameList.insert( arg.$name.txt );
   //    }
   //    self.outputDeclMacro(
   //       macroInfo.$name.txt, argNameList,
   //       fn () {
   //          if! let stmtBlock = macroInfo.$stmtBlock {
   //             filter( stmtBlock, self, node );
   //          }
   //       });
   // }
};

pub override fn convFilter.processExpMacroStat(
   node: Nodes.ExpMacroStatNode, opt: Opt ) mut
{
   // if #node.$expStrList == 0 {
   //    self.write( "''" );
   // }
   // else {
   //    foreach token, index in node.$expStrList {
   //       if index ~= 1 {
   //          self.write( '..' );
   //       }

   //       filter( token, self, node );
   //    }
   // }
};

/**
block から変数に領域割り当て処理を行なう。

@param declFlag 変数宣言を行なう場合 true
@param var 変数シンボル
@param init0 プリミティブな変数を 0 で初期化する場合 true 
*/
fn convFilter.processDeclVarC(
   declFlag:bool, var:&Ast.LowSymbol, init0:bool, manageScope:&Ast.Scope! ) mut
{
   if declFlag {
      let typeTxt = self.scopeMgr.getCTypeForSym( var );
      self.writeln( "%s %s;" ( typeTxt, self.moduleCtrl.getSymbolName( var ) ) );
   }

   let valKind = self.scopeMgr.getSymbolValKind( var );
   if valKind == .Prim {
      if init0 {
         self.writeln( "%s = 0;" ( self.moduleCtrl.getSymbolName( var )) );
      }
      return;
   }
   let! scope = manageScope {
      scope = var.$scope;
   };

   let initVal;
   if not init0 or isStemType( var.$typeInfo ) {
      if! let symbolInfo = var@@@Ast.SymbolInfo {
         switch valKind {
            case .Any {
               self.write( "lns_set_block_any" );
               self.writeln( "( %s, %d, %s );"
                             ( getBlockName( scope ), getSymbolIndex( symbolInfo ),
                               self.moduleCtrl.getSymbolName( var ) ) );
            }
            case .Stem {
               self.write( "lns_set_block_stem" );
               self.writeln( "( %s, %d, %s );"
                             ( getBlockName( scope ), getSymbolIndex( symbolInfo ),
                               self.moduleCtrl.getSymbolName( var ) ) );
            }
            case .Var {
               let typeTxt = getStemTypeId( getOrgTypeInfo( var.$typeInfo ) );
               self.writeln( "lns_set_block_var( %s, %d, %s, %s );"
                             ( getBlockName( scope ), getSymbolIndex( symbolInfo ),
                               typeTxt, self.moduleCtrl.getSymbolName( var ) ) );
            }
         }
      }
      // else {
      //    self.writeln( "%s = NULL;" ( getSymbolName( var ) ) );
      // }
   }
   else {
      initVal = getLiteral2Stem( "0", var.$typeInfo );

      if! let symbolInfo = var@@@Ast.SymbolInfo {
         switch valKind {
            case .Stem {
               self.write( "lns_initVal_stem" );
            }
            case .Any {
               self.write( "lns_initVal_any" );
            }
            case .Var {
               self.write( "lns_initVal_var" );
            }
            default {
               Util.err( "not support -- %s" (valKind.$_txt) );
            }
         }
         // self.write( "lns_initVal_var" );
         self.writeln( "( %s, %s, %d, %s );"
                       (self.moduleCtrl.getSymbolName( var ), getBlockName( scope ),
                         getSymbolIndex( symbolInfo ), initVal ) );
      }
      else {
         self.writeln( "%s = %s;" ( self.moduleCtrl.getSymbolName( var ), initVal ) );
      }
   }
}

fn convFilter.process__func__symbol(
   funcTypeInfo:&Ast.TypeInfo, has__func__Symbol:bool, mut funcName:str ) mut
{
   if not has__func__Symbol {
      return;
   }
   switch self.processMode {
      case .WideScopeVer {
         let scope = unwrap funcTypeInfo.$scope;
         let symbol = unwrap scope.getSymbolInfoChild( "__func__" );
         self.writeln(
            "static %s %s = NULL;"
            (cTypeAnyPP, self.moduleCtrl.getSymbolName( symbol ) ) );
      }
      case .InitFuncSym {
         let scope = unwrap funcTypeInfo.$scope;
         let symbol = unwrap scope.getSymbolInfoChild( "__func__" );
         let symbolParam = self.scopeMgr.getSymbolParam( symbol );
         let symbolName = self.moduleCtrl.getSymbolName( symbol );
         self.writeln( "lns_set_block_any( pBlock, %d, %s );"
                       (symbolParam.index, symbolName ) );
         self.writeln( 'lns_setQ_any( %s, lns_litStr2any( _pEnv, "%s") );'
                       ( symbolName, funcName ) );
      }
   }
}

/**
引数をクロージャで使用している場合の処理。
*/
fn convFilter.processArgClosure( declInfo:&Nodes.DeclFuncInfo ) mut
{
   foreach argNode in declInfo.$argList {
      if! let declArg = argNode@@@Nodes.DeclArgNode {
         let symbolInfo = declArg.$symbolInfo;
         if symbolInfo.$hasAccessFromClosure {
            // 引数がクロージャからアクセスされている場合は、
            // クロージャ用に変数を定義しなおす。
            let symbolParam = self.scopeMgr.getSymbolParam( symbolInfo );
            self.writeln( "%s %s;" ( symbolParam.typeTxt,
                                     self.moduleCtrl.getSymbolName( symbolInfo ) ) );     

            self.write( "lns_initVal_var(" );
            self.write( " %s, %s, %d, "
                        ( self.moduleCtrl.getSymbolName( symbolInfo ),
                          getBlockName( symbolInfo.$scope ), symbolParam.index ) );


            let valKind = getValKind( symbolInfo.$typeInfo );
            let workSymbol = new WorkSymbol(
               symbolInfo.$scope, symbolInfo.$accessMode, "_%s" (symbolInfo.$name), 
               symbolInfo.$typeInfo, symbolInfo.$kind, symbolInfo.$staticFlag,
               new SymbolParam( valKind, 0, getCType( symbolInfo.$typeInfo ) ) );
            
            self.processSym2stem( workSymbol );
            self.writeln( ");" );
         }
         elseif symbolInfo.$mutable {
            // 引数が mutable の場合は変数を定義しなおす。
            let symbolParam = self.scopeMgr.getSymbolParam( symbolInfo );
            self.processDeclVarC( true, symbolInfo, false## );
            switch getValKind( symbolInfo.$typeInfo ) {
               case .Stem {
                  self.writeln(
                     "lns_setQ( %s, _%s );" ( symbolInfo.$name, symbolInfo.$name ) );
               }
               case .Any {
                  self.writeln(
                     "lns_setQ_any( %s, _%s );" ( symbolInfo.$name, symbolInfo.$name ) );
               }
               case .Prim {
                  self.writeln( "%s = _%s;" (symbolInfo.$name, symbolInfo.$name) );
               }
            }
         }
      }
   }
}


fn convFilter.processDeclMethodInfo(
   declInfo:&Nodes.DeclFuncInfo, funcTypeInfo:&Ast.TypeInfo, parent:Nodes.Node ) mut
{
   switch self.processMode {
      case .Prototype {
         processPrototypeMethod(
            self.stream, self.moduleCtrl, declInfo.$argList, funcTypeInfo );
      }
      case .Form {
         let classType = funcTypeInfo.$parentInfo;
         let className = self.moduleCtrl.getClassCName( classType );
         if! let body = declInfo.$body {
            let methodNodeToken = unwrap declInfo.get_name();
            processMethodDeclTxt( self.stream, self.moduleCtrl, .Normal,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( "{" );

            self.pushIndent(##);

            self.pushRoutine( funcTypeInfo, body );

            if! let declClassNode = declInfo.$declClassNode {
               if declInfo.$name$.txt == "__init" {
                  // コンストラクタで、未初期化メンバを nil で初期化する。
                  foreach memberSym in declClassNode.$uninitMemberList {
                     if declInfo.$staticFlag == memberSym.$staticFlag {
                        let memberAccess;

                        if declInfo.$staticFlag {
                           memberAccess = self.moduleCtrl.getClassMemberName(memberSym );
                        }
                        else {
                           memberAccess = getAccessMember( className,
                                                           "pObj", memberSym.$name );
                        }
                        self.writeln( "%s = %s;" ( memberAccess, cValNil ));
                     }
                  }
               }
            }


            if funcTypeInfo.$staticFlag and funcTypeInfo.$rawTxt == "___init" {
               foreach symbol in (unwrap classType.$scope).$symbol2SymbolInfoMap {
                  if isClassMember( symbol ) {
                     self.processDeclVarC(
                        false, symbol, false, self.moduleTypeInfo.$scope );
                  }
               }
            }
            

            let scope = body.$scope;
            if! let selfSymbol = scope.getSymbolInfoChild( "self" ) {
               let symbolParam = self.scopeMgr.getSymbolParam( selfSymbol );
               if symbolParam.kind == .Var {
                  self.writeln( "%s self;" (cTypeVarP) );
                  self.writeln( "lns_initVal_var( self, %s, %d, LNS_STEM_ANY( pObj ) );"
                                (getBlockName( scope ), symbolParam.index ) );
               }
               else {
                  if not funcTypeInfo.$staticFlag {
                     self.writeln( "%s self = pObj;" (cTypeAnyP) );
                  }
               }
            }

            self.processArgClosure( declInfo );
            

            self.duringDeclFunc = true;
            filter( body, self, parent );
            self.duringDeclFunc = false;
            

            self.popRoutine();

            self.popIndent();
            self.writeln( "}" );
         }
         processDeclCallMethodWrapper(
            self.stream, self.moduleCtrl, self.scopeMgr, parent, funcTypeInfo, true );
         processDeclCallMethodWrapper(
            self.stream, self.moduleCtrl, self.scopeMgr, parent, funcTypeInfo, false );
      }
      case .InitFuncSym, .WideScopeVer {
         self.process__func__symbol(
            funcTypeInfo, declInfo.$has__func__Symbol,
            self.moduleCtrl.getMethodCName( funcTypeInfo ) );
      }
   }
}


pub override fn convFilter.processDeclConstr(
   node: Nodes.DeclConstrNode, opt: Opt ) mut
{
   self.processDeclMethodInfo( node.$declInfo, node.$expType, node );
};

pub override fn convFilter.processDeclDestr(
   node: Nodes.DeclDestrNode, opt: Opt ) mut
{
   // self.writeln( "function %s.__free( self )"
   //    ( node.$declInfo.$classTypeInfo$.getTxt$(##) ) );

   // self.process__func__symbol(
   //    node.$declInfo.$has__func__Symbol, node.$expType.$parentInfo, "__free" );

   // filter( unwrap node.$declInfo.$body, self, node );

   // let classTypeInfo = node.$expType.$parentInfo;
   // if! self.getDestrClass( classTypeInfo.$baseTypeInfo ) {
   //    self.writeln( "%s.__free( self )" (_exp.getTxt(##) ) );
   // }

   // self.writeln( "end" );
}

fn convFilter.getValKindOfNode( node:&Nodes.Node ) mut: ValKind {
   if #node.$expTypeList > 1 {
      return .Stem;
   }

   let symbolList = node.getSymbolInfo();
   if #symbolList > 0 {
      return self.scopeMgr.getSymbolValKind( symbolList[ 1 ] );
   }
   return getValKind( node.$expType );
}

/**
node が示す値を stem 型に変換する処理を出力する

@param node Node
@param parent このノードの親
*/
pub fn convFilter.processVal2stem( node:&Nodes.Node, parent: &Nodes.Node ) mut
{
   process2stem(
      self.stream, self.moduleCtrl, self.scopeMgr,
      self.getValKindOfNode( node ), node.$expType, parent,
      fn () {
         filter( node, self, parent );
      } );
}



/**
関数呼び出しの引数処理。

コールする関数の引数に合せて、引数を調整する。

例えばコールする関数の引数が ... の場合、 lns_createDDD() する等。

@param funcType コールする関数のタイプ
@param expListNode 引数リストノード
*/
pub fn convFilter.processCallArgList(
   funcType:&Ast.TypeInfo, expListNode: &Nodes.ExpListNode! ) mut
{
   let funcArgTypeList = funcType.$argTypeInfoList;

   // 引数を省略した場合に与えるデフォルト値
   let abbrValTxt;
   if self.moduleCtrl.getBuiltinFuncNameFromType( funcType ) or
       ( funcType.$kind == .Method and
         funcType.$parentInfo.equals( Ast.builtinTypeString ## ) )
   {
      // 本来は、 Lua モジュールで、かつ C で定義しているもの
      abbrValTxt = cValNone;
   }
   else {
      abbrValTxt = cValNil;
   }

   fn processAbbr( funcArgType:&Ast.TypeInfo ) {
      if funcArgType.$kind == .DDD {
         self.write( cValDDD0 );
      }
      else {
         self.write( abbrValTxt );
      }
   }

   
   when! expListNode {
      let expList = expListNode.$expList;
      foreach funcArgType, index in funcArgTypeList {
         self.write( ", " );
         if #expList >= index {
            let expNode = expList[ index ];
            if expNode.$expType.$kind == .Abbr {
               processAbbr( funcArgType );
            }
            else {
               if funcArgType.$kind == .DDD {
                  if expNode.$kind == Nodes.NodeKind.$Abbr {
                     self.write( cValDDD0 );
                  }
                  else {
                     filter( expNode, self, expListNode );
                  }
                  // self.processCreateDDD( true, expList, index, parent );
                  // for expIndex = index, #expList {
                  //    self.write( ", " );
                  //    self.processVal2stem( expList[ expIndex ], parent );
                  // }
                  // self.write( ")" );
                  return;
               }
               else {
                  // if funcArgType.$kind == .Form {
                  if isStemType( funcArgType ) {
                     self.processVal2stem( expNode, expListNode );
                  }
                  else {
                     filter( expNode, self, expListNode );
                  }
               }
            }
         }
         else {
            processAbbr( funcArgType );
            // if funcArgType.$kind == .DDD {
            //    self.write( cValDDD0 );
            // }
            // else {
            //    self.write( abbrValTxt );
            // }
         }
      }
   }
   else {
      foreach funcArgType in funcArgTypeList {
         self.write( ", " );
         processAbbr( funcArgType );
         // if funcArgType.$kind == .DDD {
         //    self.write( cValDDD0 );
         // }
         // else {
         //    self.write( abbrValTxt );
         // }
      }
   }
}


pub override fn convFilter.processExpCallSuper(
   node: Nodes.ExpCallSuperNode, opt: Opt ) mut
{
   let funcType;
   if node.$methodType.$rawTxt == "__init" {
      self.write( "%s( _pEnv, pObj" ( self.moduleCtrl.getCtorName( node.$superType ) ) );
      let superScope = unwrap node.$superType.$scope;
      funcType = unwrap superScope.getTypeInfoChild("__init");
   }
   else {
      self.write( "%s( _pEnv, pObj"
                  ( self.moduleCtrl.getMethodCName( node.$methodType ) ) );
      funcType = node.$methodType;
   }

   self.processCallArgList( funcType, node.$expList );
   self.writeln( ");" );
};

pub override fn convFilter.processDeclMethod(
   node: Nodes.DeclMethodNode, opt: Opt ) mut
{
   self.processDeclMethodInfo( node.$declInfo, node.$expType, node );
};

pub override fn convFilter.processProtoMethod(
   node: Nodes.ProtoMethodNode, opt: Opt ) mut
{
   if node.$expType.$abstractFlag {
      self.processDeclMethodInfo( node.$declInfo, node.$expType, node );
   }
};


pub override fn convFilter.processUnwrapSet(
   node: Nodes.UnwrapSetNode, opt: Opt ) mut
{
   // let dstExpList = node.$dstExpList;
   // filter( dstExpList, self, node );
   // self.write( " = " );
   // filter( node.$srcExpList, self, node );
   // self.writeln( "" );

   // self.write( "if " );
   // foreach expNode, index in dstExpList.$expList {
   //    if index > 1 {
   //       self.write( " or " );
   //    }
   //    self.write( "nil == " );
   //    filter( expNode, self, node );
   // }
   // self.writeln( " then" );
   // self.pushIndent(##);

   // foreach expNode, index in dstExpList.$expList {
   //    self.write( "local _exp%d = " (index));
   //    filter( expNode, self, node );
   //    self.writeln( "" );
   // }

   // if node.$unwrapBlock {
   //    filter( unwrap node.$unwrapBlock, self, node );
   // }
   // self.popIndent();
   // self.writeln( "end" );
}


fn convFilter.accessPrimValFromAny(
   dddFlag:bool, typeInfo:&Ast.TypeInfo, index:int ) mut
{
   self.write( getAccessPrimValFromStem( dddFlag, typeInfo, index ) );
}

fn convFilter.isStemSym( symbolInfo:&Ast.LowSymbol ) mut : bool {
   return self.scopeMgr.getSymbolValKind( symbolInfo ) ~= .Prim;
}


fn convFilter.isStemVal( node:&Nodes.Node ) mut : bool {
   if #node.$expTypeList > 1 {
      return false;
   }

   let symbolList = node.getSymbolInfo();
   if #symbolList > 0 {
      // val は評価のタイミングで any にしているので、 prim 以外は any。
      return self.scopeMgr.getSymbolValKind( symbolList[ 1 ] ) ~= .Prim;
   }
   return isStemType( node.$expType );
}

/**
exp の値にアクセスするためのコードを出力する。
*/
pub fn convFilter.accessPrimVal( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   // if exp@@@Nodes.LiteralIntNode or exp@@@Nodes.LiteralCharNode
   //    or exp@@@Nodes.LiteralRealNode
   switch self.getValKindOfNode( exp ) {
      case .Var {
         filter( exp, self, parent );
      }
      case .Prim {
         filter( exp, self, parent );
      }
      case .Stem {
         filter( exp, self, parent );
         self.accessPrimValFromAny( #exp.$expTypeList > 1, exp.$expType, 0 );
         // let expType = exp.$expType.$srcTypeInfo;
         // switch expType {
         //    case Ast.builtinTypeInt, Ast.builtinTypeChar {
         //       self.write( ".val.intVal" );
         //    }
         //    case Ast.builtinTypeReal {
         //       self.write( ".val.realVal" );
         //    }
         //    case Ast.builtinTypeBool {
         //       self.write( ".val.boolVal" );
         //    }
         //    default {
         //       self.write( ".val.pAny" );
         //    }
         // }
      }
      case .Any {
         filter( exp, self, parent );
      }
      default {
         Util.err( "not support -- %d" (__line__) );
      }
   }

   
   // }
   // else {
   //    filter( exp, self, parent );
   //    self.accessPrimValFromAny( #exp.$expTypeList > 1, exp.$expType, 0 );
   //    // if #exp.$expTypeList > 1 {
   //    //    self.write( "->val.ddd.pAnyList[ 0 ]" );
   //    // }

   //    // let expType = exp.$expType.$srcTypeInfo;
   //    // switch expType {
   //    //    case Ast.builtinTypeInt, Ast.builtinTypeChar {
   //    //       self.write( "->val.intVal" );
   //    //    }
   //    //    case Ast.builtinTypeReal {
   //    //       self.write( "->val.realVal" );
   //    //    }
   //    //    case Ast.builtinTypeBool {
   //    //       self.write( "->val.boolVal" );
   //    //    }
   //    // }
   // }
}


/**
symbol が示す値を any 型に変換する処理を出力する

@param symbol シンボル
*/
pub fn convFilter.processSym2Any( symbol:&Ast.LowSymbol ) mut
{
   let valKind = self.scopeMgr.getSymbolValKind( symbol );
   let symName;
   if self.isManagedAnySymbol( symbol ) {
      symName = "(*%s)" ( self.moduleCtrl.getSymbolName( symbol ) );
   }
   else {
      symName = self.moduleCtrl.getSymbolName( symbol );
   }
   switch valKind {
      case .Stem {
         self.write( symName );
         self.write( accessAny );
      }
      case .Any {
         self.write( symName );
      }
      case .Var {
         self.write( symName );
         self.write( "->stem%s" (accessAny) );
      }
      default {
         Util.err( "not suppport -- %s, %d" (valKind.$_txt, __line__ ) );
      }
   }
}



pub fn convFilter.processVal2any( node:&Nodes.Node, parent: &Nodes.Node ) mut
{
   let valKind = self.getValKindOfNode( node );
   switch valKind {
      case .Stem {
         filter( node, self, parent );
         self.write( accessAny );
      }
      case .Any {
         filter( node, self, parent );
      }
      case .Var {
         filter( node, self, parent );
         //self.write( accessAny );
      }
      default {
         Util.err( "not suppport -- %d, %s, %s, %d"
                   ( node.$pos.lineNo, valKind.$_txt,
                     Nodes.getNodeKindName( node.$kind ), __line__ ) );
      }
   }
}

/** 代入する値を出力する処理 */
form processRValue();

/**
シンボル var に値を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param var 代入先のシンボル
@param initFlag 変数に対する初期値設定の場合 true
@param expValKind 代入元の kind
@param expValType w代入元の TypeInfo
@param index exp が ... の場合の index
@param firstMRet index が多値要素の最初のインデックスの場合 true
@param processVal 代入する値にアクセスするコードを出力するコールバック
*/
fn convFilter.processSetValSingleDirect(
   parent:&Nodes.Node, node:&Nodes.Node!, var:&Ast.LowSymbol, initFlag:bool,
   expValKind:ValKind, expValType:&Ast.TypeInfo,
   index:int, firstMRet:bool, processVal:processRValue ) mut
{
   let valKind = self.scopeMgr.getSymbolValKind( var );

   let mut varName = self.moduleCtrl.getSymbolName( var );
   if self.isManagedAnySymbol( var ) {
      varName = "(*%s)" (varName);
   }
   let mut processPrefix:form! = nil;
   if! let fieldNode = node@@@Nodes.RefFieldNode {
      if fieldNode.$symbolInfo$.$staticFlag {
         //varName = self.moduleCtrl.getClassMemberName( unwrap fieldNode.$symbolInfo );
      }
      else {
         processPrefix = fn () {
            let prefixNode = fieldNode.$prefix;
            let className = self.moduleCtrl.getClassCName( prefixNode.$expType );
            self.write( "lns_obj_%s( " (className) );
            self.processVal2any( prefixNode, fieldNode );
            //filter( prefixNode, self, fieldNode );
            //self.write( accessAny );
            self.write( ")->" );
         };
      }
   }

   if var.$symbolId == invalidSymbolId {
      if valKind == expValKind {
         self.write( "%s = " (varName) );
         processVal();
         self.write( ";" );
         return;
      }
      Util.err( "illegal %s %s %s -- %d"
                (var.$name, valKind.$_txt, expValKind.$_txt, __line__) );
   }
   

   
   switch valKind {
      case .Var {
         // switch expValKind {
            // case .Stem {
            //    if initFlag {
            //       self.write( "lns_setQ( %s->stem, " ( varName ) );
            //    }
            //    else {
            //       self.write( "lns_setq( _pEnv, %s->stem, " ( varName ) );
            //    }
            //    processVal();
            //    self.writeln( " );" );
            // }
            // case .Any {
            //    if initFlag {
            //       self.write( "lns_setQ( &%s->stem, LNS_STEM_ANY( " ( varName ) );
            //    }
            //    else {
            //       self.write( "lns_setq( _pEnv, &%s->stem, LNS_STEM_ANY( " ( varName ) );
            //    }
            //    when! processPrefix {
            //       processPrefix(##);
            //    }
            //    processVal();
            //    self.write( " ) );" );
            // }
            // case .Prim {
            //    self.write( "%s->stem" (varName) );
            //    self.write( getAccessValFromStem( var.$typeInfo) );
            //    self.write( " = " );
            //    processVal();
            //    self.write( ";" );
            // }
         // }
         if initFlag {
            self.write( "lns_setQ( %s->stem, " ( varName ) );
         }
         else {
            self.write( "lns_setq( _pEnv, %s->stem, " ( varName ) );
         }
         
         process2stem(
            self.stream, self.moduleCtrl, self.scopeMgr,
            expValKind, expValType, parent, processVal );
         self.write( " );" );
      }
      case .Stem {
         switch expValKind {
            case .Stem, .Any, .Prim { 
               if initFlag {
                  self.write( "lns_setQ( " );
               }
               else {
                  self.write( "lns_setq( _pEnv, " );
               }
               when! processPrefix {
                  processPrefix(##);
               }
               self.write( "%s, " ( varName ) );
               processVal();
               self.write( " );" );
            }
            // case .Any {
            //    if initFlag {
            //       self.write( "lns_setQ_any( &%s->val.pAny, " ( varName ) );
            //    }
            //    else {
            //       self.write( "lns_setq_any( _pEnv, &%s->val.pAny, " ( varName ) );
            //    }
            //    when! processPrefix {
            //       processPrefix();
            //    }
            //    self.write( "%s, " ( varName ) );
            //    processVal();
            //    self.write( " );" );
            // }
            // case .Prim {
            //    when! processPrefix {
            //       processPrefix();
            //    }
            //    //self.write( self.scopeMgr.getAccessPrimValFromSymbol( var ) );
            //    self.write( var.$name );
            //    self.write( " = " );
            //    processVal();
            //    self.write( ";" );
            // }
         }
      }
      case .Any {
         if initFlag {
            self.write( "lns_setQ_any( &" );
         }
         else {
            self.write( "lns_setq_any( _pEnv, &" );
         }
         when! processPrefix {
            processPrefix(##);
         }
         self.write( "%s, " ( varName ) );
         processVal();
         self.write( " );" );
      }
      default {
         when! processPrefix {
            processPrefix(##);
         }
         self.write( "%s = " (varName ) );
         processVal();
         self.write( ";" );
      }
   }
}



/**
symbolInfo の値を変数にセットする処理を出力する。

@param parent 親ノード
@param dstKind 変数の種別
@param dstTypeInfo 変数の型
@param symbol 代入元のシンボル
*/
fn convFilter.processSymForSetOp(
   parent:&Nodes.Node, dstKind:ValKind,
   dstTypeInfo:&Ast.TypeInfo, symbol:&Ast.LowSymbol ) mut
{
   let srcKind = self.scopeMgr.getSymbolValKind( symbol );
   let isStemExp = srcKind ~= .Prim;

   if dstKind ~= srcKind {
      switch dstKind {
         case .Prim {
            // 値が any で、変数が Prim 型の場合
            self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbol ) );
            return;
         }
         case .Stem {
            self.processSym2stem( symbol );
            return;
         }
         case .Var {
            self.processSym2stem( symbol );
            // self.processSym2stem( symbol );
            return;
         }
         case .Any {
            self.processSym2Any( symbol );
            return;
         }
         default {
            Util.err( "not support -- %s" (dstKind.$_txt) );
         }
      }
   }
   let symName;
   if self.isManagedAnySymbol( symbol ) {
      symName = "(*%s)" ( self.moduleCtrl.getSymbolName( symbol ) );
   }
   else {
      symName = self.moduleCtrl.getSymbolName( symbol );
   }
   self.write( symName );
}

/**
インタフェース型の可能性のある値を、インタフェース型に変換する。

次の関数の様に、戻り値が Generics の型パラメータの場合、

fn func<T>() : T; 

その関数の戻り値が、インタフェースではなくクラスのオブジェクトを返すことがある。
そのような場合に、クラスのオブジェクトから所定のインタフェースの
オブジェクトを返すように lns_toIF() 処理を追加する。

ただし、通常は、
*/
fn processToIF( stream:Util.SourceStream,
                moduleCtrl:ModuleCtrl, expType:&Ast.TypeInfo, process:processExp )
{
   if expType.$kind == .IF {
      stream.write( "lns_toIF( _pEnv, " );
      process();
      stream.write( ", &lns_type_meta_%s )" (moduleCtrl.getClassCName( expType )) );
      stream.write( accessAny );
   }
   else {
      process();
   }
}



fn processGetMRet( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                   typeInfo:&Ast.TypeInfo, index:int )
{
   fn process() {
      stream.write( "lns_getMRet( _pEnv, %d )" (index) );
      stream.write( getAccessValFromStem( typeInfo ) );
   }
   if typeInfo.$kind == .IF {
      processToIF( stream, moduleCtrl, typeInfo, process );
   }
   else {
      process();
   }
}

fn needsWrapper( orgFunc:&Ast.TypeInfo, castType:&Ast.TypeInfo ): bool {
   if #orgFunc.$argTypeInfoList == #castType.$argTypeInfoList and
      #orgFunc.$retTypeInfoList == #castType.$retTypeInfoList
   {
      fn check( typeList1:&List<&Ast.TypeInfo>, typeList2:&List<&Ast.TypeInfo> ) : bool
      {
         foreach type1, index in typeList1 {
            if not type1.equals( typeList2[ index ] ## ) {
               return false;
            }
         }
         return true;
      }
      if check( orgFunc.$argTypeInfoList, castType.$argTypeInfoList ) and
         check( orgFunc.$retTypeInfoList, castType.$retTypeInfoList )
      {
         // 引数、戻り値が等しい場合は wrapper は不要。
         return false;
      }
   }
   return true;
}

fn convFilter.processFuncCast2Form(
   castType:&Ast.TypeInfo, orgFunc:&Ast.TypeInfo  ) mut
{
   if not needsWrapper( orgFunc, castType ) {
      self.write( getFunc2any( self.moduleCtrl, self.scopeMgr, orgFunc ) );
      return;
   }
   
   let closureSymList = unwrap orgFunc.$scope$.$closureSymList default [];
   
   let argList = castType.$argTypeInfoList;
   let hasDDD =
      #argList > 0 and argList[ #argList ].$kind == .DDD or false;

   self.write( getPrepareClosure(
      self.scopeMgr, self.moduleCtrl.getFuncCastWrapName( orgFunc, castType ),
      #argList, hasDDD, closureSymList ) );
}



/**
Node の値を変数にセットする処理を出力する。

@param parent 親ノード
@param dstKind 変数の種別
@param dstTypeInfo 変数の型
@param exp 値のノード
@param index exp が多値だった場合の何番目の値にアクセスするか
@param firstMRet exp が多値の先頭アクセスの場合
*/
fn convFilter.processValForSetOp(
   parent:&Nodes.Node, dstKind:ValKind, dstTypeInfo:&Ast.TypeInfo,
   exp:&Nodes.Node, index:int, firstMRet:bool ) mut
{
   let valKind = self.getValKindOfNode( exp );

   fn accessVal() {
      if firstMRet {
         processGetMRet( self.stream, self.moduleCtrl, exp.$expType, 0 );
      }
      else {
         if exp.$expType.$kind == .Func {
            self.processFuncCast2Form( dstTypeInfo, exp.$expType );
            // self.write( self.getFunc2any( exp.$expType ) );
         }
         else {
            filter( exp, self, parent );
         }
      }
   }

   fn processVal() {
      // シンボルに代入する値にアクセスするコード出力
      let mut setValTxt = "";
      if firstMRet {
         accessVal();
      }
      elseif not firstMRet and Nodes.hasMultiValNode( exp ) {
         self.write( "lns_fromDDD( " );
         accessVal();
         self.write( accessAny );
         self.write( ", %d )" (index) );
         self.write( getAccessValFromStem( exp.$expType ) );
      }
      else {
         if dstKind == .Stem {
            self.processVal2stem( exp, parent );
         }
         elseif dstKind == .Var and valKind ~= .Stem {
            //self.processVal2stem( exp, parent );
            accessVal();
         }
         else {
            accessVal();
         }
      }
   }
   if dstKind == .Prim and valKind == .Stem {
      // 値が any で、変数が Prim 型の場合
      let expSymList = exp.getSymbolInfo();
      if #expSymList > 0 {
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( expSymList[ 1 ] ) );
      }
      else {
         processVal();
         //self.write( getAccessPrimValFromStem( false, dstTypeInfo, 0 ) );
      }
   }
   else {
      processVal();
   }
}


fn processAlterAccessVal(
   stream:Util.SourceStream,
   srcTypeList:&List<&Ast.TypeInfo>, dstTypeList:&List<&Ast.TypeInfo> )
{
   if #dstTypeList == 1 {
      if srcTypeList[1].$kind == .Alternate {
         stream.write( getAccessValFromStem( dstTypeList[ 1 ] ) );
      }
   }
}

/**
AlternateTypeInfo から、実際の型に変換する処理を行なう

@param stream 出力先
@param moduleCtrl モジュール制御
@param classType この AlternateTypeInfo が続するクラス。
       クラスが存在しない場合は nil。
@param expType 変換元の値の型
@param process 値を出力するコールバック
*/
fn processAlterToActualType(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   fromType:&Ast.TypeInfo, toType:&Ast.TypeInfo, process:processExp )
{
   if fromType.$kind == .Alternate {
      if toType.$kind == .IF {
         processToIF( stream, moduleCtrl, toType, process );
      }
      else {
         process();
      }
   }
   else {
      process();
   }
}


/**
シンボル var に exp の式の結果を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param var シンボル
@param exp 代入する値の式
@param index exp が ... の場合の index
*/
fn convFilter.processSetValSingle(
   parent:&Nodes.Node, node:&Nodes.Node!, var:&Ast.LowSymbol,
   initFlag:bool, exp:&Nodes.Node, index:int, firstMRet:bool ) mut
{
   let expValKind;
   if firstMRet {
      expValKind = getValKind( exp.$expType );
   }
   else {
      expValKind = self.getValKindOfNode( exp );
   }
   
   self.processSetValSingleDirect(
      parent, node, var, initFlag, expValKind, exp.$expType, index, firstMRet,
      fn () {
         self.processValForSetOp(
            parent, self.scopeMgr.getSymbolValKind( var ),
            var.$typeInfo, exp, index, firstMRet );
      } );
}

/**
シンボル var に symbol の値を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param var 代入先シンボル
@param symbol 代入元シンボル
*/
fn convFilter.processSetSymSingle(
   parent:&Nodes.Node, node:&Nodes.Node!, var:&Ast.LowSymbol,
   initFlag:bool, symbol:&Ast.LowSymbol, toIF:bool ) mut
{
   fn process() {
      self.processSymForSetOp(
         parent, self.scopeMgr.getSymbolValKind( var ), var.$typeInfo, symbol );
   }
   
   self.processSetValSingleDirect(
      parent, node, var, initFlag, self.scopeMgr.getSymbolValKind( symbol ),
      symbol.$typeInfo, 1, false,
      fn () {
         if toIF {
            processToIF( self.stream, self.moduleCtrl, symbol.$typeInfo, process );
         }
         else {
            process();
         }
      } );
}



/**
シンボル var に exp の式の結果を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param exp 代入する値の式
@param index exp が ... の場合の index
*/
fn convFilter.processSetValSingleNode(
   parent:&Nodes.Node, var:&Nodes.Node, initFlag:bool,
   exp:&Nodes.Node, index:int, firstMRet:bool ) mut
{
   let symbolList = var.getSymbolInfo();
   if #symbolList > 0 {
      self.processSetValSingle(
         parent, var, symbolList[ 1 ], initFlag, exp, index, firstMRet );
      return;
   }

   switch var.$kind {
      case Nodes.NodeKind.$ExpRefItem {
         if! let refItemNode = var@@@Nodes.ExpRefItemNode {
            let dstType = refItemNode.$val.$expType;
            switch dstType.$kind {
               case .Map {     
                  self.write( "lns_mtd_Map_add( _pEnv, " );
                  self.processVal2any( refItemNode.$val, var );
                  self.write( ", " );
                  if! let indexNode = refItemNode.$index {
                     self.processVal2stem( indexNode, var );
                  }
                  else {
                     self.write(
                        getLiteralStrStem( '"%s"' (unwrap refItemNode.$symbol) ) );
                  }
                  self.write( ", " );
                  self.processValForSetOp(
                     parent, .Stem, dstType.$itemTypeInfoList[ 2 ],
                     exp, index, firstMRet );
                  self.write( ")" );
               }
               case .List {
                  self.write( "void lns_mtd_List_setAt( _pEnv, " );
                  self.processVal2any( refItemNode.$val, var );
                  self.write( ", " );
                  if! let indexNode = refItemNode.$index {
                     self.processVal2stem( indexNode, var );
                  }
                  else {
                     self.write(
                        getLiteralStrStem( '"%s"' (unwrap refItemNode.$symbol) ) );
                  }
                  self.write( ", " );
                  self.processValForSetOp(
                     parent, .Stem, dstType.$itemTypeInfoList[ 2 ],
                     exp, index, firstMRet );
                  self.write( ")" );
               }
               default {
                  Util.err( "not support type -- %s" ( dstType.$kind.$_txt )  );
               }
            }
         }
      }
      default {
         Util.err( "not support -- %s" (Nodes.getNodeKindName( var.$kind ) ) );
      }
   }
}

/** 代入先情報 */
alge DstInfo {
   Symbol( &Ast.LowSymbol, node:&Nodes.Node!, initFlag:bool ),
   Node( node:&Nodes.Node, initFlag:bool ),
}



/**
値をシンボルに代入する処理。

val1, val2, val3 = exp1, exp2, exp3

@param parent この代入処理の親 Node
@param varSymList 代入先のシンボルリスト。
@param expList 代入する値の Node リスト
@param varNode 代入先のシンボルリスト。 代入先が単なるシンボルの場合は不要。
    self.val = 1 のようにメンバに代入する場合に指定する。
@param mRetExp expList の MRetExp 情報。
*/
fn convFilter.processSetValToDst(
   parent: &Nodes.Node, dstList:&List<&DstInfo>, 
   expList:&List<&Nodes.Node>, mRetExp:&Nodes.MRetExp! ) mut
{
   let mut mRetIndex:int! = mRetExp$.$index;
   // 代入する値分のループを廻して、値を代入する処理を出力
   foreach exp, index in expList {
      let is1stMRet = index == mRetIndex;
      if is1stMRet {
         when! mRetExp {
            self.write( "lns_setMRet( _pEnv, " );
            filter( mRetExp.$exp, self, parent );
            self.write( accessAny );
            self.writeln( ");" );
         }
      }

      if index > #dstList {
         return;
      }

      
      if index == #expList {
         // 代入する最終要素の場合、最終要素の多値処理を行なう
         for dstIndex = index, #dstList {
            let accessIndex;
            when! mRetIndex {
               accessIndex = index - mRetIndex;
            }
            else {
               accessIndex = 0;
            }
            match dstList[ dstIndex ] {
               case .Symbol( symbolInfo, dstNode, initFlag ) {
                  self.processSetValSingle(
                     parent, dstNode, symbolInfo,
                     initFlag, exp, accessIndex, is1stMRet and dstIndex == index );
               }
               case .Node( dstNode, initFlag ) {
                  self.processSetValSingleNode(
                     parent, dstNode, initFlag, exp, accessIndex,
                     is1stMRet and dstIndex == index );         
               }
            }
            self.writeln( "" );
         }
      }
      else {
         let accessIndex;
         when! mRetIndex {
            accessIndex = index - mRetIndex;
         }
         else {
            accessIndex = 0;
         }
         match dstList[ index ] {
            case .Symbol( symbolInfo, dstNode, initFlag ) {
               self.processSetValSingle(
                  parent, dstNode, symbolInfo,
                  initFlag, exp, accessIndex, is1stMRet );
            }
            case .Node( dstNode, initFlag ) {
               self.processSetValSingleNode(
                  parent, dstNode, initFlag, exp, accessIndex, is1stMRet );         
            }
         }
         self.writeln( "" );
      }
   }
  
}


/**
値をシンボルに代入する処理。

val1, val2, val3 = exp1, exp2, exp3

@param parent この代入処理の親 Node
@param varSymList 代入先のシンボルリスト。
@param expList 代入する値の Node リスト
@param varNode 代入先のシンボルリスト。 代入先が単なるシンボルの場合は不要。
    self.val = 1 のようにメンバに代入する場合に指定する。
@param mRetExp expList の MRetExp 情報。
*/
fn convFilter.processSetValToSym(
   parent: &Nodes.Node, varSymList:&List<&Ast.LowSymbol>, initFlag:bool,
   expList:&List<&Nodes.Node>, varNode:&Nodes.Node!, mRetExp:&Nodes.MRetExp! ) mut
{
   let varNodeList:List<&Nodes.Node>;
   if! let expListNode = varNode@@@Nodes.ExpListNode {
      varNodeList = expListNode.$expList;
   }
   else {
      when! varNode {
         varNodeList = [ varNode ];
      }
      else {
         varNodeList = [];
      }
   }

   let mut dstList:List<&DstInfo> = [];
   foreach symbol, index in varSymList {
      let node:&Nodes.Node!;
      if index <= #varNodeList {
         node = varNodeList[ index ];
      }
      else {
         node = nil;
      }
      dstList.insert( DstInfo.Symbol( symbol, node, initFlag ) );
   }
   self.processSetValToDst( parent, dstList, expList, mRetExp);
}


/**
値を Node に代入する処理。

val1, val2, val3 = exp1, exp2, exp3

@param parent この代入処理の親 Node
@param dstNode 代入先の Node
@param expList 代入する値の Node リスト
@param mRetExp expList の MRetExp 情報。
*/
fn convFilter.processSetValToNode(
   parent: &Nodes.Node, dstNode:&Nodes.Node, initSymSet:&Set<&Ast.SymbolInfo>,
   expList:&List<&Nodes.Node>, mRetExp:&Nodes.MRetExp! ) mut
{
   fn isInitSym( node:&Nodes.Node ) : bool {
      let symbolList = node.getSymbolInfo();
      if #symbolList > 0 {
         return initSymSet.has( symbolList[ 1 ] );
      }
      return false;
   }
   
   let mut dstList:List<&DstInfo> = [];
   if! let expListNode = dstNode@@@Nodes.ExpListNode {
      foreach node in expListNode.$expList {
         dstList.insert( DstInfo.Node( node, isInitSym( node ) ) );
      }
   }
   else {
      dstList.insert( DstInfo.Node( dstNode, isInitSym( dstNode ) ) );
   }
   
   self.processSetValToDst( parent, dstList, expList, mRetExp);
}






fn convFilter.processDeclVarAndSet(
   varSymList:&List<&Ast.LowSymbol>, expListNode:&Nodes.ExpListNode! ) mut
{
   foreach var, index in varSymList  {
      let symbolParam = self.scopeMgr.getSymbolParam( var );
      let typeTxt, valKind = symbolParam.typeTxt, symbolParam.kind;
      let declVarFlag;
      if varSymList[ 1 ].$scope ~= self.ast.$moduleScope or
         symbolParam.index == invalidSymbolId
      {
         declVarFlag = true;
      }
      else {
         declVarFlag = false;
      }
      
      if valKind ~= .Prim {
         self.processDeclVarC( declVarFlag, var, valKind ~= .Var## );
      }
      else {
         if declVarFlag {
            self.writeln( "%s %s;" ( typeTxt, self.moduleCtrl.getSymbolName( var ) ) );
         }
      }
   }
   // 初期値代入
   when! expListNode {
      self.processSetValToSym( expListNode, varSymList, true,
                               expListNode.$expList, nil, expListNode.$mRetExp );
   }
}


pub override fn convFilter.processIfUnwrap(
   node: Nodes.IfUnwrapNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);

   let expListNode = node.$expList;
   // 一旦 work 変数に代入する
   let mut workSymList:List<&WorkSymbol> = [];
   foreach varSym, index in node.$varSymList {
      let workSymbol = new WorkSymbol(
         varSym.$scope, varSym.$accessMode, "_%s" (varSym.$name), 
         varSym.$typeInfo.$nilableTypeInfo, varSym.$kind, varSym.$staticFlag,
         new SymbolParam( .Stem, 0, cTypeStem ) );
      workSymList.insert( workSymbol );
   }
   self.processDeclVarAndSet( workSymList, expListNode );

   // work が nil でないことを確認する
   self.write( "if ( " );
   foreach workSym, index in workSymList {
      self.write( "%s.type != lns_stem_type_nil"
                  (self.moduleCtrl.getSymbolName( workSym )) );
      if index ~= #workSymList {
         self.write( " && " );
      }
   }
   self.writeln( ") {" );

   // nil でなければ、 work から変数にセットする
   self.processBlockPreProcess( node.$block.$scope );
   
   //self.processDeclVarAndSet( node.$varSymList, nil );


   foreach varSym, index in node.$varSymList {
      self.processDeclVarC( true, varSym, false ## );
      self.processSetSymSingle( node, nil, varSym, true, workSymList[ index ], false );
      self.writeln( "" );
   }
   // self.processSetValToSym( node, node.$varSymList, true,
   //                          expListNode.$expList, nil, expListNode.$mRetExp );

   // ブロックの実行
   filter( node.$block, self, node );

   self.processBlockPostProcess();
   self.writeln( "}" );
   
   if! node.$nilBlock {
      self.writeln( "else {" );
      filter( _exp, self, node );
      self.writeln( "}" );
   }
   
   
   self.popIndent();
   self.writeln( "}" );
}






pub override fn convFilter.processDeclVar(
   node: Nodes.DeclVarNode, opt: Opt ) mut
{
   switch self.processMode {
      case .WideScopeVer {
         if node.$mode == .Let {
            let varSymList = node.$symbolInfoList;
            if varSymList[ 1 ].$scope == self.moduleTypeInfo.$scope or
               self.outputBuiltinFlag
            {
               fn process( out2HMode:Out2HMode, var:&Ast.SymbolInfo ) {
                  let typeTxt = self.scopeMgr.getCTypeForSym( var );
                  self.write( getOut2HeaderPrefix( out2HMode ) );
                  self.writeln(
                     "%s %s;" ( typeTxt, self.moduleCtrl.getSymbolName( var ) ) );
               }
               foreach var, index in varSymList  {
                  _out2Header( self.stream, Ast.isPubToExternal( var.$accessMode ),
                               `{ process( out2HMode, var ); } );
               }
            }
         }
         return;
      }
      case .InitModule, .Form {
      }
      default {
         return;
      }
   }
   
   if node.$syncBlock {
      self.writeln( "{" );
      self.pushIndent(##);
      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s" (varInfo.$name.txt) );
      }
      self.writeln( "{" );
      self.pushIndent(##);
   }

   let varSymList = node.$symbolInfoList;

   if node.$unwrapFlag {

      let unwrapScope = unwrap node.$unwrapBlock$.$scope;

      let mut workSymList:List<&Ast.LowSymbol> = [];
      foreach varSym, index in varSymList {
         let tmpVarSym = unwrap unwrapScope.getSymbolInfoChild( "_%s" (varSym.$name) );
         // let symId = tmpVarSym.$symbolId;
         
         // let symbolParam = self.scopeMgr.getSymbolParam( tmpVarSym );
         // let symName = self.moduleCtrl.getSymbolName( tmpVarSym );
         // workSymList.insert( new WorkSymbol(
         //    varSym.$scope, varSym.$accessMode, symName,
         //    varSym.$typeInfo.$nilableTypeInfo, .Var, varSym.$staticFlag, symbolParam ) );
         workSymList.insert( tmpVarSym );
         if node.$mode == .Let and varSym.$scope ~= self.$moduleTypeInfo.$scope {
            self.processDeclVarC( true, varSym, false ## );
         }
      }

      // if! let unwrapBlock = node.$unwrapBlock {
      //    foreach varSym in varSymList {
      //       let tmpVarSym =
      //          unwrap unwrapBlock.$scope.getSymbolInfoChild( "_%s" (varSym.$name) );
      //       workSymList.insert( tmpVarSym );
      //       if node.$mode == .Let and varSym.$scope ~= self.$moduleTypeInfo.$scope {
      //          self.processDeclVarC( true, varSym, false ## );
      //       }
      //    }
      // }

      self.writeln( "{" );
      self.processBlockPreProcess( unwrapScope );
      
      self.processDeclVarAndSet( workSymList, node.$expList );

      if! let unwrapBlock = node.$unwrapBlock {
         self.writeln( "" );
         self.write( "if ( " );
         let mut firstFlag = true;
         foreach var in workSymList {
            if self.scopeMgr.getSymbolValKind( var ) == .Stem {
               if var.$typeInfo.$nilable {
                  if firstFlag {
                     firstFlag = false;
                  }
                  else {
                     self.write( " || " );
                  }
                  self.write( "lns_stem_type_nil == %s.type"
                     ( self.moduleCtrl.getSymbolName( var ) ) );
               }
            }
         }
         self.writeln( " ) {" );

         self.pushIndent(##);
         filter( unwrapBlock, self, node );
         self.popIndent();

         if! let thenBlock = node.$thenBlock {

            self.writeln( "}" );
            self.writeln( "else {" );
            
            self.pushIndent(##);

            foreach var, index in varSymList {
               self.processSetSymSingle(
                  node, nil, var, true, workSymList[ index ], false );
               self.writeln( "" );
            }
            self.popIndent();
            filter( thenBlock, self, node );
            self.writeln( "}" );
         }
         else {
            self.writeln( "}" );
            self.writeln( "else {" );
            self.pushIndent( ## );
            foreach var, index in varSymList {
               self.processSetSymSingle(
                  node, nil, var, true, workSymList[ index ], false );
               self.writeln( "" );
            }
            self.popIndent();
            self.writeln( "}" );
         }
         self.processBlockPostProcess();
         self.writeln( "}" );
      }
   }
   else {
      self.processDeclVarAndSet( varSymList, node.$expList );
   }



   if! node.$syncBlock {
      filter( _exp, self, node);

      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s = %s" (varInfo.$name.txt, varInfo.$name.txt) );
      }
      self.popIndent();
      self.writeln( "}" );

      foreach varInfo in node.$syncVarList {
         self.writeln( "%s = _sync_%s" (varInfo.$name.txt, varInfo.$name.txt) );
      }
      self.popIndent();
      self.writeln( "}" );
   }


   if node.get_accessMode() == .Pub {
      self.writeln( "" );
      foreach var, index in varSymList {
         let name: str = self.moduleCtrl.getSymbolName( var );
         self.pubVarName2InfoMap[ name ] = new PubVarInfo(
            node.$staticFlag, node.$accessMode,
            node.$symbolInfoList[ index ].$mutable, node.$typeInfoList[ index ] );
      }
   }
};


pub override fn convFilter.processWhen(
   node: Nodes.WhenNode, opt: Opt ) mut
{
   self.write( "if ( " );
   foreach symPair, index in node.$symPairList {
      self.processSym2stem( symPair.$src );
      self.write( ".type != lns_stem_type_nil" );
      if index ~= #node.$symPairList {
         self.write( " && " );
      }
   }
   self.writeln( " ) " );
   self.writeln( "{" );

   self.processBlockPreProcess( node.$block.$scope );
   
   foreach symPair in node.$symPairList {
      let srcSymbol = symPair.$src;
      let dstSymbol = symPair.$dst;
      let srcTypeTxt = self.scopeMgr.getCTypeForSym( srcSymbol );
      let dstTypeTxt = self.scopeMgr.getCTypeForSym( dstSymbol );
      if srcTypeTxt ~= dstTypeTxt {
         // self.writeln( "%s %s;" ( dstTypeTxt, getSymbolName( dstSymbol ) ) );
         // self.processSetSymSingle( node, nil, dstSymbol, true, srcSymbol, false );
         // self.writeln( "" );

         self.processDeclVarC( true, dstSymbol, false ## );

         // let workSymbol = new WorkSymbol(
         //    srcSymbol.$scope, srcSymbol.$accessMode, srcSymbol.$name, 
         //    srcSymbol.$typeInfo.$nonnilableType, srcSymbol.$kind,
         //    new SymbolParam( .Stem, 0, cTypeStem ) );
         
         // self.processSetSymSingle(
         //    node, nil, dstSymbol, true, workSymbol, true );
         self.processSetSymSingle(
            node, nil, dstSymbol, true, srcSymbol, false );
         self.writeln( "" );

         
      }
      else {
         self.writeln( "%s %s = %s;"
            ( dstTypeTxt, self.moduleCtrl.getSymbolName( dstSymbol ),
              self.moduleCtrl.getSymbolName( srcSymbol )) );
      }
   }
   
   filter( node.$block, self, node );

   self.processBlockPostProcess();
   

   if! node.$elseBlock {
      self.write( "} else {" );
      filter( _exp, self, node );
   }
   self.writeln( "}" );
}

pub override fn convFilter.processDeclArg(
   node: Nodes.DeclArgNode, opt: Opt ) mut
{
   processDeclAlgeSub( self.stream, node );
   // self.write( getCType( node.$expType ) );
   // if node.$symbolInfo.$hasAccessFromClosure {
   //    // 引数がクロージャで使用されている場合、引数を別名で宣言する。
   //    // 関数の先頭で、クロージャ用の変数を別途宣言する。
   //    self.write( ' _' );
   // }
   // elseif node.$symbolInfo.$mutable {
   //    // 引数が mutable の場合、
   //    // 保持する値が変更される可能性があるため、
   //    // 別途宣言してローカル変数と同じように管理する。
   //    self.write( ' _' );
   // }
   // else {
   //    self.write( ' ' );
   // }
   // self.write( node.get_name().txt );
   
   // //self.write( string.format( "%s %s", cTypeStem, node.get_name().txt ) );

   // // // filter( // node.info.argType,  self, node, baseIndent )
};

pub override fn convFilter.processDeclArgDDD(
   node: Nodes.DeclArgDDDNode, opt: Opt ) mut
{
   self.write( "%s _pDDD" (cTypeStem) );
};

pub override fn convFilter.processExpDDD(
   node: Nodes.ExpDDDNode, opt: Opt ) mut
{
   // self.write( "..." );
};

pub override fn convFilter.processExpSubDDD(
   node: Nodes.ExpSubDDDNode, opt:Opt ) mut
{
   self.write( "lns_createSubDDD( _pEnv, %d, LNS_STEM_ANY( _pEnv->pMRet ) )" (node.$remainIndex ) );
};


fn convFilter.processFuncPrototype(
   parent:Nodes.Node, accessMode:Ast.AccessMode, needFormVal:bool,
   name:str, retType:str, argList:&List<&Nodes.Node>, termFlag:bool ) mut
{
   fn process( out2HMode:Out2HMode ) {
      self.write( string.format( "%s%s %s( %s _pEnv",
                                 getOut2HeaderPrefix( out2HMode ),
                                 retType, name, cTypeEnvP ) );
      if needFormVal {
         self.write( string.format( ", %s _pForm", cTypeAnyP ) );
      }
      
      foreach arg, index in argList {
         self.write( ", " );
         filter( arg, self, parent );
      }
      self.write( " )" );
      if termFlag {
         self.writeln( ";" );
      }
   }

   if termFlag {
      _out2Header(
         self.stream, Ast.isPubToExternal( accessMode ),
         `{
            if out2HMode ~= .SourcePub {
               process( out2HMode );
            }
         } );
   }
   else {
      process( .SourcePub );
   }
}

fn convFilter.processCallUserForm(
   formName:str, formType:&Ast.TypeInfo, argNameList:&List<str> ) mut
{
   fn process( prefix:str ) {
      self.pushIndent( ## );
      self.write( prefix );
      foreach argName, index in argNameList {
         self.write( ", " );
         self.write( argName );
      }
      self.writeln( ");" );
      self.popIndent();
   }
   
   self.writeln( "if lns_isClosure( %s ) {" (formName) );
   switch getCRetType( formType.$retTypeInfoList ) {
      case "void" {
         process( "lns_closure( %s )( _pEnv, %s" (formName, formName));
      }
      case cTypeAny {
         process( "return lns_closure_any( %s )( _pEnv, %s" (formName, formName));
      }
      case cTypeInt {
         process( "return lns_closure_int( %s )( _pEnv, %s" (formName, formName));
      }
      case cTypeReal {
         process( "return lns_closure_real( %s )( _pEnv, %s" (formName, formName));
      }
      case cTypeBool {
         process( "return lns_closure_bool( %s )( _pEnv, %s" (formName, formName));
      }
      default {
         process( "return lns_closure( %s )( _pEnv, %s" (formName, formName));
      }
   }
   self.writeln( "}" );
   self.writeln( "else {" );
   switch getCRetType( formType.$retTypeInfoList ) {
      case "void" {
         process( "lns_func( %s )( _pEnv" (formName));
      }
      case cTypeAnyP {
         process( "return lns_func_any( %s )( _pEnv" (formName));
      }
      case cTypeInt {
         process( "return lns_func_int( %s )( _pEnv" (formName));
      }
      case cTypeReal {
         process( "return lns_func_real( %s )( _pEnv" (formName));
      }
      case cTypeBool {
         process( "return lns_func_bool( %s )( _pEnv" (formName));
      }
      default {
         process( "return lns_func( %s )( _pEnv" (formName));
      }
   }
   self.writeln( "}" );
}

pub override fn convFilter.processDeclForm(
   node: Nodes.DeclFormNode, opt: Opt ) mut
{
   let formType = node.$expType;

   switch self.processMode {
      case .Prototype {
         self.processFuncPrototype(
            node, formType.$accessMode, true,
            self.moduleCtrl.getCallFormName( formType ),
            getCRetType( formType.$retTypeInfoList ), node.$argList, true );
      }
      case .Form {
         self.processFuncPrototype(
            node, formType.$accessMode, true,
            self.moduleCtrl.getCallFormName( formType ),
            getCRetType( formType.$retTypeInfoList ), node.$argList, false );


         
         
         self.writeln( "{" );
         self.pushIndent( ## );

         
         let mut argNameList:List<str> = [];
         foreach arg, index in node.$argList {
            if! let workArg = arg@@@Nodes.DeclArgNode {
               argNameList.insert( workArg.$name.txt );
            }
            else {
               if! let workArg = arg@@@Nodes.DeclArgDDDNode {
                  argNameList.insert( "_pDDD" );
               }
            }
         }
         self.processCallUserForm( "_pForm", formType, argNameList );

         // fn process( prefix:str ) {
         //    self.pushIndent( ## );
         //    self.write( prefix );
         //    foreach arg, index in node.$argList {
         //       self.write( ", " );
         //       if! let workArg = arg@@@Nodes.DeclArgNode {
         //          self.write( workArg.$name.txt );
         //       }
         //       else {
         //          if! let workArg = arg@@@Nodes.DeclArgDDDNode {
         //             self.write( "_pDDD" );
         //          }
         //       }
         //    }
         //    self.writeln( ");" );
         //    self.popIndent();
         // }
         // self.writeln( "if lns_isClosure( _pForm ) {" );
         // switch getCRetType( formType.$retTypeInfoList ) {
         //    case "void" {
         //       process( "lns_closure( _pForm )( _pEnv, _pForm");
         //    }
         //    case cTypeAny {
         //       process( "return lns_closure_any( _pForm )( _pEnv, _pForm" );
         //    }
         //    case cTypeInt {
         //       process( "return lns_closure_int( _pForm )( _pEnv, _pForm" );
         //    }
         //    case cTypeReal {
         //       process( "return lns_closure_real( _pForm )( _pEnv, _pForm" );
         //    }
         //    case cTypeBool {
         //       process( "return lns_closure_bool( _pForm )( _pEnv, _pForm" );
         //    }
         //    default {
         //       process( "return lns_closure( _pForm )( _pEnv, _pForm" );
         //    }
         // }
         // self.writeln( "}" );
         // self.writeln( "else {" );
         // switch getCRetType( formType.$retTypeInfoList ) {
         //    case "void" {
         //       process( "lns_func( _pForm )( _pEnv" );
         //    }
         //    case cTypeAnyP {
         //       process( "return lns_func_any( _pForm )( _pEnv" );
         //    }
         //    case cTypeInt {
         //       process( "return lns_func_int( _pForm )( _pEnv" );
         //    }
         //    case cTypeReal {
         //       process( "return lns_func_real( _pForm )( _pEnv" );
         //    }
         //    case cTypeBool {
         //       process( "return lns_func_bool( _pForm )( _pEnv" );
         //    }
         //    default {
         //       process( "return lns_func( _pForm )( _pEnv" );
         //    }
         // }
         // self.writeln( "}" );

         
         self.popIndent();
         self.writeln( "}" );
      }
   }
}

/**
他の関数からクロージャでアクセスされる関数を、クロージャ用変数にセットする。
*/
fn convFilter.processClosureFunc(declInfo:&Nodes.DeclFuncInfo) mut {
   let! simpleName = declInfo.$name {
      return;
   };
   let! scope = declInfo.$body$.$scope {
      return;
   };
   let! funcSym = scope.getSymbolInfo( simpleName.txt, scope, false, .Normal ) {
      return;
   };
   if not funcSym.$hasAccessFromClosure {
      return;
   }

   let symbolParam = self.scopeMgr.getSymbolParam(funcSym );
   let symbolName = self.moduleCtrl.getSymbolName( funcSym );
   self.writeln( "%s %s;" (cTypeVarP, symbolName ) );
   self.write( "lns_initVal_var( %s, %s, %d, "
               ( symbolName, getBlockName( scope.$parent ), symbolParam.index ) );
   self.writeln( "LNS_STEM_ANY( %s ) );"
                 ( getFunc2any( self.moduleCtrl, self.scopeMgr, funcSym.$typeInfo  ) ) );
}

pub override fn convFilter.processDeclFunc(
   node: Nodes.DeclFuncNode, opt: Opt ) mut
{
   let declInfo = node.$declInfo;
   let name = self.moduleCtrl.getFuncName( node.$expType );
   
   fn processFuncPrototype( termFlag:bool ) {
      self.processFuncPrototype(
         node, declInfo.$accessMode, isClosure( node.$expType ),
         name, getCRetType( node.$expType.$retTypeInfoList ),
         declInfo.$argList, termFlag );
   }

   switch self.processMode {
      case .Form {
      }
      case .Prototype {
         processFuncPrototype( true );
         return;
      }
      case .InitFuncSym, .WideScopeVer {
         self.process__func__symbol(
            node.$expType, declInfo.$has__func__Symbol,
            self.moduleCtrl.getFuncName( node.$expType ) );
         return;
      }
      default {
         switch opt.node.$kind {
            case Nodes.NodeKind.$Block, Nodes.NodeKind.$ExpMacroExp {
            }
            default {
               self.write( getFunc2any( self.moduleCtrl, self.scopeMgr, node.$expType ) );
            }
         }
         // else {
         //    if! let rawName = node.$declInfo.$name {
         //       let scope = (unwrap node.$expType.$scope).$parent;
         //       let symbolInfo = unwrap scope.getSymbolInfoChild( rawName.txt );

         //       let formTxt = self.getFunc2any( node.$expType );
         //       self.processDeclVarC( true, symbolInfo, formTxt );
         //    }
         // }
         return;
      }
   }
   if self.duringDeclFunc {
      if opt.node.$kind == Nodes.NodeKind.$Block {
         self.processClosureFunc( declInfo );
         
         return;
      }
      self.write( self.moduleCtrl.getFuncName( node.$expType ) );
      return;
   }

   let! body = declInfo.$body {
      return;
   };
   
   self.duringDeclFunc = true;
   
   processFuncPrototype( false );
   self.writeln( "" );
   self.writeln( "{" );

   self.pushRoutine( node.$expType, body );
   
   self.processArgClosure( declInfo );

   let mut breakKind = Nodes.BreakKind.None;

   filter( body,  self, node );

   self.popRoutine();

   breakKind = body.getBreakKind( .Normal );

   switch breakKind {
      case .Return, .NeverRet {
         // body 終了位置は処理されない
      }
      default {
         //self.writeln( "return _pEnv->pNoneStem;" );
      }
   }

   self.writeln( "}" );

   //if declInfo.get_accessMode() == .Pub {
   let expType: Ast.TypeInfo = node.get_expType();
   if expType.get_accessMode() == .Pub {
      self.pubFuncName2InfoMap[ name ] = new PubFuncInfo(
         declInfo.get_accessMode(), node.get_expType() );
   }
};

pub override fn convFilter.processRefType(
   node: Nodes.RefTypeNode, opt: Opt ) mut
{
   // self.write( (node.get_refFlag() and "&" or "") ..
   //             (node.get_mutFlag() and "mut " or "") );
   // filter( node.get_name(),  self, node );
   // if node.get_array() == "array" {
   //    self.write( "[@]" );
   // }
   // elseif node.get_array() == "list" {
   //    self.write( "[]" );
   // }
};

pub override fn convFilter.processIf(
   node: Nodes.IfNode, opt: Opt ) mut
{
   let valList = node.get_stmtList();
   foreach val, index in valList {
      if index == 1 {
         self.write( "if ( lns_isCondTrue( " );
         self.processVal2stem( val.$exp, node );
         self.write( ") )" );
      }
      elseif val.$kind == .ElseIf {
         self.write( "else if ( lns_isCondTrue( " );
         self.processVal2stem( val.$exp, node );
         self.write( ") )" );
      }
      else {
         self.writeln( "else {" );
      }
      self.write( " " );
      filter( val.$block, self, node );
      self.write( "}" );
   }
};


form ProcessToValForm( kind:ValKind );

fn convFilter.processEquals(
   eqFlag:bool, type1:&Ast.TypeInfo, type2:&Ast.TypeInfo,
   process1:ProcessToValForm, process2:ProcessToValForm )
{
   let valKind1 = getValKind( type1 );
   let valKind2 = getValKind( type2 );
   if valKind1 == .Stem or valKind2 == .Stem {
      if not eqFlag {
         self.write( "!" );
      }
      self.write( "lns_equals( " );
      process1( .Stem );
      self.write( "," );
      process2( .Stem );
      self.write( ")" );
   }
   elseif valKind1 == .Any and valKind2 == .Any {
      if not eqFlag {
         self.write( "!" );
      }
      self.write( "lns_equals_any( " );
      process1( .Any );
      self.write( "," );
      process2( .Any );
      self.write( ")" );
   }
   elseif valKind1 == .Prim and valKind2 == .Prim {
      process1( .Prim );

      if eqFlag {
         self.write( " == " );
      }
      else {
         self.write( " != " );
      }
      process2( .Prim );
   }
   else {
      Util.err( "illegal kind %s -- %s" (valKind1.$_txt, valKind2.$_txt) );
   }
}


pub override fn convFilter.processSwitch(
   node: Nodes.SwitchNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent( ## );

   let expType = node.$exp.$expType;
   let expSymName = "_switchExp%d" (node.$id);
   self.write( "%s %s = " (getCType( expType ), expSymName ) );
   filter( node.$exp, self, node );
   self.writeln( ";" );

   let expValKind = self.getValKindOfNode( node.$exp );

   let expStemName;
   if expValKind ~= .Stem {
      expStemName = expSymName .. "Stem";
      self.write( "%s %s = " (cTypeStem, expStemName) );

      process2stem(
         self.stream, self.moduleCtrl, self.scopeMgr,
         expValKind, expType, node,
         fn () {
            self.write( expSymName );
         } );

      self.writeln( ";" );
   }
   else {
      expStemName = expSymName;
   }
   
   foreach caseInfo, index in node.$caseList {
      if index == 1 {
         self.write( "if ( " );
      }
      else {
         self.writeln( "}" );
         self.write( "else if ( " );
      }
      let expList = caseInfo.$expList;
      foreach expNode, listIndex in expList.$expList {
         if listIndex ~= 1 {
            self.write( " || " );
         }


         self.processEquals(
            true, expType, expNode.$expType,
            fn ( valKind:ValKind ) {
               if valKind == .Stem {
                  self.write( expStemName );
               }
               else {
                  self.write( expSymName );
               }
            },
            fn ( valKind:ValKind ) {
               switch valKind {
                  case .Stem {       
                     self.processVal2stem( expNode, node );
                  }
                  case .Any {
                     self.processVal2any( expNode, node );
                  }
                  case .Prim {
                     self.accessPrimVal( expNode, node );
                  }
               }
            } );
      }
      self.writeln( " ) {" );
      filter( caseInfo.$block, self, node );
   }
   if! node.$default {
      self.writeln( "}" );
      self.writeln( "else {" );
      filter( _exp, self, node );
   }

   self.writeln( "}" );

   self.popIndent();
   self.writeln( "}" );
};


pub override fn convFilter.processMatch(
   node: Nodes.MatchNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent( ## );
   self.write( "%s _matchExp = " (cTypeAnyP) );
   filter( node.$val,  self, node );
   self.write( accessAny );
   self.writeln( ";" );

   self.writeln( "switch( _matchExp->val.alge.type ) {" );
   let algeType = node.$algeTypeInfo;
   let enumName = self.moduleCtrl.getAlgeEnumCName( algeType );
   foreach caseInfo, index in node.$caseList {
      let valInfo = caseInfo.$valInfo;
      self.writeln( "case %s_%s:" (enumName, valInfo.$name ) );
      self.pushIndent(##);
      self.writeln( "{" );
      self.pushIndent(##);
      if #valInfo.$typeList > 0 {
         // パラメータの代入
         let structTxt = self.moduleCtrl.getAlgeValStrCName( algeType, valInfo.$name );
         self.writeln( "%s * _pVal = (%s *)_matchExp->val.alge.pVal;"
                       (structTxt, structTxt) );
         foreach paramType, paramIndex in valInfo.$typeList {
            let paramName = caseInfo.$valParamNameList[ paramIndex ];
            self.writeln(
               "%s %s = _pVal->_val%d;"
               (getCType( paramType ), paramName, paramIndex )); 
         }
      }
      self.popIndent();

      filter( caseInfo.$block, self, node );

      self.writeln( "}" );
      self.writeln( "break;" );
      self.popIndent();
   }
   self.writeln( "}" );
   self.popIndent();

   self.writeln( "}" );
   
   // self.writeln( "do" );
   // self.pushIndent(##);
   // self.write( "local _matchExp = " );
   // filter( node.$val,  self, node );
   // self.writeln( "" );

   // let fullName = self.getFullName( node.$algeTypeInfo );
   // foreach caseInfo, index in node.$caseList {
   //    if index == 1 {
   //       self.write( "if " );
   //    }
   //    else {
   //       self.write( "elseif " );
   //    }
   //    self.writeln( "_matchExp[1] == %s.%s[1] then"
   //                  (fullName, caseInfo.$valInfo.$name ) );
   //    foreach paramName, paramNum in caseInfo.$valParamNameList {
   //       self.writeln( "   local %s = _matchExp[2][%d]" (paramName, paramNum ) );
   //    }
   //    filter( caseInfo.$block, self, node );
   // }
   // if! node.$defaultBlock {
   //    self.writeln( "else " );
   //    filter( _exp, self, node );
   // }
   // self.writeln( "end" );
   // self.popIndent();

   // self.writeln( "end" );
};


pub override fn convFilter.processWhile(
   node: Nodes.WhileNode, opt: Opt ) mut
{
   self.processLoopPreProcess( node.$block );

   self.write( "while ( " );

   if node.$exp.$expType.$srcTypeInfo == Ast.builtinTypeBool {
      filter( node.$exp, self, node );
   }
   else {
      self.write( "lns_isCondTrue( " );
      self.processVal2stem( node.$exp, node );
      self.write( ")" );
   }
   self.writeln( " )" );

   self.writeln( "{" );
   self.pushIndent( ## );
   self.writeln( "lns_reset_block( _pEnv );" );
   
   filter( node.$block, self, node );

   self.popIndent();
   self.writeln( "}" );
   self.processLoopPostProcess();
};

pub override fn convFilter.processRepeat(
   node: Nodes.RepeatNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.processLoopPreProcess( node.$block );

   self.writeln( "while ( true ) {" );
   self.pushIndent( ## );
   self.writeln( "lns_reset_block( _pEnv );" );
   
   
   filter( node.get_block(),  self, node );

   self.write( "if ( " );
   if node.get_exp().$expType.$srcTypeInfo == Ast.builtinTypeBool {
      filter( node.get_exp(),  self, node );
   }
   else {
      self.write( "lns_isCondTrue(" );
      self.processVal2stem( node.$exp, node );
      self.write( ")" );
   }
   self.writeln( ") { break; }" );

   
   self.popIndent();
   self.writeln( "}" );
   self.processLoopPostProcess();
   self.writeln( "}" );
};

pub override fn convFilter.processFor(
   node: Nodes.ForNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   self.writeln( "%s _to;" (cTypeInt ) );
   self.writeln( "%s _inc;" (cTypeInt ) );
   self.writeln( "%s %s;" (cTypeInt, self.moduleCtrl.getSymbolName( node.$val ) ) );

   // node.get_block().$scope.

   //self.processSetValToSym( node, [ node.$val ], true, [ node.$to ] ## );
   self.processSetValSingle( node, nil, node.$val, true, node.$to, 0, false );
   self.writeln( "" );
   self.writeln( "_to = %s;" ( self.moduleCtrl.getSymbolName( node.$val )) );
   if! node.get_delta() {
      self.processSetValToSym( node, [ node.$val ], true, [ _exp ] ## );
      self.writeln( "_inc = %s;" ( self.moduleCtrl.getSymbolName( node.$val )) );
   }
   else {
      self.writeln( "_inc = 1;" );
   }
   self.processSetValToSym( node, [ node.$val ], true, [ node.$init ] ## );
   self.writeln( "" );

   self.processLoopPreProcess( node.$block );

   let indexSym = self.moduleCtrl.getSymbolName( node.$val );
   self.writeln( "for (; ; %s += _inc ) {" ( indexSym) );
   self.pushIndent(##);
   self.writeln(
      "if ( ( _inc >= 0 && %s > _to ) || ( _inc < 0 && %s < _to ) ) { break; }"
      (indexSym, indexSym) );
   self.writeln( "lns_reset_block( _pEnv );" );
   filter( node.$block,  self, node );
   self.popIndent();
   self.writeln( "}" );

   self.processLoopPostProcess();

   self.popIndent();
   self.writeln( "}" );
};

fn convFilter.processCreateDDD(
   parent:&Nodes.Node, expList:&List<&Nodes.Node> ) mut
{
   self.write( "lns_createDDD" );
   let lastExp = expList[ #expList ];
   self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );

   foreach exp in expList {
      self.write( ", " );
      self.processVal2stem( exp, parent );
   }
   self.write( ")" );
}

pub override fn convFilter.processApply(
   node: Nodes.ApplyNode, opt: Opt ) mut
{
   self.writeln( "{" );
   let varList = node.$varList;

   let scope = node.$block.$scope;

   let iteExpTypeList = node.$expList.$expTypeList;
   let iteFuncType = iteExpTypeList[ 1 ];

   let dummyId = varList[1].$symbolId;

   let mut dummyScope = new Ast.Scope( self.moduleTypeInfo.$scope , false## );
   
   let formSym = unwrap dummyScope.addLocalVar(
      false, false, "_form%d" (dummyId), node.$pos, iteFuncType, .IMut);
   let paramSym = unwrap dummyScope.addLocalVar(
      false, false, "_param%d" (dummyId), node.$pos, iteExpTypeList[ 2 ], .IMut);
   let stateSym = unwrap dummyScope.addLocalVar(
      false, false, "_state%d" (dummyId), node.$pos, iteExpTypeList[ 3 ], .IMut);
   self.scopeMgr.setupScopeParam( dummyScope );

   self.processBlockPreProcess( dummyScope );
   let mut symList:List<&Ast.LowSymbol> = [];
   symList.insert( formSym );
   symList.insert( paramSym );
   symList.insert( stateSym );
   self.processDeclVarAndSet( symList, node.$expList );

   self.writeln( "{" );
   self.processLoopPreProcess( node.$block );

   self.writeln( "while ( true ) {" );
   self.pushIndent(##);
   self.writeln( "lns_reset_block( _pEnv );" );

   foreach varSym in node.$varList {
      self.processDeclVarC( true, varSym, false ## );
   }

   // イテレータ関数を実行し、開放されないように一旦 work にセットする
   let workSymName = "_workMret%d" (dummyId);
   self.write( "%s %s = " (cTypeAnyP, workSymName) );

   if formSym.$typeInfo.$kind == .Ext {
      self.write( "lns_lua_callForm( _pEnv, *%s, "
                  ( self.moduleCtrl.getSymbolName( formSym ) ) );
      self.write( "" );
      let mut expList:List<&Nodes.Node> = [];
      expList.insert( self.createRefNodeFromSym( paramSym ) );
      expList.insert( self.createRefNodeFromSym( stateSym ) );
      self.processCreateDDD( node, expList );
      self.writeln( ")%s;" (accessAny) );
   }
   else {
      self.write( "lns_func( *%s )( _pEnv, "
                  ( self.moduleCtrl.getSymbolName( formSym ) ) );
      if self.scopeMgr.getSymbolValKind( paramSym ) == .Any {
         self.write ( "*" );
      }
      self.writeln( "%s, %s)%s;"
         ( self.moduleCtrl.getSymbolName( paramSym ),
           self.moduleCtrl.getSymbolName( stateSym ), accessAny ) );
   }
   
   self.writeln(
      "if ( lns_fromDDD( %s, 0 ).type == lns_stem_type_nil ) {" (workSymName) );
   self.writeln( "   break;" );
   self.writeln( "}" );

   // work から各変数にセットする
   let mut nodeManager = self.dummyNodeManager;
   foreach varSym, index in node.$varList {
      let valKind = self.scopeMgr.getSymbolValKind( varSym );
      let varName = self.moduleCtrl.getSymbolName( varSym );
      switch valKind {
         case .Stem {
            self.writeln(
               'lns_setq( _pEnv, %s, lns_fromDDD( %s, %d ) );'
               (varName, workSymName, index - 1 ) );
         }
         case .Any {
            self.writeln(
               'lns_setq_any( _pEnv, %s, lns_fromDDD( %s, %d )%s );'
               (varName, workSymName, index - 1, accessAny ) );
         }
         case .Prim {
            self.writeln( "%s = lns_fromDDD( %s, %d )%s"
                          ( varName, workSymName, index - 1, 
                            getAccessValFromStem( varSym.$typeInfo ) ) );
         }
         default {
            Util.err( "no support -- %s:%s:%d"
               (varSym.$name,valKind.$_txt,__line__));
         }
      }
   }


   filter( node.$block, self, node );

   self.processSetSymSingle(
      node, nil, stateSym, false, node.$varList[1], false );
   self.writeln( "" );
   
   // self.write( "lns_setq( _pEnv, %s, " (stateSym.$name ) );
   // self.processSym2stem( node.$varList[1] );
   // self.writeln( ");" );
   
   self.popIndent();
   self.writeln( "}" );


   self.processLoopPostProcess();


   self.writeln( "}" );
   self.processBlockPostProcess();
   
   
   self.writeln( "}" );
   
   
   // self.write( "for " );
   // let varList = node.get_varList();
   // foreach var, index in varList {
   //    if index > 1 {
   //       self.write( ", " );
   //    }
   //    self.write( var.txt );
   // }
   // self.write( " in " );
   // filter( node.$exp,  self, node );
   // self.write( " " );
   // filter( node.$block,  self, node );
   // self.writeln( "end" );
};

fn convFilter.processForeachSetupVal(
   parent:&Nodes.Node, scope:&Ast.Scope,
   workTxt:str, symTxt:str, symType:&Ast.TypeInfo ) mut
{
   let! symbolInfo = scope.getSymbolInfoChild( symTxt ) {
      Util.err( "not found symTxt -- %s" (symTxt)  );
   };

   self.processDeclVarC( true, symbolInfo, false ##);

   let srcSymbol = new WorkSymbol(
      symbolInfo.$scope, symbolInfo.$accessMode, workTxt,
      symbolInfo.$typeInfo, symbolInfo.$kind, symbolInfo.$staticFlag,
      new SymbolParam( .Stem, 0, cTypeStem ) );

   self.processSetSymSingle(
      parent, nil, symbolInfo, true, srcSymbol, true );
      
   // self.processSetValSingleDirect(
   //    parent, nil, symbolInfo, true, true, 0, false,
   //    fn () {
   //       processToIF(
   //          self.stream, self.moduleCtrl, symType,
   //          fn () {
   //             self.write( "(&%s)" (workTxt) );
   //             self.write( getAccessValFromStem( symType ) );
   //          } );
   //    } );
}

fn convFilter.processPoolForeachSetupVal(
   parent:&Nodes.Node, loopType:&Ast.TypeInfo, scope:&Ast.Scope,
   keyToken:&Parser.Token!, valToken:&Parser.Token! ) mut
{
  
   let valType = loopType.$itemTypeInfoList[ 1 ];
   let valSymTxt;
   if loopType.$kind == .Set {
      if! keyToken {
         valSymTxt = _exp.txt;
      }
      else {   
         //valSymTxt = "__val";
         Util.err( "keyToken is nil" );
      }
   }
   else {
      if! valToken {
         valSymTxt = _exp.txt;
      }
      else {   
         //valSymTxt = "__val";
         Util.err( "valToken is nil" );
      }
   }

   self.processForeachSetupVal( parent, scope, "_val", valSymTxt, valType );
}

fn convFilter.processMapForeachSetupVal(
   parent:&Nodes.Node, loopType:&Ast.TypeInfo, scope:&Ast.Scope,
   keyToken:&Parser.Token!, valToken:&Parser.Token!, keyTxt:str, valTxt:str ) mut
{
   when! keyToken {
      self.processForeachSetupVal( parent, scope, keyTxt, keyToken.txt,
                                   loopType.$itemTypeInfoList[ 1 ] );
   }
   self.writeln( "" );
   when! valToken {
      self.processForeachSetupVal( parent, scope, valTxt, valToken.txt,
                                   loopType.$itemTypeInfoList[ 2 ] );
   }
}

alge CollectionKind {
   List,
   Array,
   Set,
   Map,
   ExtList(extedType:&Ast.TypeInfo),
   ExtArray(extedType:&Ast.TypeInfo),
   ExtSet(extedType:&Ast.TypeInfo),
   ExtMap(extedType:&Ast.TypeInfo),
}

fn getCollectionKind( typeInfo:&Ast.TypeInfo ) : CollectionKind {
   switch typeInfo.$kind {
      case .List {
         return .List;
      }
      case .Array {
         return .Array;
      }
      case .Set {
         return .Set;
      }
      case .Map {
         return .Map;
      }
      case .Ext {
         let extType = unwrap typeInfo.$srcTypeInfo@@@Ast.ExtTypeInfo;
         let extedType = extType.$extedType;
         switch extedType.$kind {
            case .List {
               return .ExtList( extedType );
            }
            case .Array {
               return .ExtArray( extedType );
            }
            case .Set {
               return .ExtSet( extedType );
            }
            case .Map {
               return .ExtMap( extedType );
            }
         }
      }
   }
   Util.err( "unknown collection type -- %s" ( typeInfo.getTxt(##) ) );
}

pub override fn convFilter.processForeach(
   node: Nodes.ForeachNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   
   self.write( "%s _obj = " ( cTypeAnyP ) );
   self.processVal2any( node.$exp, node );
   //self.write( accessAny );
   self.writeln( ";" );

   let indexSymbol:&Ast.SymbolInfo!;
   let loopType = node.$exp.$expType;

   let collectionKind = getCollectionKind( loopType );
   
   switch loopType.$kind {
      case .List, .Array {
         self.writeln( "%s _itAny = lns_itList_new( _pEnv, _obj );" (cTypeAnyP) );
         if! let keyToken = node.$key {
            let! workSymbol = node.$block.$scope.getSymbolInfoChild( keyToken.txt ) {
               Util.err( "not found symbol -- %s" ( keyToken.txt ) );
            };
            indexSymbol = workSymbol;
            
            //self.writeln( "int %s = 0;" (keyToken.txt) );
            if self.scopeMgr.getSymbolValKind( workSymbol ) ~= .Prim {
               self.writeln( "int _%s = 0;" (keyToken.txt) );
            }
            else {
               self.processDeclVarC( true, workSymbol, true ## );
            }
         }
         else {
            indexSymbol = nil;
         }
         self.writeln( "%s _val;" ( cTypeStem ) );
      }
      case .Set {
         self.writeln( "%s _itAny = lns_itSet_new( _pEnv, _obj );" (cTypeAnyP) );
         indexSymbol = nil;
         self.writeln( "%s _val;" ( cTypeStem ) );
      }
      case .Map {
         self.writeln( "%s _itAny = lns_itMap_new( _pEnv, _obj );" (cTypeAnyP) );
         indexSymbol = nil;
         self.writeln( "lns_Map_entry_t _entry;" );
      }
      case .Ext {
         indexSymbol = nil;
         match collectionKind {
            case .ExtMap( extedType ) {
               self.writeln(
                  "%s _itAny = lns_lua_itMap_new( _pEnv, _obj );" (cTypeAnyP) );
               self.writeln( "lns_Map_entry_t _entry;" );
            }
         }
      }
      default {
         Util.err( "illegal kind -- %s" (loopType.$kind.$_txt ) );
      }
   }

   self.processLoopPreProcess( node.$block );

   switch loopType.$kind {
      case .List, .Array {
         //self.writeln( "for ( ; lns_reset_block( _pEnv ), lns_itList_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "for ( ; lns_itList_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "      lns_itList_inc( _pEnv, _itAny ) )" );
      }
      case .Set {
         //self.writeln( "for ( ; lns_reset_block( _pEnv ), lns_itSet_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "for ( ; lns_itSet_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "      lns_itSet_inc( _pEnv, _itAny ) )" );
      }
      case .Map {
         //self.writeln( "for ( ; lns_reset_block( _pEnv ), lns_itMap_hasNext( _pEnv, _itAny, &_entry );" );
         self.writeln( "for ( ; lns_itMap_hasNext( _pEnv, _itAny, &_entry );" );
         self.writeln( "      lns_itMap_inc( _pEnv, _itAny ) )" );
      }
      case .Ext {
         match collectionKind {
            case .ExtMap( extedType ) {
               self.writeln(
                  "while ( lns_lua_itMap_hasNext( _pEnv, _itAny ) )" );
            }
         }
      }
   }
   self.writeln( "{" );
   self.pushIndent(##);
   self.writeln( "lns_reset_block( _pEnv );" );
   
   when! indexSymbol {
      if self.scopeMgr.getSymbolValKind( indexSymbol ) ~= .Prim {
         self.writeln( "_%s++;" ( self.moduleCtrl.getSymbolName( indexSymbol ) ) );
         self.processDeclVarC( true, indexSymbol, true ##);
         self.processSetValSingleDirect(
            node, nil, indexSymbol, true, .Prim, Ast.builtinTypeInt, 0, false,
            fn () {
               self.write( "_%s" ( self.moduleCtrl.getSymbolName( indexSymbol ) ) );
            });
         self.writeln( "" );
      }
      else {
         self.writeln( "%s++;" ( self.moduleCtrl.getSymbolName( indexSymbol ) ) );
      }
   }

   switch loopType.$kind {
      case .List, .Set, .Array {
         self.processPoolForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val );
      }
      case .Map {
         self.processMapForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val,
            "_entry.key", "_entry.val" );
      }
      default {
         match collectionKind {
            case .ExtMap( extedType ) {
               self.writeln( "lns_lua_itMap_getEntry( _pEnv, _itAny, &_entry );" );
               self.processMapForeachSetupVal(
                  node, extedType, node.$block.$scope, node.$key, node.$val,
                  "_entry.key", "_entry.val" );
            }
         }
      }
   }
   
   filter( node.$block, self, node );

   self.popIndent();
   self.writeln( "}" );

   self.processLoopPostProcess();
   self.popIndent();
   self.writeln( "}" );
};

pub override fn convFilter.processForsort(
   node: Nodes.ForsortNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   
   self.write( "%s _obj = " ( cTypeAnyP ) );
   self.processVal2any( node.$exp, node );
   self.writeln( ";" );

   let loopType = node.$exp.$expType;
   switch loopType.$kind {
      case .Set {
         self.writeln(
            "%s _pList = lns_mtd_Map_createKeyList( _pEnv, _obj );" (cTypeAnyP) );
         self.writeln(
            "lns_mtd_List( _pList )->sort( _pEnv, _pList, %s );" (cValNil) );
         self.writeln( "%s _itAny = lns_itList_new( _pEnv, _pList );" (cTypeAnyP) );
         self.writeln( "%s _val;" ( cTypeStem ) );
      }
      case .Map {
         self.writeln(
            "%s _pKeyList = lns_mtd_Map_createKeyList( _pEnv, _obj );" (cTypeAnyP) );
         self.writeln(
            "lns_mtd_List( _pKeyList )->sort( _pEnv, _pKeyList, %s );" (cValNil) );
         self.writeln( "%s _itAny = lns_itList_new( _pEnv, _pKeyList );" (cTypeAnyP) );
         self.writeln( "%s _key;" ( cTypeStem ) );
      }
      default {
         Util.err( "illegal kind -- %s" (loopType.$kind.$_txt ) );
      }
   }

   self.processLoopPreProcess( node.$block );

   switch loopType.$kind {
      case .Set {
         self.writeln( "for ( ; lns_itList_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "      lns_itList_inc( _pEnv, _itAny ) )" );
      }
      case .Map {
         self.writeln( "for ( ; lns_itList_hasNext( _pEnv, _itAny, &_key );" );
         self.writeln( "      lns_itList_inc( _pEnv, _itAny ) )" );
      }
   }
   self.writeln( "{" );

   self.writeln( "lns_reset_block( _pEnv );" );
   
   switch loopType.$kind {
      case .Set {
         self.processPoolForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val );
      }
      case .Map {
         self.processMapForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val,
            "_key", "lns_mtd_Map_get( _pEnv, _obj, _key )" );
         
      }
      default {
      }
   }
   
   filter( node.$block, self, node );
   self.writeln( "}" );

   self.processLoopPostProcess();
   self.writeln( "}" );
   self.popIndent();
};


pub override fn convFilter.processExpUnwrap(
   node: Nodes.ExpUnwrapNode, opt: Opt ) mut
{
   fn processUnwrap( typeTxt:str ) {
      if! let defVal = node.$default {
         self.write( "lns_unwrap_%sDefault( " (typeTxt) );
         self.processVal2stem( node.$exp, node );
         self.write( "," );
         self.accessPrimVal( defVal, node );
         self.write( ")" );
      }
      else {
         self.write( "lns_unwrap_%s( " (typeTxt) );
         self.processVal2stem( node.$exp, node );
         self.write( ")" );
      }
   }

   
   
   switch getOrgTypeInfo( node.$expType ) {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         processUnwrap( "int" );
      }
      case Ast.builtinTypeReal {
         processUnwrap( "real" );
      }
      case Ast.builtinTypeBool {
         processUnwrap( "bool" );
      }
      default {
         switch self.getValKindOfNode( node ) {
            case .Stem {
               self.write( "lns_unwrap_stem( " );
            }
            case .Any {
               self.write( "lns_unwrap_any( " );
            }
            default {
               Util.err( "no support -- %s: %d"
                         (self.getValKindOfNode( node ).$_txt, __line__)  );
            }
         }
         
         self.processVal2stem( node.$exp, node );
         if! let defVal = node.$default {
            self.write( "," );
            self.processVal2stem( defVal, node );
            self.write( ")" );
         }
         else {
            self.write( ", %s )" ( cValNone ) );
         }
      }
   }
   
   // if! node.$default {
   //    self.write( '_lune.unwrapDefault( ' );
   //    filter( node.$exp, self, node );
   //    self.write( ', ' );
   //    filter( _exp, self, node );
   //    self.write( ')');
   // }
   // else {
   //    self.write( '_lune.unwrap( ' );
   //    filter( node.$exp, self, node );
   //    self.write( ')');
   // }
}


fn convFilter.processCreateMRet(
   retTypeList:&List<&Ast.TypeInfo>, expList:&List<&Nodes.Node>, parent:&Nodes.Node ) mut
{
   if expList[ 1 ].$expType.$kind == .DDD and #expList == 1 {
      self.write( "_pDDD" );
      return;
   }
   
   self.write( "lns_createMRet" );

   let lastExp = expList[ #expList ];
   self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );
   
   foreach exp, expIndex in expList {
      self.write( ", " );
      self.processVal2stem( exp, parent );
   }
   self.write( ")" );
}


/**
関数コールの引数に、多値返却の関数をコールしている場合、
その関数コールをラッパーで処理する必要があるかどうか調べる。

以下の場合、 func( sub()**) はラッパーが必要。

fn sub() : int, int {
  return 1,2;
}
fn func( val1:int, val2:int ) {
}
func( sub()** );

@param funcArgTypeList 呼び出す関数の仮引数の型リスト
@param argTypeList 実引数の型リスト。
    argTypeList の最後に多値があることを前提とする。
*/
fn needMRetWrap( funcArgTypeList:&List<&Ast.TypeInfo>,
                 argNodeList:&Nodes.ExpListNode ):bool
{
   let! mRetExp = argNodeList.$mRetExp {
      return false;
   };
   let argTypeList = argNodeList.$expTypeList;
   foreach funcArgType, index in funcArgTypeList {
      let argType = argTypeList[ index ];
      if funcArgType.$kind == .DDD {
         // 呼び出し先が ... で、引数が ... でない場合は wrapper が必要
         return argType.$kind ~= .DDD;
      }
      if argType.$kind == .DDD or mRetExp.$index == index {
         // 呼び出し先が ... でなく、次のいずれかの場合は wrapper が必要
         // - 引数が ... の場合
         // - 引数が多値の場合
         return true;
      }
      if mRetExp.$index == index {
         return true;
      }
   }
   return true;
}


alge MRetInfo {
   /** デフォルト form */
   Form,
   /** 独自で定義した form */
   FormFunc( funcType:&Ast.TypeInfo ),
   Method( methodType:&Ast.TypeInfo),
   Func( refNode:&Nodes.Node ),
   /** 多値返却を含む値から ... を生成する */
   DDD( expList:&Nodes.ExpListNode ),
   /** string.format の引数処理 */
   Format( format:str, expList:&Nodes.ExpListNode ),
}

/**
関数コールの引数に、多値返却の関数をコールしている場合の処理。


別関数を定義し、その関数内で引数の設定と関数コールを行なう。
*/
pub fn convFilter.processCallWithMRet(
   parent:&Nodes.Node, mRetFuncName:str, retTypeName:str,
   mRetInfo:MRetInfo, argList:&Nodes.ExpListNode ) mut
{
   let! mRetExp = argList.$mRetExp {
      return;
   };

   match mRetInfo {
      case .Method( funcType ) {
         if not needMRetWrap( funcType.$argTypeInfoList, argList ) {
            return;
         }
      }
      case .Form {
         if not needMRetWrap( [ Ast.builtinTypeDDD ], argList ) {
            return;
         }
      }
      case .FormFunc( funcType ) {
         if not needMRetWrap( funcType.$argTypeInfoList, argList ) {
            return;
         }
      }
      case .Func(funcNode) {
         if not needMRetWrap( funcNode.$expType.$argTypeInfoList, argList ) {
            return;
         }
      }
      case .DDD(node) {
      }
      case .Format(format,node) {
      }
   }
   
   fn processDeclMRetProto() {
      self.write( "static %s %s( %s _pEnv"
         ( retTypeName, mRetFuncName, cTypeEnvP ) );
      
      fn processArgs() {
         foreach argNode, index in argList.$expList {
            if index >= mRetExp.$index {
               break;
            }
            let argType = argNode.$expType;
            self.write( ", %s arg%d" ( getCType( argType ), index ) );
         }
         self.write( ", %s pMRet )" (cTypeStem) );
      }

      match mRetInfo {
         case .Method( funcType ) {
            self.write( ", %s _pObj" (cTypeAnyP ) );
            processArgs();
         }
         case .Form {
            self.write( ", %s _pForm" (cTypeAnyP ) );
            processArgs();
         }
         case .FormFunc( funcType ) {
            self.write( ", %s _pForm" (cTypeAnyP ) );
            processArgs();
         }
         case .DDD(node) {
            processArgs();
         }
         case .Func(funcNode) {
            processArgs();
         }
         case .Format(format,node) {
            processArgs();
         }
      }
   }
   
   switch self.processMode {
      case .Intermediate, .StringFormat {
         processDeclMRetProto();
         self.writeln( "// %d" (parent.$pos.lineNo) );
         self.writeln( "{" );

         self.pushIndent( ## );

         let mut argTypeList:List<&Ast.TypeInfo> = [];
         
         fn processSetArg( primFlag:bool ) {
            foreach argNode, index in argList.$expList {
               let mut argType = argNode.$expType;
               if index == mRetExp.$index {
                  self.writeln( "lns_setMRet( _pEnv, pMRet%s );" (accessAny) );
               }
               if index >= mRetExp.$index {
                  switch argNode.$kind {
                     case Nodes.NodeKind.$ExpToDDD {
                        let toDDDNode = unwrap argNode@@@Nodes.ExpToDDDNode;
                        self.write( "%s arg%d = " ( cTypeStem, index ) );
                        self.write( "lns_createDDD" );
                        let expList = toDDDNode.$expList.$expList;
                        let lastExp = expList[ #expList ];
                        self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );
                        foreach exp, workIndex in expList {
                           // self.write(
                           //    ", LNS_STEM_ANY( lns_getMRet( _pEnv, %d ) )" (workIndex + index - 2) );
                           self.write(
                              ", lns_getMRet( _pEnv, %d )" (workIndex + index - 2) );
                        }
                        self.write( ")" );
                        argTypeList.insert( Ast.builtinTypeDDD );
                     }
                     case Nodes.NodeKind.$ExpSubDDD {
                        self.write( "%s arg%d = " ( cTypeStem, index ) );
                        filter( argNode, self, parent );
                     }
                     default {
                        if! let castNode = argNode@@@Nodes.ExpCastNode {
                           argType = castNode.$castType;
                        }
                        
                        let typeTxt;
                        if primFlag {
                           typeTxt = getCType(argType );
                           argTypeList.insert( argType.$srcTypeInfo );
                        }
                        else {
                           typeTxt = cTypeStem;
                           argTypeList.insert( Ast.builtinTypeStem );
                        }
                        self.write( "%s arg%d = " (typeTxt, index ) );
                        if argType.$kind == .DDD {
                           if index == mRetExp.$index {
                              self.write( "pMRet" );
                           }
                           else {
                              self.write(
                                 "lns_createSubDDD( _pEnv, %d, pMRet )"
                                 (index - mRetExp.$index) );
                           }
                        }
                        else {
                           self.write(
                              "lns_getMRet( _pEnv, %d )" (index - mRetExp.$index) );
                        }
                        if primFlag {
                           self.write( getAccessValFromStem( argType ) );
                        }
                        else {
                           self.write( "->val.pAny" );
                        }
                     }
                  }
                  self.writeln( "; // %s" (argType.getTxt( self.$typeNameCtrl## )) );
               }
               else {
                  argTypeList.insert( argNode.$expType );
               }
            }
            if retTypeName ~= "void" {
               self.write( "return " );
            }
         }

         fn processArg2Stem(index:int, typeInfo:&Ast.TypeInfo ) {
            if #argTypeList >= index {
               switch argTypeList[ index ] {
                  case Ast.builtinTypeInt, Ast.builtinTypeChar {
                     self.write( "LNS_STEM_INT(" );
                     self.write( "arg%d )" ( index ) );
                  }
                  case Ast.builtinTypeReal {
                     self.write( "LNS_STEM_REAL(" );
                     self.write( "arg%d )" ( index ) );
                  }
                  case Ast.builtinTypeBool {
                     self.write( "LNS_STEM_BOOL(" );
                     self.write( "arg%d )" ( index ) );
                  }
                  default {
                     if getValKind( argTypeList[ index ] ) == .Any {
                        self.write( "LNS_STEM_ANY(" );
                        self.write( "arg%d )" ( index ) );
                     }
                     else {
                        self.write( "arg%d" ( index ) );
                     }
                  }
               }
            }
            else {
               if typeInfo.$kind == .DDD {
                  let offset = index - mRetExp.$index;
                  if offset > 0 {
                     self.write(
                        "lns_createSubDDD( _pEnv, %d, pMRet )"
                        ( index - mRetExp.$index ) );
                  }
                  elseif offset == 0 {
                     self.write( "pMRet" );
                  }
                  else {
                     self.write( cValDDD0 );
                  }
               }
               else {
                  self.write( cValNone );
               }
            }
         }
         
         fn processCreateDDD( expList:&List<&Nodes.Node>) {
            self.write( "lns_createDDD" );
            let lastExp = expList[ #expList ];
            self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );

            for index = 1, #expList {
               self.write( ", " );
               processArg2Stem( index, Ast.builtinTypeNone );
            }
         }
        

         let mut funcTypeInfo:&Ast.TypeInfo! = nil;
   
         match mRetInfo {
            case .Method( funcType ) {
               funcTypeInfo = funcType;
               
               processSetArg( true );
               self.write( "%s( _pEnv, _pObj"
                  ( self.moduleCtrl.getCallMethodCName( funcType )));
            }
            case .Form {
               processSetArg( true );
               self.write( "lns_closure( _pForm )( _pEnv, pForm" );

               processCreateDDD( argList.$expList );
            }
            case .FormFunc( funcType ) {
               funcTypeInfo = funcType;

               processSetArg( true );
               self.write( "%s( _pEnv, _pForm"
                           (self.moduleCtrl.getCallFormName( funcType ) ) );
            }
            case .Func( funcNode ) {
               funcTypeInfo = funcNode.$expType;

               processSetArg( true );
               let mut wroteFuncFlag = false;
               let builtinFunc = TransUnit.getBuiltinFunc();

               if! let cFuncName =
                  self.moduleCtrl.getBuiltinFuncNameFromType( funcNode.$expType )
               {
                  wroteFuncFlag = true;
                  self.write( cFuncName .. "(" );
               }
                  
               if not wroteFuncFlag {
                  filter( funcNode, self, parent );
                  self.write( "(" );
               }
               self.write( " _pEnv" );
            }
            case .DDD( expListNode ) {
               processSetArg( true );
               processCreateDDD( expListNode.$expList );
            }
            case .Format( format, expListNode ) {
               processSetArg( true );
               self.write( "mtd_lns_string_format( _pEnv, " );
               self.write( getLiteralStrAny( format ) );
               self.write( ", " );
               processCreateDDD( expListNode.$expList );
               self.write( ")" );
            }
         }

         when! funcTypeInfo {
            foreach argType, index in funcTypeInfo.$argTypeInfoList {
               if getValKind( argType ) == .Stem {
                  self.write( ", " );
                  processArg2Stem( index, argType );
               }
               else {
                  self.write( ", arg%d" ( index ) );
               }
            }
         }

         self.popIndent();
         self.writeln( ");" );
         self.writeln( "}" );
      }
      case .Prototype {
         processDeclMRetProto();
         self.writeln( "; // %d" (argList.$pos.lineNo) );
      }
   }
}

fn getMRetFuncName( node:&Nodes.Node ): str {
   return "l_call_mret_%d" ( node.$id );
}


pub override fn convFilter.processExpToDDD( node: Nodes.ExpToDDDNode, opt: Opt ) mut
{
   switch self.processMode {
      case .Intermediate, .Prototype {
         if! let mRetExp =  node.$expList.$mRetExp {
            if mRetExp.$index > 0 {
               // index が 0 以下の場合、 ExpCallNode 側で処理するので、
               // ここでは index が 1 以上のものだけを処理する。
               self.processCallWithMRet(
                  node, getMRetFuncName( node ), cTypeStem,
                  MRetInfo.DDD( node.$expList ), node.$expList );
            }
         }
         return;
      }
   }


   let expList = node.$expList.$expList;

   if! let mRetExp = node.$expList.$mRetExp {
      self.write( "%s( _pEnv" ( getMRetFuncName( node ) ) );
      foreach exp, index in expList {
         if index > mRetExp.$index {
            break;
         }
         self.write( ", " );
         //self.processVal2stem( exp, node );
         filter( exp, self, node );
      }
      self.write( ")" );
   }
   else {
      self.processCreateDDD( node, expList );
   }
}

pub override fn convFilter.processExpNew(
   node: Nodes.ExpNewNode, opt: Opt ) mut
{
   self.write( "%s( _pEnv" ( self.moduleCtrl.getNewName( node.$symbol.$expType ) ) );
   if! node.$argList {
      self.processCallArgList( node.$ctorTypeInfo, _exp );
      //filter( _exp,  self, node );
   }
   self.write( ")" );
};




fn convFilter.processCall(
   funcSym:&Ast.SymbolInfo!, funcType:&Ast.TypeInfo,
   setArgFlag:bool, argList:&Nodes.ExpListNode! ) mut
{
   if not setArgFlag {
      self.write( "_pEnv" );


      if! let scope = funcType.$scope {
         if #scope.$closureSymList > 0 {
            // クロージャの場合
            self.write( ", " );
            let mut setFlag = false;
            when! funcSym {
               if funcSym.$hasAccessFromClosure {
                  self.processSym2Any( funcSym );
                  setFlag = true;
               }
            }
            if not setFlag {
               self.write( getPrepareClosure(
                  self.scopeMgr, "NULL", 0, false, scope.$closureSymList ) );
            }
            //self.write( accessAny );
         }
      }
   }

   if funcType.$kind == .Func and funcType.$rawTxt == "___init" and
      funcType.$parentInfo.$kind == .Class
   {
      self.write( ", %s" ( getBlockName( self.ast.$moduleScope ) ) );
   }
   else {
      when! argList {
         let mut expList:List<&Nodes.Node> = [];
         foreach expNode in argList.$expList {
            if expNode.$expType.$kind ~= .Abbr {
               expList.insert( expNode );
            }
         }

         self.processCallArgList( funcType, argList );
      }
      else {
         self.processCallArgList( funcType, nil );
      }
   }
   self.write( " )" );
}

pub override fn convFilter.processDeclClass(
   node: Nodes.DeclClassNode, opt: Opt ) mut
{
   let classType = node.$expType;
   let className = self.moduleCtrl.getClassCName( classType );
   let classCanonicalName = self.moduleCtrl.getCanonicalName( classType );

   self.writeln(
      "// decl class %s (%s)-->" (classCanonicalName, self.processMode.$_txt) );
   
   switch self.processMode {
      case .Prototype {
         self.processDeclClassNodePrototype( node );
      }
      case .WideScopeVer {
         switch classType.$kind {
            case .Class {
               // インタフェース情報設定
               processIFMethodDataInit(
                  self.stream, self.moduleCtrl, classType, classType );
               
               processClassDataInit(
                  self.stream, self.moduleCtrl, self.scopeMgr,
                  classType, node.$fieldList );
            }
            case .IF {
               processClassMeta( self.stream, self.moduleCtrl, classType );
            }
         }
      }
      case .DefClass {
         if classType.$kind == .Class {
            self.processDeclClassDef( node );
            self.processMapping(
               node, classType,
               Ast.isPubToExternal( classType.$accessMode ) and
               Out2HMode.SourcePub or Out2HMode.SourcePri );
         }
      }
      case .Form, .InitModule {
         // self.write( self.moduleCtrl.getClassInitBlockName( classType ) );
         // self.write( "( _pEnv, NULL );" );
         if! let initBlockNode = node.$initBlock.$func {
            self.write(
               "%s( " (self.moduleCtrl.getMethodCName( initBlockNode.$expType) ) );
            
            self.processCall( nil, initBlockNode.$expType, false, nil );
            self.writeln( ";" );
         }
      }
   }
   
   self.writeln(
      "// <--- decl class %s (%s)" (classCanonicalName, self.processMode.$_txt) );
   

   
   
//    let nodeInfo = node;
//    let classNameToken = nodeInfo.get_name();
//    let className = classNameToken.txt;
//    let classTypeInfo = node.get_expType();
//    let classTypeId = classTypeInfo.$typeId;
//    let isGenericClass = isGenericType( classTypeInfo );


//    if nodeInfo.get_accessMode() == .Pub {
//       self.classId2TypeInfo[ classTypeId ] = classTypeInfo;
//    }
//    self.classId2MemberList[ classTypeId ] = nodeInfo.get_memberList();

//    if! node.$moduleName {
//       self.write(
//          string.format( "local %s = require( %s )", className, _exp.txt ) );
//       switch node.$accessMode {
//          case .Pub, .Pro {
//             if self.needModuleObj {
//                self.writeln( "" );
//                self.write( "_moduleObj.%s = %s" (className, className ) );
//             }
//          }
//       }
//       return;
//    }
//    self.writeln( string.format( "local %s = {}", className ) );

//    let mut ifTxt = "";
//    if #classTypeInfo.$interfaceList > 0 {
//       foreach ifType in classTypeInfo.$interfaceList {
//          ifTxt = ifTxt .. self.getFullName( ifType ) .. ",";
//       }
//       ifTxt = "ifList = {%s}" (ifTxt);
//    }

//    let baseInfo = classTypeInfo.get_baseTypeInfo();
//    let mut baseTxt = "";
//    if baseInfo.get_typeId() ~= Ast.rootTypeId {
//       baseTxt = "__index = %s" ( self.getFullName( baseInfo ) );
//    }

//    if #ifTxt > 0 or #baseTxt > 0 {
//       let mut metaTxt = baseTxt;
//       if #baseTxt > 0 and #ifTxt > 0 {
//          metaTxt = "%s,%s" (baseTxt,ifTxt);
//       }
//       elseif #ifTxt > 0 {
//          metaTxt = ifTxt;
//       }
//       self.writeln( "setmetatable( %s, { %s } )" ( className, metaTxt ) );
//    }

//    if nodeInfo.get_accessMode() == .Pub {
//       if self.needModuleObj {
//          self.writeln( string.format( "_moduleObj.%s = %s", className, className ) );
//       }
//    }

//    foreach declNode in node.$declStmtList {
//       filter( declNode, self, node );
//    }


//    let mut hasConstrFlag = false;
//    let mut hasDestrFlag = false;
//    let mut memberList: List<&Nodes.DeclMemberNode> = [];
//    let fieldList: List<&Nodes.Node> = nodeInfo.get_fieldList();
//    let outerMethodSet: Set<str> = nodeInfo.get_outerMethodSet();
//    let mut methodNameSet: Set<str> = (@);
//    foreach field in fieldList {
//       let mut ignoreFlag = false;
//       if field.$kind == Nodes.NodeKind.$DeclConstr {
//          hasConstrFlag = true;
//          methodNameSet.add( "__init" );
//       }
//       if field.$kind == Nodes.NodeKind.$DeclDestr {
//          hasDestrFlag = true;
//          methodNameSet.add( "__free" );
//       }
//       if! let declMemberNode = field@@@Nodes.DeclMemberNode {
//          if not declMemberNode.$staticFlag {
//             memberList.insert( declMemberNode );
//          }
//       }
//       if! let methodNode = field@@@Nodes.DeclMethodNode {
//          let declInfo = methodNode.get_declInfo();
//          let methodNameToken = unwrap declInfo.get_name();
//          if outerMethodSet.has( methodNameToken.txt ) {
//             ignoreFlag = true;
//          }
//          methodNameSet.add( methodNameToken.txt );
//       }

//       if ( not ignoreFlag ) {
//          filter( field, self, node );
//       }
//    }

//    let mut destTxt = "";
//    if! self.getDestrClass( node.get_expType() ) {
//       destTxt = ", __gc = %s.__free" (_exp.getTxt(##));
//    }

//    self.writeln(```
// function %s.setmeta( obj )
//   setmetatable( obj, { __index = %s %s } )
// end```
//       ( className, className, destTxt ) );

//    if not hasConstrFlag {
//       // デフォルトコンストラクタ生成
//       methodNameSet.add( "__init" );

//       let oldFlag;
//       {
//          let initSymbol =
//             unwrap (unwrap classTypeInfo.$scope).getSymbolInfoChild( "__init" );
//          oldFlag = (unwrap initSymbol.$typeInfo.$scope).getSymbolInfoChild( "" ) ~= nil;
//       }

//       let mut superArgTxt = "";
//       let mut thisArgTxt = "";

//       if not oldFlag and baseInfo ~= Ast.headTypeInfo {
//          if! let superInit = (unwrap baseInfo.$scope).getSymbolInfoChild( "__init" ) {
//             foreach argType, index in superInit.$typeInfo.$argTypeInfoList {
//                if #superArgTxt > 0 {
//                   superArgTxt = superArgTxt .. ", ";
//                }
//                superArgTxt = "%s__superarg%d" (superArgTxt, index);
//             }
//          }
//       }

//       foreach member in memberList {
//          if #thisArgTxt > 0 {
//             thisArgTxt = thisArgTxt .. ", ";
//          }
//          thisArgTxt = thisArgTxt .. member.$name.txt;
//       }

//       let mut argTxt = superArgTxt;
//       if #argTxt > 0 {
//          argTxt = argTxt .. ",";
//       }
//       argTxt = argTxt .. thisArgTxt;

//       self.writeln( ```
// function %s.new( %s )
//    local obj = {}
//    %s.setmeta( obj )
//    if obj.__init then
//       obj:__init( %s )
//    end
//    return obj
// end
// function %s:__init( %s )
// ```
//             ( className, argTxt, className,
//               argTxt, className, argTxt ) );
//       self.pushIndent(##);

//       if baseInfo ~= Ast.headTypeInfo {
//          // Super クラスを持つ場合、その Super クラスの __init をコールする。
//          if! let superInit = (unwrap baseInfo.$scope).getSymbolInfoChild( "__init" ) {
//             self.write( "%s.__init( self" ( self.getFullName( baseInfo ) ) );
//             if #superArgTxt > 0 {
//                self.writeln( ", %s )" ( superArgTxt ) );
//             }
//             else {
//                self.writeln( ")" );
//             }
//          }
//       }

//       foreach member in memberList {
//          let memberName = member.$name.txt;
//          self.writeln( string.format( "self.%s = %s", memberName, memberName ));
//       }
//       self.popIndent();
//       self.writeln( 'end' );
//    }

//    // accessor
//    let scope = nodeInfo.get_scope();
//    foreach memberNode in nodeInfo.$memberList {
//       let memberNameToken = memberNode.get_name();
//       let memberName = memberNameToken.txt;
//       let getterName = "get_" .. memberName;
//       // let typeInfo = scope.getTypeInfo( getterName, scope, false );
//       // let autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
//       let mut autoFlag = not methodNameSet.has( getterName );
//       let prefix = memberNode.$staticFlag and className or "self";
//       if memberNode.get_getterMode() ~= .None and autoFlag
//       {
//          self.writeln( ```
// function %s:%s()
//    return %s.%s
// end``` ( className, getterName, prefix, memberName ) );
//          methodNameSet.add( getterName );
//       }
//       let setterName = "set_" .. memberName;
//       //typeInfo = scope.getTypeInfo( setterName, scope, false );
//       //autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
//       autoFlag = not methodNameSet.has( setterName );
//       if memberNode.get_setterMode() ~= .None and autoFlag
//       {
//          self.writeln( ```
// function %s:%s( %s )
//    %s.%s = %s
// end``` ( className, setterName, memberName, prefix, memberName, memberName ) );
//          methodNameSet.add( setterName );
//       }
//    }

//    // advertise
//    foreach advertiseInfo in node.$advertiseList {
//       let memberName = advertiseInfo.$member.$name.txt;
//       let mut memberType = advertiseInfo.$member.$expType;
//       foreach child in memberType.$children {
//          if child.$kind == Ast.TypeInfoKind.Method and
//             child.$accessMode ~= .Pri and
//             not child.$staticFlag
//          {
//             let childName = advertiseInfo.$prefix .. child.getTxt(##);
//             if not methodNameSet.has( childName ) {
//                self.writeln( ```
// function %s:%s( ... )
//    return self.%s:%s( ... )
// end
// ``` (className, childName, memberName, childName) );
//             }
//          }
//       }
//    }

//    // init block
//    if #nodeInfo.$initStmtList > 0 {
//       self.writeln( "do" );
//       self.pushIndent(##);
//       foreach initStmt in nodeInfo.$initStmtList {
//          filter( initStmt, self, node );
//          self.writeln( "" );
//       }
//       self.popIndent();
//       self.writeln( "end" );
//    }

//    // Mapping
//    if classTypeInfo.isInheritFrom( Ast.builtinTypeMapping, nil ) {
//       let mut declArgTxt = "val";
//       let mut argTxt = "{}, val";
//       if isGenericType( classTypeInfo ) {
//          declArgTxt = "val, __alt2mapFunc";
//          argTxt = "{ __alt2mapFunc = __alt2mapFunc }, val";
//       }

//       self.writeln( ```
// function %s:_toMap()
//   return self
// end
// function %s._fromMap( %s )
//   local obj, mes = %s._fromMapSub( %s )
//   if obj then
//      %s.setmeta( obj )
//   end
//   return obj, mes
// end
// function %s._fromStem( %s )
//   return %s._fromMap( %s )
// end
// ``` (className, className, declArgTxt,
//       className, argTxt, className,
//       className, declArgTxt, className, declArgTxt ));

//       self.writeln( 'function %s._fromMapSub( obj, val )' (className ));

//       if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
//          self.writeln( ```
//    local result, mes = %s._fromMapSub( obj, val )
//    if not result then
//       return nil, mes
//    end
// ``` (self.getFullName( classTypeInfo.$baseTypeInfo )) );
//       }

//       self.writeln( '   local memInfo = {}' );

//       foreach memberNode in node.$memberList {
//          let funcTxt, nilable, child = self.getMapInfo( memberNode.$expType );
//          self.writeln(
//             '   table.insert( memInfo, { name = "%s", func = %s, nilable = %s, child = %s } )'
//             ( memberNode.$name.txt, funcTxt, nilable, child ) );
//       }

//       self.writeln( ```
//    local result, mess = _lune._fromMap( obj, val, memInfo )
//    if not result then
//       return nil, mess
//    end
//    return obj
// end```);
//    }
};

fn getFormNilWrapper(node:&Nodes.Node) : str
{
   return "l_nil_form_%d" (node.$id);
}

fn convFilter.processExpCallDefWrap( node: Nodes.ExpCallNode, opt: Opt ) mut {
   let funcType;
   if node.$nilAccess {
      funcType = node.$func.$expType.$nonnilableType;
   }
   else {
      return;
   }
   
   if funcType.$kind ~= .FormFunc {
      return;
   }
   
   let retCode;
   let retType;
   if getCRetType( funcType.$retTypeInfoList ) == "void" {
      retType = "void";
      retCode = "";
   }
   else {
      retType = cTypeStem;
      retCode = cValNil;
   }

   let mut argNameList:List<str> = [];
   self.write( "static %s %s( %s * _pEnv, %s form"
               ( retType, getFormNilWrapper(node), cTypeEnvP, cTypeStem ));
   foreach argType, index in funcType.$argTypeInfoList {
      let name = "arg%d" (index);
      self.write( ", %s %s" (getCType( argType ), name) );
      argNameList.insert( name );
   }
   self.writeln( ")" );
   self.writeln( "{" );
   self.pushIndent( ## );

   
   self.write( ```
if ( form.type == lns_stem_type_nil ) {
   return %s;
}
``` (retCode) );

   self.processCallUserForm( "form%s" (accessAny), funcType, argNameList );            
   
   self.popIndent();
   self.writeln( "}" );
}


pub override fn convFilter.processExpCall(
   node: Nodes.ExpCallNode, opt: Opt ) mut
{
   let funcType = node.$func.$expType.$nonnilableType;
   
   switch self.processMode {
      case .Intermediate, .Prototype {
         if! let argList = node.$argList {

            let funcNode = node.$func;

            let mRetInfo;
            switch funcNode.$expType.$kind {
               case .Method {
                  mRetInfo = MRetInfo.Method( funcType );
               }
               case .Form {
                  mRetInfo = MRetInfo.Form;
               }
               case .FormFunc {
                  mRetInfo = MRetInfo.FormFunc( node.$func.$expType );
               }
               default {
                  mRetInfo = MRetInfo.Func( node.$func );
               }
            }
            
            self.processCallWithMRet(
               node, getMRetFuncName( node ), getCRetType( node.$expTypeList ),
               mRetInfo, argList );
         }
         return;
      }
      case .DefWrap {
         self.processExpCallDefWrap( node, opt );
         return;
      }
   }


   let mut classTypeInfo:&Ast.TypeInfo! = getBelongClassType( node.$func );
  
   fn process() {
      if funcType.$kind == .Form {
         self.write( 'lns_call_form( _pEnv, ' );
         self.processVal2any( node.$func, node );
         if! let argList = node.$argList {
            if #argList.$expList > 0 {
               self.processCallArgList( funcType, argList );
            }
         }
         else {
            self.write( ', lns_global.ddd0' );
         }
         self.write( ' )' );

         return;
      }


      let mut wroteFuncFlag = false;
      let mut setArgFlag = false;

      fn fieldCall():bool {

         let! fieldNode = node.$func@@@Nodes.RefFieldNode {
            return true;
         };
         let prefixNode = fieldNode.$prefix;

      //    fn processSet(): bool {
      //       setArgFlag = true;
      //       wroteFuncFlag = true;

      //       switch fieldNode.$field.txt {
      //          case "add", "del" {
      //             filter( prefixNode, self, fieldNode );
      //             self.write( "[" );
      //             if! let argList = node.$argList {
      //                filter( argList, self, fieldNode );
      //             }
      //             self.write( "]" );
      //             switch fieldNode.$field.txt {
      //                case "add" {
      //                   self.write( "= true" );
      //                }
      //                case "del" {
      //                   self.write( "= nil" );
      //                }
      //             }
      //             return false;
      //          }
      //       }

      //       self.write( "_lune._Set_%s(" ( fieldNode.$field.txt ) );
      //       filter( prefixNode, self, fieldNode );
      //       return true;
      //    }

         let prefixType = prefixNode.$expType;

         fn processEnumAlge() {
            // wroteFuncFlag = true;
            // let fieldExpType = fieldNode.$expType;
            // let mut methodName = fieldNode.$field.txt;
            // if methodName == "get__txt" {
            //    methodName = "_getTxt";
            // }
            // self.write( "_%s( " ( methodName ) );
            // if fieldExpType.$staticFlag {
            //    setArgFlag = false;
            // }
            // else {
            //    filter( prefixNode, self, fieldNode );
            //    setArgFlag = true;
            // }
         }

         if node.$nilAccess {
      //       wroteFuncFlag = true;
      //       setArgFlag = true;
      //       switch prefixType.$kind {
      //          case .List, .Array {
      //             self.write( "_lune.nilacc( table.%s, nil, 'list', "
      //                         (fieldNode.$field.txt ) );
      //             filter( prefixNode, self, fieldNode );
      //          }
      //          default {
      //             self.write( "_lune.nilacc( " );
      //             filter( prefixNode, self, fieldNode );
      //             self.write( ", '%s', 'callmtd' " (fieldNode.$field.txt ) );
      //          }
      //       }
         }
         else {
            switch prefixType.$kind {
               // case .List, .Array {
               //    setArgFlag = true;
               //    wroteFuncFlag = true;
               //    self.write( "table.%s( " (fieldNode.$field.txt ) );
               //    filter( prefixNode, self, fieldNode );
               // }
               // case .Set {
               //    if not processSet() {
               //       return false;
               //    }
               // }
               case .Enum, .Alge {
                  processEnumAlge();
               }
               // case .Box {
               //    filter( prefixNode, self, fieldNode );
               //    self.write( "[1]" );
               //    return false;
               // }
               case .Class {
                  if prefixType.equals( Ast.builtinTypeString## ) {
                     wroteFuncFlag = true;
                     setArgFlag = true;
                     self.write( "mtd_lns_string_%s( _pEnv, " (fieldNode.$field.txt) );
                     filter( prefixNode, self, fieldNode );
                  }


                  
               //    if prefixType.isInheritFrom( Ast.builtinTypeMapping, nil ) and
               //       isGenericType( prefixType ) and
               //       ( fieldNode.$field.txt == "_fromMap" or
               //         fieldNode.$field.txt == "_fromStem" )
               //    {
               //       wroteFuncFlag = true;
               //       setArgFlag = true;
               //       filter( node.$func, self, node );
               //       self.write( "( " );
               //       if! let argList = node.$argList {
               //          filter( argList,  self, node );
               //          self.write( ", " );
               //       }
               //       self.outputAlter2MapFunc( self, prefixType.createAlt2typeMap(false) );
               //       self.write( ")" );
               //       return false;
               //    }
               }
            }
         }
         return true;
      }

      let mut funcSym:&Ast.SymbolInfo! = nil;
      if not fieldCall() {
         return;
      }

      if! let refNode = node.$func@@@Nodes.ExpRefNode {
         let builtinFunc = TransUnit.getBuiltinFunc();

         if! let cFuncTxt = self.moduleCtrl.getBuiltinFuncNameFromType( refNode.$expType )
         {
            wroteFuncFlag = true;
            self.write( cFuncTxt .. "(" );
         }
         // elseif refNode.$token.txt == "super" {
         //    wroteFuncFlag = true;
         //    setArgFlag = true;
         //    let funcType = refNode.$expType;
         //    self.write( "%s.%s( self " ( self.getFullName( funcType.$parentInfo ),
         //                                 funcType.$rawTxt ) );
         // }
      }

      if not wroteFuncFlag {
         let funcSymList = node.$func.getSymbolInfo();
         if #funcSymList > 0 {
            let workFuncSym = funcSymList[ 1 ].getOrg();
            funcSym = workFuncSym;
            if! let cFuncName =
               self.moduleCtrl.getBuiltinFuncNameFromType( workFuncSym.$typeInfo )
            {
               wroteFuncFlag = true;
               self.write( cFuncName );
               self.write( "(" );
            }
         }
      }
      
      if not wroteFuncFlag {
         switch funcType.$kind {
            case .Method {
               if! let fieldNode = node.$func@@@Nodes.RefFieldNode {
                  if node.$nilAccess {
                     self.write( self.moduleCtrl.getNilMethodCName( funcType ) );
                     self.write( "( _pEnv, " );
                     self.processVal2stem( fieldNode.$prefix, fieldNode );
                  }
                  else {
                     self.write( self.moduleCtrl.getCallMethodCName( funcType ) );
                     self.write( "( _pEnv, " );
                     self.processVal2any( fieldNode.$prefix, fieldNode );
                  }
                  //self.write( accessAny );
                  // self.write(
                  //    ",offsetof( lns_mtd_%s_t, %s )"
                  //    (self.getFullName( fieldNode.$prefix.$expType ), fieldNode.$field.txt ) );
               }
               wroteFuncFlag = true;
               setArgFlag = true;
            }
            case .Func {
               self.write( "%s( " ( self.moduleCtrl.getFuncName( funcType ) ) );
               wroteFuncFlag = true;
            }
            case .FormFunc {
               if node.$nilAccess {
                  self.write( "%s( _pEnv, " ( getFormNilWrapper(node) ));
               }
               else {
                  self.write( "%s( _pEnv, "
                              ( self.moduleCtrl.getCallFormName( funcType ) ));
               }
               self.processVal2any( node.$func, node );
               wroteFuncFlag = true;
               setArgFlag = true;
            }
         }
      }
      
      if not wroteFuncFlag {
         // if node.$nilAccess {
         //    self.write( "_lune.nilacc( " );
         //    filter( node.$func, self, node );
         //    self.write( ", nil, 'call'" );
         //    wroteFuncFlag = true;
         // }
         // else {
         filter( node.$func, self, node );

         // switch funcType.$kind {
         //    case .FormFunc { 
         //       self.write( "->val.form.pFunc" );
         //    }
         // }

         
         self.write( "( " );
         // }
      }

      // if not setArgFlag {
      //    self.write( "_pEnv, " );


      //    if! let scope = funcType.$scope {
      //       if #scope$.$closureSymList > 0 {
      //          // クロージャの場合
      //          self.write( "lns_func2any( _pEnv, (lns_closure_t *)NULL, 0, false, %d"
      //                      (#scope$.$closureSymList) );
      //          foreach symbolInfo in scope.$closureSymList {
      //             self.write( ", %s" (symbolInfo.$name) );
      //          }
      //          self.write( ")" );
      //       }
      //       else {
      //          self.write( "NULL" );
      //       }
      //    }
      //    else {
      //       self.write( "NULL" );
      //    }
      // }

      // if! let argList = node.$argList {
      //    let mut expList:List<&Nodes.Node> = [];
      //    foreach expNode in argList.$expList {
      //       if expNode.$expType.$kind ~= .Abbr {
      //          expList.insert( expNode );
      //       }
      //    }

      //    if #expList > 0 {
      //       self.processCallArgList( funcType, node.$argList );
      //    }
      // }
      // self.write( " )" );

      self.processCall( funcSym, funcType, setArgFlag, node.$argList );
   }


   fn call() {
      let mut isMret = false;
      if! let argList = node.$argList {
         if! let mRetExp = argList.$mRetExp {
            if needMRetWrap( node.$func.$expType.$argTypeInfoList, argList )
            {
               // 多値の引数を含む場合
               isMret = true;
               self.write( "%s( _pEnv" ( getMRetFuncName( node ) ) );

               let funcNode = node.$func;
               switch funcNode.$expType.$kind {
                  case .Method {
                     if! let fieldNode = node.$func@@@Nodes.RefFieldNode {
                        self.write( ", " );
                        self.processVal2any( fieldNode.$prefix, fieldNode );
                     }
                  }
                  case .Form, .FormFunc {
                     self.write( ", " );
                     self.processVal2any( node.$func, node );
                  }
               }
               foreach argNode, index in argList.$expList {
                  if index <= mRetExp.$index {
                     self.write( ", " );
                     filter( argNode, self, argList );
                  }
               }
               self.write( ")" );
            }
         }
      }
      if not isMret {
         process();
      }

      processAlterAccessVal(
         self.stream, funcType.$retTypeInfoList, node.$expTypeList );
         
      // let retTypeInfoList = funcType.$retTypeInfoList;
      // if #retTypeInfoList == 1 {
      //    if retTypeInfoList[ 1 ].$kind == .Alternate {
      //       self.write( getAccessValFromStem( node.$expType ) );
      //    }
      // }
   }


   let retTypeInfoList = funcType.$retTypeInfoList;
   if #retTypeInfoList == 1 {
      // 戻り値が alternat だった時に対応する処理
      processAlterToActualType(
         self.stream, self.moduleCtrl, retTypeInfoList[ 1 ], node.$expType, call );
   }
   else {
      call();
   }
   
};

pub override fn convFilter.processExpAccessMRet(
   node: Nodes.ExpAccessMRetNode, opt:Opt ) mut

{
   processGetMRet( self.stream, self.moduleCtrl, node.$expType, node.$index - 1 );
};


pub override fn convFilter.processExpList(
   node: Nodes.ExpListNode, opt: Opt ) mut
{
   let expList = node.get_expList();
   //let expList = node.$expList;
   foreach exp, index in expList {
      if exp.$expType.$kind == .Abbr {
         break;
      }
      if index > 1 {
         self.write( ", " );
      }
      filter( exp, self, node );
   }
};

pub override fn convFilter.processExpOp1(
   node: Nodes.ExpOp1Node, opt: Opt ) mut
{
   let mut op = node.$op.txt;
   // if op == ",,," or op == ",,,," {
   //     filter( node.$exp,  self, node );
   // }
   switch op { 
      case "~", "+", "-" {
         self.write( op );
         self.accessPrimVal( node.$exp, node );
      }
      case "not" {
         self.write( "lns_op_not( _pEnv, " );
         self.processVal2stem( node.$exp, node );
         self.write( ")" );
      }
      case "#" {
         let expType = node.$exp.$expType.$srcTypeInfo;
         if expType.$kind == .List {
            self.write( "lns_mtd_List_len( _pEnv, " );
            self.processVal2any( node.$exp, node );
            self.write( ")" );
         }
         elseif expType == Ast.builtinTypeString {
            self.processVal2any( node.$exp, node );
            self.write( "->val.str.len" );
         }
         else {
            Util.err( "not support type -- %s" (expType.getTxt(##)) );
         }
      }
      default {
         Util.err( "not support op -- %s" (op) );
      }
   }
};

pub override fn convFilter.processExpMultiTo1(
   node: Nodes.ExpMultiTo1Node, opt: Opt ) mut
{
   self.write( "lns_fromDDD( " );
   filter( node.$exp, self, node );
   self.write( accessAny );
   self.write( ", 0 )" );
   if node.$exp.$expType.$kind == .DDD and
      Ast.isNumberType( node.$expType.$srcTypeInfo.$nonnilableType )
   {
      //self.write( accessAny );
   }
   else {
      self.write( getAccessValFromStem( node.$exp.$expType ) );
   }
}



fn convFilter.processStme2Val( dstType:&Ast.TypeInfo, srcStemTxt:str ) mut
{
   switch dstType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         self.write( "lns_stem2int( " );
         self.write( srcStemTxt );
         self.write( ")" );
      }
      case Ast.builtinTypeReal {
         self.write( "lns_stem2real( " );
         self.write( srcStemTxt );
         self.write( ")" );
      }
      case Ast.builtinTypeBool {
         self.write( "lns_stem2bool( " );
         self.write( srcStemTxt );
         self.write( ")" );
      }
      default {
         self.write( srcStemTxt );
         if getValKind( dstType ) == .Any {
            self.write( accessAny );
         }
      }
   }
}

fn convFilter.processFuncCast( node: Nodes.ExpCastNode ) mut
{
   
   let castType = node.$castType;
   switch castType.$kind {
      case .Func, .Form, .FormFunc {
      }
      default {
         return;
      }
   }

   let orgFunc = node.$exp.$expType;
   let closureSymList = unwrap orgFunc.$scope$.$closureSymList default [];

   switch orgFunc.$nonnilableType.$kind {
      case .Func, .Form, .FormFunc {
      }
      case .Stem {
         // stem からのキャストの場合、同じ型へのキャストとして何もしない。
         return;
      }
      default {
         Util.err( "illegal kind -- %s, %d"
                   (orgFunc.$nonnilableType.$kind.$_txt, __line__) );
      }
   }

   if not needsWrapper( orgFunc, castType ) {
      return;      
   }

   
   self.write( "static %s %s( %s _pEnv"
               ( getCRetType( castType.$retTypeInfoList),
                 self.moduleCtrl.getFuncCastWrapName( orgFunc, castType ),
                 cTypeEnvP ) );
   if #closureSymList > 0 {
      self.write( ", %s _pForm" (cTypeAnyP) );
   }
   
   foreach argType, index in castType.$argTypeInfoList {
      self.write( ", " );
      self.write( "%s arg%d" (getCType( argType ), index ) );
   }

   self.write( ")" );
   if self.processMode == .Prototype {
      self.writeln( ";" );
      return;
   }
   
   self.writeln( "// %d" (node.$pos.lineNo) );
   self.writeln( "{" );
   self.pushIndent( ## );

   foreach typeInfo, index in orgFunc.$argTypeInfoList {
      self.write( "%s var%d = " (getCType(typeInfo), index) );

      let dstType = orgFunc.$argTypeInfoList[ index ];
      let srcType = castType.$argTypeInfoList[ index ];
      
      if index == #castType.$argTypeInfoList and
          ( #orgFunc.$argTypeInfoList ~= #castType.$argTypeInfoList or
            not dstType.equals( srcType ## ) )
      {
         if srcType.$kind == .DDD and dstType.$kind ~= .DDD {
            let dddSym = "arg%d%s" (index,accessAny);
            self.processStme2Val( dstType, "lns_fromDDD( %s, 0 )" (dddSym) );
            self.writeln( ";" );
            for subIndex = index + 1, #orgFunc.$argTypeInfoList {
               let dstTypeSub = orgFunc.$argTypeInfoList[ subIndex ];
               self.write( "%s var%d = " (getCType(typeInfo), subIndex) );
               if dstTypeSub.$kind == .DDD {
                  self.write(
                     "lns_createSubDDD( _pEnv, %d, arg%d )"
                     (subIndex - index, index ) );
               }
               else {
                  let dddSymSub = "arg%d%s" (index,accessAny);
                  self.processStme2Val(
                     dstTypeSub, "lns_fromDDD( %s, %d )" (dddSymSub, subIndex - index) );
               }
               self.writeln( ";" );
            }
            break;
         }
         else {
            self.write( "arg%d" (index) );
         }
      }
      else {
         self.write( "arg%d" (index) );
      }
      
      self.writeln( ";" );
   }

   // 関数コール
   if #orgFunc.$retTypeInfoList > 0 {
      self.write( "%s ret = " (getCRetType(orgFunc.$retTypeInfoList) ) );
   }
   self.write( "%s( _pEnv" (self.moduleCtrl.getFuncName( orgFunc ) ) );
   if #closureSymList > 0 {
      self.write( ", _pForm" );
   }
   foreach typeInfo, index in orgFunc.$argTypeInfoList {
      self.write( ", var%s" (index) );
   }
   self.writeln( ");" );

   // 戻り値処理
   if #castType.$retTypeInfoList > 0 {
      self.write( "return " );

      if #orgFunc.$retTypeInfoList == 0 {
         if #castType.$retTypeInfoList > 1 {
            self.write( cValDDD0 );
         }
         else {
            self.write( cValNil );
         }
      }
      elseif #orgFunc.$retTypeInfoList == 1 {
         if #castType.$retTypeInfoList > 1 {
            if orgFunc.$retTypeInfoList[ 1 ].$kind == .DDD {
               self.write( "ret" );
            }
            else {
               self.write( "lns_createMRet( _pEnv, false, 1, " );

               process2stem(
                  self.stream, self.moduleCtrl, self.scopeMgr,
                  getValKind( orgFunc.$retTypeInfoList[ 1 ] ),
                  orgFunc.$retTypeInfoList[ 1 ], node,             
                  fn () {
                     self.write( "ret" );
                  });
               self.write ( ")" );
            }
         }
         else {
            if getValKind( castType.$retTypeInfoList[ 1 ] ) == .Stem {
               process2stem(
                  self.stream, self.moduleCtrl, self.scopeMgr,
                  getValKind( orgFunc.$retTypeInfoList[ 1 ] ),
                  orgFunc.$retTypeInfoList[ 1 ], node,             
                  fn () {
                     self.write( "ret" );
                  });
            }
            else {
               self.write( "ret" );
            }
         }
      }
      else {
         self.write( "ret" );
      }
      self.writeln( ";" );
   }

   
   self.popIndent();
   self.writeln( "}" );
}

pub override fn convFilter.processExpCast(
   node: Nodes.ExpCastNode, opt: Opt ) mut
{
   switch self.processMode {
      case .Prototype, .Intermediate {
         self.processFuncCast( node );
         return;
      }
      default {
      }
   }

   
   let exp = node.$exp;
   let expType = exp.$expType;
   let nodeExpType = node.$expType;
   let castType = node.$castType;
   switch node.$castKind {
      case .Implicit {
         switch castType.$kind {
            case .IF {   
               if expType.$kind == .Class {
                  self.write( "lns_getIF( _pEnv, &lns_if_%s( "
                              (self.moduleCtrl.getClassCName( expType )));
                  self.processVal2any( node.$exp, node );
                  //filter( node.$exp, self, node );
                  //self.write( accessAny );
                  self.write( ")->%s )" ( self.moduleCtrl.getClassCName( castType ) ) );
               }
            }
            case .FormFunc {
               self.processFuncCast2Form( castType, expType );
               //self.write( self.getFunc2any( expType ) );
            }
            case .Form {
               self.processFuncCast2Form( castType, expType );
               //self.write( self.getFunc2any( expType ) );
            }
            default {
               filter( exp, self, node );
            }
         }
      }
      case .Force {
         switch getValKind( castType ) {
            case .Stem {
               self.processVal2stem( exp, node );
            }
            case .Any {
               self.processVal2any( exp, node );
            }
            case .Prim {
               if isStemType( expType ) {
                  switch castType.$srcTypeInfo {
                     case Ast.builtinTypeInt, Ast.builtinTypeChar {
                        self.write( "lns_stem2int( " );
                        filter( exp, self, node );
                        self.write( ")" );
                     }
                     case Ast.builtinTypeReal {
                        self.write( "lns_stem2real( " );
                        filter( exp, self, node );
                        self.write( ")" );
                     }
                     case Ast.builtinTypeBool {
                        self.write( "lns_stem2bool( " );
                        filter( exp, self, node );
                        self.write( ")" );
                     }
                     default {
                        Util.err( "illegal cast -- %s" (castType.getTxt(##)));
                     }
                  }
               }
               else {
                  filter( exp, self, node );
               }
            }
         }
      }
      case .Normal {
         let nonNilCastType = castType.$nonnilableType;
         if nonNilCastType.$kind == .Class and
            not nonNilCastType.equals( Ast.builtinTypeString ## )
         {
            self.write( "lns_castClass( " );
            self.processVal2stem( exp, node );
            self.write( ", &%s )" (self.moduleCtrl.getClassMetaName(nonNilCastType) ) );
         }
         elseif nonNilCastType.$kind == .IF {
            self.write( "lns_castIf( _pEnv, " );
            self.processVal2stem( exp, node );
            self.write( ", &%s )" (self.moduleCtrl.getClassMetaName(nonNilCastType) ) );
         }
         else {
            if getValKind( nonNilCastType ) == .Any {
               let kindTxt;
               let workType;
               if! let enumType = nonNilCastType@@@Ast.EnumTypeInfo {
                  workType = enumType.$valTypeInfo;
               }
               else {
                  workType = nonNilCastType;
               }
               switch workType.$kind {
                  case .List {
                     kindTxt = "lns_value_type_List";
                  }
                  case .Array {   
                     kindTxt = "lns_value_type_Array";
                  }
                  case .Map {     
                     kindTxt = "lns_value_type_Map";
                  }
                  case .Class {
                     if workType.equals( Ast.builtinTypeString## ) { 
                        kindTxt = "lns_value_type_str";
                     }
                     else {
                        Util.err( "not support" );
                     }
                  }
                  case .IF {      
                     Util.err( "not support" );
                  }
                  case .Func {    
                     kindTxt = "lns_value_type_form";
                  }
                  case .Alge {
                     kindTxt = "lns_value_type_alge";
                  }
                  case .DDD {     
                     kindTxt = "lns_value_type_ddd";
                  }
                  case .Set {     
                     kindTxt = "lns_value_type_Set";
                  }
                  case .Form {    
                     kindTxt = "lns_value_type_form";
                  }
                  case .FormFunc {
                     kindTxt = "lns_value_type_form";
                  }
                  default {
                     Util.err( "not support -- %s" ( castType.getTxt(##) ) );
                  }
               }
               self.write( "lns_castAny( " );
               self.processVal2stem( exp, node );
               self.write( ", %s )" ( kindTxt ) );
            }
            else {
               let kindTxt;
               if nonNilCastType.$kind ~= .Stem {
                  switch nonNilCastType.$srcTypeInfo {
                     case Ast.builtinTypeInt, Ast.builtinTypeChar {
                        kindTxt = "lns_stem_type_int";
                     }
                     case Ast.builtinTypeReal {
                        kindTxt = "lns_stem_type_real";
                     }
                     case Ast.builtinTypeBool {
                        kindTxt = "lns_stem_type_bool";
                     }
                     default {
                        Util.err( "not support -- %s" (castType.getTxt(##)) );
                     }
                  }
                  self.write( "lns_castStem( " );
                  self.processVal2stem( exp, node );
                  self.write( ", %s )" ( kindTxt ) );
               }
               else {
                  filter( exp, self, node );
               }
            }
         }
      }
   }
};


pub override fn convFilter.processExpParen(
   node: Nodes.ExpParenNode, opt: Opt ) mut
{
   if #node.$exp.$expTypeList == 1 {
      self.write( "(" );
      self.accessPrimVal( node.$exp, node );
      self.write( " )" );
   }
   else {
      processToIF( self.stream, self.moduleCtrl, node.$expType, fn () {
                      self.accessPrimVal( node.$exp, node );
                   });
   }
};



/**
form から 関数をコールする wrapper を作成。
*/
fn convFilter.processWrapForm2Func( funcType:&Ast.TypeInfo ) mut
{
   self.write( "static %s _wrap_%s_%d( %s _pEnv, %s _pForm, "
               ( cTypeStem, funcType.$rawTxt, funcType.$typeId,
                 cTypeEnvP, cTypeAnyP ) );  
   foreach argType, index in funcType.$argTypeInfoList {
      self.write( ", %s arg%d" (getCType( argType ), index ) );
   }
   self.writeln( ")" );
   self.writeln( "{" );
   self.writeln( 'return %s( _pEnv, _pForm' );
   foreach argType, index in funcType.$argTypeInfoList {
      
   }
   self.writeln( "}" );
}

fn convFilter.processAndOr( node: Nodes.ExpOp2Node,
                            opTxt: str, parent: &Nodes.Node ) mut
{
   fn isAndOr( exp:&Nodes.Node ) : bool {
      if! let parentNode = exp@@@Nodes.ExpOp2Node {
         switch parentNode.$op.txt {
            case "and", "or" {
               return true;
            }
         }
      }
      return false;
   }
   
   let mut firstFlag = not isAndOr( parent );
   if firstFlag {
      self.writeln( "lns_popVal( _pEnv, lns_incStack( _pEnv ) ||" );
      self.pushIndent( ## );
   }

   let opCC;
   if opTxt == "and" {
      opCC = "&&";
   }
   else {
      opCC = "||";
   }
   
   if isAndOr( node.$exp1 ) {
      filter( node.$exp1, self, node );
   }
   else {
      self.write( "lns_setStackVal( _pEnv, " );
      self.processVal2stem( node.$exp1, node );
      self.write( ") " );
   }
   self.writeln( opCC );
   if isAndOr( node.$exp2 ) {
      filter( node.$exp2, self, node );
   }
   else {
      self.write( "lns_setStackVal( _pEnv, " );
      self.processVal2stem( node.$exp2, node );
      self.write( ") " );
   }

   if firstFlag {
      self.write( ")" );

      if not isStemType( node.$expType ) {
         self.write( getAccessPrimValFromStem( false, node.$expType, 0 ) );
      }
      
      self.popIndent();
   }
}

fn convFilter.processConcat( node:&Nodes.ExpOp2Node, parent:&Nodes.Node ) mut
{
   self.write( "lns_strconcat( _pEnv, " );
   self.processVal2any( node.$exp1, node );
   self.write( ", " );
   self.processVal2any( node.$exp2, node );
   self.write( ")" );
}


pub override fn convFilter.processExpSetVal(
   node: Nodes.ExpSetValNode, opt: Opt ) mut
{
   let workParent:&Nodes.Node;
   //let symbolList = node.$exp1.getSymbolInfo();
   let expList;
   let mRetExp:&Nodes.MRetExp!;
   if! let expListNode = node.$exp2@@@Nodes.ExpListNode {
      expList = expListNode.$expList;
      mRetExp = expListNode.$mRetExp;
      workParent = expListNode;
   }
   else {
      expList = [ node.$exp2 ];
      mRetExp = nil;
      workParent = node;
   }
   
   self.processSetValToNode( node, node.$exp1, node.$initSymSet, expList, mRetExp );
};


pub override fn convFilter.processExpOp2(
   node: Nodes.ExpOp2Node, opt: Opt ) mut
{
   let mut opTxt = node.$op.txt;

   switch opTxt {
      case "and", "or" {
         self.processAndOr( node, opTxt, opt.node );
      }
      case ".." {
         self.processConcat( node, opt.node );
      }
      default {
         if! Ast.bitBinOpMap[ opTxt ] {
            // ビット演算の処理
            switch _exp {
               case .LShift {
                  opTxt = "<<";
               }
               case .RShift {
                  opTxt = ">>";
               }
            }
            //self.accessPrimVal( node.$exp1, node );
            filter( node.$exp1, self, node );
            self.write( " " .. opTxt .. " " );
            //self.accessPrimVal( node.$exp2, node );
            filter( node.$exp2, self, node );
         }
         else {
            if Ast.compOpSet.has( opTxt ) {
               self.processEquals(
                  opTxt == "==", node.$exp1.$expType, node.$exp2.$expType,
                  fn ( valKind:ValKind ) {
                     switch valKind {
                        case .Stem {
                           self.processVal2stem( node.$exp1, node );
                        }
                        case .Any {
                           self.processVal2any( node.$exp1, node );
                        }
                        case .Prim {
                           self.accessPrimVal( node.$exp1, node );
                        }
                     }
                  },
                  fn ( valKind:ValKind ) {
                     switch valKind {
                        case .Stem {
                           self.processVal2stem( node.$exp2, node );
                        }
                        case .Any {
                           self.processVal2any( node.$exp2, node );
                        }
                        case .Prim {
                           self.accessPrimVal( node.$exp2, node );
                        }
                     }
                  } );
               
               // let valKind1 = getValKind( node.$exp1.$expType );
               // let valKind2 = getValKind( node.$exp2.$expType );
               // if valKind1 == .Stem or valKind2 == .Stem {
               //    if opTxt ~= "==" {
               //       self.write( "!" );
               //    }
               //    self.write( "lns_equals( " );
               //    self.processVal2stem( node.$exp1, node );
               //    self.write( "," );
               //    self.processVal2stem( node.$exp2, node );
               //    self.write( ")" );
               // }
               // elseif valKind1 == .Any and valKind2 == .Any {
               //    if opTxt ~= "==" {
               //       self.write( "!" );
               //    }
               //    self.write( "lns_equals_any( " );
               //    self.processVal2any( node.$exp1, node );
               //    self.write( "," );
               //    self.processVal2any( node.$exp2, node );
               //    self.write( ")" );
               // }
               // else {
               //    self.accessPrimVal( node.$exp1, node );
               //    // filter( node.$exp1, self, node );

               //    switch opTxt {
               //       case "==" {
               //          self.write( " == " );
               //       }
               //       case "~=" {
               //          self.write( " != " );
               //       }
               //       default {
               //          Util.err( "illegal" );
               //       }
               //    }
               //    self.accessPrimVal( node.$exp2, node );
               //    // filter( node.$exp2, self, node );
               // }
            }
            elseif Ast.mathCompOpSet.has( opTxt ) {
               self.accessPrimVal( node.$exp1, node );
               // filter( node.$exp1, self, node );

               self.write( " " .. opTxt .. " " );
               self.accessPrimVal( node.$exp2, node );
               // filter( node.$exp2, self, node );
            }
            else {
               // self.accessPrimVal( node.$exp1, node );
               filter( node.$exp1, self, node );
               self.write( " " .. opTxt .. " " );
               // self.accessPrimVal( node.$exp2, node );
               filter( node.$exp2, self, node );

            }
         }
      }
   }
};

pub override fn convFilter.processExpRef(
   node: Nodes.ExpRefNode, opt: Opt ) mut
{
   if self.processMode == .Immediate {
      self.accessSymbolSet.add( node.$symbolInfo );
   }
   
   if node.$symbolInfo.$name == "super" {
      let funcType = node.$expType;
      self.write( "%s.%s" ( self.getFullName( funcType.$parentInfo ),
                            funcType.$rawTxt ) );
   }
   elseif node.$symbolInfo.$name == "__mod__" {
      self.write( "*lns_module_path" );
   }
   elseif node.$symbolInfo.$name == "..." {
      self.write( "_pDDD" );
   }
   else {
      if! let cFuncName = self.moduleCtrl.getBuiltinFuncNameFromType( node.$expType ) {
         self.write( cFuncName );
      }
      else {
         let symbolInfo = node.$symbolInfo;
         let valKind = self.scopeMgr.getSymbolValKind( symbolInfo );
         if valKind == .Var {
            self.write( "%s->stem" ( self.moduleCtrl.getSymbolName( symbolInfo )) );
            self.write( getAccessValFromStem( symbolInfo.$typeInfo ) );
         }
         else {
            // if symbolInfo.$accessMode == .Pub and
            //    symbolInfo.$kind == Ast.SymbolKind.Var
            // {
            //    if self.needModuleObj {
            //       self.write( "_moduleObj." );
            //    }
            // }
            if symbolInfo.$kind == .Fun or symbolInfo.$typeInfo.$kind == .Func {
               self.write( self.moduleCtrl.getFuncName( symbolInfo.$typeInfo ) );
            }
            else {
               //self.write( node.$symbolInfo.$name );
               if self.isManagedAnySymbol( symbolInfo ) {
                  self.write( "(*%s)" (self.moduleCtrl.getSymbolName( symbolInfo ) ) );
               }
               else {
                  self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
               }
            }
         }
      }
   }
};

pub override fn convFilter.processExpRefItem(
   node: Nodes.ExpRefItemNode, opt: Opt ) mut
{
   fn process() {
      self.write( "lns_stem_refAt( _pEnv, " );
      self.processVal2stem( node.$val, node );
      self.write( ", " );
      if! let index = node.$index {
         self.processVal2stem( index, node );
      }
      else {
         self.write(
            getLiteralStrStem( '"%s"' (unwrap node.$symbol) ) );
      }
      self.write( ")" );
   }
   
   if node.$nilAccess {
      processToIF( self.stream, self.moduleCtrl, node.$expType, process );
      return;
   }

   
   let val = node.$val;
   let valType = val.$expType;

   let parent = opt.node;
   
   if valType.equals( Ast.builtinTypeString ##) {
      // str のインデックスアクセスは、文字を返す
      self.accessPrimVal( val, node );
      self.write( "->val.str.pStr[" );
      if! let indexNode = node.$index {
         filter( indexNode, self, node );
      }
      else {
         error( "index is nil" );
      }
      self.write( "- 1 ]" );
   }
   elseif node.$isLValue {
      Util.err( "not support -- L-Value" );
   }
   else {
      processToIF( self.stream, self.moduleCtrl, node.$expType,
                   fn () {
                      switch valType.$kind {
                         case .List { 
                            self.write( "lns_mtd_List_refAt( _pEnv, " );
                            self.processVal2any( val, node );
                            self.write( ", " );
                            self.accessPrimVal( unwrap node.$index, node );
                            self.write( ")" );
                            self.write( getAccessValFromStem(
                               valType.$itemTypeInfoList[ 1 ] ) );
                         }
                         case .Map {
                            self.write( "lns_mtd_Map_get( _pEnv, " );
                            self.processVal2any( val, node );
                            self.write( ", " );
                            if! let index = node.$index {
                               self.processVal2stem( index, node );
                            }
                            else {
                               self.write(
                                  getLiteralStrStem( '"%s"' (unwrap node.$symbol) ) );
                            }
                            self.write( ")" );
                         }
                         case .Stem {
                            process();
                         }
                         default {
                            Util.err( "not support:%s -- %d:%d"
                               (valType.$kind.$_txt, __line__, node.$pos.lineNo) );
                         }
                      }
                   } );
   }
};

pub override fn convFilter.processRefField(
   node: Nodes.RefFieldNode, opt: Opt ) mut
{
   if node.$nilAccess {
      if! let symbolInfo = node.$symbolInfo {
         switch symbolInfo.$kind {
            case .Mbr {
               let prefixType = getOrgTypeInfo( node.$prefix.$expType );
               if prefixType.$kind == .Class {
                  self.write( "lns_refFieldNil( _pEnv, " );
                  self.processVal2stem( node.$prefix, node );
                  self.write( ", offsetof( %s, %s ), %s )"
                     ( self.moduleCtrl.getClassCName( prefixType ),
                       symbolInfo.$name,
                       getStemTypeId( symbolInfo.$typeInfo.$srcTypeInfo ) ) );
               }
               else {
                  Util.err( "not support -- " .. prefixType.getTxt(##) );
               }
            }
            default {
               Util.err( "not support -- " .. symbolInfo.$kind.$_txt );
            }
         }
      }
      else {
         Util.err( "not support" );
      }
      return;
   }

   
   if! let symbolInfo = node.$symbolInfo {
      if symbolInfo.$typeInfo.$kind == .Enum {
         if symbolInfo.$kind == .Mbr {
            if symbolInfo.$namespaceTypeInfo.$kind == .Enum {
               // enum 値の場合
               self.write( self.moduleCtrl.getEnumTypeName( symbolInfo.$typeInfo ) );
               self.write( "__%s" ( self.moduleCtrl.getSymbolName( symbolInfo )) );
               return;
            }
         }
         else {
            Util.err( "illegal access" );
         }
      }

      switch symbolInfo.$kind {
         case .Mbr {
            if node.$prefix.$expType.$kind == .Class {
               if symbolInfo.$staticFlag {
                  let symbolName = self.moduleCtrl.getClassMemberName( symbolInfo );
                  if self.isManagedAnySymbol( symbolInfo ) {
                     self.write( "(*%s)" (symbolName) );
                  }
                  else {
                     self.write( "%s" (symbolName) );
                  }
               }
               else {
                  let className = self.moduleCtrl.getClassCName( node.$prefix.$expType );
                  self.write( "lns_obj_%s( " (className) );
                  self.processVal2any( node.$prefix, node );
                  self.write( ")->%s" (node.$field.txt) );
               }
            }
         }
         case .Var {
            if node.$prefix.$expType.$kind == .Module {
               if symbolInfo.$staticFlag {
                  let symbolName = self.moduleCtrl.getSymbolName( symbolInfo);
                  if self.isManagedAnySymbol( symbolInfo ) {
                     self.write( "(*%s)" (symbolName) );
                  }
                  else {
                     self.write( "%s" (symbolName) );
                  }
               }
               else {
                  let className = self.moduleCtrl.getClassCName( node.$prefix.$expType );
                  self.write( "lns_obj_%s( " (className) );
                  self.processVal2any( node.$prefix, node );
                  self.write( ")->%s" (node.$field.txt) );
               }
            }
         }
         case .Mtd {
            if not symbolInfo.$staticFlag {
               Util.err( "not support yet. instanse method." );
            }
            self.write( self.moduleCtrl.getMethodCName( symbolInfo.$typeInfo ) );
         }
      }
   }
   
   // let parent = opt.node;

   // if node.$nilAccess {
   //    self.write( '_lune.nilacc( ' );
   //    filter( prefix,  self, node );
   //    self.write( ', "%s" )' (node.$field.txt) );
   // }
   // else {
   //    filter( prefix,  self, node );

   //    let mut delimit = ".";
   //    if parent.$kind == Nodes.NodeKind.$ExpCall {
   //       if node.get_expType().get_kind() == Ast.TypeInfoKind.Method {
   //          delimit = ":";
   //       }
   //       else {
   //          delimit = ".";
   //       }
   //    }
   //    let fieldToken = node.get_field();
   //    self.write( delimit .. fieldToken.txt );
   // }
};

pub override fn convFilter.processExpOmitEnum(
   node: &Nodes.ExpOmitEnumNode, opt: Opt ) mut
{
   self.write( self.moduleCtrl.getEnumValCName( node.$expType, node.$valInfo.$name ) );
   // match node.$valInfo.$val {
   //    case .Int( val ) {
   //       self.write( "%d" (val) );
   //    }
   //    case .Real( val ){
   //       self.write( "%g" (val) );
   //    }
   //    case .Str( val ) {
   //       self.write( "\"%s\"" (val) );
   //    }
   // }
   
   // self.write( "%s.%s" ( self.getFullName( node.$expType ), node.$valToken.txt ) );
};

pub override fn convFilter.processGetField(
   node: Nodes.GetFieldNode, opt: Opt ) mut
{
   let prefixNode = node.get_prefix();
   let prefixType = prefixNode.$expType.$nonnilableType;
   let fieldTxt = node.get_field().txt;

   switch prefixType.$kind {
      case .Enum {
         if node.$nilAccess {
            Util.err( "not support -- %d:%d:%s"
                      (__line__, node.$pos.lineNo, fieldTxt) );
         }
         let mut enumFullName = self.moduleCtrl.getEnumTypeName( prefixType );
         switch fieldTxt {
            case "_allList" {
               self.write( "%s_get__allList( _pEnv )" (enumFullName) );
            }
            case "_txt" {
               self.write( "%s_get__txt( _pEnv, " (enumFullName) );
               filter( prefixNode, self, node );
               self.write( ")" );
            }
            default {
               Util.err( "not support -- %d:%d:%s"
                         (__line__, node.$pos.lineNo, fieldTxt) );
            }
         }
      }
      case .Alge {
         if node.$nilAccess {
            Util.err( "not support -- %d:%d:%s"
                      (__line__, node.$pos.lineNo, fieldTxt) );
         }
         let algeName = self.moduleCtrl.getAlgeCName( prefixType );
         switch fieldTxt {
            case "_txt" {
               self.write( "%s_get__txt( _pEnv, " (algeName) );
               self.processVal2any( prefixNode, node );
               self.write( ")" );
            }
            default {
               Util.err( "not support -- %d:%d:%s"
                         (__line__, node.$pos.lineNo, fieldTxt) );
            }
         }
      }
      case .Class, .IF {
         let getterType = unwrap prefixType.$scope$.getTypeInfoField$(
            "get_%s" (fieldTxt), true, unwrap prefixType.$scope, scopeAccess );

         fn process() {
            if node.$nilAccess {
               let typeInfo = getCType( getterType.$retTypeInfoList[1] );
               switch typeInfo {
                  case cTypeInt {
                     self.write( "l_nil_mtd_getter_int( _pEnv, " );
                  }
                  case cTypeReal {
                     self.write( "l_nil_mtd_getter_real( _pEnv, " );
                  }
                  case cTypeBool {
                     self.write( "l_nil_mtd_getter_bool( _pEnv, " );
                  }
                  case cTypeAnyP {
                     self.write( "l_nil_mtd_getter_any( _pEnv, " );
                  }
                  case cTypeStem {
                     self.write( "l_nil_mtd_getter( _pEnv, " );
                  }
                  default {
                     Util.err( "not support -- %d:%d:%s"
                               (__line__, node.$pos.lineNo, fieldTxt) );
                  }
               }
               self.processVal2stem( prefixNode, node );
               self.write( ", " );
               self.write( self.moduleCtrl.getMethodCName( getterType ) );
               self.write( ")" );
            }
            else {
               self.write(
                  "%s( _pEnv" ( self.moduleCtrl.getCallMethodCName( getterType ) ) );
               if not getterType.$staticFlag {
                  self.write( ", " );
                  self.processVal2any( prefixNode, node );
               }
               self.write( ")" );

               processAlterAccessVal(
                  self.stream, getterType.$retTypeInfoList, node.$expTypeList );
            }
         }

         if #node.$expTypeList == 1 {
            processAlterToActualType(
               self.stream, self.moduleCtrl,
               getterType.$retTypeInfoList[1], node.$expType, process );
         }
         else {
            process();
         }
      }
      default {
         Util.err( "not support -- %d:%d:%s"
                   (__line__, node.$pos.lineNo, prefixType.$kind.$_txt) );
      }
   }

   
   // let mut fieldTxt = node.get_field().txt;
   // if fieldTxt == "_txt" and
   //     ( prefixType.$kind == .Enum or prefixType.$kind == .Alge )
   // {
   //    self.write( "%s:_getTxt( " (self.getFullName( prefixType ) ) );
   //    filter( prefixNode, self, node );
   //    self.writeln( ")" );
   // }
   // else {
   //    filter( prefixNode,  self, node );
   //    let mut delimit = ".";
   //    if node.get_getterTypeInfo().get_kind() == Ast.TypeInfoKind.Method {
   //       delimit = ":";
   //    }
   //    else {
   //       delimit = ".";
   //    }

   //    fieldTxt = "get_%s()" ( fieldTxt );
   //    self.write( delimit .. fieldTxt );
   // }
};


pub override fn convFilter.processReturn(
   node: Nodes.ReturnNode, opt: Opt ) mut
{
   let retTypeInfoList = self.routineInfoStack.current().$funcInfo.$retTypeInfoList;

   let blockStart;
   if! let expListNode = node.$expList {
      let expList = expListNode.$expList;
      let retKind = getRetKind( retTypeInfoList );
      let mut needSetRet = true;
      self.writeln( "{" );
      blockStart = true;
      self.pushIndent( ## );
      self.write( "%s _ret = " (getCRetType(retTypeInfoList)) );
      if #retTypeInfoList >= 2 {
         self.processCreateMRet( retTypeInfoList, expList, node );
      }
      elseif #retTypeInfoList == 1 {
         switch retKind {
            case .Stem {
               self.processVal2stem( expList[ 1 ], node );
            }
            case .Any {
               self.processVal2any( expList[ 1 ], node );
            }
            case .Prim {
               filter( expList[ 1 ], self, node );
            }
            default {
               Util.err( "no support -- %d" (__line__) );
            }
         }
      }
      else {
         //self.write( "_pEnv->pNilStem" );
      }
      self.writeln( ";" );
      if needSetRet {
         switch retKind {
            case .Stem {
               if self.routineInfoStack.$blockDepth == 1 {
                  self.writeln( "lns_setRet( _pEnv, _ret );" );
               }
               else {
                  self.writeln(
                     "lns_setRetAtBlock( LNS_BLOCK_AT( _pEnv, %d ), _ret );"
                     ( self.routineInfoStack.$blockDepth ) );
               }
            }
            case .Any {
               if self.routineInfoStack.$blockDepth == 1 {
                  self.writeln( "lns_setRet( _pEnv, LNS_STEM_ANY( _ret ) );" );
               }
               else {
                  self.writeln(
                     "lns_setRetAtBlock( LNS_BLOCK_AT( _pEnv, %d ), LNS_STEM_ANY( _ret ) );"
                     ( self.routineInfoStack.$blockDepth ) );
               }
            }
            case .Prim {
            }
            default {
               Util.err( "no support -- %d" (__line__) );
            }
         }
      }
   }
   else {
      blockStart = false;
   }

   if self.routineInfoStack.$blockDepth == 1 {
      self.writeln( "lns_leave_block( _pEnv );" );
   }
   else {
      self.writeln( "lns_leave_blockMulti( _pEnv, %d );"
                    ( self.routineInfoStack.$blockDepth ) );
   }


   if #retTypeInfoList ~= 0 {
      self.writeln( "return _ret;" );
   }
   else {
      self.writeln( "return;" );
   }

   if blockStart {
      self.popIndent();
      self.writeln( "}" );
   }
};

pub override fn convFilter.processTestBlock( node: Nodes.TestBlockNode, opt: Opt ) mut
{
   if not self.enableTest {
      return;
   }

   let moduleName = self.moduleCtrl.getFullName( self.moduleTypeInfo );
   fn processDecl() {
      self.write(
         "void %s__test_%s( %s _pEnv )"
         ( moduleName, node.$name.txt, cTypeEnvP ) );
   }
   
   switch self.processMode {
      case .Prototype {
         processDecl();
         self.writeln( ";" );
      }
      default {
         processDecl();
         self.writeln( "{" );
         self.pushIndent(##);
         
         self.writeln( 'printf( "%s:\\n" );' (node.$name.txt) );
         filter( node.$block, self, node );

         // pending: 本来はテスト実行と、結果出力は TestCtrl で行なうが、暫定でここで行なう。
         self.writeln( "lns_init_lune_base_Testing( _pEnv );" );
         self.writeln( "lune_base_Testing_outputAllResult( _pEnv, lns_io_stdout );" );

         self.popIndent();
         self.writeln( "}" );
      }
   }
}

pub override fn convFilter.processProvide(
   node: Nodes.ProvideNode, opt: Opt ) mut
{
}

pub override fn convFilter.processAlias(
   node: &Nodes.AliasNode, opt: Opt ) mut
{
   // self.write( "local %s = " (node.$newName) );
   // filter( node.$srcNode, self, node );
   // if Ast.isPubToExternal( node.$expType.$accessMode ) {
   //    self.write( "\n_moduleObj.%s = %s" (node.$newName, node.$newName) );
   // }
}

pub override fn convFilter.processBoxing(
   node: Nodes.BoxingNode, opt: Opt ) mut
{
   // self.write( "{" );

   // filter( node.$src, self, node );

   // self.write( "}" );
}

pub override fn convFilter.processUnboxing(
   node: Nodes.UnboxingNode, opt: Opt ) mut
{
   // filter( node.$src, self, node );
   // self.write( "[1]" );
}


fn convFilter.processLiteralVal( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   if self.processMode ~= .Immediate {
      let symbolList = exp.getSymbolInfo();
      if #symbolList > 0 {
         let work, valKind = self.scopeMgr.getCTypeForSym( symbolList[ 1 ] );
         if valKind ~= .Prim {
            // filter( exp, self, parent );
            self.processVal2stem( exp, parent );
            return;
         }
      }
   }
   let mut valType = exp.$expType.$srcTypeInfo;
   if! let enumType = valType@@@Ast.EnumTypeInfo {
      valType = enumType.$valTypeInfo;
   }
   
   switch valType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         self.write( "lns_imdInt( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeReal {
         self.write( "lns_imdReal( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeBool {
         self.write( "lns_imdBool( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeString {
         if! let strNode = exp@@@Nodes.LiteralStringNode { 
            if not strNode.$expList {
               self.write( "lns_imdStr( %s )" (str2cstr( strNode.$token.txt ) ) );
               return;
            }
         }
         self.write( "lns_imdAny( " );
         filter( exp, self, parent );
         //self.write( accessAny );
         self.write( ")" );
      }
      default {
         switch valType.$kind {
            case .List, .Set, .Map, .Array, .Class {
               self.write( "lns_imdAny( " );
               filter( exp, self, parent );
               //self.write( accessAny );
               self.write( ")" );
            }
            case .DDD {
               self.write( "lns_imdAny( " );
               self.processVal2any( exp, parent );
               self.write( ")" );
            }
            case .Alternate, .Stem, .Alge {
               self.write( "lns_imdStem( " );
               filter( exp, self, parent );
               self.write( ")" );
            }
            default {
               Util.err( "illegal type -- %s" (valType.getTxt(##)) );
            }
         }
      }
   }
}

fn getLiteralListFuncName( node: &Nodes.LiteralListNode ): str {
   return "lns_list_%X" (node.$id);
}

fn convFilter.processLiteralNode( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   switch exp.$kind {
      case Nodes.NodeKind.$LiteralList,
           Nodes.NodeKind.$LiteralMap,
           Nodes.NodeKind.$LiteralArray,
           Nodes.NodeKind.$LiteralSet
      {
         self.processingNode = exp;
         filter( exp, self, parent );
      }
      default {
         self.pushStream();
         filter( exp, self, parent );
         self.popStream();
      }
   }
}

fn convFilter.processLiteralListSub(
   collectionType:str, node:&Nodes.Node,
   expListNodeOrg:&Nodes.ExpListNode!, literalFuncName:str ) mut
{
   if self.processedNodeSet.has( node ) {
      if! let set = self.literalNode2AccessSymbolSet[ node ] { 
         foreach symbol in set.$list {
            self.accessSymbolSet.add( symbol );
         }
      }
      return;
   }
   self.processedNodeSet.add( node );
   let! expListNode = expListNodeOrg {
      return;
   };
   if #expListNode.$expList == 0 {
      return;
   }

   foreach exp in expListNode.$expList {
      self.processLiteralNode( exp, node );
   }
   self.processingNode = node;
   
   self.write(
      "static %s %s( %s _pEnv" (cTypeAnyP, literalFuncName, cTypeEnvP ) );
   foreach symbol in self.accessSymbolSet.$list {
      let valKind = self.scopeMgr.getSymbolValKind( symbol );
      let ctype;
      // if valKind == .Any {
      //    ctype = cTypeAnyP;
      // }
      // else {
         ctype = self.scopeMgr.getCTypeForSym( symbol );
      // }
      self.write( ", %s %s" ( ctype, self.moduleCtrl.getSymbolName( symbol ) ) );
   }
   self.writeln( ")" );
   self.writeln( "{" );
   
   self.pushIndent(##);
   self.write( "lns_imd%s( list" ( collectionType ) );
   self.pushIndent( ## );
   foreach exp in expListNode.$expList {
      self.write( ", " );
      self.processLiteralVal( exp, node );
   }
   self.popIndent();
   self.writeln( ");" );
   self.writeln( "return lns_create%s( _pEnv, list );" ( collectionType ) );
   self.popIndent();
   self.writeln( "}" );

   self.literalNode2AccessSymbolSet[ node ] = self.accessSymbolSet.clone();
}

pub override fn convFilter.processLiteralList(
   node: Nodes.LiteralListNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralListSub(
         "List", node, node.$expList, getLiteralListFuncName( node ) );
   }
   else {
      if node.$expList {
         self.write( "%s( _pEnv" ( getLiteralListFuncName( node ) ) );
         let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
            return;
         };
         foreach symbol in symbolSet.$list {
            self.write( ", %s" ( self.moduleCtrl.getSymbolName( symbol ) ) );
         }
         self.write( ")" );
      }
      else {
         self.write( "lns_class_List_new( _pEnv )" );
      }
   }
};


fn getLiteralSetFuncName( node: &Nodes.LiteralSetNode ): str {
   return "lns_set_%X" (node.$id);
}

pub override fn convFilter.processLiteralSet(
   node: Nodes.LiteralSetNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralListSub(
         "Set", node, node.$expList, getLiteralSetFuncName( node ) );
   }
   else {
      if node.$expList {
         self.write( "%s( _pEnv" ( getLiteralSetFuncName( node ) ) );
         let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
            return;
         };
         foreach symbol in symbolSet.$list {
            self.write( ", %s" ( self.moduleCtrl.getSymbolName( symbol ) ) );
         }
         self.write( ")" );
      }
      else {
         self.write( "lns_class_Set_new( _pEnv )" );
      }
   }
};


fn getLiteralMapFuncName( node: &Nodes.LiteralMapNode ): str {
   return "lns_map_%X" (node.$id);
}

fn convFilter.processLiteralMapSub( node:&Nodes.LiteralMapNode ) mut
{
   if self.processedNodeSet.has( node ) {
      if! let set = self.literalNode2AccessSymbolSet[ node ] { 
         foreach symbol in set.$list {
            self.accessSymbolSet.add( symbol );
         }
      }
      return;
   }
   self.processedNodeSet.add( node );
   let pairList = node.$pairList;
   if #pairList == 0 {
      return;
   }

   foreach pair in pairList {
      self.processLiteralNode( pair.$key, node );
      self.processLiteralNode( pair.$val, node );
   }
   self.processingNode = node;
   
   self.write(
      "static %s %s( %s _pEnv" (cTypeAnyP, getLiteralMapFuncName( node ), cTypeEnvP ) );
   foreach symbol in self.accessSymbolSet.$list {
      self.write( ", %s %s" (self.scopeMgr.getCTypeForSym( symbol ),
                              self.moduleCtrl.getSymbolName( symbol ) ) );             
   }
   self.writeln( ")" );
   self.writeln( "{" );
   
   self.pushIndent(##);
   self.write( "lns_imdMap( list" );
   self.pushIndent( ## );
   foreach pair in pairList {
      self.writeln( ", " );
      self.write( "{ " );
      self.processLiteralVal( pair.$key, node );
      self.write( ", " );
      self.processLiteralVal( pair.$val, node );
      self.write( "} " );
   }
   self.popIndent();
   self.writeln( ");" );
   self.writeln( "return lns_createMap( _pEnv, list );" );
   self.popIndent();
   self.writeln( "}" );

   self.literalNode2AccessSymbolSet[ node ] = self.accessSymbolSet.clone();
}


pub override fn convFilter.processLiteralMap(
   node: Nodes.LiteralMapNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralMapSub( node );
   }
   else {
      if #node.$pairList > 0 {
         self.write( "%s( _pEnv" ( getLiteralMapFuncName( node ) ) );
         let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
            return;
         };
         foreach symbol in symbolSet.$list {
            self.write( ", %s" ( self.moduleCtrl.getSymbolName( symbol ) ) );
         }
         self.write( ")" );
      }
      else {
         self.write( "lns_class_Map_new( _pEnv )" );
      }
   }
};

fn getLiteralArrayFuncName( node: &Nodes.LiteralArrayNode ): str {
   return "lns_array_%X" (node.$id);
}

pub override fn convFilter.processLiteralArray(
   node: Nodes.LiteralArrayNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralListSub(
         "List", node, node.$expList, getLiteralArrayFuncName( node ) );
   }
   else {
      if node.$expList {
         self.write( "%s( _pEnv" ( getLiteralArrayFuncName( node ) ) );
         let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
            return;
         };
         foreach symbol in symbolSet.$list {
            self.write( ", %s" ( self.moduleCtrl.getSymbolName( symbol ) ) );
         }
         self.write( ")" );
      }
      else {
         self.write( "lns_class_List_new( _pEnv )" );
      }
   }
};


pub override fn convFilter.processLiteralChar(
   node: Nodes.LiteralCharNode, opt: Opt ) mut
{
   self.write( string.format( "%d", node.$num ) );
};

pub override fn convFilter.processLiteralInt(
   node: Nodes.LiteralIntNode, opt: Opt ) mut
{
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralReal(
   node: Nodes.LiteralRealNode, opt: Opt ) mut
{
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralString(
   node: Nodes.LiteralStringNode, opt: Opt ) mut
{
   let mut txt = str2cstr( node.$token.txt );

   switch self.processMode {
      case .Prototype {
         if! let expListNode = node.$expList {
            if! let mRetExp = expListNode.$mRetExp {
               self.processCallWithMRet(
                  node, getMRetFuncName( node ), cTypeAnyP,
                  MRetInfo.Format( txt, expListNode ), expListNode );
            }
            else {
               self.write( "static %s lns_litstr_%d( %s _pEnv"
                             (cTypeAnyP, node.$id, cTypeEnvP ) );
               foreach exp, index in expListNode.$expList {
                  self.write( ", %s arg%d" ( cTypeStem, index ) );
               }
               self.writeln( ");" );
            }
         }
         return;
      }
      case .StringFormat {
         if! let expListNode = node.$expList {
            if! let mRetExp = expListNode.$mRetExp {
               //self.write( "%s( _pEnv" ( getMRetFuncName( node ) ) );
               // foreach exp, index in expListNode.$expList {
               //    if index > mRetExp.$index {
               //       break;   
               //    }
               //    self.write( ", " );
               //    filter( exp, self, node );
               // }
               self.processCallWithMRet(
                  node, getMRetFuncName( node ), cTypeAnyP, 
                  MRetInfo.Format( txt, expListNode ), expListNode );
            }
            else {
               self.write( "static %s lns_litstr_%d( %s _pEnv"
                  (cTypeAnyP, node.$id, cTypeEnvP ) );
               foreach exp, index in expListNode.$expList {
                  self.write( ", %s arg%d" ( cTypeStem, index ) );
               }
               self.writeln( ") // %d" (node.$pos.lineNo) );
               self.writeln( "{" );
               self.pushIndent( ## );

               self.write( "return mtd_lns_string_format( _pEnv, " );
               self.write( getLiteralStrAny( txt ) );
               self.write( ", " );

               let expList = expListNode.$expList;
               self.write( "lns_createDDD" );
               let lastExp = expList[ #expList ];
               self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );

               for index = 1, #expList {
                  self.write( ", arg%d" (index));
               }
               self.writeln( ") );" );
               
               self.popIndent();
               self.writeln( "}" );
            }
         }
         return;
      }
   }

  
   if! let expListNode = node.$expList {
      if! let mRetExp = expListNode.$mRetExp {
         self.write( "%s( _pEnv" ( getMRetFuncName( node ) ) );
         foreach exp, index in expListNode.$expList {
            if index > mRetExp.$index {
               break;   
            }
            self.write( ", " );
            filter( exp, self, node );
         }
         self.write(")" );
      }
      else {
         self.write( "lns_litstr_%d( _pEnv " ( node.$id ) );
         foreach exp in expListNode.$expList {
            self.write( ", " );
            self.processVal2stem( exp, node );
         }
         self.write(")" );
      }
   }
   else {
      let opList = TransUnit.findForm( txt );

      self.write( getLiteralStrAny( txt ) );
   }
};

pub override fn convFilter.processLiteralBool(
   node: Nodes.LiteralBoolNode, opt: Opt ) mut
{
   if node.$token.txt == "true" {
      self.write( "true" );
   }
   else {
      self.write( "false" );
   }
};

pub override fn convFilter.processLiteralNil(
   node: Nodes.LiteralNilNode, opt: Opt ) mut
{
   self.write( cValNil );
};

pub override fn convFilter.processBreak(
   node: Nodes.BreakNode, opt: Opt ) mut
{
   if self.loopInfoStack.$blockDepth > 1 {
      if self.loopInfoStack.$blockDepth == 2 {
         self.writeln( "lns_leave_block( _pEnv );" );
      }
      else {
         self.writeln( "lns_leave_blockMulti( _pEnv, %d );"
                       ( self.loopInfoStack.$blockDepth - 1 ) );
      }
   }
   self.write( "break;" );
};

pub override fn convFilter.processLiteralSymbol(
   node: Nodes.LiteralSymbolNode, opt: Opt ) mut
{
   // self.write( '%s' ( node.$symbolInfo.$name ) );
};

pub override fn convFilter.processAbbr(
   node: Nodes.AbbrNode, opt: Opt ) mut
{
   // self.write( cValNone );
   Util.err( "illegal" );
};


pub fn createFilter(
   enableTest:bool, outputBuiltin:bool, streamName: str, stream: oStream,
   headerStream: oStream, ast:&TransUnit.ASTInfo ) : Nodes.Filter<Opt>
{
   return new convFilter( enableTest, outputBuiltin,
                          streamName, stream, headerStream, ast );
}

pub fn outputBootcode( stream: oStream, launchModuleName:str )
{
   let mut srcStream = new Util.SimpleSourceOStream( stream, nil, stepIndent );

   let launchModulePath = launchModuleName.gsub( "%.", "/" );
   let moduleName = launchModuleName.gsub( "%.", "_" );
   srcStream.writeln( ```
#include <lunescript.h>
#include <%s.h>
    
void lns_run_module( %s _pEnv ) {
   %s pInfo = lns_init_%s( _pEnv );
   lns_test( _pEnv, pInfo );      
}
``` (launchModulePath, cTypeEnvP, cTypeModP, moduleName) );
}
