/*
MIT License

Copyright (c) 2018 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Ver;
import lune.base.Ast;
import lune.base.Nodes;
import lune.base.Util;
import lune.base.TransUnit;
import lune.base.frontInterface;
import lune.base.LuaMod;
import lune.base.LuaVer;
import lune.base.Parser;

let cTypeInt = "lune_int_t";
let cTypeReal = "lune_real_t";
let cTypeStem = "lune_stem_t";
let cTypeAny = "lune_any_t";
let cTypeAnyP = "lune_any_t *";
let cTypeEnvP = "lune_env_t *";
let cTypeVarP = "lune_var_t *";
let cValNil = "lune_global.nilStem";

let accessAny = ".val.pAny";

let stepIndent = 3;

/**
シンボルの C 出力名を取得する。
*/
fn getSymbolName( symbolInfo:&Ast.LowSymbol ): str {
   if Ast.isPubToExternal( symbolInfo.$accessMode ) {
      return symbolInfo.$name;
   }
   switch symbolInfo.$kind {
      case .Var {
         return "%s_%d" (symbolInfo.$name, symbolInfo.$symbolId );
      }
   }
   return symbolInfo.$name;
}

/**
funcType で示す関数がクロージャかどうかを返す。
*/
fn isClosure( funcType:&Ast.TypeInfo ): bool {
   if! let scope = funcType.$scope {
      return #scope.$closureSymList > 0;
   }
   return false;
}

class PubVerInfo {
   pub let staticFlag: bool;
   pub let accessMode: Ast.AccessMode;
   pub let mutable:bool;
   pub let typeInfo: &Ast.TypeInfo;
};

class PubFuncInfo {
   pub let accessMode: Ast.AccessMode;
   pub let typeInfo: &Ast.TypeInfo;
}

pub enum ConvMode {
   /** lns ソースを実行する */
   Exec,
   /** lua への変換を行なう */
   Convert,
   /** lua への変換と、 Meta 情報生成を行なう */
   ConvMeta,
}

class ModuleInfo extend (Ast.ModuleInfoIF){
   let assignName:str {pub};
   let modulePath:str {pub};
}

pub class Opt {
   pub let node:&Nodes.Node;
}

class RoutineInfo {
   let funcInfo:&Ast.TypeInfo {pub};
   let mut blockDepth:int {pub};

   pub fn __init( funcInfo:&Ast.TypeInfo ) {
      self.funcInfo = funcInfo;
      self.blockDepth = 1;
   }
   pub fn pushDepth() mut {
      self.blockDepth = self.blockDepth + 1;
   }
   pub fn popDepth() mut {
      self.blockDepth = self.blockDepth - 1;
   }
}


fn isStemType( valType:&Ast.TypeInfo ) : bool {
   let expType = valType.$srcTypeInfo;
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return false;
      }
      case Ast.builtinTypeReal {
         return false;
      }
      // case Ast.builtinTypeBool {
      //    return false;
      // }
      default {
         if! let enumType = expType@@@Ast.EnumTypeInfo {
            return isStemType( enumType.$valTypeInfo );
         }
         return true;
      }
   }
}

fn isStemRet( retTypeList:&List<&Ast.TypeInfo> ) : bool {
   switch #retTypeList {
      case 0 {
         return false;
      }
      case 1 {
         return isStemType( retTypeList[ 1 ] );
      }
   }
   return true;
}


fn getCType( valType:&Ast.TypeInfo, varFlag:bool ) : str {
   let expType = valType.$srcTypeInfo;
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return cTypeInt;
      }
      case Ast.builtinTypeReal {
         return "lune_real_t";
      }
      // case Ast.builtinTypeBool {
      //    return "lune_bool_t";
      // }
      default {
         if! let enumType = expType@@@Ast.EnumTypeInfo {
            return getCType( enumType.$valTypeInfo, varFlag );
         }
         if varFlag {
            return cTypeVarP;
         }
         return cTypeStem;
      }
   }
}

fn getCRetType( retTypeList:&List<&Ast.TypeInfo> ) : str {
   switch #retTypeList {
      case 0 {
         return "void";
      }
      case 1 {
         return getCType( retTypeList[ 1 ], false );
      }
   }
   return cTypeStem;
}

fn getBlockName( scope:&Ast.Scope ): str {
   return "pBlock_%X" ( scope.$scopeId );
}

/** 変換プロセス */
enum ProcessMode {
   /** プロトタイプ宣言 */
   Prototype,
   /** 大域変数 */
   WideScopeVer,
   /** モジュール初期化 */
   InitModule,
   /** 中間処理 */
   Intermediate,
   /** クラス定義 */
   DefClass,
   /** 内部関数 */
   Form,
   /** 即値 */
   Immediate,
}

class ModuleCtrl {
   //pri let mut typeInfo2ModuleName: Map<&Ast.TypeInfo,ModuleInfo>;
   pri let moduleInfoManager: &Ast.ModuleInfoManager;
   pri let typeNameCtrl: &Ast.TypeNameCtrl;
   

   pub fn __init( typeNameCtrl:&Ast.TypeNameCtrl,
                  moduleInfoManager: &Ast.ModuleInfoManager)
   {
      //self.typeInfo2ModuleName = {};
      self.typeNameCtrl = typeNameCtrl;
      self.moduleInfoManager = moduleInfoManager;
   }
   // pub fn add( moduleTypeInfo:&Ast.TypeInfo, moduleInfo:ModuleInfo ) mut {
   //    self.typeInfo2ModuleName[ moduleTypeInfo ] = moduleInfo;
   // }

   pub fn getFilePath( mut typeInfo:&Ast.TypeInfo ): str {
      let workName = typeInfo.getFullName(
         self.$typeNameCtrl, self.moduleInfoManager, false );
      let fullName = "%s" ( (workName.gsub( "[&@]", "" ).gsub( "%.", "/" ) ) );
      return fullName;
   }


   

   pub fn getFullName( mut typeInfo:&Ast.TypeInfo ): str {
      typeInfo = typeInfo.$srcTypeInfo;
      let workName = typeInfo.getFullName(
         self.$typeNameCtrl, self.moduleInfoManager, false );

      let fullName = "%s" ( (workName.gsub( "[&@]", "" ).gsub( "%.", "_" ) ) );
      if Ast.isPubToExternal( typeInfo.$accessMode ) {
         return fullName;
      }
      return "_%d_%s" (typeInfo.$typeId,fullName);
   }

   pub fn getAlgeCName( algeType:&Ast.TypeInfo ): str {
      return self.getFullName( algeType );
   }
   pub fn getAlgeEnumCName( algeType:&Ast.TypeInfo): str {
      return "lune_algeType_%s" (self.getAlgeCName( algeType ) );
   }
   pub fn getAlgeValCName( algeType:&Ast.TypeInfo, valName:str ): str {
      return "lune_alge_%s_%s" (self.getFullName( algeType ), valName);
   }
   pub fn getAlgeValStrCName( algeType:&Ast.TypeInfo, valName:str ): str {
      return "lune_alge_%s_%s_t" (self.getFullName( algeType ), valName );
   }
   pub fn getNewAlgeCName( algeType:&Ast.TypeInfo, valName:str ): str {
      return "lune_new_alge_%s_%s" (self.getFullName( algeType ), valName);
   }
  
   pub fn getAlgeInitCName( algeType:&Ast.TypeInfo ): str {
      return "lune_init_alge_%s" ( self.getAlgeCName( algeType ) );
   }


   pub fn getEnumTypeName( typeInfo: &Ast.TypeInfo ): str {
      let srcType = typeInfo.$srcTypeInfo;
      let fullName = self.getFullName( srcType );

      if Ast.isPubToExternal( typeInfo.$accessMode ) {
         return fullName;
      }
      return "%s_%d" (fullName, srcType.$typeId );
   }

   pub fn getEnumVal2NameMapName( enumType:&Ast.TypeInfo ): str {
      return "%s_val2NameMap" (self.getEnumTypeName( enumType ));
   }
   
   pub fn getFuncName( typeInfo:&Ast.TypeInfo ): str {
      if typeInfo.$rawTxt == "" {
         return "_anonymous_%d" (typeInfo.$typeId);
      }
      switch typeInfo.$accessMode {
         case .Pub, .Global {
            let builtinFunc = TransUnit.getBuiltinFunc();
            if typeInfo == builtinFunc.lune_print {
               return "lune_print";
            }
            return self.getFullName( typeInfo );
         }
      }
      return "lune_f_%d_%s" (typeInfo.$typeId, typeInfo.$rawTxt);
   }

   
   
   pub fn getClassCName( classType:&Ast.TypeInfo ) : str
   {
      return self.getFullName( classType );
   }

   pub fn getMethodCName( methodTypeInfo:&Ast.TypeInfo ) : str
   {
      return "u_mtd_%s_%s" ( self.getClassCName( methodTypeInfo.$parentInfo ),
                             methodTypeInfo.$rawTxt );
   }

   pub fn getCallMethodCName( methodTypeInfo:&Ast.TypeInfo ) : str
   {
      switch methodTypeInfo.$parentInfo.$kind {
         case .List {
            return "lune_mtd_List_%s" (methodTypeInfo.$rawTxt);
         }
         case .Array {
            return "lune_mtd_Array_%s" (methodTypeInfo.$rawTxt);
         }
         case .Set {
            return "lune_mtd_Set_%s" (methodTypeInfo.$rawTxt);
         }
         case .Map {
            return "lune_mtd_Map_%s" (methodTypeInfo.$rawTxt);
         }
      }
      return "u_call_mtd_%s_%s" ( self.getClassCName( methodTypeInfo.$parentInfo ),
                                  methodTypeInfo.$rawTxt );
   }

   pub fn getClassMemberName( symbolInfo:&Ast.SymbolInfo ):str {
      let classTypeInfo = symbolInfo.$scope.getClassTypeInfo();
      return "lune_var_%s_%s" ( self.getClassCName( classTypeInfo ),
                                symbolInfo.$name );
   }

   pub fn getFormName( typeInfo:&Ast.TypeInfo ):str {
      return "lune_form_%s" ( self.getFullName( typeInfo ) );
   }
   pub fn getCallFormName( typeInfo:&Ast.TypeInfo ):str {
      return "lune_call_formFunc_%s" ( self.getFullName( typeInfo ) );
   }
}

enum ValKind {
   /** プリミティブ型として扱う */
   Prim,
   // /** any 型として扱う */
   // Any,
   /** 作業用に作成した any 型として扱う */
   StemWork,
   /** メンバの any 型として扱う */
   StemMbr,
   /**stem 型として扱う */
   Stem,
   /** var 型として扱う */
   Var,
   /** */
   Other,
}

class SymbolParam {
   pub let kind:ValKind;
   /** スコープ内の何番目の変数として扱うか */
   pub let index:int;
   /** C で扱う時の変数の型名 */
   pub let typeTxt:str;
}

/**
C へのトランスコンパイル処理で新しく宣言する変数を管理する。

元の変数は Node 内の SymbolInfo を使用できるが、
トランスコンパイル処理で新しく宣言した変数は SymbolInfo が存在しないので、
それの代わり。
*/
class WorkSymbol extend (Ast.LowSymbol) {
   let mut scope:&Ast.Scope {pub};
   let mut accessMode:Ast.AccessMode {pub};
   let mut name:str {pub};
   let mut typeInfo:&Ast.TypeInfo {pub};
   let mut kind:Ast.SymbolKind {pub};
   let mut convModuleParam:SymbolParam {pub:stem!};

   pub fn get_symbolId() : int {
      return 0;
   }
   pub fn get_hasAccessFromClosure(): bool {
      return false;
   }
}


class ScopeInfo {
   /** スコープ内で宣言されている stem 型変数の数 */
   pub let anyNum:int;
   /** スコープ内で宣言されている var 型変数の数 */
   pub let varNum:int;
}

fn getOrgTypeInfo( typeInfo:&Ast.TypeInfo ) : &Ast.TypeInfo {
   if! let enumType = typeInfo.$srcTypeInfo.$nonnilableType@@@Ast.EnumTypeInfo {
      return enumType.$valTypeInfo;
   }
   return typeInfo.$srcTypeInfo.$nonnilableType;
}

fn getAccessPrimValFromSymbolDirect(
   symName:str, valKind:ValKind, symType:&Ast.TypeInfo ) mut :str
{
   let mut txt = symName;
   switch valKind {
      case .Var {
         txt = txt .. "->stem";
      }
      case .Stem {
      }
      case .Prim {
         return txt;
      }
   }

   switch getOrgTypeInfo( symType ) {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         txt = txt .. ".val.intVal";
      }
      case Ast.builtinTypeReal {
         txt = txt .. ".val.realVal";
      }
      case Ast.builtinTypeBool {
         txt = txt .. ".val.boolVal";
      }
   }
   return txt;
}


/**
スコープとシンボルを管理する。
*/
class ScopeMgr {
   pri let mut scope2InfoMap:Map<&Ast.Scope,&ScopeInfo>;

   pub fn __init() {
      self.scope2InfoMap = {};
   }

   pub fn setupScopeParam( scope:&Ast.Scope ) mut : int, int
   {
      if! let scopeInfo = self.scope2InfoMap[ scope ] {
         return scopeInfo.anyNum, scopeInfo.varNum;
      }

      // ローカル変数のうち、 stem として扱う変数を決定し、インデックスを紐付ける。
      let mut varNum = 0;
      let mut anyNum = 0;
      forsort symbol in scope.$symbol2SymbolInfoMap {
         let param;
         if symbol.$name ~= "__func__" {
            switch symbol.$kind {
               case .Var, .Arg {
                  if symbol.$hasAccessFromClosure {
                     // if isStemType( symbol.$typeInfo ) and symbol.$mutable {
                     //    // 次のシンボルは var 型で保持する。
                     //    // - stem 型を保持する
                     //    // - mutable
                     //    // この場合、シンボルに保持する stem データ自体が
                     //    // 入れ代わる可能性があるため var 型とする。
                     //    param = new SymbolParam( .Var, varNum, cTypeVarP );
                     //    varNum = varNum + 1;
                     // }
                     // else {
                     //    param = new SymbolParam( .Stem, anyNum, cTypeAnyP );
                     //    anyNum = anyNum + 1;
                     // }
                     param = new SymbolParam( .Var, varNum, cTypeVarP );
                     varNum = varNum + 1;
                  }
                  elseif isStemType( symbol.$typeInfo )
                  {
                     param = new SymbolParam( .Stem, anyNum, cTypeStem );
                     anyNum = anyNum + 1;
                  }
                  else {
                     param = new SymbolParam(
                        .Prim, 0, getCType( symbol.$typeInfo, false ) );
                  }
               }
               case .Mtd {
                  let retTypeList = symbol.$typeInfo.$retTypeInfoList;
                  if isStemRet( retTypeList ) {
                     param = new SymbolParam( .Other, 0, cTypeStem );
                  }
                  else {
                     param = new SymbolParam( .Prim, 0, getCRetType( retTypeList ) );
                  }
               }
               default {
                  if isStemType( symbol.$typeInfo ) {
                     if symbol.$kind == .Mbr {
                        param = new SymbolParam( .StemMbr, 0, cTypeStem );
                     }
                     else {
                        param = new SymbolParam( .Other, 0, cTypeStem );
                     }
                  }
                  else {
                     param = new SymbolParam(
                        .Prim, 0, getCType( symbol.$typeInfo, false ) );
                  }
               }
            }
         }
         else {
            param = new SymbolParam( .Stem, 0, cTypeStem );
         }
         symbol.set_convModuleParam( param );
      }

      self.scope2InfoMap[ scope ] = new ScopeInfo( anyNum, varNum );
      
      return anyNum, varNum;
   }

   pub fn getSymbolParam( symbol:&Ast.LowSymbol ) mut : &SymbolParam
   {
      if! let param = symbol.$convModuleParam {
         return param@@=SymbolParam;
      };
      let scope = symbol.$scope;

      if not self.scope2InfoMap[ scope ] {
         self.setupScopeParam( scope );
         if! let param = symbol.$convModuleParam {
            return param@@=SymbolParam;
         };
      }
      Util.err( "illegal symbol -- %s" (symbol.$name) );
   }

   pub fn getSymbolValKind( symbol:&Ast.LowSymbol ) mut : ValKind
   {
      let symbolParam = self.getSymbolParam( symbol );
      return symbolParam.kind;
   }

   pub fn getCTypeForSym( symbol:&Ast.LowSymbol ) mut : str, ValKind
   {
      let param = self.getSymbolParam( symbol );
      return param.typeTxt, param.kind;

      
      // let typeTxt;
      // if symbol.$hasAccessFromClosuer {
      //    return cTypeVarP, .Var;
      // }
      // typeTxt = getCType( symbol.$typeInfo, false );
      // if typeTxt == cTypeStem {
      //    if symbol.$kind == .Mbr {
      //       return typeTxt, .StemMbr;
      //    }
      //    return typeTxt, .Stem;
      // }
      // return typeTxt, .Prim;
   }

   pub fn symbol2Any( symbol:&Ast.LowSymbol ) mut : str
   {
      let name = getSymbolName( symbol );
      // if symbol.$hasAccessFromClosuer {
      switch self.getSymbolValKind( symbol ) {
         case .Var {
            return "1, " .. name;
         }
         case .Stem {
            return "0, " .. name;
         }
         default {
            switch symbol.$typeInfo.$srcTypeInfo {
               case Ast.builtinTypeInt, Ast.builtinTypeChar {
                  return "0, LUNE_STEM_INT( %s )" (name);
               }
               case Ast.builtinTypeReal {
                  return "0, LUNE_STEM_REAL( %s )" (name);
               }
               default {
                  Util.err( "not support -- %s" (symbol.$typeInfo.getTxt( ## )) );
               }
            }
         }
      }
   }

   pub fn getAccessPrimValFromSymbol( symbolInfo:&Ast.LowSymbol ) mut :str
   {
      return getAccessPrimValFromSymbolDirect(
         getSymbolName( symbolInfo ),
         self.getSymbolValKind( symbolInfo ), symbolInfo.$typeInfo );
   }

   pub fn getAccessPrimValFromSymbolOnly( symbolInfo:&Ast.LowSymbol ) mut :str
   {
      return getAccessPrimValFromSymbolDirect(
         "", self.getSymbolValKind( symbolInfo ), symbolInfo.$typeInfo );
   }

}

macro _out2Header( code:stat )
{
   {}
   self.stream = self.headerStream;

   ,,code;
   
   self.stream = self.sourceStream
}


class convFilter extend Nodes.Filter<Opt> {
   pri let streamName: str;
   // pri let mut stream: oStream;
   pri let mut sourceStream:Util.SimpleSourceOStream;
   pri let mut stream:Util.SimpleSourceOStream;
   pri let mut headerStream:Util.SimpleSourceOStream;
   pri let mut streamQueue: List<Util.SimpleSourceOStream>;

   pri let mut moduleCtrl:ModuleCtrl;
   
   // pri let mut indentQueue: List<int>;
   // pri let mut curLineNo: int;
   // pri let mut needIndent: bool;

   
   // クラス TypeId → TypeInfo
   pri let mut classId2TypeInfo: Map<int,&Ast.TypeInfo>;
   // クラス TypeId → Member Node List
   pri let mut classId2MemberList: Map<int,List<&Nodes.DeclMemberNode>>;
   // enum TypeId -> EnumTypeInfo
   pri let mut pubEnumId2EnumTypeInfo: Map<int,&Ast.EnumTypeInfo>;
   // enum TypeId -> AlgeTypeInfo
   pri let mut pubAlgeId2AlgeTypeInfo: Map<int,&Ast.AlgeTypeInfo>;
   // public 変数名 → 変数情報
   pri let mut pubVarName2InfoMap: Map<str,PubVerInfo>;
   // public 関数名 → 関数情報
   pri let mut pubFuncName2InfoMap: Map<str,PubFuncInfo>;
   pri let mut macroDepth: int;
   pri let moduleTypeInfo: &Ast.TypeInfo;
   pri let moduleSymbolKind: Ast.SymbolKind;
   pri let ast:Nodes.RootNode;
   pri let mut routineInfoQueue:List<RoutineInfo>;
   pri let mut currentRoutineInfo:RoutineInfo;
   pri let mut processMode:ProcessMode;
   pri let mut duringDeclFunc:bool;

   
   pri let mut processingNode: &Nodes.Node!;
   pri let mut processedNodeSet: Set<&Nodes.Node>;
   pri let mut accessSymbolSet: Util.OrderedSet<&Ast.SymbolInfo>;
   pri let mut literalNode2AccessSymbolSet:Map<&Nodes.Node,&Util.OrderedSet<&Ast.SymbolInfo>>;

   pri let mut scopeMgr:ScopeMgr;

   pub fn __init( streamName: str, stream: oStream,
                  headerStream: oStream, ast:&TransUnit.ASTInfo )
   {
      super(ast.$moduleTypeInfo, ast.$moduleTypeInfo.$scope);

      self.scopeMgr = new ScopeMgr();
      self.processingNode = nil;
      self.processedNodeSet = (@);
      self.accessSymbolSet = new Util.OrderedSet<&Ast.SymbolInfo>();
      self.literalNode2AccessSymbolSet = {};

      self.duringDeclFunc = false;

      self.processMode = .Prototype;

      self.routineInfoQueue = [];
      self.currentRoutineInfo = new RoutineInfo( Ast.builtinTypeNone );

      self.moduleTypeInfo = ast.$moduleTypeInfo;
      self.moduleSymbolKind = ast.$moduleSymbolKind;
      
      //Util.errorLog( "__init: %s" (mode) );
      self.ast = unwrap ast.$node@@@Nodes.RootNode;
      //self.indentQueue = [ 0 ];
      self.macroDepth = 0;
      self.streamName = streamName;
      //self.stream = stream;
      self.streamQueue = [];
      //self.curLineNo = 1;
      self.classId2TypeInfo = {};
      self.classId2MemberList = {};
      self.pubVarName2InfoMap = {};
      self.pubFuncName2InfoMap = {};
      self.pubEnumId2EnumTypeInfo = {};
      self.pubAlgeId2AlgeTypeInfo = {};
      //self.needIndent = false;

      self.moduleCtrl = new ModuleCtrl( self.$typeNameCtrl, self.$moduleInfoManager );

      self.currentRoutineInfo = new RoutineInfo( ast.$moduleTypeInfo );
      self.routineInfoQueue.insert( self.currentRoutineInfo );

      self.sourceStream = new Util.SimpleSourceOStream( stream, stepIndent );
      self.headerStream = new Util.SimpleSourceOStream( headerStream, stepIndent );
      self.stream = self.sourceStream;
   }

   /**
ストリームを新しく生成し、
生成したストリームを出力先のストリームに切り替える。

@return - 生成したストリーム
   */
   fn pushStream() mut : Util.memStream {
      self.streamQueue.insert( self.stream );
      let mut stream = new Util.memStream();
      self.stream = new Util.SimpleSourceOStream( stream, stepIndent );
      return stream;
   }

   /**
pushStream() で切り替えた出力ストリームを元に戻す。
   */
   fn popStream() mut {
      if #self.streamQueue == 0 {
         Util.err( "streamQueue is empty." );
      }
      self.stream = self.streamQueue[ #self.streamQueue ];
      self.streamQueue.remove(##);
   }


   

   fn getFullName( typeInfo:&Ast.TypeInfo ): str {
      return self.moduleCtrl.getFullName( typeInfo );
      // let mut enumName = typeInfo.getFullName( self.typeInfo2ModuleName, true );
      // return "%s" ( (enumName.gsub( "[&@]", "" ).gsub( "%.", "_" ) ) );
   }

   fn outputAlter2MapFunc( stream:Util.SourceStream, alt2Map:&Map<&Ast.TypeInfo,&Ast.TypeInfo>);


   advertise stream;
}

fn filter( node: &Nodes.Node, filter: convFilter,
           parent: &Nodes.Node )
{
   node.processFilter( filter, new Opt( parent ) );
}

// let mut builtInModuleSet:Set<str> = (@);
// builtInModuleSet.add( "io" );
// builtInModuleSet.add( "string" );
// builtInModuleSet.add( "table" );
// builtInModuleSet.add( "math" );
// builtInModuleSet.add( "debug" );


// fn convFilter.pushIndent( newIndent:int! ) mut {
//    let indent = unwrap newIndent default self.$indent + stepIndent;
//    self.indentQueue.insert( indent );
// }

// fn convFilter.popIndent() mut {
//    if #self.indentQueue == 0 {
//       Util.err( "self.indentQueue == 0" );
//    }
//    self.indentQueue.remove(##);
// }


// fn convFilter.writeln( txt: str ) mut {
//    self.write( txt );
//    self.write( "\n" );
//    self.needIndent = true;
// }

pub override fn convFilter.processNone(
   node: Nodes.NoneNode, opt: Opt ) mut
{
   //self.writeln( "-- none" );
};

pub override fn convFilter.processImport(
   node: Nodes.ImportNode, opt: Opt ) mut
{
   let module = node.get_modulePath();
   let mut moduleName = module.gsub( ".*%.", "" );
   moduleName = node.$assignName;
//   self.moduleCtrl.add( node.$moduleTypeInfo, new ModuleInfo( moduleName, module ) );
   // self.typeInfo2ModuleName[ node.$moduleTypeInfo ] =
   //    new ModuleInfo( moduleName, module );
   self.write( "local %s = _lune.loadModule( '%s' )" ( moduleName, module ) );
   //if self.convMode == "exe" or self.convMode == "ast" {
   // if self.convMode == .Exec {
   //    self.write( "local %s = _lune.loadModule( '%s' )" ( moduleName, module ) );
   // }
   // else {
   //    self.write( "local %s = require( '%s' )" ( moduleName, module ) );
   // }
};

fn getSymbolIndex( symbol:&Ast.SymbolInfo ) : int {
   let! param = symbol.$convModuleParam {
      return 0;
   };
   return (param@@=SymbolParam).index;
}

pub override fn convFilter.processRoot(
   node: Nodes.RootNode, opt: Opt ) mut
{
   Ast.pushProcessInfo( node.$processInfo );

   // node.visit(
   //    fn ( target:&Nodes.Node, parent:&Nodes.Node,
   //         releation:str, depth:int ): Nodes.NodeVisitMode
   //    {
   //       print( string.rep( "  ", depth ) .. Nodes.getNodeKindName( target.$kind ),
   //              releation );
   //       return .Child;
   //    }, 0 );
   
   self.writeln( "// %s" ( self.streamName ) );

   self.writeln( "#include <lunescript.h>" );
   self.writeln(
      "#include <%s.h>"
      ( self.moduleCtrl.getFilePath( node.$moduleTypeInfo ) ) );

   let children = node.get_children();

   self.processMode = .Prototype;
   foreach declEnumNode in node.$nodeManager.getDeclEnumNodeList() {
      filter( declEnumNode, self, node );
   }
   foreach declFormNode in node.$nodeManager.getDeclFormNodeList() {
      filter( declFormNode, self, node );
   }
   foreach declFuncNode in node.$nodeManager.getDeclFuncNodeList() {
      filter( declFuncNode, self, node );
   }
   foreach declAlgeNode in node.$nodeManager.getDeclAlgeNodeList() {
      filter( declAlgeNode, self, node );
   }
   foreach declClassNode in node.$nodeManager.getDeclClassNodeList() {
      filter( declClassNode, self, node );
   }
   foreach declConstrNode in node.$nodeManager.getDeclConstrNodeList() {
      filter( declConstrNode, self, node );
   }
   foreach declMethodNode in node.$nodeManager.getDeclMethodNodeList() {
      filter( declMethodNode, self, node );
   }
   foreach dddNode in node.$nodeManager.getExpToDDDNodeList() {
      filter( dddNode, self, node );
   }

   self.processMode = .WideScopeVer;
   foreach child in children {
      if child.$kind == Nodes.NodeKind.$DeclVar {
         filter( child, self, node );
      }
   }
   foreach declAlgeNode in node.$nodeManager.getDeclAlgeNodeList() {
      filter( declAlgeNode, self, node );
   }
   foreach declClassNode in node.$nodeManager.getDeclClassNodeList() {
      filter( declClassNode, self, node );
   }

   self.processMode = .Immediate;
   self.processedNodeSet = (@);

   fn procssLiteralCtor( literalNodeList:&List<&Nodes.Node> ) {
      foreach literalNode in literalNodeList {
         self.processingNode = literalNode;
         if not self.processedNodeSet.has( literalNode ) {
            self.accessSymbolSet = new Util.OrderedSet<&Ast.SymbolInfo>();
            filter( literalNode, self, node );
            self.processedNodeSet.add( node );
         }
      }
   }
   procssLiteralCtor( node.$nodeManager.getLiteralListNodeList() );
   procssLiteralCtor( node.$nodeManager.getLiteralArrayNodeList() );
   procssLiteralCtor( node.$nodeManager.getLiteralSetNodeList() );
   procssLiteralCtor( node.$nodeManager.getLiteralMapNodeList() );
   self.processingNode = nil;


   self.processMode = .Intermediate;
   foreach callNode in node.$nodeManager.getExpCallNodeList() {
      filter( callNode, self, node );
   }
   foreach dddNode in node.$nodeManager.getExpToDDDNodeList() {
      filter( dddNode, self, node );
   }

   self.processMode = .DefClass;
   foreach declClassNode in node.$nodeManager.getDeclClassNodeList() {
      filter( declClassNode, self, node );
   }
   
   self.processMode = .Form;
   foreach declFormNode in node.$nodeManager.getDeclFormNodeList() {
      filter( declFormNode, self, node );
   }
   foreach declFuncNode in node.$nodeManager.getDeclFuncNodeList() {
      self.duringDeclFunc = false;
      filter( declFuncNode, self, node );
   }
   foreach declEnumNode in node.$nodeManager.getDeclEnumNodeList() {
      filter( declEnumNode, self, node );
   }
   foreach declAlgeNode in node.$nodeManager.getDeclAlgeNodeList() {
      filter( declAlgeNode, self, node );
   }
   foreach declConstrNode in node.$nodeManager.getDeclConstrNodeList() {
      filter( declConstrNode, self, node );
   }
   foreach declMethodNode in node.$nodeManager.getDeclMethodNodeList() {
      filter( declMethodNode, self, node );
   }

   
   
   self.processMode = .InitModule;
   self.writeln( "void lune_init_test( %s _pEnv )" (cTypeEnvP) );
   self.writeln( "{" );

   self.pushIndent(##);

   let anyNum, varNum = self.scopeMgr.setupScopeParam( self.ast.$moduleScope );
   
   self.writeln( "lune_block_t * %s = lune_enter_module( %d, %d );"
                 (getBlockName( self.ast.$moduleScope ), anyNum, varNum ) );

   // init ブロック内の managedStemTop 用ブロック作成
   self.writeln( "lune_enter_block( _pEnv, 0, 0 );" );

   foreach declAlgeNode in node.$nodeManager.getDeclAlgeNodeList() {
      filter( declAlgeNode, self, node );
   }
   
   foreach child in children {
      switch child.$kind {
         case Nodes.NodeKind.$DeclAlge,
              //Nodes.NodeKind.$DeclClass,
              Nodes.NodeKind.$DeclFunc,
              Nodes.NodeKind.$DeclMacro
         {
            //filter( child, self, node );
            //self.writeln( "" );
         }
         default {
            filter( child, self, node );
            self.writeln( "" );
         }
      }
   }

   // init ブロック内の managedStemTop 用ブロックの開放
   self.writeln( "lune_leave_block( _pEnv );" );
   
   self.popIndent();

   self.writeln( "}" );

   Ast.popProcessInfo();
};

pub override fn convFilter.processSubfile(
   node: Nodes.SubfileNode, opt: Opt ) mut
{
}

fn getAccessPrimValFromStem( dddFlag:bool, typeInfo:&Ast.TypeInfo, index:int ) :str
{
   let mut txt = "";
   if dddFlag {
      txt = ".val.pAny->val.ddd.stemList[ %d ]" (index);
   }

   let expType;

   if! let enumType = typeInfo.$srcTypeInfo@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }
   else {
      expType = typeInfo.$srcTypeInfo;
   }
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         txt = txt .. ".val.intVal";
      }
      case Ast.builtinTypeReal {
         txt = txt .. ".val.realVal";
      }
      case Ast.builtinTypeBool {
         txt = txt .. ".val.boolVal";
      }
      default {
         txt = txt .. ".val.pAny";
      }
   }
   return txt;
}

fn getAccessValFromStem( typeInfo:&Ast.TypeInfo ) :str
{
   let txt;

   let expType;

   if! let enumType = typeInfo.$srcTypeInfo@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }
   else {
      expType = typeInfo.$srcTypeInfo;
   }
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         txt = ".val.intVal";
      }
      case Ast.builtinTypeReal {
         txt = ".val.realVal";
      }
      case Ast.builtinTypeStem {
         txt = "";
      }
      default {
         //txt = ".val.pAny";
         txt = "";
      }
   }
   return txt;
}

fn convFilter.processBlockPreProcess( blockNode:&Nodes.BlockNode ) mut {
   self.pushIndent( ## );
   let anyNum, varNum = self.scopeMgr.setupScopeParam( blockNode.$scope );
   self.writeln( "lune_block_t * %s = lune_enter_block( _pEnv, %d, %d );"
                 ( getBlockName( blockNode.$scope ), anyNum, varNum ) );
   self.currentRoutineInfo.pushDepth();
}

fn convFilter.processBlockPostProcess() mut {
   self.currentRoutineInfo.popDepth();
   self.writeln( "lune_leave_block( _pEnv );" );
   self.popIndent();
}

fn convFilter.pushRoutine( funcType:&Ast.TypeInfo, blockNode:&Nodes.BlockNode ) mut {
   self.processBlockPreProcess( blockNode );
   self.currentRoutineInfo = new RoutineInfo( funcType );
   self.routineInfoQueue.insert( self.currentRoutineInfo );
}

fn convFilter.popRoutine() mut {
   self.currentRoutineInfo = self.routineInfoQueue[ #self.routineInfoQueue - 1 ];
   self.routineInfoQueue.remove( ## );
   self.processBlockPostProcess();
}

fn convFilter.processLoopPreProcess( blockNode:&Nodes.BlockNode ) mut {
   self.processBlockPreProcess( blockNode );
}

fn convFilter.processLoopPostProcess() mut {
   self.processBlockPostProcess();
}

pub override fn convFilter.processBlockSub(
   node: Nodes.BlockNode, opt: Opt ) mut
{
   // ローカル変数のうち、 any として扱う変数を決定し、インデックスを紐付ける。
   let anyNum, varNum = self.scopeMgr.setupScopeParam( node.$scope );

   // クロージャでアクセスする外部変数を宣言
   let scope = node.$scope;
   forsort symbol in scope.$closureSymMap {
      // if symbol.$accessFromClosure == .Write {
      //    self.write( cTypeVarP );
      // }
      // else {
      //    self.write( cTypeStem );
      // }
      let typeTxt, valKind = self.scopeMgr.getCTypeForSym( symbol );
      let macroName;
      if valKind == .Stem {
         macroName = "lune_form_closure_any";
      }
      else {
         macroName = "lune_form_closure_var";
      }
      self.write(
         "%s %s = %s( _pForm, %d )"
         ( typeTxt, getSymbolName( symbol ), macroName,
           unwrap scope.$closureSym2NumMap[ symbol ] ) );
      // if valKind == .Stem {
      //    self.write( getAccessPrimValFromStem( false, symbol.$typeInfo, 1 ) );
      // }
      self.writeln( ";" );
   }

   let mut loopFlag = false;
   let mut readyBlock = false;
   
   let mut word = "";
   switch node.get_blockKind() {
      case .If, .Elseif {
         word = "{";
      }
      case .Else {
         word = "";
      }
      case .While {
         word = "{";
         loopFlag = true;
      }
      case .Repeat {
         word = "";
         loopFlag = true;
      }
      case .For {
         word = "";
         loopFlag = true;
      }
      case .Apply {
         word = "{";
         loopFlag = true;
      }
      case .Foreach {
         word = "";
         loopFlag = true;
      }
      case .Macro {
         word = "";
      }
      case .Func {
         readyBlock = true;
         word = "";
      }
      case .Default {
         word = "";
      }
      case .Block {
         word = "{";
      }
      case .Macro {
         word = "";
      }
      case .LetUnwrap {
         word = "";
      }
      case .IfUnwrap {
         readyBlock = true;
         word = "";
      }
      case .When {
         readyBlock = true;
         word = "";
      }
   }
   if loopFlag {
      readyBlock = true;
   }
   
   
   self.writeln( "%s // %d" ( word, node.$pos.lineNo ) );

   if not readyBlock {
      self.processBlockPreProcess( node );
   }
   // if loopFlag {
   //    self.writeln( "lune_reset_block( _pEnv );" );
   // }
   
   let stmtList = node.get_stmtList();
   foreach statement in stmtList {
      filter( statement, self, node );
      self.writeln( "" );
   }

   if not readyBlock {
      self.processBlockPostProcess();
   }
   
   if node.get_blockKind() == .Block {
      self.writeln( "}" );
   }
};

pub override fn convFilter.processStmtExp(
   node: Nodes.StmtExpNode, opt: Opt ) mut
{
   filter( node.$exp,  self, node );
   self.write( "; // %d" (node.$pos.lineNo) );
};

fn getLiteral2Any( valTxt:str, typeInfo:&Ast.TypeInfo ) : str {
   switch typeInfo.$srcTypeInfo {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return "LUNE_STEM_INT( %s )" (valTxt);
      }
      case Ast.builtinTypeReal {
         return "LUNE_STEM_REAL( %s )" (valTxt);
      }
      default {
         return "NULL";
      }
   }
}

fn getStemTypeId( typeInfo:&Ast.TypeInfo ): str {
   switch getOrgTypeInfo( typeInfo ) {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return "lune_stem_type_int";
      }
      case Ast.builtinTypeInt, Ast.builtinTypeReal {
         return "lune_stem_type_real";
      }
      default {
         return "lune_stem_type_any";
      }
   }
}

fn convFilter.getPrepareClosure(
   funcName:str, argNum:int, hasDDD:bool, symList:&List<&Ast.SymbolInfo> ) mut : str
{
   let mut txt;

   txt = "lune_func2stem( _pEnv, (lune_closure_t *)%s, %d, %s, %d"
       (funcName, argNum, hasDDD, #symList );
   foreach symbolInfo in symList {
      txt = txt .. ", ";
      txt = txt .. self.scopeMgr.symbol2Any( symbolInfo );
   }
   txt = txt .. ")";
   return txt;
}


fn convFilter.getFunc2stem( funcType:&Ast.TypeInfo ) mut : str
{
   let argList = funcType.$argTypeInfoList;
   let hasDDD =
      #argList > 0 and argList[ #argList ].$kind == .DDD or false;
   
   return self.getPrepareClosure(
      self.moduleCtrl.getFuncName( funcType ), #funcType.$argTypeInfoList,
      hasDDD, (unwrap funcType.$scope).$closureSymList );
}


fn convFilter.processSym2stem( symbolInfo:&Ast.LowSymbol) mut
{
   let mut expType = symbolInfo.$typeInfo.$srcTypeInfo;
   if! let enumType = expType@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }

   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         self.write( "LUNE_STEM_INT( " );
         self.write( "" );
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbolInfo ) );
         self.write( ")" );
      }
      case Ast.builtinTypeReal {
         self.write( "LUNE_STEM_REAL( " );
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbolInfo ) );
         self.write( ")" );
      }
      case Ast.builtinTypeStem, Ast.builtinTypeStem_ {
         self.write( getSymbolName( symbolInfo ) );
      }
      default {
         switch expType.$kind {
            case .DDD {
               self.write( "_pDDD" );
            }
            case .Func {    
               if! let scope = expType.$scope {
                  self.write( self.getFunc2stem( expType ) );
               }
               else {   
                  Util.err( "illegal func" );
               }
            }
            default {
               self.write( getSymbolName( symbolInfo ) );
            }
         }
      }
   }
}

pub override fn convFilter.processDeclEnum(
   node: Nodes.DeclEnumNode, opt: Opt ) mut
{
   let enumType = unwrap node.$expType@@@Ast.EnumTypeInfo;

   let enumFullName = self.moduleCtrl.getEnumTypeName( enumType );
   let fullName = self.getFullName( enumType );

   let isStrEnum = enumType.$valTypeInfo.equals( Ast.builtinTypeString ##);
   
   switch self.processMode {
      case .Prototype {
         foreach valName, index in node.$valueNameList {
            let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
            if isStrEnum {
               self.writeln( "%s %s__%s;" (cTypeStem,enumFullName, valName.txt));
            }
            else {
               let valTxt = "%s" (Ast.getEnumLiteralVal(valInfo.$val));
               self.writeln( "#define %s__%s %s" (enumFullName, valName.txt, valTxt ) );
            }
         }
         
         self.writeln( "%s %s_val2NameMap;" (cTypeAnyP, enumFullName) );
         self.writeln( "%s %s_allList;" (cTypeStem, enumFullName) );
      }
      case .Form {
         self.writeln(
            "%s %s_get__allList( lune_env_t * _pEnv )"
            (cTypeStem, enumFullName) );
         self.writeln( "{" );
         self.writeln( "    return %s_allList;" (enumFullName) );
         self.writeln( "}" );

         if not isStrEnum {
            let typeTxt;
            if enumType.$valTypeInfo.$srcTypeInfo == Ast.builtinTypeReal {
               typeTxt = "real";
            }
            else {
               typeTxt = "int";
            }
         }

         if not Ast.isPubToExternal( enumType.$accessMode ) {
            self.writeln( "static " );
         }
         self.writeln( "%s %s_get__txt( %s _pEnv, %s val ) {"
            ( cTypeStem, enumFullName, cTypeEnvP,
              getCType( enumType.$valTypeInfo, false ) ) );
         self.pushIndent( ## );

         self.write( "%s _work =  lune_mtd_Map_get( _pEnv, %s, "
                     ( cTypeStem,
                       self.moduleCtrl.getEnumVal2NameMapName( enumType ) ) );
         if isStemType( enumType.$valTypeInfo ) {
            self.writeln( "val );" );
         }
         else {
            let workSym = new WorkSymbol(
               unwrap self.moduleTypeInfo.$scope,
               .Local, "val", enumType.$valTypeInfo, .Arg,
               new SymbolParam( .Prim, -1, getCType( enumType.$valTypeInfo, false ) ) );
               
            self.processSym2stem( workSym );
            self.writeln( ");" );
         }
         self.writeln( "return _work;"  );
         
         self.popIndent();
         self.writeln( "}" );
         
         
         self.writeln( "void init_%s( lune_env_t * _pEnv )" ( enumFullName ) );
         self.writeln( "{" );
         self.pushIndent(##);



         let mut anyVarList:List<str> = [];
         // enum 値のセット
         if isStrEnum {
            foreach valName, index in node.$valueNameList {
               let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
               // pending: C の文字列リテラル表現できないものを対応できていない
               let valTxt = '"%s"' (Ast.getEnumLiteralVal(valInfo.$val));
               let anyVar = "%s__%s" (enumFullName, valName.txt);
               anyVarList.insert( anyVar );

               // self.writeln( "lune_setQ( %s, lune_litStr2stem( _pEnv, %s ) );"
               //               (anyVar, valTxt));
               self.writeln( "%s = lune_litStr2stem( _pEnv, %s );" (anyVar, valTxt));
            }
         }
         else {
            foreach valName, index in node.$valueNameList {
               let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
               let valTxt = '%s' (Ast.getEnumLiteralVal(valInfo.$val));
               let anyVar = "_%s" (valName.txt);
               anyVarList.insert( anyVar );
               self.write( "%s %s = " (cTypeStem, anyVar));
               self.write( getLiteral2Any( valTxt, enumType.$valTypeInfo ) );
               self.writeln( ";" );
            }
         }

         // _allList のセット
         self.write( "%s_allList = " (enumFullName) );
         self.writeln( "lune_class_List_new( _pEnv );" );
         
         foreach anyVar in anyVarList {
            self.writeln(
               "lune_mtd_List_insert( _pEnv, %s_allList%s, %s );"
               (enumFullName, accessAny, anyVar ));
         }

         // _val2NameMap のセット
         self.write( "%s_val2NameMap = " (enumFullName) );
         self.writeln( "lune_class_Map_new( _pEnv ).val.pAny;"  );
         
         foreach anyVar, index in anyVarList {
            self.writeln(
               "lune_mtd_Map_add( _pEnv, %s_val2NameMap, %s, "
               (enumFullName, anyVar ));
            
            self.writeln(
               '  lune_litStr2stem( _pEnv, "%s.%s" ) );'
               (fullName, node.$valueNameList[ index ].txt));
         }
         

         self.popIndent();
         self.writeln( "}" );
      }
      case .InitModule {
         self.writeln( "init_%s( _pEnv );" ( enumFullName ) );
      }
   }
   
   

   
//    let mut access = node.$accessMode == .Global and "" or "local ";
//    let mut enumFullName = node.$name.txt;
//    let enumType = unwrap node.$expType@@@Ast.EnumTypeInfo;
//    let parentInfo = enumType.$parentInfo;
//    let mut isTopNS = true;
//    if parentInfo ~= Ast.headTypeInfo and parentInfo.$kind == .Class {
//       enumFullName = "%s.%s" (self.getFullName( parentInfo ), enumFullName );
//       access = "";
//       isTopNS = false;
//    }


//    self.writeln( "%s%s = {}" (access, enumFullName) );
//    if isTopNS and node.$accessMode == .Pub {
//       if self.needModuleObj {
//          self.writeln( "_moduleObj.%s = %s" ( enumFullName, enumFullName ) );
//       }
//    }


//    if enumType.$accessMode == .Pub {
//       self.pubEnumId2EnumTypeInfo[ enumType.$typeId ] = enumType;
//    }

//    self.writeln( "%s._val2NameMap = {}" (enumFullName) );
//    self.writeln( ```function %s:_getTxt( val )
//    local name = self._val2NameMap[ val ]
//    if name then
//       return string.format( "%s.%%s", name )
//    end
//    return string.format( "illegal val -- %%s", val )
// end
// function %s._from( val )
//    if %s._val2NameMap[ val ] then
//       return val
//    end
//    return nil
// end
//     ``` (enumFullName, enumFullName,
//           enumFullName, enumFullName ) );
//    self.writeln(
// ```
// %s.__allList = {}
// function %s.get__allList()
//    return %s.__allList
// end
// ``` (enumFullName, enumFullName, enumFullName ) );

//    foreach valName, index in node.$valueNameList {
//       let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
//       let mut valTxt = "%s" (Ast.getEnumLiteralVal(valInfo.$val));
//       if enumType.$valTypeInfo.equals( Ast.builtinTypeString ##) {
//          valTxt = "'%s'" (Ast.getEnumLiteralVal(valInfo.$val));
//       }
//       self.writeln( "%s.%s = %s" (enumFullName, valName.txt, valTxt ) );

//       self.writeln( "%s._val2NameMap[%s] = '%s'"
//          (enumFullName, valTxt, valName.txt ) );
//       self.writeln( "%s.__allList[%d] = %s.%s"
//          (enumFullName, index, enumFullName, valName.txt ) );
//    }
}

fn isGenericType( typeInfo:&Ast.TypeInfo ): bool {
   if Ast.isGenericType( typeInfo ) {
      return true;
   }
   switch typeInfo.$kind {
      case .Class, .IF {
         if #typeInfo.$itemTypeInfoList > 0 {
            return true;
         }
      }
   }
   return false;
}



// fn convFilter.getMapInfo( typeInfo:&Ast.TypeInfo ): str, bool, str
// {
   // let mut nonnilableType = typeInfo.$srcTypeInfo;
   // if typeInfo.$nilable {
   //    nonnilableType = typeInfo.$nonnilableType;
   // }

   // let mut child = "{}";
   // let mut funcTxt = "";
   // switch nonnilableType.$kind {
   //    case .Stem {
   //       funcTxt = '_lune._toStem';
   //    }
   //    case .Class, .IF {
   //       if not nonnilableType.equals( Ast.builtinTypeString ##) {
   //          funcTxt = '%s._fromMap' (self.getFullName(nonnilableType));
   //          if isGenericType( nonnilableType ) {
   //             let mut memStream = new Util.memStream();
   //             self.outputAlter2MapFunc(
   //                memStream, nonnilableType.createAlt2typeMap(false) );
   //             child = memStream.$txt;
   //          }
   //       }
   //       else {
   //          funcTxt = '_lune._toStr';
   //       }
   //    }
   //    case .Enum, .Alge {
   //       funcTxt = '%s._from' (self.getFullName(nonnilableType));
   //    }
   //    case .Prim {
   //       switch nonnilableType {
   //          case Ast.builtinTypeInt {
   //             funcTxt = '_lune._toInt';
   //          }
   //          case Ast.builtinTypeReal {
   //             funcTxt = '_lune._toReal';
   //          }
   //          case Ast.builtinTypeBool {
   //             funcTxt = '_lune._toBool';
   //          }
   //          default {
   //             Util.err( "unknown type -- %s" (nonnilableType.getTxt(##)) );
   //          }
   //       }
   //    }
   //    case .Map {
   //       funcTxt = '_lune._toMap';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let keyFuncTxt, keyNilable, keyChild = self.getMapInfo( itemList[1] );
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[2] );

   //       child = "{ { func = %s, nilable = %s, child = %s }, \n"
   //           (keyFuncTxt, keyNilable, keyChild) ..
   //          "{ func = %s, nilable = %s, child = %s } }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .Set {
   //       funcTxt = '_lune._toSet';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[1] );

   //       child = "{ func = %s, nilable = %s, child = %s }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .List, .Array {
   //       funcTxt = '_lune._toList';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[1] );

   //       child = "{ { func = %s, nilable = %s, child = %s } }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .Alternate {
   //       let prefix = "obj.__alt2mapFunc.%s" ( nonnilableType.$rawTxt );
   //       funcTxt = "%s.func" ( prefix );
   //       child = "%s.child" ( prefix );
   //    }
   // }
   // return funcTxt, typeInfo.$nilable, child;
// }

fn processAlgeNewProto( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                        typeInfo:&Ast.TypeInfo, valInfo:&Ast.AlgeValInfo )
{
   stream.write(
      "%s %s( %s _pEnv"
      ( cTypeStem,
        moduleCtrl.getNewAlgeCName( typeInfo, valInfo.$name ), cTypeEnvP ) );

   foreach typeInfo, index in valInfo.$typeList {
      stream.write( ", %s _val%d" (getCType( typeInfo, false ), index) );
   }
   stream.write( ")" );
}

fn processAlgePrototype( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                         node:Nodes.DeclAlgeNode )
{
   let algeType = node.$algeType;
   let mut valList:List<&Ast.AlgeValInfo> = [];
   
   forsort valInfo in algeType.$valInfoMap {
      valList.insert( valInfo );
   }


   // 各値を識別する enum を宣言
   stream.writeln( "typedef enum {" );
   stream.pushIndent( ## );
   let algeTypeName = moduleCtrl.getAlgeCName( node.$expType );
   let enumName = moduleCtrl.getAlgeEnumCName( node.$expType );

   foreach valInfo, index in valList {
      if index > 1 {
         stream.writeln( "," );
      }
      stream.write( "%s_%s" (enumName, valInfo.$name) );
   }
   stream.writeln( "" );
   stream.popIndent();
   stream.writeln( "} %s;" ( enumName ) );

   // alge 型の struct を宣言
   foreach valInfo in valList {
      if #valInfo.$typeList > 0 {
         stream.writeln( "typedef struct {" );
         stream.pushIndent(##);
         foreach typeInfo, index in valInfo.$typeList {
            stream.writeln( "%s _val%d;" (getCType( typeInfo, false ), index) );
         }
         stream.popIndent();
         stream.writeln(
            "} %s;" (moduleCtrl.getAlgeValStrCName( node.$expType, valInfo.$name) ) );
      }
   }

   // alge 型のパラメータ無しの値を初期化する関数宣言
   stream.writeln(
      "static void %s( %s _pEnv );"
      (moduleCtrl.getAlgeInitCName(node.$expType), cTypeEnvP ) );

   // alge 型のパラメータ有りの値を生成する関数宣言
   foreach valInfo in valList {
      if #valInfo.$typeList > 0 {
         processAlgeNewProto( stream, moduleCtrl, node.$expType, valInfo );
         stream.writeln( ";" );
      }
   }
}

fn processAlgeWideScope( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                         node:Nodes.DeclAlgeNode )
{
   let algeType = node.$algeType;
   let mut valList:List<&Ast.AlgeValInfo> = [];
   
   forsort valInfo in algeType.$valInfoMap {
      valList.insert( valInfo );
   }

   let algeTypeName = moduleCtrl.getAlgeCName( node.$expType );

   foreach valInfo, index in valList {
      if #valInfo.$typeList == 0 {
         let varName = moduleCtrl.getAlgeValCName( node.$expType, valInfo.$name );
         stream.writeln(
            "%s %s;" (cTypeStem, varName ) );
         stream.writeln(
            "%s %s_any;" (cTypeAny, varName ) );
      }
   }
}

fn processAlgeForm( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                    node:Nodes.DeclAlgeNode )
{
   let algeType = node.$algeType;
   let mut valList:List<&Ast.AlgeValInfo> = [];
   
   forsort valInfo in algeType.$valInfoMap {
      valList.insert( valInfo );
   }

   // パラメータの無い値の初期化関数
   stream.writeln(
      "static void %s( %s _pEnv ) {"
      (moduleCtrl.getAlgeInitCName(algeType), cTypeEnvP ) );
   stream.pushIndent(##);

   let enumName = moduleCtrl.getAlgeEnumCName( algeType );
   foreach valInfo, index in valList {
      if #valInfo.$typeList == 0 {
         let varName = moduleCtrl.getAlgeValCName( algeType, valInfo.$name );
         stream.writeln(
            "lune_init_alge( &%s, &%s_any, %s_%s );"
            ( varName, varName, enumName, valInfo.$name ) );
      }
   }
   
   stream.popIndent();
   stream.writeln( "}" );

   let algeName = moduleCtrl.getAlgeCName( algeType );

   // パラメータを持つ値の生成関数
   foreach valInfo, index in valList {
      if #valInfo.$typeList > 0 {
         let mut hasAnyFlag = false;
         foreach valType, paramIndex in valInfo.$typeList {
            if isStemType( valType ) {
               hasAnyFlag = true;
               break;
            }
         }
         
         let valStruct = moduleCtrl.getAlgeValStrCName( algeType, valInfo.$name );
         let gcTxt;

         if hasAnyFlag {
            gcTxt = "lune_gc_alge_%s_%s" (algeName, valInfo.$name);
            stream.writeln(
               "static void %s( %s _pEnv, void * pVal ) {" (gcTxt, cTypeEnvP) );
            stream.pushIndent( ## );
            stream.writeln( "%s *pWorkVal = (%s *)pVal;" ( valStruct, valStruct ) );
            
            foreach valType, paramIndex in valInfo.$typeList {
               if isStemType( valType ) {
                  stream.writeln(
                     "lune_decre_ref( _pEnv, pWorkVal->_val%d.val.pAny );" ( paramIndex) );
               }
            }
            stream.popIndent();
            stream.writeln( "}" );
         }
         else {
            gcTxt = "NULL";
         }
         
         processAlgeNewProto( stream, moduleCtrl, algeType, valInfo );
         stream.writeln( "{" );
         stream.pushIndent( ## );

         stream.writeln(
            "%s pAny = lune_alge_new( _pEnv, %s_%s, sizeof( %s ), %s );"
            (cTypeStem, enumName, valInfo.$name, valStruct, gcTxt ) );
         stream.writeln( "%s *pVal = pAny.val.pAny->val.alge.pVal;" ( valStruct ) );

         foreach valType, paramIndex in valInfo.$typeList {
            if isStemType( valType ) {
               stream.writeln(
                  "lune_setQ( pVal->_val%d, _val%d );"
                  (paramIndex, paramIndex) );
            }
            else {
               stream.writeln( "pVal->_val%d = _val%d;" (paramIndex, paramIndex) );
            }
         }

         stream.writeln( "return pAny;" );
         
         stream.popIndent();
         stream.writeln( "}" );
      }
   }
   
   
}

pub override fn convFilter.processDeclAlge(
   node: Nodes.DeclAlgeNode, opt: Opt ) mut
{
   switch self.processMode {
      case .Prototype {
         processAlgePrototype( self.stream, self.moduleCtrl, node );
      }
      case .WideScopeVer {
         processAlgeWideScope( self.stream, self.moduleCtrl, node );
      }
      case .Form {
         processAlgeForm( self.stream, self.moduleCtrl, node );
      }
      case .InitModule {
         self.writeln( "%s( _pEnv );"
                       (self.moduleCtrl.getAlgeInitCName(node.$expType) ) );
      }
   }
//    let mut access = node.$accessMode == .Global and "" or "local ";
//    let mut algeFullName = node.$algeType.$rawTxt;
//    let typeInfo = unwrap node.$expType@@@Ast.AlgeTypeInfo;
//    let parentInfo = typeInfo.$parentInfo;
//    let mut isTopNS = true;
//    if parentInfo ~= Ast.headTypeInfo and parentInfo.$kind == .Class {
//       algeFullName = "%s.%s" (self.getFullName( parentInfo ), algeFullName );
//       access = "";
//       isTopNS = false;
//    }


//    self.writeln( "%s%s = {}" (access, algeFullName) );
//    self.writeln( "%s._name2Val = {}" (algeFullName) );
//    if isTopNS and node.$accessMode == .Pub {
//       if self.needModuleObj {
//          self.writeln( "_moduleObj.%s = %s" ( algeFullName, algeFullName ) );
//       }
//    }


//    if typeInfo.$accessMode == .Pub {
//       self.pubAlgeId2AlgeTypeInfo[ typeInfo.$typeId ] = typeInfo;
//    }

//    self.writeln( ```function %s:_getTxt( val )
//    local name = val[ 1 ]
//    if name then
//       return string.format( "%s.%%s", name )
//    end
//    return string.format( "illegal val -- %%s", val )
// end
// ``` (algeFullName, algeFullName ) );
//    self.writeln( ```
// function %s._from( val )
//    return _lune._AlgeFrom( %s, val )
// end
// ``` (algeFullName, algeFullName) );
//    forsort valInfo in node.$algeType.$valInfoMap {
//       self.write( '%s.%s = { "%s"' (algeFullName, valInfo.$name, valInfo.$name ) );
//       let mut memInfoTxt = "";
//       if #valInfo.$typeList > 0 {
//          self.write( ", {" );
//          foreach paramType, index in valInfo.$typeList {
//             if index > 1 {
//                self.write( "," );
//             }
//             let funcTxt, nilable, child = self.getMapInfo( paramType );
//             self.write( "{ func=%s, nilable=%s, child=%s }" (funcTxt, nilable, child) );
//          }
//          self.write( "}" );
//       }
//       self.writeln( "}" );
//       self.writeln( '%s._name2Val["%s"] = %s.%s'
//                     ( algeFullName, valInfo.$name, algeFullName, valInfo.$name ) );
//    }
}

pub override fn convFilter.processNewAlgeVal(
   node: Nodes.NewAlgeValNode, opt: Opt ) mut
{
   let valInfo = node.$valInfo;
   if #valInfo.$typeList == 0 {
      let valName = self.moduleCtrl.getAlgeValCName( node.$algeTypeInfo, valInfo.$name );
      self.write( "%s" (valName) );
   }
   else {
      self.write( self.moduleCtrl.getNewAlgeCName( node.$algeTypeInfo, valInfo.$name ) );
      self.write( "( _pEnv" );

      foreach arg in node.$paramList {
         self.write( "," );
         filter( arg, self, node );
      }
      self.write( ")" );
   }

   
   // let valInfo = node.$valInfo;
   // self.write( '_lune.newAlge( %s.%s'
   //             (self.getFullName( node.$algeTypeInfo ), valInfo.$name ) );
   // if #valInfo.$typeList > 0 {
   //    self.write( ", {" );
   //    foreach exp, index in node.$paramList {
   //       if index > 1 {
   //          self.write( "," );
   //       }
   //       filter( exp, self, node );
   //    }
   //    self.write( "}" );
   // }
   // self.write( ")" );
}



// fn convFilter.getDestrClass( classTypeInfo:&Ast.TypeInfo ) : &Ast.TypeInfo!
// {
   // let mut typeInfo = classTypeInfo;
   // while not typeInfo.equals( Ast.headTypeInfo ##) {
   //    let scope = unwrap typeInfo.$scope;
   //    if! scope.getTypeInfoChild( "__free" ) {
   //       return typeInfo;
   //    }
   //    typeInfo = typeInfo.$baseTypeInfo;
   // }
   // return nil;
// }

fn convFilter.outputAlter2MapFunc(
   stream:Util.SourceStream, alt2Map:&Map<&Ast.TypeInfo,&Ast.TypeInfo>)
{
   // stream.write( "{" );

   // foreach assinType, altType in alt2Map {
   //    if altType.$kind == .Alternate {
   //       if assinType.$kind == .Alternate {
   //          stream.write(
   //             "%s = self.__alt2mapFunc[ %q ],"
   //             (assinType.$rawTxt, assinType.$rawTxt ) );
   //       }
   //       else {
   //          let funcTxt, nilable, child = self.getMapInfo( assinType );
   //          stream.write(
   //             "%s = { func=%s, nilable=%s, child=%s },"
   //             (altType.$rawTxt, funcTxt, nilable, child) );
   //       }
   //    }
   // }

   // stream.write( "}" );
}

fn getMethodTypeTxt( retTypeList:&List<&Ast.TypeInfo> ) : str {
   if #retTypeList == 1 {
      switch retTypeList[ 1 ].$srcTypeInfo {
         case Ast.builtinTypeInt, Ast.builtinTypeChar {
            return "lune_method_int_t";
         }
         case Ast.builtinTypeReal {
            return "lune_method_real_t";
         }
      }
   }
   return "lune_method_t";
}

fn processNewConstrProto(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl, node:&Nodes.DeclClassNode ) mut
{
   let className = moduleCtrl.getClassCName( node.$expType );

   if not Ast.isPubToExternal( node.$expType.$accessMode ) {
      stream.write( "static " );
   }
   
   stream.write( "%s lune_class_%s_new( %s _pEnv"
      (cTypeStem, className, cTypeEnvP ) );


   let scope = unwrap node.$expType.$scope;
   let initFuncType = unwrap scope.getTypeInfoField( "__init", true, scope );
   foreach argType, index in initFuncType.$argTypeInfoList {
      stream.write( ", %s arg%d" ( getCType( argType, false ), index ) );
   }
   stream.write( ")" );
}

fn processMethodDeclTxt(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   callFlag:bool, methodTypeInfo:&Ast.TypeInfo, argList:&List<&Nodes.Node>! )
{
   if methodTypeInfo.$rawTxt ~= "__init" and not callFlag {
      stream.write( "static " );
   }

   stream.write(
      "%s %s( %s _pEnv"
      ( getCRetType( methodTypeInfo.$retTypeInfoList ),
        callFlag and moduleCtrl.getCallMethodCName( methodTypeInfo ) or
        moduleCtrl.getMethodCName( methodTypeInfo ), cTypeEnvP ) );
   if methodTypeInfo.$staticFlag {
      if isClosure( methodTypeInfo ) {
         stream.write( ", %s _pForm" ( cTypeAnyP ) );
      }
   }
   else {
      stream.write( ", %s pObj" ( cTypeAnyP ) );
   }

   when! argList {
      foreach argNode, index in argList {
         if! let declArgNode = argNode@@@Nodes.DeclArgNode {
            stream.write( ", %s %s" ( getCType( declArgNode.$expType, false ),
                                      declArgNode.$name.txt ) );
         }
      }
   }
   else {
      foreach arg, index in methodTypeInfo.$argTypeInfoList {
         stream.write( ", %s arg%d" ( getCType( arg, false ), index ) );
      }
   }
   stream.write( ")" );
}


fn processDeclMethodTable( stream:Util.SourceStream, classTypeInfo:&Ast.TypeInfo )
{
   fn outputField( name:str, retTypeList: &List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "%s * %s;" (methodType, name ) );
   }

   fn outputVal( scope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mtd {
               if symbolInfo.$name ~= "__init" {
                  outputField( symbolInfo.$name,
                               symbolInfo.$typeInfo.$retTypeInfoList );
               }
            }
         }
      }
   }
   outputVal( unwrap classTypeInfo.$scope );
}


fn processDeclMemberTable( stream:Util.SourceStream, classTypeInfo:&Ast.TypeInfo )
{
   fn outputVal( scope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mbr {
               if not symbolInfo.$staticFlag {
                  stream.writeln( "%s %s;" ( getCType( symbolInfo.$typeInfo, false ),
                                             symbolInfo.$name ) );
               }
            }
         }
      }
   }
   stream.writeln( "// member" );
   outputVal( unwrap classTypeInfo.$scope );
}

fn hasGC( classTypeInfo:&Ast.TypeInfo ): bool {
   if! let scope = classTypeInfo.$scope {
      if scope.getSymbolInfoField( "_gc", true, scope ) {
         return true;
      }
   }
   let mut workInfo = classTypeInfo;
   while workInfo.hasBase() {
      workInfo = workInfo.$baseTypeInfo;
      if! let scope = classTypeInfo.$scope {
         if scope.getSymbolInfoField( "_gc", true, scope ) {
            return true;
         }
      }
   }
   return false;
}
   

fn processDeclClassPrototype(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl, node:&Nodes.DeclClassNode )
{
   let className = moduleCtrl.getClassCName( node.$expType );
   
   // _gc, _del のプロトタイプ
   stream.writeln(
      "static void u_mtd_%s__del( lune_env_t * _pEnv, %s pObj );"
      (className, cTypeAnyP) );
   if hasGC( node.$expType ) {
      stream.writeln( "static void u_mtd_%s__gc( lune_env_t * _pEnv, %s pObj );"
                      (className, cTypeAnyP ) );
   }
   
   // アクセッサのプロトタイプ
   foreach member in node.$memberList {
      let memberName = member.$name.txt;
      if member.$getterMode ~= .None {
         let getterType = unwrap node.$scope.getTypeInfoField(
            "get_%s" (memberName), true, node.$scope );
         processMethodDeclTxt( stream, moduleCtrl, false, getterType## );
         stream.writeln( ";" );
      }
      if member.$setterMode ~= .None {
         let setterType = unwrap node.$scope.getTypeInfoField(
            "set_%s" (memberName), true, node.$scope );
         processMethodDeclTxt( stream, moduleCtrl, false, setterType## );
         stream.writeln( ";" );
      }
   }

   // コンストラクタのプロトタイプ
   processNewConstrProto( stream, moduleCtrl, node );
   stream.writeln( ";" );

   if not node.hasUserInit() {
      // デフォルトコンストラクタの処理
      let ctorType = unwrap node.$scope.getTypeInfoField( "__init", true, node.$scope );
      stream.write(
         "static void u_mtd_%s___init( lune_env_t * _pEnv, %s pAny"
         (className, cTypeAnyP ) );
      foreach argType, index in ctorType.$argTypeInfoList {
         stream.write(
            ", %s _arg%d"
            (getCType( argType, false ), index ) );
      }
      stream.writeln( ") {" );
      stream.pushIndent(##);

      if! let baseScope = node.$scope.$inherit {
         let superInitType =
            unwrap baseScope.getTypeInfoField( "__init", true, baseScope );
         stream.write( "u_mtd_%s___init( _pEnv, pAny"
            (moduleCtrl.getClassCName( node.$expType.$baseTypeInfo ) ) );
         foreach argType, index in superInitType.$argTypeInfoList {
            stream.write( ", _arg%d" (index) );
         }
         stream.writeln( ");" );
      }

      
      stream.writeln( "%s * pObj = lune_obj_%s( pAny );" (className, className) );
      foreach member, index in node.$memberList {
         if not member.$staticFlag {
            if isStemType( member.$expType ) {
               stream.writeln(
                  "lune_setQ( pObj->%s, _arg%d );" (member.$name.txt, index ));
            }
            else {
               stream.writeln( "pObj->%s = _arg%d;" (member.$name.txt, index));
            }
         }
      }
      stream.popIndent();
      stream.writeln( "}" );
   }
}

fn processIFObjDecl(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl, classType:&Ast.TypeInfo )
{
   if classType.hasBase() {
      processIFObjDecl( stream, moduleCtrl, classType.$baseTypeInfo );
   }

   foreach ifType in classType.$interfaceList {
      stream.writeln( "%s %s;" (cTypeAny, moduleCtrl.getClassCName( ifType ) ) );
   }
}

fn processIFObjInit(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   classType:&Ast.TypeInfo, impClassType:&Ast.TypeInfo )
{
   if classType.hasBase() {
      processIFObjInit( stream, moduleCtrl, classType.$baseTypeInfo, impClassType );
   }

   let className = moduleCtrl.getClassCName( impClassType );
   foreach ifType in classType.$interfaceList {
      let ifName = moduleCtrl.getClassCName( ifType );
      stream.writeln(
         "lune_init_if( &pObj->imp.%s, _pEnv, pAny, &lune_if_%s_imp_%s, %s );"
         (ifName, className, ifName, ifName) );
   }
}


fn convFilter.processDeclClassNodePrototype( node:&Nodes.DeclClassNode ) mut
{
   let className = self.moduleCtrl.getClassCName( node.$expType );
   
   // メソッド構造体の宣言
   self.writeln( "typedef struct lune_mtd_%s_t {" (className) );
   self.pushIndent(##);

   let kind = node.$expType.$kind;
   if kind == .Class {
      self.writeln( "lune_del_t * _del;" );
      self.writeln( "lune_gc_t * _gc;" );
   }

   processDeclMethodTable( self.stream, node.$expType );

   self.popIndent();
   self.writeln( "} lune_mtd_%s_t;" (className) );

   if kind == .Class {
      self.writeln( "typedef struct u_if_imp_%s_t {" (className) );
      self.pushIndent(##);

      processIFObjDecl( self.stream, self.moduleCtrl, node.$expType );

      self.writeln( "%s sentinel;" (cTypeAny) );
      self.popIndent();
      self.writeln( "} u_if_imp_%s_t;" (className) );
   }
   

   // クラス構造体の宣言
   self.writeln( "typedef struct %s {" (className) );
   self.pushIndent( ## );
   
   self.writeln( "lune_type_meta_t * pMeta;" );
   switch kind {
      case .Class {
         self.writeln( "u_if_imp_%s_t * pImp;" (className) );
         self.writeln( "lune_mtd_%s_t * pMtd;" (className) );
         processDeclMemberTable( self.stream, node.$expType );
         self.writeln( "// interface implements" );
         self.writeln( "u_if_imp_%s_t imp;" (className) );
      }
      case .IF {
         self.writeln( "%s pObj;" (cTypeAnyP) );
         self.writeln( "lune_mtd_%s_t * pMtd;" (className) );
      }      
   }

   self.popIndent();
   self.writeln( "} %s;" (className) );

   switch kind {
      case .Class {
         self.writeln( ```#define lune_mtd_%s( OBJ )                     \
          (((%s*)OBJ->val.classVal)->pMtd )``` (className,className) );
      }
      case .IF {
         self.writeln( ```#define lune_mtd_%s( OBJ )                     \
          ((%s*)&OBJ->val.ifVal)->pMtd``` (className,className) );
      }
   }


   if kind == .Class {
      self.writeln( "#define lune_obj_%s( OBJ ) ((%s*)OBJ->val.classVal)"
                    (className,className) );
      self.writeln( "#define lune_if_%s( OBJ ) ((%s*)OBJ->val.classVal)->pImp"
                    (className,className) );
      
      processDeclClassPrototype( self.stream, self.moduleCtrl, node );
   }
}

fn convFilter.processDeclClassDef( node:&Nodes.DeclClassNode ) mut
{
   let className = self.moduleCtrl.getClassCName( node.$expType );

   self.writeln( "static void u_mtd_%s__del( lune_env_t * _pEnv, %s pObj ) {"
      (className, cTypeAnyP) );
   self.pushIndent(##);
   
   if node.$expType.hasBase() {
      self.writeln( "u_mtd_%s__del( _pEnv, pObj );"
                    (self.moduleCtrl.getClassCName( node.$expType.$baseTypeInfo) ) );
   }

   foreach member in node.$memberList {
      if isStemType( member.$expType ) {
         self.writeln( "lune_decre_ref( _pEnv, lune_obj_%s( pObj )->%s%s );"
                       (className, member.$name.txt, accessAny ) );
      }
   }

   self.popIndent();
   self.writeln( "}" );
   
   // デフォルトコンストラクタの定義
   processNewConstrProto( self.stream, self.moduleCtrl, node );
   self.writeln( "{" );
   self.pushIndent(##);
   
   self.writeln( "lune_class_new_( _pEnv, %s, pAny, pObj );" (className) );

   self.write( "u_mtd_%s___init( _pEnv, pAny%s" ( className, accessAny ) );

   let scope = unwrap node.$expType.$scope;
   let initFuncType = unwrap scope.getTypeInfoField( "__init", true, scope );
   foreach argType, index in initFuncType.$argTypeInfoList {
      self.write( ", arg%d" ( index ) );
   }
   self.writeln( ");" );

   self.writeln( "pObj->pImp = &pObj->imp;" );
   self.writeln( "pObj->imp.sentinel.type = lune_value_type_none;" );
   
   processIFObjInit( self.stream, self.moduleCtrl, node.$expType, node.$expType );

   self.writeln( "return pAny;" );
   self.popIndent();
   self.writeln( "}" );

   // アクセッサの定義
   foreach member in node.$memberList {
      let memberName = member.$name.txt;
      if member.$getterMode ~= .None {
         let getterType = unwrap node.$scope.getTypeInfoField(
            "get_%s" (memberName), true, node.$scope );
         if getterType.$autoFlag {
            processMethodDeclTxt(
               self.stream, self.moduleCtrl, false, getterType## );
            self.writeln( "{" );
            self.pushIndent(##);
            self.writeln(
               "return lune_obj_%s(pObj)->%s;" (className, memberName) );
            self.popIndent();
            self.writeln( "}" );

            processMethodDeclTxt(
               self.stream, self.moduleCtrl, true, getterType## );
            self.writeln( "{" );
            self.pushIndent(##);
            self.writeln(
               "return lune_mtd_%s( pObj )->get_%s( _pEnv, pObj );"
               (className, memberName) );
            self.popIndent();
            self.writeln( "}" );
         }
      }
      if member.$setterMode ~= .None {
         let setterType = unwrap node.$scope.getTypeInfoField(
            "set_%s" (memberName), true, node.$scope );
         if setterType.$autoFlag {
            // self.writeln(
            //    "static void u_mtd_%s_set_%s( lune_env_t * _pEnv, %s pObj, %s arg );"
            //    ( className, memberName, cTypeStem, getCType( member.$expType, false ) ) );
            processMethodDeclTxt(
               self.stream, self.moduleCtrl, false, setterType## );
            self.writeln( "{" );
            self.pushIndent(##);
            if isStemType( member.$expType ) {
               self.writeln(
                  'lune_setq( _pEnv, lune_obj_%s(pObj)->%s, arg1 );'
                  (className, memberName) );
            }
            else {
               self.writeln( "lune_obj_%s(pObj)->%s = arg1;"
                  (className, memberName) );
            }
            self.popIndent();
            self.writeln( "}" );

            processMethodDeclTxt(
               self.stream, self.moduleCtrl, true, setterType## );
            self.writeln( "{" );
            self.pushIndent(##);
            self.writeln(
               "lune_mtd_%s( pObj )->set_%s( _pEnv, pObj, arg1 );"
               (className, memberName) );
            self.popIndent();
            self.writeln( "}" );
         }
      }
   }
}


fn processInitMethodTable(
   stream:Util.SourceStream, moduleCtrl:&ModuleCtrl, classTypeInfo:&Ast.TypeInfo)
{
   fn outputField( name:str, retTypeList:&List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "(%s *)%s," (methodType, name ) );
   }

   fn outputVal( scope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mtd {
               if symbolInfo.$name ~= "__init" {
                  outputField(
                     moduleCtrl.getMethodCName( symbolInfo.$typeInfo ),
                     symbolInfo.$typeInfo.$retTypeInfoList );
               }
            }
         }
      }
   }
   outputVal( unwrap classTypeInfo.$scope );
}

fn processInitIFMethodTable(
   stream:Util.SourceStream,
   moduleCtrl:&ModuleCtrl, ifType:&Ast.TypeInfo, classTypeInfo:&Ast.TypeInfo)
{
   fn outputField( name:str, retTypeList:&List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "(%s *)%s," (methodType, name ) );
   }

   fn outputVal( scope:&Ast.Scope, impScope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit, impScope );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mtd {
               if symbolInfo.$name ~= "__init" {
                  let impMethodType =
                     unwrap impScope.getTypeInfoField( symbolInfo.$name, true, impScope );
                  outputField(
                     moduleCtrl.getMethodCName( impMethodType ),
                     impMethodType.$retTypeInfoList );
               }
            }
         }
      }
   }
   outputVal( unwrap ifType.$scope, unwrap classTypeInfo.$scope );
}


fn processIFMethodDataInit(
   stream:Util.SourceStream,
   moduleCtrl:&ModuleCtrl, classType:&Ast.TypeInfo, orgClassType:&Ast.TypeInfo )
{
   let className = moduleCtrl.getClassCName( orgClassType );
   foreach ifType in classType.$interfaceList {
      let ifName = moduleCtrl.getClassCName( ifType );
      stream.writeln(
         "static lune_mtd_%s_t lune_if_%s_imp_%s = {" ( ifName, className, ifName ) );
      stream.pushIndent(##);

      processInitIFMethodTable( stream, moduleCtrl, ifType, orgClassType );

      stream.popIndent();
      stream.writeln( "};" );
   }
}

fn processClassDataInit(
   stream:Util.SourceStream, moduleCtrl:&ModuleCtrl, classTypeInfo:&Ast.TypeInfo )
{
   // インタフェース情報設定
   processIFMethodDataInit( stream, moduleCtrl, classTypeInfo, classTypeInfo );

   
   let className = moduleCtrl.getClassCName( classTypeInfo );

   // クラスメタ情報
   if not Ast.isPubToExternal( classTypeInfo.$accessMode ) {
      stream.write( "static " );
   }
   stream.writeln(
      'lune_type_meta_t lune_type_meta_%s = { "%s" };' (className, className) );

   // メソッド情報設定
   if not Ast.isPubToExternal( classTypeInfo.$accessMode ) {
      stream.write( "static " );
   }
   stream.writeln(
      "lune_mtd_%s_t lune_mtd_%s = {" ( className, className ) );
   stream.pushIndent(##);
   
   stream.writeln( "u_mtd_%s__del," ( className ) );

   if hasGC( classTypeInfo ) {
      stream.writeln( "u_mtd_%s__gc," ( className ) );
   }
   else {
      stream.writeln( "NULL," );
   }

   processInitMethodTable( stream, moduleCtrl, classTypeInfo );
   stream.popIndent();
   stream.writeln( "};" );

   // static メンバー用変数宣言
   foreach symbolInfo in (unwrap classTypeInfo.$scope).$symbol2SymbolInfoMap {
      if symbolInfo.$kind == .Mbr and symbolInfo.$staticFlag {
         stream.writeln( "%s %s;" ( getCType( symbolInfo.$typeInfo, false ),
                                    moduleCtrl.getClassMemberName( symbolInfo ) ) );
      }
   }
}

pub override fn convFilter.processDeclMember(
   node: Nodes.DeclMemberNode, opt: Opt ) mut
{
   // dump( baseIndent, node, node.info.name.txt )
   // node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};

pub override fn convFilter.processExpMacroExp(
   node: Nodes.ExpMacroExpNode, opt: Opt ) mut
{
   foreach stmt in node.$stmtList {
      filter( stmt, self, node );
   }
};


form outputMacroStmtBlock();

pub fn convFilter.outputDeclMacro(
   name:str, argNameList:&List<str>, callback:outputMacroStmtBlock ) mut
{
   // self.write( "local function %s(" ( name ) );

   // // let argTxt = "";
   // // foreach arg, index in macroInfo.get_argList() {
   // //    if index > 1 {
   // //       self.write( ", " );
   // //       argTxt = argTxt .. ", ";
   // //    }
   // //    filter( arg, self, node, baseIndent );
   // //    if arg.get_kind() == Nodes.NodeKind.$DeclArg {
   // //       argTxt = argTxt .. (arg@@Nodes.DeclArgNode).$name.txt;
   // //    }
   // //    else {
   // //       error( "not support ... in macro %s" ( node.get_declInfo().$name.txt ) );
   // //    }
   // // }

   // // self.writeln( ")", baseIndent );

   // self.writeln( "__macroArgs )" );
   // self.pushIndent(##);
   // foreach argName in argNameList {
   //    self.writeln( "local %s = __macroArgs.%s" (argName, argName ) );
   // }

   // self.writeln( "local macroVar = {}" );
   // self.writeln( "macroVar.__names = {}" );

   // self.macroDepth = self.macroDepth + 1;

   // callback();

   // self.macroDepth = self.macroDepth - 1;

   // self.writeln( "" );
   // self.writeln( "return macroVar" );
   // self.popIndent();
   // self.writeln( "end" );
   // self.writeln( "return %s" ( name ) );
}

pub override fn convFilter.processDeclMacro(
   node: Nodes.DeclMacroNode, opt: Opt ) mut
{
   // if self.inMacro {
   //    let macroInfo = node.get_declInfo();
   //    let mut argNameList:List<str> = [];
   //    foreach arg in macroInfo.$argList {
   //       argNameList.insert( arg.$name.txt );
   //    }
   //    self.outputDeclMacro(
   //       macroInfo.$name.txt, argNameList,
   //       fn () {
   //          if! let stmtBlock = macroInfo.$stmtBlock {
   //             filter( stmtBlock, self, node );
   //          }
   //       });
   // }
};

pub override fn convFilter.processExpMacroStat(
   node: Nodes.ExpMacroStatNode, opt: Opt ) mut
{
   // if #node.$expStrList == 0 {
   //    self.write( "''" );
   // }
   // else {
   //    foreach token, index in node.$expStrList {
   //       if index ~= 1 {
   //          self.write( '..' );
   //       }

   //       filter( token, self, node );
   //    }
   // }
};


pub override fn convFilter.processExpNew(
   node: Nodes.ExpNewNode, opt: Opt ) mut
{
   let classFullName = self.getFullName( node.get_symbol().$expType );
   self.write( "lune_class_%s_new( _pEnv" ( classFullName ) );
   if! node.get_argList() {
      self.write( ", " );
      filter( _exp,  self, node );
   }
   self.write( ")" );
};

fn convFilter.process__func__symbol(
   has__func__Symbol:bool, classType:&Ast.TypeInfo, mut funcName:str ) mut
{
   // if has__func__Symbol {
   //    let mut nameSpace = "";
   //    if classType ~= Ast.headTypeInfo {
   //       nameSpace = self.getFullName( classType );
   //    }
   //    if funcName == "" {
   //       funcName = "<anonymous>";
   //    }
   //    self.pushIndent(##);
   //    self.writeln( "local __func__ = '%s.%s'" (nameSpace, funcName) );
   //    self.popIndent();
   // }
}

fn convFilter.processDeclMethodInfo(
   declInfo:&Nodes.DeclFuncInfo, funcTypeInfo:&Ast.TypeInfo, parent:Nodes.Node ) mut
{
   switch self.processMode {
      case .Prototype {
         if funcTypeInfo.$parentInfo.$kind == .Class {
            processMethodDeclTxt( self.stream, self.moduleCtrl, false,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( ";" );
         }
         if funcTypeInfo.$rawTxt ~= "__init" and not funcTypeInfo.$staticFlag {
            processMethodDeclTxt( self.stream, self.moduleCtrl, true,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( ";" );
         }
      }
      case .Form {
         let className = self.moduleCtrl.getClassCName( unwrap declInfo.$classTypeInfo );
         if! let body = declInfo.$body {
            let methodNodeToken = unwrap declInfo.get_name();
            let methodName = methodNodeToken.txt;
            processMethodDeclTxt( self.stream, self.moduleCtrl, false,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( "{" );

            self.pushIndent(##);
            if not funcTypeInfo.$staticFlag {
               self.writeln( "%s self = LUNE_STEM_ANY( pObj );" (cTypeStem) );
            }

            self.pushRoutine( funcTypeInfo, body );

            // self.processBlockPreProcess( body );
            filter( body, self, parent );
            // self.processBlockPostProcess();

            self.popRoutine();

            self.popIndent();
            self.writeln( "}" );
         }
         if funcTypeInfo.$rawTxt ~= "__init" and not funcTypeInfo.$staticFlag {
            processMethodDeclTxt( self.stream, self.moduleCtrl, true,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( "{" );

            if #funcTypeInfo.$retTypeInfoList ~= 0 {
               self.write( "return " );
            }

            self.write( "lune_mtd_%s( pObj )->%s( _pEnv, "
                        ( className, funcTypeInfo.$rawTxt ) );
            if declInfo.$classTypeInfo$.$kind == .IF {
               self.write( "lune_getImpObj( pObj ) " );
            }
            else {
               self.write( "pObj " );
            }
            foreach argNode in declInfo.$argList {
               if! let declArgNode = argNode@@@Nodes.DeclArgNode {
                  self.write( ", %s" ( declArgNode.$name.txt ) );
               }
            }
            self.writeln( ");" );
            
            self.writeln( "}" );
         }
      }
   }
}


pub override fn convFilter.processDeclConstr(
   node: Nodes.DeclConstrNode, opt: Opt ) mut
{
   self.processDeclMethodInfo( node.$declInfo, node.$expType, node );
};

pub override fn convFilter.processDeclDestr(
   node: Nodes.DeclDestrNode, opt: Opt ) mut
{
   // self.writeln( "function %s.__free( self )"
   //    ( node.$declInfo.$classTypeInfo$.getTxt$(##) ) );

   // self.process__func__symbol(
   //    node.$declInfo.$has__func__Symbol, node.$expType.$parentInfo, "__free" );

   // filter( unwrap node.$declInfo.$body, self, node );

   // let classTypeInfo = node.$expType.$parentInfo;
   // if! self.getDestrClass( classTypeInfo.$baseTypeInfo ) {
   //    self.writeln( "%s.__free( self )" (_exp.getTxt(##) ) );
   // }

   // self.writeln( "end" );
}


pub override fn convFilter.processExpCallSuper(
   node: Nodes.ExpCallSuperNode, opt: Opt ) mut
{
   // let typeInfo:Ast.TypeInfo = node.$superType;
   // if node.$methodType.$rawTxt == "__init" {
   //    self.write( "%s.%s( self"
   //                ( self.getFullName( typeInfo ), node.$methodType.$rawTxt ) );
   // }
   // else {
   //    self.write( "%s.%s( self"
   //                ( self.getFullName( typeInfo ), node.$methodType.$rawTxt ) );
   // }

   // if! node.$expList {
   //    self.write( "," );
   //    filter( _exp, self, node );
   // }
   // self.writeln( ")" );
};

pub override fn convFilter.processDeclMethod(
   node: Nodes.DeclMethodNode, opt: Opt ) mut
{
   self.processDeclMethodInfo( node.$declInfo, node.$expType, node );
};


pub override fn convFilter.processUnwrapSet(
   node: Nodes.UnwrapSetNode, opt: Opt ) mut
{
   // let dstExpList = node.$dstExpList;
   // filter( dstExpList, self, node );
   // self.write( " = " );
   // filter( node.$srcExpList, self, node );
   // self.writeln( "" );

   // self.write( "if " );
   // foreach expNode, index in dstExpList.$expList {
   //    if index > 1 {
   //       self.write( " or " );
   //    }
   //    self.write( "nil == " );
   //    filter( expNode, self, node );
   // }
   // self.writeln( " then" );
   // self.pushIndent(##);

   // foreach expNode, index in dstExpList.$expList {
   //    self.write( "local _exp%d = " (index));
   //    filter( expNode, self, node );
   //    self.writeln( "" );
   // }

   // if node.$unwrapBlock {
   //    filter( unwrap node.$unwrapBlock, self, node );
   // }
   // self.popIndent();
   // self.writeln( "end" );
}


fn convFilter.accessPrimValFromAny(
   dddFlag:bool, typeInfo:&Ast.TypeInfo, index:int ) mut
{
   self.write( getAccessPrimValFromStem( dddFlag, typeInfo, index ) );
}

fn convFilter.isStemSym( symbolInfo:&Ast.LowSymbol ) mut : bool {
   return self.scopeMgr.getSymbolValKind( symbolInfo ) ~= .Prim;
}

fn convFilter.isStemVal( node:&Nodes.Node ) mut : bool {
   if #node.$expTypeList > 1 {
      return true;
   }

   let symbolList = node.getSymbolInfo();
   if #symbolList > 0 {
      // val は評価のタイミングで any にしているので、 prim 以外は any。
      return self.scopeMgr.getSymbolValKind( symbolList[ 1 ] ) ~= .Prim;
   }
   return isStemType( node.$expType );
}

/**
exp の値にアクセスするためのコードを出力する。
*/
pub fn convFilter.accessPrimVal( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   // if exp@@@Nodes.LiteralIntNode or exp@@@Nodes.LiteralCharNode
   //    or exp@@@Nodes.LiteralRealNode
   if not self.isStemVal( exp ) {
      filter( exp, self, parent );
   }
   else {
      filter( exp, self, parent );
      self.accessPrimValFromAny( #exp.$expTypeList > 1, exp.$expType, 0 );
      // if #exp.$expTypeList > 1 {
      //    self.write( "->val.ddd.pAnyList[ 0 ]" );
      // }

      // let expType = exp.$expType.$srcTypeInfo;
      // switch expType {
      //    case Ast.builtinTypeInt, Ast.builtinTypeChar {
      //       self.write( "->val.intVal" );
      //    }
      //    case Ast.builtinTypeReal {
      //       self.write( "->val.realVal" );
      //    }
      //    case Ast.builtinTypeBool {
      //       self.write( "->val.boolVal" );
      //    }
      // }
   }
}


/**
symbol が示す値を any 型に変換する処理を出力する

@param symbol シンボル
*/
pub fn convFilter.processSym2Any( symbol:&Ast.LowSymbol ) mut
{
   let mut symName = getSymbolName( symbol );
   
   switch self.scopeMgr.getSymbolValKind( symbol ) {
      case .Stem {
         if isStemType( symbol.$typeInfo ) {
            self.write( getSymbolName( symbol ) );
            self.write( accessAny );
         }
         else {
            symName = "%s%s"  ( getSymbolName( symbol ),
                                getAccessValFromStem( symbol.$typeInfo ) );
         }
      }
      case .Prim {
      }
      default {
         self.write( getSymbolName( symbol ) );
      }
   }

   let mut expType = symbol.$typeInfo.$srcTypeInfo;
   if! let enumType = expType@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         self.write( "LUNE_STEM_INT( %s )" ( symName ) );
      }
      case Ast.builtinTypeReal {
         self.write( "LUNE_STEM_REAL( %s )" ( symName ) );
      }
   }
}



/**
node が示す値を any 型に変換する処理を出力する

@param node Node
@param parent このノードの親
*/
pub fn convFilter.processVal2any( node:&Nodes.Node, parent: &Nodes.Node ) mut
{
   if self.isStemVal( node ) {
      filter( node, self, parent );
   }
   else {
      let mut expType = node.$expType.$srcTypeInfo;
      if! let enumType = expType@@@Ast.EnumTypeInfo {
         expType = enumType.$valTypeInfo;
      }
      
      switch expType {
         // case Ast.builtinTypeBool {
         //    self.write( "lune_bool2stem( _pEnv, " );
         //    filter( node, self, parent );
         //    self.write( ")" );
         // }
         case Ast.builtinTypeInt, Ast.builtinTypeChar {
            self.write( "LUNE_STEM_INT( " );
            filter( node, self, parent );
            self.write( ")" );
         }
         case Ast.builtinTypeReal {
            self.write( "LUNE_STEM_REAL( " );
            filter( node, self, parent );
            self.write( ")" );
         }
         default {
            switch expType.$kind {
               case .DDD {
                  self.write( "_pDDD" );
               }
               case .Func {    
                  if! let scope = expType.$scope {
                     // let argList = expType.$argTypeInfoList;
                     // let hasDDD =
                     //    #argList > 0 and argList[ #argList ].$kind == .DDD or false;
                     
                     // // self.write( "lune_func2stem( _pEnv, (lune_closure_t *)" );
                     // // self.write( getFuncName( expType ) );
                     // // self.write( ", %d, %s, %d"
                     // //             ( #node.$expType.$argTypeInfoList, hasDDD,
                     // //               #scope$.$closureSymList) );     
                     
                     // // foreach symbolInfo in scope.$closureSymList {
                     // //    self.write( ", %s" (symbolInfo.$name) );
                     // // }
                     // // self.write( ")" );

                     // self.processPrepareClosure(
                     //    getFuncName( expType ), #node.$expType.$argTypeInfoList,
                     //    hasDDD, scope$.$closureSymList );
                     self.write( self.getFunc2stem( expType ) );
                  }
                  else {   
                     Util.err( "illegal func" );
                  }
               }
               default {
                  filter( node, self, parent );
               }
            }
         }
      }
   }
   // filter( node, self, parent );
}

pub fn convFilter.processVal2stem(
   node:&Nodes.Node, parent: &Nodes.Node ) mut
{
   let mut expType = node.$expType.$srcTypeInfo;
   if! let enumType = expType@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }

   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         self.write( "LUNE_STEM_INT( " );
         filter( node, self, parent );
         // let symbolInfoList = node.getSymbolInfo();
         // if #symbolInfoList > 0 {
         //    self.write(
         //       self.scopeMgr.getAccessPrimValFromSymbolOnly( symbolInfoList[ 1 ] ) );
         // }
         // else {
         // }
         self.write( ")" );
      }
      case Ast.builtinTypeReal {
         self.write( "LUNE_STEM_REAL( " );
         filter( node, self, parent );
         // let symbolInfoList = node.getSymbolInfo();
         // if #symbolInfoList > 0 {
         //    self.write(
         //       self.scopeMgr.getAccessPrimValFromSymbolOnly( symbolInfoList[ 1 ] ) );
         // }
         self.write( ")" );
      }
      default {
         switch expType.$kind {
            case .DDD {
               self.write( "_pDDD" );
            }
            case .Func {    
               if! let scope = expType.$scope {
                  // let argList = expType.$argTypeInfoList;
                  // let hasDDD =
                  //    #argList > 0 and argList[ #argList ].$kind == .DDD or false;
                  
                  // // self.write( "lune_func2stem( _pEnv, (lune_closure_t *)" );
                  // // self.write( getFuncName( expType ) );
                  // // self.write( ", %d, %s, %d"
                  // //             ( #node.$expType.$argTypeInfoList, hasDDD,
                  // //               #scope$.$closureSymList) );     
                  
                  // // foreach symbolInfo in scope.$closureSymList {
                  // //    self.write( ", %s" (symbolInfo.$name) );
                  // // }
                  // // self.write( ")" );

                  // self.processPrepareClosure(
                  //    getFuncName( expType ), #node.$expType.$argTypeInfoList,
                  //    hasDDD, scope$.$closureSymList );
                  self.write( self.getFunc2stem( expType ) );
               }
               else {   
                  Util.err( "illegal func" );
               }
            }
            default {
               filter( node, self, parent );
            }
         }
      }
   }
}

fn hasMultiVal( exp:&Nodes.Node ): bool {
   return exp.$expType.$kind == .DDD or #exp.$expTypeList > 1;
   // return exp.$expType.$kind == .DDD;
}


/**
シンボル var に値を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param var 代入先のシンボル
@param initFlag 変数に対する初期値設定の場合 true
@param isStemExp 値が any 型かどうか
@param index exp が ... の場合の index
@param firstMRet index が多値要素の最初のインデックスの場合 true
@param processVal 代入する値にアクセスするコードを出力するコールバック
*/
fn convFilter.processSetValSingleDirect(
   parent:&Nodes.Node, node:&Nodes.Node!, var:&Ast.LowSymbol,
   initFlag:bool, isStemExp:bool, index:int, firstMRet:bool, processVal:form ) mut
{
   let valKind = self.scopeMgr.getSymbolValKind( var );

   let mut varName = getSymbolName( var );
   let mut processPrefix:form! = nil;
   if! let fieldNode = node@@@Nodes.RefFieldNode {
      if fieldNode.$symbolInfo$.$staticFlag {
         varName = self.moduleCtrl.getClassMemberName( unwrap fieldNode.$symbolInfo );
      }
      else {
         processPrefix = fn () {
            let prefixNode = fieldNode.$prefix;
            let className = self.moduleCtrl.getClassCName( prefixNode.$expType );
            self.write( "lune_obj_%s( " (className) );
            filter( prefixNode, self, fieldNode );
            self.write( accessAny );
            self.write( ")->" );
         };
      }
   }

   switch valKind {
      case .Var {
         if isStemType( var.$typeInfo ) {
            if initFlag {
               self.write( "lune_setQ( %s->stem, " ( varName ) );
            }
            else {
               self.write( "lune_setq( _pEnv, %s->stem, " ( varName ) );
            }
            processVal();
            self.writeln( " );" );
         }
         else {
            self.write( "%s->stem" (varName) );
            self.write( getAccessValFromStem( var.$typeInfo) );
            self.write( " = " );
            processVal();
            self.write( ";" );
         }
      }
      case .Stem {
         if isStemExp {
            if initFlag {
               self.write( "lune_setQ( " );
            }
            else {
               self.write( "lune_setq( _pEnv, " );
            }
            when! processPrefix {
               processPrefix();
            }
            self.write( "%s, " ( varName ) );
            processVal();
            self.write( " );" );
         }
         else {
            when! processPrefix {
               processPrefix();
            }
            self.write( self.scopeMgr.getAccessPrimValFromSymbol( var ) );
            self.write( " = " );
            processVal();
            self.write( ";" );
         }
      }
      default {
         when! processPrefix {
            processPrefix();
         }
         self.write( "%s = " (varName ) );
         processVal();
         self.write( ";" );
      }
   }
}



/**
symbolInfo の値を変数にセットする処理を出力する。

@param parent 親ノード
@param dstKind 変数の種別
@param dstTypeInfo 変数の型
@param symbol 代入元のシンボル
*/
fn convFilter.processSymForSetOp(
   parent:&Nodes.Node, dstKind:ValKind,
   dstTypeInfo:&Ast.TypeInfo, symbol:&Ast.LowSymbol ) mut
{
   let srcKind = self.scopeMgr.getSymbolValKind( symbol );
   let isStemExp = srcKind ~= .Prim;

   if dstKind ~= srcKind {
      switch dstKind {
         case .Prim {
            // 値が any で、変数が Prim 型の場合
            self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbol ) );
            return;
         }
         case .Stem {
            self.processSym2stem( symbol );
            return;
         }
         case .Var {
            if srcKind ~= .Prim {
               if not isStemType( symbol.$typeInfo ) {
                  self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbol ) );
               }
               else {
                  self.processSym2stem( symbol );
               }
               return;
            }
            // self.processSym2stem( symbol );
            // return;
         }
         default {
            self.processSym2stem( symbol );
            return;
         }
      }
   }
   self.write( getSymbolName( symbol ) );
}




/**
Node の値を変数にセットする処理を出力する。

@param parent 親ノード
@param dstKind 変数の種別
@param dstTypeInfo 変数の型
@param exp 値のノード
@param index exp が多値だった場合の何番目の値にアクセスするか
@param firstMRet exp が多値の先頭アクセスの場合
*/
fn convFilter.processValForSetOp(
   parent:&Nodes.Node, dstKind:ValKind, dstTypeInfo:&Ast.TypeInfo,
   exp:&Nodes.Node, index:int, firstMRet:bool ) mut
{
   let isStemExp = self.isStemVal( exp );

   fn accessVal() {
      if firstMRet {
         self.write( "lune_getMRet( _pEnv, 0 )" );
         self.write( getAccessValFromStem( exp.$expType ) );
      }
      else {
         filter( exp, self, parent );
      }
   }

   fn processVal() {
      // シンボルに代入する値にアクセスするコード出力
      let mut setValTxt = "";
      if firstMRet {
         accessVal();
      }
      elseif not firstMRet and hasMultiVal( exp ) {
         self.write( "lune_fromDDD( " );
         accessVal();
         self.write( accessAny );
         self.write( ", %d )" (index) );
         self.write( getAccessValFromStem( exp.$expType ) );
      }
      else {
         if dstKind == .Stem {
            self.processVal2stem( exp, parent );
         }
         elseif dstKind == .Var and not isStemExp {
            //self.processVal2stem( exp, parent );
            accessVal();
         }
         else {
            accessVal();
         }
      }
   }
   if dstKind == .Prim and isStemExp {
      // 値が any で、変数が Prim 型の場合
      let expSymList = exp.getSymbolInfo();
      if #expSymList > 0 {
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( expSymList[ 1 ] ) );
      }
      else {
         processVal();
         //self.write( getAccessPrimValFromStem( false, dstTypeInfo, 0 ) );
      }
   }
   else {
      processVal();
   }
}


/**
インタフェース型の可能性のある値を、インタフェース型に変換する。

次の関数の様に、戻り値が Generics の型パラメータの場合、

fn func<T>() : T; 

その関数の戻り値が、インタフェースではなくクラスのオブジェクトを返すことがある。
そのような場合に、クラスのオブジェクトから所定のインタフェースの
オブジェクトを返すように lune_toIF() 処理を追加する。

ただし、通常は、
*/
fn processToIF( stream:Util.SourceStream,
                moduleCtrl:ModuleCtrl, expType:&Ast.TypeInfo, process:form )
{
   if expType.$kind == .IF {
      stream.write( "lune_toIF( _pEnv, " );
      process();
      stream.write( accessAny );
      stream.write( ", &lune_type_meta_%s )" (moduleCtrl.getClassCName( expType )) );
   }
   else {
      process();
   }
}

fn processToIFGeneric(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   classType:&Ast.TypeInfo!, expType:&Ast.TypeInfo, process:form )
{
   when! classType {
      if expType.$kind == .Alternate {
         let alt2typeMap = classType.createAlt2typeMap( false );
         let workRetType = Ast.AlternateTypeInfo.getAssign( expType, alt2typeMap );

         processToIF( stream, moduleCtrl, workRetType, process );
      }
      else {
         process();
      }
   }
   else {
      process();
   }
}


/**
シンボル var に exp の式の結果を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param var シンボル
@param exp 代入する値の式
@param index exp が ... の場合の index
*/
fn convFilter.processSetValSingle(
   parent:&Nodes.Node, node:&Nodes.Node!, var:&Ast.LowSymbol,
   initFlag:bool, exp:&Nodes.Node, index:int, firstMRet:bool ) mut
{
   self.processSetValSingleDirect(
      parent, node, var, initFlag, self.isStemVal( exp ), index, firstMRet,
      fn () {
         self.processValForSetOp(
            parent, self.scopeMgr.getSymbolValKind( var ),
            var.$typeInfo, exp, index, firstMRet );
      } );
}

/**
シンボル var に symbol の値を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param var 代入先シンボル
@param symbol 代入元シンボル
*/
fn convFilter.processSetSymSingle(
   parent:&Nodes.Node, node:&Nodes.Node!, var:&Ast.LowSymbol,
   initFlag:bool, symbol:&Ast.LowSymbol, toIF:bool ) mut
{
   fn process() {
      self.processSymForSetOp(
         parent, self.scopeMgr.getSymbolValKind( var ), var.$typeInfo, symbol );
   }
   
   self.processSetValSingleDirect(
      parent, node, var, initFlag, self.isStemSym( symbol ), 1, false,
      fn () {
         if toIF {
            processToIF( self.stream, self.moduleCtrl, symbol.$typeInfo, process );
         }
         else {
            process();
         }
      } );
}



/**
値をシンボルに代入する処理。

val1, val2, val3 = exp1, exp2, exp3

@param parent この代入処理の親 Node
@param varSymList 代入先のシンボルリスト。
@param expList 代入する値の Node リスト
@param varNode 代入先のシンボルリスト。 代入先が単なるシンボルの場合は不要。
    self.val = 1 のようにメンバに代入する場合に指定する。
@param mRetExp expList の MRetExp 情報。
*/
fn convFilter.processSetValToSym(
   parent: &Nodes.Node, varSymList:&List<&Ast.LowSymbol>, initFlag:bool,
   expList:&List<&Nodes.Node>, varNode:&Nodes.Node!, mRetExp:&Nodes.MRetExp! ) mut
{
   let varNodeList:List<&Nodes.Node>;
   if! let expListNode = varNode@@@Nodes.ExpListNode {
      varNodeList = expListNode.$expList;
   }
   else {
      when! varNode {
         varNodeList = [ varNode ];
      }
      else {
         varNodeList = [];
      }
   }

   let mut mRetIndex:int! = mRetExp$.$index;
   // 代入する値分のループを廻して、値を代入する処理を出力
   foreach exp, index in expList {
      let is1stMRet = index == mRetIndex;
      if is1stMRet {
         when! mRetExp {
            self.write( "lune_setMRet( _pEnv, " );
            filter( mRetExp.$exp, self, parent );
            self.write( accessAny );
            self.writeln( ");" );
         }
      }

      if index > #varSymList {
         return;
      }
      if index == #expList {
         // 代入する最終要素の場合、最終要素の多値処理を行なう
         for varIndex = index, #varSymList {
            let mut workNode:&Nodes.Node! = nil;
            if #varNodeList >= varIndex {
               workNode = varNodeList[ varIndex ];
            }
            self.processSetValSingle( parent, workNode, varSymList[ varIndex ],
                                      initFlag, exp, varIndex - index, is1stMRet );
            self.writeln( "" );
         }
      }
      else {
         let mut workNode:&Nodes.Node! = nil;
         if #varNodeList >= index {
            workNode = varNodeList[ index ];
         }
         self.processSetValSingle( parent, workNode, varSymList[ index ],
                                   initFlag, exp, 0, is1stMRet );
         self.writeln( "" );
      }
   }
      
}


/**
シンボル var に exp の式の結果を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param exp 代入する値の式
@param index exp が ... の場合の index
*/
fn convFilter.processSetValSingleNode(
   parent:&Nodes.Node, var:&Nodes.Node, exp:&Nodes.Node, index:int, firstMRet:bool ) mut
{
   let isStemExp = self.isStemVal( exp );
   let symbolList = var.getSymbolInfo();
   if #symbolList > 0 {
      self.processSetValSingle(
         parent, var, symbolList[ 1 ], false, exp, index, firstMRet );
      return;
   }

   switch var.$kind {
      case Nodes.NodeKind.$ExpRefItem {
         if! let refItemNode = var@@@Nodes.ExpRefItemNode {
            let dstType = refItemNode.$val.$expType;
            if dstType.$kind == .Map {
               self.write( "lune_mtd_Map_add( _pEnv, " );
               filter( refItemNode.$val, self, var );
               self.write( accessAny );
               self.write( ", " );
               if! let indexNode = refItemNode.$index {
                  self.processVal2stem( indexNode, var );
               }
               self.write( ", " );
               self.processValForSetOp(
                  parent, .Stem, dstType.$itemTypeInfoList[ 2 ],
                  exp, index, firstMRet );
               self.write( ")" );
            }
         }
      }
      default {
         Util.err( "not support -- %s" (Nodes.getNodeKindName( var.$kind ) ) );
      }
   }
}



/**
値を Node に代入する処理。

val1, val2, val3 = exp1, exp2, exp3

@param parent この代入処理の親 Node
@param dstNode 代入先の Node
@param expList 代入する値の Node リスト
@param mRetExp expList の MRetExp 情報。
*/
fn convFilter.processSetValToNode(
   parent: &Nodes.Node, dstNode:&Nodes.Node,
   expList:&List<&Nodes.Node>, mRetExp:&Nodes.MRetExp! ) mut
{
   let dstNodeList:List<&Nodes.Node>;
   if! let expListNode = dstNode@@@Nodes.ExpListNode {
      dstNodeList = expListNode.$expList;
   }
   else {
      dstNodeList = [ dstNode ];
   }

   let mut mRetIndex:int! = mRetExp$.$index;
   // 代入する値分のループを廻して、値を代入する処理を出力
   foreach exp, index in expList {
      let is1stMRet = index == mRetIndex;
      if is1stMRet {
         when! mRetExp {
            self.write( "lune_setMRet( _pEnv, " );
            filter( mRetExp.$exp, self, parent );
            self.write( accessAny );
            self.writeln( ");" );
         }
      }

      if index > #dstNodeList {
         return;
      }
      if index == #expList {
         // 代入する最終要素の場合、最終要素の多値処理を行なう
         for varIndex = index, #dstNodeList {
            let mut workNode = dstNodeList[ varIndex ];
            self.processSetValSingleNode(
               parent, workNode, exp, varIndex - index, is1stMRet );   
         }
      }
      else {
         self.processSetValSingleNode(
            parent, dstNodeList[ index ], exp, 0, is1stMRet );
      }
   }
      
}



/**
block から変数に領域割り当て処理を行なう。

@param declFlag 変数宣言を行なう場合 true
@param var 変数シンボル
@param init0 プリミティブな変数を 0 で初期化する場合 true 
*/
pub fn convFilter.processDeclVarC( declFlag:bool, var:&Ast.LowSymbol, init0:bool ) mut
{
   if declFlag {
      let typeTxt = self.scopeMgr.getCTypeForSym( var );
      self.writeln( "%s %s;" ( typeTxt, getSymbolName( var ) ) );
   }

   let valKind = self.scopeMgr.getSymbolValKind( var );
   if valKind == .Prim {
      if init0 {
         self.writeln( "%s = 0;" ( getSymbolName( var )) );
      }
      return;
   }

   let initVal;
   if not init0 or isStemType( var.$typeInfo ) {
      if! let symbolInfo = var@@@Ast.SymbolInfo {
         if valKind == .Stem {
            self.write( "lune_set_block_stem" );
            self.writeln( "( %s, %d, %s );"
                          ( getBlockName( var.$scope ), getSymbolIndex( symbolInfo ),
                            getSymbolName( var ) ) );
         }
         else {
            let typeTxt = getStemTypeId( var.$typeInfo );
            self.writeln( "lune_set_block_var( %s, %d, %s, %s );"
                          ( getBlockName( var.$scope ), getSymbolIndex( symbolInfo ),
                            typeTxt, getSymbolName( var ) ) );
         }
      }
      // else {
      //    self.writeln( "%s = NULL;" ( getSymbolName( var ) ) );
      // }
   }
   else {
      initVal = getLiteral2Any( "0", var.$typeInfo );

      if! let symbolInfo = var@@@Ast.SymbolInfo {
         // if valKind == .Stem {
         //    self.write( "lune_initVal_any" );
         // }
         // else {
         //    self.write( "lune_initVal_var" );
         // }
         self.write( "lune_initVal_var" );
         self.writeln( "( %s, %s, %d, %s );"
                       (getSymbolName( var ), getBlockName( var.$scope ),
                         getSymbolIndex( symbolInfo ), initVal ) );
      }
      else {
         self.writeln( "%s = %s;" ( getSymbolName( var ), initVal ) );
      }
   }
}

fn convFilter.processDeclVarAndSet(
   varSymList:&List<&Ast.LowSymbol>, expListNode:&Nodes.ExpListNode! ) mut
{
   foreach var, index in varSymList  {
      let typeTxt, valKind = self.scopeMgr.getCTypeForSym( var );
      if valKind ~= .Prim {
         let declVarFlag;
         if varSymList[ 1 ].$scope ~= self.ast.$moduleScope {
            declVarFlag = true;
         }
         else {
            declVarFlag = false;
         }
         self.processDeclVarC( declVarFlag, var, true );
      }
      else {
         if varSymList[ 1 ].$scope ~= self.ast.$moduleScope {
            self.writeln( "%s %s;" ( typeTxt, getSymbolName( var ) ) );
         }
      }
   }
   // 初期値代入
   when! expListNode {
      self.processSetValToSym( expListNode, varSymList, true,
                               expListNode.$expList, nil, expListNode.$mRetExp );
   }
}


pub override fn convFilter.processIfUnwrap(
   node: Nodes.IfUnwrapNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);

   let expListNode = node.$expList;
   // 一旦 work 変数に代入する
   let mut workSymList:List<&WorkSymbol> = [];
   foreach varSym, index in node.$varSymList {
      let workSymbol = new WorkSymbol(
         varSym.$scope, varSym.$accessMode, "_%s" (varSym.$name), 
         varSym.$typeInfo.$nilableTypeInfo, varSym.$kind,
         new SymbolParam( .StemWork, -1, cTypeStem ) );
      workSymList.insert( workSymbol );
   }
   self.processDeclVarAndSet( workSymList, expListNode );

   // work が nil でないことを確認する
   self.write( "if ( " );
   foreach workSym, index in workSymList {
      self.write( "%s.type != lune_stem_type_nil" (getSymbolName( workSym )) );
      if index ~= #workSymList {
         self.write( " && " );
      }
   }
   self.writeln( ") {" );

   // nil でなければ、 work から変数にセットする
   self.processBlockPreProcess( node.$block );
   
   self.processDeclVarAndSet( node.$varSymList, nil );


   foreach varSym, index in node.$varSymList {
      self.processSetSymSingle( node, nil, varSym, true, workSymList[ index ], false );
      self.writeln( "" );
   }
   // self.processSetValToSym( node, node.$varSymList, true,
   //                          expListNode.$expList, nil, expListNode.$mRetExp );

   // ブロックの実行
   filter( node.$block, self, node );

   self.processBlockPostProcess();
   self.writeln( "}" );
   
   if! node.$nilBlock {
      self.writeln( "else {" );
      filter( _exp, self, node );
      self.writeln( "}" );
   }
   
   
   self.popIndent();
   self.writeln( "}" );
}






pub override fn convFilter.processDeclVar(
   node: Nodes.DeclVarNode, opt: Opt ) mut
{
   switch self.processMode {
      case .WideScopeVer {
         let varSymList = node.$symbolInfoList;
         foreach var, index in varSymList  {
            let typeTxt = self.scopeMgr.getCTypeForSym( var );
            switch var.$accessMode {
               case .Pub, .Global {
               }
               default {
                  self.write( "static " );
               }
            }
            self.writeln( "%s %s;" ( typeTxt, getSymbolName( var ) ) );
         }
         return;
      }
      case .InitModule, .Form {
      }
      default {
         return;
      }
   }
   
   if node.$syncBlock {
      self.writeln( "{" );
      self.pushIndent(##);
      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s" (varInfo.$name.txt) );
      }
      self.writeln( "{" );
      self.pushIndent(##);
   }

   let varSymList = node.$symbolInfoList;

   self.processDeclVarAndSet( varSymList, node.$expList );


   if! node.$unwrapBlock {
      self.writeln( "" );
      self.write( "if " );
      let mut firstFlag = true;
      foreach var in varSymList {
         if var.$typeInfo.$nilable {
            if firstFlag {
               firstFlag = false;
            }
            else {
               self.write( " || " );
            }
            self.write( "lune_stem_type_nil == %s.type" ( getSymbolName( var ) ) );
         }
      }
      self.writeln( " {" );
      self.pushIndent(##);

      foreach var, index in varSymList  {
         self.writeln( "local _%s = %s" ( getSymbolName( var ), getSymbolName( var ) ) );
      }
      self.popIndent();

      filter( _exp, self, node );

      if! let thenBlock = node.$thenBlock {
         self.writeln( "else {" );
         self.pushIndent(##);
         filter( thenBlock, self, node );
         self.popIndent();
      };

      self.writeln( "}" );
   }

   if! node.$syncBlock {
      filter( _exp, self, node);

      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s = %s" (varInfo.$name.txt, varInfo.$name.txt) );
      }
      self.popIndent();
      self.writeln( "}" );

      foreach varInfo in node.$syncVarList {
         self.writeln( "%s = _sync_%s" (varInfo.$name.txt, varInfo.$name.txt) );
      }
      self.popIndent();
      self.writeln( "}" );
   }


   if node.get_accessMode() == .Pub {
      self.writeln( "" );
      foreach var, index in varSymList {
         let name: str = getSymbolName( var );
         self.pubVarName2InfoMap[ name ] = new PubVerInfo(
            node.$staticFlag, node.$accessMode,
            node.$symbolInfoList[ index ].$mutable, node.$typeInfoList[ index ] );
      }
   }
};


pub override fn convFilter.processWhen(
   node: Nodes.WhenNode, opt: Opt ) mut
{
   self.write( "if ( " );
   foreach symPair, index in node.$symPairList {
      self.write( "%s.type != lune_stem_type_nil" ( getSymbolName( symPair.$src )) );
      if index ~= #node.$symPairList {
         self.write( " && " );
      }
   }
   self.writeln( " ) " );
   self.writeln( "{" );

   self.processBlockPreProcess( node.$block );
   
   foreach symPair in node.$symPairList {
      let srcSymbol = symPair.$src;
      let dstSymbol = symPair.$dst;
      let srcTypeTxt = self.scopeMgr.getCTypeForSym( srcSymbol );
      let dstTypeTxt = self.scopeMgr.getCTypeForSym( dstSymbol );
      if srcTypeTxt ~= dstTypeTxt {
         // self.writeln( "%s %s;" ( dstTypeTxt, getSymbolName( dstSymbol ) ) );
         // self.processSetSymSingle( node, nil, dstSymbol, true, srcSymbol, false );
         // self.writeln( "" );

         self.processDeclVarC( true, dstSymbol, false );

         let workSymbol = new WorkSymbol(
            srcSymbol.$scope, srcSymbol.$accessMode, srcSymbol.$name, 
            srcSymbol.$typeInfo.$nonnilableType, srcSymbol.$kind,
            new SymbolParam( .Stem, -1, cTypeStem ) );
         
         self.processSetSymSingle(
            node, nil, dstSymbol, true, workSymbol, true );
         self.writeln( "" );

         
      }
      else {
         self.writeln( "%s %s = %s;" ( dstTypeTxt, getSymbolName( dstSymbol ),
                                       getSymbolName( srcSymbol )) );
      }
   }
   
   filter( node.$block, self, node );

   self.processBlockPostProcess();
   

   if! node.$elseBlock {
      self.write( "} else {" );
      filter( _exp, self, node );
   }
   self.writeln( "}" );
}


pub override fn convFilter.processDeclArg(
   node: Nodes.DeclArgNode, opt: Opt ) mut
{
   // 引数がクロージャで使用されている場合、引数を別名で宣言する。
   // 関数の先頭で、クロージャ用の変数を別途宣言する。
   self.write( getCType( node.$expType, false ) );
   if node.$symbolInfo.$hasAccessFromClosure {
      self.write( ' _' );
   }
   else {
      self.write( ' ' );
   }
   self.write( node.get_name().txt );
   
   //self.write( string.format( "%s %s", cTypeStem, node.get_name().txt ) );

   // // filter( // node.info.argType,  self, node, baseIndent )
};

pub override fn convFilter.processDeclArgDDD(
   node: Nodes.DeclArgDDDNode, opt: Opt ) mut
{
   self.write( "%s _pDDD" (cTypeStem) );
};

pub override fn convFilter.processExpDDD(
   node: Nodes.ExpDDDNode, opt: Opt ) mut
{
   // self.write( "..." );
};

fn convFilter.processPrototype(
   parent:Nodes.Node, accessMode:Ast.AccessMode, needFormVal:bool,
   name:str, retType:str, argList:&List<&Nodes.Node> ) mut
{
   let mut letTxt = "";

   if not Ast.isPubToExternal( accessMode ) {
      letTxt = "static ";
   }
   self.write( string.format(
      "%s%s %s( %s _pEnv", letTxt, retType, name, cTypeEnvP ) );

   if needFormVal {
      self.write( string.format( ", %s _pForm", cTypeAnyP ) );
   }
   
   foreach arg, index in argList {
      self.write( ", " );
      filter( arg, self, parent );
   }
   self.write( " )" );
}



pub override fn convFilter.processDeclForm(
   node: Nodes.DeclFormNode, opt: Opt ) mut
{
   let formType = node.$expType;

   switch self.processMode {
      case .Prototype {
         self.processPrototype(
            node, formType.$accessMode, true,
            self.moduleCtrl.getCallFormName( formType ),
            getCRetType( formType.$retTypeInfoList ), node.$argList );
         
         self.writeln( ";" );
      }
      case .Form {
         self.processPrototype(
            node, formType.$accessMode, true,
            self.moduleCtrl.getCallFormName( formType ),
            getCRetType( formType.$retTypeInfoList ), node.$argList );

         fn process( prefix:str ) {
            self.pushIndent( ## );
            self.write( prefix );
            foreach arg, index in node.$argList {
               self.write( ", " );
               if! let workArg = arg@@@Nodes.DeclArgNode {
                  self.write( workArg.$name.txt );
               }
               else {
                  if! let workArg = arg@@@Nodes.DeclArgDDDNode {
                     self.write( "_pDDD" );
                  }
               }
            }
            self.writeln( ");" );
            self.popIndent();
         }
         
         self.writeln( "{" );
         self.pushIndent( ## );

         self.writeln( "if lune_isClosure( _pForm ) {" );
         switch getCRetType( formType.$retTypeInfoList ) {
            case "void" {
               process( "lune_closure( _pForm )( _pEnv, _pForm");
            }
            case cTypeInt {
               process( "return lune_closure_int( _pForm )( _pEnv, _pForm" );
            }
            case cTypeReal {
               process( "return lune_closure_real( _pForm )( _pEnv, _pForm" );
            }
            default {
               process( "return lune_closure( _pForm )( _pEnv, _pForm" );
            }
         }
         self.writeln( "}" );
         self.writeln( "else {" );
         switch getCRetType( formType.$retTypeInfoList ) {
            case "void" {
               process( "lune_func( _pForm )( _pEnv" );
            }
            case cTypeInt {
               process( "return lune_func_int( _pForm )( _pEnv" );
            }
            case cTypeReal {
               process( "return lune_func_real( _pForm )( _pEnv" );
            }
            default {
               process( "return lune_func( _pForm )( _pEnv" );
            }
         }
         self.writeln( "}" );

         
         self.popIndent();
         self.writeln( "}" );
      }
   }
}


pub override fn convFilter.processDeclFunc(
   node: Nodes.DeclFuncNode, opt: Opt ) mut
{
   let declInfo = node.get_declInfo();
   let name = self.moduleCtrl.getFuncName( node.$expType );
   
   fn processPrototype() {
      self.processPrototype(
         node, declInfo.$accessMode, isClosure( node.$expType ),
         name, getCRetType( node.$expType.$retTypeInfoList ), declInfo.$argList );
   }
   
   switch self.processMode {
      case .Form {
      }
      case .Prototype {
         processPrototype();
         self.writeln( ";" );
         return;
      }
      default {
         if opt.node.$kind ~= Nodes.NodeKind.$Block {
            self.write( self.getFunc2stem( node.$expType ) );
            //self.processVal2stem( node, opt.node );
         }
         // else {
         //    if! let rawName = node.$declInfo.$name {
         //       let scope = (unwrap node.$expType.$scope).$parent;
         //       let symbolInfo = unwrap scope.getSymbolInfoChild( rawName.txt );

         //       let formTxt = self.getFunc2stem( node.$expType );
         //       self.processDeclVarC( true, symbolInfo, formTxt );
         //    }
         // }
         return;
      }
   }
   if self.duringDeclFunc {
      if opt.node.$kind == Nodes.NodeKind.$Block {
         return;
      }
      self.write( self.moduleCtrl.getFuncName( node.$expType ) );
      return;
   }

   let! body = declInfo.$body {
      return;
   };
   
   self.duringDeclFunc = true;
   
   processPrototype();
   self.writeln( "" );
   self.writeln( "{" );

   self.pushRoutine( node.$expType, body );
   
   // self.processBlockPreProcess( body  );
   
   foreach argNode in node.$declInfo.$argList {
      if! let declArg = argNode@@@Nodes.DeclArgNode {
         let symbolInfo = declArg.$symbolInfo;
         if symbolInfo.$hasAccessFromClosure {
            // 引数がクロージャからアクセスされている場合は、
            // クロージャ用に変数を定義しなおす
            let symbolParam = self.scopeMgr.getSymbolParam( symbolInfo );
            self.writeln( "%s %s;" ( symbolParam.typeTxt, getSymbolName( symbolInfo ) ) );

            let mut skipFlag = false;
            if symbolParam.kind == .Stem {
               self.write( "lune_initVal_any(" );
               self.write( " %s, %s, %d, "
                           ( getSymbolName( symbolInfo ),
                             getBlockName( symbolInfo.$scope ), symbolParam.index ) );
            }
            else {
               // if symbolParam.kind == .Var and isStemType( symbolInfo.$typeInfo ) {
               //    self.write( "lune_initVal_var(" );
               //    self.write( " %s, %s, %d, "
               //                ( getSymbolName( symbolInfo ),
               //                  getBlockName( symbolInfo.$scope ), symbolParam.index ) );
               // }
               // else {
                  self.write( "lune_initVal_var(" );
                  self.write( " %s, %s, %d, "
                              ( getSymbolName( symbolInfo ),
                                getBlockName( symbolInfo.$scope ), symbolParam.index ) );

                  let valKind;
                  if isStemType( symbolInfo.$typeInfo ) {
                     valKind = ValKind.Stem;
                  }
                  else {
                     valKind = ValKind.Prim;
                  }
                  let workSymbol = new WorkSymbol(
                     symbolInfo.$scope, symbolInfo.$accessMode, "_%s" (symbolInfo.$name), 
                     symbolInfo.$typeInfo, symbolInfo.$kind,
                     new SymbolParam( valKind, -1, cTypeStem ) );    

                  self.processSym2stem( workSymbol );
                  self.writeln( ");" );
                  skipFlag = true;
               // }
            }
            if not skipFlag {
               let workArgName = "_" .. getSymbolName( symbolInfo );
               if not isStemType( symbolInfo.$typeInfo ) {
                  self.write( getLiteral2Any( workArgName, symbolInfo.$typeInfo ) );
               }
               else {
                  self.write( workArgName );
               }
               self.writeln( ");" );
            }
         }
      }
   }

   
   // let localVerNum = 0;
   // self.writeln( "lune_enter_block( _pEnv, %d );" (localVerNum) );

   // // クロージャでアクセスする外部変数を宣言
   // let scope = unwrap node.$expType.$scope;
   // forsort symbol in scope.$closureSymMap {
   //    self.writeln( "%s %s = lune_form_closure( _pForm, %d );"
   //                  ( cTypeStem, symbol.$name, unwrap scope.$closureSym2NumMap[ symbol ]  ) );
   // }
   

   // foreach refType, index in declInfo.get_retTypeList() {
   //    if index > 1 {
   //   self.write( ", " )
   //    }
   //filter( //    refType,  self, node, baseIndent )
   // }

   let mut breakKind = Nodes.BreakKind.None;

   self.process__func__symbol(
      declInfo.$has__func__Symbol, node.$expType.$parentInfo, name );

   // self.pushRoutine( node.$expType );
   
   filter( body,  self, node );

   self.popRoutine();

   // self.processBlockPostProcess();
   
   
   breakKind = body.getBreakKind( .Normal );

   switch breakKind {
      case .Return, .NeverRet {
         // body 終了位置は処理されない
      }
      default {
         //self.writeln( "return _pEnv->pNoneStem;" );
      }
   }

   self.writeln( "}" );

   //if declInfo.get_accessMode() == .Pub {
   let expType: Ast.TypeInfo = node.get_expType();
   if expType.get_accessMode() == .Pub {
      self.pubFuncName2InfoMap[ name ] = new PubFuncInfo(
         declInfo.get_accessMode(), node.get_expType() );
   }
};

pub override fn convFilter.processRefType(
   node: Nodes.RefTypeNode, opt: Opt ) mut
{
   // self.write( (node.get_refFlag() and "&" or "") ..
   //             (node.get_mutFlag() and "mut " or "") );
   // filter( node.get_name(),  self, node );
   // if node.get_array() == "array" {
   //    self.write( "[@]" );
   // }
   // elseif node.get_array() == "list" {
   //    self.write( "[]" );
   // }
};

pub override fn convFilter.processIf(
   node: Nodes.IfNode, opt: Opt ) mut
{
   let valList = node.get_stmtList();
   foreach val, index in valList {
      if index == 1 {
         self.write( "if ( lune_isCondTrue( " );
         self.processVal2stem( val.$exp, node );
         self.write( ") )" );
      }
      elseif val.$kind == .ElseIf {
         self.write( "else if ( lune_isCondTrue( " );
         self.processVal2stem( val.$exp, node );
         self.write( ") )" );
      }
      else {
         self.writeln( "else {" );
      }
      self.write( " " );
      filter( val.$block, self, node );
      self.write( "}" );
   }
};

pub override fn convFilter.processSwitch(
   node: Nodes.SwitchNode, opt: Opt ) mut
{
   // self.writeln( "do" );
   // self.pushIndent(##);
   // self.write( "local _switchExp = " );
   // filter( node.get_exp(),  self, node );
   // self.writeln( "" );

   // foreach caseInfo, index in node.get_caseList() {
   //    if index == 1 {
   //       self.write( "if " );
   //    }
   //    else {
   //       self.write( "elseif " );
   //    }
   //    let expList = caseInfo.get_expList();
   //    foreach expNode, listIndex in expList.get_expList() {
   //       if listIndex ~= 1 {
   //          self.write( " or " );
   //       }

   //       self.write( "_switchExp == " );
   //       filter( expNode, self, node );
   //    }
   //    self.write( " then" );
   //    filter( caseInfo.$block, self, node );
   // }
   // if! node.get_default() {
   //    self.writeln( "else " );
   //    self.pushIndent(##);
   //    filter( _exp, self, node );
   //    self.popIndent();
   // }
   // self.writeln( "end" );
   // self.popIndent();

   // self.writeln( "end" );
};


pub override fn convFilter.processMatch(
   node: Nodes.MatchNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent( ## );
   self.write( "%s _matchExp = " (cTypeAnyP) );
   filter( node.$val,  self, node );
   self.write( accessAny );
   self.writeln( ";" );

   self.writeln( "switch( _matchExp->val.alge.type ) {" );
   let algeType = node.$algeTypeInfo;
   let enumName = self.moduleCtrl.getAlgeEnumCName( algeType );
   foreach caseInfo, index in node.$caseList {
      let valInfo = caseInfo.$valInfo;
      self.writeln( "case %s_%s:" (enumName, valInfo.$name ) );
      self.pushIndent(##);
      self.writeln( "{" );
      self.pushIndent(##);
      if #valInfo.$typeList > 0 {
         // パラメータの代入
         let structTxt = self.moduleCtrl.getAlgeValStrCName( algeType, valInfo.$name );
         self.writeln( "%s * _pVal = (%s *)_matchExp->val.alge.pVal;"
                       (structTxt, structTxt) );
         foreach paramType, paramIndex in valInfo.$typeList {
            let paramName = caseInfo.$valParamNameList[ paramIndex ];
            self.writeln(
               "%s %s = _pVal->_val%d;"
               (getCType( paramType, false ), paramName, paramIndex )); 
         }
      }
      self.popIndent();

      filter( caseInfo.$block, self, node );

      self.writeln( "}" );
      self.writeln( "break;" );
      self.popIndent();
   }
   self.writeln( "}" );
   self.popIndent();

   self.writeln( "}" );
   
   // self.writeln( "do" );
   // self.pushIndent(##);
   // self.write( "local _matchExp = " );
   // filter( node.$val,  self, node );
   // self.writeln( "" );

   // let fullName = self.getFullName( node.$algeTypeInfo );
   // foreach caseInfo, index in node.$caseList {
   //    if index == 1 {
   //       self.write( "if " );
   //    }
   //    else {
   //       self.write( "elseif " );
   //    }
   //    self.writeln( "_matchExp[1] == %s.%s[1] then"
   //                  (fullName, caseInfo.$valInfo.$name ) );
   //    foreach paramName, paramNum in caseInfo.$valParamNameList {
   //       self.writeln( "   local %s = _matchExp[2][%d]" (paramName, paramNum ) );
   //    }
   //    filter( caseInfo.$block, self, node );
   // }
   // if! node.$defaultBlock {
   //    self.writeln( "else " );
   //    filter( _exp, self, node );
   // }
   // self.writeln( "end" );
   // self.popIndent();

   // self.writeln( "end" );
};


pub override fn convFilter.processWhile(
   node: Nodes.WhileNode, opt: Opt ) mut
{
   // self.write( "while " );

   // filter( node.get_exp(), self, node );
   // self.write( " " );
   // filter( node.get_block(), self, node );
   // self.writeln( "end" );
};

pub override fn convFilter.processRepeat(
   node: Nodes.RepeatNode, opt: Opt ) mut
{
   // self.write( "repeat " );
   // filter( node.get_block(),  self, node );
   // self.write( "until " );
   // filter( node.get_exp(),  self, node );
};

pub override fn convFilter.processFor(
   node: Nodes.ForNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   self.writeln( "%s _to;" (cTypeInt ) );
   self.writeln( "%s _inc;" (cTypeInt ) );
   self.writeln( "%s %s;" (cTypeInt, getSymbolName( node.$val ) ) );

   // node.get_block().$scope.

   //self.processSetValToSym( node, [ node.$val ], true, [ node.$to ] ## );
   self.processSetValSingle( node, nil, node.$val, true, node.$to, 0, false );
   self.writeln( "" );
   self.writeln( "_to = %s;" ( getSymbolName( node.$val )) );
   if! node.get_delta() {
      self.processSetValToSym( node, [ node.$val ], true, [ _exp ] ## );
      self.writeln( "_inc = %s;" ( getSymbolName( node.$val )) );
   }
   else {
      self.writeln( "_inc = 1;" );
   }
   self.processSetValToSym( node, [ node.$val ], true, [ node.$init ] ## );
   self.writeln( "" );

   self.processLoopPreProcess( node.$block );
   
   self.writeln(
      "for (; %s <= _to; %s += _inc ) {"
      (getSymbolName( node.$val ), getSymbolName( node.$val )) );
   self.writeln( "lune_reset_block( _pEnv );" );
   filter( node.$block,  self, node );
   self.writeln( "}" );

   self.processLoopPostProcess();

   self.popIndent();
   self.writeln( "}" );
};

pub override fn convFilter.processApply(
   node: Nodes.ApplyNode, opt: Opt ) mut
{
   // self.write( "for " );
   // let varList = node.get_varList();
   // foreach var, index in varList {
   //    if index > 1 {
   //       self.write( ", " );
   //    }
   //    self.write( var.txt );
   // }
   // self.write( " in " );
   // filter( node.$exp,  self, node );
   // self.write( " " );
   // filter( node.$block,  self, node );
   // self.writeln( "end" );
};

fn convFilter.processForeachSetupVal(
   parent:&Nodes.Node, scope:&Ast.Scope,
   workTxt:str, symTxt:str, symType:&Ast.TypeInfo ) mut
{
   let! symbolInfo = scope.getSymbolInfoChild( symTxt ) {
      Util.err( "not found symTxt -- %s" (symTxt)  );
   };

   self.processDeclVarC( true, symbolInfo, false );

   let srcSymbol = new WorkSymbol(
      symbolInfo.$scope, symbolInfo.$accessMode, workTxt,
      symbolInfo.$typeInfo, symbolInfo.$kind,
      new SymbolParam( .Stem, -1, cTypeStem ) );

   self.processSetSymSingle(
      parent, nil, symbolInfo, true, srcSymbol, true );
      
   // self.processSetValSingleDirect(
   //    parent, nil, symbolInfo, true, true, 0, false,
   //    fn () {
   //       processToIF(
   //          self.stream, self.moduleCtrl, symType,
   //          fn () {
   //             self.write( "(&%s)" (workTxt) );
   //             self.write( getAccessValFromStem( symType ) );
   //          } );
   //    } );
}

fn convFilter.processPoolForeachSetupVal(
   parent:&Nodes.Node, loopType:&Ast.TypeInfo, scope:&Ast.Scope,
   keyToken:&Parser.Token!, valToken:&Parser.Token! ) mut
{
  
   let valType = loopType.$itemTypeInfoList[ 1 ];
   let valSymTxt;
   if loopType.$kind == .Set {
      if! keyToken {
         valSymTxt = _exp.txt;
      }
      else {   
         //valSymTxt = "__val";
         Util.err( "keyToken is nil" );
      }
   }
   else {
      if! valToken {
         valSymTxt = _exp.txt;
      }
      else {   
         //valSymTxt = "__val";
         Util.err( "valToken is nil" );
      }
   }

   self.processForeachSetupVal( parent, scope, "_val", valSymTxt, valType );
}

fn convFilter.processMapForeachSetupVal(
   parent:&Nodes.Node, loopType:&Ast.TypeInfo, scope:&Ast.Scope,
   keyToken:&Parser.Token!, valToken:&Parser.Token!, keyTxt:str, valTxt:str ) mut
{
   when! keyToken {
      self.processForeachSetupVal( parent, scope, keyTxt, keyToken.txt,
                                   loopType.$itemTypeInfoList[ 1 ] );
   }
   self.writeln( "" );
   when! valToken {
      self.processForeachSetupVal( parent, scope, valTxt, valToken.txt,
                                   loopType.$itemTypeInfoList[ 2 ] );
   }
}

pub override fn convFilter.processForeach(
   node: Nodes.ForeachNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   
   self.write( "%s _obj = " ( cTypeAnyP ) );
   filter( node.$exp, self, node );
   self.write( accessAny );
   self.writeln( ";" );

   let indexSymbol:&Ast.SymbolInfo!;
   let loopType = node.$exp.$expType;
   switch loopType.$kind {
      case .List, .Array {
         self.writeln( "%s _itAny = lune_itList_new( _pEnv, _obj );" (cTypeAnyP) );
         if! let keyToken = node.$key {
            let! workSymbol = node.$block.$scope.getSymbolInfoChild( keyToken.txt ) {
               Util.err( "not found symbol -- %s" ( keyToken.txt ) );
            };
            indexSymbol = workSymbol;
            
            //self.writeln( "int %s = 0;" (keyToken.txt) );
            if self.scopeMgr.getSymbolValKind( workSymbol ) ~= .Prim {
               self.writeln( "int _%s = 0;" (keyToken.txt) );
            }
            else {
               self.processDeclVarC( true, workSymbol, true );
            }
         }
         else {
            indexSymbol = nil;
         }
         self.writeln( "%s _val;" ( cTypeStem ) );
      }
      case .Set {
         self.writeln( "%s _itAny = lune_itSet_new( _pEnv, _obj );" (cTypeAnyP) );
         indexSymbol = nil;
         self.writeln( "%s _val;" ( cTypeStem ) );
      }
      case .Map {
         self.writeln( "%s _itAny = lune_itMap_new( _pEnv, _obj );" (cTypeAnyP) );
         indexSymbol = nil;
         self.writeln( "lune_Map_entry_t _entry;" );
      }
      default {
         Util.err( "illegal kind -- %s" (loopType.$kind.$_txt ) );
      }
   }

   self.processLoopPreProcess( node.$block );

   switch loopType.$kind {
      case .List, .Array {
         self.writeln( "for ( ; lune_itList_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "      lune_itList_inc( _pEnv, _itAny ) )" );
      }
      case .Set {
         self.writeln( "for ( ; lune_itSet_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "      lune_itSet_inc( _pEnv, _itAny ) )" );
      }
      case .Map {
         self.writeln( "for ( ; lune_itMap_hasNext( _pEnv, _itAny, &_entry );" );
         self.writeln( "      lune_itMap_inc( _pEnv, _itAny ) )" );
      }
   }
   self.writeln( "{" );
   self.pushIndent(##);
   self.writeln( "lune_reset_block( _pEnv );" );
   
   when! indexSymbol {
      if self.scopeMgr.getSymbolValKind( indexSymbol ) ~= .Prim {
         self.writeln( "_%s++;" ( getSymbolName( indexSymbol ) ) );
         self.processDeclVarC( true, indexSymbol, true );
         self.processSetValSingleDirect(
            node, nil, indexSymbol, true, false, 0, false,
            fn () {
               self.write( "_%s;" ( getSymbolName( indexSymbol ) ) );
            });
         self.writeln( "" );
      }
      else {
         self.writeln( "%s++;" ( getSymbolName( indexSymbol ) ) );
      }
   }

   switch loopType.$kind {
      case .List, .Set, .Array {
         self.processPoolForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val );
      }
      case .Map {
         self.processMapForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val,
            "_entry.key", "_entry.val" );
      }
      default {
      }
   }
   
   filter( node.$block, self, node );

   self.popIndent();
   self.writeln( "}" );

   self.processLoopPostProcess();
   self.popIndent();
   self.writeln( "}" );
};

pub override fn convFilter.processForsort(
   node: Nodes.ForsortNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   
   self.write( "%s _obj = " ( cTypeAnyP ) );
   filter( node.$exp, self, node );
   self.write( accessAny );
   self.writeln( ";" );

   let loopType = node.$exp.$expType;
   switch loopType.$kind {
      case .Set {
         self.writeln(
            "%s _pList = lune_mtd_Map_createKeyList( _pEnv, _obj )%s;"
            (cTypeAnyP, accessAny) );
         self.writeln(
            "lune_mtd_List( _pList )->sort( _pEnv, _pList, %s );" (cValNil) );
         self.writeln( "%s _itAny = lune_itList_new( _pEnv, _pList );" (cTypeAnyP) );
         self.writeln( "%s _val;" ( cTypeStem ) );
      }
      case .Map {
         self.writeln(
            "%s _pKeyList = lune_mtd_Map_createKeyList( _pEnv, _obj )%s;"
            (cTypeAnyP, accessAny) );
         self.writeln(
            "lune_mtd_List( _pKeyList )->sort( _pEnv, _pKeyList, %s );" (cValNil) );
         self.writeln( "%s _itAny = lune_itList_new( _pEnv, _pKeyList );" (cTypeAnyP) );
         self.writeln( "%s _key;" ( cTypeStem ) );
      }
      default {
         Util.err( "illegal kind -- %s" (loopType.$kind.$_txt ) );
      }
   }

   self.processLoopPreProcess( node.$block );

   switch loopType.$kind {
      case .Set {
         self.writeln( "for ( ; lune_itList_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "      lune_itList_inc( _pEnv, _itAny ) )" );
      }
      case .Map {
         self.writeln( "for ( ; lune_itList_hasNext( _pEnv, _itAny, &_key );" );
         self.writeln( "      lune_itList_inc( _pEnv, _itAny ) )" );
      }
   }
   self.writeln( "{" );

   self.writeln( "lune_reset_block( _pEnv );" );
   
   switch loopType.$kind {
      case .Set {
         self.processPoolForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val );
      }
      case .Map {
         self.processMapForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val,
            "_key", "lune_mtd_Map_get( _pEnv, _obj, _key )" );
         
      }
      default {
      }
   }
   
   filter( node.$block, self, node );
   self.writeln( "}" );

   self.processLoopPostProcess();
   self.writeln( "}" );
   self.popIndent();
};


pub override fn convFilter.processExpUnwrap(
   node: Nodes.ExpUnwrapNode, opt: Opt ) mut
{
   fn processUnwrap( typeTxt:str ) {
      if! let defVal = node.$default {
         self.write( "lune_unwrap_%sDefault( " (typeTxt) );
         self.processVal2stem( node.$exp, node );
         self.write( "," );
         self.accessPrimVal( defVal, node );
         self.write( ")" );
      }
      else {
         self.write( "lune_unwrap_%s( " (typeTxt) );
         self.processVal2stem( node.$exp, node );
         self.write( ")" );
      }
   }
   
   switch node.$expType.$srcTypeInfo {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         processUnwrap( "int" );
      }
      case Ast.builtinTypeReal {
         processUnwrap( "real" );
      }
      default {
         self.write( "lune_unwrap_stem( " );
         self.processVal2stem( node.$exp, node );
         if! let defVal = node.$default {
            self.write( "," );
            self.processVal2stem( defVal, node );
            self.write( ")" );
         }
         else {
            self.write( ", NULL )" );
         }
      }
   }
   
   // if! node.$default {
   //    self.write( '_lune.unwrapDefault( ' );
   //    filter( node.$exp, self, node );
   //    self.write( ', ' );
   //    filter( _exp, self, node );
   //    self.write( ')');
   // }
   // else {
   //    self.write( '_lune.unwrap( ' );
   //    filter( node.$exp, self, node );
   //    self.write( ')');
   // }
}


fn convFilter.processCreateMRet(
   retTypeList:&List<&Ast.TypeInfo>, expList:&List<&Nodes.Node>, parent:&Nodes.Node ) mut
{
   if expList[ 1 ].$expType.$kind == .DDD and #expList == 1 {
      self.write( "_pDDD" );
      return;
   }
   
   self.write( "lune_createMRet" );

   let lastExp = expList[ #expList ];
   self.write( "( _pEnv, %s, %d" ( hasMultiVal( lastExp ), #expList ) );
   
   foreach exp, expIndex in expList {
      self.write( ", " );
      self.processVal2stem( exp, parent );
   }
   self.write( ")" );
}


alge MRetInfo {
   /** デフォルト form */
   Form,
   /** 独自で定義した form */
   FormFunc( refNode:&Nodes.ExpRefNode),
   Method( methodType:&Ast.TypeInfo),
   Func( refNode:&Nodes.Node ),
   DDD( exp2DDD:&Nodes.ExpToDDDNode),
}

pub fn convFilter.processCallWithMRet(
   parent:&Nodes.Node, mRetFuncName:str, retTypeName:str,
   funcArgNum:int, mRetInfo:MRetInfo,
   argList:&Nodes.ExpListNode ) mut
{
   let! mRetExp = argList.$mRetExp {
      return;
   };
   
   fn processDeclMRetProto() {
      self.write( "static %s %s( %s _pEnv"
         ( retTypeName, mRetFuncName, cTypeEnvP ) );
      
      fn processArgs() {
         foreach argNode, index in argList.$expList {
            if index >= mRetExp.$index {
               break;
            }
            let argType = argNode.$expType;
            self.write( ", %s arg%d" ( getCType( argType, false ), index ) );
         }
         self.write( ", %s pMRet )" (cTypeStem) );
      }

      match mRetInfo {
         case .Method( funcType ) {
            self.write( ", %s _pObj" (cTypeAnyP ) );
            processArgs();
         }
         case .Form {
            self.write( ", %s _pForm" (cTypeAnyP ) );
            processArgs();
         }
         case .FormFunc( funcNode ) {
            self.write( ", %s _pForm" (cTypeAnyP ) );
            processArgs();
         }
         case .DDD(node) {
            processArgs();
         }
         case .Func(funcNode) {
            processArgs();
         }
      }
   }
   
   switch self.processMode {
      case .Intermediate {
         processDeclMRetProto();
         self.writeln( "// %d" (parent.$pos.lineNo) );
         self.writeln( "{" );

         self.pushIndent( ## );

         let mut argTypeList:List<&Ast.TypeInfo> = [];
         
         fn processSetArg( primFlag:bool ) {
            foreach argNode, index in argList.$expList {
               let argType = argNode.$expType;
               if index == mRetExp.$index {
                  self.writeln( "lune_setMRet( _pEnv, pMRet%s );" (accessAny) );
               }
               if index >= mRetExp.$index {
                  if! let toDDDNode = argNode@@@Nodes.ExpToDDDNode {
                     self.write( "%s arg%d = " ( cTypeStem, index ) );
                     self.write( "lune_createDDD" );
                     let expList = toDDDNode.$expList.$expList;
                     let lastExp = expList[ #expList ];
                     self.write( "( _pEnv, %s, %d" ( hasMultiVal( lastExp ), #expList ) );
                     foreach exp, workIndex in expList {
                        // self.write(
                        //    ", LUNE_STEM_ANY( lune_getMRet( _pEnv, %d ) )" (workIndex + index - 2) );
                        self.write(
                           ", lune_getMRet( _pEnv, %d )" (workIndex + index - 2) );
                     }
                     self.write( ")" );
                     argTypeList.insert( Ast.builtinTypeDDD );
                  }
                  else {
                     let typeTxt;
                     if primFlag {
                        typeTxt = getCType(argType, false);
                        argTypeList.insert( argType.$srcTypeInfo );
                     }
                     else {
                        typeTxt = cTypeStem;
                        argTypeList.insert( Ast.builtinTypeStem );
                     }
                     self.write(
                        "%s arg%d = lune_getMRet( _pEnv, %d )"
                        (typeTxt, index, index - mRetExp.$index) );
                     if primFlag {
                        self.write( getAccessValFromStem( argType ) );
                     }
                     else {
                        self.write( "->val.pAny" );
                     }
                  }
                  self.writeln( "; // %s" (argType.getTxt( self.$typeNameCtrl## )) );
               }
               else {
                  argTypeList.insert( argNode.$expType );
               }
            }
            if retTypeName ~= "void" {
               self.write( "return " );
            }
         }

         let mut wroteArgFlag = false;

         fn processCreateDDD( expList:&List<&Nodes.Node>) {
            self.write( "lune_createDDD" );
            let lastExp = expList[ #expList ];
            self.write( "( _pEnv, %s, %d" ( hasMultiVal( lastExp ), #expList ) );

            for index = 1, #expList {
               let workExp = expList[ index ];
               self.write( ", " );
               switch argTypeList[ index ] {
                  case Ast.builtinTypeInt, Ast.builtinTypeChar {
                     self.write( "LUNE_STEM_INT(" );
                     self.write( "arg%d )" ( index ) );
                  }
                  case Ast.builtinTypeReal {
                     self.write( "LUNE_STEM_REAL(" );
                     self.write( "arg%d )" ( index ) );
                  }
                  default {
                     self.write( "arg%d" ( index ) );
                  }
               }
               // if index >= mRetExp.$index {
               //    self.write( "arg%d" ( index ) );
               // }
               // else {
               //    self.write( getLiteral2Any( "arg%d" ( index ), workExp.$expType ) );
               // }
            }
         }
        
         match mRetInfo {
            case .Method( funcType ) {
               processSetArg( true );
               self.write( "%s( _pEnv, _pObj"
                  ( self.moduleCtrl.getCallMethodCName( funcType )));
            }
            case .Form {
               processSetArg( true );
               //self.write( 'lune_call_form( _pEnv, _pForm, %d' (funcArgNum) );
               self.write( "lune_closure( _pForm )( _pEnv, pForm%s" (accessAny) );

               wroteArgFlag = true;
               processCreateDDD( argList.$expList );
               // self.write( "lune_createDDD" );
               // let expList = argList.$expList;
               // let lastExp = expList[ #expList ];
               // self.write( "( _pEnv, %s, %d" ( hasMultiVal( lastExp ), #expList ) );
            }
            case .FormFunc( funcNode ) {
               processSetArg( true );
               self.write( "%s( _pEnv, _pForm"
                           (self.moduleCtrl.getCallFormName( funcNode.$expType ) ) );
            }
            case .Func( funcNode ) {
               processSetArg( true );
               let mut wroteFuncFlag = false;
               let builtinFunc = TransUnit.getBuiltinFunc();

               if funcNode.$expType == builtinFunc.lune_print {
                  wroteFuncFlag = true;
                  self.write( "lune_print(" );
               }
                  
               if not wroteFuncFlag {
                  filter( funcNode, self, parent );
                  self.write( "(" );
               }
               self.write( " _pEnv" );
            }
            case .DDD(node) {
               processSetArg( true );
               wroteArgFlag = true;
               // self.write( "lune_createDDD" );
               // let expList = node.$expList.$expList;
               // let lastExp = expList[ #expList ];
               // self.write( "( _pEnv, %s, %d" ( hasMultiVal( lastExp ), #expList ) );
               processCreateDDD( node.$expList.$expList );
            }
         }

         if not wroteArgFlag {
            for index = 1, funcArgNum {
               self.write( ", arg%d" ( index ) );
            }
         }

         self.popIndent();
         self.writeln( ");" );
         self.writeln( "}" );
      }
      case .Prototype {
         processDeclMRetProto();
         self.writeln( "; // %d" (argList.$pos.lineNo) );
      }
   }
}

fn getMRetFuncName( node:&Nodes.Node ): str {
   return "lune_call_mret_%d" ( node.$id );
}

pub override fn convFilter.processExpToDDD( node: Nodes.ExpToDDDNode, opt: Opt ) mut
{
   switch self.processMode {
      case .Intermediate, .Prototype {
         if! let mRetExp =  node.$expList.$mRetExp {
            if mRetExp.$index > 0 {
               // index が 0 以下の場合、 ExpCallNode 側で処理するので、
               // ここでは index が 1 以上のものだけを処理する。
               self.processCallWithMRet(
                  node, getMRetFuncName( node ), cTypeStem,
                  #node.$expList.$expList, MRetInfo.DDD( node ), node.$expList );
            }
         }
         return;
      }
   }


   let expList = node.$expList.$expList;

   if! let mRetExp = node.$expList.$mRetExp {
      self.write( "%s( _pEnv" ( getMRetFuncName( node ) ) );
      foreach exp, index in expList {
         if index > mRetExp.$index {
            break;
         }
         self.write( ", " );
         //self.processVal2stem( exp, node );
         filter( exp, self, node );
      }
   }
   else {
      self.write( "lune_createDDD" );
      let lastExp = expList[ #expList ];
      self.write( "( _pEnv, %s, %d" ( hasMultiVal( lastExp ), #expList ) );

      let mut processed = false;
      if #node.$expType.$itemTypeInfoList > 0 {
         let itemType = node.$expType.$itemTypeInfoList[ 1 ].$srcTypeInfo.$nonnilableType;

         if Ast.isNumberType( itemType ) {
            // DDD が 数値に限定されている場合、
            // ExpMultiTo1 の型が 数値の nilable になるので、
            // any にしておく必要がある。
            processed = true;
            foreach exp in expList {
               self.write( ", " );
               self.processVal2stem( exp, node );
            }
         }
      }
      if not processed { 
         foreach exp in expList {
            self.write( ", " );
            self.processVal2stem( exp, node );
         }
      }
   }
   self.write( ")" );
}

/**
関数呼び出しの引数処理。

コールする関数の引数に合せて、引数を調整する。

例えばコールする関数の引数が ... の場合、 lune_createDDD() する等。

@param funcType コールする関数のタイプ
@param expListNode 引数リストノード
*/
pub fn convFilter.processCallArgList(
   funcType:&Ast.TypeInfo, expListNode: &Nodes.ExpListNode! ) mut
{
   when! expListNode {
      let expList = expListNode.$expList;
      foreach funcArgType, index in funcType.$argTypeInfoList {
         if index ~= 1 {
            self.write( ", " );
         }
         if #expList >= index {
            if funcArgType.$kind == .DDD {
               if expList[ index ].$kind == Nodes.NodeKind.$Abbr {
                  self.write( "lune_global.ddd0" );
               }
               else {
                  filter( expList[ index ], self, expListNode );
               }
               // self.processCreateDDD( true, expList, index, parent );
               // for expIndex = index, #expList {
               //    self.write( ", " );
               //    self.processVal2stem( expList[ expIndex ], parent );
               // }
               // self.write( ")" );
               return;
            }
            else {
               // if funcArgType.$kind == .Form {
               if isStemType( funcArgType ) {
                  self.processVal2stem( expList[ index ], expListNode );
               }
               else {
                  filter( expList[ index ], self, expListNode );
               }
            }
         }
         else {
            if funcArgType.$kind == .DDD {
               self.write( "lune_global.ddd0" );
            }
            else {
               self.write( cValNil );
            }
         }
      }
   }
}


fn convFilter.processCall(
   funcType:&Ast.TypeInfo, setArgFlag:bool, argList:&Nodes.ExpListNode! ) mut
{
   if not setArgFlag {
      self.write( "_pEnv" );


      if! let scope = funcType.$scope {
         if #scope.$closureSymList > 0 {
            // クロージャの場合
            // self.write( "lune_func2stem( _pEnv, (lune_closure_t *)NULL, 0, false, %d"
            //             (#scope.$closureSymList) );
            // foreach symbolInfo in scope.$closureSymList {
            //    self.write( ", " );
            //    self.write( symbol2Any( symbolInfo ) );
            // }
            // self.write( ")" );
            self.write( ", " );
            self.write( self.getPrepareClosure( "NULL", 0, false,
                                                scope.$closureSymList ) );
            self.write( accessAny );
         }
      }
   }

   when! argList {
      let mut expList:List<&Nodes.Node> = [];
      foreach expNode in argList.$expList {
         if expNode.$expType.$kind ~= .Abbr {
            expList.insert( expNode );
         }
      }

      if #expList > 0 {
         self.write( ", " );
         self.processCallArgList( funcType, argList );
      }
   }
   self.write( " )" );
}

pub override fn convFilter.processDeclClass(
   node: Nodes.DeclClassNode, opt: Opt ) mut
{
   let classType = node.$expType;
   let className = self.moduleCtrl.getClassCName( classType );

   switch self.processMode {
      case .Prototype {
         self.processDeclClassNodePrototype( node );
      }
      case .WideScopeVer {
         switch classType.$kind {
            case .Class {
               processClassDataInit( self.stream, self.moduleCtrl, classType );
            }
            case .IF {
               self.writeln(
                  'lune_type_meta_t lune_type_meta_%s = { "%s" };'
                  (className, className) );
            }
         }
      }
      case .DefClass {
         if classType.$kind == .Class {
            self.processDeclClassDef( node );
         }
      }
      case .Form, .InitModule {
         // self.write( self.moduleCtrl.getClassInitBlockName( classType ) );
         // self.write( "( _pEnv, NULL );" );
         if! let initBlockNode = node.$initBlock.$func {
            self.write(
               "%s(" (self.moduleCtrl.getMethodCName( initBlockNode.$expType) ) );
            self.processCall( initBlockNode.$expType, false, nil );
            self.writeln( ";" );
         }
      }
   }
   

   
   

   
   
//    let nodeInfo = node;
//    let classNameToken = nodeInfo.get_name();
//    let className = classNameToken.txt;
//    let classTypeInfo = node.get_expType();
//    let classTypeId = classTypeInfo.$typeId;
//    let isGenericClass = isGenericType( classTypeInfo );


//    if nodeInfo.get_accessMode() == .Pub {
//       self.classId2TypeInfo[ classTypeId ] = classTypeInfo;
//    }
//    self.classId2MemberList[ classTypeId ] = nodeInfo.get_memberList();

//    if! node.$moduleName {
//       self.write(
//          string.format( "local %s = require( %s )", className, _exp.txt ) );
//       switch node.$accessMode {
//          case .Pub, .Pro {
//             if self.needModuleObj {
//                self.writeln( "" );
//                self.write( "_moduleObj.%s = %s" (className, className ) );
//             }
//          }
//       }
//       return;
//    }
//    self.writeln( string.format( "local %s = {}", className ) );

//    let mut ifTxt = "";
//    if #classTypeInfo.$interfaceList > 0 {
//       foreach ifType in classTypeInfo.$interfaceList {
//          ifTxt = ifTxt .. self.getFullName( ifType ) .. ",";
//       }
//       ifTxt = "ifList = {%s}" (ifTxt);
//    }

//    let baseInfo = classTypeInfo.get_baseTypeInfo();
//    let mut baseTxt = "";
//    if baseInfo.get_typeId() ~= Ast.rootTypeId {
//       baseTxt = "__index = %s" ( self.getFullName( baseInfo ) );
//    }

//    if #ifTxt > 0 or #baseTxt > 0 {
//       let mut metaTxt = baseTxt;
//       if #baseTxt > 0 and #ifTxt > 0 {
//          metaTxt = "%s,%s" (baseTxt,ifTxt);
//       }
//       elseif #ifTxt > 0 {
//          metaTxt = ifTxt;
//       }
//       self.writeln( "setmetatable( %s, { %s } )" ( className, metaTxt ) );
//    }

//    if nodeInfo.get_accessMode() == .Pub {
//       if self.needModuleObj {
//          self.writeln( string.format( "_moduleObj.%s = %s", className, className ) );
//       }
//    }

//    foreach declNode in node.$declStmtList {
//       filter( declNode, self, node );
//    }


//    let mut hasConstrFlag = false;
//    let mut hasDestrFlag = false;
//    let mut memberList: List<&Nodes.DeclMemberNode> = [];
//    let fieldList: List<&Nodes.Node> = nodeInfo.get_fieldList();
//    let outerMethodSet: Set<str> = nodeInfo.get_outerMethodSet();
//    let mut methodNameSet: Set<str> = (@);
//    foreach field in fieldList {
//       let mut ignoreFlag = false;
//       if field.$kind == Nodes.NodeKind.$DeclConstr {
//          hasConstrFlag = true;
//          methodNameSet.add( "__init" );
//       }
//       if field.$kind == Nodes.NodeKind.$DeclDestr {
//          hasDestrFlag = true;
//          methodNameSet.add( "__free" );
//       }
//       if! let declMemberNode = field@@@Nodes.DeclMemberNode {
//          if not declMemberNode.$staticFlag {
//             memberList.insert( declMemberNode );
//          }
//       }
//       if! let methodNode = field@@@Nodes.DeclMethodNode {
//          let declInfo = methodNode.get_declInfo();
//          let methodNameToken = unwrap declInfo.get_name();
//          if outerMethodSet.has( methodNameToken.txt ) {
//             ignoreFlag = true;
//          }
//          methodNameSet.add( methodNameToken.txt );
//       }

//       if ( not ignoreFlag ) {
//          filter( field, self, node );
//       }
//    }

//    let mut destTxt = "";
//    if! self.getDestrClass( node.get_expType() ) {
//       destTxt = ", __gc = %s.__free" (_exp.getTxt(##));
//    }

//    self.writeln(```
// function %s.setmeta( obj )
//   setmetatable( obj, { __index = %s %s } )
// end```
//       ( className, className, destTxt ) );

//    if not hasConstrFlag {
//       // デフォルトコンストラクタ生成
//       methodNameSet.add( "__init" );

//       let oldFlag;
//       {
//          let initSymbol =
//             unwrap (unwrap classTypeInfo.$scope).getSymbolInfoChild( "__init" );
//          oldFlag = (unwrap initSymbol.$typeInfo.$scope).getSymbolInfoChild( "" ) ~= nil;
//       }

//       let mut superArgTxt = "";
//       let mut thisArgTxt = "";

//       if not oldFlag and baseInfo ~= Ast.headTypeInfo {
//          if! let superInit = (unwrap baseInfo.$scope).getSymbolInfoChild( "__init" ) {
//             foreach argType, index in superInit.$typeInfo.$argTypeInfoList {
//                if #superArgTxt > 0 {
//                   superArgTxt = superArgTxt .. ", ";
//                }
//                superArgTxt = "%s__superarg%d" (superArgTxt, index);
//             }
//          }
//       }

//       foreach member in memberList {
//          if #thisArgTxt > 0 {
//             thisArgTxt = thisArgTxt .. ", ";
//          }
//          thisArgTxt = thisArgTxt .. member.$name.txt;
//       }

//       let mut argTxt = superArgTxt;
//       if #argTxt > 0 {
//          argTxt = argTxt .. ",";
//       }
//       argTxt = argTxt .. thisArgTxt;

//       self.writeln( ```
// function %s.new( %s )
//    local obj = {}
//    %s.setmeta( obj )
//    if obj.__init then
//       obj:__init( %s )
//    end
//    return obj
// end
// function %s:__init( %s )
// ```
//             ( className, argTxt, className,
//               argTxt, className, argTxt ) );
//       self.pushIndent(##);

//       if baseInfo ~= Ast.headTypeInfo {
//          // Super クラスを持つ場合、その Super クラスの __init をコールする。
//          if! let superInit = (unwrap baseInfo.$scope).getSymbolInfoChild( "__init" ) {
//             self.write( "%s.__init( self" ( self.getFullName( baseInfo ) ) );
//             if #superArgTxt > 0 {
//                self.writeln( ", %s )" ( superArgTxt ) );
//             }
//             else {
//                self.writeln( ")" );
//             }
//          }
//       }

//       foreach member in memberList {
//          let memberName = member.$name.txt;
//          self.writeln( string.format( "self.%s = %s", memberName, memberName ));
//       }
//       self.popIndent();
//       self.writeln( 'end' );
//    }

//    // accessor
//    let scope = nodeInfo.get_scope();
//    foreach memberNode in nodeInfo.$memberList {
//       let memberNameToken = memberNode.get_name();
//       let memberName = memberNameToken.txt;
//       let getterName = "get_" .. memberName;
//       // let typeInfo = scope.getTypeInfo( getterName, scope, false );
//       // let autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
//       let mut autoFlag = not methodNameSet.has( getterName );
//       let prefix = memberNode.$staticFlag and className or "self";
//       if memberNode.get_getterMode() ~= .None and autoFlag
//       {
//          self.writeln( ```
// function %s:%s()
//    return %s.%s
// end``` ( className, getterName, prefix, memberName ) );
//          methodNameSet.add( getterName );
//       }
//       let setterName = "set_" .. memberName;
//       //typeInfo = scope.getTypeInfo( setterName, scope, false );
//       //autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
//       autoFlag = not methodNameSet.has( setterName );
//       if memberNode.get_setterMode() ~= .None and autoFlag
//       {
//          self.writeln( ```
// function %s:%s( %s )
//    %s.%s = %s
// end``` ( className, setterName, memberName, prefix, memberName, memberName ) );
//          methodNameSet.add( setterName );
//       }
//    }

//    // advertise
//    foreach advertiseInfo in node.$advertiseList {
//       let memberName = advertiseInfo.$member.$name.txt;
//       let mut memberType = advertiseInfo.$member.$expType;
//       foreach child in memberType.$children {
//          if child.$kind == Ast.TypeInfoKind.Method and
//             child.$accessMode ~= .Pri and
//             not child.$staticFlag
//          {
//             let childName = advertiseInfo.$prefix .. child.getTxt(##);
//             if not methodNameSet.has( childName ) {
//                self.writeln( ```
// function %s:%s( ... )
//    return self.%s:%s( ... )
// end
// ``` (className, childName, memberName, childName) );
//             }
//          }
//       }
//    }

//    // init block
//    if #nodeInfo.$initStmtList > 0 {
//       self.writeln( "do" );
//       self.pushIndent(##);
//       foreach initStmt in nodeInfo.$initStmtList {
//          filter( initStmt, self, node );
//          self.writeln( "" );
//       }
//       self.popIndent();
//       self.writeln( "end" );
//    }

//    // Mapping
//    if classTypeInfo.isInheritFrom( Ast.builtinTypeMapping, nil ) {
//       let mut declArgTxt = "val";
//       let mut argTxt = "{}, val";
//       if isGenericType( classTypeInfo ) {
//          declArgTxt = "val, __alt2mapFunc";
//          argTxt = "{ __alt2mapFunc = __alt2mapFunc }, val";
//       }

//       self.writeln( ```
// function %s:_toMap()
//   return self
// end
// function %s._fromMap( %s )
//   local obj, mes = %s._fromMapSub( %s )
//   if obj then
//      %s.setmeta( obj )
//   end
//   return obj, mes
// end
// function %s._fromStem( %s )
//   return %s._fromMap( %s )
// end
// ``` (className, className, declArgTxt,
//       className, argTxt, className,
//       className, declArgTxt, className, declArgTxt ));

//       self.writeln( 'function %s._fromMapSub( obj, val )' (className ));

//       if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
//          self.writeln( ```
//    local result, mes = %s._fromMapSub( obj, val )
//    if not result then
//       return nil, mes
//    end
// ``` (self.getFullName( classTypeInfo.$baseTypeInfo )) );
//       }

//       self.writeln( '   local memInfo = {}' );

//       foreach memberNode in node.$memberList {
//          let funcTxt, nilable, child = self.getMapInfo( memberNode.$expType );
//          self.writeln(
//             '   table.insert( memInfo, { name = "%s", func = %s, nilable = %s, child = %s } )'
//             ( memberNode.$name.txt, funcTxt, nilable, child ) );
//       }

//       self.writeln( ```
//    local result, mess = _lune._fromMap( obj, val, memInfo )
//    if not result then
//       return nil, mess
//    end
//    return obj
// end```);
//    }
};


pub override fn convFilter.processExpCall(
   node: Nodes.ExpCallNode, opt: Opt ) mut
{
   switch self.processMode {
      case .Intermediate, .Prototype {
         if! let argList = node.$argList {

            let funcNode = node.$func;
            let funcType = funcNode.$expType;

            let mRetInfo;
            switch funcNode.$expType.$kind {
               case .Method {
                  mRetInfo = MRetInfo.Method( funcType );
               }
               case .Form {
                  mRetInfo = MRetInfo.Form;
               }
               case .FormFunc {
                  mRetInfo = MRetInfo.FormFunc( unwrap node.$func@@@Nodes.ExpRefNode );
               }
               default {
                  mRetInfo = MRetInfo.Func( node.$func );
               }
            }
            
            self.processCallWithMRet(
               node, getMRetFuncName( node ), getCRetType( node.$expTypeList ),
               #funcType.$argTypeInfoList, mRetInfo, argList );
         }
         return;
      }
   }
   
   
   
   fn process() {
      if node.$func.$expType.$kind == .Form {
         self.write( 'lune_call_form( _pEnv, ' );
         filter( node.$func, self, node );
         self.write( accessAny );
         if! let argList = node.$argList {
            if #argList.$expList > 0 {
               self.write( ', ' );
               self.processCallArgList( node.$func.$expType, node.$argList );
            }
         }
         else {
            self.write( ', lune_global.ddd0' );
         }
         self.write( ' )' );

         return;
      }


      // let classTypeInfo:&Ast.TypeInfo = nil;
      // if! let fieldNode = node.$func@@@Nodes.RefFieldNode {
      //    let prefixType = fieldNode.$prefix.$expType;
      //    switch prefixType.$kind {
      //       case .Class, .IF {
      //          classTypeInfo = prefixType;
      //       }
      //    }
      // }
      // processToIFGeneric(
      //    self.stream, self.moduleCtrl,
      //    classTypeInfo, expType:&Ast.TypeInfo, process:form )
      
      
      let mut wroteFuncFlag = false;
      let mut setArgFlag = false;

      fn fieldCall():bool {

         let! fieldNode = node.$func@@@Nodes.RefFieldNode {
            return true;
         };
         let prefixNode = fieldNode.$prefix;

      //    fn processSet(): bool {
      //       setArgFlag = true;
      //       wroteFuncFlag = true;

      //       switch fieldNode.$field.txt {
      //          case "add", "del" {
      //             filter( prefixNode, self, fieldNode );
      //             self.write( "[" );
      //             if! let argList = node.$argList {
      //                filter( argList, self, fieldNode );
      //             }
      //             self.write( "]" );
      //             switch fieldNode.$field.txt {
      //                case "add" {
      //                   self.write( "= true" );
      //                }
      //                case "del" {
      //                   self.write( "= nil" );
      //                }
      //             }
      //             return false;
      //          }
      //       }

      //       self.write( "_lune._Set_%s(" ( fieldNode.$field.txt ) );
      //       filter( prefixNode, self, fieldNode );
      //       return true;
      //    }

         let prefixType = prefixNode.$expType;

         fn processEnumAlge() {
            // wroteFuncFlag = true;
            // let fieldExpType = fieldNode.$expType;
            // let mut methodName = fieldNode.$field.txt;
            // if methodName == "get__txt" {
            //    methodName = "_getTxt";
            // }
            // self.write( "_%s( " ( methodName ) );
            // if fieldExpType.$staticFlag {
            //    setArgFlag = false;
            // }
            // else {
            //    filter( prefixNode, self, fieldNode );
            //    setArgFlag = true;
            // }
         }

         if node.$nilAccess {
      //       wroteFuncFlag = true;
      //       setArgFlag = true;
      //       switch prefixType.$kind {
      //          case .List, .Array {
      //             self.write( "_lune.nilacc( table.%s, nil, 'list', "
      //                         (fieldNode.$field.txt ) );
      //             filter( prefixNode, self, fieldNode );
      //          }
      //          default {
      //             self.write( "_lune.nilacc( " );
      //             filter( prefixNode, self, fieldNode );
      //             self.write( ", '%s', 'callmtd' " (fieldNode.$field.txt ) );
      //          }
      //       }
         }
         else {
            switch prefixType.$kind {
               // case .List, .Array {
               //    setArgFlag = true;
               //    wroteFuncFlag = true;
               //    self.write( "table.%s( " (fieldNode.$field.txt ) );
               //    filter( prefixNode, self, fieldNode );
               // }
               // case .Set {
               //    if not processSet() {
               //       return false;
               //    }
               // }
               case .Enum, .Alge {
                  processEnumAlge();
               }
               // case .Box {
               //    filter( prefixNode, self, fieldNode );
               //    self.write( "[1]" );
               //    return false;
               // }
               // case .Class {
               //    if prefixType.isInheritFrom( Ast.builtinTypeMapping, nil ) and
               //       isGenericType( prefixType ) and
               //       ( fieldNode.$field.txt == "_fromMap" or
               //         fieldNode.$field.txt == "_fromStem" )
               //    {
               //       wroteFuncFlag = true;
               //       setArgFlag = true;
               //       filter( node.$func, self, node );
               //       self.write( "( " );
               //       if! let argList = node.$argList {
               //          filter( argList,  self, node );
               //          self.write( ", " );
               //       }
               //       self.outputAlter2MapFunc( self, prefixType.createAlt2typeMap(false) );
               //       self.write( ")" );
               //       return false;
               //    }
               // }
            }
         }
         return true;
      }

      if not fieldCall() {
         return;
      }

      if! let refNode = node.$func@@@Nodes.ExpRefNode {
         let builtinFunc = TransUnit.getBuiltinFunc();
         
         if refNode.$expType == builtinFunc.lune_print {
            wroteFuncFlag = true;
            self.write( "lune_print(" );
         }
         // elseif refNode.$token.txt == "super" {
         //    wroteFuncFlag = true;
         //    setArgFlag = true;
         //    let funcType = refNode.$expType;
         //    self.write( "%s.%s( self " ( self.getFullName( funcType.$parentInfo ),
         //                                 funcType.$rawTxt ) );
         // }
      }
      
      if not wroteFuncFlag {
         switch node.$func.$expType.$kind {
            case .Method {
               if! let fieldNode = node.$func@@@Nodes.RefFieldNode {
                  //self.write( "lune_call_method_0( _pEnv, " );
                  self.write( "%s( _pEnv, "
                              ( self.moduleCtrl.getCallMethodCName( node.$func.$expType )));
                  filter( fieldNode.$prefix, self, fieldNode );
                  self.write( accessAny );
                  // self.write(
                  //    ",offsetof( lune_mtd_%s_t, %s )"
                  //    (self.getFullName( fieldNode.$prefix.$expType ), fieldNode.$field.txt ) );
               }
               wroteFuncFlag = true;
               setArgFlag = true;
            }
            case .FormFunc {
               self.write( "%s( _pEnv, "
                           ( self.moduleCtrl.getCallFormName( node.$func.$expType ) ));
               filter( node.$func, self, node );
               self.write( accessAny );
               wroteFuncFlag = true;
               setArgFlag = true;
            }
         }
      }
      
      if not wroteFuncFlag {
         // if node.$nilAccess {
         //    self.write( "_lune.nilacc( " );
         //    filter( node.$func, self, node );
         //    self.write( ", nil, 'call'" );
         //    wroteFuncFlag = true;
         // }
         // else {
         filter( node.$func, self, node );

         // switch node.$func.$expType.$kind {
         //    case .FormFunc { 
         //       self.write( "->val.form.pFunc" );
         //    }
         // }

         
         self.write( "( " );
         // }
      }

      // if not setArgFlag {
      //    self.write( "_pEnv, " );


      //    if! let scope = node.$func.$expType.$scope {
      //       if #scope$.$closureSymList > 0 {
      //          // クロージャの場合
      //          self.write( "lune_func2stem( _pEnv, (lune_closure_t *)NULL, 0, false, %d"
      //                      (#scope$.$closureSymList) );
      //          foreach symbolInfo in scope.$closureSymList {
      //             self.write( ", %s" (symbolInfo.$name) );
      //          }
      //          self.write( ")" );
      //       }
      //       else {
      //          self.write( "NULL" );
      //       }
      //    }
      //    else {
      //       self.write( "NULL" );
      //    }
      // }

      // if! let argList = node.$argList {
      //    let mut expList:List<&Nodes.Node> = [];
      //    foreach expNode in argList.$expList {
      //       if expNode.$expType.$kind ~= .Abbr {
      //          expList.insert( expNode );
      //       }
      //    }

      //    if #expList > 0 {
      //       self.write( ", " );
      //       self.processCallArgList( node.$func.$expType, node.$argList );
      //    }
      // }
      // self.write( " )" );

      self.processCall( node.$func.$expType, setArgFlag, node.$argList );
   }


   let mut isMret = false;
   if! let argList = node.$argList {
      if! let mRetExp = argList.$mRetExp {
         // 多値の引数を含む場合
         isMret = true;
         self.write( "%s( _pEnv" ( getMRetFuncName( node ) ) );

         let funcNode = node.$func;
         switch funcNode.$expType.$kind {
            case .Method {
               if! let fieldNode = node.$func@@@Nodes.RefFieldNode {
                  self.write( ", " );
                  filter( fieldNode.$prefix, self, fieldNode );
                  self.write( accessAny );
               }
            }
            case .Form, .FormFunc {
               self.write( ", " );
               filter( node.$func, self, node );
               self.write( accessAny );
            }
         }
         foreach argNode, index in argList.$expList {
            if index <= mRetExp.$index {
               self.write( ", " );
               filter( argNode, self, argList );
            }
         }
         self.write( ")" );
      }
   }
   if not isMret {
      process();
   }
};

pub override fn convFilter.processExpAccessMRet(
   node: Nodes.ExpAccessMRetNode, opt:Opt ) mut

{
   self.write( "lune_getMRet( _pEnv, %d )" ( node.$index - 1 ) );
   self.write( getAccessValFromStem( node.$expType ) );
};


pub override fn convFilter.processExpList(
   node: Nodes.ExpListNode, opt: Opt ) mut
{
   let expList = node.get_expList();
   //let expList = node.$expList;
   foreach exp, index in expList {
      if exp.$expType.$kind == .Abbr {
         break;
      }
      if index > 1 {
         self.write( ", " );
      }
      filter( exp, self, node );
   }
};

pub override fn convFilter.processExpOp1(
   node: Nodes.ExpOp1Node, opt: Opt ) mut
{
   let mut op = node.$op.txt;
   // if op == ",,," or op == ",,,," {
   //     filter( node.$exp,  self, node );
   // }
   switch op { 
      case "~", "+", "-" {
         self.write( op );
         self.accessPrimVal( node.$exp, node );
      }
      case "not" {
         self.write( "lune_op_not( _pEnv, " );
         self.processVal2stem( node.$exp, node );
         self.write( ")" );
      }
      default {
         Util.err( "not support op -- %s" (op) );
      }
   }
};

pub override fn convFilter.processExpMultiTo1(
   node: Nodes.ExpMultiTo1Node, opt: Opt ) mut
{
   self.write( "lune_fromDDD( " );
   filter( node.$exp, self, node );
   self.write( accessAny );
   self.write( ", 0 )" );
   if node.$exp.$expType.$kind == .DDD and
      Ast.isNumberType( node.$expType.$srcTypeInfo.$nonnilableType )
   {
      self.write( accessAny );
   }
   else {
      self.write( getAccessValFromStem( node.$exp.$expType ) );
   }
}

pub override fn convFilter.processExpCast(
   node: Nodes.ExpCastNode, opt: Opt ) mut
{
   let exp = node.$exp;
   let expType = exp.$expType;
   let nodeExpType = node.$expType;
   let castType = node.$castType;
   switch node.$castKind {
      case .Implicit {
         switch castType.$kind {
            case .IF {   
               if expType.$kind == .Class {
                  self.write( "lune_getIF( _pEnv, &lune_if_%s( "
                              (self.moduleCtrl.getClassCName( expType )));
                  filter( node.$exp, self, node );
                  self.write( accessAny );
                  self.write( ")->%s )" ( self.moduleCtrl.getClassCName( castType ) ) );
               }
            }
            case .FormFunc {
               self.write( self.getFunc2stem( expType ) );
            }
            case .Form {
               // pending 本来は処理が異なる
               self.write( self.getFunc2stem( expType ) );
            }
            default {
               filter( exp, self, node );
            }
         }
      }
      case .Force {
         if Ast.isNumberType( castType ) {
            self.write( "(%s)" ( getCType( castType, false ) ) );
            filter( exp, self, node );
         }
         else {
            error( "not support cast" );
         }
      }
   }
   // if node.$force {
   //    if node.$expType.equals( Ast.builtinTypeInt ##) {
   //       self.write( "math.floor(" );
   //       filter( node.$exp,  self, node );
   //       self.write( ")" );
   //    }
   //    else {
   //       filter( node.$exp,  self, node );
   //    }
   // }
   // else {
   //    self.write( "_lune.__Cast( " );
   //    filter( node.$exp,  self, node );
   //    let castKind;
   //    let mut classObj = "nil";
   //    switch node.$expType.$nonnilableType {
   //       case Ast.builtinTypeInt {
   //          castKind = LuaMod.CastKind.Int;
   //       }
   //       case Ast.builtinTypeReal {
   //          castKind = LuaMod.CastKind.Real;
   //       }
   //       case Ast.builtinTypeString {
   //          castKind = LuaMod.CastKind.Str;
   //       }
   //       default {
   //          castKind = LuaMod.CastKind.Class;
   //          classObj = self.getFullName( node.$expType.$nonnilableType );
   //       }
   //    }
   //    self.write( ", %d, %s )" ( castKind, classObj) );
   // }
};


pub override fn convFilter.processExpParen(
   node: Nodes.ExpParenNode, opt: Opt ) mut
{
   self.write( "(" );

   self.accessPrimVal( node.$exp, node );
   // filter( node.$exp,  self, node );
   // self.write( getAccessPrimValFromStem( #node.$exp.$expTypeList > 1,
   //                                       node.$expType, 0 ) );
   self.write( " )" );
};



/**
form から 関数をコールする wrapper を作成。
*/
fn convFilter.processWrapForm2Func( funcType:&Ast.TypeInfo ) mut
{
   self.write( "static %s _wrap_%s_%d( %s _pEnv, %s _pForm, "
               ( cTypeStem, funcType.$rawTxt, funcType.$typeId,
                 cTypeEnvP, cTypeAnyP ) );  
   foreach argType, index in funcType.$argTypeInfoList {
      self.write( ", %s arg%d" (getCType( argType, false ), index ) );
   }
   self.writeln( ")" );
   self.writeln( "{" );
   self.writeln( 'return %s( _pEnv, _pForm' );
   foreach argType, index in funcType.$argTypeInfoList {
      
   }
   self.writeln( "}" );
}

fn convFilter.processAndOr( node: Nodes.ExpOp2Node,
                            opTxt: str, parent: &Nodes.Node ) mut
{
   fn isAndOr( exp:&Nodes.Node ) : bool {
      if! let parentNode = exp@@@Nodes.ExpOp2Node {
         switch parentNode.$op.txt {
            case "and", "or" {
               return true;
            }
         }
      }
      return false;
   }
   
   let mut firstFlag = not isAndOr( parent );
   if firstFlag {
      self.writeln( "lune_popVal( _pEnv, lune_incStack( _pEnv ) ||" );
      self.pushIndent( ## );
   }

   let opCC;
   if opTxt == "and" {
      opCC = "&&";
   }
   else {
      opCC = "||";
   }
   
   if isAndOr( node.$exp1 ) {
      filter( node.$exp1, self, node );
   }
   else {
      self.write( "lune_setStackVal( _pEnv, " );
      self.processVal2stem( node.$exp1, node );
      self.write( ") " );
      //self.writeln( opCC );
   }
   if isAndOr( node.$exp2 ) {
      filter( node.$exp2, self, node );
   }
   else {
      self.writeln( opCC );
      self.write( "lune_setStackVal( _pEnv, " );
      self.processVal2stem( node.$exp2, node );
      self.write( ") " );
   }

   if firstFlag {
      self.write( ")" );

      if not isStemType( node.$expType ) {
         self.write( getAccessPrimValFromStem( false, node.$expType, 0 ) );
      }
      
      self.popIndent();
   }
}

pub override fn convFilter.processExpOp2(
   node: Nodes.ExpOp2Node, opt: Opt ) mut
{
   let mut opTxt = node.$op.txt;

   switch opTxt {
      case "=" {
         let workParent:&Nodes.Node;
         //let symbolList = node.$exp1.getSymbolInfo();
         let expList;
         let mRetExp:&Nodes.MRetExp!;
         if! let expListNode = node.$exp2@@@Nodes.ExpListNode {
            expList = expListNode.$expList;
            mRetExp = expListNode.$mRetExp;
            workParent = expListNode;
         }
         else {
            expList = [ node.$exp2 ];
            mRetExp = nil;
            workParent = node;
         }
         
         self.processSetValToNode( node, node.$exp1, expList, mRetExp );
      }
      case "and", "or" {
         self.processAndOr( node, opTxt, opt.node );
      }
      default {
         if! Ast.bitBinOpMap[ opTxt ] {
            // ビット演算の処理
            switch _exp {
               case .LShift {
                  opTxt = "<<";
               }
               case .RShift {
                  opTxt = ">>";
               }
            }
            //self.accessPrimVal( node.$exp1, node );
            filter( node.$exp1, self, node );
            self.write( " " .. opTxt .. " " );
            //self.accessPrimVal( node.$exp2, node );
            filter( node.$exp2, self, node );
         }
         else {
            if Ast.compOpSet.has( opTxt ) {
               self.write( "LUNE_STEM_BOOL( " );
               self.accessPrimVal( node.$exp1, node );
               // filter( node.$exp1, self, node );

               self.write( " " .. opTxt .. " " );
               self.accessPrimVal( node.$exp2, node );
               // filter( node.$exp2, self, node );

               self.write( ")" );
            }
            elseif Ast.mathCompOpSet.has( opTxt ) {
               self.write( "LUNE_STEM_BOOL( " );
               self.accessPrimVal( node.$exp1, node );
               // filter( node.$exp1, self, node );

               self.write( " " .. opTxt .. " " );
               self.accessPrimVal( node.$exp2, node );
               // filter( node.$exp2, self, node );

               self.write( ")" );
            }
            else {
               // self.accessPrimVal( node.$exp1, node );
               filter( node.$exp1, self, node );
               self.write( " " .. opTxt .. " " );
               // self.accessPrimVal( node.$exp2, node );
               filter( node.$exp2, self, node );

            }
         }
      }
   }
};

pub override fn convFilter.processExpRef(
   node: Nodes.ExpRefNode, opt: Opt ) mut
{
   if self.processMode == .Immediate {
      self.accessSymbolSet.add( node.$symbolInfo );
   }
   
   if node.$token.txt == "super" {
      let funcType = node.$expType;
      self.write( "%s.%s" ( self.getFullName( funcType.$parentInfo ),
                            funcType.$rawTxt ) );
   }
   elseif node.$token.txt == "..." {
      self.write( "_pDDD" );
   }
   elseif node.$expType.equals( TransUnit.getBuiltinFunc().lune__load ##) {
      self.write( "lune__load" );
   }
   else {
      let symbolInfo = node.$symbolInfo;
      if self.scopeMgr.getSymbolValKind( symbolInfo ) == .Var {
         self.write( "%s->stem" ( getSymbolName( symbolInfo )) );
         self.write( getAccessValFromStem( symbolInfo.$typeInfo ) );
      }
      else {
         // if symbolInfo.$accessMode == .Pub and
         //    symbolInfo.$kind == Ast.SymbolKind.Var
         // {
         //    if self.needModuleObj {
         //       self.write( "_moduleObj." );
         //    }
         // }
         if symbolInfo.$kind == .Fun or symbolInfo.$typeInfo.$kind == .Func {
            self.write( self.moduleCtrl.getFuncName( symbolInfo.$typeInfo ) );
         }
         else {
            //self.write( node.$token.txt );
            self.write( getSymbolName( symbolInfo ) );
         }
      }
   }
};

pub override fn convFilter.processExpRefItem(
   node: Nodes.ExpRefItemNode, opt: Opt ) mut
{
   // if node.$nilAccess {
   //    self.write( "_lune.nilacc( " );
   //    filter( node.$val, self, node );
   //    self.write( ", nil, 'item', " );
   //    if! node.$index {
   //       filter( _exp, self, node );
   //    }
   //    else {
   //       self.write( "'%s'" ( unwrap node.$symbol ) );
   //    }
   //    self.write( ")" );
   // }
   // else {

   let val = node.$val;
   let valType = val.$expType;
   
   if valType.equals( Ast.builtinTypeString ##) {
      self.accessPrimVal( val, node );
      self.write( "->val.str.pStr[" );
      if! let indexNode = node.$index {
         filter( indexNode, self, node );
      }
      else {
         error( "index is nil" );
      }
      self.write( "- 1 ]" );
   }
   else {
      processToIF( self.stream, self.moduleCtrl, node.$expType,
                   fn () {
                      switch valType.$kind {
                         case .List { 
                            self.write( "lune_mtd_List_refAt( _pEnv, " );
                            // self.processVal2stem( val, node );
                            filter( val, self, node );
                            self.write( accessAny );
                            self.write( ", " );
                            self.accessPrimVal( unwrap node.$index, node );
                            self.write( ")" );
                            self.write( getAccessValFromStem(
                               valType.$itemTypeInfoList[ 1 ] ) );
                         }
                      }
                   } );
   }
   // }
};

pub override fn convFilter.processRefField(
   node: Nodes.RefFieldNode, opt: Opt ) mut
{
   if! let symbolInfo = node.$symbolInfo {
      if symbolInfo.$typeInfo.$kind == .Enum {
         if symbolInfo.$kind == .Mbr {
            // enum 値の場合
            self.write( self.moduleCtrl.getEnumTypeName( symbolInfo.$typeInfo ) );
            self.write( "__%s" ( getSymbolName( symbolInfo )) );
            return;
         }
         Util.err( "illegal access" );
      }

      switch symbolInfo.$kind {
         case .Mbr {
            if node.$prefix.$expType.$kind == .Class {
               if symbolInfo.$staticFlag {
                  self.write( self.moduleCtrl.getClassMemberName( symbolInfo ) );
               }
               else {
                  let className = self.moduleCtrl.getClassCName( node.$prefix.$expType );
                  self.write( "lune_obj_%s( " (className) );
                  if! let expRefNode = node.$prefix@@@Nodes.ExpRefNode {
                     // self.write( getSymbolName( expRefNode.$symbolInfo ));
                     filter( node.$prefix, self, node );
                  }
                  else {
                     filter( node.$prefix, self, node );
                  }
                  self.write( "%s )->%s" (accessAny, node.$field.txt) );
               }
            }
         }
         case .Mtd {
            if not symbolInfo.$staticFlag {
               Util.err( "not support yet. instanse method." );
            }
            self.write( self.moduleCtrl.getMethodCName( symbolInfo.$typeInfo ) );
         }
      }
   }
   
   // let parent = opt.node;

   // if node.$nilAccess {
   //    self.write( '_lune.nilacc( ' );
   //    filter( prefix,  self, node );
   //    self.write( ', "%s" )' (node.$field.txt) );
   // }
   // else {
   //    filter( prefix,  self, node );

   //    let mut delimit = ".";
   //    if parent.$kind == Nodes.NodeKind.$ExpCall {
   //       if node.get_expType().get_kind() == Ast.TypeInfoKind.Method {
   //          delimit = ":";
   //       }
   //       else {
   //          delimit = ".";
   //       }
   //    }
   //    let fieldToken = node.get_field();
   //    self.write( delimit .. fieldToken.txt );
   // }
};

pub override fn convFilter.processExpOmitEnum(
   node: &Nodes.ExpOmitEnumNode, opt: Opt ) mut
{
   // self.write( "%s.%s" ( self.getFullName( node.$expType ), node.$valToken.txt ) );
};

pub override fn convFilter.processGetField(
   node: Nodes.GetFieldNode, opt: Opt ) mut
{
   let prefixNode = node.get_prefix();
   let prefixType = prefixNode.$expType;
   let fieldTxt = node.get_field().txt;

   if prefixType.$kind == .Enum {
      let mut enumFullName = self.moduleCtrl.getEnumTypeName( prefixType );
      switch fieldTxt {
         case "_allList" {
            self.write( "%s_get__allList( _pEnv )" (enumFullName) );
         }
         case "_txt" {
            self.write( "%s_get__txt( _pEnv, " (enumFullName) );
            filter( prefixNode, self, node );
            self.write( ")" );
         }
      }
   }
   elseif prefixType.$kind == .Class or prefixType.$kind == .IF {
      let getterType = unwrap prefixType.$scope$.getTypeInfoField$(
         "get_%s" (fieldTxt), true, unwrap prefixType.$scope );
      processToIFGeneric(
         self.stream, self.moduleCtrl,
         prefixType, getterType.$retTypeInfoList[1], fn ()
         {
            self.write(
               "%s( _pEnv, " ( self.moduleCtrl.getCallMethodCName( getterType ) ) );
            filter( prefixNode, self, node );
            self.write( accessAny );
            self.write( ")" );
         } );
   }

   
   // let mut fieldTxt = node.get_field().txt;
   // if fieldTxt == "_txt" and
   //     ( prefixType.$kind == .Enum or prefixType.$kind == .Alge )
   // {
   //    self.write( "%s:_getTxt( " (self.getFullName( prefixType ) ) );
   //    filter( prefixNode, self, node );
   //    self.writeln( ")" );
   // }
   // else {
   //    filter( prefixNode,  self, node );
   //    let mut delimit = ".";
   //    if node.get_getterTypeInfo().get_kind() == Ast.TypeInfoKind.Method {
   //       delimit = ":";
   //    }
   //    else {
   //       delimit = ".";
   //    }

   //    fieldTxt = "get_%s()" ( fieldTxt );
   //    self.write( delimit .. fieldTxt );
   // }
};


pub override fn convFilter.processReturn(
   node: Nodes.ReturnNode, opt: Opt ) mut
{
   let retTypeInfoList = self.currentRoutineInfo.$funcInfo.$retTypeInfoList;

   let blockStart;
   if! let expListNode = node.$expList {
      let expList = expListNode.$expList;
      let isStem = isStemRet( retTypeInfoList );
      let mut needSetRet = true;
      self.writeln( "{" );
      blockStart = true;
      self.pushIndent( ## );
      self.write( "%s _ret = " (getCRetType(retTypeInfoList)) );
      if #retTypeInfoList >= 2 {
         self.processCreateMRet( retTypeInfoList, expList, node );
      }
      elseif #retTypeInfoList == 1 {
         if isStem {
            self.processVal2stem( expList[ 1 ], node );
            if Ast.builtinTypeBool.equals( retTypeInfoList[ 1 ] ## ) {
               // bool は、同じ stem を使い廻すので SetRet しない
               needSetRet = false;
            }
         }
         else {
            filter( expList[ 1 ], self, node );
         }
      }
      else {
         //self.write( "_pEnv->pNilStem" );
      }
      self.writeln( ";" );
      if isStem and needSetRet {
         self.writeln( "lune_setRet( _pEnv, _ret );" );
      }
   }
   else {
      blockStart = false;
   }

   if self.currentRoutineInfo.$blockDepth == 1 {
      self.writeln( "lune_leave_block( _pEnv );" );
   }
   else {
      self.writeln( "lune_leave_blockMulti( _pEnv, %d );"
                    ( self.currentRoutineInfo.$blockDepth ) );
   }


   if #retTypeInfoList ~= 0 {
      self.writeln( "return _ret;" );
   }
   else {
      self.writeln( "return;" );
   }

   if blockStart {
      self.popIndent();
      self.writeln( "}" );
   }
};

pub override fn convFilter.processProvide(
   node: Nodes.ProvideNode, opt: Opt ) mut
{
}

pub override fn convFilter.processAlias(
   node: &Nodes.AliasNode, opt: Opt ) mut
{
   // self.write( "local %s = " (node.$newName) );
   // filter( node.$srcNode, self, node );
   // if Ast.isPubToExternal( node.$expType.$accessMode ) {
   //    self.write( "\n_moduleObj.%s = %s" (node.$newName, node.$newName) );
   // }
}

pub override fn convFilter.processBoxing(
   node: Nodes.BoxingNode, opt: Opt ) mut
{
   // self.write( "{" );

   // filter( node.$src, self, node );

   // self.write( "}" );
}

pub override fn convFilter.processUnboxing(
   node: Nodes.UnboxingNode, opt: Opt ) mut
{
   // filter( node.$src, self, node );
   // self.write( "[1]" );
}


fn convFilter.processLiteralVal( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   if self.processMode ~= .Immediate {
      let symbolList = exp.getSymbolInfo();
      if #symbolList > 0 {
         let work, valKind = self.scopeMgr.getCTypeForSym( symbolList[ 1 ] );
         if valKind ~= .Prim {
            // filter( exp, self, parent );
            self.processVal2stem( exp, parent );
            return;
         }
      }
   }
   let mut valType = exp.$expType.$srcTypeInfo;
   if! let enumType = valType@@@Ast.EnumTypeInfo {
      valType = enumType.$valTypeInfo;
   }
   
   switch valType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         self.write( "lune_imdInt( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeReal {
         self.write( "lune_imdReal( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeBool {
         self.write( "lune_imdBool( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeString {
         if! let strNode = exp@@@Nodes.LiteralStringNode { 
            if #strNode.$argList == 0 {
               self.write( "lune_imdStr( %s )" (strNode.$token.txt ) );
               return;
            }
         }
         self.write( "lune_imdAny( " );
         filter( exp, self, parent );
         self.write( accessAny );
         self.write( ")" );
      }
      default {
         switch valType.$kind {
            case .List, .Set, .Map, .Array, .Class {
               self.write( "lune_imdAny( " );
               filter( exp, self, parent );
               self.write( accessAny );
               self.write( ")" );
            }
            default {
               Util.err( "illegal type -- %s" (valType.getTxt(##)) );
            }
         }
      }
   }
}

fn getLiteralListFuncName( node: &Nodes.LiteralListNode ): str {
   return "lune_list_%X" (node.$id);
}

fn convFilter.processLiteralNode( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   switch exp.$kind {
      case Nodes.NodeKind.$LiteralList,
           Nodes.NodeKind.$LiteralMap,
           Nodes.NodeKind.$LiteralArray,
           Nodes.NodeKind.$LiteralSet
      {
         self.processingNode = exp;
         filter( exp, self, parent );
      }
      default {
         self.pushStream();
         filter( exp, self, parent );
         self.popStream();
      }
   }
}

fn convFilter.processLiteralListSub(
   collectionType:str, node:&Nodes.Node,
   expListNodeOrg:&Nodes.ExpListNode!, literalFuncName:str ) mut
{
   if self.processedNodeSet.has( node ) {
      if! let set = self.literalNode2AccessSymbolSet[ node ] { 
         foreach symbol in set.$list {
            self.accessSymbolSet.add( symbol );
         }
      }
      return;
   }
   self.processedNodeSet.add( node );
   let! expListNode = expListNodeOrg {
      return;
   };
   if #expListNode.$expList == 0 {
      return;
   }

   foreach exp in expListNode.$expList {
      self.processLiteralNode( exp, node );
   }
   self.processingNode = node;
   
   self.write(
      "static %s %s( %s _pEnv" (cTypeStem, literalFuncName, cTypeEnvP ) );
   foreach symbol in self.accessSymbolSet.$list {
      self.write( ", %s %s" (self.scopeMgr.getCTypeForSym( symbol ),
                              getSymbolName( symbol ) ) );             
   }
   self.writeln( ")" );
   self.writeln( "{" );
   
   self.pushIndent(##);
   self.write( "lune_imd%s( list" ( collectionType ) );
   self.pushIndent( ## );
   foreach exp in expListNode.$expList {
      self.write( ", " );
      self.processLiteralVal( exp, node );
   }
   self.popIndent();
   self.writeln( ");" );
   self.writeln( "return lune_create%s( _pEnv, list );" ( collectionType ) );
   self.popIndent();
   self.writeln( "}" );

   self.literalNode2AccessSymbolSet[ node ] = self.accessSymbolSet.clone();
}

pub override fn convFilter.processLiteralList(
   node: Nodes.LiteralListNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralListSub(
         "List", node, node.$expList, getLiteralListFuncName( node ) );
   }
   else {
      if node.$expList {
         self.write( "%s( _pEnv" ( getLiteralListFuncName( node ) ) );
         let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
            return;
         };
         foreach symbol in symbolSet.$list {
            self.write( ", %s" ( getSymbolName( symbol ) ) );
         }
         self.write( ")" );
      }
      else {
         self.write( "lune_class_List_new( _pEnv )" );
      }
   }
};


fn getLiteralSetFuncName( node: &Nodes.LiteralSetNode ): str {
   return "lune_set_%X" (node.$id);
}

pub override fn convFilter.processLiteralSet(
   node: Nodes.LiteralSetNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralListSub(
         "Set", node, node.$expList, getLiteralSetFuncName( node ) );
   }
   else {
      if node.$expList {
         self.write( "%s( _pEnv" ( getLiteralSetFuncName( node ) ) );
         let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
            return;
         };
         foreach symbol in symbolSet.$list {
            self.write( ", %s" ( getSymbolName( symbol ) ) );
         }
         self.write( ")" );
      }
      else {
         self.write( "lune_class_Set_new( _pEnv )" );
      }
   }
};


fn getLiteralMapFuncName( node: &Nodes.LiteralMapNode ): str {
   return "lune_map_%X" (node.$id);
}

fn convFilter.processLiteralMapSub( node:&Nodes.LiteralMapNode ) mut
{
   if self.processedNodeSet.has( node ) {
      if! let set = self.literalNode2AccessSymbolSet[ node ] { 
         foreach symbol in set.$list {
            self.accessSymbolSet.add( symbol );
         }
      }
      return;
   }
   self.processedNodeSet.add( node );
   let pairList = node.$pairList;
   if #pairList == 0 {
      return;
   }

   foreach pair in pairList {
      self.processLiteralNode( pair.$key, node );
      self.processLiteralNode( pair.$val, node );
   }
   self.processingNode = node;
   
   self.write(
      "static %s %s( %s _pEnv" (cTypeStem, getLiteralMapFuncName( node ), cTypeEnvP ) );
   foreach symbol in self.accessSymbolSet.$list {
      self.write( ", %s %s" (self.scopeMgr.getCTypeForSym( symbol ),
                              getSymbolName( symbol ) ) );             
   }
   self.writeln( ")" );
   self.writeln( "{" );
   
   self.pushIndent(##);
   self.write( "lune_imdMap( list" );
   self.pushIndent( ## );
   foreach pair in pairList {
      self.writeln( ", " );
      self.write( "{ " );
      self.processLiteralVal( pair.$key, node );
      self.write( ", " );
      self.processLiteralVal( pair.$val, node );
      self.write( "} " );
   }
   self.popIndent();
   self.writeln( ");" );
   self.writeln( "return lune_createMap( _pEnv, list );" );
   self.popIndent();
   self.writeln( "}" );

   self.literalNode2AccessSymbolSet[ node ] = self.accessSymbolSet.clone();
}


pub override fn convFilter.processLiteralMap(
   node: Nodes.LiteralMapNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralMapSub( node );
   }
   else {
      if #node.$pairList > 0 {
         self.write( "%s( _pEnv" ( getLiteralMapFuncName( node ) ) );
         let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
            return;
         };
         foreach symbol in symbolSet.$list {
            self.write( ", %s" ( getSymbolName( symbol ) ) );
         }
         self.write( ")" );
      }
      else {
         self.write( "lune_class_Map_new( _pEnv )" );
      }
   }
};

pub override fn convFilter.processLiteralArray(
   node: Nodes.LiteralArrayNode, opt: Opt ) mut
{
   // self.write( "{" );

   // if! node.$expList {
   //    filter( _exp, self, node );
   // }

   // self.write( "}" );
};


pub override fn convFilter.processLiteralChar(
   node: Nodes.LiteralCharNode, opt: Opt ) mut
{
   self.write( string.format( "%d", node.$num ) );
};

pub override fn convFilter.processLiteralInt(
   node: Nodes.LiteralIntNode, opt: Opt ) mut
{
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralReal(
   node: Nodes.LiteralRealNode, opt: Opt ) mut
{
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralString(
   node: Nodes.LiteralStringNode, opt: Opt ) mut
{
   
   let mut txt = node.get_token().txt;
   if string.find( txt, '^```' ## ) {
      txt = '[==[' .. txt.sub( 4, -4 ) .. ']==]';
   }
   let opList = TransUnit.findForm( txt );

   self.write( "lune_litStr2stem( _pEnv, " );
   
   let argList = node.get_argList();
   if #argList > 0 {
      self.write( string.format( 'string.format( %s, ', txt ) );
      foreach val, index in argList {
         if index > 1 {
            self.write( ", " );
         }

         filter( val, self, node );
      }
      self.write( ")" );
   }
   else {
      self.write( txt );
   }

   self.write( ")" );
};

pub override fn convFilter.processLiteralBool(
   node: Nodes.LiteralBoolNode, opt: Opt ) mut
{
   if node.$token.txt == "true" {
      self.write( "lune_global.trueStem" );
   }
   else {
      self.write( "lune_global.falseStem" );
   }
};

pub override fn convFilter.processLiteralNil(
   node: Nodes.LiteralNilNode, opt: Opt ) mut
{
   self.write( cValNil );
};

pub override fn convFilter.processBreak(
   node: Nodes.BreakNode, opt: Opt ) mut
{
   self.write( "break" );
};

pub override fn convFilter.processLiteralSymbol(
   node: Nodes.LiteralSymbolNode, opt: Opt ) mut
{
   // self.write( '%s' ( node.$token.txt ) );
};

pub override fn convFilter.processAbbr(
   node: Nodes.AbbrNode, opt: Opt ) mut
{
   self.write( cValNil );
};


pub fn createFilter(
   streamName: str, stream: oStream,
   headerStream: oStream, ast:&TransUnit.ASTInfo ) : Nodes.Filter<Opt>
{
   return new convFilter( streamName, stream, headerStream, ast );
}

