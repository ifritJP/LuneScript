/*
MIT License

Copyright (c) 2018, 2019 ifritJP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import lune.base.Ver;
import lune.base.Ast;
import lune.base.Nodes;
import lune.base.Util;
import lune.base.TransUnit;
import lune.base.frontInterface;
import lune.base.LuaMod;
import lune.base.LuaVer;
import lune.base.Parser;
import lune.base.LuneControl;

let cTypeInt = "lns_int_t";
let cTypeReal = "lns_real_t";
let cTypeBool = "lns_bool_t";
let cTypeStem = "lns_stem_t";
let cTypeAny = "lns_any_t";
let cTypeAnyP = "lns_any_t *";
let cTypeAnyPP = "lns_any_t **";
let cTypeEnvP = "lns_env_t *";
let cTypeVarP = "lns_var_t *";
let cTypeBlockP = "lns_block_t *";
let cValNil = "lns_global.nilStem";
let cValNone = "lns_global.noneStem";

let accessAny = ".val.pAny";

let stepIndent = 3;

/**
構文解析済みで、全シンボルにアクセスしても問題ないので、
ここでは scopeAccess をフルとする。 
*/
let scopeAccess = Ast.ScopeAccess.Full;

let invalidSymbolId = -1;

/**
node の属するクラスの TypeInfo を返す。

@return node の属するクラスの TypeInfo。 クラスに属さない場合は nil。
*/
fn getBelongClassType( node:&Nodes.Node ) : &Ast.TypeInfo! {
   if node.$expType.$kind ~= .Method {
      return nil;
   }
   let! fieldNode = node@@@Nodes.RefFieldNode {
      return nil;
   };
   return fieldNode.$prefix.$expType;
}

/**
funcType で示す関数がクロージャかどうかを返す。
*/
fn isClosure( funcType:&Ast.TypeInfo ): bool {
   if! let scope = funcType.$scope {
      return #scope.$closureSymList > 0;
   }
   return false;
}

/** 公開変数情報 */
class PubVarInfo {
   pub let staticFlag: bool;
   pub let accessMode: Ast.AccessMode;
   pub let mutable:bool;
   pub let typeInfo: &Ast.TypeInfo;
};

/** 公開関数情報 */
class PubFuncInfo {
   pub let accessMode: Ast.AccessMode;
   pub let typeInfo: &Ast.TypeInfo;
}

pub enum ConvMode {
   /** lns ソースを実行する */
   Exec,
   /** lua への変換を行なう */
   Convert,
   /** lua への変換と、 Meta 情報生成を行なう */
   ConvMeta,
}

/** インポートしているモジュールの情報 */
class ModuleInfo extend (Ast.ModuleInfoIF){
   /** import したモジュールに割り当てている名前 */
   let assignName:str {pub};
   /** モジュールのパス */
   let modulePath:str {pub};
}

/** 出力に使用するパラメータ */
pub class Opt {
   pub let node:&Nodes.Node;
}

/** 解析中の関数情報 */
class RoutineInfo {
   /** 解析中の関数の型 */
   let funcInfo:&Ast.TypeInfo {pub};
   /** 解析中の関数内のブロックの深さ */
   let mut blockDepth:int {pub};

   pub fn __init( funcInfo:&Ast.TypeInfo ) {
      self.funcInfo = funcInfo;
      self.blockDepth = 1;
   }
   pub fn pushDepth() mut {
      self.blockDepth = self.blockDepth + 1;
   }
   pub fn popDepth() mut {
      self.blockDepth = self.blockDepth - 1;
   }
}


enum ValKind {
   /** プリミティブ型として扱う */
   Prim,
   // /** any 型として扱う */
   Any,
   /** 作業用に作成した any 型として扱う */
   StemWork,
   /**stem 型として扱う */
   Stem,
   /** var 型として扱う */
   Var,
   /** */
   Other,
}


/**
指定の型を扱う時の ValKind が Stem かどうか。 

変数を扱う場合は ScopeMgr.getSymbolValKind() を使用する必要がある。
*/
fn getValKind( valType:&Ast.TypeInfo ) : ValKind {
   let expType = valType.$srcTypeInfo;
   if expType.$nilable {
      return .Stem;
   }
   switch expType.$kind {
      case .Alternate, .Stem, .DDD, .Alge {
         return .Stem;
      }
   }
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return .Prim;
      }
      case Ast.builtinTypeReal {
         return .Prim;
      }
      case Ast.builtinTypeBool {
         return .Prim;
      }
      default {
         // if expType.$kind == .DDD {
         //    return .Any;
         // }
         if! let enumType = expType@@@Ast.EnumTypeInfo {
            return getValKind( enumType.$valTypeInfo );
         }
         return .Any;
      }
   }
}

/**
指定の型を扱う時の ValKind が Stem かどうか。 

変数を扱う場合は ScopeMgr.getSymbolValKind() を使用する必要がある。
*/
fn isStemType( valType:&Ast.TypeInfo ) : bool {
   return getValKind( valType ) == .Stem;
}


fn getRetKind( retTypeList:&List<&Ast.TypeInfo> ) : ValKind {
   switch #retTypeList {
      case 0 {
         return .Other;
      }
      case 1 {
         return getValKind( retTypeList[ 1 ] );
      }
   }
   return .Stem;
}


/**
戻り値の ValKind が Stem かどうか。
*/
fn isStemRet( retTypeList:&List<&Ast.TypeInfo> ) : bool {
   return getRetKind( retTypeList ) == .Stem;
}

/**
指定の型を C で扱う時の型名を返す。
*/
fn getCType( valType:&Ast.TypeInfo ) : str {
   let expType = valType.$srcTypeInfo;
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return cTypeInt;
      }
      case Ast.builtinTypeReal {
         return cTypeReal;
      }
      case Ast.builtinTypeBool {
         return cTypeBool;
      }
      default {
         if! let enumType = expType@@@Ast.EnumTypeInfo {
            return getCType( enumType.$valTypeInfo );
         }

         if getValKind( valType ) == .Any {
            return cTypeAnyP;
         }
         
         return cTypeStem;
      }
   }
}

/**
指定の戻り値型を C で扱う時の型名を返す。
*/
fn getCRetType( retTypeList:&List<&Ast.TypeInfo> ) : str {
   switch #retTypeList {
      case 0 {
         return "void";
      }
      case 1 {
         return getCType( retTypeList[ 1 ] );
      }
   }
   return cTypeStem;
}

fn getBlockName( scope:&Ast.Scope ): str {
   return "pBlock_%X" ( scope.$scopeId );
}

/** 変換プロセス */
enum ProcessMode {
   /** include */
   Include,
   /** プロトタイプ宣言 */
   Prototype,
   /** 大域変数 */
   WideScopeVer,
   /** モジュール初期化 */
   InitModule,
   /** 中間処理 */
   Intermediate,
   /** string format */
   StringFormat,
   /** クラス定義 */
   DefClass,
   /** 内部関数 */
   Form,
   /** 即値 */
   Immediate,
   /** __func__ の初期化 */
   InitFuncSym,
}

class ModuleCtrl {
   pri let moduleInfoManager: &Ast.ModuleInfoManager;
   pri let typeNameCtrl: &Ast.TypeNameCtrl;
   

   /**
ビルトイン関数のシンボル → Cの関数名のマップ
*/
   let builtinSym2CFuncMap:&Map<&Ast.SymbolInfo,str>;
   let builtinType2CFuncMap:&Map<&Ast.TypeInfo,str>;

   static fn setupBuiltinSym():&Map<&Ast.SymbolInfo,str>, &Map<&Ast.TypeInfo,str> {
      let builtinFunc = TransUnit.getBuiltinFunc();

      let mut symMap:Map<&Ast.SymbolInfo,str> = {};
      let mut typeMap:Map<&Ast.TypeInfo,str> = {};
      macro _setBuiltinFnc(func:sym) {
         {
            let symbol = "lns_%s" (,,,,func);
         }
         typeMap[ builtinFunc.,,,symbol ] = "lns_f_" .. ,,,,func;
      }
      macro _setBuiltinMtd(func:sym) {
         {
            let symbol = "%s_sym" (,,,,func);
         }
         symMap[ builtinFunc.,,,symbol ] = "mtd_lns_" .. ,,,,func;
      }

      _setBuiltinFnc( type );
      _setBuiltinFnc( error );
      _setBuiltinFnc( print );
      _setBuiltinFnc( tonumber );
      _setBuiltinFnc( tostring );
      _setBuiltinFnc( load );
      _setBuiltinFnc( loadfile );
      _setBuiltinFnc( require );
      _setBuiltinFnc( collectgarbage );
      _setBuiltinFnc( _fcall );
      _setBuiltinFnc( _load );
      _setBuiltinFnc( _kind );
      _setBuiltinMtd( io_open );
      _setBuiltinMtd( io_popen );
      _setBuiltinMtd( package_searchpath );
      _setBuiltinMtd( os_clock );
      _setBuiltinMtd( os_date );
      _setBuiltinMtd( os_difftime );
      _setBuiltinMtd( os_exit );
      _setBuiltinMtd( os_remove );
      _setBuiltinMtd( os_rename );
      _setBuiltinMtd( os_time );
      _setBuiltinMtd( string_byte );
      _setBuiltinMtd( string_dump );
      _setBuiltinMtd( string_find );
      _setBuiltinMtd( string_format );
      _setBuiltinMtd( string_gmatch );
      _setBuiltinMtd( string_gsub );
      _setBuiltinMtd( string_lower );
      _setBuiltinMtd( string_rep );
      _setBuiltinMtd( string_reverse );
      _setBuiltinMtd( string_sub );
      _setBuiltinMtd( string_upper );
      _setBuiltinMtd( math_random );
      _setBuiltinMtd( math_randomseed );
      _setBuiltinMtd( debug_getinfo );
      _setBuiltinMtd( debug_getlocal );
      return symMap, typeMap;
   }
   
   pub fn __init( typeNameCtrl:&Ast.TypeNameCtrl,
                  moduleInfoManager: &Ast.ModuleInfoManager)
   {
      self.builtinSym2CFuncMap, self.builtinType2CFuncMap = ModuleCtrl.setupBuiltinSym();
      self.typeNameCtrl = typeNameCtrl;
      self.moduleInfoManager = moduleInfoManager;
   }

   pub fn getBuiltinFuncName( symbol:&Ast.SymbolInfo): str! {
      return self.builtinSym2CFuncMap[ symbol ];
   }

   pub fn getBuiltinFuncNameFromType( typeInfo:&Ast.TypeInfo): str! {
      return self.builtinType2CFuncMap[ typeInfo ];
   }

   /**
   指定のモジュールを定義するファイルパスを取得する。

.c, .h 等の拡張子は付かない。
   */
   pub fn getFilePath( mut moduleTypeInfo:&Ast.TypeInfo ): str {
      let workName = moduleTypeInfo.getFullName(
         self.$typeNameCtrl, self.moduleInfoManager, false );
      let fullName = "%s" ( (workName.gsub( "[&@]", "" ).gsub( "%.", "/" ) ) );
      return fullName;
   }



/**
指定の型の関数名を取得する。
*/
   pub fn getFullName( mut typeInfo:&Ast.TypeInfo ): str {
      typeInfo = typeInfo.$srcTypeInfo;
      let workName = typeInfo.getFullName(
         self.$typeNameCtrl, self.moduleInfoManager, false );

      let fullName = "%s" ( (workName.gsub( "[&@]", "" ).gsub( "%.", "_" ) ) );
      if Ast.isPubToExternal( typeInfo.$accessMode ) {
         return fullName;
      }
      return "_%d_%s" (typeInfo.$typeId,fullName);
   }

   /**
シンボルの C 出力名を取得する。
*/
   pub fn getSymbolName( symbolInfo:&Ast.LowSymbol ): str {
      if symbolInfo.$kind == .Mbr {
         return symbolInfo.$name;
      }
      if Ast.isPubToExternal( symbolInfo.$accessMode ) {
         if symbolInfo.$accessMode == .Global {
            return "lns_" .. symbolInfo.$name;
         }
         let moduleType = symbolInfo.$scope.getNamespaceTypeInfo().getModule();
         return "lns_%s_%s" ( self.getFullName( moduleType ), symbolInfo.$name );
      }
      switch symbolInfo.$kind {
         case .Var {
            if symbolInfo.$symbolId == invalidSymbolId {
               return symbolInfo.$name;
            }
            return "lns_%s_%d" (symbolInfo.$name, symbolInfo.$symbolId );
         }
      }
      return symbolInfo.$name;
   }

   pub fn getAlgeCName( algeType:&Ast.TypeInfo ): str {
      return self.getFullName( algeType );
   }
   pub fn getAlgeEnumCName( algeType:&Ast.TypeInfo): str {
      return "lns_algeType_%s" (self.getAlgeCName( algeType ) );
   }
   pub fn getAlgeValCName( algeType:&Ast.TypeInfo, valName:str ): str {
      return "lns__alge_%s_%s" (self.getFullName( algeType ), valName);
   }
   pub fn getAlgeValStrCName( algeType:&Ast.TypeInfo, valName:str ): str {
      return "lns__alge_%s_%s_t" (self.getFullName( algeType ), valName );
   }
   pub fn getNewAlgeCName( algeType:&Ast.TypeInfo, valName:str ): str {
      return "lns__new_alge_%s_%s" (self.getFullName( algeType ), valName);
   }
  
   pub fn getAlgeInitCName( algeType:&Ast.TypeInfo ): str {
      return "lns__init_alge_%s" ( self.getAlgeCName( algeType ) );
   }


   pub fn getEnumTypeName( typeInfo: &Ast.TypeInfo ): str {
      let srcType = typeInfo.$srcTypeInfo;
      let fullName = self.getFullName( srcType );

      if Ast.isPubToExternal( typeInfo.$accessMode ) {
         return fullName;
      }
      return "%s_%d" (fullName, srcType.$typeId );
   }

   pub fn getEnumValCName( typeInfo:&Ast.TypeInfo, valName:str ): str {
      return "%s__%s" (self.getEnumTypeName( typeInfo ), valName);
   }

   pub fn getEnumVal2NameMapName( enumType:&Ast.TypeInfo ): str {
      return "%s_val2NameMap" (self.getEnumTypeName( enumType ));
   }
   
   pub fn getClassCName( classType:&Ast.TypeInfo ) : str
   {
      return "lns_" .. self.getFullName( classType );
   }

   pub fn getMethodCName( methodTypeInfo:&Ast.TypeInfo ) : str
   {
      return "mtd_%s_%s" ( self.getClassCName( methodTypeInfo.$parentInfo ),
                                 methodTypeInfo.$rawTxt );
   }

   pub fn getFuncName( typeInfo:&Ast.TypeInfo ): str {
      if typeInfo.$rawTxt == "" {
         return "lns_anonymous_%d" (typeInfo.$typeId);
      }
      if typeInfo.$parentInfo.$kind == .Class {
         return self.getMethodCName( typeInfo );
      }
      
      switch typeInfo.$accessMode {
         case .Pub, .Global {
            if! let cFuncName = self.getBuiltinFuncNameFromType( typeInfo ) {
               return cFuncName;
            }
            return self.getFullName( typeInfo );
         }
      }
      return "lns_f_%d_%s" (typeInfo.$typeId, typeInfo.$rawTxt);
   }

   pub fn getCallMethodCName( methodTypeInfo:&Ast.TypeInfo ) : str
   {
      switch methodTypeInfo.$parentInfo.$kind {
         case .List {
            return "lns_mtd_List_%s" (methodTypeInfo.$rawTxt);
         }
         case .Array {
            return "lns_mtd_Array_%s" (methodTypeInfo.$rawTxt);
         }
         case .Set {
            return "lns_mtd_Set_%s" (methodTypeInfo.$rawTxt);
         }
         case .Map {
            return "lns_mtd_Map_%s" (methodTypeInfo.$rawTxt);
         }
      }
      return "l_call_mtd_%s_%s" ( self.getClassCName( methodTypeInfo.$parentInfo ),
                                  methodTypeInfo.$rawTxt );
   }

   pub fn getClassMemberName( symbolInfo:&Ast.SymbolInfo ):str {
      let classTypeInfo = symbolInfo.$scope.getClassTypeInfo();
      return "l_var_%s_%s" ( self.getClassCName( classTypeInfo ),
                                symbolInfo.$name );
   }

   pub fn getFormName( typeInfo:&Ast.TypeInfo ):str {
      return "l_form_%s" ( self.getFullName( typeInfo ) );
   }
   pub fn getCallFormName( typeInfo:&Ast.TypeInfo ):str {
      return "lns_call_formFunc_%s" ( self.getFullName( typeInfo ) );
   }
}

/**
シンボルに紐付けて管理する情報。
*/
class SymbolParam {
   pub let kind:ValKind;
   /** スコープ内の何番目の変数として扱うか */
   pub let index:int;
   /** C で扱う時の変数の型名 */
   pub let typeTxt:str;
}

/**
C へのトランスコンパイル処理で新しく宣言する変数を管理する。

元の変数は Node 内の SymbolInfo を使用できるが、
トランスコンパイル処理で新しく宣言した変数は SymbolInfo が存在しないので、
それの代わり。
*/
class WorkSymbol extend (Ast.LowSymbol) {
   let mut scope:&Ast.Scope {pub};
   let mut accessMode:Ast.AccessMode {pub};
   let mut name:str {pub};
   let mut typeInfo:&Ast.TypeInfo {pub};
   let mut kind:Ast.SymbolKind {pub};
   let mut convModuleParam:SymbolParam {pub:stem!};

   pub fn get_symbolId() : int {
      return invalidSymbolId;
   }
   pub fn get_hasAccessFromClosure(): bool {
      return false;
   }
}


class ScopeInfo {
   /** スコープ内で宣言されている stem 型変数の数 */
   pub let mut anyNum:int;
   /** スコープ内で宣言されている stem 型変数の数 */
   pub let mut stemNum:int;
   /** スコープ内で宣言されている var 型変数の数 */
   pub let mut varNum:int;
}

fn getOrgTypeInfo( typeInfo:&Ast.TypeInfo ) : &Ast.TypeInfo {
   if! let enumType = typeInfo.$srcTypeInfo.$nonnilableType@@@Ast.EnumTypeInfo {
      return enumType.$valTypeInfo;
   }
   return typeInfo.$srcTypeInfo.$nonnilableType;
}

fn getAccessPrimValFromSymbolDirect(
   symName:str, valKind:ValKind, symType:&Ast.TypeInfo ) mut :str
{
   let mut txt = symName;
   switch valKind {
      case .Var {
         txt = txt .. "->stem";
      }
      case .Stem {
      }
      case .Prim {
         return txt;
      }
   }

   switch getOrgTypeInfo( symType ) {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         txt = txt .. ".val.intVal";
      }
      case Ast.builtinTypeReal {
         txt = txt .. ".val.realVal";
      }
      case Ast.builtinTypeBool {
         txt = txt .. ".val.boolVal";
      }
   }
   return txt;
}


fn createSymbolParam( name:str, valKind:ValKind, cTypeTxt:str ) : SymbolParam
{
   switch valKind {
      case .Stem {
         return new SymbolParam( .Stem, 0, cTypeStem );
      }
      case .Any {
         return new SymbolParam( .Any, 0, cTypeAnyP );
      }
      case .Prim {
         return new SymbolParam( .Prim, 0, cTypeTxt );
      }
      case .Other {
         return new SymbolParam( .Other, 0, "void" );
      }
      default {
         Util.err( "not support %s:%s" ( name, valKind.$_txt ) );
      }
   }
}

/**
スコープとシンボルを管理する。
*/
class ScopeMgr {
   pri let mut scope2InfoMap:Map<&Ast.Scope,ScopeInfo>;
   pri let mut moduleCtrl:ModuleCtrl;
   pri let mut numOf__func__:int {pub};
   pri let mut moduleBlockAnyNum:int;

   pri fn __init( moduleCtrl:ModuleCtrl ) {
      self.scope2InfoMap = {};
      self.moduleCtrl = moduleCtrl;
      self.numOf__func__ = 0;
      self.moduleBlockAnyNum = 0;
   }

   fn setupScopeParamSub( scope:&Ast.Scope ) mut : ScopeInfo
   {
      if! let mut scopeInfo = self.scope2InfoMap[ scope ] {
         return scopeInfo;
      }

      let mut scopeInfo;
      if not scope.$ownerTypeInfo$.$externalFlag {
         // ローカル変数のうち、stem, var として扱う変数を決定し、インデックスを紐付ける。
         let mut varNum = 0;
         let mut stemNum = 0;
         let mut anyNum = 0;

         if scope.$ownerTypeInfo$.isModule$() {
            // モジュールの場合、
            // lns_module_globalStemList, lns_module_path の分 + 2 する
            anyNum = 2;
         }

         forsort symbol in scope.$symbol2SymbolInfoMap {
            let param;
            if symbol.$name ~= "__func__" {
               switch symbol.$kind {
                  case .Var, .Arg {
                     if symbol.$hasAccessFromClosure {
                        // クロージャアクセスされるシンボルは、 Var 型で管理する
                        param = new SymbolParam( .Var, varNum, cTypeVarP );
                        varNum = varNum + 1;
                     }
                     else {
                        switch getValKind(symbol.$typeInfo) {
                           case .Stem {
                              param = new SymbolParam( .Stem, stemNum, cTypeStem );
                              stemNum = stemNum + 1;
                           }
                           case .Any {
                              if symbol.$name == "self" {
                                 param = new SymbolParam( .Any, 0, cTypeAnyP );
                              }
                              else {
                                 if symbol.$kind == .Var {
                                    param = new SymbolParam( .Any, anyNum, cTypeAnyPP );
                                 }
                                 else {
                                    param = new SymbolParam( .Any, anyNum, cTypeAnyP );
                                 }
                                 anyNum = anyNum + 1;
                              }
                           }
                           case .Prim {
                              param = new SymbolParam(
                                 .Prim, 0, getCType( symbol.$typeInfo ) );
                           }
                           default {
                              Util.err( "not support %s" (symbol.$typeInfo.getTxt(##)));
                           }
                        }
                     }
                  }
                  case .Mtd {
                     let retTypeList = symbol.$typeInfo.$retTypeInfoList;
                     param = createSymbolParam( symbol.$name, getRetKind( retTypeList ),
                                                getCRetType( retTypeList ) );
                  }
                  case .Mbr, .Fun {
                     param = createSymbolParam(
                        symbol.$name, getValKind( symbol.$typeInfo ),
                        getCType( symbol.$typeInfo ) );
                  }
                  default {
                     param = new SymbolParam( .Other, 0, cTypeStem );
                  }
               }
            }
            else {
               param = new SymbolParam(
                  .Any, self.numOf__func__ + self.moduleBlockAnyNum, cTypeAnyP );
               self.numOf__func__ = self.numOf__func__ + 1;
            }
            symbol.set_convModuleParam( param );
         }
         
         scopeInfo = new ScopeInfo( anyNum, stemNum, varNum );
      }
      else {
         scopeInfo = new ScopeInfo( 0, 0, 0 );
      }
      self.scope2InfoMap[ scope ] = scopeInfo;
      
      return scopeInfo;
   }

   pub static fn create( moduleCtrl:ModuleCtrl, initBlockScope:&Ast.Scope ):ScopeMgr
   {
      let mut scopeMgr = new ScopeMgr( moduleCtrl );
      let param = scopeMgr.setupScopeParamSub( initBlockScope );
      scopeMgr.moduleBlockAnyNum = param.anyNum;
      return scopeMgr;
   }

   pub fn setupScopeParam( scope:&Ast.Scope ) mut : int, int, int
   {
      let scopeInfo = self.setupScopeParamSub( scope );
      return scopeInfo.anyNum, scopeInfo.stemNum, scopeInfo.varNum;
   }

   pub fn getSymbolParam( symbol:&Ast.LowSymbol ) mut : &SymbolParam
   {
      if! let param = symbol.$convModuleParam {
         return param@@=SymbolParam;
      };
      let scope = symbol.$scope;

      if not self.scope2InfoMap[ scope ] {
         self.setupScopeParam( scope );
         if! let param = symbol.$convModuleParam {
            return param@@=SymbolParam;
         };
      }
      Util.err( "illegal symbol -- %s %d" (symbol.$name, __line__ ) );
   }

   pub fn getSymbolValKind( symbol:&Ast.LowSymbol ) mut : ValKind
   {
      let symbolParam = self.getSymbolParam( symbol );
      return symbolParam.kind;
   }

   pub fn getCTypeForSym( symbol:&Ast.LowSymbol ) mut : str, ValKind
   {
      let param = self.getSymbolParam( symbol );
      return param.typeTxt, param.kind;

      
      // let typeTxt;
      // if symbol.$hasAccessFromClosuer {
      //    return cTypeVarP, .Var;
      // }
      // typeTxt = getCType( symbol.$typeInfo, false );
      // if typeTxt == cTypeStem {
      //    if symbol.$kind == .Mbr {
      //       return typeTxt, .StemMbr;
      //    }
      //    return typeTxt, .Stem;
      // }
      // return typeTxt, .Prim;
   }

   pub fn symbol2Any( symbol:&Ast.LowSymbol ) mut : str
   {
      let name = self.moduleCtrl.getSymbolName( symbol );
      // if symbol.$hasAccessFromClosuer {
      switch self.getSymbolValKind( symbol ) {
         case .Var {
            return name;
         }
         default {
            Util.err( "not support -- %s" (symbol.$typeInfo.getTxt( ## )) );
         }
      }
   }

   pub fn getAccessPrimValFromSymbol( symbolInfo:&Ast.LowSymbol ) mut :str
   {
      return getAccessPrimValFromSymbolDirect(
         self.moduleCtrl.getSymbolName( symbolInfo ),
         self.getSymbolValKind( symbolInfo ), symbolInfo.$typeInfo );
   }

   pub fn getAccessPrimValFromSymbolOnly( symbolInfo:&Ast.LowSymbol ) mut :str
   {
      return getAccessPrimValFromSymbolDirect(
         "", self.getSymbolValKind( symbolInfo ), symbolInfo.$typeInfo );
   }

}


fn getLiteralStrAny(txt:str):str {
   return 'lns_litStr2any( _pEnv, %s )' (txt);
}

fn getLiteralStrStem(txt:str):str {
   return 'LNS_STEM_ANY( %s )' (getLiteralStrAny(txt));
}


enum Out2HMode {
   HeaderPub,
   HeaderPri,
   SourcePub,
   SourcePri,
}

fn getOut2HeaderPrefix( mode:Out2HMode ) : str
{
   switch mode {
      case .HeaderPub {
         return "extern ";
      }
      case .SourcePri {
         return "static ";
      }
   }
   return "";
}

/**
ヘッダとソースにコードを出力する。

@param sourceStream 出力先
@param flag 公開する処理かどうか
@param code コードを出力する処理。
  この code 内では、 out2HMode を参照して処理を替える。

*/
macro _out2Header( sourceStream:sym, flag:__exp, code:stat )
{
   {}
   {
      fn processwork( out2HMode:Out2HMode ) {
         ,,code;
      }
      if ,,flag {
         ,,sourceStream.switchToHeader();
         processwork( .HeaderPub );
         ,,sourceStream.returnToSource();
         
         processwork( .SourcePub );
      }
      else {
         processwork( .SourcePri );
      }
   }
}

class convFilter extend Nodes.Filter<Opt> {
   pri let streamName: str;
   // pri let mut stream: oStream;
   pri let mut stream:Util.SimpleSourceOStream;

   pri let mut streamQueue: List<Util.SimpleSourceOStream>;

   pri let mut moduleCtrl:ModuleCtrl;
   
   // pri let mut indentQueue: List<int>;
   // pri let mut curLineNo: int;
   // pri let mut needIndent: bool;

   
   // // クラス TypeId → TypeInfo
   // pri let mut classId2TypeInfo: Map<int,&Ast.TypeInfo>;
   // // クラス TypeId → Member Node List
   // pri let mut classId2MemberList: Map<int,List<&Nodes.DeclMemberNode>>;
   // // enum TypeId -> EnumTypeInfo
   // pri let mut pubEnumId2EnumTypeInfo: Map<int,&Ast.EnumTypeInfo>;
   // // enum TypeId -> AlgeTypeInfo
   // pri let mut pubAlgeId2AlgeTypeInfo: Map<int,&Ast.AlgeTypeInfo>;
   // public 変数名 → 変数情報
   pri let mut pubVarName2InfoMap: Map<str,PubVarInfo>;
   // public 関数名 → 関数情報
   pri let mut pubFuncName2InfoMap: Map<str,PubFuncInfo>;
   // pri let mut macroDepth: int;
   pri let moduleTypeInfo: &Ast.TypeInfo;
   // pri let moduleSymbolKind: Ast.SymbolKind;
   pri let ast:Nodes.RootNode;
   pri let mut routineInfoQueue:List<RoutineInfo>;
   pri let mut currentRoutineInfo:RoutineInfo;
   pri let mut processMode:ProcessMode;
   pri let mut duringDeclFunc:bool;

   
   pri let mut processingNode: &Nodes.Node!;
   pri let mut processedNodeSet: Set<&Nodes.Node>;
   pri let mut accessSymbolSet: Util.OrderedSet<&Ast.SymbolInfo>;
   pri let mut literalNode2AccessSymbolSet:Map<&Nodes.Node,&Util.OrderedSet<&Ast.SymbolInfo>>;

   pri let mut scopeMgr:ScopeMgr;

   pri let mut outputBuiltinFlag:bool;
   pri let mut enableTest:bool;
   pri let mut canConv:bool;

   pri let mut dummyNodeManager:Nodes.NodeManager;

   fn createRefNodeFromSym( symbol:&Ast.SymbolInfo ) mut: &Nodes.ExpRefNode {
      return Nodes.ExpRefNode.create(
         self.dummyNodeManager, unwrap symbol.$pos, [ symbol.$typeInfo ], symbol );
   }

   pub fn __init( enableTest:bool, outputBuiltin:bool, streamName: str, stream: oStream,
                  headerStream: oStream, ast:&TransUnit.ASTInfo )
   {
      super(ast.$moduleTypeInfo, ast.$moduleTypeInfo.$scope);

      self.dummyNodeManager = new Nodes.NodeManager();
      self.canConv = true;
      self.enableTest = enableTest;
      self.outputBuiltinFlag = outputBuiltin;
      self.processingNode = nil;
      self.processedNodeSet = (@);
      self.accessSymbolSet = new Util.OrderedSet<&Ast.SymbolInfo>();
      self.literalNode2AccessSymbolSet = {};

      self.duringDeclFunc = false;

      self.processMode = .Prototype;

      self.routineInfoQueue = [];
      self.currentRoutineInfo = new RoutineInfo( Ast.builtinTypeNone );

      self.moduleTypeInfo = ast.$moduleTypeInfo;
      // self.moduleSymbolKind = ast.$moduleSymbolKind;
      
      //Util.errorLog( "__init: %s" (mode) );
      self.ast = unwrap ast.$node@@@Nodes.RootNode;
      //self.indentQueue = [ 0 ];
      // self.macroDepth = 0;
      self.streamName = streamName;
      //self.stream = stream;
      self.streamQueue = [];
      //self.curLineNo = 1;
      // self.classId2TypeInfo = {};
      // self.classId2MemberList = {};
      self.pubVarName2InfoMap = {};
      self.pubFuncName2InfoMap = {};
      // self.pubEnumId2EnumTypeInfo = {};
      // self.pubAlgeId2AlgeTypeInfo = {};
      //self.needIndent = false;

      self.moduleCtrl = new ModuleCtrl( self.$typeNameCtrl, self.$moduleInfoManager );
      self.scopeMgr = ScopeMgr.create(
         self.moduleCtrl, unwrap ast.$moduleTypeInfo.$scope );

      self.currentRoutineInfo = new RoutineInfo( ast.$moduleTypeInfo );
      self.routineInfoQueue.insert( self.currentRoutineInfo );

      self.stream = new Util.SimpleSourceOStream( stream, headerStream, stepIndent );
   }

   /**
ストリームを新しく生成し、
生成したストリームを出力先のストリームに切り替える。

@return - 生成したストリーム
   */
   fn pushStream() mut : Util.memStream {
      self.streamQueue.insert( self.stream );
      let mut stream = new Util.memStream();
      self.stream = new Util.SimpleSourceOStream( stream, nil, stepIndent );
      return stream;
   }

   /**
pushStream() で切り替えた出力ストリームを元に戻す。
   */
   fn popStream() mut {
      if #self.streamQueue == 0 {
         Util.err( "streamQueue is empty." );
      }
      self.stream = self.streamQueue[ #self.streamQueue ];
      self.streamQueue.remove(##);
   }


   

   fn getFullName( typeInfo:&Ast.TypeInfo ): str {
      return self.moduleCtrl.getFullName( typeInfo );
      // let mut enumName = typeInfo.getFullName( self.typeInfo2ModuleName, true );
      // return "%s" ( (enumName.gsub( "[&@]", "" ).gsub( "%.", "_" ) ) );
   }

   fn outputAlter2MapFunc( stream:Util.SourceStream, alt2Map:&Map<&Ast.TypeInfo,&Ast.TypeInfo>);


   fn processAddModuleGlobal( valName:str ) mut {
      self.stream.writeln(
         "lns_mtd_List_insert( _pEnv, *lns_module_globalStemList, %s );"
         (valName ) );
   }
   
   advertise stream;
}



fn filter( node: &Nodes.Node, filter: convFilter,
           parent: &Nodes.Node )
{
   node.processFilter( filter, new Opt( parent ) );
}

// let mut builtInModuleSet:Set<str> = (@);
// builtInModuleSet.add( "io" );
// builtInModuleSet.add( "string" );
// builtInModuleSet.add( "table" );
// builtInModuleSet.add( "math" );
// builtInModuleSet.add( "debug" );


// fn convFilter.pushIndent( newIndent:int! ) mut {
//    let indent = unwrap newIndent default self.$indent + stepIndent;
//    self.indentQueue.insert( indent );
// }

// fn convFilter.popIndent() mut {
//    if #self.indentQueue == 0 {
//       Util.err( "self.indentQueue == 0" );
//    }
//    self.indentQueue.remove(##);
// }


// fn convFilter.writeln( txt: str ) mut {
//    self.write( txt );
//    self.write( "\n" );
//    self.needIndent = true;
// }

pub override fn convFilter.processNone(
   node: Nodes.NoneNode, opt: Opt ) mut
{
   //self.writeln( "-- none" );
};

pub override fn convFilter.processImport(
   node: Nodes.ImportNode, opt: Opt ) mut
{
   if self.processMode == .Include {
      fn process( out2HMode:Out2HMode ) {
         switch out2HMode {
            case .HeaderPub {
               if node.$symbolInfo.$scope ~= node.$moduleTypeInfo.$scope {
                  return;
               }
            }
            case .SourcePub, .SourcePri {
            }
            default {
               return;
            }
         }
         self.writeln( "#include<%s.h>" ((node.$modulePath.gsub("%.", "/"))) );
      }
      _out2Header(
         self.stream, true,
         `{ process( out2HMode ); } );
   }
   else {
      self.writeln( "lns_init_%s( _pEnv );"
                    (self.moduleCtrl.getFullName( node.$moduleTypeInfo ) ));
   }
};

fn getSymbolIndex( symbol:&Ast.SymbolInfo ) : int {
   let! param = symbol.$convModuleParam {
      return 0;
   };
   return (param@@=SymbolParam).index;
}

fn convFilter.processInitModule( node: Nodes.RootNode ) mut
{
   let anyNum, stemNum, varNum = self.scopeMgr.setupScopeParam( self.ast.$moduleScope );
   
   self.processMode = .InitModule;

   let moduleFullName = self.moduleCtrl.getFullName( node.$moduleTypeInfo );
   let moduleInfoName = "s_module_%s" (moduleFullName);
   
   if self.outputBuiltinFlag {
      self.writeln( "static void lns_init_lns_builtin_Sub( lns_env_t * _pEnv );" );
   }
   elseif not self.canConv {
      self.writeln(
         "extern void lns_init_%s_Sub( lns_env_t * _pEnv );" ( moduleFullName ) );
   }


   fn process( out2HMode:Out2HMode ) {
      self.write(
         "%svoid lns_init_%s( %s _pEnv )"
         ( getOut2HeaderPrefix( out2HMode ), moduleFullName, cTypeEnvP) );
      
      
      switch out2HMode {
         case .HeaderPub {
            self.writeln( ";" );
         }
         case .SourcePub {
            self.writeln( "{" );
         }
      }
   }
   
   _out2Header( self.stream, true, `{ process( out2HMode ); } );


   self.pushIndent(##);

   self.writeln( "if ( %s.readyFlag ) {" ( moduleInfoName ));
   self.pushIndent(##);
   self.writeln( "return;" );
   self.popIndent();
   self.writeln( "}" );
   self.writeln( "%s.readyFlag = true;" ( moduleInfoName ) );
   self.writeln( "lns_add2list( &_pEnv->loadModuleTop, &%s);" (moduleInfoName) );
   self.writeln( "" );


   let moduleBlockName = getBlockName( self.ast.$moduleScope );
   self.writeln( "lns_block_t * %s = lns_enter_module( _pEnv, %d, %d, %d );"
                 (moduleBlockName,
                   anyNum + self.scopeMgr.$numOf__func__, stemNum, varNum ) );
   self.writeln( "%s.pBlock = %s;" (moduleInfoName, moduleBlockName));

   self.writeln( "lns_set_block_any( %s, 0, lns_module_globalStemList);"
                 (moduleBlockName) );
   self.writeln(
      "lns_setQ_any( lns_module_globalStemList, lns_class_List_new( _pEnv ));" );

   self.writeln( "lns_set_block_any( %s, 1, lns_module_path);" (moduleBlockName) );
   self.writeln(
      'lns_setQ_any( lns_module_path, lns_litStr2any( _pEnv, "%s"));'
      ( moduleFullName ) );
   

   // init ブロック内の managedStemTop 用ブロック作成

   // ブロックのスコープの ScopeParam をセットアップし、
   // __func__ シンボルの情報を確定させる。
   foreach blockNode in node.$nodeManager.getBlockNodeList() {
      self.scopeMgr.setupScopeParam( blockNode.$scope );
   }
   self.writeln( "lns_enter_block( _pEnv, 0, 0, 0 );" );
   if self.canConv {
      self.writeln( "initFuncSym( _pEnv, %s );" (moduleBlockName) );
   }
   self.writeln( "" );

   if self.outputBuiltinFlag {
      self.writeln( "lns_init_lns_builtin_Sub( _pEnv );" );
   }
   if not self.canConv {
      self.writeln( "lns_init_%s_Sub( _pEnv );" ( moduleFullName) );
   }
   else {
      foreach declAlgeNode in node.$nodeManager.getDeclAlgeNodeList() {
         filter( declAlgeNode, self, node );
      }
      
      foreach child in node.$children {
         switch child.$kind {
            case Nodes.NodeKind.$DeclAlge,
                 //Nodes.NodeKind.$DeclClass,
                 Nodes.NodeKind.$DeclFunc,
                 Nodes.NodeKind.$DeclMacro
            {
               //filter( child, self, node );
               //self.writeln( "" );
            }
            default {
               filter( child, self, node );
               self.writeln( "" );
            }
         }
      }
   }

   // init ブロック内の managedStemTop 用ブロックの開放
   self.writeln( "lns_leave_block( _pEnv );" );
   
   self.popIndent();

   self.writeln( "}" );
}

/**
builtin 関数の引数シンボル情報
*/
class BuiltinArgSymbolInfo extend Ast.SymbolInfo {
   let scope:&Ast.Scope {pub};
   let name:str {pub};
   let mut typeInfo:&Ast.TypeInfo {pub,pub};
   let allmut convModuleParam:stem! {pub,pub};
   let namespaceTypeInfo:&Ast.TypeInfo {pub};
   
   /** 左辺値になれる場合 true */
   pub override fn get_canBeLeft(): bool {
      return false;
   }
   /** 右辺値になれる場合 true */
   pub override fn get_canBeRight(): bool {
      return true;
   }
   /** このシンボルの ID */
   pub override fn get_symbolId(): int {
      return 0;
   }
   /** シンボルのアクセス */
   pub override fn get_accessMode(): Ast.AccessMode {
      return .Pub;
   }
   pub override fn get_staticFlag() :bool {
      return false;
   }
   pub override fn get_kind(): Ast.SymbolKind {
      return .Arg;
   }
   pub override fn get_pos(): &Parser.Position! {
      return nil;
   }
   /** このシンボルが mut かどうか */
   pub override fn get_mutable(): bool {
      return true;
   }
   pub override fn get_mutMode(): Ast.MutMode {
      return .Mut;
   }
   /** このシンボルがデータを保持しているかどうか */
   pub override fn get_hasValueFlag(): bool {
      return true;
   }
   pub override fn set_hasValueFlag( arg:bool ) {
   }
   pub override fn get_hasAccessFromClosure(): bool {
      return false;
   }
   pub override fn set_hasAccessFromClosure(flag:bool) {
   }

   pub override fn canAccess(
      fromScope:&Ast.Scope, access:Ast.ScopeAccess ) : &Ast.SymbolInfo!
   {
      return self;
   }

   pub override fn getOrg(): &Ast.SymbolInfo {
      return self;
   }
}

fn registerBuiltin() {
   let builtin = TransUnit.getBuiltinFunc();
   foreach symbol in builtin.$allSymbol {
      let param;
      switch symbol.$kind {
         case .Mtd, .Fun {
            let retTypeList = symbol.$typeInfo.$retTypeInfoList;
            param = createSymbolParam( symbol.$name, getRetKind( retTypeList ),
                                       getCRetType( retTypeList ) );
         }
         case .Mbr {
            param = createSymbolParam(
               symbol.$name, getValKind( symbol.$typeInfo ),
               getCType( symbol.$typeInfo ) );
         }
         default {
            Util.err( "illeal symbol -- %s %d" (symbol.$name, __line__) );
         }
      }
      symbol.set_convModuleParam( param );
   }
}

fn convFilter.processBuiltin() : &Nodes.NodeManager
{
   let mut nodeManager = new Nodes.NodeManager();
   let mut dummyPos = new Parser.Position( 0, 0 );

   fn createNodeFromSymbol(
      classInfo:&Ast.TypeInfo!, symbol:&Ast.SymbolInfo ): &Nodes.Node!
   {
      let token = new Parser.Token( .Symb, symbol.$name, dummyPos, false## );
      switch symbol.$kind {
         case .Mtd, .Fun {
            let mut argList:List<&Nodes.Node> = [];
            foreach argType, index in symbol.$typeInfo.$argTypeInfoList {
               let argToken = new Parser.Token(
                  .Symb, "arg%d" (index), dummyPos, false## );
               let dummyScope = new Ast.Scope( nil, false ## );
               let argSym = new BuiltinArgSymbolInfo(
                  dummyScope, argToken.txt, argType, nil, symbol.$typeInfo );
               
               argList.insert(
                  Nodes.DeclArgNode.create(
                     nodeManager, dummyPos, [ argType ],
                     argToken, argSym ) );
            }

            when! classInfo {
               let declFuncInfo = new Nodes.DeclFuncInfo(
                  .Mtd, classInfo, token, argList, false, .Pub, nil,
                  symbol.$typeInfo.$retTypeInfoList, false, false );
               return Nodes.DeclMethodNode.create(
                  nodeManager, dummyPos, [ symbol.$typeInfo ], declFuncInfo );
            }
            else {
               let declFuncInfo = new Nodes.DeclFuncInfo(
                  .Func, nil, token, argList, false, .Pub, nil,
                  symbol.$typeInfo.$retTypeInfoList, false, false );
               return Nodes.DeclFuncNode.create(
                  nodeManager, dummyPos, [ symbol.$typeInfo ], declFuncInfo );
            }
         }
         case .Mbr {
            return nil;
         }
         default {
            Util.err( "illegal kind -- %s" (symbol.$kind.$_txt) );
         }
      }
   }
   

   let builtin = TransUnit.getBuiltinFunc();
   foreach classInfo in builtin.$allClass {
      switch classInfo.$kind {
         case .List, .Array, .Set, .Map, .Box {
         }
         default {
            if classInfo ~= Ast.builtinTypeString {
               print( classInfo.getTxt( ## ) );

               let classScope = unwrap classInfo.$scope;

               let mut fieldList:List<&Nodes.Node> = [];
               
               let declClassNode = Nodes.DeclClassNode.create(
                  nodeManager, dummyPos, [ classInfo ], .Pub,
                  new Parser.Token( .Symb, classInfo.$rawTxt, dummyPos, false## ),
                  classInfo.$rawTxt, nil, fieldList, [], fieldList, [], classScope,
                  new Nodes.ClassInitBlockInfo( nil ), [], [], (@));

               forsort field in classScope.$symbol2SymbolInfoMap {
                  if! let node = createNodeFromSymbol( classInfo, field ) {
                     fieldList.insert( node );
                  }
               }
            }
         }
      }
   }
   foreach symbol in builtin.$allSymbol {
      if symbol.$namespaceTypeInfo.$kind == .Root {
         createNodeFromSymbol( nil, symbol );
      }
   }
   return nodeManager;
}

pub override fn convFilter.processRoot(
   node: Nodes.RootNode, opt: Opt ) mut
{
   let nodeManager;

   registerBuiltin();
   if self.outputBuiltinFlag {
      nodeManager = self.processBuiltin();
   }
   else {
      nodeManager = node.$nodeManager;
   }

   // 最初にトップスコープのパラメータを確定させる
   self.scopeMgr.setupScopeParam( self.ast.$moduleScope );

   
   Ast.pushProcessInfo( node.$processInfo );

   foreach pragma in node.$luneHelperInfo.pragmaSet {
      match pragma {
         case .can_not_conv_code( codeSet ) {
            if codeSet.has( LuneControl.Code.C ) {
               self.canConv = false;
               break;
            }
         }
      }
   }

   self.stream.switchToHeader();
   let ifdefname =
      self.moduleCtrl.getFilePath( self.moduleTypeInfo ).gsub( "/", "_" );
   self.writeln( ```
#ifndef __%s__
#define __%s__
       ``` (ifdefname, ifdefname) );
   self.stream.returnToSource();
   
   
   self.writeln( "// %s" ( self.streamName ) );

   self.writeln( "#include <lunescript.h>" );
   self.writeln(
      "#include <%s.h>"
      ( self.moduleCtrl.getFilePath( node.$moduleTypeInfo ) ) );

   let children = node.get_children();

   self.processMode = .Include;
   foreach importNode in nodeManager.getImportNodeList() {
      filter( importNode, self, node );
   }

   self.writeln(
      "static lns_module_t s_module_%s = {NULL,NULL,false};"
      (self.moduleCtrl.getFullName( node.$moduleTypeInfo )) );
   self.writeln( "static %s lns_module_globalStemList;" (cTypeAnyPP) );
   self.writeln( "static %s lns_module_path = NULL;" (cTypeAnyPP));


   fn process( onlyPub:bool ) {
      macro _processOnlyPub( list:__exp ) {
         foreach workNode in ,,list {
            if onlyPub {
               if Ast.isPubToExternal( workNode.$expType.$accessMode ) {
                  filter( workNode, self, node );
               }
            }
            else {
               filter( workNode, self, node );
            }
         }
      }
      
      self.processMode = .Prototype;
      _processOnlyPub( nodeManager.getDeclEnumNodeList() );
      _processOnlyPub( nodeManager.getDeclFormNodeList() );
      _processOnlyPub( nodeManager.getDeclFuncNodeList() );
      _processOnlyPub( nodeManager.getDeclAlgeNodeList() );
      _processOnlyPub( nodeManager.getDeclClassNodeList() );
      _processOnlyPub( nodeManager.getDeclConstrNodeList() );
      _processOnlyPub( nodeManager.getDeclMethodNodeList() );
      if self.canConv {
         _processOnlyPub( nodeManager.getExpToDDDNodeList() );
         _processOnlyPub( nodeManager.getLiteralStringNodeList() );
      }

      self.processMode = .WideScopeVer;
      foreach child in children {
         if child.$kind == Nodes.NodeKind.$DeclVar {
            if! let declVarNode = child@@@Nodes.DeclVarNode {
               if not onlyPub or Ast.isPubToExternal( declVarNode.$accessMode ) {
                  filter( child, self, node );
               }
            }
         }
      }
      _processOnlyPub( nodeManager.getDeclAlgeNodeList() );
      _processOnlyPub( nodeManager.getDeclClassNodeList() );

      _processOnlyPub( nodeManager.getDeclConstrNodeList() );
      _processOnlyPub( nodeManager.getDeclMethodNodeList() );
      _processOnlyPub( nodeManager.getDeclFuncNodeList() );


      self.processMode = .DefClass;
      _processOnlyPub( nodeManager.getDeclClassNodeList() );
   }

   process( not self.canConv );

   if self.canConv {
      self.processMode = .StringFormat;
      foreach litStr in nodeManager.getLiteralStringNodeList() {
         filter( litStr, self, node );
      }
      
      
      self.processMode = .Immediate;
      self.processedNodeSet = (@);

      fn procssLiteralCtor( literalNodeList:&List<&Nodes.Node> ) {
         foreach literalNode in literalNodeList {
            self.processingNode = literalNode;
            if not self.processedNodeSet.has( literalNode ) {
               self.accessSymbolSet = new Util.OrderedSet<&Ast.SymbolInfo>();
               filter( literalNode, self, node );
               self.processedNodeSet.add( node );
            }
         }
      }
      procssLiteralCtor( nodeManager.getLiteralListNodeList() );
      procssLiteralCtor( nodeManager.getLiteralArrayNodeList() );
      procssLiteralCtor( nodeManager.getLiteralSetNodeList() );
      procssLiteralCtor( nodeManager.getLiteralMapNodeList() );
      self.processingNode = nil;

      
      self.processMode = .Intermediate;
      foreach callNode in nodeManager.getExpCallNodeList() {
         filter( callNode, self, node );
      }
      foreach dddNode in nodeManager.getExpToDDDNodeList() {
         filter( dddNode, self, node );
      }

      self.processMode = .InitFuncSym;
      self.writeln( "static void initFuncSym( %s _pEnv, %s pBlock )\n{"
                    (cTypeEnvP, cTypeBlockP) );
      self.pushIndent( ## );
      
      foreach declConstrNode in nodeManager.getDeclConstrNodeList() {
         filter( declConstrNode, self, node );
      }
      foreach declMethodNode in nodeManager.getDeclMethodNodeList() {
         filter( declMethodNode, self, node );
      }
      foreach declFuncNode in nodeManager.getDeclFuncNodeList() {
         filter( declFuncNode, self, node );
      }

      self.popIndent();
      self.writeln( "}" );
      


      
      self.processMode = .Form;
      foreach declEnumNode in nodeManager.getDeclEnumNodeList() {
         filter( declEnumNode, self, node );
      }
      foreach declAlgeNode in nodeManager.getDeclAlgeNodeList() {
         filter( declAlgeNode, self, node );
      }
      foreach declConstrNode in nodeManager.getDeclConstrNodeList() {
         filter( declConstrNode, self, node );
      }
      foreach declMethodNode in nodeManager.getDeclMethodNodeList() {
         filter( declMethodNode, self, node );
      }
      foreach declFormNode in nodeManager.getDeclFormNodeList() {
         filter( declFormNode, self, node );
      }
      foreach declFuncNode in nodeManager.getDeclFuncNodeList() {
         self.duringDeclFunc = false;
         filter( declFuncNode, self, node );
      }
   }

   
   

   self.processInitModule( node );

   if self.outputBuiltinFlag {
      self.writeln( '#include "lns_builtinInc.c"' );
   }
   

   self.stream.switchToHeader();
   self.writeln( "#endif" );
   self.stream.returnToSource();
   
   Ast.popProcessInfo();
};

pub override fn convFilter.processSubfile(
   node: Nodes.SubfileNode, opt: Opt ) mut
{
}

fn getAccessPrimValFromStem( dddFlag:bool, typeInfo:&Ast.TypeInfo, index:int ) :str
{
   let mut txt = "";
   if dddFlag {
      txt = ".val.pAny->val.ddd.stemList[ %d ]" (index);
   }

   let expType;

   if! let enumType = typeInfo.$srcTypeInfo@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }
   else {
      expType = typeInfo.$srcTypeInfo;
   }
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         txt = txt .. ".val.intVal";
      }
      case Ast.builtinTypeReal {
         txt = txt .. ".val.realVal";
      }
      case Ast.builtinTypeBool {
         txt = txt .. ".val.boolVal";
      }
      default {
         if getValKind( expType ) == .Any {
            txt = txt .. ".val.pAny";
         }
      }
   }
   return txt;
}

fn getAccessValFromStem( typeInfo:&Ast.TypeInfo ) :str
{
   let txt;

   let expType;

   if! let enumType = typeInfo.$srcTypeInfo@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }
   else {
      expType = typeInfo.$srcTypeInfo;
   }
   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         txt = ".val.intVal";
      }
      case Ast.builtinTypeReal {
         txt = ".val.realVal";
      }
      case Ast.builtinTypeBool {
         txt = ".val.boolVal";
      }
      default {
         if getValKind( typeInfo ) == .Any {
            txt = accessAny;
         }
         else {
            txt = "";
         }
      }
   }
   return txt;
}

fn convFilter.processBlockPreProcess( scope:&Ast.Scope ) mut {
   self.pushIndent( ## );
   let anyNum, stemNum, varNum = self.scopeMgr.setupScopeParam( scope );
   self.writeln( "lns_block_t * %s = lns_enter_block( _pEnv, %d, %d, %d );"
                 ( getBlockName( scope ), anyNum, stemNum, varNum ) );
   self.currentRoutineInfo.pushDepth();
}

fn convFilter.processBlockPostProcess() mut {
   self.currentRoutineInfo.popDepth();
   self.writeln( "lns_leave_block( _pEnv );" );
   self.popIndent();
}

fn convFilter.pushRoutine( funcType:&Ast.TypeInfo, blockNode:&Nodes.BlockNode ) mut {
   self.processBlockPreProcess( blockNode.$scope );
   self.currentRoutineInfo = new RoutineInfo( funcType );
   self.routineInfoQueue.insert( self.currentRoutineInfo );
}

fn convFilter.popRoutine() mut {
   self.currentRoutineInfo = self.routineInfoQueue[ #self.routineInfoQueue - 1 ];
   self.routineInfoQueue.remove( ## );
   self.processBlockPostProcess();
}

fn convFilter.processLoopPreProcess( blockNode:&Nodes.BlockNode ) mut {
   self.processBlockPreProcess( blockNode.$scope );
}

fn convFilter.processLoopPostProcess() mut {
   self.processBlockPostProcess();
}

pub override fn convFilter.processBlockSub(
   node: Nodes.BlockNode, opt: Opt ) mut
{
   // ローカル変数のうち、 any として扱う変数を決定し、インデックスを紐付ける。
   self.scopeMgr.setupScopeParam( node.$scope );

   // クロージャでアクセスする外部変数を宣言
   let scope = node.$scope;
   forsort symbol in scope.$closureSymMap {
      // if symbol.$accessFromClosure == .Write {
      //    self.write( cTypeVarP );
      // }
      // else {
      //    self.write( cTypeStem );
      // }
      let typeTxt, valKind = self.scopeMgr.getCTypeForSym( symbol );
      self.write(
         "%s %s = l_form_closure_var( _pForm, %d )"
         ( typeTxt, self.moduleCtrl.getSymbolName( symbol ),
           unwrap scope.$closureSym2NumMap[ symbol ] ) );
      // if valKind == .Stem {
      //    self.write( getAccessPrimValFromStem( false, symbol.$typeInfo, 1 ) );
      // }
      self.writeln( ";" );
   }

   let mut loopFlag = false;
   let mut readyBlock = false;
   
   let mut word = "";
   switch node.get_blockKind() {
      case .If, .Elseif {
         word = "{";
      }
      case .Else {
         word = "";
      }
      case .While {
         word = "{";
         loopFlag = true;
      }
      case .Repeat {
         word = "";
         loopFlag = true;
      }
      case .For {
         word = "";
         loopFlag = true;
      }
      case .Apply {
         word = "";
         loopFlag = true;
      }
      case .Foreach {
         word = "";
         loopFlag = true;
      }
      case .Macro {
         word = "";
      }
      case .Func {
         readyBlock = true;
         word = "";
      }
      case .Default {
         word = "";
      }
      case .Block {
         word = "{";
      }
      case .Macro {
         word = "";
      }
      case .LetUnwrap {
         word = "";
      }
      case .IfUnwrap {
         readyBlock = true;
         word = "";
      }
      case .When {
         readyBlock = true;
         word = "";
      }
   }
   if loopFlag {
      readyBlock = true;
   }
   
   
   self.writeln( "%s // %d" ( word, node.$pos.lineNo ) );

   if not readyBlock {
      self.processBlockPreProcess( node.$scope );
   }
   // if loopFlag {
   //    self.writeln( "lns_reset_block( _pEnv );" );
   // }
   
   let stmtList = node.get_stmtList();
   foreach statement in stmtList {
      filter( statement, self, node );
      self.writeln( "" );
   }

   if not readyBlock {
      self.processBlockPostProcess();
   }
   
   if node.get_blockKind() == .Block {
      self.writeln( "}" );
   }
};

pub override fn convFilter.processStmtExp(
   node: Nodes.StmtExpNode, opt: Opt ) mut
{
   filter( node.$exp,  self, node );
   self.write( "; // %d" (node.$pos.lineNo) );
};

fn getLiteral2Stem( valTxt:str, typeInfo:&Ast.TypeInfo ) : str {
   switch typeInfo.$srcTypeInfo {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return "LNS_STEM_INT( %s )" (valTxt);
      }
      case Ast.builtinTypeReal {
         return "LNS_STEM_REAL( %s )" (valTxt);
      }
      case Ast.builtinTypeBool {
         return "LNS_STEM_BOOL( %s )" (valTxt);
      }
      default {
         return "NULL";
      }
   }
}

fn getStemTypeId( typeInfo:&Ast.TypeInfo ): str {
   switch getOrgTypeInfo( typeInfo ) {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         return "lns_stem_type_int";
      }
      case Ast.builtinTypeInt, Ast.builtinTypeReal {
         return "lns_stem_type_real";
      }
      default {
         return "lns_stem_type_any";
      }
   }
}

fn convFilter.getPrepareClosure(
   funcName:str, argNum:int, hasDDD:bool, symList:&List<&Ast.SymbolInfo> ) mut : str
{
   let mut txt;

   txt = "lns_func2any( _pEnv, (lns_closure_t *)%s, %d, %s, %d"
       (funcName, argNum, hasDDD, #symList );
   foreach symbolInfo in symList {
      txt = txt .. ", ";
      txt = txt .. self.scopeMgr.symbol2Any( symbolInfo );
   }
   txt = txt .. ")";
   return txt;
}


fn convFilter.getFunc2any( funcType:&Ast.TypeInfo ) mut : str
{
   let argList = funcType.$argTypeInfoList;
   let hasDDD =
      #argList > 0 and argList[ #argList ].$kind == .DDD or false;
   
   return self.getPrepareClosure(
      self.moduleCtrl.getFuncName( funcType ), #funcType.$argTypeInfoList,
      hasDDD, (unwrap funcType.$scope).$closureSymList );
}


fn convFilter.processSym2stem( symbolInfo:&Ast.LowSymbol) mut
{
   let valKind = self.scopeMgr.getSymbolValKind( symbolInfo );
   switch valKind {
      case .Any {
         self.write( "LNS_STEM_ANY( " );
         if symbolInfo.$kind == .Var {
            self.write( "*" );
         }
         self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
         self.write( ")" );
         return;
      }
      case .Var {
         self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
         self.write( "->stem" );
         return;
      }
      case .Stem {
         self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
         return;
      }
   }
   
   let mut expType = symbolInfo.$typeInfo.$srcTypeInfo;
   if! let enumType = expType@@@Ast.EnumTypeInfo {
      expType = enumType.$valTypeInfo;
   }

   switch expType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         self.write( "LNS_STEM_INT( " );
         self.write( "" );
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbolInfo ) );
         self.write( ")" );
      }
      case Ast.builtinTypeReal {
         self.write( "LNS_STEM_REAL( " );
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbolInfo ) );
         self.write( ")" );
      }
      case Ast.builtinTypeBool {
         self.write( "LNS_STEM_BOOL( " );
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbolInfo ) );
         self.write( ")" );
      }
      case Ast.builtinTypeStem, Ast.builtinTypeStem_ {
         self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
      }
      default {
         switch expType.$kind {
            case .DDD {
               self.write( "_pDDD" );
            }
            case .Func {    
               if! let scope = expType.$scope {
                  self.write( "LNS_STEM_ANY(" );
                  self.write( self.getFunc2any( expType ) );
                  self.write( ")" );
               }
               else {   
                  Util.err( "illegal func" );
               }
            }
            default {
               self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
            }
         }
      }
   }
}

pub override fn convFilter.processDeclEnum(
   node: Nodes.DeclEnumNode, opt: Opt ) mut
{
   let enumType = unwrap node.$expType@@@Ast.EnumTypeInfo;

   let enumFullName = self.moduleCtrl.getEnumTypeName( enumType );
   let fullName = self.getFullName( enumType );

   let isStrEnum = enumType.$valTypeInfo.equals( Ast.builtinTypeString ##);

   switch self.processMode {
      case .Prototype {
         fn process(out2HMode:Out2HMode) {
            let prefix = getOut2HeaderPrefix( out2HMode );
            foreach valName, index in node.$valueNameList {
               let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
               let enumValName =
                  self.moduleCtrl.getEnumValCName( enumType, valName.txt );
               if isStrEnum {
                  self.writeln( "%s%s %s;" (prefix, cTypeAnyP, enumValName ));
               }
               else {
                  switch out2HMode {
                     case .HeaderPub, .SourcePri {
                        let valTxt = "%s" (Ast.getEnumLiteralVal(valInfo.$val));
                        self.writeln( "#define %s %s" ( enumValName, valTxt ) );
                     }
                  }
               }
            }
            switch out2HMode {
               case .HeaderPub, .SourcePri {
                  self.writeln(
                     "%s%s %s_get__allList( lns_env_t * _pEnv );"
                     (prefix, cTypeAnyP, enumFullName) );
                  self.writeln( "%s%s %s_get__txt( %s _pEnv, %s val );"
                                ( prefix, cTypeAnyP, enumFullName, cTypeEnvP,
                                  getCType( enumType.$valTypeInfo ) ) );
               }
            }
         }
         _out2Header(
            self.stream,
            Ast.isPubToExternal( enumType.$accessMode ),
            `{
               process( out2HMode );
            });
         
         self.writeln( "static %s %s_val2NameMap;" (cTypeAnyP, enumFullName) );
         self.writeln( "static %s %s_allList;" (cTypeAnyP, enumFullName) );
      }
      case .Form {
         if not Ast.isPubToExternal( enumType.$accessMode ) {
            self.write( "static " );
         }
         self.writeln(
            "%s %s_get__allList( lns_env_t * _pEnv )"
            (cTypeAnyP, enumFullName) );
         self.writeln( "{" );
         self.writeln( "    return %s_allList;" (enumFullName) );
         self.writeln( "}" );

         if not isStrEnum {
            let typeTxt;
            if enumType.$valTypeInfo.$srcTypeInfo == Ast.builtinTypeReal {
               typeTxt = "real";
            }
            else {
               typeTxt = "int";
            }
         }

         if not Ast.isPubToExternal( enumType.$accessMode ) {
            self.write( "static " );
         }
         self.writeln( "%s %s_get__txt( %s _pEnv, %s val ) {"
            ( cTypeAnyP, enumFullName, cTypeEnvP,
              getCType( enumType.$valTypeInfo ) ) );
         self.pushIndent( ## );

         self.write( "%s _work =  lns_mtd_Map_get( _pEnv, %s, "
                     ( cTypeStem,
                       self.moduleCtrl.getEnumVal2NameMapName( enumType ) ) );
         // if isStemType( enumType.$valTypeInfo ) {
         //    self.writeln( "val );" );
         // }
         // else {
            let workSym = new WorkSymbol(
               unwrap self.moduleTypeInfo.$scope,
               .Local, "val", enumType.$valTypeInfo, .Arg,
               new SymbolParam( getValKind( enumType.$valTypeInfo ),
                                0, getCType( enumType.$valTypeInfo ) ) );
               
            self.processSym2stem( workSym );
            self.writeln( ");" );
         // }
         self.writeln( "return _work%s;" (accessAny)  );
         
         self.popIndent();
         self.writeln( "}" );
         
         
         self.writeln( "static void init_%s( lns_env_t * _pEnv )" ( enumFullName ) );
         self.writeln( "{" );
         self.pushIndent(##);



         let mut anyVarList:List<str> = [];
         // enum 値のセット
         if isStrEnum {
            foreach valName, index in node.$valueNameList {
               let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
               // pending: C の文字列リテラル表現できないものを対応できていない
               let valTxt = '"%s"' (Ast.getEnumLiteralVal(valInfo.$val));
               let anyVar = self.moduleCtrl.getEnumValCName( enumType, valName.txt );
               anyVarList.insert( "LNS_STEM_ANY( %s )" (anyVar) );

               // self.writeln( "lns_setQ( %s, lns_litStr2any( _pEnv, %s ) );"
               //               (anyVar, valTxt));
               self.writeln( "%s = lns_litStr2any( _pEnv, %s );" (anyVar, valTxt));
            }
         }
         else {
            foreach valName, index in node.$valueNameList {
               let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
               let valTxt = '%s' (Ast.getEnumLiteralVal(valInfo.$val));
               let anyVar = "_%s" (valName.txt);
               anyVarList.insert( anyVar );
               self.write( "%s %s = " (cTypeStem, anyVar));
               self.write( getLiteral2Stem( valTxt, enumType.$valTypeInfo ) );
               self.writeln( ";" );
            }
         }

         // _allList のセット
         let allListName = "%s_allList" (enumFullName);
         self.write( allListName );
         self.writeln( " = lns_class_List_new( _pEnv );" );
         self.processAddModuleGlobal( "LNS_STEM_ANY( %s )" (allListName) );
         
         foreach anyVar in anyVarList {
            self.writeln(
               "lns_mtd_List_insert( _pEnv, %s_allList, %s );"
               (enumFullName, anyVar ));
         }

         // _val2NameMap のセット
         let val2NameMapName = "%s_val2NameMap" (enumFullName);
         self.write( val2NameMapName );
         self.writeln( " = lns_class_Map_new( _pEnv );"  );
         self.processAddModuleGlobal( "LNS_STEM_ANY( %s )" (val2NameMapName) );
         
         foreach anyVar, index in anyVarList {
            self.writeln(
               "lns_mtd_Map_add( _pEnv, %s_val2NameMap, %s, "
               (enumFullName, anyVar ));
            
            self.writeln(
               '  LNS_STEM_ANY( lns_litStr2any( _pEnv, "%s.%s" ) ) );'
               (fullName, node.$valueNameList[ index ].txt));
         }
         

         self.popIndent();
         self.writeln( "}" );
      }
      case .InitModule {
         self.writeln( "init_%s( _pEnv );" ( enumFullName ) );
      }
   }
   
   

   
//    let mut access = node.$accessMode == .Global and "" or "local ";
//    let mut enumFullName = node.$name.txt;
//    let enumType = unwrap node.$expType@@@Ast.EnumTypeInfo;
//    let parentInfo = enumType.$parentInfo;
//    let mut isTopNS = true;
//    if parentInfo ~= Ast.headTypeInfo and parentInfo.$kind == .Class {
//       enumFullName = "%s.%s" (self.getFullName( parentInfo ), enumFullName );
//       access = "";
//       isTopNS = false;
//    }


//    self.writeln( "%s%s = {}" (access, enumFullName) );
//    if isTopNS and node.$accessMode == .Pub {
//       if self.needModuleObj {
//          self.writeln( "_moduleObj.%s = %s" ( enumFullName, enumFullName ) );
//       }
//    }


//    if enumType.$accessMode == .Pub {
//       self.pubEnumId2EnumTypeInfo[ enumType.$typeId ] = enumType;
//    }

//    self.writeln( "%s._val2NameMap = {}" (enumFullName) );
//    self.writeln( ```function %s:_getTxt( val )
//    local name = self._val2NameMap[ val ]
//    if name then
//       return string.format( "%s.%%s", name )
//    end
//    return string.format( "illegal val -- %%s", val )
// end
// function %s._from( val )
//    if %s._val2NameMap[ val ] then
//       return val
//    end
//    return nil
// end
//     ``` (enumFullName, enumFullName,
//           enumFullName, enumFullName ) );
//    self.writeln(
// ```
// %s.__allList = {}
// function %s.get__allList()
//    return %s.__allList
// end
// ``` (enumFullName, enumFullName, enumFullName ) );

//    foreach valName, index in node.$valueNameList {
//       let valInfo = unwrap enumType.getEnumValInfo( valName.txt );
//       let mut valTxt = "%s" (Ast.getEnumLiteralVal(valInfo.$val));
//       if enumType.$valTypeInfo.equals( Ast.builtinTypeString ##) {
//          valTxt = "'%s'" (Ast.getEnumLiteralVal(valInfo.$val));
//       }
//       self.writeln( "%s.%s = %s" (enumFullName, valName.txt, valTxt ) );

//       self.writeln( "%s._val2NameMap[%s] = '%s'"
//          (enumFullName, valTxt, valName.txt ) );
//       self.writeln( "%s.__allList[%d] = %s.%s"
//          (enumFullName, index, enumFullName, valName.txt ) );
//    }
}

fn isGenericType( typeInfo:&Ast.TypeInfo ): bool {
   if Ast.isGenericType( typeInfo ) {
      return true;
   }
   switch typeInfo.$kind {
      case .Class, .IF {
         if #typeInfo.$itemTypeInfoList > 0 {
            return true;
         }
      }
   }
   return false;
}



// fn convFilter.getMapInfo( typeInfo:&Ast.TypeInfo ): str, bool, str
// {
   // let mut nonnilableType = typeInfo.$srcTypeInfo;
   // if typeInfo.$nilable {
   //    nonnilableType = typeInfo.$nonnilableType;
   // }

   // let mut child = "{}";
   // let mut funcTxt = "";
   // switch nonnilableType.$kind {
   //    case .Stem {
   //       funcTxt = '_lune._toStem';
   //    }
   //    case .Class, .IF {
   //       if not nonnilableType.equals( Ast.builtinTypeString ##) {
   //          funcTxt = '%s._fromMap' (self.getFullName(nonnilableType));
   //          if isGenericType( nonnilableType ) {
   //             let mut memStream = new Util.memStream();
   //             self.outputAlter2MapFunc(
   //                memStream, nonnilableType.createAlt2typeMap(false) );
   //             child = memStream.$txt;
   //          }
   //       }
   //       else {
   //          funcTxt = '_lune._toStr';
   //       }
   //    }
   //    case .Enum, .Alge {
   //       funcTxt = '%s._from' (self.getFullName(nonnilableType));
   //    }
   //    case .Prim {
   //       switch nonnilableType {
   //          case Ast.builtinTypeInt {
   //             funcTxt = '_lune._toInt';
   //          }
   //          case Ast.builtinTypeReal {
   //             funcTxt = '_lune._toReal';
   //          }
   //          case Ast.builtinTypeBool {
   //             funcTxt = '_lune._toBool';
   //          }
   //          default {
   //             Util.err( "unknown type -- %s" (nonnilableType.getTxt(##)) );
   //          }
   //       }
   //    }
   //    case .Map {
   //       funcTxt = '_lune._toMap';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let keyFuncTxt, keyNilable, keyChild = self.getMapInfo( itemList[1] );
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[2] );

   //       child = "{ { func = %s, nilable = %s, child = %s }, \n"
   //           (keyFuncTxt, keyNilable, keyChild) ..
   //          "{ func = %s, nilable = %s, child = %s } }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .Set {
   //       funcTxt = '_lune._toSet';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[1] );

   //       child = "{ func = %s, nilable = %s, child = %s }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .List, .Array {
   //       funcTxt = '_lune._toList';
   //       let itemList = nonnilableType.$itemTypeInfoList;
   //       let valFuncTxt, valNilable, valChild = self.getMapInfo( itemList[1] );

   //       child = "{ { func = %s, nilable = %s, child = %s } }"
   //           (valFuncTxt, valNilable, valChild);
   //    }
   //    case .Alternate {
   //       let prefix = "obj.__alt2mapFunc.%s" ( nonnilableType.$rawTxt );
   //       funcTxt = "%s.func" ( prefix );
   //       child = "%s.child" ( prefix );
   //    }
   // }
   // return funcTxt, typeInfo.$nilable, child;
// }

fn processAlgeNewProto( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                        typeInfo:&Ast.TypeInfo, valInfo:&Ast.AlgeValInfo )
{
   stream.write(
      "%s %s( %s _pEnv"
      ( cTypeStem,
        moduleCtrl.getNewAlgeCName( typeInfo, valInfo.$name ), cTypeEnvP ) );

   foreach typeInfo, index in valInfo.$typeList {
      stream.write( ", %s _val%d" (getCType( typeInfo ), index) );
   }
   stream.write( ")" );
}

fn processAlgePrototype( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                         node:Nodes.DeclAlgeNode )
{
   let algeType = node.$algeType;
   let mut valList:List<&Ast.AlgeValInfo> = [];
   
   forsort valInfo in algeType.$valInfoMap {
      valList.insert( valInfo );
   }

   fn process() {
      // 各値を識別する enum を宣言
      stream.writeln( "typedef enum {" );
      stream.pushIndent( ## );
      let algeTypeName = moduleCtrl.getAlgeCName( node.$expType );
      let enumName = moduleCtrl.getAlgeEnumCName( node.$expType );

      
      foreach valInfo, index in valList {
         if index > 1 {
            stream.writeln( "," );
         }
         stream.write( "%s_%s" (enumName, valInfo.$name) );
      }
      stream.writeln( "" );
      stream.popIndent();
      stream.writeln( "} %s;" ( enumName ) );

      // alge 型の struct を宣言
      foreach valInfo in valList {
         if #valInfo.$typeList > 0 {
            stream.writeln( "typedef struct {" );
            stream.pushIndent(##);
            foreach typeInfo, index in valInfo.$typeList {
               stream.writeln( "%s _val%d;" (getCType( typeInfo ), index) );
            }
            stream.popIndent();
            stream.writeln(
               "} %s;" (moduleCtrl.getAlgeValStrCName( node.$expType, valInfo.$name) ) );
         }
      }

      // alge 型のパラメータ有りの値を生成する関数宣言
      foreach valInfo in valList {
         if #valInfo.$typeList > 0 {
            processAlgeNewProto( stream, moduleCtrl, node.$expType, valInfo );
            stream.writeln( ";" );
         }
      }
   }


   _out2Header(
      stream,
      Ast.isPubToExternal( node.$expType.$accessMode ),
      `{
         switch out2HMode {
            case .HeaderPub, .SourcePri {
               process();
            }
         }
      });


   // alge 型のパラメータ無しの値を初期化する関数宣言
   stream.writeln(
      "static void %s( %s _pEnv );"
      (moduleCtrl.getAlgeInitCName(node.$expType), cTypeEnvP ) );
}

fn processAlgeWideScope( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                         node:Nodes.DeclAlgeNode )
{
   let algeType = node.$algeType;
   let mut valList:List<&Ast.AlgeValInfo> = [];
   
   forsort valInfo in algeType.$valInfoMap {
      valList.insert( valInfo );
   }

   let algeTypeName = moduleCtrl.getAlgeCName( node.$expType );

   fn process( out2HMode:Out2HMode ) {
      let prefix = getOut2HeaderPrefix( out2HMode );

      foreach valInfo, index in valList {
         if #valInfo.$typeList == 0 {
            let varName = moduleCtrl.getAlgeValCName( node.$expType, valInfo.$name );
            stream.writeln(
               "%s%s %s;" (prefix, cTypeStem, varName ) );
            stream.writeln(
               "%s%s %s_any;" (prefix, cTypeAny, varName ) );
         }
      }
   }
   
   _out2Header(
      stream,
      Ast.isPubToExternal( node.$expType.$accessMode ),
      `{
         switch out2HMode {
            case .HeaderPub, .SourcePri, .SourcePub {
               process( out2HMode );
            }
         }
      });
}

fn processAlgeForm( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                    node:Nodes.DeclAlgeNode )
{
   let algeType = node.$algeType;
   let mut valList:List<&Ast.AlgeValInfo> = [];
   
   forsort valInfo in algeType.$valInfoMap {
      valList.insert( valInfo );
   }

   // パラメータの無い値の初期化関数
   stream.writeln(
      "static void %s( %s _pEnv ) {"
      (moduleCtrl.getAlgeInitCName(algeType), cTypeEnvP ) );
   stream.pushIndent(##);

   let enumName = moduleCtrl.getAlgeEnumCName( algeType );
   foreach valInfo, index in valList {
      if #valInfo.$typeList == 0 {
         let varName = moduleCtrl.getAlgeValCName( algeType, valInfo.$name );
         stream.writeln(
            "lns_init_alge( &%s, &%s_any, %s_%s );"
            ( varName, varName, enumName, valInfo.$name ) );
      }
   }
   
   stream.popIndent();
   stream.writeln( "}" );

   let algeName = moduleCtrl.getAlgeCName( algeType );

   // パラメータを持つ値の生成関数
   foreach valInfo, index in valList {
      if #valInfo.$typeList > 0 {
         let mut hasAnyFlag = false;
         foreach valType, paramIndex in valInfo.$typeList {
            if isStemType( valType ) {
               hasAnyFlag = true;
               break;
            }
         }
         
         let valStruct = moduleCtrl.getAlgeValStrCName( algeType, valInfo.$name );
         let gcTxt;

         if hasAnyFlag {
            gcTxt = "lns_gc_alge_%s_%s" (algeName, valInfo.$name);
            stream.writeln(
               "static void %s( %s _pEnv, void * pVal ) {" (gcTxt, cTypeEnvP) );
            stream.pushIndent( ## );
            stream.writeln( "%s *pWorkVal = (%s *)pVal;" ( valStruct, valStruct ) );
            
            foreach valType, paramIndex in valInfo.$typeList {
               if isStemType( valType ) {
                  stream.writeln(
                     "lns_decre_ref( _pEnv, pWorkVal->_val%d.val.pAny );" ( paramIndex) );
               }
            }
            stream.popIndent();
            stream.writeln( "}" );
         }
         else {
            gcTxt = "NULL";
         }
         
         processAlgeNewProto( stream, moduleCtrl, algeType, valInfo );
         stream.writeln( "{" );
         stream.pushIndent( ## );

         stream.writeln(
            "%s pAny = lns_alge_new( _pEnv, %s_%s, sizeof( %s ), %s );"
            (cTypeAnyP, enumName, valInfo.$name, valStruct, gcTxt ) );
         stream.writeln( "%s *pVal = pAny->val.alge.pVal;" ( valStruct ) );

         foreach valType, paramIndex in valInfo.$typeList {
            if isStemType( valType ) {
               stream.writeln(
                  "lns_setQ( pVal->_val%d, _val%d );"
                  (paramIndex, paramIndex) );
            }
            else {
               stream.writeln( "pVal->_val%d = _val%d;" (paramIndex, paramIndex) );
            }
         }

         stream.writeln( "return LNS_STEM_ANY( pAny );" );
         
         stream.popIndent();
         stream.writeln( "}" );
      }
   }
   
   
}

pub override fn convFilter.processDeclAlge(
   node: Nodes.DeclAlgeNode, opt: Opt ) mut
{
   switch self.processMode {
      case .Prototype {
         processAlgePrototype( self.stream, self.moduleCtrl, node );
      }
      case .WideScopeVer {
         processAlgeWideScope( self.stream, self.moduleCtrl, node );
      }
      case .Form {
         processAlgeForm( self.stream, self.moduleCtrl, node );
      }
      case .InitModule {
         self.writeln( "%s( _pEnv );"
                       (self.moduleCtrl.getAlgeInitCName(node.$expType) ) );
      }
   }
//    let mut access = node.$accessMode == .Global and "" or "local ";
//    let mut algeFullName = node.$algeType.$rawTxt;
//    let typeInfo = unwrap node.$expType@@@Ast.AlgeTypeInfo;
//    let parentInfo = typeInfo.$parentInfo;
//    let mut isTopNS = true;
//    if parentInfo ~= Ast.headTypeInfo and parentInfo.$kind == .Class {
//       algeFullName = "%s.%s" (self.getFullName( parentInfo ), algeFullName );
//       access = "";
//       isTopNS = false;
//    }


//    self.writeln( "%s%s = {}" (access, algeFullName) );
//    self.writeln( "%s._name2Val = {}" (algeFullName) );
//    if isTopNS and node.$accessMode == .Pub {
//       if self.needModuleObj {
//          self.writeln( "_moduleObj.%s = %s" ( algeFullName, algeFullName ) );
//       }
//    }


//    if typeInfo.$accessMode == .Pub {
//       self.pubAlgeId2AlgeTypeInfo[ typeInfo.$typeId ] = typeInfo;
//    }

//    self.writeln( ```function %s:_getTxt( val )
//    local name = val[ 1 ]
//    if name then
//       return string.format( "%s.%%s", name )
//    end
//    return string.format( "illegal val -- %%s", val )
// end
// ``` (algeFullName, algeFullName ) );
//    self.writeln( ```
// function %s._from( val )
//    return _lune._AlgeFrom( %s, val )
// end
// ``` (algeFullName, algeFullName) );
//    forsort valInfo in node.$algeType.$valInfoMap {
//       self.write( '%s.%s = { "%s"' (algeFullName, valInfo.$name, valInfo.$name ) );
//       let mut memInfoTxt = "";
//       if #valInfo.$typeList > 0 {
//          self.write( ", {" );
//          foreach paramType, index in valInfo.$typeList {
//             if index > 1 {
//                self.write( "," );
//             }
//             let funcTxt, nilable, child = self.getMapInfo( paramType );
//             self.write( "{ func=%s, nilable=%s, child=%s }" (funcTxt, nilable, child) );
//          }
//          self.write( "}" );
//       }
//       self.writeln( "}" );
//       self.writeln( '%s._name2Val["%s"] = %s.%s'
//                     ( algeFullName, valInfo.$name, algeFullName, valInfo.$name ) );
//    }
}

pub override fn convFilter.processNewAlgeVal(
   node: Nodes.NewAlgeValNode, opt: Opt ) mut
{
   let valInfo = node.$valInfo;
   if #valInfo.$typeList == 0 {
      let valName = self.moduleCtrl.getAlgeValCName( node.$algeTypeInfo, valInfo.$name );
      self.write( "%s" (valName) );
   }
   else {
      self.write( self.moduleCtrl.getNewAlgeCName( node.$algeTypeInfo, valInfo.$name ) );
      self.write( "( _pEnv" );

      foreach arg in node.$paramList {
         self.write( "," );
         filter( arg, self, node );
      }
      self.write( ")" );
   }

   
   // let valInfo = node.$valInfo;
   // self.write( '_lune.newAlge( %s.%s'
   //             (self.getFullName( node.$algeTypeInfo ), valInfo.$name ) );
   // if #valInfo.$typeList > 0 {
   //    self.write( ", {" );
   //    foreach exp, index in node.$paramList {
   //       if index > 1 {
   //          self.write( "," );
   //       }
   //       filter( exp, self, node );
   //    }
   //    self.write( "}" );
   // }
   // self.write( ")" );
}



// fn convFilter.getDestrClass( classTypeInfo:&Ast.TypeInfo ) : &Ast.TypeInfo!
// {
   // let mut typeInfo = classTypeInfo;
   // while not typeInfo.equals( Ast.headTypeInfo ##) {
   //    let scope = unwrap typeInfo.$scope;
   //    if! scope.getTypeInfoChild( "__free" ) {
   //       return typeInfo;
   //    }
   //    typeInfo = typeInfo.$baseTypeInfo;
   // }
   // return nil;
// }

fn convFilter.outputAlter2MapFunc(
   stream:Util.SourceStream, alt2Map:&Map<&Ast.TypeInfo,&Ast.TypeInfo>)
{
   // stream.write( "{" );

   // foreach assinType, altType in alt2Map {
   //    if altType.$kind == .Alternate {
   //       if assinType.$kind == .Alternate {
   //          stream.write(
   //             "%s = self.__alt2mapFunc[ %q ],"
   //             (assinType.$rawTxt, assinType.$rawTxt ) );
   //       }
   //       else {
   //          let funcTxt, nilable, child = self.getMapInfo( assinType );
   //          stream.write(
   //             "%s = { func=%s, nilable=%s, child=%s },"
   //             (altType.$rawTxt, funcTxt, nilable, child) );
   //       }
   //    }
   // }

   // stream.write( "}" );
}

fn getMethodTypeTxt( retTypeList:&List<&Ast.TypeInfo> ) : str {
   if #retTypeList == 1 {
      let mut retType = retTypeList[ 1 ].$srcTypeInfo;
      if! let enumType = retType@@@Ast.EnumTypeInfo {
         retType = enumType.$valTypeInfo;
      }
      switch retType {
         case Ast.builtinTypeInt, Ast.builtinTypeChar {
            return "lns_method_int_t";
         }
         case Ast.builtinTypeReal {
            return "lns_method_real_t";
         }
         case Ast.builtinTypeBool {
            return "lns_method_bool_t";
         }
      }
      if getValKind( retType ) == .Any {
            return "lns_method_any_t";
      }
   }
   return "lns_method_t";
}

fn processNewConstrProto(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   node:&Nodes.DeclClassNode, out2HMode:Out2HMode, outputBuiltinFlag:bool ) mut
{
   let className = moduleCtrl.getClassCName( node.$expType );

   stream.write( getOut2HeaderPrefix( out2HMode ) );
   stream.write( "%s lns_class_%s_new( %s _pEnv"
      (cTypeAnyP, className, cTypeEnvP ) );


   if not outputBuiltinFlag {
      let scope = unwrap node.$expType.$scope;
      let initFuncType = unwrap scope.getTypeInfoField(
         "__init", true, scope, scopeAccess );
      foreach argType, index in initFuncType.$argTypeInfoList {
         stream.write( ", %s arg%d" ( getCType( argType ), index ) );
      }
   }
   stream.write( ")" );
}

fn processMethodDeclTxt(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   callFlag:bool, methodTypeInfo:&Ast.TypeInfo, argList:&List<&Nodes.Node>! )
{
   if methodTypeInfo.$rawTxt ~= "__init" and not callFlag {
      if not methodTypeInfo.$staticFlag or
         not Ast.isPubToExternal( methodTypeInfo.$accessMode ) or
         not Ast.isPubToExternal( methodTypeInfo.$parentInfo.$accessMode )
      {
         stream.write( "static " );
      }
   }

   stream.write(
      "%s %s( %s _pEnv"
      ( getCRetType( methodTypeInfo.$retTypeInfoList ),
        callFlag and moduleCtrl.getCallMethodCName( methodTypeInfo ) or
        moduleCtrl.getMethodCName( methodTypeInfo ), cTypeEnvP ) );
   if methodTypeInfo.$staticFlag {
      if isClosure( methodTypeInfo ) {
         stream.write( ", %s _pForm" ( cTypeAnyP ) );
      }
   }
   else {
      stream.write( ", %s pObj" ( cTypeAnyP ) );
   }

   when! argList {
      foreach argNode, index in argList {
         if! let declArgNode = argNode@@@Nodes.DeclArgNode {
            stream.write( ", %s %s" ( getCType( declArgNode.$expType ),
                                      declArgNode.$name.txt ) );
         }
      }
   }
   else {
      foreach arg, index in methodTypeInfo.$argTypeInfoList {
         stream.write( ", %s arg%d" ( getCType( arg ), index ) );
      }
   }
   stream.write( ")" );
}


fn processDeclMethodTable( stream:Util.SourceStream, classTypeInfo:&Ast.TypeInfo )
{
   fn outputField( name:str, retTypeList: &List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "%s * %s;" (methodType, name ) );
   }

   fn outputVal( scope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mtd {
               if symbolInfo.$name ~= "__init" {
                  if not scope.getSymbolInfoField(
                     symbolInfo.$name, false, scope, .Normal )
                  {
                     outputField( symbolInfo.$name,
                                  symbolInfo.$typeInfo.$retTypeInfoList );
                  }
               }
            }
         }
      }
   }
   outputVal( unwrap classTypeInfo.$scope );
}


fn processDeclMemberTable( stream:Util.SourceStream, classTypeInfo:&Ast.TypeInfo )
{
   fn outputVal( scope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mbr {
               if not symbolInfo.$staticFlag {
                  stream.writeln( "%s %s;" ( getCType( symbolInfo.$typeInfo ),
                                             symbolInfo.$name ) );
               }
            }
         }
      }
   }
   stream.writeln( "// member" );
   outputVal( unwrap classTypeInfo.$scope );
}

fn hasGC( classTypeInfo:&Ast.TypeInfo ): bool {
   if! let scope = classTypeInfo.$scope {
      if scope.getSymbolInfoField( "_gc", true, scope, scopeAccess ) {
         return true;
      }
   }
   let mut workInfo = classTypeInfo;
   while workInfo.hasBase() {
      workInfo = workInfo.$baseTypeInfo;
      if! let scope = classTypeInfo.$scope {
         if scope.getSymbolInfoField( "_gc", true, scope, scopeAccess ) {
            return true;
         }
      }
   }
   return false;
}
   

fn processDeclClassPrototype(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   scopeMgr:ScopeMgr, node:&Nodes.DeclClassNode )
{
   let className = moduleCtrl.getClassCName( node.$expType );
   
   // _gc, _del のプロトタイプ
   stream.writeln(
      "static void mtd_%s__del( lns_env_t * _pEnv, %s pObj );"
      (className, cTypeAnyP) );
   if hasGC( node.$expType ) {
      stream.writeln( "static void mtd_%s__gc( lns_env_t * _pEnv, %s pObj );"
                      (className, cTypeAnyP ) );
   }
   
   // アクセッサのプロトタイプ
   foreach member in node.$memberList {
      let memberName = member.$name.txt;
      if member.$getterMode ~= .None {
         let getterType = unwrap node.$scope.getTypeInfoField(
            "get_%s" (memberName), true, node.$scope, scopeAccess );
         processMethodDeclTxt( stream, moduleCtrl, false, getterType## );
         stream.writeln( ";" );
      }
      if member.$setterMode ~= .None {
         let setterType = unwrap node.$scope.getTypeInfoField(
            "set_%s" (memberName), true, node.$scope, scopeAccess );
         processMethodDeclTxt( stream, moduleCtrl, false, setterType## );
         stream.writeln( ";" );
      }
   }

   foreach advInfo in node.$advertiseList {
      let member = advInfo.$member;
      let nameList = Ast.getAllMethodName( member.$expType );
      // foreach symbol in unwrap member.$expType.$scope.filterTypeInfoField(
      //    bool!, Scope, ScopeAccess, filterForm(SymbolInfo): bool): bool {
         
      // }
   }
}

fn processDefaultCtor(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   scopeMgr:ScopeMgr, node:&Nodes.DeclClassNode )
{
   let className = moduleCtrl.getClassCName( node.$expType );

   if not node.hasUserInit() {
      // デフォルトコンストラクタの処理
      stream.write(
         "static void mtd_%s___init( lns_env_t * _pEnv, %s pAny"
         (className, cTypeAnyP ) );

      let ctorType = unwrap node.$scope.getTypeInfoField(
         "__init", true, node.$scope, scopeAccess );
      
      foreach argType, index in ctorType.$argTypeInfoList {
         stream.write(
            ", %s _arg%d"
            (getCType( argType ), index ) );
      }
      stream.writeln( ") {" );
      stream.pushIndent(##);

      if! let baseScope = node.$scope.$inherit {
         let superInitType =
            unwrap baseScope.getTypeInfoField( "__init", true, baseScope, scopeAccess );
         stream.write( "mtd_%s___init( _pEnv, pAny"
            (moduleCtrl.getClassCName( node.$expType.$baseTypeInfo ) ) );
         foreach argType, index in superInitType.$argTypeInfoList {
            stream.write( ", _arg%d" (index) );
         }
         stream.writeln( ");" );
      }

      
      stream.writeln( "%s * pObj = lns_obj_%s( pAny );" (className, className) );
      foreach member, index in node.$memberList {
         if not member.$staticFlag {
            let valKind = scopeMgr.getSymbolValKind( member.$symbolInfo );
            switch valKind {
               case .Stem {
                  stream.writeln(
                     "lns_setQ( pObj->%s, _arg%d );" (member.$name.txt, index ));
               }
               case .Any {
                  stream.writeln(
                     "lns_setQ_any( &pObj->%s, _arg%d );" (member.$name.txt, index ));
               }
               case .Prim {
                  stream.writeln( "pObj->%s = _arg%d;" (member.$name.txt, index));
               }
               default {
                  Util.err(
                     "no support -- %s:%s:%d"
                     (member.$name.txt, valKind.$_txt, __line__) );
               }
            }
         }
      }
      stream.popIndent();
      stream.writeln( "}" );
   }
}

fn processIFObjDecl(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl, classType:&Ast.TypeInfo )
{
   if classType.hasBase() {
      processIFObjDecl( stream, moduleCtrl, classType.$baseTypeInfo );
   }

   foreach ifType in classType.$interfaceList {
      stream.writeln( "%s %s;" (cTypeAny, moduleCtrl.getClassCName( ifType ) ) );
   }
}

fn processIFObjInit(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   classType:&Ast.TypeInfo, impClassType:&Ast.TypeInfo )
{
   if classType.hasBase() {
      processIFObjInit( stream, moduleCtrl, classType.$baseTypeInfo, impClassType );
   }

   let className = moduleCtrl.getClassCName( impClassType );
   foreach ifType in classType.$interfaceList {
      let ifName = moduleCtrl.getClassCName( ifType );
      stream.writeln(
         "lns_init_if( &pObj->imp.%s, _pEnv, pAny, &lns_if_%s_imp_%s, %s );"
         (ifName, className, ifName, ifName) );
   }
}


fn convFilter.processDeclClassNodePrototype( node:&Nodes.DeclClassNode ) mut
{
   let className = self.moduleCtrl.getClassCName( node.$expType );

   let kind = node.$expType.$kind;

   fn process( out2HMode:Out2HMode ) {
      // メソッド構造体の宣言
      self.writeln( "typedef struct lns_mtd_%s_t {" (className) );
      self.pushIndent(##);

      if kind == .Class {
         self.writeln( "lns_del_t * _del;" );
         self.writeln( "lns_gc_t * _gc;" );
      }

      processDeclMethodTable( self.stream, node.$expType );

      self.popIndent();
      self.writeln( "} lns_mtd_%s_t;" (className) );

      if kind == .Class {
         self.writeln( "typedef struct u_if_imp_%s_t {" (className) );
         self.pushIndent(##);

         processIFObjDecl( self.stream, self.moduleCtrl, node.$expType );

         self.writeln( "%s sentinel;" (cTypeAny) );
         self.popIndent();
         self.writeln( "} u_if_imp_%s_t;" (className) );
      }
      

      // クラス構造体の宣言
      self.writeln( "typedef struct %s {" (className) );
      self.pushIndent( ## );
      
      self.writeln( "lns_type_meta_t * pMeta;" );
      switch kind {
         case .Class {
            self.writeln( "u_if_imp_%s_t * pImp;" (className) );
            self.writeln( "lns_mtd_%s_t * pMtd;" (className) );
            processDeclMemberTable( self.stream, node.$expType );
            self.writeln( "// interface implements" );
            self.writeln( "u_if_imp_%s_t imp;" (className) );
         }
         case .IF {
            self.writeln( "%s pObj;" (cTypeAnyP) );
            self.writeln( "lns_mtd_%s_t * pMtd;" (className) );
         }      
      }

      self.popIndent();
      self.writeln( "} %s;" (className) );

      switch kind {
         case .Class {
            self.writeln( ```#define lns_mtd_%s( OBJ )                     \
                (((%s*)OBJ->val.classVal)->pMtd )``` (className,className) );
            self.writeln( "#define lns_obj_%s( OBJ ) ((%s*)OBJ->val.classVal)"
                          (className,className) );
            self.writeln( "#define lns_if_%s( OBJ ) ((%s*)OBJ->val.classVal)->pImp"
                          (className,className) );

            //if not self.outputBuiltinFlag {
               // コンストラクタのプロトタイプ
            processNewConstrProto(
               self.stream, self.moduleCtrl, node, out2HMode, self.outputBuiltinFlag );
               self.stream.writeln( ";" );
            //}
         }
         case .IF {
            self.writeln( ```#define lns_mtd_%s( OBJ )                     \
             ((%s*)&OBJ->val.ifVal)->pMtd``` (className,className) );
            if out2HMode == .HeaderPub {
               self.writeln( 'extern lns_type_meta_t lns_type_meta_%s;' (className) );
            }
         }
      }
   }
   
   _out2Header(
      self.stream,
      Ast.isPubToExternal( node.$expType.$accessMode ),
      `{
         switch out2HMode {
            case .HeaderPub, .SourcePri {
               process( out2HMode );
            }
         }
      });

   if kind == .Class {
      processDeclClassPrototype( self.stream, self.moduleCtrl, self.scopeMgr, node );

      if not self.outputBuiltinFlag {
         processDefaultCtor( self.stream, self.moduleCtrl, self.scopeMgr, node );
      }
   }
}

fn convFilter.processDeclClassDef( node:&Nodes.DeclClassNode ) mut
{
   let className = self.moduleCtrl.getClassCName( node.$expType );

   self.writeln( "static void mtd_%s__del( lns_env_t * _pEnv, %s pObj ) {"
      (className, cTypeAnyP) );
   self.pushIndent(##);
   
   if node.$expType.hasBase() {
      self.writeln( "mtd_%s__del( _pEnv, pObj );"
                    (self.moduleCtrl.getClassCName( node.$expType.$baseTypeInfo) ) );
   }

   foreach member in node.$memberList {
      let valKind = self.scopeMgr.getSymbolValKind( member.$symbolInfo );
      switch valKind {
         case .Stem, .Any {
            let access;
            if member.$expType.$kind == .Alternate {
               self.writeln( "lns_decre_ref_alter" );
               access = "";
            }
            else {
               self.writeln( "lns_decre_ref" );
               if valKind == .Stem {
                  access = accessAny;
               }
               else {
                  access = "";
               }
            }
            self.writeln( "( _pEnv, lns_obj_%s( pObj )->%s%s );"
                          (className, member.$name.txt, access ) );
         }
      }
   }

   self.popIndent();
   self.writeln( "}" );

   // デフォルトコンストラクタの定義
   processNewConstrProto( self.stream, self.moduleCtrl, node, .SourcePub,
                          self.outputBuiltinFlag );
   self.writeln( "{" );
   self.pushIndent(##);
   
   self.writeln( "lns_class_new_( _pEnv, %s, pAny, pObj );" (className) );

   if not self.outputBuiltinFlag {
      self.write( "mtd_%s___init( _pEnv, pAny" ( className ) );

      let scope = unwrap node.$expType.$scope;
      if not self.outputBuiltinFlag {
         let initFuncType = unwrap scope.getTypeInfoField( "__init", true, scope, scopeAccess );
         foreach argType, index in initFuncType.$argTypeInfoList {
            self.write( ", arg%d" ( index ) );
         }
      }
      self.writeln( ");" );
   }
   
   self.writeln( "pObj->pImp = &pObj->imp;" );
   self.writeln( "pObj->imp.sentinel.type = lns_value_type_none;" );
   
   processIFObjInit( self.stream, self.moduleCtrl, node.$expType, node.$expType );

   self.writeln( "return pAny;" );
   self.popIndent();
   self.writeln( "}" );


   // アクセッサの定義
   foreach member in node.$memberList {
      let memberName = member.$name.txt;
      if member.$getterMode ~= .None {
         let getterType = unwrap node.$scope.getTypeInfoField(
            "get_%s" (memberName), true, node.$scope, scopeAccess );
         if getterType.$autoFlag {
            processMethodDeclTxt(
               self.stream, self.moduleCtrl, false, getterType## );
            self.writeln( "{" );
            self.pushIndent(##);
            self.writeln(
               "return lns_obj_%s(pObj)->%s;" (className, memberName) );
            self.popIndent();
            self.writeln( "}" );

            processMethodDeclTxt(
               self.stream, self.moduleCtrl, true, getterType## );
            self.writeln( "{" );
            self.pushIndent(##);
            self.writeln(
               "return lns_mtd_%s( pObj )->get_%s( _pEnv, pObj );"
               (className, memberName) );
            self.popIndent();
            self.writeln( "}" );
         }
      }
      if member.$setterMode ~= .None {
         let setterType = unwrap node.$scope.getTypeInfoField(
            "set_%s" (memberName), true, node.$scope, scopeAccess );
         if setterType.$autoFlag {
            // self.writeln(
            //    "static void mtd_%s_set_%s( lns_env_t * _pEnv, %s pObj, %s arg );"
            //    ( className, memberName, cTypeStem, getCType( member.$expType, false ) ) );
            processMethodDeclTxt(
               self.stream, self.moduleCtrl, false, setterType## );
            self.writeln( "{" );
            self.pushIndent(##);
            let valKind = self.scopeMgr.getSymbolValKind( member.$symbolInfo );
            switch valKind {
               case .Stem {
                  self.writeln(
                     'lns_setq( _pEnv, lns_obj_%s(pObj)->%s, arg1 );'
                     (className, memberName) );
               }
               case .Any {
                  self.writeln(
                     'lns_setq_any( _pEnv, &lns_obj_%s(pObj)->%s, arg1 );'
                     (className, memberName) );
               }
               case .Prim {
                  self.writeln( "lns_obj_%s(pObj)->%s = arg1;"
                     (className, memberName) );
               }
               default {
                  Util.err( "no support -- %s:%s:%d"
                     (member.$symbolInfo.$name,valKind.$_txt,__line__));
               }
            }
            self.popIndent();
            self.writeln( "}" );

            processMethodDeclTxt(
               self.stream, self.moduleCtrl, true, setterType## );
            self.writeln( "{" );
            self.pushIndent(##);
            self.writeln(
               "lns_mtd_%s( pObj )->set_%s( _pEnv, pObj, arg1 );"
               (className, memberName) );
            self.popIndent();
            self.writeln( "}" );
         }
      }
   }
}


fn processInitMethodTable(
   stream:Util.SourceStream, moduleCtrl:&ModuleCtrl, classTypeInfo:&Ast.TypeInfo )
{
   fn outputField( name:str, retTypeList:&List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "(%s *)%s," (methodType, name ) );
   }

   // let mut nameSet = new Util.OrderedSet<str>();
   // fn outputVal( scope:&Ast.Scope ) {
   //    if! let inherit = scope.$inherit {
   //       outputVal( inherit );
   //    }
   //    forsort symbolInfo in scope.$symbol2SymbolInfoMap {
   //       switch symbolInfo.$kind {
   //          case .Mtd {
   //             if symbolInfo.$name ~= "__init" {
   //                nameSet.add( symbolInfo.$name );
   //             }
   //          }
   //       }
   //    }
   // }

   let scope = unwrap classTypeInfo.$scope;
   // outputVal( scope );
   let nameSet = Ast.getAllMethodName( classTypeInfo );
   
   foreach name in nameSet.$list {
      let symbolInfo = unwrap scope.getSymbolInfoField( name, true, scope, .Normal );
      if not symbolInfo.$typeInfo.$abstractFlag {
         outputField( moduleCtrl.getMethodCName( symbolInfo.$typeInfo ),
                      symbolInfo.$typeInfo.$retTypeInfoList );
      }
      else {
         stream.writeln( "NULL," );
      }
   }
}

fn processInitIFMethodTable(
   stream:Util.SourceStream,
   moduleCtrl:&ModuleCtrl, ifType:&Ast.TypeInfo, classTypeInfo:&Ast.TypeInfo)
{
   fn outputField( name:str, retTypeList:&List<&Ast.TypeInfo> ) {
      let methodType = getMethodTypeTxt( retTypeList );
      stream.writeln( "(%s *)%s," (methodType, name ) );
   }

   fn outputVal( scope:&Ast.Scope, impScope:&Ast.Scope ) {
      if! let inherit = scope.$inherit {
         outputVal( inherit, impScope );
      }
      forsort symbolInfo in scope.$symbol2SymbolInfoMap {
         switch symbolInfo.$kind {
            case .Mtd {
               if symbolInfo.$name ~= "__init" {
                  let impMethodType = unwrap impScope.getTypeInfoField(
                     symbolInfo.$name, true, impScope, scopeAccess );
                  outputField(
                     moduleCtrl.getMethodCName( impMethodType ),
                     impMethodType.$retTypeInfoList );
               }
            }
         }
      }
   }
   outputVal( unwrap ifType.$scope, unwrap classTypeInfo.$scope );
}


fn processIFMethodDataInit(
   stream:Util.SourceStream,
   moduleCtrl:&ModuleCtrl, classType:&Ast.TypeInfo, orgClassType:&Ast.TypeInfo )
{
   let className = moduleCtrl.getClassCName( orgClassType );
   foreach ifType in classType.$interfaceList {
      let ifName = moduleCtrl.getClassCName( ifType );
      stream.writeln(
         "static lns_mtd_%s_t lns_if_%s_imp_%s = {" ( ifName, className, ifName ) );
      stream.pushIndent(##);

      processInitIFMethodTable( stream, moduleCtrl, ifType, orgClassType );

      stream.popIndent();
      stream.writeln( "};" );
   }
}

fn processClassDataInit(
   stream:Util.SourceStream, moduleCtrl:&ModuleCtrl,
   classTypeInfo:&Ast.TypeInfo, fieldList:&List<&Nodes.Node> )
{
  
   let className = moduleCtrl.getClassCName( classTypeInfo );

   // クラスメタ情報
   if not Ast.isPubToExternal( classTypeInfo.$accessMode ) {
      stream.write( "static " );
   }
   stream.writeln(
      'lns_type_meta_t lns_type_meta_%s = { "%s" };' (className, className) );

   // メソッド情報設定
   if not Ast.isPubToExternal( classTypeInfo.$accessMode ) {
      stream.write( "static " );
   }
   stream.writeln(
      "lns_mtd_%s_t lns_mtd_%s = {" ( className, className ) );
   stream.pushIndent(##);
   
   stream.writeln( "mtd_%s__del," ( className ) );

   if hasGC( classTypeInfo ) {
      stream.writeln( "mtd_%s__gc," ( className ) );
   }
   else {
      stream.writeln( "NULL," );
   }

   processInitMethodTable( stream, moduleCtrl, classTypeInfo );
   stream.popIndent();
   stream.writeln( "};" );

   fn process( out2HMode:Out2HMode, symbolInfo:&Ast.SymbolInfo ) {
      switch out2HMode {
         case .HeaderPub, .SourcePub, .SourcePri {
            stream.writeln( "%s%s %s;"
               ( getOut2HeaderPrefix( out2HMode ),
                 getCType( symbolInfo.$typeInfo ),
                 moduleCtrl.getClassMemberName( symbolInfo ) ) );
         }
      }
   }
   
   // static メンバー用変数宣言
   foreach symbolInfo in (unwrap classTypeInfo.$scope).$symbol2SymbolInfoMap {
      if symbolInfo.$kind == .Mbr and symbolInfo.$staticFlag {
         _out2Header(
            stream,
            Ast.isPubToExternal( classTypeInfo.$accessMode ) and
            Ast.isPubToExternal( symbolInfo.$accessMode ),
            `{ process( out2HMode, symbolInfo ); } );
      }
   }
   
   
}

pub override fn convFilter.processDeclMember(
   node: Nodes.DeclMemberNode, opt: Opt ) mut
{
   // dump( baseIndent, node, node.info.name.txt )
   // node.info.refType.filter( self, prefix .. "  ", depth + 1 )
};

pub override fn convFilter.processExpMacroExp(
   node: Nodes.ExpMacroExpNode, opt: Opt ) mut
{
   foreach stmt in node.$stmtList {
      filter( stmt, self, node );
      self.writeln( "" );
   }
};


form outputMacroStmtBlock();

pub fn convFilter.outputDeclMacro(
   name:str, argNameList:&List<str>, callback:outputMacroStmtBlock ) mut
{
   // self.write( "local function %s(" ( name ) );

   // // let argTxt = "";
   // // foreach arg, index in macroInfo.get_argList() {
   // //    if index > 1 {
   // //       self.write( ", " );
   // //       argTxt = argTxt .. ", ";
   // //    }
   // //    filter( arg, self, node, baseIndent );
   // //    if arg.get_kind() == Nodes.NodeKind.$DeclArg {
   // //       argTxt = argTxt .. (arg@@Nodes.DeclArgNode).$name.txt;
   // //    }
   // //    else {
   // //       error( "not support ... in macro %s" ( node.get_declInfo().$name.txt ) );
   // //    }
   // // }

   // // self.writeln( ")", baseIndent );

   // self.writeln( "__macroArgs )" );
   // self.pushIndent(##);
   // foreach argName in argNameList {
   //    self.writeln( "local %s = __macroArgs.%s" (argName, argName ) );
   // }

   // self.writeln( "local macroVar = {}" );
   // self.writeln( "macroVar.__names = {}" );

   // self.macroDepth = self.macroDepth + 1;

   // callback();

   // self.macroDepth = self.macroDepth - 1;

   // self.writeln( "" );
   // self.writeln( "return macroVar" );
   // self.popIndent();
   // self.writeln( "end" );
   // self.writeln( "return %s" ( name ) );
}

pub override fn convFilter.processDeclMacro(
   node: Nodes.DeclMacroNode, opt: Opt ) mut
{
   // if self.inMacro {
   //    let macroInfo = node.get_declInfo();
   //    let mut argNameList:List<str> = [];
   //    foreach arg in macroInfo.$argList {
   //       argNameList.insert( arg.$name.txt );
   //    }
   //    self.outputDeclMacro(
   //       macroInfo.$name.txt, argNameList,
   //       fn () {
   //          if! let stmtBlock = macroInfo.$stmtBlock {
   //             filter( stmtBlock, self, node );
   //          }
   //       });
   // }
};

pub override fn convFilter.processExpMacroStat(
   node: Nodes.ExpMacroStatNode, opt: Opt ) mut
{
   // if #node.$expStrList == 0 {
   //    self.write( "''" );
   // }
   // else {
   //    foreach token, index in node.$expStrList {
   //       if index ~= 1 {
   //          self.write( '..' );
   //       }

   //       filter( token, self, node );
   //    }
   // }
};

/**
block から変数に領域割り当て処理を行なう。

@param declFlag 変数宣言を行なう場合 true
@param var 変数シンボル
@param init0 プリミティブな変数を 0 で初期化する場合 true 
*/
pub fn convFilter.processDeclVarC( declFlag:bool, var:&Ast.LowSymbol, init0:bool ) mut
{
   if declFlag {
      let typeTxt = self.scopeMgr.getCTypeForSym( var );
      self.writeln( "%s %s;" ( typeTxt, self.moduleCtrl.getSymbolName( var ) ) );
   }

   let valKind = self.scopeMgr.getSymbolValKind( var );
   if valKind == .Prim {
      if init0 {
         self.writeln( "%s = 0;" ( self.moduleCtrl.getSymbolName( var )) );
      }
      return;
   }

   let initVal;
   if not init0 or isStemType( var.$typeInfo ) {
      if! let symbolInfo = var@@@Ast.SymbolInfo {
         switch valKind {
            case .Any {
               self.write( "lns_set_block_any" );
               self.writeln( "( %s, %d, %s );"
                             ( getBlockName( var.$scope ), getSymbolIndex( symbolInfo ),
                               self.moduleCtrl.getSymbolName( var ) ) );
            }
            case .Stem {
               self.write( "lns_set_block_stem" );
               self.writeln( "( %s, %d, %s );"
                             ( getBlockName( var.$scope ), getSymbolIndex( symbolInfo ),
                               self.moduleCtrl.getSymbolName( var ) ) );
            }
            case .Var {
               let typeTxt = getStemTypeId( var.$typeInfo );
               self.writeln( "lns_set_block_var( %s, %d, %s, %s );"
                             ( getBlockName( var.$scope ), getSymbolIndex( symbolInfo ),
                               typeTxt, self.moduleCtrl.getSymbolName( var ) ) );
            }
         }
      }
      // else {
      //    self.writeln( "%s = NULL;" ( getSymbolName( var ) ) );
      // }
   }
   else {
      initVal = getLiteral2Stem( "0", var.$typeInfo );

      if! let symbolInfo = var@@@Ast.SymbolInfo {
         switch valKind {
            case .Stem {
               self.write( "lns_initVal_stem" );
            }
            case .Any {
               self.write( "lns_initVal_any" );
            }
            case .Var {
               self.write( "lns_initVal_var" );
            }
            default {
               Util.err( "not support -- %s" (valKind.$_txt) );
            }
         }
         // self.write( "lns_initVal_var" );
         self.writeln( "( %s, %s, %d, %s );"
                       (self.moduleCtrl.getSymbolName( var ), getBlockName( var.$scope ),
                         getSymbolIndex( symbolInfo ), initVal ) );
      }
      else {
         self.writeln( "%s = %s;" ( self.moduleCtrl.getSymbolName( var ), initVal ) );
      }
   }
}

fn convFilter.process__func__symbol(
   funcTypeInfo:&Ast.TypeInfo, has__func__Symbol:bool, mut funcName:str ) mut
{
   if not has__func__Symbol {
      return;
   }
   switch self.processMode {
      case .WideScopeVer {
         let scope = unwrap funcTypeInfo.$scope;
         let symbol = unwrap scope.getSymbolInfoChild( "__func__" );
         self.writeln(
            "static %s %s = NULL;"
            (cTypeAnyPP, self.moduleCtrl.getSymbolName( symbol ) ) );
      }
      case .InitFuncSym {
         let scope = unwrap funcTypeInfo.$scope;
         let symbol = unwrap scope.getSymbolInfoChild( "__func__" );
         let symbolParam = self.scopeMgr.getSymbolParam( symbol );
         let symbolName = self.moduleCtrl.getSymbolName( symbol );
         self.writeln( "lns_set_block_any( pBlock, %d, %s );"
                       (symbolParam.index, symbolName ) );
         self.writeln( 'lns_setQ_any( %s, lns_litStr2any( _pEnv, "%s") );'
                       ( symbolName, funcName ) );
      }
   }
}

fn convFilter.processDeclMethodInfo(
   declInfo:&Nodes.DeclFuncInfo, funcTypeInfo:&Ast.TypeInfo, parent:Nodes.Node ) mut
{
   switch self.processMode {
      case .Prototype {
         fn processHeader( out2HMode:Out2HMode ) {
            if out2HMode == .HeaderPub {
               self.write( "extern " );
            }
            else {
               self.write( "static " );
            }
            if not funcTypeInfo.$staticFlag {
               // メソッドコール用ラッパー
               processMethodDeclTxt( self.stream, self.moduleCtrl, true,
                                     funcTypeInfo, declInfo.$argList );
               self.writeln( ";" );
            }
            else {
               // static メソッドの関数プロトタイプ
               processMethodDeclTxt( self.stream, self.moduleCtrl, false,
                                     funcTypeInfo, declInfo.$argList );
               self.writeln( ";" );
            }
         }

         if funcTypeInfo.$parentInfo.$kind == .Class and
            funcTypeInfo.$rawTxt == "__init"
         {
            processMethodDeclTxt( self.stream, self.moduleCtrl, false,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( ";" );
         }
         else {
            _out2Header(
               self.stream,
               Ast.isPubToExternal( funcTypeInfo.$parentInfo.$accessMode ) and
               Ast.isPubToExternal( funcTypeInfo.$accessMode ),
               `{
                  switch out2HMode {
                     case .SourcePri {
                        if funcTypeInfo.$parentInfo.$kind == .Class {
                           processMethodDeclTxt( self.stream, self.moduleCtrl, false,
                                                 funcTypeInfo, declInfo.$argList );
                           self.writeln( ";" );
                        }
                     }
                     case .SourcePub {
                        if funcTypeInfo.$parentInfo.$kind == .Class {
                           if not funcTypeInfo.$staticFlag {
                              processMethodDeclTxt( self.stream, self.moduleCtrl, false,
                                                    funcTypeInfo, declInfo.$argList );
                              self.writeln( ";" );
                           }
                        }
                     }
                     case .HeaderPub {
                        processHeader( out2HMode );
                     }
                  }
               });
         }
      }
      case .Form {
         let className = self.moduleCtrl.getClassCName( unwrap declInfo.$classTypeInfo );
         if! let body = declInfo.$body {
            let methodNodeToken = unwrap declInfo.get_name();
            processMethodDeclTxt( self.stream, self.moduleCtrl, false,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( "{" );

            self.pushIndent(##);

            // self.process__func__symbol(
            //    funcTypeInfo, declInfo.$has__func__Symbol,
            //    self.moduleCtrl.getMethodCName( funcTypeInfo ) );
            
            if not funcTypeInfo.$staticFlag {
               self.writeln( "%s self = pObj;" (cTypeAnyP) );
            }

            self.pushRoutine( funcTypeInfo, body );

            // self.processBlockPreProcess( body );
            filter( body, self, parent );
            // self.processBlockPostProcess();

            self.popRoutine();

            self.popIndent();
            self.writeln( "}" );
         }
         if funcTypeInfo.$rawTxt ~= "__init" and not funcTypeInfo.$staticFlag {
            processMethodDeclTxt( self.stream, self.moduleCtrl, true,
                                  funcTypeInfo, declInfo.$argList );
            self.writeln( "{" );

            if #funcTypeInfo.$retTypeInfoList ~= 0 {
               self.write( "return " );
            }

            self.write( "lns_mtd_%s( pObj )->%s( _pEnv, "
                        ( className, funcTypeInfo.$rawTxt ) );
            if declInfo.$classTypeInfo$.$kind == .IF {
               self.write( "lns_getImpObj( pObj ) " );
            }
            else {
               self.write( "pObj " );
            }
            foreach argNode in declInfo.$argList {
               if! let declArgNode = argNode@@@Nodes.DeclArgNode {
                  self.write( ", %s" ( declArgNode.$name.txt ) );
               }
            }
            self.writeln( ");" );
            
            self.writeln( "}" );
         }
      }
      case .InitFuncSym, .WideScopeVer {
         self.process__func__symbol(
            funcTypeInfo, declInfo.$has__func__Symbol,
            self.moduleCtrl.getMethodCName( funcTypeInfo ) );
      }
   }
}


pub override fn convFilter.processDeclConstr(
   node: Nodes.DeclConstrNode, opt: Opt ) mut
{
   self.processDeclMethodInfo( node.$declInfo, node.$expType, node );
};

pub override fn convFilter.processDeclDestr(
   node: Nodes.DeclDestrNode, opt: Opt ) mut
{
   // self.writeln( "function %s.__free( self )"
   //    ( node.$declInfo.$classTypeInfo$.getTxt$(##) ) );

   // self.process__func__symbol(
   //    node.$declInfo.$has__func__Symbol, node.$expType.$parentInfo, "__free" );

   // filter( unwrap node.$declInfo.$body, self, node );

   // let classTypeInfo = node.$expType.$parentInfo;
   // if! self.getDestrClass( classTypeInfo.$baseTypeInfo ) {
   //    self.writeln( "%s.__free( self )" (_exp.getTxt(##) ) );
   // }

   // self.writeln( "end" );
}


pub override fn convFilter.processExpCallSuper(
   node: Nodes.ExpCallSuperNode, opt: Opt ) mut
{
   // let typeInfo:Ast.TypeInfo = node.$superType;
   // if node.$methodType.$rawTxt == "__init" {
   //    self.write( "%s.%s( self"
   //                ( self.getFullName( typeInfo ), node.$methodType.$rawTxt ) );
   // }
   // else {
   //    self.write( "%s.%s( self"
   //                ( self.getFullName( typeInfo ), node.$methodType.$rawTxt ) );
   // }

   // if! node.$expList {
   //    self.write( "," );
   //    filter( _exp, self, node );
   // }
   // self.writeln( ")" );
};

pub override fn convFilter.processDeclMethod(
   node: Nodes.DeclMethodNode, opt: Opt ) mut
{
   self.processDeclMethodInfo( node.$declInfo, node.$expType, node );
};


pub override fn convFilter.processUnwrapSet(
   node: Nodes.UnwrapSetNode, opt: Opt ) mut
{
   // let dstExpList = node.$dstExpList;
   // filter( dstExpList, self, node );
   // self.write( " = " );
   // filter( node.$srcExpList, self, node );
   // self.writeln( "" );

   // self.write( "if " );
   // foreach expNode, index in dstExpList.$expList {
   //    if index > 1 {
   //       self.write( " or " );
   //    }
   //    self.write( "nil == " );
   //    filter( expNode, self, node );
   // }
   // self.writeln( " then" );
   // self.pushIndent(##);

   // foreach expNode, index in dstExpList.$expList {
   //    self.write( "local _exp%d = " (index));
   //    filter( expNode, self, node );
   //    self.writeln( "" );
   // }

   // if node.$unwrapBlock {
   //    filter( unwrap node.$unwrapBlock, self, node );
   // }
   // self.popIndent();
   // self.writeln( "end" );
}


fn convFilter.accessPrimValFromAny(
   dddFlag:bool, typeInfo:&Ast.TypeInfo, index:int ) mut
{
   self.write( getAccessPrimValFromStem( dddFlag, typeInfo, index ) );
}

fn convFilter.isStemSym( symbolInfo:&Ast.LowSymbol ) mut : bool {
   return self.scopeMgr.getSymbolValKind( symbolInfo ) ~= .Prim;
}

fn convFilter.getValKindOfNode( node:&Nodes.Node ) mut: ValKind {
   if #node.$expTypeList > 1 {
      return .Stem;
   }

   let symbolList = node.getSymbolInfo();
   if #symbolList > 0 {
      return self.scopeMgr.getSymbolValKind( symbolList[ 1 ] );
   }
   return getValKind( node.$expType );
}


fn convFilter.isStemVal( node:&Nodes.Node ) mut : bool {
   if #node.$expTypeList > 1 {
      return false;
   }

   let symbolList = node.getSymbolInfo();
   if #symbolList > 0 {
      // val は評価のタイミングで any にしているので、 prim 以外は any。
      return self.scopeMgr.getSymbolValKind( symbolList[ 1 ] ) ~= .Prim;
   }
   return isStemType( node.$expType );
}

/**
exp の値にアクセスするためのコードを出力する。
*/
pub fn convFilter.accessPrimVal( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   // if exp@@@Nodes.LiteralIntNode or exp@@@Nodes.LiteralCharNode
   //    or exp@@@Nodes.LiteralRealNode
   switch self.getValKindOfNode( exp ) {
      case .Prim {
         filter( exp, self, parent );
      }
      case .Stem {
         filter( exp, self, parent );
         self.accessPrimValFromAny( #exp.$expTypeList > 1, exp.$expType, 0 );
         // let expType = exp.$expType.$srcTypeInfo;
         // switch expType {
         //    case Ast.builtinTypeInt, Ast.builtinTypeChar {
         //       self.write( ".val.intVal" );
         //    }
         //    case Ast.builtinTypeReal {
         //       self.write( ".val.realVal" );
         //    }
         //    case Ast.builtinTypeBool {
         //       self.write( ".val.boolVal" );
         //    }
         //    default {
         //       self.write( ".val.pAny" );
         //    }
         // }
      }
      case .Any {
         filter( exp, self, parent );
      }
   }

   
   // }
   // else {
   //    filter( exp, self, parent );
   //    self.accessPrimValFromAny( #exp.$expTypeList > 1, exp.$expType, 0 );
   //    // if #exp.$expTypeList > 1 {
   //    //    self.write( "->val.ddd.pAnyList[ 0 ]" );
   //    // }

   //    // let expType = exp.$expType.$srcTypeInfo;
   //    // switch expType {
   //    //    case Ast.builtinTypeInt, Ast.builtinTypeChar {
   //    //       self.write( "->val.intVal" );
   //    //    }
   //    //    case Ast.builtinTypeReal {
   //    //       self.write( "->val.realVal" );
   //    //    }
   //    //    case Ast.builtinTypeBool {
   //    //       self.write( "->val.boolVal" );
   //    //    }
   //    // }
   // }
}


/**
symbol が示す値を any 型に変換する処理を出力する

@param symbol シンボル
*/
pub fn convFilter.processSym2Any( symbol:&Ast.LowSymbol ) mut
{
   let valKind = self.scopeMgr.getSymbolValKind( symbol );
   switch valKind {
      case .Stem {
         self.write( self.moduleCtrl.getSymbolName( symbol ) );
         self.write( accessAny );
      }
      case .Any {
         self.write( self.moduleCtrl.getSymbolName( symbol ) );
      }
      default {
         Util.err( "not suppport -- %s, %d" (valKind.$_txt, __line__ ) );
      }
   }
}



/**
node が示す値を stem 型に変換する処理を出力する

@param node Node
@param parent このノードの親
*/
pub fn convFilter.processVal2stem( node:&Nodes.Node, parent: &Nodes.Node ) mut
{
   let valKind = self.getValKindOfNode( node );

   switch valKind {
      case .Stem {
         filter( node, self, parent );
      }
      default {
         let mut expType = node.$expType.$srcTypeInfo;
         if! let enumType = expType@@@Ast.EnumTypeInfo {
            expType = enumType.$valTypeInfo;
         }
         
         switch expType {
            // case Ast.builtinTypeBool {
            //    self.write( "lns_bool2stem( _pEnv, " );
            //    filter( node, self, parent );
            //    self.write( ")" );
            // }
            case Ast.builtinTypeInt, Ast.builtinTypeChar {
               self.write( "LNS_STEM_INT( " );
               filter( node, self, parent );
               self.write( ")" );
            }
            case Ast.builtinTypeReal {
               self.write( "LNS_STEM_REAL( " );
               filter( node, self, parent );
               self.write( ")" );
            }
            case Ast.builtinTypeBool {
               self.write( "LNS_STEM_BOOL( " );
               filter( node, self, parent );
               self.write( ")" );
            }
            default {
               switch expType.$kind {
                  case .DDD {
                     self.write( "_pDDD" );
                  }
                  case .Func {    
                     if! let scope = expType.$scope {
                        // let argList = expType.$argTypeInfoList;
                        // let hasDDD =
                        //    #argList > 0 and argList[ #argList ].$kind == .DDD or false;
                        
                        // // self.write( "lns_func2any( _pEnv, (lns_closure_t *)" );
                        // // self.write( getFuncName( expType ) );
                        // // self.write( ", %d, %s, %d"
                        // //             ( #node.$expType.$argTypeInfoList, hasDDD,
                        // //               #scope$.$closureSymList) );     
                        
                        // // foreach symbolInfo in scope.$closureSymList {
                        // //    self.write( ", %s" (symbolInfo.$name) );
                        // // }
                        // // self.write( ")" );

                        // self.processPrepareClosure(
                        //    getFuncName( expType ), #node.$expType.$argTypeInfoList,
                        //    hasDDD, scope$.$closureSymList );
                        self.write( "LNS_STEM_ANY(" );
                        self.write( self.getFunc2any( expType ) );
                        self.write( ")" );
                     }
                     else {   
                        Util.err( "illegal func" );
                     }
                  }
                  default {
                     if valKind == .Var and getValKind( expType ) == .Stem {
                        filter( node, self, parent );
                     }
                     else {
                        self.write( "LNS_STEM_ANY( " );
                        filter( node, self, parent );
                        self.write( ")" );
                     }
                  }
               }
            }
         }
      }
   }
   // filter( node, self, parent );
}

pub fn convFilter.processVal2any( node:&Nodes.Node, parent: &Nodes.Node ) mut
{
   let valKind = self.getValKindOfNode( node );
   switch valKind {
      case .Stem {
         filter( node, self, parent );
         self.write( accessAny );
      }
      case .Any {
         filter( node, self, parent );
      }
      case .Var {
         filter( node, self, parent );
         // self.write( "->stem" );
         // self.write( accessAny );
      }
      default {
         Util.err( "not suppport -- %d, %s, %s, %d"
                   ( node.$pos.lineNo, valKind.$_txt,
                     Nodes.getNodeKindName( node.$kind ), __line__ ) );
      }
   }
}

/**
シンボル var に値を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param var 代入先のシンボル
@param initFlag 変数に対する初期値設定の場合 true
@param isStemExp 値が any 型かどうか
@param index exp が ... の場合の index
@param firstMRet index が多値要素の最初のインデックスの場合 true
@param processVal 代入する値にアクセスするコードを出力するコールバック
*/
fn convFilter.processSetValSingleDirect(
   parent:&Nodes.Node, node:&Nodes.Node!, var:&Ast.LowSymbol,
   initFlag:bool, expValKind:ValKind, index:int, firstMRet:bool, processVal:form ) mut
{
   let valKind = self.scopeMgr.getSymbolValKind( var );

   let mut varName = self.moduleCtrl.getSymbolName( var );
   if valKind == .Any and var.$kind == .Var {
      varName = "(*%s)" (varName);
   }
   
   let mut processPrefix:form! = nil;
   if! let fieldNode = node@@@Nodes.RefFieldNode {
      if fieldNode.$symbolInfo$.$staticFlag {
         varName = self.moduleCtrl.getClassMemberName( unwrap fieldNode.$symbolInfo );
      }
      else {
         processPrefix = fn () {
            let prefixNode = fieldNode.$prefix;
            let className = self.moduleCtrl.getClassCName( prefixNode.$expType );
            self.write( "lns_obj_%s( " (className) );
            self.processVal2any( prefixNode, fieldNode );
            //filter( prefixNode, self, fieldNode );
            //self.write( accessAny );
            self.write( ")->" );
         };
      }
   }

   if var.$symbolId == invalidSymbolId {
      if valKind == expValKind {
         self.write( "%s = " (varName) );
         processVal();
         self.write( ";" );
         return;
      }
      Util.err( "illegal %s %s %s -- %d"
                (var.$name, valKind.$_txt, expValKind.$_txt, __line__) );
   }
   

   
   switch valKind {
      case .Var {
         switch expValKind {
            case .Stem {
               if initFlag {
                  self.write( "lns_setQ( %s->stem, " ( varName ) );
               }
               else {
                  self.write( "lns_setq( _pEnv, %s->stem, " ( varName ) );
               }
               processVal();
               self.writeln( " );" );
            }
            case .Any {
               if initFlag {
                  self.write( "lns_setQ_any( &%s->stem.val.pAny, " ( varName ) );
               }
               else {
                  self.write( "lns_setq_any( _pEnv, &%s->stem.val.pAny, " ( varName ) );
               }
               when! processPrefix {
                  processPrefix();
               }
               processVal();
               self.write( " );" );
            }
            case .Prim {
               self.write( "%s->stem" (varName) );
               self.write( getAccessValFromStem( var.$typeInfo) );
               self.write( " = " );
               processVal();
               self.write( ";" );
            }
         }
      }
      case .Stem {
         switch expValKind {
            case .Stem, .Any { 
               if initFlag {
                  self.write( "lns_setQ( " );
               }
               else {
                  self.write( "lns_setq( _pEnv, " );
               }
               when! processPrefix {
                  processPrefix();
               }
               self.write( "%s, " ( varName ) );
               processVal();
               self.write( " );" );
            }
            // case .Any {
            //    if initFlag {
            //       self.write( "lns_setQ_any( &%s->val.pAny, " ( varName ) );
            //    }
            //    else {
            //       self.write( "lns_setq_any( _pEnv, &%s->val.pAny, " ( varName ) );
            //    }
            //    when! processPrefix {
            //       processPrefix();
            //    }
            //    self.write( "%s, " ( varName ) );
            //    processVal();
            //    self.write( " );" );
            // }
            case .Prim {
               when! processPrefix {
                  processPrefix();
               }
               self.write( self.scopeMgr.getAccessPrimValFromSymbol( var ) );
               self.write( " = " );
               processVal();
               self.write( ";" );
            }
         }
      }
      case .Any {
         if initFlag {
            self.write( "lns_setQ_any( &" );
         }
         else {
            self.write( "lns_setq_any( _pEnv, &" );
         }
         when! processPrefix {
            processPrefix();
         }
         self.write( "%s, " ( varName ) );
         processVal();
         self.write( " );" );
      }
      default {
         when! processPrefix {
            processPrefix();
         }
         self.write( "%s = " (varName ) );
         processVal();
         self.write( ";" );
      }
   }
}



/**
symbolInfo の値を変数にセットする処理を出力する。

@param parent 親ノード
@param dstKind 変数の種別
@param dstTypeInfo 変数の型
@param symbol 代入元のシンボル
*/
fn convFilter.processSymForSetOp(
   parent:&Nodes.Node, dstKind:ValKind,
   dstTypeInfo:&Ast.TypeInfo, symbol:&Ast.LowSymbol ) mut
{
   let srcKind = self.scopeMgr.getSymbolValKind( symbol );
   let isStemExp = srcKind ~= .Prim;

   if dstKind ~= srcKind {
      switch dstKind {
         case .Prim {
            // 値が any で、変数が Prim 型の場合
            self.write( self.scopeMgr.getAccessPrimValFromSymbol( symbol ) );
            return;
         }
         case .Stem {
            self.processSym2stem( symbol );
            return;
         }
         case .Var {
            self.processSym2stem( symbol );
            // self.processSym2stem( symbol );
            return;
         }
         case .Any {
            self.processSym2Any( symbol );
            return;
         }
         default {
            Util.err( "not support -- %s" (dstKind.$_txt) );
         }
      }
   }
   self.write( self.moduleCtrl.getSymbolName( symbol ) );
}


/**
インタフェース型の可能性のある値を、インタフェース型に変換する。

次の関数の様に、戻り値が Generics の型パラメータの場合、

fn func<T>() : T; 

その関数の戻り値が、インタフェースではなくクラスのオブジェクトを返すことがある。
そのような場合に、クラスのオブジェクトから所定のインタフェースの
オブジェクトを返すように lns_toIF() 処理を追加する。

ただし、通常は、
*/
fn processToIF( stream:Util.SourceStream,
                moduleCtrl:ModuleCtrl, expType:&Ast.TypeInfo, process:form )
{
   if expType.$kind == .IF {
      stream.write( "lns_toIF( _pEnv, " );
      process();
      // stream.write( accessAny );
      stream.write( ", &lns_type_meta_%s )" (moduleCtrl.getClassCName( expType )) );
      stream.write( accessAny );
   }
   else {
      process();
   }
}



fn processGetMRet( stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
                   typeInfo:&Ast.TypeInfo, index:int )
{
   fn process() {
      stream.write( "lns_getMRet( _pEnv, %d )" (index) );
      stream.write( getAccessValFromStem( typeInfo ) );
   }
   if typeInfo.$kind == .IF {
      processToIF( stream, moduleCtrl, typeInfo, process );
   }
   else {
      process();
   }
}


/**
Node の値を変数にセットする処理を出力する。

@param parent 親ノード
@param dstKind 変数の種別
@param dstTypeInfo 変数の型
@param exp 値のノード
@param index exp が多値だった場合の何番目の値にアクセスするか
@param firstMRet exp が多値の先頭アクセスの場合
*/
fn convFilter.processValForSetOp(
   parent:&Nodes.Node, dstKind:ValKind, dstTypeInfo:&Ast.TypeInfo,
   exp:&Nodes.Node, index:int, firstMRet:bool ) mut
{
   let valKind = self.getValKindOfNode( exp );

   fn accessVal() {
      if firstMRet {
         processGetMRet( self.stream, self.moduleCtrl, exp.$expType, 0 );
      }
      else {
         if exp.$expType.$kind == .Func {
            self.write( self.getFunc2any( exp.$expType ) );
         }
         else {
            filter( exp, self, parent );
         }
      }
   }

   fn processVal() {
      // シンボルに代入する値にアクセスするコード出力
      let mut setValTxt = "";
      if firstMRet {
         accessVal();
      }
      elseif not firstMRet and Nodes.hasMultiValNode( exp ) {
         self.write( "lns_fromDDD( " );
         accessVal();
         self.write( accessAny );
         self.write( ", %d )" (index) );
         self.write( getAccessValFromStem( exp.$expType ) );
      }
      else {
         if dstKind == .Stem {
            self.processVal2stem( exp, parent );
         }
         elseif dstKind == .Var and valKind ~= .Stem {
            //self.processVal2stem( exp, parent );
            accessVal();
         }
         else {
            accessVal();
         }
      }
   }
   if dstKind == .Prim and valKind == .Stem {
      // 値が any で、変数が Prim 型の場合
      let expSymList = exp.getSymbolInfo();
      if #expSymList > 0 {
         self.write( self.scopeMgr.getAccessPrimValFromSymbol( expSymList[ 1 ] ) );
      }
      else {
         processVal();
         //self.write( getAccessPrimValFromStem( false, dstTypeInfo, 0 ) );
      }
   }
   else {
      processVal();
   }
}


fn processAlterAccessVal(
   stream:Util.SourceStream,
   srcTypeList:&List<&Ast.TypeInfo>, dstTypeList:&List<&Ast.TypeInfo> )
{
   if #dstTypeList == 1 {
      if srcTypeList[1].$kind == .Alternate {
         stream.write( getAccessValFromStem( dstTypeList[ 1 ] ) );
      }
   }
}

/**
AlternateTypeInfo から、実際の型に変換する処理を行なう

@param stream 出力先
@param moduleCtrl モジュール制御
@param classType この AlternateTypeInfo が続するクラス。
       クラスが存在しない場合は nil。
@param expType 変換元の値の型
@param process 値を出力するコールバック
*/
fn processAlterToActualType(
   stream:Util.SourceStream, moduleCtrl:ModuleCtrl,
   fromType:&Ast.TypeInfo, toType:&Ast.TypeInfo, process:form )
{
   if fromType.$kind == .Alternate {
      if toType.$kind == .IF {
         processToIF( stream, moduleCtrl, toType, process );
      }
      else {
         process();
      }
   }
   else {
      process();
   }
}


/**
シンボル var に exp の式の結果を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param var シンボル
@param exp 代入する値の式
@param index exp が ... の場合の index
*/
fn convFilter.processSetValSingle(
   parent:&Nodes.Node, node:&Nodes.Node!, var:&Ast.LowSymbol,
   initFlag:bool, exp:&Nodes.Node, index:int, firstMRet:bool ) mut
{
   let expValKind;
   if firstMRet {
      expValKind = getValKind( exp.$expType );
   }
   else {
      expValKind = self.getValKindOfNode( exp );
   }
   
   self.processSetValSingleDirect(
      parent, node, var, initFlag, expValKind, index, firstMRet,
      fn () {
         self.processValForSetOp(
            parent, self.scopeMgr.getSymbolValKind( var ),
            var.$typeInfo, exp, index, firstMRet );
      } );
}

/**
シンボル var に symbol の値を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param var 代入先シンボル
@param symbol 代入元シンボル
*/
fn convFilter.processSetSymSingle(
   parent:&Nodes.Node, node:&Nodes.Node!, var:&Ast.LowSymbol,
   initFlag:bool, symbol:&Ast.LowSymbol, toIF:bool ) mut
{
   fn process() {
      self.processSymForSetOp(
         parent, self.scopeMgr.getSymbolValKind( var ), var.$typeInfo, symbol );
   }
   
   self.processSetValSingleDirect(
      parent, node, var, initFlag, self.scopeMgr.getSymbolValKind( symbol ), 1, false,
      fn () {
         if toIF {
            processToIF( self.stream, self.moduleCtrl, symbol.$typeInfo, process );
         }
         else {
            process();
         }
      } );
}



/**
シンボル var に exp の式の結果を代入する。

@param node var シンボルを示す node。
   var シンボルが単なるシンボルの場合 nil で問題なし。
   var シンボルがメンバの時に指定する。
@param exp 代入する値の式
@param index exp が ... の場合の index
*/
fn convFilter.processSetValSingleNode(
   parent:&Nodes.Node, var:&Nodes.Node, initFlag:bool,
   exp:&Nodes.Node, index:int, firstMRet:bool ) mut
{
   let symbolList = var.getSymbolInfo();
   if #symbolList > 0 {
      self.processSetValSingle(
         parent, var, symbolList[ 1 ], initFlag, exp, index, firstMRet );
      return;
   }

   switch var.$kind {
      case Nodes.NodeKind.$ExpRefItem {
         if! let refItemNode = var@@@Nodes.ExpRefItemNode {
            let dstType = refItemNode.$val.$expType;
            if dstType.$kind == .Map {
               self.write( "lns_mtd_Map_add( _pEnv, " );
               self.processVal2any( refItemNode.$val, var );
               self.write( ", " );
               if! let indexNode = refItemNode.$index {
                  self.processVal2stem( indexNode, var );
               }
               self.write( ", " );
               self.processValForSetOp(
                  parent, .Stem, dstType.$itemTypeInfoList[ 2 ],
                  exp, index, firstMRet );
               self.write( ")" );
            }
         }
      }
      default {
         Util.err( "not support -- %s" (Nodes.getNodeKindName( var.$kind ) ) );
      }
   }
}

/** 代入先情報 */
alge DstInfo {
   Symbol( &Ast.LowSymbol, node:&Nodes.Node! ),
   Node( node:&Nodes.Node ),
}



/**
値をシンボルに代入する処理。

val1, val2, val3 = exp1, exp2, exp3

@param parent この代入処理の親 Node
@param varSymList 代入先のシンボルリスト。
@param expList 代入する値の Node リスト
@param varNode 代入先のシンボルリスト。 代入先が単なるシンボルの場合は不要。
    self.val = 1 のようにメンバに代入する場合に指定する。
@param mRetExp expList の MRetExp 情報。
*/
fn convFilter.processSetValToDst(
   parent: &Nodes.Node, dstList:&List<&DstInfo>, initFlag:bool,
   expList:&List<&Nodes.Node>, mRetExp:&Nodes.MRetExp! ) mut
{
   let mut mRetIndex:int! = mRetExp$.$index;
   // 代入する値分のループを廻して、値を代入する処理を出力
   foreach exp, index in expList {
      let is1stMRet = index == mRetIndex;
      if is1stMRet {
         when! mRetExp {
            self.write( "lns_setMRet( _pEnv, " );
            filter( mRetExp.$exp, self, parent );
            self.write( accessAny );
            self.writeln( ");" );
         }
      }

      if index > #dstList {
         return;
      }

      
      if index == #expList {
         // 代入する最終要素の場合、最終要素の多値処理を行なう
         for dstIndex = index, #dstList {
            let accessIndex;
            when! mRetIndex {
               accessIndex = index - mRetIndex;
            }
            else {
               accessIndex = 0;
            }
            match dstList[ dstIndex ] {
               case .Symbol( symbolInfo, dstNode ) {
                  self.processSetValSingle(
                     parent, dstNode, symbolInfo,
                     initFlag, exp, accessIndex, is1stMRet and dstIndex == index );
               }
               case .Node( dstNode ) {
                  self.processSetValSingleNode(
                     parent, dstNode, initFlag, exp, accessIndex,
                     is1stMRet and dstIndex == index );         
               }
            }
            self.writeln( "" );
         }
      }
      else {
         let accessIndex;
         when! mRetIndex {
            accessIndex = index - mRetIndex;
         }
         else {
            accessIndex = 0;
         }
         match dstList[ index ] {
            case .Symbol( symbolInfo, dstNode ) {
               self.processSetValSingle(
                  parent, dstNode, symbolInfo,
                  initFlag, exp, accessIndex, is1stMRet );
            }
            case .Node( dstNode ) {
               self.processSetValSingleNode(
                  parent, dstNode, initFlag, exp, accessIndex, is1stMRet );         
            }
         }
         self.writeln( "" );
      }
   }
  
}


/**
値をシンボルに代入する処理。

val1, val2, val3 = exp1, exp2, exp3

@param parent この代入処理の親 Node
@param varSymList 代入先のシンボルリスト。
@param expList 代入する値の Node リスト
@param varNode 代入先のシンボルリスト。 代入先が単なるシンボルの場合は不要。
    self.val = 1 のようにメンバに代入する場合に指定する。
@param mRetExp expList の MRetExp 情報。
*/
fn convFilter.processSetValToSym(
   parent: &Nodes.Node, varSymList:&List<&Ast.LowSymbol>, initFlag:bool,
   expList:&List<&Nodes.Node>, varNode:&Nodes.Node!, mRetExp:&Nodes.MRetExp! ) mut
{
   let varNodeList:List<&Nodes.Node>;
   if! let expListNode = varNode@@@Nodes.ExpListNode {
      varNodeList = expListNode.$expList;
   }
   else {
      when! varNode {
         varNodeList = [ varNode ];
      }
      else {
         varNodeList = [];
      }
   }

   let mut dstList:List<&DstInfo> = [];
   foreach symbol, index in varSymList {
      let node:&Nodes.Node!;
      if index <= #varNodeList {
         node = varNodeList[ index ];
      }
      else {
         node = nil;
      }
      dstList.insert( DstInfo.Symbol( symbol, node ) );
   }
   self.processSetValToDst( parent, dstList, initFlag, expList, mRetExp);


   // let mut mRetIndex:int! = mRetExp$.$index;
   // // 代入する値分のループを廻して、値を代入する処理を出力
   // foreach exp, index in expList {
   //    let is1stMRet = index == mRetIndex;
   //    if is1stMRet {
   //       when! mRetExp {
   //          self.write( "lns_setMRet( _pEnv, " );
   //          filter( mRetExp.$exp, self, parent );
   //          self.write( accessAny );
   //          self.writeln( ");" );
   //       }
   //    }

   //    if index > #varSymList {
   //       return;
   //    }
   //    if index == #expList {
   //       // 代入する最終要素の場合、最終要素の多値処理を行なう
   //       for varIndex = index, #varSymList {
   //          let mut workNode:&Nodes.Node! = nil;
   //          if #varNodeList >= varIndex {
   //             workNode = varNodeList[ varIndex ];
   //          }
   //          self.processSetValSingle( parent, workNode, varSymList[ varIndex ],
   //                                    initFlag, exp, varIndex - index, is1stMRet );
   //          self.writeln( "" );
   //       }
   //    }
   //    else {
   //       let mut workNode:&Nodes.Node! = nil;
   //       if #varNodeList >= index {
   //          workNode = varNodeList[ index ];
   //       }
   //       self.processSetValSingle( parent, workNode, varSymList[ index ],
   //                                 initFlag, exp, 0, is1stMRet );
   //       self.writeln( "" );
   //    }
   // }
      
}


/**
値を Node に代入する処理。

val1, val2, val3 = exp1, exp2, exp3

@param parent この代入処理の親 Node
@param dstNode 代入先の Node
@param expList 代入する値の Node リスト
@param mRetExp expList の MRetExp 情報。
*/
fn convFilter.processSetValToNode(
   parent: &Nodes.Node, dstNode:&Nodes.Node,
   expList:&List<&Nodes.Node>, mRetExp:&Nodes.MRetExp! ) mut
{
   let mut dstList:List<&DstInfo> = [];
   if! let expListNode = dstNode@@@Nodes.ExpListNode {
      foreach node in expListNode.$expList {
         dstList.insert( DstInfo.Node( node ) );
      }
   }
   else {
      dstList.insert( DstInfo.Node( dstNode ) );
   }
   
   self.processSetValToDst( parent, dstList, false, expList, mRetExp);

   
   // let dstNodeList:List<&Nodes.Node>;
   // if! let expListNode = dstNode@@@Nodes.ExpListNode {
   //    dstNodeList = expListNode.$expList;
   // }
   // else {
   //    dstNodeList = [ dstNode ];
   // }

   // let mut mRetIndex:int! = mRetExp$.$index;
   // // 代入する値分のループを廻して、値を代入する処理を出力
   // foreach exp, index in expList {
   //    let is1stMRet = index == mRetIndex;
   //    if is1stMRet {
   //       when! mRetExp {
   //          self.write( "lns_setMRet( _pEnv, " );
   //          filter( mRetExp.$exp, self, parent );
   //          self.write( accessAny );
   //          self.writeln( ");" );
   //       }
   //    }

   //    if index > #dstNodeList {
   //       return;
   //    }
   //    if index == #expList {
   //       // 代入する最終要素の場合、最終要素の多値処理を行なう
   //       for varIndex = index, #dstNodeList {
   //          let mut workNode = dstNodeList[ varIndex ];
   //          self.processSetValSingleNode(
   //             parent, workNode, exp, varIndex - index,
   //             is1stMRet and varIndex == index );
   //       }
   //    }
   //    else {
   //       let accessIndex;
   //       when! mRetIndex {
   //          accessIndex = index - mRetIndex;
   //       }
   //       else {
   //          accessIndex = 0;
   //       }
   //       self.processSetValSingleNode(
   //          parent, dstNodeList[ index ], exp, accessIndex, is1stMRet );
   //    }
   // }



   
}






fn convFilter.processDeclVarAndSet(
   varSymList:&List<&Ast.LowSymbol>, expListNode:&Nodes.ExpListNode! ) mut
{
   foreach var, index in varSymList  {
      let typeTxt, valKind = self.scopeMgr.getCTypeForSym( var );
      if valKind ~= .Prim {
         let declVarFlag;
         if varSymList[ 1 ].$scope ~= self.ast.$moduleScope {
            declVarFlag = true;
         }
         else {
            declVarFlag = false;
         }
         self.processDeclVarC( declVarFlag, var, valKind ~= .Var );
      }
      else {
         if varSymList[ 1 ].$scope ~= self.ast.$moduleScope {
            self.writeln( "%s %s;" ( typeTxt, self.moduleCtrl.getSymbolName( var ) ) );
         }
      }
   }
   // 初期値代入
   when! expListNode {
      self.processSetValToSym( expListNode, varSymList, true,
                               expListNode.$expList, nil, expListNode.$mRetExp );
   }
}


pub override fn convFilter.processIfUnwrap(
   node: Nodes.IfUnwrapNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);

   let expListNode = node.$expList;
   // 一旦 work 変数に代入する
   let mut workSymList:List<&WorkSymbol> = [];
   foreach varSym, index in node.$varSymList {
      let workSymbol = new WorkSymbol(
         varSym.$scope, varSym.$accessMode, "_%s" (varSym.$name), 
         varSym.$typeInfo.$nilableTypeInfo, varSym.$kind,
         new SymbolParam( .Stem, 0, cTypeStem ) );
      workSymList.insert( workSymbol );
   }
   self.processDeclVarAndSet( workSymList, expListNode );

   // work が nil でないことを確認する
   self.write( "if ( " );
   foreach workSym, index in workSymList {
      self.write( "%s.type != lns_stem_type_nil"
                  (self.moduleCtrl.getSymbolName( workSym )) );
      if index ~= #workSymList {
         self.write( " && " );
      }
   }
   self.writeln( ") {" );

   // nil でなければ、 work から変数にセットする
   self.processBlockPreProcess( node.$block.$scope );
   
   //self.processDeclVarAndSet( node.$varSymList, nil );


   foreach varSym, index in node.$varSymList {
      self.processDeclVarC( true, varSym, false );
      self.processSetSymSingle( node, nil, varSym, true, workSymList[ index ], false );
      self.writeln( "" );
   }
   // self.processSetValToSym( node, node.$varSymList, true,
   //                          expListNode.$expList, nil, expListNode.$mRetExp );

   // ブロックの実行
   filter( node.$block, self, node );

   self.processBlockPostProcess();
   self.writeln( "}" );
   
   if! node.$nilBlock {
      self.writeln( "else {" );
      filter( _exp, self, node );
      self.writeln( "}" );
   }
   
   
   self.popIndent();
   self.writeln( "}" );
}






pub override fn convFilter.processDeclVar(
   node: Nodes.DeclVarNode, opt: Opt ) mut
{
   switch self.processMode {
      case .WideScopeVer {
         let varSymList = node.$symbolInfoList;
         foreach var, index in varSymList  {
            let typeTxt = self.scopeMgr.getCTypeForSym( var );
            switch var.$accessMode {
               case .Pub, .Global {
               }
               default {
                  self.write( "static " );
               }
            }
            self.writeln( "%s %s;" ( typeTxt, self.moduleCtrl.getSymbolName( var ) ) );
         }
         return;
      }
      case .InitModule, .Form {
      }
      default {
         return;
      }
   }
   
   if node.$syncBlock {
      self.writeln( "{" );
      self.pushIndent(##);
      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s" (varInfo.$name.txt) );
      }
      self.writeln( "{" );
      self.pushIndent(##);
   }

   let varSymList = node.$symbolInfoList;

   if node.$unwrapFlag {
      let mut workSymList:List<&Ast.LowSymbol> = [];
      foreach varSym in varSymList {
         workSymList.insert( new WorkSymbol(
            varSym.$scope, varSym.$accessMode, "_" .. varSym.$name,
            varSym.$typeInfo.$nilableTypeInfo, .Var,
            new SymbolParam( .Stem, invalidSymbolId, cTypeStem ) ) );
         self.processDeclVarC( true, varSym, false );
      }
      self.processDeclVarAndSet( workSymList, node.$expList );

      if! let unwrapBlock = node.$unwrapBlock {
         self.writeln( "" );
         self.write( "if ( " );
         let mut firstFlag = true;
         foreach var in workSymList {
            if var.$typeInfo.$nilable {
               if firstFlag {
                  firstFlag = false;
               }
               else {
                  self.write( " || " );
               }
               self.write( "lns_stem_type_nil == %s.type"
                  ( self.moduleCtrl.getSymbolName( var ) ) );
            }
         }
         self.writeln( " ) {" );

         filter( unwrapBlock, self, node );

         self.writeln( "}" );
         self.writeln( "else {" );
         
         self.pushIndent(##);

         foreach var, index in varSymList  {
            self.processSetSymSingle(
               node, nil, var, true, workSymList[ index ], false );
            self.writeln( "" );
         }
         self.popIndent();

         if! let thenBlock = node.$thenBlock {
            self.writeln( "}" );
            self.writeln( "else {" );
            self.pushIndent(##);
            filter( thenBlock, self, node );
            self.popIndent();
         };

         self.writeln( "}" );
      }
   }
   else {
      self.processDeclVarAndSet( varSymList, node.$expList );
   }



   if! node.$syncBlock {
      filter( _exp, self, node);

      foreach varInfo in node.$syncVarList {
         self.writeln( "_sync_%s = %s" (varInfo.$name.txt, varInfo.$name.txt) );
      }
      self.popIndent();
      self.writeln( "}" );

      foreach varInfo in node.$syncVarList {
         self.writeln( "%s = _sync_%s" (varInfo.$name.txt, varInfo.$name.txt) );
      }
      self.popIndent();
      self.writeln( "}" );
   }


   if node.get_accessMode() == .Pub {
      self.writeln( "" );
      foreach var, index in varSymList {
         let name: str = self.moduleCtrl.getSymbolName( var );
         self.pubVarName2InfoMap[ name ] = new PubVarInfo(
            node.$staticFlag, node.$accessMode,
            node.$symbolInfoList[ index ].$mutable, node.$typeInfoList[ index ] );
      }
   }
};


pub override fn convFilter.processWhen(
   node: Nodes.WhenNode, opt: Opt ) mut
{
   self.write( "if ( " );
   foreach symPair, index in node.$symPairList {
      self.write( "%s.type != lns_stem_type_nil"
                  ( self.moduleCtrl.getSymbolName( symPair.$src )) );
      if index ~= #node.$symPairList {
         self.write( " && " );
      }
   }
   self.writeln( " ) " );
   self.writeln( "{" );

   self.processBlockPreProcess( node.$block.$scope );
   
   foreach symPair in node.$symPairList {
      let srcSymbol = symPair.$src;
      let dstSymbol = symPair.$dst;
      let srcTypeTxt = self.scopeMgr.getCTypeForSym( srcSymbol );
      let dstTypeTxt = self.scopeMgr.getCTypeForSym( dstSymbol );
      if srcTypeTxt ~= dstTypeTxt {
         // self.writeln( "%s %s;" ( dstTypeTxt, getSymbolName( dstSymbol ) ) );
         // self.processSetSymSingle( node, nil, dstSymbol, true, srcSymbol, false );
         // self.writeln( "" );

         self.processDeclVarC( true, dstSymbol, false );

         // let workSymbol = new WorkSymbol(
         //    srcSymbol.$scope, srcSymbol.$accessMode, srcSymbol.$name, 
         //    srcSymbol.$typeInfo.$nonnilableType, srcSymbol.$kind,
         //    new SymbolParam( .Stem, 0, cTypeStem ) );
         
         // self.processSetSymSingle(
         //    node, nil, dstSymbol, true, workSymbol, true );
         self.processSetSymSingle(
            node, nil, dstSymbol, true, srcSymbol, false );
         self.writeln( "" );

         
      }
      else {
         self.writeln( "%s %s = %s;"
            ( dstTypeTxt, self.moduleCtrl.getSymbolName( dstSymbol ),
              self.moduleCtrl.getSymbolName( srcSymbol )) );
      }
   }
   
   filter( node.$block, self, node );

   self.processBlockPostProcess();
   

   if! node.$elseBlock {
      self.write( "} else {" );
      filter( _exp, self, node );
   }
   self.writeln( "}" );
}


pub override fn convFilter.processDeclArg(
   node: Nodes.DeclArgNode, opt: Opt ) mut
{
   // 引数がクロージャで使用されている場合、引数を別名で宣言する。
   // 関数の先頭で、クロージャ用の変数を別途宣言する。
   self.write( getCType( node.$expType ) );
   if node.$symbolInfo.$hasAccessFromClosure {
      self.write( ' _' );
   }
   else {
      self.write( ' ' );
   }
   self.write( node.get_name().txt );
   
   //self.write( string.format( "%s %s", cTypeStem, node.get_name().txt ) );

   // // filter( // node.info.argType,  self, node, baseIndent )
};

pub override fn convFilter.processDeclArgDDD(
   node: Nodes.DeclArgDDDNode, opt: Opt ) mut
{
   self.write( "%s _pDDD" (cTypeStem) );
};

pub override fn convFilter.processExpDDD(
   node: Nodes.ExpDDDNode, opt: Opt ) mut
{
   // self.write( "..." );
};

pub override fn convFilter.processExpSubDDD(
   node: Nodes.ExpSubDDDNode, opt:Opt ) mut
{
   self.write( "lns_createSubDDD( _pEnv, %d, LNS_STEM_ANY( _pEnv->pMRet ) )" (node.$remainIndex ) );
};


fn convFilter.processFuncPrototype(
   parent:Nodes.Node, accessMode:Ast.AccessMode, needFormVal:bool,
   name:str, retType:str, argList:&List<&Nodes.Node>, termFlag:bool ) mut
{
   fn process( out2HMode:Out2HMode ) {
      self.write( string.format( "%s%s %s( %s _pEnv",
                                 getOut2HeaderPrefix( out2HMode ),
                                 retType, name, cTypeEnvP ) );
      if needFormVal {
         self.write( string.format( ", %s _pForm", cTypeAnyP ) );
      }
      
      foreach arg, index in argList {
         self.write( ", " );
         filter( arg, self, parent );
      }
      self.write( " )" );
      if termFlag {
         self.writeln( ";" );
      }
   }

   if termFlag {
      _out2Header(
         self.stream, Ast.isPubToExternal( accessMode ),
         `{
            if out2HMode ~= .SourcePub {
               process( out2HMode );
            }
         } );
   }
   else {
      process( .SourcePub );
   }
}



pub override fn convFilter.processDeclForm(
   node: Nodes.DeclFormNode, opt: Opt ) mut
{
   let formType = node.$expType;

   switch self.processMode {
      case .Prototype {
         self.processFuncPrototype(
            node, formType.$accessMode, true,
            self.moduleCtrl.getCallFormName( formType ),
            getCRetType( formType.$retTypeInfoList ), node.$argList, true );
      }
      case .Form {
         self.processFuncPrototype(
            node, formType.$accessMode, true,
            self.moduleCtrl.getCallFormName( formType ),
            getCRetType( formType.$retTypeInfoList ), node.$argList, false );

         fn process( prefix:str ) {
            self.pushIndent( ## );
            self.write( prefix );
            foreach arg, index in node.$argList {
               self.write( ", " );
               if! let workArg = arg@@@Nodes.DeclArgNode {
                  self.write( workArg.$name.txt );
               }
               else {
                  if! let workArg = arg@@@Nodes.DeclArgDDDNode {
                     self.write( "_pDDD" );
                  }
               }
            }
            self.writeln( ");" );
            self.popIndent();
         }
         
         self.writeln( "{" );
         self.pushIndent( ## );

         self.writeln( "if lns_isClosure( _pForm ) {" );
         switch getCRetType( formType.$retTypeInfoList ) {
            case "void" {
               process( "lns_closure( _pForm )( _pEnv, _pForm");
            }
            case cTypeAny {
               process( "return lns_closure_any( _pForm )( _pEnv, _pForm" );
            }
            case cTypeInt {
               process( "return lns_closure_int( _pForm )( _pEnv, _pForm" );
            }
            case cTypeReal {
               process( "return lns_closure_real( _pForm )( _pEnv, _pForm" );
            }
            case cTypeBool {
               process( "return lns_closure_bool( _pForm )( _pEnv, _pForm" );
            }
            default {
               process( "return lns_closure( _pForm )( _pEnv, _pForm" );
            }
         }
         self.writeln( "}" );
         self.writeln( "else {" );
         switch getCRetType( formType.$retTypeInfoList ) {
            case "void" {
               process( "lns_func( _pForm )( _pEnv" );
            }
            case cTypeAnyP {
               process( "return lns_func_any( _pForm )( _pEnv" );
            }
            case cTypeInt {
               process( "return lns_func_int( _pForm )( _pEnv" );
            }
            case cTypeReal {
               process( "return lns_func_real( _pForm )( _pEnv" );
            }
            case cTypeBool {
               process( "return lns_func_bool( _pForm )( _pEnv" );
            }
            default {
               process( "return lns_func( _pForm )( _pEnv" );
            }
         }
         self.writeln( "}" );

         
         self.popIndent();
         self.writeln( "}" );
      }
   }
}


pub override fn convFilter.processDeclFunc(
   node: Nodes.DeclFuncNode, opt: Opt ) mut
{
   let declInfo = node.$declInfo;
   let name = self.moduleCtrl.getFuncName( node.$expType );
   
   fn processFuncPrototype( termFlag:bool ) {
      self.processFuncPrototype(
         node, declInfo.$accessMode, isClosure( node.$expType ),
         name, getCRetType( node.$expType.$retTypeInfoList ),
         declInfo.$argList, termFlag );
   }

   switch self.processMode {
      case .Form {
      }
      case .Prototype {
         processFuncPrototype( true );
         return;
      }
      case .InitFuncSym, .WideScopeVer {
         self.process__func__symbol(
            node.$expType, declInfo.$has__func__Symbol,
            self.moduleCtrl.getFuncName( node.$expType ) );
         return;
      }
      default {
         switch opt.node.$kind {
            case Nodes.NodeKind.$Block, Nodes.NodeKind.$ExpMacroExp {
            }
            default {
               self.write( self.getFunc2any( node.$expType ) );
            }
         }
         // else {
         //    if! let rawName = node.$declInfo.$name {
         //       let scope = (unwrap node.$expType.$scope).$parent;
         //       let symbolInfo = unwrap scope.getSymbolInfoChild( rawName.txt );

         //       let formTxt = self.getFunc2any( node.$expType );
         //       self.processDeclVarC( true, symbolInfo, formTxt );
         //    }
         // }
         return;
      }
   }
   if self.duringDeclFunc {
      if opt.node.$kind == Nodes.NodeKind.$Block {
         return;
      }
      self.write( self.moduleCtrl.getFuncName( node.$expType ) );
      return;
   }

   let! body = declInfo.$body {
      return;
   };
   
   self.duringDeclFunc = true;
   
   processFuncPrototype( false );
   self.writeln( "" );
   self.writeln( "{" );

   self.pushRoutine( node.$expType, body );
   
   // self.processBlockPreProcess( body  );
   
   foreach argNode in node.$declInfo.$argList {
      if! let declArg = argNode@@@Nodes.DeclArgNode {
         let symbolInfo = declArg.$symbolInfo;
         if symbolInfo.$hasAccessFromClosure {
            // 引数がクロージャからアクセスされている場合は、
            // クロージャ用に変数を定義しなおす
            let symbolParam = self.scopeMgr.getSymbolParam( symbolInfo );
            self.writeln( "%s %s;" ( symbolParam.typeTxt,
                                     self.moduleCtrl.getSymbolName( symbolInfo ) ) );     

            let mut skipFlag = false;
            if symbolParam.kind == .Stem {
               self.write( "lns_initVal_any(" );
               self.write( " %s, %s, %d, "
                           ( self.moduleCtrl.getSymbolName( symbolInfo ),
                             getBlockName( symbolInfo.$scope ), symbolParam.index ) );
            }
            else {
               // if symbolParam.kind == .Var and isStemType( symbolInfo.$typeInfo ) {
               //    self.write( "lns_initVal_var(" );
               //    self.write( " %s, %s, %d, "
               //                ( getSymbolName( symbolInfo ),
               //                  getBlockName( symbolInfo.$scope ), symbolParam.index ) );
               // }
               // else {
                  self.write( "lns_initVal_var(" );
                  self.write( " %s, %s, %d, "
                              ( self.moduleCtrl.getSymbolName( symbolInfo ),
                                getBlockName( symbolInfo.$scope ), symbolParam.index ) );

                  let valKind;
                  if isStemType( symbolInfo.$typeInfo ) {
                     valKind = ValKind.Stem;
                  }
                  else {
                     valKind = ValKind.Prim;
                  }
                  let workSymbol = new WorkSymbol(
                     symbolInfo.$scope, symbolInfo.$accessMode, "_%s" (symbolInfo.$name), 
                     symbolInfo.$typeInfo, symbolInfo.$kind,
                     new SymbolParam( valKind, 0, cTypeStem ) );    

                  self.processSym2stem( workSymbol );
                  self.writeln( ");" );
                  skipFlag = true;
               // }
            }
            if not skipFlag {
               let workArgName = "_" .. self.moduleCtrl.getSymbolName( symbolInfo );
               if not isStemType( symbolInfo.$typeInfo ) {
                  self.write( getLiteral2Stem( workArgName, symbolInfo.$typeInfo ) );
               }
               else {
                  self.write( workArgName );
               }
               self.writeln( ");" );
            }
         }
      }
   }

   
   // let localVerNum = 0;
   // self.writeln( "lns_enter_block( _pEnv, %d );" (localVerNum) );

   // // クロージャでアクセスする外部変数を宣言
   // let scope = unwrap node.$expType.$scope;
   // forsort symbol in scope.$closureSymMap {
   //    self.writeln( "%s %s = l_form_closure( _pForm, %d );"
   //                  ( cTypeStem, symbol.$name, unwrap scope.$closureSym2NumMap[ symbol ]  ) );
   // }
   

   // foreach refType, index in declInfo.get_retTypeList() {
   //    if index > 1 {
   //   self.write( ", " )
   //    }
   //filter( //    refType,  self, node, baseIndent )
   // }

   let mut breakKind = Nodes.BreakKind.None;

   // self.process__func__symbol(
   //    node.$expType, declInfo.$has__func__Symbol, name );

   // self.pushRoutine( node.$expType );
   
   filter( body,  self, node );

   self.popRoutine();

   // self.processBlockPostProcess();
   
   
   breakKind = body.getBreakKind( .Normal );

   switch breakKind {
      case .Return, .NeverRet {
         // body 終了位置は処理されない
      }
      default {
         //self.writeln( "return _pEnv->pNoneStem;" );
      }
   }

   self.writeln( "}" );

   //if declInfo.get_accessMode() == .Pub {
   let expType: Ast.TypeInfo = node.get_expType();
   if expType.get_accessMode() == .Pub {
      self.pubFuncName2InfoMap[ name ] = new PubFuncInfo(
         declInfo.get_accessMode(), node.get_expType() );
   }
};

pub override fn convFilter.processRefType(
   node: Nodes.RefTypeNode, opt: Opt ) mut
{
   // self.write( (node.get_refFlag() and "&" or "") ..
   //             (node.get_mutFlag() and "mut " or "") );
   // filter( node.get_name(),  self, node );
   // if node.get_array() == "array" {
   //    self.write( "[@]" );
   // }
   // elseif node.get_array() == "list" {
   //    self.write( "[]" );
   // }
};

pub override fn convFilter.processIf(
   node: Nodes.IfNode, opt: Opt ) mut
{
   let valList = node.get_stmtList();
   foreach val, index in valList {
      if index == 1 {
         self.write( "if ( lns_isCondTrue( " );
         self.processVal2stem( val.$exp, node );
         self.write( ") )" );
      }
      elseif val.$kind == .ElseIf {
         self.write( "else if ( lns_isCondTrue( " );
         self.processVal2stem( val.$exp, node );
         self.write( ") )" );
      }
      else {
         self.writeln( "else {" );
      }
      self.write( " " );
      filter( val.$block, self, node );
      self.write( "}" );
   }
};

pub override fn convFilter.processSwitch(
   node: Nodes.SwitchNode, opt: Opt ) mut
{
   // self.writeln( "do" );
   // self.pushIndent(##);
   // self.write( "local _switchExp = " );
   // filter( node.get_exp(),  self, node );
   // self.writeln( "" );

   // foreach caseInfo, index in node.get_caseList() {
   //    if index == 1 {
   //       self.write( "if " );
   //    }
   //    else {
   //       self.write( "elseif " );
   //    }
   //    let expList = caseInfo.get_expList();
   //    foreach expNode, listIndex in expList.get_expList() {
   //       if listIndex ~= 1 {
   //          self.write( " or " );
   //       }

   //       self.write( "_switchExp == " );
   //       filter( expNode, self, node );
   //    }
   //    self.write( " then" );
   //    filter( caseInfo.$block, self, node );
   // }
   // if! node.get_default() {
   //    self.writeln( "else " );
   //    self.pushIndent(##);
   //    filter( _exp, self, node );
   //    self.popIndent();
   // }
   // self.writeln( "end" );
   // self.popIndent();

   // self.writeln( "end" );
};


pub override fn convFilter.processMatch(
   node: Nodes.MatchNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent( ## );
   self.write( "%s _matchExp = " (cTypeAnyP) );
   filter( node.$val,  self, node );
   self.write( accessAny );
   self.writeln( ";" );

   self.writeln( "switch( _matchExp->val.alge.type ) {" );
   let algeType = node.$algeTypeInfo;
   let enumName = self.moduleCtrl.getAlgeEnumCName( algeType );
   foreach caseInfo, index in node.$caseList {
      let valInfo = caseInfo.$valInfo;
      self.writeln( "case %s_%s:" (enumName, valInfo.$name ) );
      self.pushIndent(##);
      self.writeln( "{" );
      self.pushIndent(##);
      if #valInfo.$typeList > 0 {
         // パラメータの代入
         let structTxt = self.moduleCtrl.getAlgeValStrCName( algeType, valInfo.$name );
         self.writeln( "%s * _pVal = (%s *)_matchExp->val.alge.pVal;"
                       (structTxt, structTxt) );
         foreach paramType, paramIndex in valInfo.$typeList {
            let paramName = caseInfo.$valParamNameList[ paramIndex ];
            self.writeln(
               "%s %s = _pVal->_val%d;"
               (getCType( paramType ), paramName, paramIndex )); 
         }
      }
      self.popIndent();

      filter( caseInfo.$block, self, node );

      self.writeln( "}" );
      self.writeln( "break;" );
      self.popIndent();
   }
   self.writeln( "}" );
   self.popIndent();

   self.writeln( "}" );
   
   // self.writeln( "do" );
   // self.pushIndent(##);
   // self.write( "local _matchExp = " );
   // filter( node.$val,  self, node );
   // self.writeln( "" );

   // let fullName = self.getFullName( node.$algeTypeInfo );
   // foreach caseInfo, index in node.$caseList {
   //    if index == 1 {
   //       self.write( "if " );
   //    }
   //    else {
   //       self.write( "elseif " );
   //    }
   //    self.writeln( "_matchExp[1] == %s.%s[1] then"
   //                  (fullName, caseInfo.$valInfo.$name ) );
   //    foreach paramName, paramNum in caseInfo.$valParamNameList {
   //       self.writeln( "   local %s = _matchExp[2][%d]" (paramName, paramNum ) );
   //    }
   //    filter( caseInfo.$block, self, node );
   // }
   // if! node.$defaultBlock {
   //    self.writeln( "else " );
   //    filter( _exp, self, node );
   // }
   // self.writeln( "end" );
   // self.popIndent();

   // self.writeln( "end" );
};


pub override fn convFilter.processWhile(
   node: Nodes.WhileNode, opt: Opt ) mut
{
   // self.write( "while " );

   // filter( node.get_exp(), self, node );
   // self.write( " " );
   // filter( node.get_block(), self, node );
   // self.writeln( "end" );
};

pub override fn convFilter.processRepeat(
   node: Nodes.RepeatNode, opt: Opt ) mut
{
   // self.write( "repeat " );
   // filter( node.get_block(),  self, node );
   // self.write( "until " );
   // filter( node.get_exp(),  self, node );
};

pub override fn convFilter.processFor(
   node: Nodes.ForNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   self.writeln( "%s _to;" (cTypeInt ) );
   self.writeln( "%s _inc;" (cTypeInt ) );
   self.writeln( "%s %s;" (cTypeInt, self.moduleCtrl.getSymbolName( node.$val ) ) );

   // node.get_block().$scope.

   //self.processSetValToSym( node, [ node.$val ], true, [ node.$to ] ## );
   self.processSetValSingle( node, nil, node.$val, true, node.$to, 0, false );
   self.writeln( "" );
   self.writeln( "_to = %s;" ( self.moduleCtrl.getSymbolName( node.$val )) );
   if! node.get_delta() {
      self.processSetValToSym( node, [ node.$val ], true, [ _exp ] ## );
      self.writeln( "_inc = %s;" ( self.moduleCtrl.getSymbolName( node.$val )) );
   }
   else {
      self.writeln( "_inc = 1;" );
   }
   self.processSetValToSym( node, [ node.$val ], true, [ node.$init ] ## );
   self.writeln( "" );

   self.processLoopPreProcess( node.$block );
   
   self.writeln(
      "for (; %s <= _to; %s += _inc ) {"
      (self.moduleCtrl.getSymbolName( node.$val ),
        self.moduleCtrl.getSymbolName( node.$val )) );
   self.writeln( "lns_reset_block( _pEnv );" );
   filter( node.$block,  self, node );
   self.writeln( "}" );

   self.processLoopPostProcess();

   self.popIndent();
   self.writeln( "}" );
};

fn convFilter.processCreateDDD(
   parent:&Nodes.Node, expList:&List<&Nodes.Node> ) mut
{
   self.write( "lns_createDDD" );
   let lastExp = expList[ #expList ];
   self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );

   foreach exp in expList {
      self.write( ", " );
      self.processVal2stem( exp, parent );
   }
   self.write( ")" );
}

pub override fn convFilter.processApply(
   node: Nodes.ApplyNode, opt: Opt ) mut
{
   self.writeln( "{" );
   let varList = node.$varList;

   let scope = node.$block.$scope;

   let iteExpTypeList = node.$expList.$expTypeList;
   let iteFuncType = iteExpTypeList[ 1 ];

   let dummyId = varList[1].$symbolId;

   let mut dummyScope = new Ast.Scope( nil, false## );
   
   let formSym = dummyScope.addLocalVar(
      false, false, "_form%d" (dummyId), node.$pos, iteFuncType, .IMut);
   let paramSym = dummyScope.addLocalVar(
      false, false, "_param%d" (dummyId), node.$pos, iteExpTypeList[ 2 ], .IMut);
   let stateSym = dummyScope.addLocalVar(
      false, false, "_state%d" (dummyId), node.$pos, iteExpTypeList[ 3 ], .IMut);
   self.scopeMgr.setupScopeParam( dummyScope );

   self.processBlockPreProcess( dummyScope );
   let mut symList:List<&Ast.LowSymbol> = [];
   symList.insert( formSym );
   symList.insert( paramSym );
   symList.insert( stateSym );
   self.processDeclVarAndSet( symList, node.$expList );

   self.writeln( "{" );
   self.processLoopPreProcess( node.$block );

   self.writeln( "while ( true ) {" );
   self.pushIndent(##);
   self.writeln( "lns_reset_block( _pEnv );" );

   foreach varSym in node.$varList {
      self.processDeclVarC( true, varSym, false );
   }

   // イテレータ関数を実行し、開放されないように一旦 work にセットする
   let workSymName = "_workMret%d" (dummyId);
   self.write( "%s %s = " (cTypeAnyP, workSymName) );

   if formSym.$typeInfo.$kind == .Ext {
      self.write( "lns_lua_callForm( _pEnv, *%s, "
                  ( self.moduleCtrl.getSymbolName( formSym ) ) );
      self.write( "" );
      let mut expList:List<&Nodes.Node> = [];
      expList.insert( self.createRefNodeFromSym( paramSym ) );
      expList.insert( self.createRefNodeFromSym( stateSym ) );
      self.processCreateDDD( node, expList );
      self.writeln( ")%s;" (accessAny) );
   }
   else {
      self.write( "lns_func( *%s )( _pEnv, "
                  ( self.moduleCtrl.getSymbolName( formSym ) ) );
      if self.scopeMgr.getSymbolValKind( paramSym ) == .Any {
         self.write ( "*" );
      }
      self.writeln( "%s, %s)%s;"
         ( self.moduleCtrl.getSymbolName( paramSym ),
           self.moduleCtrl.getSymbolName( stateSym ), accessAny ) );
   }
   
   self.writeln(
      "if ( lns_fromDDD( %s, 0 ).type == lns_stem_type_nil ) {" (workSymName) );
   self.writeln( "   break;" );
   self.writeln( "}" );

   // work から各変数にセットする
   let mut nodeManager = self.dummyNodeManager;
   foreach varSym, index in node.$varList {
      let valKind = self.scopeMgr.getSymbolValKind( varSym );
      let varName = self.moduleCtrl.getSymbolName( varSym );
      switch valKind {
         case .Stem {
            self.writeln(
               'lns_setq( _pEnv, %s, lns_fromDDD( %s, %d ) );'
               (varName, workSymName, index - 1 ) );
         }
         case .Any {
            self.writeln(
               'lns_setq_any( _pEnv, %s, lns_fromDDD( %s, %d )%s );'
               (varName, workSymName, index - 1, accessAny ) );
         }
         case .Prim {
            self.writeln( "%s = lns_fromDDD( %s, %d )%s"
                          ( varName, workSymName, index - 1, 
                            getAccessValFromStem( varSym.$typeInfo ) ) );
         }
         default {
            Util.err( "no support -- %s:%s:%d"
               (varSym.$name,valKind.$_txt,__line__));
         }
      }
   }


   filter( node.$block, self, node );

   self.processSetSymSingle(
      node, nil, stateSym, false, node.$varList[1], false );
   self.writeln( "" );
   
   // self.write( "lns_setq( _pEnv, %s, " (stateSym.$name ) );
   // self.processSym2stem( node.$varList[1] );
   // self.writeln( ");" );
   
   self.popIndent();
   self.writeln( "}" );


   self.processLoopPostProcess();


   self.writeln( "}" );
   self.processLoopPostProcess();
   
   
   self.writeln( "}" );
   
   
   // self.write( "for " );
   // let varList = node.get_varList();
   // foreach var, index in varList {
   //    if index > 1 {
   //       self.write( ", " );
   //    }
   //    self.write( var.txt );
   // }
   // self.write( " in " );
   // filter( node.$exp,  self, node );
   // self.write( " " );
   // filter( node.$block,  self, node );
   // self.writeln( "end" );
};

fn convFilter.processForeachSetupVal(
   parent:&Nodes.Node, scope:&Ast.Scope,
   workTxt:str, symTxt:str, symType:&Ast.TypeInfo ) mut
{
   let! symbolInfo = scope.getSymbolInfoChild( symTxt ) {
      Util.err( "not found symTxt -- %s" (symTxt)  );
   };

   self.processDeclVarC( true, symbolInfo, false );

   let srcSymbol = new WorkSymbol(
      symbolInfo.$scope, symbolInfo.$accessMode, workTxt,
      symbolInfo.$typeInfo, symbolInfo.$kind,
      new SymbolParam( .Stem, 0, cTypeStem ) );

   self.processSetSymSingle(
      parent, nil, symbolInfo, true, srcSymbol, true );
      
   // self.processSetValSingleDirect(
   //    parent, nil, symbolInfo, true, true, 0, false,
   //    fn () {
   //       processToIF(
   //          self.stream, self.moduleCtrl, symType,
   //          fn () {
   //             self.write( "(&%s)" (workTxt) );
   //             self.write( getAccessValFromStem( symType ) );
   //          } );
   //    } );
}

fn convFilter.processPoolForeachSetupVal(
   parent:&Nodes.Node, loopType:&Ast.TypeInfo, scope:&Ast.Scope,
   keyToken:&Parser.Token!, valToken:&Parser.Token! ) mut
{
  
   let valType = loopType.$itemTypeInfoList[ 1 ];
   let valSymTxt;
   if loopType.$kind == .Set {
      if! keyToken {
         valSymTxt = _exp.txt;
      }
      else {   
         //valSymTxt = "__val";
         Util.err( "keyToken is nil" );
      }
   }
   else {
      if! valToken {
         valSymTxt = _exp.txt;
      }
      else {   
         //valSymTxt = "__val";
         Util.err( "valToken is nil" );
      }
   }

   self.processForeachSetupVal( parent, scope, "_val", valSymTxt, valType );
}

fn convFilter.processMapForeachSetupVal(
   parent:&Nodes.Node, loopType:&Ast.TypeInfo, scope:&Ast.Scope,
   keyToken:&Parser.Token!, valToken:&Parser.Token!, keyTxt:str, valTxt:str ) mut
{
   when! keyToken {
      self.processForeachSetupVal( parent, scope, keyTxt, keyToken.txt,
                                   loopType.$itemTypeInfoList[ 1 ] );
   }
   self.writeln( "" );
   when! valToken {
      self.processForeachSetupVal( parent, scope, valTxt, valToken.txt,
                                   loopType.$itemTypeInfoList[ 2 ] );
   }
}

alge CollectionKind {
   List,
   Array,
   Set,
   Map,
   ExtList(extedType:&Ast.TypeInfo),
   ExtArray(extedType:&Ast.TypeInfo),
   ExtSet(extedType:&Ast.TypeInfo),
   ExtMap(extedType:&Ast.TypeInfo),
}

fn getCollectionKind( typeInfo:&Ast.TypeInfo ) : CollectionKind {
   switch typeInfo.$kind {
      case .List {
         return .List;
      }
      case .Array {
         return .Array;
      }
      case .Set {
         return .Set;
      }
      case .Map {
         return .Map;
      }
      case .Ext {
         let extType = unwrap typeInfo.$srcTypeInfo@@@Ast.ExtTypeInfo;
         let extedType = extType.$extedType;
         switch extedType.$kind {
            case .List {
               return .ExtList( extedType );
            }
            case .Array {
               return .ExtArray( extedType );
            }
            case .Set {
               return .ExtSet( extedType );
            }
            case .Map {
               return .ExtMap( extedType );
            }
         }
      }
   }
   Util.err( "unknown collection type -- %s" ( typeInfo.getTxt(##) ) );
}

pub override fn convFilter.processForeach(
   node: Nodes.ForeachNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   
   self.write( "%s _obj = " ( cTypeAnyP ) );
   self.processVal2any( node.$exp, node );
   //self.write( accessAny );
   self.writeln( ";" );

   let indexSymbol:&Ast.SymbolInfo!;
   let loopType = node.$exp.$expType;

   let collectionKind = getCollectionKind( loopType );
   
   switch loopType.$kind {
      case .List, .Array {
         self.writeln( "%s _itAny = lns_itList_new( _pEnv, _obj );" (cTypeAnyP) );
         if! let keyToken = node.$key {
            let! workSymbol = node.$block.$scope.getSymbolInfoChild( keyToken.txt ) {
               Util.err( "not found symbol -- %s" ( keyToken.txt ) );
            };
            indexSymbol = workSymbol;
            
            //self.writeln( "int %s = 0;" (keyToken.txt) );
            if self.scopeMgr.getSymbolValKind( workSymbol ) ~= .Prim {
               self.writeln( "int _%s = 0;" (keyToken.txt) );
            }
            else {
               self.processDeclVarC( true, workSymbol, true );
            }
         }
         else {
            indexSymbol = nil;
         }
         self.writeln( "%s _val;" ( cTypeStem ) );
      }
      case .Set {
         self.writeln( "%s _itAny = lns_itSet_new( _pEnv, _obj );" (cTypeAnyP) );
         indexSymbol = nil;
         self.writeln( "%s _val;" ( cTypeStem ) );
      }
      case .Map {
         self.writeln( "%s _itAny = lns_itMap_new( _pEnv, _obj );" (cTypeAnyP) );
         indexSymbol = nil;
         self.writeln( "lns_Map_entry_t _entry;" );
      }
      case .Ext {
         indexSymbol = nil;
         match collectionKind {
            case .ExtMap( extedType ) {
               self.writeln(
                  "%s _itAny = lns_lua_itMap_new( _pEnv, _obj );" (cTypeAnyP) );
               self.writeln( "lns_Map_entry_t _entry;" );
            }
         }
      }
      default {
         Util.err( "illegal kind -- %s" (loopType.$kind.$_txt ) );
      }
   }

   self.processLoopPreProcess( node.$block );

   switch loopType.$kind {
      case .List, .Array {
         //self.writeln( "for ( ; lns_reset_block( _pEnv ), lns_itList_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "for ( ; lns_itList_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "      lns_itList_inc( _pEnv, _itAny ) )" );
      }
      case .Set {
         //self.writeln( "for ( ; lns_reset_block( _pEnv ), lns_itSet_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "for ( ; lns_itSet_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "      lns_itSet_inc( _pEnv, _itAny ) )" );
      }
      case .Map {
         //self.writeln( "for ( ; lns_reset_block( _pEnv ), lns_itMap_hasNext( _pEnv, _itAny, &_entry );" );
         self.writeln( "for ( ; lns_itMap_hasNext( _pEnv, _itAny, &_entry );" );
         self.writeln( "      lns_itMap_inc( _pEnv, _itAny ) )" );
      }
      case .Ext {
         match collectionKind {
            case .ExtMap( extedType ) {
               self.writeln(
                  "while ( lns_lua_itMap_hasNext( _pEnv, _itAny ) )" );
            }
         }
      }
   }
   self.writeln( "{" );
   self.pushIndent(##);
   self.writeln( "lns_reset_block( _pEnv );" );
   
   when! indexSymbol {
      if self.scopeMgr.getSymbolValKind( indexSymbol ) ~= .Prim {
         self.writeln( "_%s++;" ( self.moduleCtrl.getSymbolName( indexSymbol ) ) );
         self.processDeclVarC( true, indexSymbol, true );
         self.processSetValSingleDirect(
            node, nil, indexSymbol, true, .Prim, 0, false,
            fn () {
               self.write( "_%s;" ( self.moduleCtrl.getSymbolName( indexSymbol ) ) );
            });
         self.writeln( "" );
      }
      else {
         self.writeln( "%s++;" ( self.moduleCtrl.getSymbolName( indexSymbol ) ) );
      }
   }

   switch loopType.$kind {
      case .List, .Set, .Array {
         self.processPoolForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val );
      }
      case .Map {
         self.processMapForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val,
            "_entry.key", "_entry.val" );
      }
      default {
         match collectionKind {
            case .ExtMap( extedType ) {
               self.writeln( "lns_lua_itMap_getEntry( _pEnv, _itAny, &_entry );" );
               self.processMapForeachSetupVal(
                  node, extedType, node.$block.$scope, node.$key, node.$val,
                  "_entry.key", "_entry.val" );
            }
         }
      }
   }
   
   filter( node.$block, self, node );

   self.popIndent();
   self.writeln( "}" );

   self.processLoopPostProcess();
   self.popIndent();
   self.writeln( "}" );
};

pub override fn convFilter.processForsort(
   node: Nodes.ForsortNode, opt: Opt ) mut
{
   self.writeln( "{" );
   self.pushIndent(##);
   
   self.write( "%s _obj = " ( cTypeAnyP ) );
   self.processVal2any( node.$exp, node );
   self.writeln( ";" );

   let loopType = node.$exp.$expType;
   switch loopType.$kind {
      case .Set {
         self.writeln(
            "%s _pList = lns_mtd_Map_createKeyList( _pEnv, _obj );" (cTypeAnyP) );
         self.writeln(
            "lns_mtd_List( _pList )->sort( _pEnv, _pList, %s );" (cValNil) );
         self.writeln( "%s _itAny = lns_itList_new( _pEnv, _pList );" (cTypeAnyP) );
         self.writeln( "%s _val;" ( cTypeStem ) );
      }
      case .Map {
         self.writeln(
            "%s _pKeyList = lns_mtd_Map_createKeyList( _pEnv, _obj );" (cTypeAnyP) );
         self.writeln(
            "lns_mtd_List( _pKeyList )->sort( _pEnv, _pKeyList, %s );" (cValNil) );
         self.writeln( "%s _itAny = lns_itList_new( _pEnv, _pKeyList );" (cTypeAnyP) );
         self.writeln( "%s _key;" ( cTypeStem ) );
      }
      default {
         Util.err( "illegal kind -- %s" (loopType.$kind.$_txt ) );
      }
   }

   self.processLoopPreProcess( node.$block );

   switch loopType.$kind {
      case .Set {
         self.writeln( "for ( ; lns_itList_hasNext( _pEnv, _itAny, &_val );" );
         self.writeln( "      lns_itList_inc( _pEnv, _itAny ) )" );
      }
      case .Map {
         self.writeln( "for ( ; lns_itList_hasNext( _pEnv, _itAny, &_key );" );
         self.writeln( "      lns_itList_inc( _pEnv, _itAny ) )" );
      }
   }
   self.writeln( "{" );

   self.writeln( "lns_reset_block( _pEnv );" );
   
   switch loopType.$kind {
      case .Set {
         self.processPoolForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val );
      }
      case .Map {
         self.processMapForeachSetupVal(
            node, loopType, node.$block.$scope, node.$key, node.$val,
            "_key", "lns_mtd_Map_get( _pEnv, _obj, _key )" );
         
      }
      default {
      }
   }
   
   filter( node.$block, self, node );
   self.writeln( "}" );

   self.processLoopPostProcess();
   self.writeln( "}" );
   self.popIndent();
};


pub override fn convFilter.processExpUnwrap(
   node: Nodes.ExpUnwrapNode, opt: Opt ) mut
{
   fn processUnwrap( typeTxt:str ) {
      if! let defVal = node.$default {
         self.write( "lns_unwrap_%sDefault( " (typeTxt) );
         self.processVal2stem( node.$exp, node );
         self.write( "," );
         self.accessPrimVal( defVal, node );
         self.write( ")" );
      }
      else {
         self.write( "lns_unwrap_%s( " (typeTxt) );
         self.processVal2stem( node.$exp, node );
         self.write( ")" );
      }
   }
   
   switch node.$expType.$srcTypeInfo {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         processUnwrap( "int" );
      }
      case Ast.builtinTypeReal {
         processUnwrap( "real" );
      }
      default {
         switch self.getValKindOfNode( node ) {
            case .Stem {
               self.write( "lns_unwrap_stem( " );
            }
            case .Any {
               self.write( "lns_unwrap_any( " );
            }
            default {
               Util.err( "no support -- %d" (__line__)  );
            }
         }
         
         self.processVal2stem( node.$exp, node );
         if! let defVal = node.$default {
            self.write( "," );
            self.processVal2stem( defVal, node );
            self.write( ")" );
         }
         else {
            self.write( ", lns_global.nilStem )" );
         }
      }
   }
   
   // if! node.$default {
   //    self.write( '_lune.unwrapDefault( ' );
   //    filter( node.$exp, self, node );
   //    self.write( ', ' );
   //    filter( _exp, self, node );
   //    self.write( ')');
   // }
   // else {
   //    self.write( '_lune.unwrap( ' );
   //    filter( node.$exp, self, node );
   //    self.write( ')');
   // }
}


fn convFilter.processCreateMRet(
   retTypeList:&List<&Ast.TypeInfo>, expList:&List<&Nodes.Node>, parent:&Nodes.Node ) mut
{
   if expList[ 1 ].$expType.$kind == .DDD and #expList == 1 {
      self.write( "_pDDD" );
      return;
   }
   
   self.write( "lns_createMRet" );

   let lastExp = expList[ #expList ];
   self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );
   
   foreach exp, expIndex in expList {
      self.write( ", " );
      self.processVal2stem( exp, parent );
   }
   self.write( ")" );
}


alge MRetInfo {
   /** デフォルト form */
   Form,
   /** 独自で定義した form */
   FormFunc( refNode:&Nodes.ExpRefNode),
   Method( methodType:&Ast.TypeInfo),
   Func( refNode:&Nodes.Node ),
   DDD( expList:&Nodes.ExpListNode ),
   Format( format:str, expList:&Nodes.ExpListNode ),
}

pub fn convFilter.processCallWithMRet(
   parent:&Nodes.Node, mRetFuncName:str, retTypeName:str,
   funcArgNum:int, mRetInfo:MRetInfo,
   argList:&Nodes.ExpListNode ) mut
{
   let! mRetExp = argList.$mRetExp {
      return;
   };
   
   fn processDeclMRetProto() {
      self.write( "static %s %s( %s _pEnv"
         ( retTypeName, mRetFuncName, cTypeEnvP ) );
      
      fn processArgs() {
         foreach argNode, index in argList.$expList {
            if index >= mRetExp.$index {
               break;
            }
            let argType = argNode.$expType;
            self.write( ", %s arg%d" ( getCType( argType ), index ) );
         }
         self.write( ", %s pMRet )" (cTypeStem) );
      }

      match mRetInfo {
         case .Method( funcType ) {
            self.write( ", %s _pObj" (cTypeAnyP ) );
            processArgs();
         }
         case .Form {
            self.write( ", %s _pForm" (cTypeAnyP ) );
            processArgs();
         }
         case .FormFunc( funcNode ) {
            self.write( ", %s _pForm" (cTypeAnyP ) );
            processArgs();
         }
         case .DDD(node) {
            processArgs();
         }
         case .Func(funcNode) {
            processArgs();
         }
         case .Format(format,node) {
            processArgs();
         }
      }
   }
   
   switch self.processMode {
      case .Intermediate, .StringFormat {
         processDeclMRetProto();
         self.writeln( "// %d" (parent.$pos.lineNo) );
         self.writeln( "{" );

         self.pushIndent( ## );

         let mut argTypeList:List<&Ast.TypeInfo> = [];
         
         fn processSetArg( primFlag:bool ) {
            foreach argNode, index in argList.$expList {
               let mut argType = argNode.$expType;
               if index == mRetExp.$index {
                  self.writeln( "lns_setMRet( _pEnv, pMRet%s );" (accessAny) );
               }
               if index >= mRetExp.$index {
                  switch argNode.$kind {
                     case Nodes.NodeKind.$ExpToDDD {
                        let toDDDNode = unwrap argNode@@@Nodes.ExpToDDDNode;
                        self.write( "%s arg%d = " ( cTypeStem, index ) );
                        self.write( "lns_createDDD" );
                        let expList = toDDDNode.$expList.$expList;
                        let lastExp = expList[ #expList ];
                        self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );
                        foreach exp, workIndex in expList {
                           // self.write(
                           //    ", LNS_STEM_ANY( lns_getMRet( _pEnv, %d ) )" (workIndex + index - 2) );
                           self.write(
                              ", lns_getMRet( _pEnv, %d )" (workIndex + index - 2) );
                        }
                        self.write( ")" );
                        argTypeList.insert( Ast.builtinTypeDDD );
                     }
                     case Nodes.NodeKind.$ExpSubDDD {
                        self.write( "%s arg%d = " ( cTypeStem, index ) );
                        filter( argNode, self, parent );
                     }
                     default {
                        if! let castNode = argNode@@@Nodes.ExpCastNode {
                           argType = castNode.$castType;
                        }
                        
                        let typeTxt;
                        if primFlag {
                           typeTxt = getCType(argType );
                           argTypeList.insert( argType.$srcTypeInfo );
                        }
                        else {
                           typeTxt = cTypeStem;
                           argTypeList.insert( Ast.builtinTypeStem );
                        }
                        self.write( "%s arg%d = " (typeTxt, index ) );
                        if argType.$kind == .DDD {
                           self.write( "pMRet" );
                        }
                        else {
                           self.write(
                              "lns_getMRet( _pEnv, %d )" (index - mRetExp.$index) );
                        }
                        if primFlag {
                           self.write( getAccessValFromStem( argType ) );
                        }
                        else {
                           self.write( "->val.pAny" );
                        }
                     }
                  }
                  self.writeln( "; // %s" (argType.getTxt( self.$typeNameCtrl## )) );
               }
               else {
                  argTypeList.insert( argNode.$expType );
               }
            }
            if retTypeName ~= "void" {
               self.write( "return " );
            }
         }

         let mut wroteArgFlag = false;

         fn processCreateDDD( expList:&List<&Nodes.Node>) {
            self.write( "lns_createDDD" );
            let lastExp = expList[ #expList ];
            self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );

            for index = 1, #expList {
               let workExp = expList[ index ];
               self.write( ", " );
               switch argTypeList[ index ] {
                  case Ast.builtinTypeInt, Ast.builtinTypeChar {
                     self.write( "LNS_STEM_INT(" );
                     self.write( "arg%d )" ( index ) );
                  }
                  case Ast.builtinTypeReal {
                     self.write( "LNS_STEM_REAL(" );
                     self.write( "arg%d )" ( index ) );
                  }
                  case Ast.builtinTypeBool {
                     self.write( "LNS_STEM_BOOL(" );
                     self.write( "arg%d )" ( index ) );
                  }
                  default {
                     if getValKind( argTypeList[ index ] ) == .Any {
                        self.write( "LNS_STEM_ANY(" );
                        self.write( "arg%d )" ( index ) );
                     }
                     else {
                        self.write( "arg%d" ( index ) );
                     }
                  }
               }
               // if index >= mRetExp.$index {
               //    self.write( "arg%d" ( index ) );
               // }
               // else {
               //    self.write( getLiteral2Stem( "arg%d" ( index ), workExp.$expType ) );
               // }
            }
         }
        
         match mRetInfo {
            case .Method( funcType ) {
               processSetArg( true );
               self.write( "%s( _pEnv, _pObj"
                  ( self.moduleCtrl.getCallMethodCName( funcType )));
            }
            case .Form {
               processSetArg( true );
               //self.write( 'lns_call_form( _pEnv, _pForm, %d' (funcArgNum) );
               self.write( "lns_closure( _pForm )( _pEnv, pForm" );

               wroteArgFlag = true;
               processCreateDDD( argList.$expList );
               // self.write( "lns_createDDD" );
               // let expList = argList.$expList;
               // let lastExp = expList[ #expList ];
               // self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );
            }
            case .FormFunc( funcNode ) {
               processSetArg( true );
               self.write( "%s( _pEnv, _pForm"
                           (self.moduleCtrl.getCallFormName( funcNode.$expType ) ) );
            }
            case .Func( funcNode ) {
               processSetArg( true );
               let mut wroteFuncFlag = false;
               let builtinFunc = TransUnit.getBuiltinFunc();

               if! let cFuncName =
                  self.moduleCtrl.getBuiltinFuncNameFromType( funcNode.$expType )
               {
                  wroteFuncFlag = true;
                  self.write( cFuncName .. "(" );
               }
                  
               if not wroteFuncFlag {
                  filter( funcNode, self, parent );
                  self.write( "(" );
               }
               self.write( " _pEnv" );
            }
            case .DDD( expListNode ) {
               processSetArg( true );
               wroteArgFlag = true;
               processCreateDDD( expListNode.$expList );
            }
            case .Format( format, expListNode ) {
               processSetArg( true );
               wroteArgFlag = true;
               self.write( "mtd_lns_string_format( _pEnv, " );
               self.write( getLiteralStrAny( format ) );
               self.write( ", " );
               processCreateDDD( expListNode.$expList );
               self.write( ")" );
            }
         }

         if not wroteArgFlag {
            for index = 1, funcArgNum {
               self.write( ", arg%d" ( index ) );
            }
         }

         self.popIndent();
         self.writeln( ");" );
         self.writeln( "}" );
      }
      case .Prototype {
         processDeclMRetProto();
         self.writeln( "; // %d" (argList.$pos.lineNo) );
      }
   }
}

fn getMRetFuncName( node:&Nodes.Node ): str {
   return "l_call_mret_%d" ( node.$id );
}


pub override fn convFilter.processExpToDDD( node: Nodes.ExpToDDDNode, opt: Opt ) mut
{
   switch self.processMode {
      case .Intermediate, .Prototype {
         if! let mRetExp =  node.$expList.$mRetExp {
            if mRetExp.$index > 0 {
               // index が 0 以下の場合、 ExpCallNode 側で処理するので、
               // ここでは index が 1 以上のものだけを処理する。
               self.processCallWithMRet(
                  node, getMRetFuncName( node ), cTypeStem,
                  #node.$expList.$expList, MRetInfo.DDD( node.$expList ), node.$expList );
            }
         }
         return;
      }
   }


   let expList = node.$expList.$expList;

   if! let mRetExp = node.$expList.$mRetExp {
      self.write( "%s( _pEnv" ( getMRetFuncName( node ) ) );
      foreach exp, index in expList {
         if index > mRetExp.$index {
            break;
         }
         self.write( ", " );
         //self.processVal2stem( exp, node );
         filter( exp, self, node );
      }
      self.write( ")" );
   }
   else {
      self.processCreateDDD( node, expList );
   }
}

/**
関数呼び出しの引数処理。

コールする関数の引数に合せて、引数を調整する。

例えばコールする関数の引数が ... の場合、 lns_createDDD() する等。

@param funcType コールする関数のタイプ
@param expListNode 引数リストノード
*/
pub fn convFilter.processCallArgList(
   funcArgTypeList:&List<&Ast.TypeInfo>, expListNode: &Nodes.ExpListNode! ) mut
{
   when! expListNode {
      let expList = expListNode.$expList;
      foreach funcArgType, index in funcArgTypeList {
         self.write( ", " );
         if #expList >= index {
            if funcArgType.$kind == .DDD {
               if expList[ index ].$kind == Nodes.NodeKind.$Abbr {
                  self.write( "lns_global.ddd0" );
               }
               else {
                  filter( expList[ index ], self, expListNode );
               }
               // self.processCreateDDD( true, expList, index, parent );
               // for expIndex = index, #expList {
               //    self.write( ", " );
               //    self.processVal2stem( expList[ expIndex ], parent );
               // }
               // self.write( ")" );
               return;
            }
            else {
               // if funcArgType.$kind == .Form {
               if isStemType( funcArgType ) {
                  self.processVal2stem( expList[ index ], expListNode );
               }
               else {
                  filter( expList[ index ], self, expListNode );
               }
            }
         }
         else {
            if funcArgType.$kind == .DDD {
               self.write( "lns_global.ddd0" );
            }
            else {
               self.write( cValNone );
            }
         }
      }
   }
   else {
      for count = 1, #funcArgTypeList {
         self.write( ", %s" (cValNone) );
      }
   }
}

pub override fn convFilter.processExpNew(
   node: Nodes.ExpNewNode, opt: Opt ) mut
{
   let classFullName = self.moduleCtrl.getClassCName( node.$symbol.$expType );
   self.write( "lns_class_%s_new( _pEnv" ( classFullName ) );
   if! node.$argList {
      self.processCallArgList( node.$ctorTypeInfo.$argTypeInfoList, _exp );
      //filter( _exp,  self, node );
   }
   self.write( ")" );
};




fn convFilter.processCall(
   funcType:&Ast.TypeInfo, setArgFlag:bool, argList:&Nodes.ExpListNode! ) mut
{
   if not setArgFlag {
      self.write( "_pEnv" );


      if! let scope = funcType.$scope {
         if #scope.$closureSymList > 0 {
            // クロージャの場合
            // self.write( "lns_func2any( _pEnv, (lns_closure_t *)NULL, 0, false, %d"
            //             (#scope.$closureSymList) );
            // foreach symbolInfo in scope.$closureSymList {
            //    self.write( ", " );
            //    self.write( symbol2Any( symbolInfo ) );
            // }
            // self.write( ")" );
            self.write( ", " );
            self.write( self.getPrepareClosure( "NULL", 0, false,
                                                scope.$closureSymList ) );
            //self.write( accessAny );
         }
      }
   }

   when! argList {
      let mut expList:List<&Nodes.Node> = [];
      foreach expNode in argList.$expList {
         if expNode.$expType.$kind ~= .Abbr {
            expList.insert( expNode );
         }
      }

      self.processCallArgList( funcType.$argTypeInfoList, argList );
   }
   self.write( " )" );
}

pub override fn convFilter.processDeclClass(
   node: Nodes.DeclClassNode, opt: Opt ) mut
{
   let classType = node.$expType;
   let className = self.moduleCtrl.getClassCName( classType );

   switch self.processMode {
      case .Prototype {
         self.processDeclClassNodePrototype( node );
      }
      case .WideScopeVer {
         switch classType.$kind {
            case .Class {
               // インタフェース情報設定
               processIFMethodDataInit(
                  self.stream, self.moduleCtrl, classType, classType );
               
               processClassDataInit(
                  self.stream, self.moduleCtrl, classType, node.$fieldList );
            }
            case .IF {
               self.writeln(
                  'lns_type_meta_t lns_type_meta_%s = { "%s" };'
                  (className, className) );
            }
         }
      }
      case .DefClass {
         if classType.$kind == .Class {
            self.processDeclClassDef( node );
         }
      }
      case .Form, .InitModule {
         // self.write( self.moduleCtrl.getClassInitBlockName( classType ) );
         // self.write( "( _pEnv, NULL );" );
         if! let initBlockNode = node.$initBlock.$func {
            self.write(
               "%s(" (self.moduleCtrl.getMethodCName( initBlockNode.$expType) ) );
            self.processCall( initBlockNode.$expType, false, nil );
            self.writeln( ";" );
         }
      }
   }
   

   
   

   
   
//    let nodeInfo = node;
//    let classNameToken = nodeInfo.get_name();
//    let className = classNameToken.txt;
//    let classTypeInfo = node.get_expType();
//    let classTypeId = classTypeInfo.$typeId;
//    let isGenericClass = isGenericType( classTypeInfo );


//    if nodeInfo.get_accessMode() == .Pub {
//       self.classId2TypeInfo[ classTypeId ] = classTypeInfo;
//    }
//    self.classId2MemberList[ classTypeId ] = nodeInfo.get_memberList();

//    if! node.$moduleName {
//       self.write(
//          string.format( "local %s = require( %s )", className, _exp.txt ) );
//       switch node.$accessMode {
//          case .Pub, .Pro {
//             if self.needModuleObj {
//                self.writeln( "" );
//                self.write( "_moduleObj.%s = %s" (className, className ) );
//             }
//          }
//       }
//       return;
//    }
//    self.writeln( string.format( "local %s = {}", className ) );

//    let mut ifTxt = "";
//    if #classTypeInfo.$interfaceList > 0 {
//       foreach ifType in classTypeInfo.$interfaceList {
//          ifTxt = ifTxt .. self.getFullName( ifType ) .. ",";
//       }
//       ifTxt = "ifList = {%s}" (ifTxt);
//    }

//    let baseInfo = classTypeInfo.get_baseTypeInfo();
//    let mut baseTxt = "";
//    if baseInfo.get_typeId() ~= Ast.rootTypeId {
//       baseTxt = "__index = %s" ( self.getFullName( baseInfo ) );
//    }

//    if #ifTxt > 0 or #baseTxt > 0 {
//       let mut metaTxt = baseTxt;
//       if #baseTxt > 0 and #ifTxt > 0 {
//          metaTxt = "%s,%s" (baseTxt,ifTxt);
//       }
//       elseif #ifTxt > 0 {
//          metaTxt = ifTxt;
//       }
//       self.writeln( "setmetatable( %s, { %s } )" ( className, metaTxt ) );
//    }

//    if nodeInfo.get_accessMode() == .Pub {
//       if self.needModuleObj {
//          self.writeln( string.format( "_moduleObj.%s = %s", className, className ) );
//       }
//    }

//    foreach declNode in node.$declStmtList {
//       filter( declNode, self, node );
//    }


//    let mut hasConstrFlag = false;
//    let mut hasDestrFlag = false;
//    let mut memberList: List<&Nodes.DeclMemberNode> = [];
//    let fieldList: List<&Nodes.Node> = nodeInfo.get_fieldList();
//    let outerMethodSet: Set<str> = nodeInfo.get_outerMethodSet();
//    let mut methodNameSet: Set<str> = (@);
//    foreach field in fieldList {
//       let mut ignoreFlag = false;
//       if field.$kind == Nodes.NodeKind.$DeclConstr {
//          hasConstrFlag = true;
//          methodNameSet.add( "__init" );
//       }
//       if field.$kind == Nodes.NodeKind.$DeclDestr {
//          hasDestrFlag = true;
//          methodNameSet.add( "__free" );
//       }
//       if! let declMemberNode = field@@@Nodes.DeclMemberNode {
//          if not declMemberNode.$staticFlag {
//             memberList.insert( declMemberNode );
//          }
//       }
//       if! let methodNode = field@@@Nodes.DeclMethodNode {
//          let declInfo = methodNode.get_declInfo();
//          let methodNameToken = unwrap declInfo.get_name();
//          if outerMethodSet.has( methodNameToken.txt ) {
//             ignoreFlag = true;
//          }
//          methodNameSet.add( methodNameToken.txt );
//       }

//       if ( not ignoreFlag ) {
//          filter( field, self, node );
//       }
//    }

//    let mut destTxt = "";
//    if! self.getDestrClass( node.get_expType() ) {
//       destTxt = ", __gc = %s.__free" (_exp.getTxt(##));
//    }

//    self.writeln(```
// function %s.setmeta( obj )
//   setmetatable( obj, { __index = %s %s } )
// end```
//       ( className, className, destTxt ) );

//    if not hasConstrFlag {
//       // デフォルトコンストラクタ生成
//       methodNameSet.add( "__init" );

//       let oldFlag;
//       {
//          let initSymbol =
//             unwrap (unwrap classTypeInfo.$scope).getSymbolInfoChild( "__init" );
//          oldFlag = (unwrap initSymbol.$typeInfo.$scope).getSymbolInfoChild( "" ) ~= nil;
//       }

//       let mut superArgTxt = "";
//       let mut thisArgTxt = "";

//       if not oldFlag and baseInfo ~= Ast.headTypeInfo {
//          if! let superInit = (unwrap baseInfo.$scope).getSymbolInfoChild( "__init" ) {
//             foreach argType, index in superInit.$typeInfo.$argTypeInfoList {
//                if #superArgTxt > 0 {
//                   superArgTxt = superArgTxt .. ", ";
//                }
//                superArgTxt = "%s__superarg%d" (superArgTxt, index);
//             }
//          }
//       }

//       foreach member in memberList {
//          if #thisArgTxt > 0 {
//             thisArgTxt = thisArgTxt .. ", ";
//          }
//          thisArgTxt = thisArgTxt .. member.$name.txt;
//       }

//       let mut argTxt = superArgTxt;
//       if #argTxt > 0 {
//          argTxt = argTxt .. ",";
//       }
//       argTxt = argTxt .. thisArgTxt;

//       self.writeln( ```
// function %s.new( %s )
//    local obj = {}
//    %s.setmeta( obj )
//    if obj.__init then
//       obj:__init( %s )
//    end
//    return obj
// end
// function %s:__init( %s )
// ```
//             ( className, argTxt, className,
//               argTxt, className, argTxt ) );
//       self.pushIndent(##);

//       if baseInfo ~= Ast.headTypeInfo {
//          // Super クラスを持つ場合、その Super クラスの __init をコールする。
//          if! let superInit = (unwrap baseInfo.$scope).getSymbolInfoChild( "__init" ) {
//             self.write( "%s.__init( self" ( self.getFullName( baseInfo ) ) );
//             if #superArgTxt > 0 {
//                self.writeln( ", %s )" ( superArgTxt ) );
//             }
//             else {
//                self.writeln( ")" );
//             }
//          }
//       }

//       foreach member in memberList {
//          let memberName = member.$name.txt;
//          self.writeln( string.format( "self.%s = %s", memberName, memberName ));
//       }
//       self.popIndent();
//       self.writeln( 'end' );
//    }

//    // accessor
//    let scope = nodeInfo.get_scope();
//    foreach memberNode in nodeInfo.$memberList {
//       let memberNameToken = memberNode.get_name();
//       let memberName = memberNameToken.txt;
//       let getterName = "get_" .. memberName;
//       // let typeInfo = scope.getTypeInfo( getterName, scope, false );
//       // let autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
//       let mut autoFlag = not methodNameSet.has( getterName );
//       let prefix = memberNode.$staticFlag and className or "self";
//       if memberNode.get_getterMode() ~= .None and autoFlag
//       {
//          self.writeln( ```
// function %s:%s()
//    return %s.%s
// end``` ( className, getterName, prefix, memberName ) );
//          methodNameSet.add( getterName );
//       }
//       let setterName = "set_" .. memberName;
//       //typeInfo = scope.getTypeInfo( setterName, scope, false );
//       //autoFlag = not typeInfo or (unwrap typeInfo).get_autoFlag();
//       autoFlag = not methodNameSet.has( setterName );
//       if memberNode.get_setterMode() ~= .None and autoFlag
//       {
//          self.writeln( ```
// function %s:%s( %s )
//    %s.%s = %s
// end``` ( className, setterName, memberName, prefix, memberName, memberName ) );
//          methodNameSet.add( setterName );
//       }
//    }

//    // advertise
//    foreach advertiseInfo in node.$advertiseList {
//       let memberName = advertiseInfo.$member.$name.txt;
//       let mut memberType = advertiseInfo.$member.$expType;
//       foreach child in memberType.$children {
//          if child.$kind == Ast.TypeInfoKind.Method and
//             child.$accessMode ~= .Pri and
//             not child.$staticFlag
//          {
//             let childName = advertiseInfo.$prefix .. child.getTxt(##);
//             if not methodNameSet.has( childName ) {
//                self.writeln( ```
// function %s:%s( ... )
//    return self.%s:%s( ... )
// end
// ``` (className, childName, memberName, childName) );
//             }
//          }
//       }
//    }

//    // init block
//    if #nodeInfo.$initStmtList > 0 {
//       self.writeln( "do" );
//       self.pushIndent(##);
//       foreach initStmt in nodeInfo.$initStmtList {
//          filter( initStmt, self, node );
//          self.writeln( "" );
//       }
//       self.popIndent();
//       self.writeln( "end" );
//    }

//    // Mapping
//    if classTypeInfo.isInheritFrom( Ast.builtinTypeMapping, nil ) {
//       let mut declArgTxt = "val";
//       let mut argTxt = "{}, val";
//       if isGenericType( classTypeInfo ) {
//          declArgTxt = "val, __alt2mapFunc";
//          argTxt = "{ __alt2mapFunc = __alt2mapFunc }, val";
//       }

//       self.writeln( ```
// function %s:_toMap()
//   return self
// end
// function %s._fromMap( %s )
//   local obj, mes = %s._fromMapSub( %s )
//   if obj then
//      %s.setmeta( obj )
//   end
//   return obj, mes
// end
// function %s._fromStem( %s )
//   return %s._fromMap( %s )
// end
// ``` (className, className, declArgTxt,
//       className, argTxt, className,
//       className, declArgTxt, className, declArgTxt ));

//       self.writeln( 'function %s._fromMapSub( obj, val )' (className ));

//       if classTypeInfo.$baseTypeInfo ~= Ast.headTypeInfo {
//          self.writeln( ```
//    local result, mes = %s._fromMapSub( obj, val )
//    if not result then
//       return nil, mes
//    end
// ``` (self.getFullName( classTypeInfo.$baseTypeInfo )) );
//       }

//       self.writeln( '   local memInfo = {}' );

//       foreach memberNode in node.$memberList {
//          let funcTxt, nilable, child = self.getMapInfo( memberNode.$expType );
//          self.writeln(
//             '   table.insert( memInfo, { name = "%s", func = %s, nilable = %s, child = %s } )'
//             ( memberNode.$name.txt, funcTxt, nilable, child ) );
//       }

//       self.writeln( ```
//    local result, mess = _lune._fromMap( obj, val, memInfo )
//    if not result then
//       return nil, mess
//    end
//    return obj
// end```);
//    }
};


pub override fn convFilter.processExpCall(
   node: Nodes.ExpCallNode, opt: Opt ) mut
{
   let funcType = node.$func.$expType;
   
   switch self.processMode {
      case .Intermediate, .Prototype {
         if! let argList = node.$argList {

            let funcNode = node.$func;

            let mRetInfo;
            switch funcNode.$expType.$kind {
               case .Method {
                  mRetInfo = MRetInfo.Method( funcType );
               }
               case .Form {
                  mRetInfo = MRetInfo.Form;
               }
               case .FormFunc {
                  mRetInfo = MRetInfo.FormFunc( unwrap node.$func@@@Nodes.ExpRefNode );
               }
               default {
                  mRetInfo = MRetInfo.Func( node.$func );
               }
            }
            
            self.processCallWithMRet(
               node, getMRetFuncName( node ), getCRetType( node.$expTypeList ),
               #funcType.$argTypeInfoList, mRetInfo, argList );
         }
         return;
      }
   }


   let mut classTypeInfo:&Ast.TypeInfo! = getBelongClassType( node.$func );
  
   fn process() {
      if funcType.$kind == .Form {
         self.write( 'lns_call_form( _pEnv, ' );
         self.processVal2any( node.$func, node );
         if! let argList = node.$argList {
            if #argList.$expList > 0 {
               self.processCallArgList( funcType.$argTypeInfoList, argList );
            }
         }
         else {
            self.write( ', lns_global.ddd0' );
         }
         self.write( ' )' );

         return;
      }


      let mut wroteFuncFlag = false;
      let mut setArgFlag = false;

      fn fieldCall():bool {

         let! fieldNode = node.$func@@@Nodes.RefFieldNode {
            return true;
         };
         let prefixNode = fieldNode.$prefix;

      //    fn processSet(): bool {
      //       setArgFlag = true;
      //       wroteFuncFlag = true;

      //       switch fieldNode.$field.txt {
      //          case "add", "del" {
      //             filter( prefixNode, self, fieldNode );
      //             self.write( "[" );
      //             if! let argList = node.$argList {
      //                filter( argList, self, fieldNode );
      //             }
      //             self.write( "]" );
      //             switch fieldNode.$field.txt {
      //                case "add" {
      //                   self.write( "= true" );
      //                }
      //                case "del" {
      //                   self.write( "= nil" );
      //                }
      //             }
      //             return false;
      //          }
      //       }

      //       self.write( "_lune._Set_%s(" ( fieldNode.$field.txt ) );
      //       filter( prefixNode, self, fieldNode );
      //       return true;
      //    }

         let prefixType = prefixNode.$expType;

         fn processEnumAlge() {
            // wroteFuncFlag = true;
            // let fieldExpType = fieldNode.$expType;
            // let mut methodName = fieldNode.$field.txt;
            // if methodName == "get__txt" {
            //    methodName = "_getTxt";
            // }
            // self.write( "_%s( " ( methodName ) );
            // if fieldExpType.$staticFlag {
            //    setArgFlag = false;
            // }
            // else {
            //    filter( prefixNode, self, fieldNode );
            //    setArgFlag = true;
            // }
         }

         if node.$nilAccess {
      //       wroteFuncFlag = true;
      //       setArgFlag = true;
      //       switch prefixType.$kind {
      //          case .List, .Array {
      //             self.write( "_lune.nilacc( table.%s, nil, 'list', "
      //                         (fieldNode.$field.txt ) );
      //             filter( prefixNode, self, fieldNode );
      //          }
      //          default {
      //             self.write( "_lune.nilacc( " );
      //             filter( prefixNode, self, fieldNode );
      //             self.write( ", '%s', 'callmtd' " (fieldNode.$field.txt ) );
      //          }
      //       }
         }
         else {
            switch prefixType.$kind {
               // case .List, .Array {
               //    setArgFlag = true;
               //    wroteFuncFlag = true;
               //    self.write( "table.%s( " (fieldNode.$field.txt ) );
               //    filter( prefixNode, self, fieldNode );
               // }
               // case .Set {
               //    if not processSet() {
               //       return false;
               //    }
               // }
               case .Enum, .Alge {
                  processEnumAlge();
               }
               // case .Box {
               //    filter( prefixNode, self, fieldNode );
               //    self.write( "[1]" );
               //    return false;
               // }
               case .Class {
                  if prefixType.equals( Ast.builtinTypeString## ) {
                     wroteFuncFlag = true;
                     setArgFlag = true;
                     self.write( "mtd_lns_string_%s( _pEnv, " (fieldNode.$field.txt) );
                     filter( prefixNode, self, fieldNode );
                  }


                  
               //    if prefixType.isInheritFrom( Ast.builtinTypeMapping, nil ) and
               //       isGenericType( prefixType ) and
               //       ( fieldNode.$field.txt == "_fromMap" or
               //         fieldNode.$field.txt == "_fromStem" )
               //    {
               //       wroteFuncFlag = true;
               //       setArgFlag = true;
               //       filter( node.$func, self, node );
               //       self.write( "( " );
               //       if! let argList = node.$argList {
               //          filter( argList,  self, node );
               //          self.write( ", " );
               //       }
               //       self.outputAlter2MapFunc( self, prefixType.createAlt2typeMap(false) );
               //       self.write( ")" );
               //       return false;
               //    }
               }
            }
         }
         return true;
      }

      if not fieldCall() {
         return;
      }

      if! let refNode = node.$func@@@Nodes.ExpRefNode {
         let builtinFunc = TransUnit.getBuiltinFunc();

         if! let cFuncTxt = self.moduleCtrl.getBuiltinFuncNameFromType( refNode.$expType )
         {
            wroteFuncFlag = true;
            self.write( cFuncTxt .. "(" );
         }
         // elseif refNode.$token.txt == "super" {
         //    wroteFuncFlag = true;
         //    setArgFlag = true;
         //    let funcType = refNode.$expType;
         //    self.write( "%s.%s( self " ( self.getFullName( funcType.$parentInfo ),
         //                                 funcType.$rawTxt ) );
         // }
      }

      if not wroteFuncFlag {
         let funcSymList = node.$func.getSymbolInfo();
         if #funcSymList > 0 {
            let funcSym = funcSymList[ 1 ].getOrg();
            if! let cFuncName = self.moduleCtrl.getBuiltinFuncName( funcSym ) {
               wroteFuncFlag = true;
               self.write( cFuncName );
               self.write( "(" );
            }
         }
      }
      
      if not wroteFuncFlag {
         switch funcType.$kind {
            case .Method {
               if! let fieldNode = node.$func@@@Nodes.RefFieldNode {
                  //self.write( "l_call_method_0( _pEnv, " );
                  self.write( "%s( _pEnv, "
                              ( self.moduleCtrl.getCallMethodCName( funcType )));
                  self.processVal2any( fieldNode.$prefix, fieldNode );
                  //self.write( accessAny );
                  // self.write(
                  //    ",offsetof( lns_mtd_%s_t, %s )"
                  //    (self.getFullName( fieldNode.$prefix.$expType ), fieldNode.$field.txt ) );
               }
               wroteFuncFlag = true;
               setArgFlag = true;
            }
            case .Func {
               self.write( "%s( " ( self.moduleCtrl.getFuncName( funcType ) ) );
               wroteFuncFlag = true;
            }
            case .FormFunc {
               self.write( "%s( _pEnv, "
                           ( self.moduleCtrl.getCallFormName( funcType ) ));
               self.processVal2any( node.$func, node );
               wroteFuncFlag = true;
               setArgFlag = true;
            }
         }
      }
      
      if not wroteFuncFlag {
         // if node.$nilAccess {
         //    self.write( "_lune.nilacc( " );
         //    filter( node.$func, self, node );
         //    self.write( ", nil, 'call'" );
         //    wroteFuncFlag = true;
         // }
         // else {
         filter( node.$func, self, node );

         // switch funcType.$kind {
         //    case .FormFunc { 
         //       self.write( "->val.form.pFunc" );
         //    }
         // }

         
         self.write( "( " );
         // }
      }

      // if not setArgFlag {
      //    self.write( "_pEnv, " );


      //    if! let scope = funcType.$scope {
      //       if #scope$.$closureSymList > 0 {
      //          // クロージャの場合
      //          self.write( "lns_func2any( _pEnv, (lns_closure_t *)NULL, 0, false, %d"
      //                      (#scope$.$closureSymList) );
      //          foreach symbolInfo in scope.$closureSymList {
      //             self.write( ", %s" (symbolInfo.$name) );
      //          }
      //          self.write( ")" );
      //       }
      //       else {
      //          self.write( "NULL" );
      //       }
      //    }
      //    else {
      //       self.write( "NULL" );
      //    }
      // }

      // if! let argList = node.$argList {
      //    let mut expList:List<&Nodes.Node> = [];
      //    foreach expNode in argList.$expList {
      //       if expNode.$expType.$kind ~= .Abbr {
      //          expList.insert( expNode );
      //       }
      //    }

      //    if #expList > 0 {
      //       self.processCallArgList( funcType, node.$argList );
      //    }
      // }
      // self.write( " )" );

      self.processCall( funcType, setArgFlag, node.$argList );
   }


   fn call() {
      let mut isMret = false;
      if! let argList = node.$argList {
         if! let mRetExp = argList.$mRetExp {
            // 多値の引数を含む場合
            isMret = true;
            self.write( "%s( _pEnv" ( getMRetFuncName( node ) ) );

            let funcNode = node.$func;
            switch funcNode.$expType.$kind {
               case .Method {
                  if! let fieldNode = node.$func@@@Nodes.RefFieldNode {
                     self.write( ", " );
                     self.processVal2any( fieldNode.$prefix, fieldNode );
                  }
               }
               case .Form, .FormFunc {
                  self.write( ", " );
                  self.processVal2any( node.$func, node );
               }
            }
            foreach argNode, index in argList.$expList {
               if index <= mRetExp.$index {
                  self.write( ", " );
                  filter( argNode, self, argList );
               }
            }
            self.write( ")" );
         }
      }
      if not isMret {
         process();
      }

      processAlterAccessVal(
         self.stream, funcType.$retTypeInfoList, node.$expTypeList );
         
      // let retTypeInfoList = funcType.$retTypeInfoList;
      // if #retTypeInfoList == 1 {
      //    if retTypeInfoList[ 1 ].$kind == .Alternate {
      //       self.write( getAccessValFromStem( node.$expType ) );
      //    }
      // }
   }


   let retTypeInfoList = funcType.$retTypeInfoList;
   if #retTypeInfoList == 1 {
      // 戻り値が alternat だった時に対応する処理
      processAlterToActualType(
         self.stream, self.moduleCtrl, retTypeInfoList[ 1 ], node.$expType, call );
   }
   else {
      call();
   }
   
};

pub override fn convFilter.processExpAccessMRet(
   node: Nodes.ExpAccessMRetNode, opt:Opt ) mut

{
   processGetMRet( self.stream, self.moduleCtrl, node.$expType, node.$index - 1 );
};


pub override fn convFilter.processExpList(
   node: Nodes.ExpListNode, opt: Opt ) mut
{
   let expList = node.get_expList();
   //let expList = node.$expList;
   foreach exp, index in expList {
      if exp.$expType.$kind == .Abbr {
         break;
      }
      if index > 1 {
         self.write( ", " );
      }
      filter( exp, self, node );
   }
};

pub override fn convFilter.processExpOp1(
   node: Nodes.ExpOp1Node, opt: Opt ) mut
{
   let mut op = node.$op.txt;
   // if op == ",,," or op == ",,,," {
   //     filter( node.$exp,  self, node );
   // }
   switch op { 
      case "~", "+", "-" {
         self.write( op );
         self.accessPrimVal( node.$exp, node );
      }
      case "not" {
         self.write( "lns_op_not( _pEnv, " );
         self.processVal2stem( node.$exp, node );
         self.write( ")" );
      }
      case "#" {
         let expType = node.$exp.$expType.$srcTypeInfo;
         if expType.$kind == .List {
            self.write( "lns_mtd_List_len( _pEnv, " );
            self.processVal2any( node.$exp, node );
            self.write( ")" );
         }
         elseif expType == Ast.builtinTypeString {
            self.processVal2any( node.$exp, node );
            self.write( "->val.str.len" );
         }
         else {
            Util.err( "not support type -- %s" (expType.getTxt(##)) );
         }
      }
      default {
         Util.err( "not support op -- %s" (op) );
      }
   }
};

pub override fn convFilter.processExpMultiTo1(
   node: Nodes.ExpMultiTo1Node, opt: Opt ) mut
{
   self.write( "lns_fromDDD( " );
   filter( node.$exp, self, node );
   self.write( accessAny );
   self.write( ", 0 )" );
   if node.$exp.$expType.$kind == .DDD and
      Ast.isNumberType( node.$expType.$srcTypeInfo.$nonnilableType )
   {
      self.write( accessAny );
   }
   else {
      self.write( getAccessValFromStem( node.$exp.$expType ) );
   }
}

pub override fn convFilter.processExpCast(
   node: Nodes.ExpCastNode, opt: Opt ) mut
{
   let exp = node.$exp;
   let expType = exp.$expType;
   let nodeExpType = node.$expType;
   let castType = node.$castType;
   switch node.$castKind {
      case .Implicit {
         switch castType.$kind {
            case .IF {   
               if expType.$kind == .Class {
                  self.write( "lns_getIF( _pEnv, &lns_if_%s( "
                              (self.moduleCtrl.getClassCName( expType )));
                  self.processVal2any( node.$exp, node );
                  //filter( node.$exp, self, node );
                  //self.write( accessAny );
                  self.write( ")->%s )" ( self.moduleCtrl.getClassCName( castType ) ) );
               }
            }
            case .FormFunc {
               self.write( self.getFunc2any( expType ) );
            }
            case .Form {
               // pending 本来は処理が異なる
               self.write( self.getFunc2any( expType ) );
            }
            default {
               filter( exp, self, node );
            }
         }
      }
      case .Force {
         if isStemType( expType ) {
            switch castType {
               case Ast.builtinTypeInt, Ast.builtinTypeChar {
                  self.write( "lns_stem2int( " );
                  filter( exp, self, node );
                  self.write( ")" );
               }
               case Ast.builtinTypeReal {
                  self.write( "lns_stem2real( " );
                  filter( exp, self, node );
                  self.write( ")" );
               }
               case Ast.builtinTypeBool {
                  self.write( "lns_stem2bool( " );
                  filter( exp, self, node );
                  self.write( ")" );
               }
               default {
                  // 強制キャストは実行時の処理に任せる。
                  // ランタイムエラーになってもしかたがない。
                  if getValKind( castType ) == .Any {
                     self.processVal2any( exp, node );
                  }
                  else {
                     filter( exp, self, node );
                  }
               }
            }
         }
         else {
            filter( exp, self, node );
         }
      }
      case .Normal {
            error( "not support cast" );
      }
   }
   // if node.$force {
   //    if node.$expType.equals( Ast.builtinTypeInt ##) {
   //       self.write( "math.floor(" );
   //       filter( node.$exp,  self, node );
   //       self.write( ")" );
   //    }
   //    else {
   //       filter( node.$exp,  self, node );
   //    }
   // }
   // else {
   //    self.write( "_lune.__Cast( " );
   //    filter( node.$exp,  self, node );
   //    let castKind;
   //    let mut classObj = "nil";
   //    switch node.$expType.$nonnilableType {
   //       case Ast.builtinTypeInt {
   //          castKind = LuaMod.CastKind.Int;
   //       }
   //       case Ast.builtinTypeReal {
   //          castKind = LuaMod.CastKind.Real;
   //       }
   //       case Ast.builtinTypeString {
   //          castKind = LuaMod.CastKind.Str;
   //       }
   //       default {
   //          castKind = LuaMod.CastKind.Class;
   //          classObj = self.getFullName( node.$expType.$nonnilableType );
   //       }
   //    }
   //    self.write( ", %d, %s )" ( castKind, classObj) );
   // }
};


pub override fn convFilter.processExpParen(
   node: Nodes.ExpParenNode, opt: Opt ) mut
{
   if #node.$exp.$expTypeList == 1 {
      self.write( "(" );
      self.accessPrimVal( node.$exp, node );
      self.write( " )" );
   }
   else {
      processToIF( self.stream, self.moduleCtrl, node.$expType, fn () {
                      self.accessPrimVal( node.$exp, node );
                   });
   }
};



/**
form から 関数をコールする wrapper を作成。
*/
fn convFilter.processWrapForm2Func( funcType:&Ast.TypeInfo ) mut
{
   self.write( "static %s _wrap_%s_%d( %s _pEnv, %s _pForm, "
               ( cTypeStem, funcType.$rawTxt, funcType.$typeId,
                 cTypeEnvP, cTypeAnyP ) );  
   foreach argType, index in funcType.$argTypeInfoList {
      self.write( ", %s arg%d" (getCType( argType ), index ) );
   }
   self.writeln( ")" );
   self.writeln( "{" );
   self.writeln( 'return %s( _pEnv, _pForm' );
   foreach argType, index in funcType.$argTypeInfoList {
      
   }
   self.writeln( "}" );
}

fn convFilter.processAndOr( node: Nodes.ExpOp2Node,
                            opTxt: str, parent: &Nodes.Node ) mut
{
   fn isAndOr( exp:&Nodes.Node ) : bool {
      if! let parentNode = exp@@@Nodes.ExpOp2Node {
         switch parentNode.$op.txt {
            case "and", "or" {
               return true;
            }
         }
      }
      return false;
   }
   
   let mut firstFlag = not isAndOr( parent );
   if firstFlag {
      self.writeln( "lns_popVal( _pEnv, lns_incStack( _pEnv ) ||" );
      self.pushIndent( ## );
   }

   let opCC;
   if opTxt == "and" {
      opCC = "&&";
   }
   else {
      opCC = "||";
   }
   
   if isAndOr( node.$exp1 ) {
      filter( node.$exp1, self, node );
   }
   else {
      self.write( "lns_setStackVal( _pEnv, " );
      self.processVal2stem( node.$exp1, node );
      self.write( ") " );
      //self.writeln( opCC );
   }
   if isAndOr( node.$exp2 ) {
      filter( node.$exp2, self, node );
   }
   else {
      self.writeln( opCC );
      self.write( "lns_setStackVal( _pEnv, " );
      self.processVal2stem( node.$exp2, node );
      self.write( ") " );
   }

   if firstFlag {
      self.write( ")" );

      if not isStemType( node.$expType ) {
         self.write( getAccessPrimValFromStem( false, node.$expType, 0 ) );
      }
      
      self.popIndent();
   }
}

fn convFilter.processConcat( node:&Nodes.ExpOp2Node, parent:&Nodes.Node ) mut
{
   self.write( "lns_strconcat( _pEnv, " );
   self.processVal2any( node.$exp1, node );
   self.write( ", " );
   self.processVal2any( node.$exp2, node );
   self.write( ")" );
}



pub override fn convFilter.processExpOp2(
   node: Nodes.ExpOp2Node, opt: Opt ) mut
{
   let mut opTxt = node.$op.txt;

   switch opTxt {
      case "=" {
         let workParent:&Nodes.Node;
         //let symbolList = node.$exp1.getSymbolInfo();
         let expList;
         let mRetExp:&Nodes.MRetExp!;
         if! let expListNode = node.$exp2@@@Nodes.ExpListNode {
            expList = expListNode.$expList;
            mRetExp = expListNode.$mRetExp;
            workParent = expListNode;
         }
         else {
            expList = [ node.$exp2 ];
            mRetExp = nil;
            workParent = node;
         }
         
         self.processSetValToNode( node, node.$exp1, expList, mRetExp );
      }
      case "and", "or" {
         self.processAndOr( node, opTxt, opt.node );
      }
      case ".." {
         self.processConcat( node, opt.node );
      }
      default {
         if! Ast.bitBinOpMap[ opTxt ] {
            // ビット演算の処理
            switch _exp {
               case .LShift {
                  opTxt = "<<";
               }
               case .RShift {
                  opTxt = ">>";
               }
            }
            //self.accessPrimVal( node.$exp1, node );
            filter( node.$exp1, self, node );
            self.write( " " .. opTxt .. " " );
            //self.accessPrimVal( node.$exp2, node );
            filter( node.$exp2, self, node );
         }
         else {
            if Ast.compOpSet.has( opTxt ) {
               let valKind1 = getValKind( node.$exp1.$expType );
               let valKind2 = getValKind( node.$exp2.$expType );
               if valKind1 == .Stem or valKind2 == .Stem {
                  if opTxt ~= "==" {
                     self.write( "!" );
                  }
                  self.write( "lns_equals( " );
                  self.processVal2stem( node.$exp1, node );
                  self.write( "," );
                  self.processVal2stem( node.$exp2, node );
                  self.write( ")" );
               }
               elseif valKind1 == .Any and valKind2 == .Any {
                  if opTxt ~= "==" {
                     self.write( "!" );
                  }
                  self.write( "lns_equals_any( " );
                  self.processVal2any( node.$exp1, node );
                  self.write( "," );
                  self.processVal2any( node.$exp2, node );
                  self.write( ")" );
               }
               else {
                  self.accessPrimVal( node.$exp1, node );
                  // filter( node.$exp1, self, node );

                  self.write( " " .. opTxt .. " " );
                  self.accessPrimVal( node.$exp2, node );
                  // filter( node.$exp2, self, node );
               }
            }
            elseif Ast.mathCompOpSet.has( opTxt ) {
               self.accessPrimVal( node.$exp1, node );
               // filter( node.$exp1, self, node );

               self.write( " " .. opTxt .. " " );
               self.accessPrimVal( node.$exp2, node );
               // filter( node.$exp2, self, node );
            }
            else {
               // self.accessPrimVal( node.$exp1, node );
               filter( node.$exp1, self, node );
               self.write( " " .. opTxt .. " " );
               // self.accessPrimVal( node.$exp2, node );
               filter( node.$exp2, self, node );

            }
         }
      }
   }
};

pub override fn convFilter.processExpRef(
   node: Nodes.ExpRefNode, opt: Opt ) mut
{
   if self.processMode == .Immediate {
      self.accessSymbolSet.add( node.$symbolInfo );
   }
   
   if node.$symbolInfo.$name == "super" {
      let funcType = node.$expType;
      self.write( "%s.%s" ( self.getFullName( funcType.$parentInfo ),
                            funcType.$rawTxt ) );
   }
   elseif node.$symbolInfo.$name == "__mod__" {
      self.write( "*lns_module_path" );
   }
   elseif node.$symbolInfo.$name == "..." {
      self.write( "_pDDD" );
   }
   else {
      if! let cFuncName = self.moduleCtrl.getBuiltinFuncNameFromType( node.$expType ) {
         self.write( cFuncName );
      }
      else {
         let symbolInfo = node.$symbolInfo;
         let valKind = self.scopeMgr.getSymbolValKind( symbolInfo );
         if valKind == .Var {
            self.write( "%s->stem" ( self.moduleCtrl.getSymbolName( symbolInfo )) );
            self.write( getAccessValFromStem( symbolInfo.$typeInfo ) );
         }
         else {
            // if symbolInfo.$accessMode == .Pub and
            //    symbolInfo.$kind == Ast.SymbolKind.Var
            // {
            //    if self.needModuleObj {
            //       self.write( "_moduleObj." );
            //    }
            // }
            if symbolInfo.$kind == .Fun or symbolInfo.$typeInfo.$kind == .Func {
               self.write( self.moduleCtrl.getFuncName( symbolInfo.$typeInfo ) );
            }
            else {
               //self.write( node.$symbolInfo.$name );
               if valKind == .Any and symbolInfo.$kind == .Var {
                  self.write( "(*%s)" (self.moduleCtrl.getSymbolName( symbolInfo ) ) );
               }
               else {
                  self.write( self.moduleCtrl.getSymbolName( symbolInfo ) );
               }
            }
         }
      }
   }
};

pub override fn convFilter.processExpRefItem(
   node: Nodes.ExpRefItemNode, opt: Opt ) mut
{
   // if node.$nilAccess {
   //    self.write( "_lune.nilacc( " );
   //    filter( node.$val, self, node );
   //    self.write( ", nil, 'item', " );
   //    if! node.$index {
   //       filter( _exp, self, node );
   //    }
   //    else {
   //       self.write( "'%s'" ( unwrap node.$symbol ) );
   //    }
   //    self.write( ")" );
   // }
   // else {

   let val = node.$val;
   let valType = val.$expType;
   
   if valType.equals( Ast.builtinTypeString ##) {
      self.accessPrimVal( val, node );
      self.write( "->val.str.pStr[" );
      if! let indexNode = node.$index {
         filter( indexNode, self, node );
      }
      else {
         error( "index is nil" );
      }
      self.write( "- 1 ]" );
   }
   else {
      processToIF( self.stream, self.moduleCtrl, node.$expType,
                   fn () {
                      switch valType.$kind {
                         case .List { 
                            self.write( "lns_mtd_List_refAt( _pEnv, " );
                            self.processVal2any( val, node );
                            self.write( ", " );
                            self.accessPrimVal( unwrap node.$index, node );
                            self.write( ")" );
                            self.write( getAccessValFromStem(
                               valType.$itemTypeInfoList[ 1 ] ) );
                         }
                         case .Map {
                            self.write( "lns_mtd_Map_get( _pEnv, " );
                            self.processVal2any( val, node );
                            self.write( ", " );
                            if! let index = node.$index {
                               self.processVal2stem( index, node );
                            }
                            else {
                               self.write( getLiteralStrAny( unwrap node.$symbol ) );
                            }
                            self.write( ")" );
                         }
                         default {
                            Util.err( "not support:%d:%d" (__line__, node.$pos.lineNo) );
                         }
                      }
                   } );
   }
   // }
};

pub override fn convFilter.processRefField(
   node: Nodes.RefFieldNode, opt: Opt ) mut
{
   if! let symbolInfo = node.$symbolInfo {
      if symbolInfo.$typeInfo.$kind == .Enum {
         if symbolInfo.$kind == .Mbr {
            if symbolInfo.$namespaceTypeInfo.$kind == .Enum {
               // enum 値の場合
               self.write( self.moduleCtrl.getEnumTypeName( symbolInfo.$typeInfo ) );
               self.write( "__%s" ( self.moduleCtrl.getSymbolName( symbolInfo )) );
               return;
            }
         }
         else {
            Util.err( "illegal access" );
         }
      }

      switch symbolInfo.$kind {
         case .Mbr {
            if node.$prefix.$expType.$kind == .Class {
               if symbolInfo.$staticFlag {
                  self.write( self.moduleCtrl.getClassMemberName( symbolInfo ) );
               }
               else {
                  let className = self.moduleCtrl.getClassCName( node.$prefix.$expType );
                  self.write( "lns_obj_%s( " (className) );
                  // if! let expRefNode = node.$prefix@@@Nodes.ExpRefNode {
                  //    // self.write( getSymbolName( expRefNode.$symbolInfo ));
                  //    filter( node.$prefix, self, node );
                  // }
                  // else {
                  //    filter( node.$prefix, self, node );
                  // }
                  self.processVal2any( node.$prefix, node );
                  self.write( ")->%s" (node.$field.txt) );
               }
            }
         }
         case .Mtd {
            if not symbolInfo.$staticFlag {
               Util.err( "not support yet. instanse method." );
            }
            self.write( self.moduleCtrl.getMethodCName( symbolInfo.$typeInfo ) );
         }
      }
   }
   
   // let parent = opt.node;

   // if node.$nilAccess {
   //    self.write( '_lune.nilacc( ' );
   //    filter( prefix,  self, node );
   //    self.write( ', "%s" )' (node.$field.txt) );
   // }
   // else {
   //    filter( prefix,  self, node );

   //    let mut delimit = ".";
   //    if parent.$kind == Nodes.NodeKind.$ExpCall {
   //       if node.get_expType().get_kind() == Ast.TypeInfoKind.Method {
   //          delimit = ":";
   //       }
   //       else {
   //          delimit = ".";
   //       }
   //    }
   //    let fieldToken = node.get_field();
   //    self.write( delimit .. fieldToken.txt );
   // }
};

pub override fn convFilter.processExpOmitEnum(
   node: &Nodes.ExpOmitEnumNode, opt: Opt ) mut
{
   self.write( self.moduleCtrl.getEnumValCName( node.$expType, node.$valInfo.$name ) );
   // match node.$valInfo.$val {
   //    case .Int( val ) {
   //       self.write( "%d" (val) );
   //    }
   //    case .Real( val ){
   //       self.write( "%g" (val) );
   //    }
   //    case .Str( val ) {
   //       self.write( "\"%s\"" (val) );
   //    }
   // }
   
   // self.write( "%s.%s" ( self.getFullName( node.$expType ), node.$valToken.txt ) );
};

pub override fn convFilter.processGetField(
   node: Nodes.GetFieldNode, opt: Opt ) mut
{
   let prefixNode = node.get_prefix();
   let prefixType = prefixNode.$expType;
   let fieldTxt = node.get_field().txt;

   if prefixType.$kind == .Enum {
      let mut enumFullName = self.moduleCtrl.getEnumTypeName( prefixType );
      switch fieldTxt {
         case "_allList" {
            self.write( "%s_get__allList( _pEnv )" (enumFullName) );
         }
         case "_txt" {
            self.write( "%s_get__txt( _pEnv, " (enumFullName) );
            filter( prefixNode, self, node );
            self.write( ")" );
         }
      }
   }
   elseif prefixType.$kind == .Class or prefixType.$kind == .IF {
      let getterType = unwrap prefixType.$scope$.getTypeInfoField$(
         "get_%s" (fieldTxt), true, unwrap prefixType.$scope, scopeAccess );

      fn process() {
         self.write(
            "%s( _pEnv, " ( self.moduleCtrl.getCallMethodCName( getterType ) ) );
         self.processVal2any( prefixNode, node );
         self.write( ")" );

         processAlterAccessVal(
            self.stream, getterType.$retTypeInfoList, node.$expTypeList );
         // if #node.$expTypeList == 1 {
         //    if getterType.$retTypeInfoList[1].$kind == .Alternate {
         //       self.write( getAccessValFromStem( node.$expType ) );
         //    }
         // }
      }

      if #node.$expTypeList == 1 {
         processAlterToActualType(
            self.stream, self.moduleCtrl,
            getterType.$retTypeInfoList[1], node.$expType, process );
      }
      else {
         process();
      }
   }

   
   // let mut fieldTxt = node.get_field().txt;
   // if fieldTxt == "_txt" and
   //     ( prefixType.$kind == .Enum or prefixType.$kind == .Alge )
   // {
   //    self.write( "%s:_getTxt( " (self.getFullName( prefixType ) ) );
   //    filter( prefixNode, self, node );
   //    self.writeln( ")" );
   // }
   // else {
   //    filter( prefixNode,  self, node );
   //    let mut delimit = ".";
   //    if node.get_getterTypeInfo().get_kind() == Ast.TypeInfoKind.Method {
   //       delimit = ":";
   //    }
   //    else {
   //       delimit = ".";
   //    }

   //    fieldTxt = "get_%s()" ( fieldTxt );
   //    self.write( delimit .. fieldTxt );
   // }
};


pub override fn convFilter.processReturn(
   node: Nodes.ReturnNode, opt: Opt ) mut
{
   let retTypeInfoList = self.currentRoutineInfo.$funcInfo.$retTypeInfoList;

   let blockStart;
   if! let expListNode = node.$expList {
      let expList = expListNode.$expList;
      let retKind = getRetKind( retTypeInfoList );
      let mut needSetRet = true;
      self.writeln( "{" );
      blockStart = true;
      self.pushIndent( ## );
      self.write( "%s _ret = " (getCRetType(retTypeInfoList)) );
      if #retTypeInfoList >= 2 {
         self.processCreateMRet( retTypeInfoList, expList, node );
      }
      elseif #retTypeInfoList == 1 {
         switch retKind {
            case .Stem {
               self.processVal2stem( expList[ 1 ], node );
            }
            case .Any {
               self.processVal2any( expList[ 1 ], node );
            }
            case .Prim {
               filter( expList[ 1 ], self, node );
            }
            default {
               Util.err( "no support -- %d" (__line__) );
            }
         }
      }
      else {
         //self.write( "_pEnv->pNilStem" );
      }
      self.writeln( ";" );
      if needSetRet {
         switch retKind {
            case .Stem {
               self.writeln( "lns_setRet( _pEnv, _ret );" );
            }
            case .Any {
               self.writeln( "lns_setRet( _pEnv, LNS_STEM_ANY( _ret ) );" );
            }
            case .Prim {
            }
            default {
               Util.err( "no support -- %d" (__line__) );
            }
         }
      }
   }
   else {
      blockStart = false;
   }

   if self.currentRoutineInfo.$blockDepth == 1 {
      self.writeln( "lns_leave_block( _pEnv );" );
   }
   else {
      self.writeln( "lns_leave_blockMulti( _pEnv, %d );"
                    ( self.currentRoutineInfo.$blockDepth ) );
   }


   if #retTypeInfoList ~= 0 {
      self.writeln( "return _ret;" );
   }
   else {
      self.writeln( "return;" );
   }

   if blockStart {
      self.popIndent();
      self.writeln( "}" );
   }
};

pub override fn convFilter.processTestBlock( node: Nodes.TestBlockNode, opt: Opt ) mut
{
   if self.enableTest {
      self.writeln( 'printf( "%s:\\n" );' (node.$name.txt) );
      filter( node.$block, self, node );

      // pending: 本来はテスト実行と、結果出力は TestCtrl で行なうが、暫定でここで行なう。
      self.writeln( "lns_init_lune_base_Testing( _pEnv );" );
      self.writeln( "lune_base_Testing_outputAllResult( _pEnv, l_var_lns_io_stderr );" );
   }
}

pub override fn convFilter.processProvide(
   node: Nodes.ProvideNode, opt: Opt ) mut
{
}

pub override fn convFilter.processAlias(
   node: &Nodes.AliasNode, opt: Opt ) mut
{
   // self.write( "local %s = " (node.$newName) );
   // filter( node.$srcNode, self, node );
   // if Ast.isPubToExternal( node.$expType.$accessMode ) {
   //    self.write( "\n_moduleObj.%s = %s" (node.$newName, node.$newName) );
   // }
}

pub override fn convFilter.processBoxing(
   node: Nodes.BoxingNode, opt: Opt ) mut
{
   // self.write( "{" );

   // filter( node.$src, self, node );

   // self.write( "}" );
}

pub override fn convFilter.processUnboxing(
   node: Nodes.UnboxingNode, opt: Opt ) mut
{
   // filter( node.$src, self, node );
   // self.write( "[1]" );
}


fn convFilter.processLiteralVal( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   if self.processMode ~= .Immediate {
      let symbolList = exp.getSymbolInfo();
      if #symbolList > 0 {
         let work, valKind = self.scopeMgr.getCTypeForSym( symbolList[ 1 ] );
         if valKind ~= .Prim {
            // filter( exp, self, parent );
            self.processVal2stem( exp, parent );
            return;
         }
      }
   }
   let mut valType = exp.$expType.$srcTypeInfo;
   if! let enumType = valType@@@Ast.EnumTypeInfo {
      valType = enumType.$valTypeInfo;
   }
   
   switch valType {
      case Ast.builtinTypeInt, Ast.builtinTypeChar {
         self.write( "lns_imdInt( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeReal {
         self.write( "lns_imdReal( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeBool {
         self.write( "lns_imdBool( " );
         filter( exp, self, parent );
         self.write( ")" );
      }
      case Ast.builtinTypeString {
         if! let strNode = exp@@@Nodes.LiteralStringNode { 
            if not strNode.$expList {
               self.write( "lns_imdStr( %s )" (strNode.$token.txt ) );
               return;
            }
         }
         self.write( "lns_imdAny( " );
         filter( exp, self, parent );
         //self.write( accessAny );
         self.write( ")" );
      }
      default {
         switch valType.$kind {
            case .List, .Set, .Map, .Array, .Class {
               self.write( "lns_imdAny( " );
               filter( exp, self, parent );
               //self.write( accessAny );
               self.write( ")" );
            }
            default {
               Util.err( "illegal type -- %s" (valType.getTxt(##)) );
            }
         }
      }
   }
}

fn getLiteralListFuncName( node: &Nodes.LiteralListNode ): str {
   return "lns_list_%X" (node.$id);
}

fn convFilter.processLiteralNode( exp:&Nodes.Node, parent:&Nodes.Node ) mut {
   switch exp.$kind {
      case Nodes.NodeKind.$LiteralList,
           Nodes.NodeKind.$LiteralMap,
           Nodes.NodeKind.$LiteralArray,
           Nodes.NodeKind.$LiteralSet
      {
         self.processingNode = exp;
         filter( exp, self, parent );
      }
      default {
         self.pushStream();
         filter( exp, self, parent );
         self.popStream();
      }
   }
}

fn convFilter.processLiteralListSub(
   collectionType:str, node:&Nodes.Node,
   expListNodeOrg:&Nodes.ExpListNode!, literalFuncName:str ) mut
{
   if self.processedNodeSet.has( node ) {
      if! let set = self.literalNode2AccessSymbolSet[ node ] { 
         foreach symbol in set.$list {
            self.accessSymbolSet.add( symbol );
         }
      }
      return;
   }
   self.processedNodeSet.add( node );
   let! expListNode = expListNodeOrg {
      return;
   };
   if #expListNode.$expList == 0 {
      return;
   }

   foreach exp in expListNode.$expList {
      self.processLiteralNode( exp, node );
   }
   self.processingNode = node;
   
   self.write(
      "static %s %s( %s _pEnv" (cTypeAnyP, literalFuncName, cTypeEnvP ) );
   foreach symbol in self.accessSymbolSet.$list {
      let valKind = self.scopeMgr.getSymbolValKind( symbol );
      let ctype;
      // if valKind == .Any {
      //    ctype = cTypeAnyP;
      // }
      // else {
         ctype = self.scopeMgr.getCTypeForSym( symbol );
      // }
      self.write( ", %s %s" ( ctype, self.moduleCtrl.getSymbolName( symbol ) ) );
   }
   self.writeln( ")" );
   self.writeln( "{" );
   
   self.pushIndent(##);
   self.write( "lns_imd%s( list" ( collectionType ) );
   self.pushIndent( ## );
   foreach exp in expListNode.$expList {
      self.write( ", " );
      self.processLiteralVal( exp, node );
   }
   self.popIndent();
   self.writeln( ");" );
   self.writeln( "return lns_create%s( _pEnv, list );" ( collectionType ) );
   self.popIndent();
   self.writeln( "}" );

   self.literalNode2AccessSymbolSet[ node ] = self.accessSymbolSet.clone();
}

pub override fn convFilter.processLiteralList(
   node: Nodes.LiteralListNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralListSub(
         "List", node, node.$expList, getLiteralListFuncName( node ) );
   }
   else {
      if node.$expList {
         self.write( "%s( _pEnv" ( getLiteralListFuncName( node ) ) );
         let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
            return;
         };
         foreach symbol in symbolSet.$list {
            self.write( ", %s" ( self.moduleCtrl.getSymbolName( symbol ) ) );
         }
         self.write( ")" );
      }
      else {
         self.write( "lns_class_List_new( _pEnv )" );
      }
   }
};


fn getLiteralSetFuncName( node: &Nodes.LiteralSetNode ): str {
   return "lns_set_%X" (node.$id);
}

pub override fn convFilter.processLiteralSet(
   node: Nodes.LiteralSetNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralListSub(
         "Set", node, node.$expList, getLiteralSetFuncName( node ) );
   }
   else {
      if node.$expList {
         self.write( "%s( _pEnv" ( getLiteralSetFuncName( node ) ) );
         let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
            return;
         };
         foreach symbol in symbolSet.$list {
            self.write( ", %s" ( self.moduleCtrl.getSymbolName( symbol ) ) );
         }
         self.write( ")" );
      }
      else {
         self.write( "lns_class_Set_new( _pEnv )" );
      }
   }
};


fn getLiteralMapFuncName( node: &Nodes.LiteralMapNode ): str {
   return "lns_map_%X" (node.$id);
}

fn convFilter.processLiteralMapSub( node:&Nodes.LiteralMapNode ) mut
{
   if self.processedNodeSet.has( node ) {
      if! let set = self.literalNode2AccessSymbolSet[ node ] { 
         foreach symbol in set.$list {
            self.accessSymbolSet.add( symbol );
         }
      }
      return;
   }
   self.processedNodeSet.add( node );
   let pairList = node.$pairList;
   if #pairList == 0 {
      return;
   }

   foreach pair in pairList {
      self.processLiteralNode( pair.$key, node );
      self.processLiteralNode( pair.$val, node );
   }
   self.processingNode = node;
   
   self.write(
      "static %s %s( %s _pEnv" (cTypeAnyP, getLiteralMapFuncName( node ), cTypeEnvP ) );
   foreach symbol in self.accessSymbolSet.$list {
      self.write( ", %s %s" (self.scopeMgr.getCTypeForSym( symbol ),
                              self.moduleCtrl.getSymbolName( symbol ) ) );             
   }
   self.writeln( ")" );
   self.writeln( "{" );
   
   self.pushIndent(##);
   self.write( "lns_imdMap( list" );
   self.pushIndent( ## );
   foreach pair in pairList {
      self.writeln( ", " );
      self.write( "{ " );
      self.processLiteralVal( pair.$key, node );
      self.write( ", " );
      self.processLiteralVal( pair.$val, node );
      self.write( "} " );
   }
   self.popIndent();
   self.writeln( ");" );
   self.writeln( "return lns_createMap( _pEnv, list );" );
   self.popIndent();
   self.writeln( "}" );

   self.literalNode2AccessSymbolSet[ node ] = self.accessSymbolSet.clone();
}


pub override fn convFilter.processLiteralMap(
   node: Nodes.LiteralMapNode, opt: Opt ) mut
{
   if self.processMode == .Immediate and self.processingNode == node {
      self.processLiteralMapSub( node );
   }
   else {
      if #node.$pairList > 0 {
         self.write( "%s( _pEnv" ( getLiteralMapFuncName( node ) ) );
         let! symbolSet = self.literalNode2AccessSymbolSet[ node ] {
            return;
         };
         foreach symbol in symbolSet.$list {
            self.write( ", %s" ( self.moduleCtrl.getSymbolName( symbol ) ) );
         }
         self.write( ")" );
      }
      else {
         self.write( "lns_class_Map_new( _pEnv )" );
      }
   }
};

pub override fn convFilter.processLiteralArray(
   node: Nodes.LiteralArrayNode, opt: Opt ) mut
{
   // self.write( "{" );

   // if! node.$expList {
   //    filter( _exp, self, node );
   // }

   // self.write( "}" );
};


pub override fn convFilter.processLiteralChar(
   node: Nodes.LiteralCharNode, opt: Opt ) mut
{
   self.write( string.format( "%d", node.$num ) );
};

pub override fn convFilter.processLiteralInt(
   node: Nodes.LiteralIntNode, opt: Opt ) mut
{
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralReal(
   node: Nodes.LiteralRealNode, opt: Opt ) mut
{
   self.write( node.$token.txt );
};

pub override fn convFilter.processLiteralString(
   node: Nodes.LiteralStringNode, opt: Opt ) mut
{
   let mut txt = node.$token.txt;
   if string.find( txt, '^```' ## ) {
      txt = ("%q" ( txt.sub( 4, -4 ) )).gsub( "\\\n", "\\n" );
   }
   elseif string.find( txt, "^'" ## ) {
      txt = '%q' ( txt.sub( 2, -2 ) );
   }
   txt = txt.gsub( "\\9", "\\t" );

   switch self.processMode {
      case .Prototype {
         if! let expListNode = node.$expList {
            if! let mRetExp = expListNode.$mRetExp {
               self.processCallWithMRet(
                  node, getMRetFuncName( node ), cTypeAnyP, #expListNode.$expList,
                  MRetInfo.Format( txt, expListNode ), expListNode );
            }
            else {
               self.write( "static %s lns_litstr_%d( %s _pEnv"
                             (cTypeAnyP, node.$id, cTypeEnvP ) );
               foreach exp, index in expListNode.$expList {
                  self.write( ", %s arg%d" ( cTypeStem, index ) );
               }
               self.writeln( ");" );
            }
         }
         return;
      }
      case .StringFormat {
         if! let expListNode = node.$expList {
            if! let mRetExp = expListNode.$mRetExp {
               //self.write( "%s( _pEnv" ( getMRetFuncName( node ) ) );
               // foreach exp, index in expListNode.$expList {
               //    if index > mRetExp.$index {
               //       break;   
               //    }
               //    self.write( ", " );
               //    filter( exp, self, node );
               // }
               self.processCallWithMRet(
                  node, getMRetFuncName( node ), cTypeAnyP, #expListNode.$expList,
                  MRetInfo.Format( txt, expListNode ), expListNode );
            }
            else {
               self.write( "static %s lns_litstr_%d( %s _pEnv"
                  (cTypeAnyP, node.$id, cTypeEnvP ) );
               foreach exp, index in expListNode.$expList {
                  self.write( ", %s arg%d" ( cTypeStem, index ) );
               }
               self.writeln( ")" );
               self.writeln( "{" );
               self.pushIndent( ## );

               self.write( "return mtd_lns_string_format( _pEnv, " );
               self.write( getLiteralStrAny( txt ) );
               self.write( ", " );

               let expList = expListNode.$expList;
               self.write( "lns_createDDD" );
               let lastExp = expList[ #expList ];
               self.write( "( _pEnv, %s, %d" ( Nodes.hasMultiValNode( lastExp ), #expList ) );

               for index = 1, #expList {
                  self.write( ", arg%d" (index));
               }
               self.writeln( ") );" );
               
               self.popIndent();
               self.writeln( "}" );
            }
         }
         return;
      }
   }

  
   if! let expListNode = node.$expList {
      if! let mRetExp = expListNode.$mRetExp {
         self.write( "%s( _pEnv" ( getMRetFuncName( node ) ) );
         foreach exp, index in expListNode.$expList {
            if index > mRetExp.$index {
               break;   
            }
            self.write( ", " );
            filter( exp, self, node );
         }
         self.write(")" );
      }
      else {
         self.write( "lns_litstr_%d( _pEnv " ( node.$id ) );
         foreach exp in expListNode.$expList {
            self.write( ", " );
            self.processVal2stem( exp, node );
         }
         self.write(")" );
      }
   }
   else {
      let opList = TransUnit.findForm( txt );

      self.write( getLiteralStrAny( txt ) );
   }
};

pub override fn convFilter.processLiteralBool(
   node: Nodes.LiteralBoolNode, opt: Opt ) mut
{
   if node.$token.txt == "true" {
      self.write( "true" );
   }
   else {
      self.write( "false" );
   }
};

pub override fn convFilter.processLiteralNil(
   node: Nodes.LiteralNilNode, opt: Opt ) mut
{
   self.write( cValNil );
};

pub override fn convFilter.processBreak(
   node: Nodes.BreakNode, opt: Opt ) mut
{
   self.write( "break" );
};

pub override fn convFilter.processLiteralSymbol(
   node: Nodes.LiteralSymbolNode, opt: Opt ) mut
{
   // self.write( '%s' ( node.$symbolInfo.$name ) );
};

pub override fn convFilter.processAbbr(
   node: Nodes.AbbrNode, opt: Opt ) mut
{
   self.write( cValNone );
};


pub fn createFilter(
   enableTest:bool, outputBuiltin:bool, streamName: str, stream: oStream,
   headerStream: oStream, ast:&TransUnit.ASTInfo ) : Nodes.Filter<Opt>
{
   return new convFilter( enableTest, outputBuiltin,
                          streamName, stream, headerStream, ast );
}

pub fn outputBootcode( stream: oStream, launchModuleName:str )
{
   let mut srcStream = new Util.SimpleSourceOStream( stream, nil, stepIndent );

   let launchModulePath = launchModuleName.gsub( "%.", "/" );
   let initFuncName = "lns_init_%s" ( (launchModuleName.gsub( "%.", "_" ) ));
   srcStream.writeln( ```
#include <lunescript.h>
#include <%s.h>
    
void lns_run_module( lns_env_t * _pEnv ) {
   %s( _pEnv );    
}
``` (launchModulePath, initFuncName) );
}
