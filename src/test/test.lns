( val1 and "&" and "+" or "" ) .. "";

let val1 : int, val2 : real = ?a, 1.0;
let val3 : real, val4, val5 : real = 0x1, 1.0e-2, 0.1e+3;
let val6 : int[] = [
    1, 2, 3
];
let val7 : int[@] = [@1,2,3];
let val8 : string = "1234\"";
let val9, val10 = "'1234'", ```:a23```;
let val11 = {
    "A": { "AA": 1 },
    "B": { "BB": 2,
	   "CC": 3,
    },  
    "D": [ 1, 2, 3 ]
};
let val12 = nil;
val11.A.AA = 3;
pub fn plus1_2( val1: int,	
		val2: int, val3: int[], val4: &mut int ) : int, int
{   
    val1 = -10@int + (val2 + val3[1]);
    let sub: stem = { ''  aa
	"z": {   	
	    "a": 1
	}   	
    };
    {   
	
    }   
    
    val2 = val3;
    val4 = val6;
    if not val {
    }
    if val10 == ""
    {      	 
	while true {
	    break; 
        }      
    }	
    elseif val1 {
        repeat {
        } val1 ~= true;
    }	
    elseif val1 {
        for index = 1, 10, 1 {
        }  
    }	
    else {
        apply val, sub of pairs( val7 ) {
	    foreach item in val6 {
	    } 	  
        }  
    }	
    return val1 + 1, val2 + 1;
}
pub fn plus2( val1: int, ... ) : int {
    print( "abc%s%s" (1,"ab") );
    print( ... );
}

class ClassA {
    let val: int;
    __init() {
	self.val = 0;
    }
    func( data: int ) : int {
	self.val = self.val + 1;
	return data + self.val;
    }
}

fn ClassA.sub() : int {
    return self.val;
}

static fn ClassA.sub2() : int {
     return 1;
 }

let classA = ClassA.new();
print( classA.func( 0 ) );
print( classA.func( 0 ) );
print( classA.sub() );

if not classA {
}

let fun = fn () {
    let hoge = ?\t;
};

print( '```' );

let valSymbol = nil;
let keySymbol = nil;
