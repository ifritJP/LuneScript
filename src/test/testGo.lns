#! lnsc -shebang

_lune_control use_macro_special_var;

import test.subGoPkg.SubPkg;

pub fn __main( args:&_List<str> ):int {
   return 0;
}

macro _section() {
   print( "----%s-----" (__line__) );
}
_section();
{
   fn func( work:&List<Map<str,int>> ) {
      foreach list in work {
         foreach val, key in list {
            print( key, val );
         }
      }
   }
   let mut work = [{ "ab":1 }, { "xyz":2 }];
   work.remove(##);
   work.insert( {"eee":10} );
   func( work );
}
_section();
{
   fn func( val1:int!, val2:int! ) {
      when! val1, val2 {
         print( val1 + val2 );
      }
      else {
         print( val1, val2 );
      }
   }
   func( 1, 10 );
   func( nil, 10 );
   func( 10, nil );
   func( nil, nil );
}
_section();
{
   fn func( val1:int!, val2:int! ) {
      if! let val10, val20 = val1, val2 {
         print( val10 + val20 );
      }
      else {
         print( val1, val2 );
      }
   }
   func( 1, 10 );
   func( nil, 10 );
   func( 10, nil );
   func( nil, nil );
}
_section();
{
   fn func() : int! {
      return 1;
   }
   let! val = func() {
      val = 2;
   };
   print( val );
}
_section();
{
   fn func( val1:int!, val2:int! ) {
      let! val10, val20 = val1, val2 {
         print( val1, val2 );
         return;
      }
      then {
         print( val10 + val20 );
      };
      print( val10 - val20 );
   }
   func( 1, 10 );
   func( nil, 10 );
   func( 10, nil );
   func( nil, nil );
}
_section();
{
   class Test {
      pro let val1:int;
      pro let val2:int;
      pub fn sub1(): int {
         return self.val1 + 100;
      }
      pub fn sub2(): int {
         return self.val2 + 100;
      }
   }
   class Sub extend Test {
      let val3:int;
      pub override fn sub1(): int {
         return self.val1 + 200;
      }
      pub fn sub3(): int {
         return self.val3 + 200;
      }
   }
   class SubSub extend Sub {
      pub override fn sub1(): int {
         return self.val1 + 300;
      }
      pub override fn sub2(): int {
         return self.val2 + 300;
      }
   }

   fn func1( test:&Test ): int, int {
      if! let sub2 = test@@@Sub {
         print( "OK", sub2.sub2() );
      }
      else {
         print( "CAN'T CAST" );
      }
      return test.sub1(), test.sub2();
   }

   fn func2( test:&stem ) {
      if! let sub2 = test@@@Sub {
         print( "OK", sub2.sub2() );
      }
      else {
         print( "CAN'T CAST" );
      }
   }

   let test = new Test( 1, 2 );
   print( func1( test )** );
   func2( test );

   let sub = new Sub( 1, 2, 3 );
   print( sub.sub3(), func1( sub )** );
   func2( sub );

   let subsub = new SubSub( 1, 2, 3 );
   print( subsub.sub3(), func1( subsub )** );
   func2( subsub );
}
_section();
{
   class Test {
      let val1:int;
      let val2:int;
      pub fn __init(val1:int, val2:int) {
         self.val1 = val1;
         self.val2 = val2;
      }
      pub fn func() {
         print( self.val1, self.val2 );
      }
   }

   fn func():int,int {
      return 1, 2;
   }

   class Sub extend Test {
   }

   class SubSub extend Sub {
      let val3:int;
      pub fn __init() {
         super( 0, (func()));
         self.val3 = 3;
      }
      pub override fn func() {
         super();
         print( self.val3 );
      }
   }

   let test = new SubSub();
   test.func();
}
_section();
{
   class Test {
      let val:int;
      pub fn func():int {
         return self.val;
      }
   }
   class Sub extend Test {
      pub override fn func():int {
         return super() + 100;
      }
   }
   let list = [ new Sub( 1 ), new Test( 10 ) ];
   foreach val in list {
      print( val.func() );
   }
}
_section();
{
   fn func( val:str ) {
      switch val {
         case "1", "2" {
            print( "A" );
         }
         case "3", "4" {
            print( "B" );
         }
         default {
            print( "C" );
         }
      }
   }

   foreach val in [ "1", "2", "3", "4", "5" ] {
      func( val );
   }
}
_section();
{
   let mut val = 1;
   while true {
      if val > 10 {
         break;
      }
      print( val );
      val = val + 1;
   }
}
_section();
{
   let mut val = 1;
   repeat {
      print( val );
      val = val + 1;
   } val > 10;
}
_section();
{
   class Test {
      let mut val:int {pub,pub};
   }

   let mut test = new Test( 10 );
   test.set_val( test.$val + 100 );
   print( test.$val );   
}
_section();
class Testggg {
   static let val:int;

   __init {
      Testggg.val = 1;
   }
   pub fn func():int {
      return Testggg.val + 10;
   }
   pub static fn sfunc():int {
      return 10;
   }
}
_section();
{
   let test = new Testggg();
   print( test.func(), Testggg.sfunc() );
}
_section();
{
   enum Test {
      Val1,
      Val2,
   }
   foreach val in Test.$_allList {
      print( val + 10 );
   }
   enum Test2 {
      Val1 = "a",
      Val2 = "b",
   }
   foreach val, index in Test2.$_allList {
      print( index, val, Test2._from( val ), val.get__txt(), val.$_txt );
   }
}
_section();
{
   enum Test {
      Val1,
      Val2,
   }

   fn func( val:Test ) {
      print( val + 1 );
   }

   func( .Val1 );
}
_section();
{
   alge Val {
      val1,
      val2( int, str ),
   }

   fn sub( val:Val ) {
      match val {
         case .val2( val1, val2 ) {
            print( "val2 %s" (val2) );
         }
         default {
            print( "other" );
         }
      }
      if val == .val1 {
         print( "equal" );
      }
      print( val.$_txt );
   }
   sub( Val.val1 );
   sub( Val.val2( 100, "xyz" ) );
}
_section();
{
   fn func( val:int, ... ) {
      print( ..., val );
   }

   func( 1, 2, "abc" );
}
_section();
{
   fn func( val:int, ... ) {
      let list = [ ... ];
      foreach item in list {
         print( item );
      }
   }

   func( 1, 2, "abc" );
}
_section();
{
   let val = -1.5;
   for index = 10,1, val {
      print( index );
   }
}
_section();
{
   form TestForm( val:str ):int, int;
   fn func( txt:str ) : TestForm! {
      return fn ( val:str ):int,int { print( val .. txt ); return 1, 2; };
   }
   let sub = func( "xyz" );
   when! sub {
      print( sub( "hoge" )** );
   }
}
_section();
{
   class Test0 {
      pub let val:int {pub};
      pub fn func( val:int ):int {
         return self.val + val;
      }
   }
   class Test1 {
      pub let val0:Test0 {pub};
      pub fn func( val:int ):int {
         return self.val0.$val + val;
      }
   }
   class Test2 {
      pub let val1:Test1! {pub};
   }
   class Test3 {
      pub let val2:Test2! {pub};
   }
   fn func(test:Test3) {
      // field, field, call
      print( test.val2$.val1$.func$( 1 ) );
      // field, field, field, call
      print( test.val2$.val1$.val0$.func$( 10 ) );
      // field, get, call
      print( test.val2$.$val1$.func$( 1 ) );
      // field, get, get
      print( test.val2$.$val1$.$val0$.val );
      // field, get, get, call
      print( test.val2$.$val1$.$val0$.func$( 1 ) );
      // field, call, field
      print( test.val2$.get_val1$()$.val0$.val );
      // field, call, field, field
      print( test.val2$.get_val1$()$.val0$.val );
      // field, call, get
      print( test.val2$.get_val1$()$.$val0$.val );
      // field, call, get, get
      print( test.val2$.get_val1$()$.$val0$.$val );
      // field, call, cal
      print( test.val2$.get_val1$()$.func$( 1 ) );
   }
   func( new Test3(##) );
   func( new Test3( new Test2(##)) );
   func( new Test3( new Test2( new Test1( new Test0( 10 )  ))) );
}
_section();
{
   class Test {
      pub fn func1():int {
         return 1;
      }
      pub fn func2():int, int {
         return 1, 2;
      }
      pub fn func5():int, int, int, int, int {
         return 1, 2, 3, 4, 5;
      }
   }
   fn func( test:Test! ) {
      {
         let! val1 = test$.func1$() {
            print( "NG" );
            return;
         };
         print( val1 );
      }
      {
         let! val1, val2 = test$.func2$() {
            print( "NG" );
            return;
         };
         print( val1 + val2 );
      }
      {
         let! val1, val2, val3, val4, val5 = test$.func5$() {
            print( "NG" );
            return;
         };
         print( val1 + val2 + val3 + val4 + val5  );
      }
   }
   func( new Test() );
}
_section();
{
   class Test {
      let val:int {pub};
   }
   class Sub {
      let val:Test {pub};
   }
   let test:&Sub! = new Sub( new Test( 1 ) );
   print( test$.get_val$()$.get_val$() );
   print( test$.$val$.$val );
   print( test$.get_val$()$.$val );
   print( test$.$val$.get_val$() );
}
_section();
{
   class Test<T> {
      pub let val:T {pub};
      pub fn func():&T {
         return self.val;
      }
      pub fn func2():&T, &T {
         return self.val, self.val;
      }
   }
   fn func1( test:&Test<int> ) {
      print( test.func() + 10 );
   }
   fn func2( test:&Test<str> ) {
      print( test.func() .. "xyz" );
   }


   let test = new Test( 1 );
   func1( test );
   let test2 = new Test( "a" );
   func2( test2 );

   print( test.func2() + 1 );
   print( test2.func2() .. "xyz" );
   fn sub( val1:int, val2:int, val3:int! ) {
      print( val1, val2 );
   }
   sub( test.func2()** ## );
   print( test.$val + 1);
   print( test.val + 1, test.val + 2);
   {
      let val1, val2 = test.val + 1, test.val + 2;
      print( val1 + val2 );
   }
}
_section();
{
   fn func( txt:str ) {
      print( "gsub:", txt, txt.gsub( "ai", "AI")** );
      print( "find:", txt, txt.find( "op" ## )** );
      print( "byte:", txt, txt.byte( 2, 3 )** );
      print( "rep:", txt, txt.rep( 3 ) );
      print( "sub:", txt, txt.sub( 2, 3 ) );
      print( "lower:", txt, txt.lower() );
      print( "upper:", txt, txt.upper() );
      print( "reverse:", txt, txt.reverse() );
      __luago {
         apply token of txt.gmatch( "[^a]+" ) {
            print( token );
         }
      }
   }
   func( "fieoapfjaiopjfeop" );
}
_section();
{
   fn ite( param:int, prev:stem! ) : int!, str {
      let mut prevInt:int = 0;
      if prev == param {
         return nil, "";
      }  
      when! prev {
         prevInt = prev@@int;
      }  
      else {
         prevInt = 0;
      }  
      let next = prevInt + 1;
      return next, "@%d@" ( next );
   }  

   form iteForm( param:int, prev:stem! ) : int!, str;

   fn testIte( max:int ): iteForm, int, int! {
      return ite, max, nil;
   }  

   apply value1, value2 of testIte( 10 ) {
      print( value1, value2 );
   }
}
_section();
{
   fn func() : ...<int> {
      return 1, 2, 3;
   }

   {
      let val1, val2, val3 = func();
      print( val1, val2, val3 );
   }
   {
      let val1, val2 = func();
      print( val1, val2 );
   }
   print( func() );
}
_section();
{
   fn func() : ...<int> {
      return 1, 2, 3;
   }

   {
      if! let val1, val2, val3 = func() {
         print( val1 + 10, val2 + 10, val3 + 10 );
      }
   }
   {
      let val1, val2 = func();
      print( val1, val2 );
   }
   print( func() );
}
_section();
{
   fn func( stream:oStream ) {
      stream.write( "abcd\n" );
   }
   func( io.stdout );
}
_section();
{
   let set = (@ "10", "9", "1", "2", "3", "4" );
   forsort val in set {
      print( val .. "aa" );
   }  
}
_section();
{
   let list = [ "10", "9", "1", "2", "3", "4" ];
   foreach val in list {
      print( val .. "aa" );
   }  
}
_section();
{
   let map = {"X":1, "O":2, "A":3, "B":4, "C":5, "D":6 };
   forsort val, key in map {
      print( key .. "aa", val + 10 );
   }  
}
_section();
{
   let nilable:int! = nil;
   let mut map:_Map<str,int> = {
      "X":1, "O":2, "A":3, "B":4, "C":5, "D":6, "Z":nil, "ZZ":nilable
   };
   map[ "xyz" ] = 10;
   map[ "A" ] = nil;
   forsort val, key in map {
      print( key .. "aa", val + 10 );
   }  
}
_section();
{
   fn func() {
      print( __mod__, __func__, __line__ );
   }
   func();
}
_section();
{
   class Test extend (Mapping) {
      let val:List<int> {pub};
      let val2:Map<int,str> {pub};
   }
   class Sub extend Test {
      let val3:Set<real> {pub};
   }
   class Hoge extend (Mapping) {
      let list:List<Sub> {pub};
   }
   let hoge = new Hoge(
      [ new Sub( [100, 200, 300], {10:"aa", 20:"bb"}, (@ 1.5, 10.5 ) ),
        new Sub( [1000, 2000, 3000], {100:"aaa", 200:"bbb"}, (@ 10.5, 100.5 ) ) ]);

   let map = hoge._toMap();
   foreach val0, key0 in map {
      foreach test, index in val0@@_List<_Map<str,stem>> {
         forsort val, key in test {
            switch key {
               case "val" {
                  foreach val2, key2 in val@@_List<int> {
                     print( key0, index, key, key2, val2 );
                  }
               }
               case "val2" {
                  forsort val2, key2 in val@@_Map<int,str> {
                     print( key0, index, key, key2, val2 );
                  }
               }
               case "val3" {
                  forsort val2 in val@@_Set<real> {
                     print( key0, index, key, val2 );
                  }
               }
            }
         }
      }
   }

   let hoge2, mess = Hoge._fromStem( map );
   when! hoge2 {
      foreach sub in hoge2.$list {
         forsort val in sub.$val3 {
            print( val );
         }
         forsort val, key in sub.$val2 {
            print( key, val );
         }
         foreach val, index in sub.$val {
            print( index, val );
         }
      }
   } else {
      error( "error %d: %s" (__line__, mess) );
   }
}
_section();
{
   fn func():int, int {
      return 1, 2;
   }
   {
      let val = func();
   }
}
/*nolua51*/_section();
/*nolua51*/{
/*nolua51*/   __luago {
/*nolua51*/      print( string.format( "%s = %s", "abcd", 123 ) );
/*nolua51*/      if! let luafn = _load( 'print( "hoge:" )' ## ) {
/*nolua51*/         luafn(##);
/*nolua51*/         let bin = string.dump( luafn ## );
/*nolua51*/         let fn2, mess =  _load( bin ## );
/*nolua51*/         when! fn2 {
/*nolua51*/            fn2(##);
/*nolua51*/         } else {
/*nolua51*/            print( mess );
/*nolua51*/         }
/*nolua51*/      }
/*nolua51*/   }
/*nolua51*/}
_section();
{
   if! let mut fileObj = io.open( "testGo.lns" ##) {
      print( fileObj.read( 100 ) );
   }
}
_section();
{
   fn func( val:stem! ) {
      print( type( val ) );
   }
   func( 1 );
   func( 1.5 );
   func( true );
   func( "a" );
   func( fn() {} );
   func( [ 1 ] );
}
_section();
{
   class Test {
   }
   class Sub extend Test {
   }
   fn func( val:&Test!, val2:int! ):int {
      return 1;
   }
   func( new Sub() ## );
}
_section();
{
   class Test {
   };
   fn func( val1:&stem!, val2:&stem!, val3:str ) {
   }
   func( new Test(), new Test(), "a" );
}
_section();
{
   enum Val {
      Val1,
      Val2,
   }

   fn func( val:Val ) : int,real,str,bool,stem {
      _switch val {
         case .Val1 {
            return 1,1.5,"",true,2;
         }
         case .Val2 {
            return 1,1.5,"",true,2;
         }
      }
   }
   func( .Val1 );

   fn func2( val:Val ) : int {
      if val == .Val1 {
         return 1;
      } else {
         return 2;
      }
   }
   func2( .Val1 );
}
_section();
{
   macro _eq( val1:__exp, val2:__exp ) {
      {}
      {
         let result = ,,val1 == ,,val2;
         print( "%s == %s: %s" (,,,,val1, ,,,,val2, result ) );
      }
   }
   {
      class Test {
      }
      class Sub extend Test {
      }

      let sub = new Sub();
      let test1:&Sub! = sub;
      let test2:&Test! = sub;
      let test3:&stem! = sub;

      print( "class----" );
      _eq( test1, test2 );
      _eq( test1, test3 );
      _eq( test2, test1 );
      _eq( test2, test3 );
      _eq( test3, test1 );
      _eq( test3, test2 );
      _eq( test1, nil );
      _eq( test1, new Sub() );
   }
   {
      class Test<T> {
         let val:T {pub};
         pub fn eq( val:&T ):bool {
            return self.val == val;
         }
      }
      class Hoge {
      }

      let hoge = new Hoge();
      let test = new Test( hoge );
      let test1:&Test<&Hoge>! = test;
      let test2:&Test<&Hoge>! = test;
      let test3:&stem! = test;

      print( "generic class ----" );
      _eq( test1, test2 );
      _eq( test1, test3 );
      _eq( test2, test1 );
      _eq( test2, test3 );
      _eq( test3, test1 );
      _eq( test3, test2 );
      _eq( test1, nil );
      //_eq( test1, new Test(1) );

      _eq( test1$.eq$( hoge ), true );
      _eq( test1$.eq$( new Hoge() ), false );
   }
   {
      print( "int----" );
      let val1:int! = 1;
      let val2:stem! = 1;
      let val3:stem! = val2;
      _eq( val1, val2 );
      _eq( val1, val3 );
      _eq( val2, val1 );
      _eq( val2, val3 );
      _eq( val3, val1 );
      _eq( val3, val2 );
      _eq( val1, nil );
      _eq( val1, 2 );
   }
   {
      print( "list----" );
      let val1:List<int> = [1];
      let val2:stem! = val1;
      let val3:stem! = val2;
      _eq( val1, val2 );
      _eq( val1, val3 );
      _eq( val2, val1 );
      _eq( val2, val3 );
      _eq( val3, val1 );
      _eq( val3, val2 );
      _eq( val2, nil );
      _eq( val2, [1] );
   }
}
_section();
{
   fn func( val:int! ) {
      if! val {
      }
   }
   func( 1 );
}
pub enum Valg {
   Val1,
   Val2,
}
_section();
{
   {
      enum Val {
         Val1,
         Val2,
      }
      foreach val in Val.$_allList {
         print( val );
      }
   }
   {
      enum Val {
         Val1,
         Val2,
      }
   }
}
_section();
{
   interface Test {
      pub fn func();
   }
   class Hoge0 extend (Test) {
      pub fn func() {
         print( __func__ );
      }
   }

   class Hoge1 extend (Test) {
      let test:Test;

      advertise test;
   }
   let hoge = new Hoge1( new Hoge0() );
   hoge.func();
}
_section();
{
   class Super {
      pub fn func() {
         print( __func__ );
      }
   }
   class Test extend Super {
   }
   let list:_List<Test> = [ new Test() ];
   let list2:&_List<stem> = list;
   foreach val in list2@@_List<Super> {
      val.func();
   }
}
_section();
{
   {
      let mut list = [ 1 ];
      list[ 1 ] = 10;
      list[ 2 ] = 20;
      foreach val in list {
         print( val );
      }
   }
   {
      let mut map = { 1:"a" };
      map[ 1 ] = "10";
      foreach val, key in map {
         print( key, val );
      }
   }
}
_section();
{
   let list = [ 1, 2 ];
   let list2 = [ 0, list.unpack() ];
   foreach val in list2 {
      print( val + 10 );
   }
}
_section();
{
   class Test {
   }
   class Sub extend Test {
   }

   macro _test( comp:__exp, collection:__exp ) {
      foreach val in ,,collection {
         print( "%s  : %s" (,,,,comp, val == ,,comp) );
      }
   }

   let sub = new Sub();
   let test:&Test = sub;
   let sub2 = new Sub();
   let test2:&Test = sub2;
   let list = [ sub ];
   _test( test, list );
   _test( sub, list );
   _test( test2, list );
   _test( sub2, list );
   let set = (@ sub );
   _test( test, set );
   _test( sub, set );
   _test( test2, set );
   _test( sub2, set );
   let map = { sub:sub };
   _test( test, map );
   _test( sub, map );
   _test( test2, map );
   _test( sub2, map );
}
_section();
{
   class Test<T> {
      let val:T {pro};
      pub fn func( val:T ) : T {
         print( __func__, self.val == val );
         return val;
      }
   }
   class Sub<T> extend Test<T>  {
      pub override fn func( val:T ) : T {
         print( __func__, self.$val == val );
         return val;
      }
   }
   let sub = new Sub( "abc" );
   print( sub.func( "abc" ) .. "xyz" );
}
_section();
{
   for val = 1, 1 {
      print( "hoge" );
   }   
}
_section();
{
   form test( val:stem, list:&Map<int,str> );

   let code = ```
      return function( val, list )
   print( val )
   for index, item in pairs( list ) do
      print( index, item )
   end
end```;
   __luago {
      let loaded = _load( code ## );
      when! loaded {
         let func = loaded(##);
         when! func {
            (func@@Luaval<test>)( "hoge:", {1:"a", 2:"b", 3:"c" } );
         }
      }
   }
}
_section();
{
   __luago {
      let code = ```
      return { 10, 20, 30 }
```;
      let loaded = _load( code ## );
      when! loaded {
         if! let obj = loaded(##) {
            let list = obj@@&List<int>;
            print( #list );
            foreach val, key in list {
               print( key, val );
            }
         }
      }
   }
}
_section();
{
   form test() : Luaval<&List<stem>>;

   let code = ```
      return { 1,2,3, "a", "b", { abc = 1, xyz = 10 } }
```;
   fn func( txt:str ) {
      __luago {
         let loaded = _load( txt ## );
         when! loaded {
            if! let obj = loaded(##) {
               foreach val, index in obj@@_List<&stem> {
                  if type( val ) == "table" {
                     forsort val2, key2 in val@@&Map<stem,stem> {
                        print( key2, val2, type( key2 ), type( val2 ) );
                     }
                  } else {
                     print( index + 10, val, type( val ) );
                  }
               }
            } else {
               print( "NG", __line__ );
            }
         } else {
            print( "NG", __line__ );
         }
      }
   }
   func( code );
}
_section();
{
   let step = 32;

   // Lua のフィボナッチ関数
   let code = ```
      local function fib ( n )
   if n < 2 then return n end
   return fib(n - 2) + fib(n - 1)
end
return fib
```;

   // Lua コードのロード
   form fibFunc( num:int ):int;
   fn loadLua( txt:str ) : Luaval<fibFunc> {
      let fib;
      __luago {
         let loaded = unwrap _load( txt ## );
         fib = unwrap loaded(##);
      }
      return fib@@fibFunc;
   }

   // プロファイル用マクロ
   macro _profile( exec:__exp ) {
      {}
      {
         let prev = os.clock();
         print( "%s = %d: step = %d: time = %g: DIFF_IGNORE"
                (,,,,exec, ,,exec, step, os.clock() - prev ) );
      }
   }

   // Lua のコードをロードして実行
   __luago {
      let fib_lua = loadLua( code );
      _profile( fib_lua( step ) );
   }

   // LuneScript のフィボナッチ関数
   fn fib_lns( num:int ) : int {
      if num < 2 {
         return num;
      }
      return fib_lns( num - 2 ) + fib_lns( num - 1 );
   }
   // Go で定義した fib_lns 関数を実行
   _profile( fib_lns( step ) );
}
_section();
{
   let code = ```
      local obj = {}
local list = { 100, 200, 300 }
local list2 = { 11, 12, 13 }
obj.val = { item1=list, item2=list2 }
return obj
```;

   class Hoge {
      pub let val:&Map<str,&List<int>>;
   }
   

   __luago {
      let loaded = unwrap _load( code ## );
      let obj = unwrap loaded(##);
      let hoge = obj@@=Hoge;
      let mut keyList:List<str> = [];
      foreach _, key in hoge.val {
         keyList.insert( key );
      }
      keyList.sort(##);
      foreach key in keyList {
         let list = unwrap hoge.val[key];
         foreach val, index in list {
            print( key, index, val );
         }
      }
   }
}
_section();
{
   macro _hoge() {
      let mut GGG = 1;
   }

   _hoge();
   print( GGG );
}
_section();
{
   foreach _ in [ 1, 2, 3 ] {
      print( "hoge" );
   }
}
_section();
{
   abstract class Test extend (Mapping) {
      let val:int {pub};
      pub abstract fn func();
   }
   class Sub extend Test(Mapping) {
      pub override fn func() {
      }
   }
   let test:&Test = new Sub(1);
   test.func();
}
_section();
{
   class Test {
      pub fn func() {
         print( __func__ );
      }
   }
   class Sub extend Test {
      pub fn sub() {
         print( __func__ );
      }
   }
   fn hoge( list:&_List<&Test> ) {
      foreach val in list@@_List<&Sub> {
         val.sub();
      }
   }
   let test:Test = new Sub();
   let mut list:_List<&Test> = [];
   list.insert( test );
   hoge( list );

   class Hoge<T:Test> {
      pub fn func( val:T ) {
         val.func();
      }
   }
   let hoge2 = new Hoge<Test>();
   hoge2.func( new Test() );
}
_section();
{
   let lnsCode = ```
aaa
```;
   print( lnsCode );
}
_section();
{
   fn func() : int, int {
      return 1,2;
   }
   let val;
   val = func();
   print( val );
}
_section();
{
   interface IF {
      pub fn func();
   }
   interface IF2 {
      pub fn func();
   }
   abstract class Test extend (IF,IF2) {
      pub abstract fn func();
   }
   abstract class Sub extend Test {
   }
   class SubSub extend Sub {
      pub override fn func() {
         print( __func__ );
      }
   }
   fn func( obj:&IF ) {
      obj.func();
   }

   {
      let sub:Sub = new SubSub();
      func( sub );
      let test:Test = sub;
      func( test );
   }
}
_section();
{
   class Test {
   }
   class Sub<T:Test> {
      let mut stack:_List<T>;

      pub fn __init() {
         self.stack = [];
      }
      
      pub fn current() mut : T {
         if #self.stack == 0 {
         }
         return self.stack[ #self.stack ];
      }
      pub fn currentR() : &T {
         if #self.stack == 0 {
         }
         return self.stack[ #self.stack ];
      }
   }
}
_section();
{
   let workName = "abc";
   let fullName = "%s" ( (workName.gsub( "[&@]", "" ).gsub( "%.", "/" ) ) );
   print( fullName );
}
_section();
{
   class Test {
      pub fn func() {
         print( __func__ );
      }
   }
   class Sub<T:Test> {
      let val:Test {pub:stem!};
      let val2:T {pub:&T};
   }
   let sub = new Sub( new Test(), new Test());
   if! let val = sub.$val {
      if! let test = val@@@Test {
         test.func();
      }
   }
   sub.$val2.func();
}
_section();
{
   let mut func:form! = nil;
   func = fn () {
      print( "func" );
   };
   when! func {
      func(##);
   }
}
_section();
{
   form fornfunc();
   let mut func:fornfunc! = nil;
   func = fn () {
      print( "func" );
   };
   when! func {
      func();
   }
}
_section();
{
   fn func( txt:str ) {
      let path = "hoge";
      let! mut file = io.open( path, "w" ) {
         print( "open error" );
         return;
      };
      file.write( txt );
      file.close();

      __luago {
         let loaded, mess = loadfile( path );
         when! loaded {
            if! let obj = loaded(##) {
               foreach val in obj@@_List<stem> {
                  print( expandLuavalMap( val ) );
               }
            } else {
               print( "load error" );
            }
         } else {
            print( mess );
         }
      }
   }
   func( "return { 'a', 'b', 'c' }" );
}
_section();
{
   fn func( txt:str ) {
      __luago {
         let loaded, mess = _load( txt ## );
         when! loaded {
            if! let obj = loaded(##) {
               class Test {
                  pub let val1:&List<str>;
                  pub let val2:&List<int>;
               }
               let test = obj@@=Test;
               foreach val, index in test.val1 {
                  print( index, val );
               }
               foreach val, index in test.val2 {
                  print( index, val );
               }
            } else {
               print( "load error" );
            }
         } else {
            print( mess );
         }
      }
   }
   func( "return { val1 = {'a', 'b'}, val2 = {10,20} }" );
}
_section();
{
   __luago { 
      let loaded, mess = _load( "return { [1] = 'a', [5] = 'b', [2] = 'c' }"## );
      when! loaded {
         let map = unwrap loaded(##);
         forsort val, key in map@@Map<int,str> {
            print( key, val );
         }
      } else {
         print( mess );
      }
   }
}
_section();
{
   __luago {  
      let loaded, mess = _load( "return { [1] = 'a', [5] = 'b', [2] = 'c' }"## );
      when! loaded {
         let map = unwrap loaded(##);
         forsort val, key in map@@Map<int,str> {
            print( key, val );
         }
         if! let map2 = expandLuavalMap( map ) {
            forsort val, key in map2@@_Map<int,str> {
               print( key, val );
            }
         }
      } else {
         print( mess );
      }
   }
}
_section();
{
   class Test extend (Mapping) {
      pub let val:int;
   }
   let test = new Test( 100 );
   let map = test._toMap();
   foreach val, key in map {
      print( key, val );
   }
   if! let test2 = Test._fromStem( map ) {
      print( test2.val );
   }
}
_section();
{
   class Test extend (Mapping) {
      pub let val:int;
   }
   let test = new Test( 100 );
   let map = test._toMap();
   foreach val, key in map {
      print( key, val );
   }
   if! let test2 = Test._fromStem( map ) {
      print( test2.val );
   }
}
_section();
{
   __luago {
      let loaded, mess = _load( "return { list = { 10, 20, 30 } }"## );
      when! loaded {
         let obj = unwrap loaded(##);
         class Test extend (Mapping) {
            pub let list:&_List<int>;
         }
         if! let test = Test._fromStem( expandLuavalMap( obj ) ) {
            foreach val, key in test.list {
               print( key, val );
            }
         }
      } else {
         print( mess );
      }
   }
}

_section();
{
   fn func( txt:str )
   {
      __luago {
         let loaded, mess = _load( txt ## );
         when! loaded {
            let map = unwrap loaded(##);
            if! let map2 = expandLuavalMap( map ) {
               forsort _, key in map2@@_Map<str,stem> {
                  print( key );
               }
            }
         } else {
            print( mess );
         }
      }
   }
   let txt = ```
         local _moduleObj = {}
----- meta -----
_moduleObj.__version = '1.1.10'
_moduleObj.__formatVersion = '1.0.78'
_moduleObj.__buildId = "1603461398.000000:1"
_moduleObj.__enableTest = false
_moduleObj.__hasTest = false
local __typeId2ClassInfoMap = {}
_moduleObj.__typeId2ClassInfoMap = __typeId2ClassInfoMap
do
   local __classInfo1007 = {}
   __typeId2ClassInfoMap[ 1007 ] = __classInfo1007
end
do
   local __classInfo1039 = {}
   __typeId2ClassInfoMap[ 1039 ] = __classInfo1039
end
do
   local __classInfo1001 = {}
   __typeId2ClassInfoMap[ 1001 ] = __classInfo1001
end
do
   local __classInfo1003 = {}
   __typeId2ClassInfoMap[ 1003 ] = __classInfo1003
end
do
   local __classInfo1005 = {}
   __typeId2ClassInfoMap[ 1005 ] = __classInfo1005
end
local __macroName2InfoMap = {}
_moduleObj.__macroName2InfoMap = __macroName2InfoMap
do
   local info = {}
   __macroName2InfoMap[ 1147 ] = info
   info.name = "_eq"
   info.argList = {{name="ctrl",typeId=100},{name="val1",typeId=110},{name="val2",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"checkEq"},{6,"("},{8,",,"},{5,"val1"},{6,","},{8,",,"},{5,"val2"},{6,","},{8,",,,,"},{5,"val1"},{6,","},{8,",,,,"},{5,"val2"},{6,","},{7,"nil"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"}}
end
do
   local info = {}
   __macroName2InfoMap[ 1149 ] = info
   info.name = "_neq"
   info.argList = {{name="ctrl",typeId=100},{name="val1",typeId=110},{name="val2",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"checkEq"},{6,"("},{8,",,"},{5,"val1"},{6,","},{8,",,"},{5,"val2"},{6,","},{8,",,,,"},{5,"val1"},{6,","},{8,",,,,"},{5,"val2"},{6,","},{7,"nil"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"}}
end
do
   local info = {}
   __macroName2InfoMap[ 1151 ] = info
   info.name = "_isT"
   info.argList = {{name="ctrl",typeId=100},{name="val",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"isTrue"},{6,"("},{8,",,"},{5,"val"},{6,","},{8,",,,,"},{5,"val"},{6,","},{7,"nil"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"}}
end
do
   local info = {}
   __macroName2InfoMap[ 1153 ] = info
   info.name = "_isNotT"
   info.argList = {{name="ctrl",typeId=100},{name="val",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"isNotTrue"},{6,"("},{8,",,"},{5,"val"},{6,","},{8,",,,,"},{5,"val"},{6,","},{7,"nil"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"}}
end
do
   local info = {}
   __macroName2InfoMap[ 1155 ] = info
   info.name = "_isNil"
   info.argList = {{name="ctrl",typeId=100},{name="val",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"isNil"},{6,"("},{8,",,"},{5,"val"},{6,","},{8,",,,,"},{5,"val"},{6,","},{7,"nil"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"}}
end
do
   local info = {}
   __macroName2InfoMap[ 1157 ] = info
   info.name = "_err"
   info.argList = {{name="ctrl",typeId=100},{name="mes",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"err"},{6,"("},{8,",,"},{5,"mes"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"},{6,";"}}
end
do
   local info = {}
   __macroName2InfoMap[ 1159 ] = info
   info.name = "_eqM"
   info.argList = {{name="ctrl",typeId=100},{name="msg",typeId=51},{name="val1",typeId=110},{name="val2",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"checkEq"},{6,"("},{8,",,"},{5,"val1"},{6,","},{8,",,"},{5,"val2"},{6,","},{8,",,,,"},{5,"val1"},{6,","},{8,",,,,"},{5,"val2"},{6,","},{8,",,"},{5,"msg"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"}}
end
do
   local info = {}
   __macroName2InfoMap[ 1161 ] = info
   info.name = "_neqM"
   info.argList = {{name="ctrl",typeId=100},{name="msg",typeId=51},{name="val1",typeId=110},{name="val2",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"checkEq"},{6,"("},{8,",,"},{5,"val1"},{6,","},{8,",,"},{5,"val2"},{6,","},{8,",,,,"},{5,"val1"},{6,","},{8,",,,,"},{5,"val2"},{6,","},{8,",,"},{5,"msg"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"}}
end
do
   local info = {}
   __macroName2InfoMap[ 1163 ] = info
   info.name = "_isTM"
   info.argList = {{name="ctrl",typeId=100},{name="msg",typeId=51},{name="val",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"isTrue"},{6,"("},{8,",,"},{5,"val"},{6,","},{8,",,,,"},{5,"val"},{6,","},{8,",,"},{5,"msg"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"}}
end
do
   local info = {}
   __macroName2InfoMap[ 1165 ] = info
   info.name = "_isNotTM"
   info.argList = {{name="ctrl",typeId=100},{name="msg",typeId=51},{name="val",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"isNotTrue"},{6,"("},{8,",,"},{5,"val"},{6,","},{8,",,,,"},{5,"val"},{6,","},{8,",,"},{5,"msg"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"}}
end
do
   local info = {}
   __macroName2InfoMap[ 1167 ] = info
   info.name = "_isNilM"
   info.argList = {{name="ctrl",typeId=100},{name="msg",typeId=51},{name="val",typeId=110}}
   info.symList = {}
   info.tokenList = {
   {8,",,"},{5,"ctrl"},{6,"."},{5,"isNil"},{6,"("},{8,",,"},{5,"val"},{6,","},{8,",,,,"},{5,"val"},{6,","},{8,",,"},{5,"msg"},{6,","},{5,"__mod__"},{6,","},{5,"__line__"},{6,")"}}
end
local __varName2InfoMap = {}
_moduleObj.__varName2InfoMap = __varName2InfoMap
local __typeInfoList = {}
_moduleObj.__typeInfoList = __typeInfoList
local __dependIdMap = {}
_moduleObj.__dependIdMap = __dependIdMap
__typeInfoList[1] = { skind = 2, parentId = 1, typeId = 1001, txt = '@lune', kind = 12, 
children = {1003, } }
__typeInfoList[2] = { skind = 2, parentId = 1001, typeId = 1003, txt = '@base', kind = 12, 
children = {1005, } }
__typeInfoList[3] = { skind = 2, parentId = 1003, typeId = 1005, txt = '@Testing', kind = 12, 
children = {1007, 1039, 1073, 1134, 1137, 1141, 1144, 1147, 1149, 1151, 1153, 1155, 1157, 1159, 1161, 1163, 1165, 1167, } }
__typeInfoList[4] = { skind=3, parentId = 1005, typeId = 1007, baseId = 1, txt = 'Result',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 6, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {}, retTypeId = {}, children = {1015, 1018, 1021, 1024, 1027, 1030, 1033, 1036}, }
__typeInfoList[5] = { skind = 0, parentId = 1005, typeId = 1008, nilable = true, orgTypeId = 1007 }
__typeInfoList[6] = { skind = 1, parentId = 1005, typeId = 1014, srcTypeId = 1007, mutMode = 0 }
__typeInfoList[7] = { skind=3, parentId = 1007, typeId = 1015, baseId = 1, txt = 'outputResult',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 0, itemTypeId = {}, ifList = {}, argTypeId = {184}, retTypeId = {}, children = {}, }
__typeInfoList[8] = { skind=3, parentId = 1007, typeId = 1018, baseId = 1, txt = 'err',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {51, 51, 31}, retTypeId = {}, children = {}, }
__typeInfoList[9] = { skind=3, parentId = 1007, typeId = 1021, baseId = 1, txt = 'isTrue',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {25, 51, 52, 51, 31}, retTypeId = {26}, children = {}, }
__typeInfoList[10] = { skind=3, parentId = 1007, typeId = 1024, baseId = 1, txt = 'isNotTrue',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {25, 51, 52, 51, 31}, retTypeId = {26}, children = {}, }
__typeInfoList[11] = { skind=3, parentId = 1007, typeId = 1027, baseId = 1, txt = 'isNil',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {25, 51, 52, 51, 31}, retTypeId = {26}, children = {}, }
__typeInfoList[12] = { skind=3, parentId = 1007, typeId = 1030, baseId = 1, txt = 'checkEq',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {25, 25, 51, 51, 52, 51, 31}, retTypeId = {26}, children = {}, }
__typeInfoList[13] = { skind=3, parentId = 1007, typeId = 1033, baseId = 1, txt = 'checkNotEq',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {25, 25, 51, 51, 52, 51, 31}, retTypeId = {26}, children = {}, }
__typeInfoList[14] = { skind=3, parentId = 1007, typeId = 1036, baseId = 1, txt = '__init',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 0, itemTypeId = {}, ifList = {}, argTypeId = {51, 31, 31}, retTypeId = {}, children = {}, }
__typeInfoList[15] = { skind=3, parentId = 1005, typeId = 1039, baseId = 1, txt = 'Ctrl',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 6, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {}, retTypeId = {}, children = {1046, 1049, 1052, 1055, 1058, 1061, 1064, 1067, 1070}, }
__typeInfoList[16] = { skind = 0, parentId = 1005, typeId = 1040, nilable = true, orgTypeId = 1039 }
__typeInfoList[17] = { skind=3, parentId = 1039, typeId = 1046, baseId = 1, txt = 'get_result',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 0, itemTypeId = {}, ifList = {}, argTypeId = {}, retTypeId = {1007}, children = {}, }
__typeInfoList[18] = { skind=3, parentId = 1039, typeId = 1049, baseId = 1, txt = '__init',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 0, itemTypeId = {}, ifList = {}, argTypeId = {1007}, retTypeId = {}, children = {}, }
__typeInfoList[19] = { skind=3, parentId = 1039, typeId = 1052, baseId = 1, txt = 'checkEq',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {25, 25, 51, 51, 52, 51, 31}, retTypeId = {26}, children = {}, }
__typeInfoList[20] = { skind=3, parentId = 1039, typeId = 1055, baseId = 1, txt = 'checkNotEq',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {25, 25, 51, 51, 52, 51, 31}, retTypeId = {26}, children = {}, }
__typeInfoList[21] = { skind=3, parentId = 1039, typeId = 1058, baseId = 1, txt = 'err',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {51, 51, 31}, retTypeId = {}, children = {}, }
__typeInfoList[22] = { skind=3, parentId = 1039, typeId = 1061, baseId = 1, txt = 'isNil',
        abstractFlag = false, staticFlag = false, accessMode = 1, kind = 9, mutMode = 2, itemTypeId = {}, ifList = {}, argTypeId = {25, 51, 52, 51, 31}, retTypeId = {26}, children = {}, }

local __dependModuleMap = {}
_moduleObj.__dependModuleMap = __dependModuleMap
_moduleObj.__subModuleMap = {}
_moduleObj.__moduleTypeId = 1005
_moduleObj.__moduleSymbolKind = 0
_moduleObj.__moduleMutable = true
----- meta -----
return _moduleObj
```;
   func( txt );
}
_section();
{
   fn func( obj:stem ) {
      print( obj[ 1 ] );
   }
   fn func2( obj:stem! ) {
      print( obj$[ 1 ] );
   }
   func( [ "a", "b" ] );
   func( { 1:"a", 2:"b" } );
   func2( [ "a", "b" ] );
   func2( { 1:"a", 2:"b" } );
   func2( nil );
}
_section();
{
   if! let mut fileObj = io.open( "hoge", "w" ) {
      fileObj.write( "aaaa" );
      fileObj.seek( "set", 0 );
      fileObj.read( "*a" );
   }
}
_section();
{
   macro _hoge() {
      {
         __var.abc = "abc";
      }
   }
   _hoge();
   macro _hoge2() {
      {
         let txt = (unwrap __var.abc)@@str;
      }
      print( ,,txt );
   }
   _hoge2();
}
_section();
{
   let txt = "123456789";
   let mut map:Map<str,int> = {};
   fn func( val:str, from:int, to:int ) {
      print( from, to, val );
   }
   for index = 1, #txt + 1 {
      func( txt.sub( index ## ), index, 0 );
   }
   for index = 1, #txt + 1{
      for subindex = 1, #txt + 1{
         func( txt.sub( index, subindex ), index, subindex );
         func( txt.sub( index, -subindex ), index, -subindex );
         func( txt.sub( -index, subindex ), -index, subindex );
         func( txt.sub( -index, -subindex ), -index, -subindex );
      }
   }

   forsort len, val in map {
      print( len, val );
   }
}
_section();
{
   let val = "abcd";
   if val.find( "^abc", -1 ## ) {
      print( "hoge" );
   }
   if val.find( "^abc", 0 ## ) {
      print( "hoge" );
   }
   if val.find( "^abc", 1 ## ) {
      print( "hoge" );
   }
   if val.find( "^abc", 2 ## ) {
      print( "hoge" );
   }
   print( string.find( "abcd", "^abc", 0 ## ) );
   let txt = "1234567890";
   print( txt.find( "67"## ) );
   print( txt.find( "90"## ) );
   print( txt.find( "0"## ) );
   print( string.find( '"%s\\t"', '[^%%]%%[%d]*%a'## ) );
}
_section();
{
   fn func():...<int!> {
      return 1,2;
   }
   fn hoge() {
      let! index = func() {
         return;
      };
      print( index );
   }
   hoge();
}
_section();
{
   let txt = ```
1	2
```;
   print( txt );
}
_section();
{
   let code = ```
return { 1, 2, 3, 4 };
```;
   __luago {
      if! let loaded = _load( code, nil ) {
         let obj = loaded( ## );
         if! let map = expandLuavalMap( obj ) {
            forsort val, key in map@@_Map<int,int> {
               print( key + 10, val + 20 );
            }
         }
      }
   }
}
_section();
{
   print( (unwrap tonumber( "0xFFFD" ##) default 0)@@int );
}
_section();
{
   class Test {
      let mut val:int {pub};
      pub let mut test:Test! {pub};
      pub let mut list:&List<Test>! {pub};
      pub let mut map:&Map<int,Test>! {pub};
      pub fn __init() {
         self.test = self;
         self.val = 0;
         self.list = [ self ];
         self.map = { 1:self };
      }
      pub fn func() mut :Test! {
         self.val = self.val + 1;
         return self;
      }
      pub fn clear() mut {
         self.val = 0;
      }
   }

   fn sub( lineNo:int, test:&Test! ) {
      print( lineNo, test$.$val );
   }

   fn func(test:Test!) {
      macro _sub( exp:__exp ) {
         sub( __line__, ,,exp );
         test$.clear$();
      }
      
      // get, get, get
      _sub( test$.$test$.$test$.$test );
      // get, get, filed
      _sub( test$.$test$.$test$.test );
      // get, get, call
      _sub( test$.$test$.$test$.func$() );
      // get, get, call
      _sub( test$.$test$.$test$.$list$[1] );
      // get, get, call
      _sub( test$.$test$.$test$.$map$[ 1 ] );
      // get, field, get
      _sub( test$.$test$.test$.$test );
      // get, field, field
      _sub( test$.$test$.test$.test );
      // get, field, call
      _sub( test$.$test$.test$.func$() );
      // get, call, get
      _sub( test$.$test$.func$()$.$test );
      // get, call, filed
      _sub( test$.$test$.func$()$.test );
      // get, call, call
      _sub( test$.$test$.func$()$.func$() );

      // field, get, get
      _sub( test$.test$.$test$.$test );
      // field, get, filed
      _sub( test$.test$.$test$.test );
      // field, get, call
      _sub( test$.test$.$test$.func$() );
      // field, field, get
      _sub( test$.test$.test$.$test );
      // field, field, field
      _sub( test$.test$.test$.test );
      // field, field, call
      _sub( test$.test$.test$.func$() );
      // field, call, get
      _sub( test$.test$.func$()$.$test );
      // field, call, filed
      _sub( test$.test$.func$()$.test );
      // field, call, call
      _sub( test$.test$.func$()$.func$() );

      // field, get, get
      _sub( test$.func$()$.$test$.$test );
      // field, get, filed
      _sub( test$.func$()$.$test$.test );
      // field, get, call
      _sub( test$.func$()$.$test$.func$() );
      // field, field, get
      _sub( test$.func$()$.test$.$test );
      // field, field, field
      _sub( test$.func$()$.test$.test );
      // field, field, call
      _sub( test$.func$()$.test$.func$() );
      // field, call, get
      _sub( test$.func$()$.func$()$.$test );
      // field, call, filed
      _sub( test$.func$()$.func$()$.test );
      // field, call, call
      _sub( test$.func$()$.func$()$.func$() );
   }
   func( new Test() );
   func( nil );
}
_section();
{
   form testFunc();
   class Hoge {
      pub let test:testFunc;
   }
   let hoge = new Hoge( fn() { print( "hoge" ); } );
   hoge.test();
}
_section();
{
   let val:stem = 1;
   print( val@@@SubPkg.Hoge );
}
_section();
{
   fn loadCode( code:str ) : Luaval<&stem>! {
      let ret;
      __luago {
         let loaded, mess = _load( code ## );
         when! loaded {
            if! let obj = loaded(##) {
               ret = obj;
            } else {
               error( "failed to load" );
            }
         } else {
            error( "%s -- %s" (mess, code) );
         }
      }
      return ret;
   }
   form toListEmptyLua() : &_List<&stem>;
   let luaFunc = unwrap loadCode( "return function() return { 'a', 'b', 'c' } end" );
   let toListEmpty = luaFunc@@toListEmptyLua;
   __luago {
      let valList = toListEmpty();
      foreach val, key in valList {
         print( "%s %s" ( expandLuavalMap( key ), expandLuavalMap( val ) ) );
      }
   }
}
_section();
class HogeHogeHoge {
   static let val:int {pub};
   __init {
      HogeHogeHoge.val = 1;
   }
}
print( HogeHogeHoge.$val );
_section();
{
   class Super {
      pub fn func():int {
         return 1;
      }
   }
   class Hoge extend Super {
   }

   fn func() : &Hoge, &Hoge {
      return new Hoge(), new Hoge();
   }
   {
      let val1:&Super;
      let val2:&Hoge;
      val1, val2 = func();
      print( val1.func(), val2.func() );
   }
   {
      let val1:&Hoge;
      let val2:&Hoge;
      val1, val2 = func();
      print( val1.func(), val2.func() );
   }
   {
      let txt = "aaa";
      let mut nonNumIndex = 1;
      unwrap! nonNumIndex = txt.find( '[^%d]', nonNumIndex ## ) {
         error( "" );
      };
      print( nonNumIndex );
   }
}
_section();
{
   class RunItem extend (__AsyncItem,Mapping) {
      let result:bool {pub};
   }


   abstract class Runner extend (__Runner) {
      _lune_control default_async_this_class;
      
      pub abstract fn runMain() mut;

      pub fn run() mut {
         self.runMain();
      }

      
      pub fn start() mut {
         __run( self, 0, "" );
      }
      pub fn getResult() mut {
         __join(self);
      }
   }

   {
      class TestRunner extend Runner {
         _lune_control default_async_this_class;

         let txt:str;
         
         pub fn __init( txt:str) {
            super();
            self.txt = txt;
         }
         
         pub override fn runMain() mut {
            fn fib_lns( num:int ) : int {
               if num < 2 {
                  return num;
               }
               return fib_lns( num - 2 ) + fib_lns( num - 1 );
            }
            fib_lns( 25 );
         }
      }


      let list:List<Runner> = [];
      for index = 1, 100 {
         let mut test = new TestRunner( "%d" (index) );
         test.start();
         list.insert( test );
      }
      foreach test in list {
         test.getResult();
      }
   }

   {
      class TestRunner extend Runner {
         _lune_control default_async_this_class;

         let funcObj:Luaval<form>;
         let mapObj:Luaval<&Map<str,int>>;
         let listObj:Luaval<&List<str>>;

         
         pub fn __init( txt:str) {
            super();

            fn loadlua( code:str ) __noasync : Luaval<&stem> {
               let obj;
               __luago {
                  let! loaded = _load( code, nil ) {
                     error("load error");
                  };
                  if! loaded( ## ) {
                     obj = _exp;
                  } else {
                     error( "lua func error" );
                  };
               }
               return obj;
            }

            __asyncLock {
               self.funcObj = loadlua( "return function() return 1 end" )@@Luaval<form>;
               self.mapObj = loadlua( "return { val = 10 }" )@@Luaval<&Map<str,int>>;
               self.listObj = loadlua( "return { 'a', 'b', 'c' }" )@@Luaval<&List<str>>;
            }
         }
         
         pub override fn runMain() mut {
            __luaLock {
               {
                  print( #self.listObj );
                  foreach val, key in self.listObj {
                     print( key, val );   
                  }
                  print( self.listObj[ 1 ] );
               }
               {
                  print( self.mapObj.val );
                  print( self.mapObj[ "val" ] );
                  forsort val, key in self.mapObj {
                     print( key, val );   
                  }
               }
               {
                  self.funcObj(##);
               }
            }
         }
      }


      let list:List<Runner> = [];
      for index = 1, 1 {
         let mut test = new TestRunner( "%d" (index) );
         test.start();
         list.insert( test );
      }
      foreach test in list {
         test.getResult();
      }
   }
}
_section();
{
   form Closure();
   fn func( val:int ) : Closure, Closure {
      let mut work = val;
      fn create( val2:int ): Closure {
         return fn() {
            work = work + val2;
         };
      }
      fn sub2() {
         print( work );
      }
      return create( 10 ), sub2;
   }
   {
      let sub1, sub2 = func( 1 );
      let sub10, sub20 = func( 100 );
      sub1();
      sub10();
      sub2();
      sub20();
   }
}
_section();
{
   abstract class Runner extend (__Runner) {
      _lune_control default_async_this_class;
      
      pub fn __init() {
      }
      
      pub abstract fn runMain() mut;

      pub fn run() mut {
         self.runMain();
      }

      
      pub fn start() mut {
         __run( self, 0, "" );
      }
      pub fn join() mut {
         __join( self );
      }
   }

   fn busyWait( count:int ) {
      let mut total = 0;
      for _ = 0, count * 1000000 {
         total = total + 1;
      }
   }

   class TestRunner extend Runner {
      _lune_control default_async_this_class;

      let txt:str;
      let mut fin:bool {pub};
      
      pub fn __init( txt:str) {
         super();
         self.txt = txt;
         self.fin = false;
      }
      
      pub override fn runMain() mut {
         for _ = 1, 10 {
            __asyncLock {
               busyWait( 10 );
            }
         }
         self.fin = true;
      }
   }

   class TestRunner2 extend Runner {
      _lune_control default_async_this_class;

      let mut fin:bool {pub};
      
      pub fn __init( txt:str) {
         super();
         self.fin = false;
      }
      
      pub override fn runMain() mut {
         let mut test = new TestRunner("hoge");
         let mut test2 = new TestRunner("hoge2");
         print( "hoge start" );
         test.start();
         test2.start();
         test.join();
         test2.join();
         print( "hoge end" );

         if test.$fin and test2.$fin {
            self.fin = true;
         } else {
            print( "hoge", test.$fin, test2.$fin );
         }
      }
   }
   {
      let list:List<TestRunner2> = [];
      for index = 1, 1 {
         let mut test = new TestRunner2( "%d" (index) );
         test.start();
         list.insert( test );
      }
      busyWait( 300 );
      foreach test in list {
         test.join();
         print( "wait done2" );
         print( "fin", test.$fin );
      }
   }
}
_section();
{
   class Super {
      pub fn func() {
         print( "1" );
      }
   }
   interface IF {
      pub fn func();
   }
   class Sub extend Super (IF) {
   }

   let sub = new Sub();
   sub.func();
}
_section();
{
   class Super {
      pro fn __init( val1:int, val2:int ) {
         print( val1, val2 );
      }
      pro fn sub( val1:int, val2:int ) {
         print( val1, val2 );
      }
   }
   class Hoge extend Super {
      static fn func() : int, int {
         return 1, 2;
      }
      pro override fn sub( val1:int, val2:int ) {
         super( Hoge.func()** );
      }
      pub fn __init() {
         super( Hoge.func()** );
         self.sub( 3, 4 );
      }
   }
   new Hoge();
}
_section();
{
   class Runner extend (__Runner) {
      _lune_control default_async_this_class;

      let mut flag:__lns.Sync.Flag!;

      pub fn __init() {
         self.flag = __lns.Sync.createFlag();
         __run( self, __lns.runMode.Queue, "" );
      }
      
      pub fn run() mut {
         print( "run" );
         for _ = 1, 100000 {
         }
         print( "set" );
         if! self.flag {
            _exp.set();
         }
      }

      pub fn get() {
         if! self.flag {
            _exp.wait();
         }
         print( "get" );
      }
   }

   let runner = new Runner();
   runner.get();
   print( "get2" );
}
// _section();
// {
//    fn func() {
//       __lns.runtime.log( "hoge" );
//    }

//    __lns.runtime.enableLog( true );
   
//    let mut processor = __lns.Sync.createProcesser( "test" );
//    __request processor func();

//    if! let mut stream = io.open( "log", "w") {
//       __lns.runtime.dumpLog( stream );
//       stream.seek( "set", 0);
//       while true {
//          let! line = stream.read( "*l" ) {
//             break;
//          };
//          print( (line.gsub( "^ *%d+:", "ONLY_GO:" )) );
//       }
//       stream.close();
//    }
//    processor.end();

//    __lns.runtime.enableLog( false );
// }
_section();
{
   class Val extend (__absimmut) {
      let val:int;
      pub fn func() : int {
         return self.val;
      }
   }

   class Hoge {
      let val:Val;
      pub fn func2(): &Val {
         return self.val;
      }
   }

   let mut test = new Hoge( new Val(1) );
   for index = 1, 1000 * 1000 {
      test = new Hoge( new Val(index) );
   }
   print( test.func2().func() );
   let list = [ new Val( 1 ) ];
   foreach val in list {
      print( val.func() );
   }
   {
      let hoge:Val! = new Val( 1 );
      when! hoge {
         print( hoge.func() );
      }
   }
   {
      let map:Map<Val,Val> = { new Val(1): new Val(2) };
      foreach val, key in map {
         print( key.func(), val.func() );
      }
   }
}
_section();
{
   fn replace( txt:str, src:str, dst:str ) : str {
      return txt.replace( src, dst );
   }
   print( replace( "abcdefgab", "ab", "AB" ) );
   print( replace( "abcdbcdefgab", "bcd", "BCD" ) );
   print( replace( "a[bcd]ebcdefgab", "[bcd]", "BCD" ) );
}
_section();
{
   class Hoge {
      pub fn __init() {
         print( __func__ );
      }
   }
}
_section();
{
   class Super {
      pub fn func() {
      };
   }
   class Sub extend Super {
      pub override fn func() {
      };
   }
   class SubSub extend Sub {
      let sub:&Sub;
      pub fn __init( sub:&Sub ) {
         super( );
         self.sub = sub;
      }

      advertise sub;
   }
}
_section();
{
   fn func() : Map<int,int>, int! {
      return {}, 1;
   }
   if! let map, val = func() {
      print( map[ 0 ], val );
   }

   fn sub() {
      let! map, val = func() {
         return;
      };
      print( map[ 0 ], val );
   }
   sub();
}
_section();
{
   fn func(): int, int!, int {
      return 1, 2, 3;
   }
   fn sub() {
      if! let val, val2 = func() {
         print( __line__, val + 1, val2 + 2 );
      }
      {
         let! val, val2 = func() {
            return;
         };
         print( __line__, val + 1, val2 + 2 );
      }
      if! let val, val2, _ = func() {
         print( __line__, val + 1, val2 + 2 );
      }
      {
         let! val, val2, _ = func() {
            return;
         };
         print( __line__, val + 1, val2 + 2 );
      }
   }
   sub();
}
_section();
{
   alge Hoge<T1,T2> {
      Val(T1,T2)
   }
   {
      let hoge = Hoge.Val( 1, "abc" );
      match hoge {
         case .Val(param1,param2) {
            print( param1 + 10, param2 .. "hoge"  );
         }
      }
   }
}
_section();
{
   interface IF1 {
      pub fn func();
   }
   class Hoge2 extend (IF1) {
      pub fn func() {
         print( __func__ );
      }
   }
   fn func1(if1:IF1) {
      if1.func();
   }
   fn func2<T:(IF1)>(t:T) {
      func1( t );
   }
   func2( new Hoge2() );
}
_section();
{
   form Func<T>( val: T) : T;
   class Hoge<T> {
      let val:T;
      pub fn sub( func:Func<T> ) : T {
         return func( self.val );
      }
   }
   let hoge = new Hoge( "abc" );
   print( "000" .. hoge.sub( fn ( val:str ) : str {
      return val .. "xyz";
   }) );
}
_section();
{
   if! let pipe = __lns.Sync._createPipe( int, 1 ) {
      pipe.put( 10 );
      print( (unwrap pipe.get()) + 1, "ONLY_GO" );
   }
}
_section();
{
   abstract class Hoge<T1,T2> {
      pub abstract fn func1() : T1;
      pub abstract fn func2() : T2;
   }

   class Sub extend Hoge<A=int,B=str> {
      pub override fn func1() : A {
         return 10;
      }
      pub override fn func2() : B {
         return "abc";
      }
      pub fn sub() {
         print( self.func1() + 1, self.func1() + 1,
                self.func2() .. "xyz", "xyz" .. self.func2() );
      }
   }
   let sub = new Sub();
   sub.sub();
}
_section();
{
   {
      interface IF<T> {
         pub fn func() : T;
      }
      class Hoge extend (IF<A=int>) {
         pub fn func() : A {
            return 10;
         }
      }
      let hoge = new Hoge();
      print( hoge.func() + 1) ;
   }
   {
      interface IF<T> {
         pub fn func(val:T);
      }
      class Hoge extend (IF<int>) {
         pub fn func( val:int ) {
            print( val + 10 );
         }
      }
      let hoge = new Hoge();
      hoge.func( 1 );
   }
}
_section();
{
   // 非同期処理で T 型のデータを生成する際の基底クラス。
   // 実際に非同期処理する場合は、この基底クラスを派生し、
   // runMain() メソッドを override 実装する。
   abstract class RunnerBase<T> extend (__Runner, __AsyncItem ) {
      let pipe:__pipe<RunnerBase<T>>!;
      let mut artifact:T! {pub};
      let mut ranFlag:bool {pub};

      pub fn __init( pipe:__pipe<RunnerBase<T>>! ) __async {
         self.pipe = pipe;
         self.artifact = nil;
         self.ranFlag = false;
      }

      pro abstract fn runMain() __async mut : T;
      
      pub fn run() __async mut {
         self.artifact = self.runMain();
         self.ranFlag = true;
         
         if! let pipe = self.pipe {
            pipe.put( self );
         }
      }
   }

   // RunnerBase<T> で非同期処理した結果の T を処理するコールバック関数型。
   form EndProcessFunc<T>( t:RunnerBase<T> ) __trans;

   // RunnerBase<T> の非同期処理開始と、処理終了待ちを制御する。
   class RunnerWaiter<T> {
      let pipe:__pipe<RunnerBase<T>>!;
      let mut startNum:int;
      let finTargetList:List<RunnerBase<T>>;

      pub fn __init(pipe:__pipe<RunnerBase<T>>!) __async {
         self.pipe = pipe;
         self.startNum = 0;
         self.finTargetList = [];
      }
      
      local fn startTarget( target: RunnerBase<T>, mode:int, name:str ) mut : bool {
         self.startNum = self.startNum + 1;
         let result = __run( target, mode, name );
         if not result or not self.pipe {
            self.startNum = self.startNum - 1;
            self.finTargetList.insert( target );
         }
         return result;
      }

      pub fn wait( func:EndProcessFunc<T> ) __async mut {
         if! let pipe = self.pipe {
            for _ = 1, self.startNum {
               let! mut runner = pipe.get() {
                  break;
               };
               func( runner );
            }
         }
         foreach target in self.finTargetList {
            func( target );
         }
      }
   }

   // 実際に非同期処理を書くクラス。
   // RunnerBase<T=str> を派生している。
   // T=str は、結果が T で、 runMain() の戻り値として T を利用する。
   class TestRunner extend RunnerBase<T=str> {
      let num:int;
      pro override fn runMain() __async mut : T {
         return "%d" (self.num);
      }
   }

   {
      let mut pipe = __lns.Sync._createPipe( RunnerBase<str>, 1 );
      let mut endProcess = new RunnerWaiter<str>( pipe );

      for count = 1, 10 {
         let mut hoge = new TestRunner( pipe, count );
         endProcess.startTarget( hoge, __lns.runMode.Queue, "test" );
      }

      // 出力確認ソート用に一度マップに登録する
      let map:Map<str,RunnerBase<str>> = {};
      endProcess.wait(
         fn ( runner: RunnerBase<str> ) {
            let! val = runner.$artifact {
               return;
            };
            map[ val ] = runner;
         }
      );
      forsort runner in map {
         print( runner.$ranFlag, runner.$artifact );
      }
   }
}
_section();
{
   __luago {
      let! mut proc = io.popen( "ls" ) {
         error( "error ls" );
      };
      if not proc.read( "*a" ) {
         error( "read error" );
      };
      proc.close();
   }
}
_section();
{
   alge Result<T1,T2>{
      Ok( val:T1 ),
      Ng( val:T2 ),
   }

   class LnsErr extend (__Er) {
      pub fn get_txt() __async : str {
         return "hoge";
      }
   }

   fn func( index:int ) : Result<str,__Er> {
      if index == 1 {
         return .Ok("ok!!");
      }
      return .Ng( new LnsErr() );
   }

   for index = 1,2 {
      match func( index ) {
         case .Ok(val) {
            print( val );
         }
         case .Ng( val ) {
            print( val.$txt );
         }
      }
   }
}
_section();
{
   class Hoge {
      pub fn func(): &Hoge! {
         return nil;
      }
      pub fn sub(): &Hoge! {
         return nil;
      }
      pub fn ok(): &Hoge! {
         return self;
      }
      pub fn foo() {
         print( "ok" );
      }
   }

   fn func(hoge:Hoge!,index:int): str! {
      switch index {
         case 0 {
            hoge!.foo();
         }
         case 1 {
            hoge!.func()!.foo();
         }
         case 2 {
            hoge!.func()!.sub()!.foo();
         }
      }
      return nil;
   }

   let mut hoge = new Hoge();
   func( hoge, 2 );
   func( hoge, 1 );
   func( hoge, 0 );
}
_section();
{
   fn func1(val:int) : __Ret<str,int> {
      if val == 0 {
         return .Err( 0 );
      }
      return .Ok( "ok" );
   }
   for index = 0, 1 {
      match func1( index ) {
         case .Ok( val ) {
            print( val .. "abc" );
         }
         case .Err( val ) {
            print( val + 10 );
         }
      }
   }
   fn create(): __Er {
      return __serr( "foo" );
   }
   let err = create();
   print( err.$txt );
}
_section();
{
   class Hoge {
      let val:str {pub};
      pub fn func(val:int) : __Ret<&Hoge,__Er> {
         if val == 1 {
            return .Err( __serr( "err" ) );
         }
         return .Ok( self );
      }

      fn foo() {
         print( __func__ );
      }

      fn bar() : str! {
         return __func__;
      }

      pub fn sub(val:int) : __Ret<str,__Er> {
         let obj = self.func(val)!;
         switch val {
            case 2 {  
               if! obj.func(val)!.bar() {
                  return .Ok( _exp );
               }
            }
            case 3 {
               if! let txt = obj.func(val)!.bar() {
                  return .Ok( txt .. "xyz" );
               }
            }
         }
         return .Ok( obj.$val );
      }
   }
   let hoge = new Hoge( "abc" );
   for index = 1, 4, 1 {
      print( index );
      match hoge.sub( index ) {
         case .Err( err ) {
            print( "err", err.$txt );
         }
         case .Ok( val ) {
            print( "ok", val );
         }
      }
   }
}
_section();
{
   class Hoge {
      let val:str {pub};
      pub fn func(val:int) : __Ret<&Hoge,__Er> {
         if val == 1 {
            return .Err( __serr( "err" ) );
         }
         return .Ok( self );
      }

      fn foo() {
         print( __func__ );
      }

      fn bar() : str! {
         return __func__;
      }

      pub fn sub(val:int) : __Ret<str,__Er> {
         if self.func(val)!.$val == self.$val {
            return .Ok( self.val );
         }
         return .Ok( "NG" );
      }
   }
   let hoge = new Hoge( "abc" );
   for index = 1, 2 {
      print( index );
      match hoge.sub( index ) {
         case .Err( err ) {
            print( "err", err.$txt );
         }
         case .Ok( val ) {
            print( "ok", val );
         }
      }
   }
}
_section();
{
   fn func() : (int,str) {
      return (= 1, "abc");
   }

   {
      let val1, val2 = func()...;
      print( val1 + 10, val2 .. "xyz" );
   }
}
_section();
{
   fn func() : List<(a:int,b:str)> {
      return [(= 1, "abc"), (= 2, "ABC")];
   }

   {
      foreach tuple in func() {
         let val1 = tuple...;
         print( val1 + 10 );
      }
   }
   {
      foreach tuple in func() {
         let val1, val2 = tuple...;
         print( val1 + 10, val2 .. "xyz" );
      }
   }
}
_section();
{
   fn sub(flag:bool) : __Ret<(int,str),__Er> {
      if flag {
         return .Ok( (=1,"abc") );
      }
      return .Err( __serr( "err" ));
   }

   fn func(flag:bool) : __Ret<int,__Er> {
      let val1, val2 = sub(flag)!...;
      let val3, val4 = sub(flag)!...;
      print( val1, val2, val3, val4 );
      return .Ok( val1 + val3 );
   }

   foreach cond in [true,false] {
      match func( cond ) {
         case .Ok( val ) {
            print( "ok", val );
         }
         case .Err( val ) {
            print( "ng", val.$txt );
         }
      }
   }
}
_section();
{
   fn sub(flag:bool) : (int,str)!,str! {
      if flag {
         return (= 1,"abc"),nil;
      }
      return nil, "err";
   }

   fn func(flag:bool) : int!,str! {
      let val1, val2 = sub(flag)!...;
      let val3, val4 = sub(flag)!...;
      print( val1, val2, val3, val4 );
      return val1 + val3, nil;
   }

   foreach cond in [true,false] {
      let ok, err = func( cond );
      when! ok {
         print( "ok", ok );
      } else {
         print( "ng", err );
      }
   }
}
_section();
{
   {
      fn sub() : (str!,int) {
         return (= nil, 1 );
      }
      fn sub2() : (str!,int) {
         return (= "abc", 1 );
      }
      fn dump( tuple:(str!,int) ) {
         let val1, val2 = tuple...;
         when! val1 {
            print( val1 .. "xyz", val2 + 10 );
         } else {
            print( val2 + 10 );
         }
         print( tuple...**, 20 );
      }
      dump( sub() );
      dump( sub2() );
   }
}
_section();
{
   class Val1 {
      let val:int {pub};
   }
   class Val2 {
      let val:int {pub};
   }

   fn func(): (Val1, Val2) {
      return (= new Val1(0), new Val2(1) );
   }

   let val1, val2 = func()...;
   print( val1.$val, val2.$val );
}
_section();
{
   fn func(flag:bool): int! {
      if flag {
         return 1;
      }
      return 0;
   }
   fn sub(flag:bool): int! {
      let list:List<int> = [1];
      list[1] = func(flag)!;

      return list[1];
   }
   print( sub(true), sub(false) );
}
_section();
{
   fn func(flag:bool): int! {
      if flag {
         return 1;
      }
      return 0;
   }
   fn sub(flag:bool): int! {
      let val;
      val = func(flag)!;

      return val;
   }
   print( sub(true), sub(false) );
}
_section();
{
   class Hoge {
      pub fn func() {
         print( __func__ );
      }
   }
   class Sub extend Hoge {
   }
   class Sub2 {
   }
   fn func(): (&Hoge) {
      let sub = new Sub();
      return (= sub );
   }
   let hoge = func()...;
   hoge.func();
}
_section();
fn func1__() : str! {
   return "hoge";
}
pub let! val__ = func1__() {
   val__ = "aaa";
} then {
   print( "then", val__ );
};  
print( "next", val__ );
pub let! val1__ = func1__() {
   val1__ = "aaa";
};
print( "next", val1__ );


fn func2__() : str! {
   return nil;
}
pub let! val2__ = func2__() {
   val2__ = "aaa";
} then {
   print( "then", val2__ );
};  
print( "next", val2__ );
pub let! val3__ = func2__() {
   val3__ = "aaa";
};
print( "next", val3__ );
_section();
{
   proto class AAA;
   proto class BBB extend AAA;
   class AAA {
   }
   class BBB extend AAA {
   }
}
_section();
{
   macro _test( cond:bool, block1:__block, block2:__block ) {
      {
         let mut block;

         if cond {
            block = block1;
         } else {
            block = block2;
         }
      }
      ,,block;
   }
   macro _hoge() {
      print( "AAA" );
   }
   macro _age() {
      _test( true, { print( "hoge" ); }, { _hoge(); } );
      _test( false, { print( "hoge" ); }, { _hoge(); } );
   }
   _age();
}
_section();
{
   interface IF {
      pub fn get_val() __async :int;
   }

   class SuperSuper extend (IF) {
      let val:int{pub};
   }

   class Super extend SuperSuper {
   }
   class Sub extend Super {
   }

   fn func0( list:&List<&IF> ) {
      foreach val in list {
         print( val.$val );
      }
   }
   fn func1( list:&List<&Super> ) {
      foreach val in list {
         print( val.$val );
      }
   }
   fn func2( list:&List<&SuperSuper> ) {
      foreach val in list {
         print( val.$val );
      }
   }

   let list = [ new Sub(1), new Sub(2) ];
   {
      let obj:&IF = new Sub(1);
      print( obj.$val );
   }

   func0( [ new Super(0), new Sub(0), list.unpack() ] );
   func1( [ new Super(0), new Sub(0), list.unpack() ] );
   func2( [ new Super(0), new Sub(0), list.unpack() ] );
}
_section();
{
   interface IF {
      pub fn get_val() __async :int;
   }
   class Super extend(IF) {
      let val:int {pub};
   }
   class Sub extend Super {
   }
   fn func() :  &Super, &Super {
      return new Sub(0), new Sub(1);
   }
   fn func3(...<&Super>) {
      foreach val in [ ... ] {
         print( val.$val );
      }
   }
   fn func2(list:__List<&Super>) {
      print( "-------" );
      func3( list.unpack() );
   }
   {
      func2( [ func(), func()** ] );
      func2( [ func() ] );
   }
   {
      let list:List<&Sub> = [ new Sub(0), new Sub(1), new Sub(2) ];
      let list2:List<&Super> = [ list.unpack() ];
      func3( list2.unpack() );
   }
   {
      fn sub( obj:&Super!, obj2:&Super! ) {
         print( obj$.$val, obj2$.$val );
      }
      let list:__List<&Sub> = [ new Sub(0), new Sub(1) ];
      let list2:__List<&Sub> = [ list.unpack() ];
      func3( list.unpack() );
      func3( list2.unpack() );
      sub( list.unpack() );
   }
   fn func4(...<&IF>) {
      foreach val in [ ... ] {
         print( val.$val );
      }
   }
   {
      let list:List<&Sub> = [ new Sub(0), new Sub(1), new Sub(2) ];
      let list2:List<&IF> = [ list.unpack() ];
      func4( list2.unpack() );
   }
}
// _section();
// {
//    class Super {
//       let val:int {pub};
//    }
//    class Sub extend Super {
//    }
//    {
//       let list:List<&Sub> = [ new Sub(0), new Sub(1), new Sub(2) ];
//       let set:Set<&Super> = (@ list.unpack() );
//       foreach val in list {
//          if set.has( val ) {
//             print( val.$val );
//          }
//       }
//    }
// }   
   // _section();
   // {
   //    class Super {
   //       let val:int {pub};
   //    }
   //    class Hoge extend Super {
   //    }
   //    let flag = true;
   //    let mut work:__Map<str,&Super> = flag and {} or {};
   //    foreach val, key in work {
   //       print( key, val.$val );
   //    }
   // }
