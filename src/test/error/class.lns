class Test {
   pri static let val:int {pub};
   __init {
      Test.val = 0;
   }
   pri let mut val1:int {pub};
   pub fn __init( val:int ) {
      super( 1 ); // error
      self.val1 = val;
      return; // error: return
   }
   pri let val2:int; // error: after __init
   pub fn func( val:int ) mut {
      self.val1 = val;
   }
   pub fn func2( val:int ) mut {
      self.val1 = val;
   }
}

Test.func( 1 ); // error

{
   let test = new Test(1,2); // error
   test.func( 1, 1.0, 2.0 ); // error
   let test2 = Test; // error
   Test = test; // error
   Test = int; // error
   let val = int + 1; // error
   let mut val2 = 1;
   val2 = 1 + int; //error
   val2 = int + 1; //error
}



class Test2 {
   pri let val:int;
   pub fn __init() { // error: does not set 'val';
   }
}

class Test3 {
   pri let val1:int;
   pub let mut val2:int;
   pub static let val3:int;
   __init {
      Test3.val3 = 0;
   }
   pub fn __init() {
      self.val1, self.val2 = 0, 1;
   }
}
{
   Test3.val2 = 1; // error: access member from class.
   let mut test3 = new Test3();
   test3.val3 = 0; // error: access class member from obj.
   let mut val = 0;
   val = test3; // error
}

proto class Test4;
interface Test4 { // error
}

proto interface Test5;
class Test5 { // error
}

interface Test6 {
   pub let val:int; // error
   fn sub(); // error
   pub fn sub2() { // error
   }
}

class Test extend Test6 { // error
}

class Test7 { // error
   static let val:int;
}

class Test8 {
   static let val1:int;
   static let val2:int;
   __init {
      Test8.val1 = 1;
   }
}


class Super1 {
   pri let val:int;
   pub fn func() {
   }
   pub override fn func() { // error
   }
}

class Sub1 extend Super1 { // error: no __init
}

abstract class Super2 {
   pri let val:int!;
   pub fn func1() {
   }
   pub fn func2() {
   }
   pub fn func3() {
   }
   pub abstract fn func4() { // error
   }
}

class Sub2 extend Super2 { // error
   pub override fn func1() mut { // error
   }
   pub override fn func2(arg:int) mut { // error
   }
   pub override fn func3() mut : int { // error
   }
}

class Super3 {
   pub abstract fn func4();  // error
}

abstract class Super4 {
   pub abstract fn func4();
}

{
   let val = new Super4(); // error
}

class TestMap0 extend (Mapping) {
}

class TestMap extend (Mapping) {
   pub let val:int!;
   pub let val2:stem;
   let map1:Map<int,TestMap0>;
   let map1:Map<TestMap0,int>; // error
   let map2:Map<Super3,int>;  // error
   let map3:Map<int,Super3>;  // error
}

{
   let obj = new TestMap0();
   let mut map = obj._toMap();
   map.val = 1; // error
}


class SuperMap {
}

class SubMap extend SuperMap (Mapping) { // error
}

class PriClass {
}

pub class PubClass {
   pub fn func(): PriClass { // error
      return new PriClass();
   }
}

interface IFTest {
   pub fn func( val:int );
}

class IFTest2 extend (IFTest) {
   pub fn func( val:str );
}


pub proto abstract class TestAbs;
class TestAbs { // error
}

pub proto abstract class TestProto;
abstract class TestProto {  // error
}

interface IF {
   pub fn func();
}
abstract class extIF extend (IF) {
}
class extIF2 extend (IF) { // error
}
class subIF extend extIF { // error
}
class subIF2 extend extIF {
   pub fn func() {
   }
}


class SuperArg {
   let val:int;
}

class SubArg extend SuperArg {
   pub fn __init() {
      super( 1.0 ); // error
   }
}

class StaticClass {
   let val:int;
   static fn func() {
      self.val; // error
   }
}
