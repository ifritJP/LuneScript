subfile use test.startsub;
import test.simple;
import lune.base.Writer;
import test.Sub2;
import test.Class1;
import test.Class2;
import test.Class3;
import test.Class4;

macro _print( symbol2:stat, format:str! ) {
   {
      let work = unwrap format default "%s";
   }
   print( string.format( "macro %s " .. ,,work, ,,,,symbol2, ,,symbol2 ));
}

let mut classA = new simple.ClassA();
print( classA.func( 0 ) );
print( classA.func( 0 ) );
print( classA.sub() );

let classB = new simple.ClassB( 123 );
print( "classB.func()", classB.func() );
print( "classB.sub()", classB.sub() );
let hoge = classB.func2();
print( "Hoge.func()", hoge.func() );
Sub2.sub2val = 10;
print( "Hoge.func()", hoge.func() );

let func3ret = classB.func3() ;
foreach val in func3ret {
   print( val );
}

print( "12%d" ( 10 ) );

{
   let val = 1;
   print( "%g" (val@@real));
}

print( "op", type( {} ),  1 and "2" and 3.0 and type( {} ) );
print( "op", 3.0, 1 and "2" and 3.0 or  {} );
print( "op", "2", 1 and "2" or  3.0 and {} );
print( "op", "2", 1 and "2" or  3.0 or  {} );
print( "op", 1,   1 or  "2" and 3.0 and {} );
print( "op", 1,   1 or  "2" and 3.0 or  {} );
print( "op", 1,   1 or  "2" or  3.0 and {} );
print( "op", 1,   1 or  "2" or  3.0 or  {} );

for index = 1, 4 {
   switch index {
      case 1, 2 {       
         print( "hoge", index );
      }   
      case 3 {
         print( "foo", index );
      }   
      default {
         print( "bar", index );
      }   
   }   
}

fn func( val: int! ): int {
   let! val2 = val { return 0; };
   
   return val2 + 2;
}

print( 3, func( 1 ) );
print( 0, func( nil ) );

macro _test() {
   print( "macro hoge" );
}
_test();


macro _test2( val:int, funcxx:sym ) {
   {
      fn func(val2:int):str {
         return "mfunc%d" (val2);
      }
      let message = "hello %d %s" ( val, ,,,,funcxx );
      let stat = `{ print( "macro stat" ); };
      let stat2 = `{
         for index = 1, 10 {
            print( "hoge %d" ( index ) );
         }
      };
      let mut stat3:stat[] = [];
      for index = 1, 4 {
         stat3.insert( `{ print( "foo %d" ( ,,index ) ); } );
      }
      let symbol1 = ,,,func( 1 );
      let symbol2 = ,,,"mfunc%d" (1);
      let stat4 = `{
         ,,symbol1( "100" );
         ,,symbol2( ,,func( 2 ) );
         ,,,func(1)~~( ,,,,symbol1 );
      };
   }
   print( ,,message );
   print( "--funcxx--" );
   ,,funcxx( "macro test2" );
   print( "--stat--" );
   ,,stat;
   print( "--stat2--" );
   ,,stat2;
   print( "--stat3--" );
   ,,stat3;
   print( "--symbol1--" );
   ,,symbol1( "10" );
   print( "--stat4--" );
   ,,stat4;
}

fn mfunc1( val: str ) {
   print( "mfunc1", val );
}


_test2( 1, print );

macro _classtest( macroVal: int, fieldInfoList: Map<str,str>[] ) {
   {
      let name = ,,,"classTest%d" (macroVal);
      let mut field:stat[] = [];

      if fieldInfoList {
         foreach fieldInfo in fieldInfoList {
            foreach typeName, varName in fieldInfo {
               field.insert( `{
                  pri let ,,,varName : ,,,typeName { pub };
               });
            }
         }
      }
   }
   class ,,name {
      ,,field;
      pub fn func(): int {
         return ,,macroVal;
      }
   }
}

_classtest( 1, [ { "val": "int" }, { "val2": "str" } ] ) ;
_classtest( 2, [] );
_classtest( 3, [] );

{
   let classObj = new classTest1( 1000, "2000" );
   print( classObj.func(), classObj.get_val(), classObj.get_val2() );
}
{
   let classObj = new classTest2();
   print( classObj.func() );
}
{
   let classObj = new classTest3();
   print( classObj.func() );
}


macro _stattest( val: stat ) {
   ,,val;
}

_stattest(
   `{
      print( "1" );
      print( "2" );
   } );

macro _symboltest( symbol: sym, val:stem ) {
   print( ,,symbol( ,,val ) );
}

_symboltest( string.format, "test\n" );



class GetTest {
   let val: int { pub };
   pub fn __init() {
      self.val = 100;
   }
}
print( (new GetTest()).$val );

class GetTest2 {
   let val: int { pub };
   pub fn __init() {
      self.val = 200;
   }
}
print( (new GetTest2()).$val );

{
   fn TestRetDDD(): ... {
      return 1,2,3;
   }   
   let! ddd1, ddd2, ddd3 = TestRetDDD() {
      error( "fail" );
   };
   print( "2 = %d, 3 = %d, 4 = %d"
          (ddd1@@int + 1, ddd2@@int + 1, ddd3@@int + 1 ) );
}

{
   let nilableInt1: int! = nil;
   let! unwrapInt1, unwrapInt2: int = nilableInt1, nil {
      unwrapInt1 = 123; unwrapInt2 = unwrap _unwrapInt2 default -456; }
   then {
      print( "NG" );
   };
   print( "123 = %d, -456 = %d" ( unwrapInt1, unwrapInt2 ) );
}

{
   let nilableInt1: int! = 567;
   let! unwrapInt1, unwrapInt2: int = nilableInt1, 890 {
      unwrapInt1 = 123; unwrapInt2 = 456; };
   print( "567 = %d, 890 = %d" (unwrapInt1, unwrapInt2 ) );
}

{
   let hoge1: int = 1;
   let hoge2: int = 2;
   unwrap! hoge1, hoge2 = 3, 4 {
      print( "NG" );
   }
   then {
      print( "3 = %d, 4 = %d" ( hoge1, hoge2 ) );
   };
   print( "3 = %d, 4 = %d" ( hoge1, hoge2 ) );
}

{
   let mut hoge1: int = 1;
   let mut hoge2: int = 2;
   sync! hoge1, hoge2 = 3, 4 {
      print( "NG" );
   }
   then {
      print( "3 = %d, 4 = %d" ( hoge1, hoge2 ) );
   }
   do {
      print( "3 = %d, 4 = %d" ( hoge1, hoge2 ) );
      hoge1 = hoge1 * 10;
      hoge2 = hoge2 * 10;
   };
   print( "30 = %d, 40 = %d" ( hoge1, hoge2 ) );
}



{
   let nilableInt1: int! = null;
   if! nilableInt1 {
      print( _exp, "not nil" );
   }
   else {
      print( "nil" );
   }
}

{
   let nilableInt1: int! = 1;
   if! nilableInt1 {
      print( _exp, "not nil" );
   }
   else {
      print( "nil" );
   }
}

{
   let test: int! = nil;
}

{
   let mut val:int! = nil;
   if! let val1, val2:int = 1, val {
      print("NG");
   }
   else {
      print( "OK" );
   }
   val = 2;
   if! let val1, val2:int = 1, val {
      print( "OK", val1, val2 );
   }
   else {
      print("NG");
   }
}

fn testret() : int! {
   return nil;
}

{
   let mut arry: int[] = [];
   arry.insert( 1 );
   foreach val, index in arry {
      print( index, val );
   }
   arry.remove();
}

{
   print( 10 / 3, 10 / 3.0, (10 / 3.0)@@int );
}

{
   foreach val in [ 1, 2, 3 ] {
      let val2:int = val;
   }
}   

class ClassAA {
   pri static let val:int { pub };

   __init {
      ClassAA.val = 1;
   }
   
   pub static fn func() {
      print( "val = %s" (ClassAA.val) ) ;
   }
}

ClassAA.func();
_print( `{ ClassAA.$val } );
{
   let classAA = new ClassAA();
}

Sub2.External.func1( 100 );
Sub2.External.func2( 10 );
Sub2.External.func2( 20 );
_print( `{ Sub2.External.val } );

{
   let foo = {
      "bar": {
         "baz": 1,
         "hoge": [ 'a', 'b', 'c' ],
         "sage": "xyz",
      }
   };

   _print( `{ foo$.bar$.baz }, "%s" );
   _print( `{ foo$.ba$.baz }, "%s" );
   _print( `{ foo$.bar$.hoge$[1] }, "%s" );
   _print( `{ foo$.ba$.hoge$[1] }, "%s" );
   _print( `{ foo$.bar$.sage$[1] }, "%c" );
   _print( `{ foo$.ba$.sage$[1] }, "%s" );
}

{
   class Test {
      let val:int;
      pub fn func(): int {
         return self.val;
      }
   }
   let test:Test! = new Test( 1 );
   _print( `{ test$.func$() } );
   let test2:Test! = nil;
   _print( `{ test2$.func$() } );
   let mut funcnil:form! = fn():int { return 1; };
   _print( `{ funcnil$() } );
   funcnil = nil;
   _print( `{ funcnil$() } );
}


{
   interface IF {
      pub fn func(): int;
   }
   class TestCC extend (IF) {
      pub fn func(): int {
         return 1;
      }
   }
   let test:IF = new TestCC();
   _print( `{ test.func() } );
}

{
   let mut val1, mut val2 = 1, 2;
   val1, val2 = 3, 4;
   _print( `{ val1 } );
   _print( `{ val2 } );
}

{
   class TestDD {
      pri let val:int { pub };
      pub fn func1(): int {
         return 1 + self.val;
      }
      pub fn func2(): int {
         return 2 + self.val;
      }
   }
   class TestEE {
      pri let testDD: TestDD;
      pub fn __init() {
         self.testDD = new TestDD( 100 );
      }
      pub fn func1(): int {
         return 3;
      }
      advertise testDD;
   }
   let testEE = new TestEE();
   _print( `{ testEE.func1() } );
   _print( `{ testEE.func2() } );
}

{
   let mut jsonWriter = new Writer.JSON( io.stdout );
   jsonWriter.startParent( "hoge", true );
   jsonWriter.write( "foo", "bar" );
   jsonWriter.endElement();
   jsonWriter.fin();
}

{
   let val = 0xff1;
   _print( `{ val } );
}


{
   enum enumTest {
      val1,
      val2,
      val3 = val2 + 10 - 1 * 2 / 3,
      val4
   }
   _print( `{ enumTest.val4 } );
   let mut val2 = 0;
   val2 = enumTest.val1;

   enum enumTest2 {
      val1 = 1.0,
      val2,
      val3 = val2 + 10 - 1 * 2 / 3,
      val4
   }
   _print( `{ enumTest2.val4 } );
   
}

{
   let mut val = { "abc": 1 };
   //val.abc = 1;
}

{
   let mut val = { "abc": 1 };
   print( val.abc );
   val.abc = 2;
   val.efg = 3;
   val[ "zzz" ] = 4;
   print( val[ "ab" .. "c" ], val.efg, val.zzz );
}

interface IFTEST {
   pub fn sub();
}

class TEST2 extend (IFTEST) {
   pub fn sub() {
      print( "TEST2.sub()" );
   }
}


class TEST extend (IFTEST) {
   let iftest:IFTEST;

   advertise iftest;
}

{
   let test = new TEST( new TEST2() );
   test.sub();
}

enum TESTENUM {
   val1,
   val2,
   val3,
}

enum TESTENUM2 {
   val1 = 100,
   val2,
   val3,
}

{
   let mut val = TESTENUM.val1;
   val = .val1;
   print( val );
   val = .val2;
   print( val );

   switch ( val ) {
      case .val1, .val2 {
         print( "ok" );
      }  
      default {
         print( "ng" );
      }  
   }

   fn testenum( enum1:TESTENUM, enum2:TESTENUM2 ) {
      print( "testenum", enum1, enum2 );
   }
   testenum( .val2, .val2 );
}

class TestDest {
   let mut val:int;
   fn __free() {
      self.val = self.val * 10;
      print( "__free(): %d" (self.val) );
   }
}
// new TestDest( 100 );


module GlueTest require 'test.glueTest' glue 'hoge_' {
   pub static fn create(val:int): GlueTest;
   pub static fn func1( val:int, txt:str, list:int[] ) : int;
   pub fn func2( val:int, val2:int!, val3:real!, val4:str! ): str;
   //pub fn func2( val:int ): str;
}

GlueTest.func1( 10, "abc", [] );
let age = GlueTest.create( 100 );
age.func2( 2 );
age.func2( 2, 3, 4.0, "xyz" );
