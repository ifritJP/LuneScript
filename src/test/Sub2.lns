import test.Sub4;

pub let mut sub2val = 1;
sub2val = sub2val + 1;

pub class Hoge {
    pub let val:int;
    pub fn func(): int {
        return sub2val;
    }
}

global let sub2globalval = 1;
global fn sub2globalfun(): int {
   return sub2globalval;
}

pub enum enumTestSub {
   val1,
   val2,
   val3
}
pub let testEnum:enumTestSub! = nil;

pub module External require "test.external" {
   pub static let val:int;
   pub static fn func1( val:int );
   pub fn func2( val:int );
}

pub class Test {
   pub enum Hoge {
      val,
   }

   pub fn func() {
      let hoge = Test.Hoge.val;
      if hoge == .val {
         print( hoge );
      }
   }
}

pub class Hoge2 extend (Mapping) {
   pri let val:int {pub};
}

pub alge AlgeTest {
   Val1,
   Val2,
   Val3( int ),
   Val4( int, str, Hoge2 ),
   Val5( AlgeTest ),
}

pub class Test2 extend (Mapping) {
   pri let algetest:AlgeTest {pub};
}

fn check( mess:str, test1:AlgeTest ) {
   match test1 {
      case .Val1 {
         print( mess, test1.$_txt );
      }  
      case .Val2 {
         print( mess, test1.$_txt, 2 );
      }
      case .Val3( x ) {
         print( mess, test1.$_txt, x + 10 );
      }
      case .Val4( x, y, z ) {
         print( mess, test1.$_txt, x + 10, y .. "X", z.$val );
      }
      case .Val5( x ) {
         print( mess, test1.$_txt );
         check( mess, x );
      }
      default {
         print( mess, "default" );
      }
   }
}

fn testMap( algeTest:AlgeTest ) {
   let name = algeTest.$_txt;
   let test = new Test2( algeTest );
   check( name, test.$algetest );

   let map = test._toMap();
   foreach val, key in map {
      foreach val2, key2 in val@@Map<stem,stem> {
         print( key, key2, val2 );
      }  
   }  
   let test2, err = Test2._fromMap(map);
   when! test2 {
      check( name .. "-2", test2.$algetest );
   }  
   else {
      print( "NG", err );
   }  
}

pub macro _test( val:enumTestSub ) {
   print( ,,val.$_txt );
}

fn main() {
   let test = new Test();
   test.func();

   let mut val = Test.Hoge.val;
   val = .val;
   print( val.$_txt );

   testMap( AlgeTest.Val1 );
   testMap( AlgeTest.Val2 );
   testMap( AlgeTest.Val3( 1) );
   testMap( AlgeTest.Val4( 1, "abc", new Hoge2( 10 )) );
   testMap( AlgeTest.Val5( AlgeTest.Val1 ) );

   _test( .val1 );
}

pub class IF {
   pub let val:int;
}

pub form form1( val:int ): int;

pub fn testext(): int, real, str, Map<int,real>,List<int>, int!, real!, str!, Map<int,real>!,List<int>!
{
   return 1, 1.0, "", {}, [], nil, nil, nil, nil, nil;
}

pub macro _MacroTest2(txt:str,val:int) {
   {
      let val2 = "xyz%s%d"(txt,val);
   }
   print( ,,val2, ,,txt, ,,val );
}

pub macro _MacroTest3(val:int) {
   print( "HOGE", ,,val );
}

pub fn DDDfunc( ...<int> ): ...<int> {
   let list = [ ... ];
   return 0, list.unpack();
}

pub fn DDDfunc2( ...<str!> ): ...<str!> {
   let list = [ ... ];
   return "0", list.unpack();
}
